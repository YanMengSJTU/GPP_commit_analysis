diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..187ea46746
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,43 @@
+> We LOVE to help with any issues or bug you have!
+
+> **Questions**: If you have questions about how to use Realm, please ask on [SO](http://stackoverflow.com/questions/ask?tags=realm) - we monitor the Realm tag.
+
+> **Feature Request**: Just fill in the first two sections below.
+
+> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.
+>
+> Thanks for helping us help you :-)
+>
+> Remove this and above before submitting.
+
+#### Goal
+
+> What do you want to achieve?
+
+#### Expected Results
+
+> ?
+
+#### Actual Results
+
+>  E.g. full stack trace with exception
+
+#### Steps & Code to Reproduce
+
+> Describe your current debugging efforts.
+
+#### Code Sample
+
+```java
+
+> Your code here. Bigger samples should ideally be as separate Android Studio project, 
+> in gists/repositories or privately at help@realm.io)
+
+```
+
+#### Version of Realm and tooling
+Realm version(s): ?
+
+Android Studio version: ?
+
+Which Android version and device: ?
diff --git a/.gitignore b/.gitignore
index b8ed128e2b..a72b66b484 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,7 +23,6 @@ core-*
 
 # JNI libs
 realm_version_check.timestamp
-/realm/src/main/jniLibs
 
 # Build artifacts
 *.so
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000000..8937e5d1e5
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,410 @@
+## 0.88.0
+
+* Updated Realm Core to 0.97.0.
+
+### Breaking changes
+
+* Realm has now to be installed as a Gradle plugin.
+* DynamicRealm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
+* DynamicRealm.executeTransaction() now throws IllegalArgumentException instead of silently accepting a null Transaction object.
+* String setters now throw IllegalArgumentException instead of RealmError for invalid surrogates.
+* DynamicRealm.distinct()/distinctAsync() and Realm.distinct()/distinctAsync() now throw IllegalArgumentException instead of UnsupportedOperationException for invalid type or unindexed field.
+* All thread local change listeners are now delayed until the next Looper event instead of being triggered when committing.
+* Removed RealmConfiguration.getSchemaMediator() from public API which was deprecated in 0.86.0. Please use RealmConfiguration.getRealmObjectClasses() to obtain the set of model classes (#1797).
+* Realm.migrateRealm() throws a FileNotFoundException if the Realm file doesn't exist.
+* It is now required to unsubscribe from all Realm RxJava observables in order to fully close the Realm (#2357).
+
+### Deprecated
+
+* Realm.getInstance(Context). Use Realm.getInstance(RealmConfiguration) or Realm.getDefaultInstance() instead.
+* Realm.getTable(Class) which was public because of the old migration API. Use Realm.getSchema() or DynamicRealm.getSchema() instead.
+* Realm.executeTransaction(Transaction, Callback) and replaced it with Realm.executeTransactionAsync(Transaction), Realm.executeTransactionAsync(Transaction, OnSuccess), Realm.executeTransactionAsync(Transaction, OnError) and Realm.executeTransactionAsync(Transaction, OnSuccess, OnError).
+
+### Enhancements
+
+* Support for custom methods, custom logic in accessors, custom accessor names, interface implementation and public fields in Realm objects. (#909)
+* Support to project Lombok. (#502)
+* RealmQuery.isNotEmpty() (#2025).
+* Realm.deleteAll() and RealmList.deleteAllFromRealm() (#1560).
+* RealmQuery.distinct() and RealmResults.distinct() (#1568).
+* RealmQuery.distinctAsync() and RealmResults.distinctAsync() (#2118).
+* Improved .so loading by using [ReLinker](https://github.com/KeepSafe/ReLinker).
+* Improved performance of RealmList#contains() (#897).
+* distinct(...) for Realm, DynamicRealm, RealmQuery, and RealmResults can take multiple parameters (#2284).
+* "realm" and "row" can be used as field name in model classes (#2255).
+* RealmResults.size() now returns Integer.MAX_VALUE when actual size is greater than Integer.MAX_VALUE (#2129).
+* Removed allowBackup from AndroidManifest (#2307).
+
+### Bug fixes
+
+* Error occurring during test and connectedCheck of unit test example (#1934).
+* Bug in jsonExample (#2092).
+* Multiple calls of RealmResults.distinct() causes to return wrong results (#2198).
+* Calling DynamicRealmObject.setList() with RealmList<DynamicRealmObject> (#2368).
+* RealmChangeListeners did not triggering correctly if findFirstAsync() didn't find any object. findFirstAsync() Observables now also correctly call onNext when the query completes in that case (#2200).
+* Setting a null value to trigger RealmChangeListener (#2366).
+* Preventing throwing BadVersionException (#2391).
+
+### Credits
+
+* Thanks to Bill Best (@wmbest2) for snapshot testing.
+* Thanks to Graham Smith (@grahamsmith) for a detailed bug report (#2200).
+
+## 0.87.5
+* Updated Realm Core to 0.96.2.
+  - IllegalStateException won't be thrown anymore in RealmResults.where() if the RealmList which the RealmResults is created on has been deleted. Instead, the RealmResults will be treated as empty forever.
+  - Fixed a bug causing a bad version exception, when using findFirstAsync (#2115).
+
+## 0.87.4
+* Updated Realm Core to 0.96.0.
+  - Fixed bug causing BadVersionException or crashing core when running async queries.
+
+## 0.87.3
+* IllegalArgumentException is now properly thrown when calling Realm.copyFromRealm() with a DynamicRealmObject (#2058).
+* Fixed a message in IllegalArgumentException thrown by the accessors of DynamicRealmObject (#2141).
+* Fixed RealmList not returning DynamicRealmObjects of the correct underlying type (#2143).
+* Fixed potential crash when rolling back removal of classes that reference each other (#1829).
+* Updated Realm Core to 0.95.8.
+  - Fixed a bug where undetected deleted object might lead to seg. fault (#1945).
+  - Better performance when deleting objects (#2015).
+
+## 0.87.2
+* Removed explicit GC call when committing a transaction (#1925).
+* Fixed a bug when RealmObjectSchema.addField() was called with the PRIMARY_KEY modifier, the field was not set as a required field (#2001).
+* Fixed a bug which could throw a ConcurrentModificationException in RealmObject's or RealmResults' change listener (#1970).
+* Fixed RealmList.set() so it now correctly returns the old element instead of the new (#2044).
+* Fixed the deployment of source and javadoc jars (#1971).
+
+## 0.87.1
+* Upgraded to NDK R10e. Using gcc 4.9 for all architectures.
+* Updated Realm Core to 0.95.6
+  - Fixed a bug where an async query can be copied incomplete in rare cases (#1717).
+* Fixed potential memory leak when using async query.
+* Added a check to prevent removing a RealmChangeListener from a non-Looper thread (#1962). (Thank you @hohnamkung)
+
+## 0.87.0
+* Added Realm.asObservable(), RealmResults.asObservable(), RealmObject.asObservable(), DynamicRealm.asObservable() and DynamicRealmObject.asObservable().
+* Added RealmConfiguration.Builder.rxFactory() and RxObservableFactory for custom RxJava observable factory classes.
+* Added Realm.copyFromRealm() for creating detached copies of Realm objects (#931).
+* Added RealmObjectSchema.getFieldType() (#1883).
+* Added unitTestExample to showcase unit and instrumentation tests. Examples include jUnit3, jUnit4, Espresso, Robolectric, and MPowermock usage with Realm (#1440).
+* Added support for ISO8601 based dates for JSON import. If JSON dates are invalid a RealmException will be thrown (#1213).
+* Added APK splits to gridViewExample (#1834).
+
+## 0.86.1
+* Improved the performance of removing objects (RealmResults.clear() and RealmResults.remove()).
+* Updated Realm Core to 0.95.5.
+* Updated ProGuard configuration (#1904).
+* Fixed a bug where RealmQuery.findFirst() returned a wrong result if the RealmQuery had been created from a RealmResults.where() (#1905).
+* Fixed a bug causing DynamicRealmObject.getObject()/setObject() to use the wrong class (#1912).
+* Fixed a bug which could cause a crash when closing Realm instances in change listeners (#1900).
+* Fixed a crash occurring during update of multiple async queries (#1895).
+* Fixed listeners not triggered for RealmObject & RealmResults created using copy or create methods (#1884).
+* Fixed RealmChangeListener never called inside RealmResults (#1894).
+* Fixed crash when calling clear on a RealmList (#1886).
+
+## 0.86.0
+* BREAKING CHANGE: The Migration API has been replaced with a new API.
+* BREAKING CHANGE: RealmResults.SORT_ORDER_ASCENDING and RealmResults.SORT_ORDER_DESCENDING constants have been replaced by Sort.ASCENDING and Sort.DESCENDING enums.
+* BREAKING CHANGE: RealmQuery.CASE_SENSITIVE and RealmQuery.CASE_INSENSITIVE constants have been replaced by Case.SENSITIVE and Case.INSENSITIVE enums.
+* BREAKING CHANGE: Realm.addChangeListener, RealmObject.addChangeListener and RealmResults.addChangeListener hold a strong reference to the listener, you should unregister the listener to avoid memory leaks.
+* BREAKING CHANGE: Removed deprecated methods RealmQuery.minimum{Int,Float,Double}, RealmQuery.maximum{Int,Float,Double}, RealmQuery.sum{Int,Float,Double} and RealmQuery.average{Int,Float,Double}. Use RealmQuery.min(), RealmQuery.max(), RealmQuery.sum() and RealmQuery.average() instead.
+* BREAKING CHANGE: Removed RealmConfiguration.getSchemaMediator() which is public by mistake. And RealmConfiguration.getRealmObjectClasses() is added as an alternative in order to obtain the set of model classes (#1797).
+* BREAKING CHANGE: Realm.addChangeListener, RealmObject.addChangeListener and RealmResults.addChangeListener will throw an IllegalStateException when invoked on a non-Looper thread. This is to prevent registering listeners that will not be invoked.
+* BREAKING CHANGE: trying to access a property on an unloaded RealmObject obtained asynchronously will throw an IllegalStateException
+* Added new Dynamic API using DynamicRealm and DynamicRealmObject.
+* Added Realm.getSchema() and DynamicRealm.getSchema().
+* Realm.createOrUpdateObjectFromJson() now works correctly if the RealmObject class contains a primary key (#1777).
+* Realm.compactRealm() doesn't throw an exception if the Realm file is opened. It just returns false instead.
+* Updated Realm Core to 0.95.3.
+  - Fixed a bug where RealmQuery.average(String) returned a wrong value for a nullable Long/Integer/Short/Byte field (#1803).
+  - Fixed a bug where RealmQuery.average(String) wrongly counted the null value for average calculation (#1854).
+
+## 0.85.1
+* Fixed a bug which could corrupt primary key information when updating from a Realm version <= 0.84.1 (#1775).
+
+## 0.85.0
+* BREAKING CHANGE: Removed RealmEncryptionNotSupportedException since the encryption implementation changed in Realm's underlying storage engine. Encryption is now supported on all devices.
+* BREAKING CHANGE: Realm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
+* BREAKING CHANGE: RealmQuery.isNull() and RealmQuery.isNotNull() now throw IllegalArgumentException instead of RealmError if the fieldname is a linked field and the last element is a link (#1693).
+* Added Realm.isEmpty().
+* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (standalone, removed, closed, from different Realm) object (#1749).
+* Attempting to refresh a Realm while a transaction is in process will now throw an IllegalStateException (#1712).
+* The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle)
+* Updated Realm Core to 0.95.
+  - Removed reliance on POSIX signals when using encryption.
+
+## 0.84.2
+* Fixed a bug making it impossible to convert a field to become required during a migration (#1695).
+* Fixed a bug making it impossible to read Realms created using primary keys and created by iOS (#1703).
+* Fixed some memory leaks when an Exception is thrown (#1730).
+* Fixed a memory leak when using relationships (#1285).
+* Fixed a bug causing cached column indices to be cleared too soon (#1732).
+
+## 0.84.1
+* Updated Realm Core to 0.94.4.
+  - Fixed a bug that could cause a crash when running the same query multiple times.
+* Updated ProGuard configuration. See [documentation](https://realm.io/docs/java/latest/#proguard) for more details.
+* Updated Kotlin example to use 1.0.0-beta.
+* Fixed warnings reported by "lint -Xlint:all" (#1644).
+* Fixed a bug where simultaneous opening and closing a Realm from different threads might result in a NullPointerException (#1646).
+* Fixed a bug which made it possible to externally modify the encryption key in a RealmConfiguration (#1678).
+
+## 0.84.0
+* Added support for async queries and transactions.
+* Added support for parsing JSON Dates with timezone information. (Thank you @LateralKevin)
+* Added RealmQuery.isEmpty().
+* Added Realm.isClosed() method.
+* Added Realm.distinct() method.
+* Added RealmQuery.isValid(), RealmResults.isValid() and RealmList.isValid(). Each method checks whether the instance is still valid to use or not(for example, the Realm has been closed or any parent object has been removed).
+* Added Realm.isInTransaction() method.
+* Updated Realm Core to version 0.94.3.
+  - Fallback for mremap() now work correctly on BlackBerry devices.
+* Following methods in managed RealmList now throw IllegalStateException instead of native crash when RealmList.isValid() returns false: add(int,RealmObject), add(RealmObject)
+* Following methods in managed RealmList now throw IllegalStateException instead of ArrayIndexOutOfBoundsException when RealmList.isValid() returns false: set(int,RealmObject), move(int,int), remove(int), get(int)
+* Following methods in managed RealmList now throw IllegalStateException instead of returning 0/null when RealmList.isValid() returns false: clear(), removeAll(Collection), remove(RealmObject), first(), last(), size(), where()
+* RealmPrimaryKeyConstraintException is now thrown instead of RealmException if two objects with same primary key are inserted.
+* IllegalStateException is now thrown when calling Realm's clear(), RealmResults's remove(), removeLast(), clear() or RealmObject's removeFromRealm() from an incorrect thread.
+* Fixed a bug affecting RealmConfiguration.equals().
+* Fixed a bug in RealmQuery.isNotNull() which produced wrong results for binary data.
+* Fixed a bug in RealmQuery.isNull() and RealmQuery.isNotNull() which validated the query prematurely.
+* Fixed a bug where closed Realms were trying to refresh themselves resulting in a NullPointerException.
+* Fixed a bug that made it possible to migrate open Realms, which could cause undefined behavior when querying, reading or writing data.
+* Fixed a bug causing column indices to be wrong for some edge cases. See #1611 for details.
+
+## 0.83.1
+* Updated Realm Core to version 0.94.1.
+  - Fixed a bug when using Realm.compactRealm() which could make it impossible to open the Realm file again.
+  - Fixed a bug, so isNull link queries now always return true if any part is null.
+
+## 0.83
+* BREAKING CHANGE: Database file format update. The Realm file created by this version cannot be used by previous versions of Realm.
+* BREAKING CHANGE: Removed deprecated methods and constructors from the Realm class.
+* BREAKING CHANGE: Introduced boxed types Boolean, Byte, Short, Integer, Long, Float and Double. Added null support. Introduced annotation @Required to indicate a field is not nullable. String, Date and byte[] became nullable by default which means a RealmMigrationNeededException will be thrown if an previous version of a Realm file is opened.
+* Deprecated methods: RealmQuery.minimum{Int,Float,Double}, RealmQuery.maximum{Int,Float,Double}. Use RealmQuery.min() and RealmQuery.max() instead.
+* Added support for x86_64.
+* Fixed an issue where opening the same Realm file on two Looper threads could potentially lead to an IllegalStateException being thrown.
+* Fixed an issue preventing the call of listeners on refresh().
+* Opening a Realm file from one thread will no longer be blocked by a transaction from another thread.
+* Range restrictions of Date fields have been removed. Date fields now accepts any value. Milliseconds are still removed.
+
+## 0.82.2
+* Fixed a bug which might cause failure when loading the native library.
+* Fixed a bug which might trigger a timeout in Context.finalize().
+* Fixed a bug which might cause RealmObject.isValid() to throw an exception if the object is deleted.
+* Updated Realm core to version 0.89.9
+  - Fixed a potential stack overflow issue which might cause a crash when encryption was used.
+  - Embedded crypto functions into Realm dynamic lib to avoid random issues on some devices.
+  - Throw RealmEncryptionNotSupportedException if the device doesn't support Realm encryption. At least one device type (HTC One X) contains system bugs that prevents Realm's encryption from functioning properly. This is now detected, and an exception is thrown when trying to open/create an encrypted Realm file. It's up to the application to catch this and decide if it's OK to proceed without encryption instead.
+
+## 0.82.1
+* Fixed a bug where using the wrong encryption key first caused the right key to be seen as invalid.
+* Fixed a bug where String fields were ignored when updating objects from JSON with null values.
+* Fixed a bug when calling System.exit(0), the process might hang.
+
+## 0.82
+* BREAKING CHANGE: Fields with annotation @PrimaryKey are indexed automatically now. Older schemas require a migration.
+* RealmConfiguration.setModules() now accept ignore null values which Realm.getDefaultModule() might return.
+* Trying to access a deleted Realm object throw throws a proper IllegalStateException.
+* Added in-memory Realm support.
+* Closing realm on another thread different from where it was created now throws an exception.
+* Realm will now throw a RealmError when Realm's underlying storage engine encounters an unrecoverable error.
+* @Index annotation can also be applied to byte/short/int/long/boolean/Date now.
+* Fixed a bug where RealmQuery objects are prematurely garbage collected.
+* Removed RealmQuery.between() for link queries.
+
+## 0.81.1
+* Fixed memory leak causing Realm to never release Realm objects.
+
+## 0.81
+* Introduced RealmModules for working with custom schemas in libraries and apps.
+* Introduced Realm.getDefaultInstance(), Realm.setDefaultInstance(RealmConfiguration) and Realm.getInstance(RealmConfiguration).
+* Deprecated most constructors. They have been been replaced by Realm.getInstance(RealmConfiguration) and Realm.getDefaultInstance().
+* Deprecated Realm.migrateRealmAtPath(). It has been replaced by Realm.migrateRealm(RealmConfiguration).
+* Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
+* Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
+* RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
+* Realm now works with Kotlin (M12+). (Thank you @cypressious)
+* Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
+* Added a check to give a better error message when null is used as value for a primary key.
+* Fixed unchecked cast warnings when building with Realm.
+* Cleaned up examples (remove old test project).
+* Added checking for missing generic type in RealmList fields in annotation processor.
+
+## 0.80.3
+* Calling Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+* Fixed a bug making it impossible to open Realms created by Realm-Cocoa if a model had a primary key defined.
+* Trying to using Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+* RealmChangedListener now also gets called on the same thread that did the commit.
+* Fixed bug where Realm.createOrUpdateWithJson() reset Date and Binary data to default values if not found in the JSON output.
+* Fixed a memory leak when using RealmBaseAdapter.
+* RealmBaseAdapter now allow RealmResults to be null. (Thanks @zaki50)
+* Fixed a bug where a change to a model class (`RealmList<A>` to `RealmList<B>`) would not throw a RealmMigrationNeededException.
+* Fixed a bug where setting multiple RealmLists didn't remove the previously added objects.
+* Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (Thanks @beeender)
+* Fixed duplicated listeners in the same realm instance. Trying to add duplicated listeners is ignored now. (Thanks @beeender)
+
+## 0.80.2
+* Trying to use Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+* RealmMigrationNeedException can now return the path to the Realm that needs to be migrated.
+* Fixed bug where creating a Realm instance with a hashcode collision no longer returned the wrong Realm instance.
+* Updated Realm Core to version 0.89.2
+  - fixed bug causing a crash when opening an encrypted Realm file on ARM64 devices.
+
+## 0.80.1
+* Realm.createOrUpdateWithJson() no longer resets fields to their default value if they are not found in the JSON input.
+* Realm.compactRealmFile() now uses Realm Core's compact() method which is more failure resilient.
+* Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
+* The ARM64 binary is now properly a part of the Eclipse distribution package.
+* A RealmMigrationExceptionNeeded is now properly thrown if @Index and @PrimaryKey are not set correctly during a migration.
+* Fixed bug causing Realms to be cached even though they failed to open correctly.
+* Added Realm.deleteRealmFile(File) method.
+* Fixed bug causing queries to fail if multiple Realms has different field ordering.
+* Fixed bug when using Realm.copyToRealm() with a primary key could crash if default value was already used in the Realm.
+* Updated Realm Core to version 0.89.0
+  - Improved performance for sorting RealmResults.
+  - Improved performance for refreshing a Realm after inserting or modifying strings or binary data.
+  - Fixed bug causing incorrect result when querying indexed fields.
+  - Fixed bug causing corruption of string index when deleting an object where there are duplicate values for the indexed field.
+  - Fixed bug causing a crash after compacting the Realm file.
+* Added RealmQuery.isNull() and RealmQuery.isNotNull() for querying relationships.
+* Fixed a potential NPE in the RealmList constructor.
+
+## 0.80
+* Queries on relationships can be case sensitive.
+* Fixed bug when importing JSONObjects containing NULL values.
+* Fixed crash when trying to remove last element of a RealmList.
+* Fixed bug crashing annotation processor when using "name" in model classes for RealmObject references
+* Fixed problem occurring when opening an encrypted Realm with two different instances of the same key.
+* Version checker no longer reports that updates are available when latest version is used.
+* Added support for static fields in RealmObjects.
+* Realm.writeEncryptedCopyTo() has been reenabled.
+
+## 0.79.1
+* copyToRealm() no longer crashes on cyclic data structures.
+* Fixed potential crash when using copyToRealmOrUpdate with an object graph containing a mix of elements with and without primary keys.
+
+## 0.79
+* Added support for ARM64.
+* Added RealmQuery.not() to negate a query condition.
+* Added copyToRealmOrUpdate() and createOrUpdateFromJson() methods, that works for models with primary keys.
+* Made the native libraries much smaller. Arm went from 1.8MB to 800KB.
+* Better error reporting when trying to create or open a Realm file fails.
+* Improved error reporting in case of missing accessors in model classes.
+* Re-enabled RealmResults.remove(index) and RealmResults.removeLast().
+* Primary keys are now supported through the @PrimaryKey annotation.
+* Fixed error when instantiating a Realm with the wrong key.
+* Throw an exception if deleteRealmFile() is called when there is an open instance of the Realm.
+* Made migrations and compression methods synchronised.
+* Removed methods deprecated in 0.76. Now Realm.allObjectsSorted() and RealmQuery.findAllSorted() need to be used instead.
+* Reimplemented Realm.allObjectSorted() for better performance.
+
+## 0.78
+* Added proper support for encryption. Encryption support is now included by default. Keys are now 64 bytes long.
+* Added support to write an encrypted copy of a Realm.
+* Realm no longer incorrectly warns that an instance has been closed too many times.
+* Realm now shows a log warning if an instance is being finalized without being closed.
+* Fixed bug causing Realms to be cached during a RealmMigration resulting in invalid realms being returned from Realm.getInstance().
+* Updated core to 0.88.
+
+## 0.77
+* Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
+* Added more logging capabilities at the JNI level.
+* Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
+* Added support for standalone objects and custom constructors.
+* Added more precise imports in proxy classes to avoid ambiguous references.
+* Added support for executing a transaction with a closure using Realm.executeTransaction().
+* Added RealmObject.isValid() to test if an object is still accessible.
+* RealmResults.sort() now has better error reporting.
+* Fixed bug when doing queries on the elements of a RealmList, ie. like Realm.where(Foo.class).getBars().where().equalTo("name").
+* Fixed bug causing refresh() to be called on background threads with closed Realms.
+* Fixed bug where calling Realm.close() too many times could result in Realm not getting closed at all. This now triggers a log warning.
+* Throw NoSuchMethodError when RealmResults.indexOf() is called, since it's not implemented yet.
+* Improved handling of empty model classes in the annotation processor
+* Removed deprecated static constructors.
+* Introduced new static constructors based on File instead of Context, allowing to save Realm files in custom locations.
+* RealmList.remove() now properly returns the removed object.
+* Calling realm.close() no longer prevent updates to other open realm instances on the same thread.
+
+## 0.76.0
+* RealmObjects can now be imported using JSON.
+* Gradle wrapper updated to support Android Studio 1.0.
+* Fixed bug in RealmObject.equals() so it now correctly compares two objects from the same Realm.
+* Fixed bug in Realm crashing for receiving notifications after close().
+* Realm class is now marked as final.
+* Replaced concurrency example with a better thread example.
+* Allowed to add/remove RealmChangeListeners in RealmChangeListeners.
+* Upgraded to core 0.87.0 (encryption support, API changes).
+* Close the Realm instance after migrations.
+* Added a check to deny the writing of objects outside of a transaction.
+
+## 0.75.1 (03 December 2014)
+* Changed sort to be an in-place method.
+* Renamed SORT_ORDER_DECENDING to SORT_ORDER_DESCENDING.
+* Added sorting functionality to allObjects() and findAll().
+* Fixed bug when querying a date column with equalTo(), it would act as lessThan()
+
+## 0.75.0 (28 Nov 2014)
+* Realm now implements Closeable, allowing better cleanup of native resources.
+* Added writeCopyTo() and compactRealmFile() to write and compact a Realm to a new file.
+* RealmObject.toString(), equals() and hashCode() now support models with cyclic references.
+* RealmResults.iterator() and listIterator() now correctly iterates the results when using remove().
+* Bug fixed in Exception text when field names was not matching the database.
+* Bug fixed so Realm no longer throws an Exception when removing the last object.
+* Bug fixed in RealmResults which prevented sub-querying.
+* The Date type does not support millisecond resolution, and dates before 1901-12-13 and dates after 2038-01-19 are not supported on 32 bit systems.
+* Fixed bug so Realm no longer throws an Exception when removing the last object.
+* Fixed bug in RealmResults which prevented sub-querying.
+
+## 0.74.0 (19 Nov 2014)
+* Added support for more field/accessors naming conventions.
+* Added case sensitive versions of string comparison operators equalTo and notEqualTo.
+* Added where() to RealmList to initiate queries.
+* Added verification of fields names in queries with links.
+* Added exception for queries with invalid field name.
+* Allow static methods in model classes.
+* An exception will now be thrown if you try to move Realm, RealmResults or RealmObject between threads.
+* Fixed a bug in the calculation of the maximum of date field in a RealmResults.
+* Updated core to 0.86.0, fixing a bug in cancelling an empty transaction, and major query speedups with floats/doubles.
+* Consistent handling of UTF-8 strings.
+* removeFromRealm() now calls moveLastOver() which is faster and more reliable when deleting multiple objects.
+
+## 0.73.1 (05 Nov 2014)
+* Fixed a bug that would send infinite notifications in some instances.
+
+## 0.73.0 (04 Nov 2014)
+* Fixed a bug not allowing queries with more than 1024 conditions.
+* Rewritten the notification system. The API did not change but it's now much more reliable.
+* Added support for switching auto-refresh on and off (Realm.setAutoRefresh).
+* Added RealmBaseAdapter and an example using it.
+* Added deleteFromRealm() method to RealmObject.
+
+## 0.72.0 (27 Oct 2014)
+* Extended sorting support to more types: boolean, byte, short, int, long, float, double, Date, and String fields are now supported.
+* Better support for Java 7 and 8 in the annotations processor.
+* Better support for the Eclipse annotations processor.
+* Added Eclipse support to the distribution folder.
+* Added Realm.cancelTransaction() to cancel/abort/rollback a transaction.
+* Added support for link queries in the form realm.where(Owner.class).equalTo("cat.age", 12).findAll().
+* Faster implementation of RealmQuery.findFirst().
+* Upgraded core to 0.85.1 (deep copying of strings in queries; preparation for link queries).
+
+## 0.71.0 (07 Oct 2014)
+* Simplified the release artifact to a single Jar file.
+* Added support for Eclipse.
+* Added support for deploying to Maven.
+* Throw exception if nested transactions are used (it's not allowed).
+* Javadoc updated.
+* Fixed [bug in RealmResults](https://github.com/realm/realm-java/issues/453).
+* New annotation @Index to add search index to a field (currently only supporting String fields).
+* Made the annotations processor more verbose and strict.
+* Added RealmQuery.count() method.
+* Added a new example about concurrency.
+* Upgraded to core 0.84.0.
+
+## 0.70.1 (30 Sep 2014)
+* Enabled unit testing for the realm project.
+* Fixed handling of camel-cased field names.
+
+## 0.70.0 (29 Sep 2014)
+* This is the first public beta release.
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index c0ed464344..ae1a793a9e 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -25,8 +25,160 @@ Realm welcomes all contributions! The only requirement we have is that, like man
 
 [Please submit your CLA electronically using our Google form](https://docs.google.com/forms/d/1bVp-Wp5nmNFz9Nx-ngTmYBVWVdwTyKj4T0WtfVm0Ozs/viewform?fbzx=4154977190905366979) so we can accept your submissions. The GitHub username you file there will need to match that of your Pull Requests. If you have any questions or cannot file the CLA electronically, you can email <help@realm.io>.
 
-## Unit tests
-All PR's must be accompanied by related unit tests.
+## Repository Guidelines
+
+### Code Style
 
-## Code style
 While we havn't described our code style yet, please just follow the existing style you see in the files you change.
+
+### Unit Tests
+
+All PR's must be accompanied by related unit tests. All bug fixes must have a unit test proving that the bug is fixed.
+You can use `./realm/gradlew connectedCheck createDebugCoverageReport` to generate a coverage report to check for 
+missing unit test coverage. The aim is 100% code coverage.
+
+When writing unit tests, use the following guide lines:
+
+1) Unit tests must be written using JUnit4.
+
+2) All tests for a class should be grouped in a class called `<className>Tests`, unless the functionality is cross-
+   cutting like [`RxJavaTests`](https://github.com/realm/realm-java/blob/master/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java) 
+   or [`RealmAsyncQueryTests`](https://github.com/realm/realm-java/blob/master/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java).
+
+3) Test methods should use camelCase and underscore `_` between logical sections to increase method name readability. 
+   Methods should ideally start with the name of the method being tested. Patterns like: `<methodName>_<description>`, 
+   `<methodName>_<param>_<description>` or `<description>` are encouraged.
+   
+4) All unit tests creating Realms must do so using the [`TestRealmConfigurationFactory`](https://github.com/realm/realm-java/blob/master/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java) 
+   or [`RunInLooperThread`](https://github.com/realm/realm-java/blob/master/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java) 
+   test rules. This ensures that all Realms are properly closed and deleted between each test.
+
+5) Use the `@RunInLooperThread` rule for any test that depends on Realms notification system. 
+
+6) Input-parameters should be boundary tested. Especially `Null/NotNull`, but also the state of Realm objects like
+   standalone objects, deleted objects, objects from other threads.
+
+7) Unit tests are not required to only have 1 test. It is acceptable to combine multiple tests into one unit test, but
+   if it fails, it should be clear why it failed. E.g. you can group related tests with the same setup like negative 
+   tests. If you do so, make sure to separate each "subtest" with a comment stating what you test.
+
+8) Use only `@Test(expected = xxx.class)` if the test case contains one line. If the test contains multiple 
+   lines and it is the last line that is tested, use the `ExceptedException` rule instead. In all other cases, use 
+   the following pattern:
+   
+    try {
+      somethingThatThrowsIllegalArgument();   
+    } catch (IllegalArgumentException ignored) {
+    }
+
+9) Use comments to make the intent of the unit test easily understandable at a glance. A simple one line comment is 
+   often easier to read `thanALongCamelCasedSentenceThatAttemptsToDescribeWhatHappens`. Describe the test steps inside 
+   the method, if it's not glaringly obvious.
+
+This is an example of how a unit test class could look like:
+
+    @RunWith(AndroidJUnit4.class)
+    public class RealmTests {
+    
+      @Rule
+      public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    
+      @Rule
+      public final RunInLooperThread looperThread = new RunInLooperThread();
+    
+      private Realm realm;   
+    
+      @Before
+      public void setUp() {
+         RealmConfiguration config = configFactory.createConfiguration();
+         realm = Realm.getInstance(config);
+      }
+      
+      @After
+      public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }  
+      }
+    
+      @Test(expected = IllegalStateException.class)
+      public void createObject_outsideTransaction() {
+        realm.createObject(Foo.class);
+      }
+    
+      @Test
+      public void createObject_illegalInput {
+        // Class not part of the schema
+        try {
+          realm.createObject(Foo.class);    
+        } catch (IllegalArgumentException ignored) {
+        }
+    
+        // Null class
+        try {
+            realm.createObject(null);    
+        } catch (IllegalArgumentException ignored) {
+        }
+      }
+      
+      @Test
+      @RunTestInLooperThread
+      public void addChangeListener_notifiedOnLocalCommit() {
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assert(1, realm.allObjects(Foo.class).size());
+                looperThread.testComplete();
+            }
+        });
+    
+        realm.beginTransaction();
+        realm.createObject(Foo.class);
+        realm.commitTransaction();
+      }
+    }
+  
+### Javadoc
+
+All public classes and methods must have Javadoc describing their purpose.
+
+```java
+/**
+ * Checks if given field is equal to the provided value. 
+ *
+ * <pre>
+ * {@code
+ *   // A multi-line code sample should be formatted like this.
+ *   // Please wrap the code element in a <pre> tag.
+ * }
+ * </pre>
+ *
+ * @param fieldName the field to compare.
+ * @param fieldValue the value to compare with.
+ * @param caseSensitive if {@code true}, substring matching is case sensitive. Setting this to {@code false} works for English locale characters only.
+ * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+ *                      locale characters.
+ * @return the query object.
+ * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+ * @throws IllegalArgumentException if field name doesn't exists, it doesn't contain a list of links or the type
+ * of the object represented by the DynamicRealmObject doesn't match.
+ * @deprecated Please use {@link #average(String)} instead.
+ * @see #endGroup()
+ */
+public RealmQuery<E> equalTo(String fieldName, String fieldValue, boolean caseSensitive) {
+  // ...
+}
+```
+
+* Method descriptions begin with a verb phrase, e.g. "Checks" instead of "Check". 
+* Capitalize the first letter of the method and @deprecated descriptions. Everything else starts with lower case.
+* Empty line between method description and the rest.
+* End all descriptions with a period `.` (except @see).
+* Reference other Realm classes using `{@link ...}`.
+* Wrap Java values in `{@code ...}`.
+* @throws description must start with "if".
+* Never list generic exceptions like `RuntimeException`, `Exception` or `Error`. Always reference the specific error.
+* Line-length maximum is 120 chars. Parameter descriptions that go above this, should be split into multiple lines and indented. Otherwise do not use indentation (contrary to Oracle guidelines).
+
+Above is based on the official guidelines from Oracle regarding Javadoc: http://www.oracle.com/technetwork/articles/java/index-137868.html
+
diff --git a/LICENSE b/LICENSE
index 48be149531..62e2f9e364 100644
--- a/LICENSE
+++ b/LICENSE
@@ -255,15 +255,15 @@ EXPORT COMPLIANCE
 You understand that the Software may contain cryptographic functions that may be
 subject to export restrictions, and you represent and warrant that you are not
 located in a country that is subject to United States export restriction or embargo,
-including Cuba, Iran, North Korea, Sudan, or Syria, and that you are not on the
-Department of Commerce list of Denied Persons, Unverified Parties, or affiliated
-with a Restricted Entity.
+including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
+are not on the Department of Commerce list of Denied Persons, Unverified Parties,
+or affiliated with a Restricted Entity.
 
 You agree to comply with all export, re-export and import restrictions and
 regulations of the Department of Commerce or other agency or authority of the
 United States or other applicable countries. You also agree not to transfer, or
 authorize the transfer of, directly or indirectly, the Software to any prohibited
-country, including Cuba, Iran, North Korea, Sudan, or Syria, or to any person or
-organization on or affiliated with the Department of Commerce lists of Denied
-Persons, Unverified Parties or Restricted Entities, or otherwise in violation of any
-such restrictions or regulations.
+country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
+or to any person or organization on or affiliated with the Department of
+Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
+otherwise in violation of any such restrictions or regulations.
diff --git a/README.md b/README.md
index acb0a06119..b870db5df7 100644
--- a/README.md
+++ b/README.md
@@ -24,22 +24,32 @@ The API reference is located at [realm.io/docs/java/api](http://realm.io/docs/ja
 - **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We activtely monitor & answer questions on SO!
 - **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
 - **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
-- **Want to ask in-depth questions?** [Join our online office hours](https://attendee.gotowebinar.com/rt/1182038037080364033). We host these once a month, and you can join via chat, audio call, or video call.
 - Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
 
 ## Using Snapshots
 
-If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [JFrog](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-android/)
+If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [OJO](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-android/)
 
+```gradle
+buildscript {
     repositories {
         maven {
             url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
         }
     }
-
     dependencies {
-      compile 'io.realm:realm-android:0.80.3-SNAPSHOT'
+        classpath "io.realm:realm-gradle-plugin:<version>-SNAPSHOT"
+    }
+}
+
+repositories {
+    maven {
+        url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
     }
+}
+```
+
+See [version.txt](version.txt) for the latest version number.
 
 ## Building Realm
 
@@ -47,31 +57,79 @@ In case you don't want to use the precompiled version, you can build Realm yours
 
 Prerequisites:
 
-* Make sure `make` is available in your `$PATH`
-* Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
-* Download & install the Android SDK, **Android 4.4W (API 20)** (for example through Android Studio’s **Android SDK Manager**)
-* _Also_ download & install the Android SDK, **Android 4.4.2 (API 19)** (for example through Android Studio’s **Android SDK Manager**)
-* Download the **Android NDK (= r10d)**. For example, on Mac OS you can do this with [Homebrew](http://brew.sh) with `brew install android-ndk`.
-* Add a `local.properties` file at the root of this folder with the correct paths for the Android SDK and NDK, for example:
+ * Make sure `make` is available in your `$PATH`
+ * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
+ * Download & install the Android SDK, **Android 4.4.2 (API 19)**, **Android 4.4W (API 20)** and **Android 5.0 (API 21)** (for example through Android Studio’s **Android SDK Manager**)
+ * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
+ * Or you can use [Hombrew](https://github.com/Homebrew/homebrew) to install Android NDK for Mac:
+
+    ```
+    brew install android-ndk
+    ```
+
+ * Add two environment variables to your profile:
+
+    ```
+    export ANDROID_HOME=~/Library/Android/sdk
+    export NDK_HOME=/usr/local/Cellar/android-ndk/r10e
+    ```
+
+ * If you are using OS X, you'd be better to add following lines to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see those environment variables.
 
     ```
-    sdk.dir=/Applications/Android Studio.app/sdk
-    ndk.dir=/usr/local/Cellar/android-ndk/r10d
+    launchctl setenv ANDROID_HOME "$ANDROID_HOME"
+    launchctl setenv NDK_HOME "$NDK_HOME"
     ```
 
+ * And if you'd like to specify the location to store the archives of Realm's core, set `REALM_CORE_DOWNLOAD_DIR` environment variable. It enables you to keep core's archive when executing `git clean -xfd`.
+
+   ```
+   export REALM_CORE_DOWNLOAD_DIR=~/.realmCore
+   ```
+
+   OS X users should also add following line to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see this environment variable..
+
+   ```
+   launchctl setenv REALM_CORE_DOWNLOAD_DIR "$REALM_CORE_DOWNLOAD_DIR"
+   ```
+
 Once you have completed all the pre-requisites building Realm is done with a simple command
 
-    ./gradlew androidJar
+```
+./gradlew assemble
+```
+
+That command will generate:
 
-That command will generate the .jar file containing the Realm runtime and the annotation processor. You will find it in realm/build/libs.
+ * a jar file for the Realm Gradle plugin
+ * an aar file for the Realm library
+ * a jar file for the annotations
+ * a jar file for the annotations processor
 
 ### Other Commands
 
- * `./gradlew realm:javadocRelease` will generate the Javadocs
- * `./gradlew realm:connectedCheck` will run the tests on a connected Android device
+ * `./gradlew tasks` will show all the available tasks
+ * `./gradlew javadoc` will generate the Javadocs
+ * `./gradlew monkeyExamples` will run the monkey tests on all the examples
+ * `./gradlew installRealmJava` will install the Realm library and plugin to mavenLocal()
+ * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This saves recompilation time a lot.
 
-Generating the Javadoc using the command above will report a failure (1 error, 30+ warnings). The Javadoc is generated, and we will fix 
-`realm/build.gradle` in the near future.
+Generating the Javadoc using the command above will report a large number of warnings. The Javadoc is generated, and we will fix the issue in the near future.
+
+### Gotchas
+
+The repository is organized in six Gradle projects:
+
+ * `realm`: it contains the actual library (including the JNI layer) and the annotations processor.
+ * `realm-annotations`: it contains the annotations defined by Realm.
+ * `realm-transformer`: it contains the bytecode transformer.
+ * `gradle-plugin`: it contains the Gradle plugin.
+ * `examples`: it contains the example projects. This project directly depends on `gradle-plugin` which adds a dependency to the artifacts produced by `realm`.
+ * The root folder is another Gradle project and all it does is orchestrating the other jobs
+
+This means that `./gradlew clean` and `./gradlew cleanExamples` will fail if `assembleExamples` has not been executed first.
+Note that IntelliJ [does not support multiple projects in the same window](https://youtrack.jetbrains.com/issue/IDEABKL-6118#)
+so each sub-project must be opened in its own window.
 
 ## Contributing
 
@@ -79,9 +137,13 @@ See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 
 ## License
 
-Realm Java is published under the Apache 2.0 license.  
+Realm Java is published under the Apache 2.0 license.
 The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/java/#faq).
 
+**This product is not being made available to any person located in Cuba, Iran,
+North Korea, Sudan, Syria or the Crimea region, or to any other person that is
+not eligible to receive the product under U.S. law.**
+
 ## Feedback
 
 **_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm), announce your app on [our mailing-list](https://groups.google.com/forum/#!forum/realm-java), or email [help@realm.io](mailto:help@realm.io) to let us know about it!_**
diff --git a/build.gradle b/build.gradle
index 0ca1d69da1..654c3174c0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,22 +3,337 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.3'
-        classpath 'de.undercouch:gradle-download-task:1.0'
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
+        classpath 'ch.netzwerg:gradle-release-plugin:1.2.0'
     }
 }
 
-allprojects {
-  apply plugin: 'android-sdk-manager'
+apply plugin: 'ch.netzwerg.release'
 
-  group = 'io.realm'
-  version = new File("${rootDir}/version.txt").text.trim();
-  repositories {
-    jcenter()
-  }
+def currentVersion = file("${projectDir}/version.txt").text.trim();
+
+def props = new Properties()
+props.load(new FileInputStream("${rootDir}/realm.properties"))
+props.each { key, val ->
+    project.set(key, val)
+}
+
+task assembleAnnotations(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble the Realm annotations'
+    buildFile = file('realm-annotations/build.gradle')
+    tasks = ['assemble']
+}
+
+task installAnnotations(type:GradleBuild) {
+    group = 'Install'
+    description = 'Install the jar realm-annotations into mavenLocal()'
+    buildFile = file('realm-annotations/build.gradle')
+    tasks = ['install']
+}
+
+task assembleTransformer(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble the Realm transformer'
+    dependsOn installAnnotations
+    buildFile = file('realm-transformer/build.gradle')
+    tasks = ['assemble']
+}
+
+task installTransformer(type:GradleBuild) {
+    group = 'Install'
+    description = 'Install the jar realm-transformer into mavenLocal()'
+    dependsOn installAnnotations
+    buildFile = file('realm-transformer/build.gradle')
+    tasks = ['install']
+}
+
+task assembleRealm(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble the Realm project'
+    dependsOn installAnnotations
+    dependsOn installTransformer
+    buildFile = file('realm/build.gradle')
+    tasks = ['assemble', 'javadocJar', 'sourcesJar']
+}
+
+task check(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the JVM tests and checks Realm project'
+    buildFile = file('realm/build.gradle')
+    tasks = ['check']
+}
+
+task connectedCheck(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the Android unit tests of the Realm project'
+    dependsOn installTransformer
+    buildFile = file('realm/build.gradle')
+    tasks = ['connectedCheck']
+}
+
+task installRealm(type:GradleBuild) {
+    group = 'Install'
+    description = 'Install the artifacts of Realm libraries into mavenLocal()'
+    dependsOn installTransformer
+    buildFile = file('realm/build.gradle')
+    tasks = ['install']
+}
+
+task assembleGradlePlugin(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble the Realm Gradle plugin'
+    dependsOn installRealm
+    dependsOn installTransformer
+    buildFile = file('gradle-plugin/build.gradle')
+    tasks = ['assemble']
+}
+
+task installGradlePlugin(type:GradleBuild) {
+    description = 'Install the Realm Gradle plugin into mavenLocal()'
+    group = 'Install'
+    dependsOn installRealm
+    dependsOn installTransformer
+    buildFile = file('gradle-plugin/build.gradle')
+    tasks = ['install']
+}
+
+task installRealmJava(type:Task) {
+    dependsOn installGradlePlugin
+    dependsOn installRealm
+    group = 'Install'
+    description = 'Install the Realm library and Gradle plugin into mavenLocal()'
+}
+
+task assembleExamples(type:GradleBuild) {
+    dependsOn installGradlePlugin
+    dependsOn installRealm
+    group = 'Build'
+    description = 'Assemble the Realm examples'
+    buildFile = file('examples/build.gradle')
+    tasks = ['assemble']
+}
+
+task monkeyExamples(type:GradleBuild) {
+    dependsOn installGradlePlugin
+    dependsOn installRealm
+    group = 'Build'
+    description = 'Run the monkey tests on the Realm examples'
+    buildFile = file('examples/build.gradle')
+    tasks = ['monkeyRelease']
+}
+
+task javadoc(type:GradleBuild) {
+    description = 'Generate the Javadoc Jar for the Realm project'
+    group = 'Docs'
+    buildFile = file('realm/build.gradle')
+    tasks = ['javadocJar']
+}
+
+task sourcesJar(type:GradleBuild) {
+    description = 'Generate the sources Jar for the Realm project'
+    group = 'Docs'
+    buildFile = file('realm/build.gradle')
+    tasks = ['sourcesJar']
+}
+
+task assemble {
+    group 'Build'
+    description = 'Build Realm, the Gradle plugin and the examples'
+    dependsOn assembleExamples
+}
+
+task distributionPackage(type:Zip) {
+    description = 'Generate the distribution package'
+    dependsOn assembleRealm
+    dependsOn javadoc
+
+    group = 'Artifact'
+    archiveName = "realm-java-${currentVersion}.zip"
+    destinationDir = file("${buildDir}/outputs/distribution")
+
+    from('changelog.txt')
+    from('LICENSE')
+    from('version.txt')
+    from("${buildDir}/outputs/gradle") {
+        include "realm-android-${currentVersion}.jar"
+        into 'gradle'
+    }
+    from('realm/realm-library/build/libs') {
+        include 'realm-android-${currentVersion}-javadoc.jar'
+        into 'docs'
+    }
+    from('realm/realm-library/build/docs') {
+        include '**/*'
+        into 'docs'
+    }
+    from('examples') {
+        exclude 'local.properties'
+        exclude '**/.gradle'
+        exclude '**/build'
+        into 'examples'
+    }
+}
+
+task cleanRealm(type:GradleBuild) {
+    description = 'Clean the Realm project'
+    group = 'Clean'
+    buildFile = file('realm/build.gradle')
+    tasks = ['clean']
+    if (project.hasProperty('dontCleanJniFiles')) {
+        startParameter.projectProperties = [dontCleanJniFiles: ""]
+    }
+}
+
+task cleanGradlePlugin(type:GradleBuild) {
+    description = 'Clean the Realm Gradle plugin project'
+    group = 'Clean'
+    buildFile = file('gradle-plugin/build.gradle')
+    tasks = ['clean']
+}
+
+task cleanExamples(type:GradleBuild) {
+    description = 'Clean the Realm examples'
+    group = 'Clean'
+    buildFile = file('examples/build.gradle')
+    tasks = ['clean']
+}
+
+task cleanLocalMavenRepos(type:Delete) {
+    description = 'Remove any Realm artifacts from the local Maven repositories'
+    group = 'Clean'
+    delete "${System.env.HOME}/.m2/repository/io/realm"
+}
+
+task clean {
+    description = 'Perform all the other clean tasks'
+    group = 'Clean'
+    cleanLocalMavenRepos.dependsOn cleanRealm
+    cleanLocalMavenRepos.dependsOn cleanGradlePlugin
+    cleanLocalMavenRepos.dependsOn cleanExamples
+    dependsOn cleanLocalMavenRepos
+}
+
+task uploadDistributionPackage(type: Exec) {
+    group = 'Release'
+    description = 'Upload the distribution package to S3'
+    dependsOn distributionPackage
+    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+}
+
+task createEmptyFile(type: Exec) {
+    group = 'Release'
+    description = 'Create an empty file that will serve as a link on S3'
+    dependsOn uploadDistributionPackage
+    commandLine 'touch', 'latest'
+}
+
+['java', 'android'].each() { link ->
+    task "upload${link.capitalize()}LatestLink"(type: Exec) {
+        group = 'Release'
+        description = "Update the link to the latest version for ${link.capitalize()}"
+        dependsOn createEmptyFile
+        commandLine 's3cmd', 'put', 'latest', "--add-header=x-amz-website-redirect-location:/downloads/java/realm-java-${currentVersion}.zip", "s3://static.realm.io/downloads/${link}/latest"
+    }
+}
+
+task uploadUpdateVersion(type: Exec) {
+    group = 'Release'
+    description = 'Update the file on S3 containing the latest version'
+    ['java', 'android'].each() { link ->
+        dependsOn "upload${link.capitalize()}LatestLink"
+    }
+    commandLine 's3cmd', 'put', "${rootDir}/version.txt", 's3://static.realm.io/update/java'
+}
+
+task distribute {
+    group = 'Release'
+    description = 'Distribute release artifacts to S3'
+    dependsOn uploadUpdateVersion
+}
+
+task bintrayRealm(type: GradleBuild) {
+    description = 'Publish the Realm AAR and AP to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm/build.gradle')
+    tasks = ['bintrayUpload']
+}
+
+task bintrayAnnotations(type: GradleBuild) {
+    description = 'Publish the Realm Annotations to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm-annotations/build.gradle')
+    tasks = ['bintrayUpload']
+}
+
+task bintrayGradlePlugin(type: GradleBuild) {
+    description = 'Publish the Realm Gradle Plugin to Bintray'
+    group = 'Publishing'
+    buildFile = file('gradle-plugin/build.gradle')
+    tasks = ['bintrayUpload']
+}
+
+task bintrayTransformer(type: GradleBuild) {
+    description = 'Publish the Realm Transformer to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm-transformer/build.gradle')
+    tasks = ['bintrayUpload']
+}
+
+task bintrayUpload {
+    description = 'Publish all the Realm artifacts to Bintray'
+    group = 'Publishing'
+    dependsOn bintrayRealm
+    dependsOn bintrayAnnotations
+    dependsOn bintrayGradlePlugin
+    dependsOn bintrayTransformer
+}
+
+task ojoRealm(type: GradleBuild) {
+    description = 'Publish the Realm AAR and AP SNAPSHOT to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm/build.gradle')
+    tasks = ['artifactoryPublish']
+}
+
+task ojoAnnotations(type: GradleBuild) {
+    description = 'Publish the Realm Annotations SNAPSHOT to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm-annotations/build.gradle')
+    tasks = ['artifactoryPublish']
+}
+
+task ojoGradlePlugin(type: GradleBuild) {
+    description = 'Publish the Realm Gradle Plugin SNAPSHOT to Bintray'
+    group = 'Publishing'
+    buildFile = file('gradle-plugin/build.gradle')
+    tasks = ['artifactoryPublish']
+}
+
+task ojoTransformer(type: GradleBuild) {
+    description = 'Publish the Realm Transformer SNAPSHOT to Bintray'
+    group = 'Publishing'
+    buildFile = file('realm-transformer/build.gradle')
+    tasks = ['artifactoryPublish']
+}
+
+task ojoUpload {
+    description = 'Publish all the Realm SNAPSHOT artifacts to OJO'
+    group = 'Publishing'
+    dependsOn ojoRealm
+    dependsOn ojoAnnotations
+    dependsOn ojoGradlePlugin
+    dependsOn ojoTransformer
+}
+
+// This is just a placeholder for the release plugin
+task build {}
+
+release {
+    push = false
+    versionSuffix = '-SNAPSHOT'
+    tagPrefix = 'v'
+}
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
 }
diff --git a/changelog.txt b/changelog.txt
deleted file mode 100644
index 802bc6612c..0000000000
--- a/changelog.txt
+++ /dev/null
@@ -1,181 +0,0 @@
-0.80.3
- * Calling Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
- * Fixed a bug making it impossible to open Realms created by Realm-Cocoa if a model had a primary key defined.
- * Trying to using Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
- * RealmChangedListener now also gets called on the same thread that did the commit.
- * Fixed bug where Realm.createOrUpdateWithJson() reset Date and Binary data to default values if not found in the JSON output.
- * Fixed a memory leak when using RealmBaseAdapter.
- * RealmBaseAdapter now allow RealmResults to be null (thanks @zaki50).
- * Fixed a bug where a change to a model class (RealmList<A> to RealmList<B>) would not throw a RealmMigrationNeededException.
- * Fixed a bug where where setting multiple RealmLists didn't remove the previously added objects.
- * Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (thanks @beeender)
- * Fixed duplicated listeners in the same realm instance. Trying to add duplicated listeners is ignored now. (thanks @beeender)
-
-0.80.2
- * Trying to use Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
- * RealmMigrationNeedException can now return the path to the Realm that needs to be migrated.
- * Fixed bug where creating a Realm instance with a hashcode collision no longer returned the wrong Realm instance.
- * Updated Realm Core to version 0.89.2
-   - fixed bug causing a crash when opening an encrypted Realm file on ARM64 devices.
-
-0.80.1
- * Realm.createOrUpdateWithJson() no longer resets fields to their default value if they are not found in the JSON input.
- * Realm.compactRealmFile() now uses Realm Core's compact() method which is more failure resilient.
- * Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
- * The ARM64 binary is now properly a part of the Eclipse distribution package.
- * A RealmMigrationExceptionNeeded is now properly thrown if @Index and @PrimaryKey are not set correctly during a migration.
- * Fixed bug causing Realms to be cached even though they failed to open correctly.
- * Added Realm.deleteRealmFile(File) method.
- * Fixed bug causing queries to fail if multiple Realms has different field ordering.
- * Fixed bug when using Realm.copyToRealm() with a primary key could crash if default value was already used in the Realm.
- * Updated Realm Core to version 0.89.0
-   - improved performance for sorting RealmResults.
-   - improved performance for refreshing a Realm after inserting or modifying strings or binary data.
-   - fixed bug causing incorrect result when querying indexed fields.
-   - fixed bug causing corruption of string index when deleting an object where there are duplicate values for the indexed field.
-   - fixed bug causing a crash after compacting the Realm file.
- * Added RealmQuery.isNull() and RealmQuery.isNotNull() for querying relationships.
- * Fixed a potential NPE in the RealmList constructor.
-
-0.80
-* Queries on relationships can be case sensitive.
-* Fixed bug when importing JSONObjects containing NULL values.
-* Fixed crash when trying to remove last element of a RealmList.
-* Fixed bug crashing annotation processor when using "name" in model classes for RealmObject references
-* Fixed problem occurring when opening an encrypted Realm with two different instances of the same key.
-* Version checker no longer reports that updates are available when latest version is used.
-* Added support for static fields in RealmObjects.
-* Realm.writeEncryptedCopyTo() has been reenabled.
-
-0.79.1
- * copyToRealm() no longer crashes on cyclic data structures.
- * Fixed potential crash when using copyToRealmOrUpdate with an object graph containing a mix of elements with and without primary keys.
-
-0.79
- * Added support for ARM64.
- * Added RealmQuery.not() to negate a query condition.
- * Made the native libraries much smaller. Arm went from 1.8MB to 800KB.
- * Better error reporting when trying to create or open a Realm file fails.
- * Improved error reporting in case of missing accessors in model classes.
- * Re-enabled RealmResults.remove(index) and RealmResults.removeLast().
- * Primary keys are now supported through the @PrimaryKey annotation.
- * Added copyToRealmOrUpdate() and createOrUpdateFromJson() methods, that works for models with primary keys.
- * Fixed error when instantiating a Realm with the wrong key.
- * Throw an exception if deleteRealmFile() is called when there is an open instance of the Realm.
- * Made migrations and compression methods synchronised.
- * Removed methods deprecated in 0.76. Now Realm.allObjectsSorted() and RealmQuery.findAllSorted() need to be used instead.
- * Reimplemented Realm.allObjectSorted() for better performance.
-
-0.78
- * Added proper support for encryption. Encryption support is now included by default. Keys are now 64 bytes long.
- * Added support to write an encrypted copy of a Realm.
- * Realm no longer incorrectly warns that an instance has been closed too many times.
- * Realm now shows a log warning if an instance is being finalized without being closed.
- * Fixed bug causing Realms to be cached during a RealmMigration resulting in invalid realms being returned from Realm.getInstance().
- * Updated core to 0.88.
-
-0.77
- * Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
- * RealmResults.sort() now has better error reporting.
- * Added more logging capabilities at the JNI level.
- * Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
- * Fixed bug when doing queries on the elements of a RealmList, ie. like Realm.where(Foo.class).getBars().where().equalTo("name").
- * Throw NoSuchMethodError when RealmResults.indexOf() is called, since it's not implemented yet.
- * Added support for standalone objects and custom constructors.
- * Added more precise imports in proxy classes to avoid ambiguous references.
- * Improved handling of empty model classes in the annotation processor
- * Added support for executing a transaction with a closure using Realm.executeTransaction().
- * Fixed bug causing refresh() to be called on background threads with closed Realms.
- * Fixed bug where calling Realm.close() too many times could result in Realm not getting closed at all. This now triggers a log warning.
- * Added RealmObject.isValid() to test if an object is still accessible.
- * Removed deprecated static constructors.
- * Introduced new static constructors based on File instead of Context, allowing to save Realm files in custom locations.
- * RealmList.remove() now properly returns the removed object.
- * Calling realm.close() no longer prevent updates to other open realm instances on the same thread.
-
-0.76.0
- * RealmObjects can now be imported using JSON.
- * Gradle wrapper updated to support Android Studio 1.0.
- * Bug fixed in RealmObject.equals() so it now correctly compares two objects from the same Realm.
- * Realm class is now marked as final.
- * Replaced concurrency example with a better thread example.
- * Allow to add/remove RealmChangeListeners in RealmChangeListeners.
- * Upgrading to core 0.87.0 (encryption support, API changes).
- * Bug fixed in Realm crashing for receiving notifications after close().
- * Close the Realm instance after migrations.
- * Added a check to deny the writing of objects outside of a transaction.
-
-0.75.1 (03 December 2014)
-  * Changing sort to be an in-place method.
-  * Renaming SORT_ORDER_DECENDING to SORT_ORDER_DESCENDING.
-  * Adding sorting functionality to allObjects() and findAll().
-  * Bug fixed: when querying a date column with equalTo(), it would act as lessThan()
-
-0.75.0 (28 Nov 2014)
-  * Realm now implements Closeable, allowing better cleanup of native resources
-  * Adding writeCopyTo() and compactRealmFile() to write and compact a Realm to a new file.
-  * RealmObject.toString(), equals() and hashCode() now support models with cyclic references.
-  * RealmResults.iterator() and listIterator() now correctly iterates the results when using remove().
-  * Bug fixed in Exception text when field names was not matching the database
-  * Bug fixed so Realm no longer throws an Exception when removing the last object
-  * Bug fixed in RealmResults which prevented sub-querying
-  * The Date type does not support millisecond resolution, and dates before 1900-12-13
-    and dates after 2038-01-19 are not supported on 32 bit systems
-  * Fixed bug so Realm no longer throws an Exception when removing the last object
-  * Bug fixed in RealmResults which prevented subquerying
-
-
-
-0.74.0 (19 Nov 2014)
-  * Added support for more field/accessors naming conventions
-  * Allow static methods in model classes
-  * An exception will now be thrown if you try to move Realm, RealmResults or RealmObject between threads.
-  * Fixed a bug in the calculation of the maximum of date field in a RealmResults
-  * Adding case sensitive versions of string comparison operators equalTo and notEqualTo
-  * Adding where() to RealmList to initiate queries
-  * Updated core to 0.86.0, fixing a bug in cancelling an empty transaction, and major query speedups with floats/doubles
-  * Consistent handling of UTF-8 strings
-  * removeFromRealm() now calls moveLastOver() which is faster and more reliable when deleting multiple objects
-  * Added verification of fields names in queries with links.
-  * Added exception for queries with invalid field name
-
-0.73.1 (05 Nov 2014)
-  * Fixed a bug that would send infinite notifications in some instances
-
-0.73.0 (04 Nov 2014)
-  * Fixed a bug not allowing queries with more than 1024 conditions
-  * Rewritten the notification system. The API did not change but it's now much more reliable
-  * Added support for switching auto-refresh on and off (Realm.setAutoRefresh)
-  * Added RealmBaseAdapter and an example using it
-  * Added deleteFromRealm() method to RealmObject
-
-0.72.0 (27 Oct 2014)
-  * Extended sorting support to more types: boolean, byte, short, int, long, float, double, Date, and String
-    fields are now supported
-  * Better support for Java 7 and 8 in the annotations processor
-  * Better support for the Eclipse annotations processor
-  * Added Eclipse support to the distribution folder
-  * Added Realm.cancelTransaction() to cancel/abort/rollback a write transaction
-  * Faster implementation of RealmQuery.findFirst()
-  * Upgraded core to 0.85.1 (deep copying of strings in queries; preparation for link queries)
-  * Added support for link queries in the form realm.where(Owner.class).equalTo("cat.age", 12).findAll()
-
-0.71.0 (07 Oct 2014)
-  * Simplified the release artifact to a single Jar file
-  * Added support for Eclipse
-  * Added support for deploying to Maven
-  * Throw exception if nested write transactions are used (it's not allowed)
-  * Javadoc updated
-  * Fixed bug in RealmResults: https://github.com/realm/realm-java/issues/453
-  * New annotation @Index to add search index to a field (currently only supporting String fields)
-  * Made the annotations processor more verbose and strict
-  * Adding RealmQuery.count() method
-  * Added a new example about concurrency
-  * Upgrading to core 0.84.0
-
-0.70.1 (30 Sep 2014)
-  * Enable unit testing for the realm project
-  * Fixed handling of camel-cased field names
-
-0.70.0 (29 Sep 2014)
-  * This is the first public beta release
diff --git a/distribution/.gitignore b/distribution/.gitignore
deleted file mode 100644
index 1a4d537dc2..0000000000
--- a/distribution/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-changelog.txt
\ No newline at end of file
diff --git a/distribution/README.txt b/distribution/README.txt
deleted file mode 100644
index cefc8531f1..0000000000
--- a/distribution/README.txt
+++ /dev/null
@@ -1,23 +0,0 @@
-Realm for Android
-=================
-This is a beta release of Realm for Android.
-
-Getting Started
----------------
-Please check the documentation on http://realm.io/docs/java for how to get started.
-
-Examples
---------
-Included in this distribution are a couple of examples.
-You can try them out from Android Studio through "File->Import Project" and selecting the
-build.gradle file in the respective example. Then click "Run".
-But more importantly check out the source code in RealmIntroExample/app/src
-which will provide examples for how to use the API.
-
-Feedback
---------
-We highly appreciate your feedback to make Realm  awesome!
-Please send your feedback to https://groups.google.com/forum/#!forum/realm-java
-
-Thanks!
-The Realm team
diff --git a/distribution/RealmAdapterExample/.gitignore b/distribution/RealmAdapterExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmAdapterExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmAdapterExample/app/.gitignore b/distribution/RealmAdapterExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmAdapterExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmAdapterExample/app/proguard-rules.pro b/distribution/RealmAdapterExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmAdapterExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmAdapterExample/build.gradle b/distribution/RealmAdapterExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmAdapterExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmAdapterExample/gradle.properties b/distribution/RealmAdapterExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmAdapterExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 0c44860eea..0000000000
--- a/distribution/RealmAdapterExample/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Apr 10 15:27:10 PDT 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmAdapterExample/settings.gradle b/distribution/RealmAdapterExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmAdapterExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/distribution/RealmEncryptionExample/.gitignore b/distribution/RealmEncryptionExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmEncryptionExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmEncryptionExample/app/.gitignore b/distribution/RealmEncryptionExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmEncryptionExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmEncryptionExample/app/proguard-rules.pro b/distribution/RealmEncryptionExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmEncryptionExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmEncryptionExample/build.gradle b/distribution/RealmEncryptionExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmEncryptionExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmEncryptionExample/gradle.properties b/distribution/RealmEncryptionExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmEncryptionExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmEncryptionExample/settings.gradle b/distribution/RealmEncryptionExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmEncryptionExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/distribution/RealmGridViewExample/.gitignore b/distribution/RealmGridViewExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmGridViewExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmGridViewExample/app/.gitignore b/distribution/RealmGridViewExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmGridViewExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmGridViewExample/app/proguard-rules.pro b/distribution/RealmGridViewExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmGridViewExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmGridViewExample/build.gradle b/distribution/RealmGridViewExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmGridViewExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmGridViewExample/gradle.properties b/distribution/RealmGridViewExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmGridViewExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmGridViewExample/settings.gradle b/distribution/RealmGridViewExample/settings.gradle
deleted file mode 100644
index 9d495b34f8..0000000000
--- a/distribution/RealmGridViewExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
\ No newline at end of file
diff --git a/distribution/RealmIntroExample/.gitignore b/distribution/RealmIntroExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmIntroExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmIntroExample/app/.gitignore b/distribution/RealmIntroExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmIntroExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmIntroExample/app/proguard-rules.pro b/distribution/RealmIntroExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmIntroExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmIntroExample/build.gradle b/distribution/RealmIntroExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmIntroExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmIntroExample/gradle.properties b/distribution/RealmIntroExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmIntroExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 0c44860eea..0000000000
--- a/distribution/RealmIntroExample/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Apr 10 15:27:10 PDT 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmIntroExample/gradlew b/distribution/RealmIntroExample/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/distribution/RealmIntroExample/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmIntroExample/gradlew.bat b/distribution/RealmIntroExample/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/distribution/RealmIntroExample/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/distribution/RealmIntroExample/settings.gradle b/distribution/RealmIntroExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmIntroExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/distribution/RealmJsonExample/.gitignore b/distribution/RealmJsonExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmJsonExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmJsonExample/app/.gitignore b/distribution/RealmJsonExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmJsonExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmJsonExample/app/proguard-rules.pro b/distribution/RealmJsonExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmJsonExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmJsonExample/build.gradle b/distribution/RealmJsonExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmJsonExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmJsonExample/gradle.properties b/distribution/RealmJsonExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmJsonExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 0c44860eea..0000000000
--- a/distribution/RealmJsonExample/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Apr 10 15:27:10 PDT 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmJsonExample/gradlew b/distribution/RealmJsonExample/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/distribution/RealmJsonExample/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmJsonExample/gradlew.bat b/distribution/RealmJsonExample/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/distribution/RealmJsonExample/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/distribution/RealmJsonExample/settings.gradle b/distribution/RealmJsonExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmJsonExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/distribution/RealmMigrationExample/.gitignore b/distribution/RealmMigrationExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmMigrationExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmMigrationExample/app/.gitignore b/distribution/RealmMigrationExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmMigrationExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmMigrationExample/app/proguard-rules.pro b/distribution/RealmMigrationExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmMigrationExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmMigrationExample/build.gradle b/distribution/RealmMigrationExample/build.gradle
deleted file mode 100644
index b9a5d3c65e..0000000000
--- a/distribution/RealmMigrationExample/build.gradle
+++ /dev/null
@@ -1,18 +0,0 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmMigrationExample/gradle.properties b/distribution/RealmMigrationExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmMigrationExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 0c44860eea..0000000000
--- a/distribution/RealmMigrationExample/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Apr 10 15:27:10 PDT 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmMigrationExample/gradlew b/distribution/RealmMigrationExample/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/distribution/RealmMigrationExample/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmMigrationExample/gradlew.bat b/distribution/RealmMigrationExample/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/distribution/RealmMigrationExample/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/distribution/RealmMigrationExample/settings.gradle b/distribution/RealmMigrationExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmMigrationExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/distribution/RealmThreadExample/.gitignore b/distribution/RealmThreadExample/.gitignore
deleted file mode 100644
index afbdab33e9..0000000000
--- a/distribution/RealmThreadExample/.gitignore
+++ /dev/null
@@ -1,6 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
diff --git a/distribution/RealmThreadExample/app/.gitignore b/distribution/RealmThreadExample/app/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/distribution/RealmThreadExample/app/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/distribution/RealmThreadExample/app/proguard-rules.pro b/distribution/RealmThreadExample/app/proguard-rules.pro
deleted file mode 100644
index bb65c6fe88..0000000000
--- a/distribution/RealmThreadExample/app/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/distribution/RealmThreadExample/build.gradle b/distribution/RealmThreadExample/build.gradle
deleted file mode 100644
index dfcb4bf4d1..0000000000
--- a/distribution/RealmThreadExample/build.gradle
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
-    }
-}
-
-allprojects {
-    repositories {
-        jcenter()
-    }
-}
diff --git a/distribution/RealmThreadExample/gradle.properties b/distribution/RealmThreadExample/gradle.properties
deleted file mode 100644
index 5d08ba75bb..0000000000
--- a/distribution/RealmThreadExample/gradle.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-# Default value: -Xmx10248m -XX:MaxPermSize=256m
-# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. More details, visit
-# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
-# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 0c44860eea..0000000000
--- a/distribution/RealmThreadExample/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Apr 10 15:27:10 PDT 2013
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmThreadExample/gradlew b/distribution/RealmThreadExample/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/distribution/RealmThreadExample/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmThreadExample/gradlew.bat b/distribution/RealmThreadExample/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/distribution/RealmThreadExample/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/distribution/RealmThreadExample/settings.gradle b/distribution/RealmThreadExample/settings.gradle
deleted file mode 100644
index e7b4def49c..0000000000
--- a/distribution/RealmThreadExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-include ':app'
diff --git a/examples/adapterExample/build.gradle b/examples/adapterExample/build.gradle
index 7e811a8518..d9a210bc64 100644
--- a/examples/adapterExample/build.gradle
+++ b/examples/adapterExample/build.gradle
@@ -1,21 +1,22 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId "io.realm.examples.realmadapters"
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 19
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 
@@ -23,12 +24,3 @@ android {
         events 2000
     }
 }
-
-
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
-dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
-}
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
index 53f3e2496a..69915fc341 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
@@ -26,6 +26,7 @@
 import android.widget.ListView;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.examples.realmadapters.models.TimeStamp;
 
@@ -40,9 +41,12 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_my);
 
-        Realm.deleteRealmFile(this);
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfig);
+        // Set the default Realm configuration at the beginning.
+        Realm.setDefaultConfiguration(realmConfig);
+        realm = Realm.getDefaultInstance();
 
-        realm = Realm.getInstance(this);
         RealmResults<TimeStamp> timeStamps = realm.where(TimeStamp.class).findAll();
         final MyAdapter adapter = new MyAdapter(this, R.id.listView, timeStamps, true);
         ListView listView = (ListView) findViewById(R.id.listView);
@@ -68,7 +72,7 @@ protected void onPause() {
     @Override
     protected void onResume() {
         super.onResume();
-        workerThread = new WorkerThread(this);
+        workerThread = new WorkerThread();
         workerThread.start();
     }
 
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
index 914bb1cd18..847ffd4bf1 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/WorkerThread.java
@@ -15,7 +15,6 @@
  */
 package io.realm.examples.realmadapters;
 
-import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
 
@@ -25,18 +24,12 @@
 
     public Handler workerHandler;
 
-    private Context context;
-
-    public WorkerThread(Context context) {
-        this.context = context;
-    }
-
     @Override
     public void run() {
         Realm realm = null;
         try {
             Looper.prepare();
-            realm = Realm.getInstance(context);
+            realm = Realm.getDefaultInstance();
             workerHandler = new WorkerHandler(realm);
             Looper.loop();
         } finally {
diff --git a/examples/build.gradle b/examples/build.gradle
new file mode 100644
index 0000000000..c1c2682d7a
--- /dev/null
+++ b/examples/build.gradle
@@ -0,0 +1,34 @@
+project.ext.sdkVersion = 23
+project.ext.buildTools = '23.0.0'
+
+// Don't cache SNAPSHOT (changing) dependencies.
+configurations.all {
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+
+allprojects {
+    def currentVersion = file("${rootDir}/../version.txt").text.trim()
+
+    buildscript {
+        repositories {
+            mavenLocal()
+            jcenter()
+        }
+        dependencies {
+            classpath 'com.android.tools.build:gradle:1.5.0'
+            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
+            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+            classpath "io.realm:realm-gradle-plugin:${currentVersion}"
+        }
+    }
+
+    group = 'io.realm'
+    version = currentVersion
+
+    repositories {
+        mavenLocal()
+        jcenter()
+    }
+}
diff --git a/examples/encryptionExample/.gitignore b/examples/encryptionExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/encryptionExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 3cd83ff083..60181889d3 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -1,13 +1,16 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion '20.0.0'
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
     defaultConfig {
         applicationId 'examples.realm.io.encryptionExample'
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 14
-        targetSdkVersion 19
         versionCode 1
         versionName '1.0'
     }
@@ -15,7 +18,6 @@ android {
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     productFlavors {
@@ -25,11 +27,3 @@ android {
         events 2000
     }
 }
-
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
-dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
-}
diff --git a/examples/encryptionExample/proguard-rules.pro b/examples/encryptionExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/examples/encryptionExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
index 6143ce6d94..7b70163cfe 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
@@ -23,6 +23,7 @@
 import java.security.SecureRandom;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 
 public class EncryptionExampleActivity extends Activity {
 
@@ -34,9 +35,6 @@
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        // Start with a clean slate every time
-        Realm.deleteRealmFile(this);
-
         // Generate a key
         // IMPORTANT! This is a silly way to generate a key. It is also never stored.
         // For proper key handling please consult:
@@ -44,10 +42,15 @@ protected void onCreate(Bundle savedInstanceState) {
         // * http://nelenkov.blogspot.dk/2012/05/storing-application-secrets-in-androids.html
         byte[] key = new byte[64];
         new SecureRandom().nextBytes(key);
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this)
+                .encryptionKey(key)
+                .build();
 
-        // Open the Realm with encryption enabled
-        realm = Realm.getInstance(this, key);
+        // Start with a clean slate every time
+        Realm.deleteRealm(realmConfiguration);
 
+        // Open the Realm with encryption enabled
+        realm = Realm.getInstance(realmConfiguration);
 
         // Everything continues to work as normal except for that the file is encrypted on disk
         realm.beginTransaction();
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..e8c6bf7bb4
Binary files /dev/null and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
similarity index 80%
rename from gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties
rename to examples/gradle/wrapper/gradle-wrapper.properties
index 0c71e760dc..587246a1a4 100644
--- a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Apr 10 15:27:10 PDT 2013
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/distribution/RealmAdapterExample/gradlew b/examples/gradlew
similarity index 96%
rename from distribution/RealmAdapterExample/gradlew
rename to examples/gradlew
index 91a7e269e1..97fac783e1 100755
--- a/distribution/RealmAdapterExample/gradlew
+++ b/examples/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/distribution/RealmAdapterExample/gradlew.bat b/examples/gradlew.bat
similarity index 100%
rename from distribution/RealmAdapterExample/gradlew.bat
rename to examples/gradlew.bat
diff --git a/examples/gridViewExample/.gitignore b/examples/gridViewExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/gridViewExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index a325e0edc7..15365c35c7 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -1,20 +1,22 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
     defaultConfig {
         applicationId 'io.realm.examples.realmgridview'
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 19
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     productFlavors {
@@ -23,13 +25,18 @@ android {
     command {
         events 2000
     }
-}
 
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
+    splits {
+        // Split apks on build target ABI, view all options for the splits here:
+        // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits
+        abi {
+            enable true
+            reset()
+            include 'arm', 'arm-v7a', 'arm64', 'mips', 'x86', 'x86_64'
+        }
+    }
 }
 
 dependencies {
-    compile 'com.google.code.gson:gson:2.3.1'
-    compile files("../../realm/build/libs/realm-${version}.jar")
+    compile 'com.google.code.gson:gson:2.5'
 }
diff --git a/examples/gridViewExample/proguard-rules.pro b/examples/gridViewExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/examples/gridViewExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
index a94beadca5..2c61e50694 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
@@ -33,8 +33,6 @@
 
 public class CityAdapter extends BaseAdapter {
 
-    public static final String TAG = GridViewExampleActivity.class.getName();
-
     private LayoutInflater inflater;
 
     private List<City> cities = null;
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index 3973193f83..edc41c4e0d 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -18,7 +18,6 @@
 
 import android.app.Activity;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.View;
 import android.widget.AdapterView;
 import android.widget.GridView;
@@ -27,7 +26,6 @@
 import com.google.gson.FieldAttributes;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import com.google.gson.reflect.TypeToken;
@@ -36,19 +34,16 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
-import io.realm.internal.Row;
 
 public class GridViewExampleActivity extends Activity implements AdapterView.OnItemClickListener {
 
-    public static final String TAG = GridViewExampleActivity.class.getName();
-
     private GridView mGridView;
     private CityAdapter mAdapter;
 
@@ -59,11 +54,13 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+
         // Clear the realm from last time
-        Realm.deleteRealmFile(this);
+        Realm.deleteRealm(realmConfiguration);
 
         // Create a new empty instance of Realm
-        realm = Realm.getInstance(this);
+        realm = Realm.getInstance(realmConfiguration);
     }
 
     @Override
@@ -96,7 +93,7 @@ protected void onDestroy() {
     private List<City> loadCities() {
         // In this case we're loading from local assets.
         // NOTE: could alternatively easily load from network
-        InputStream stream = null;
+        InputStream stream;
         try {
             stream = getAssets().open("cities.json");
         } catch (IOException e) {
@@ -104,7 +101,7 @@ protected void onDestroy() {
         }
 
         // GSON can parse the data.
-        // Note there is a bug in GSON 2.3.1 that can cause it to StackOverflow when working with RealmObjects.
+        // Note there is a bug in GSON 2.5 that can cause it to StackOverflow when working with RealmObjects.
         // To work around this, use the ExclusionStrategy below or downgrade to 1.7.1
         // See more here: https://code.google.com/p/google-gson/issues/detail?id=440
         Gson gson = new GsonBuilder()
@@ -134,8 +131,6 @@ public boolean shouldSkipClass(Class<?> clazz) {
     }
 
     public void updateCities() {
-        Realm realm = Realm.getInstance(this);
-
         // Pull all the cities from the realm
         RealmResults<City> cities = realm.where(City.class).findAll();
 
@@ -149,10 +144,7 @@ public void updateCities() {
     public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
         City modifiedCity = (City)mAdapter.getItem(position);
 
-        // Update the realm object affected by the user
-        Realm realm = Realm.getInstance(this);
-
-        // Acquire the list of realm cities matching the name of the clicked City.
+        // Acquire the RealmObject matching the name of the clicked City.
         City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
 
         // Create a transaction to increment the vote count for the selected City in the realm
diff --git a/examples/introExample/.gitignore b/examples/introExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/introExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index b9ad8685cc..b253559d33 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,13 +1,17 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'com.neenbedankt.android-apt'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
     defaultConfig {
         applicationId 'io.realm.examples.intro'
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 19
         versionCode 1
         versionName "1.0"
     }
@@ -15,7 +19,6 @@ android {
     buildTypes {
         release {
             minifyEnabled false
-//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 
@@ -26,11 +29,3 @@ android {
         events 2000
     }
 }
-
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
-dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
-}
diff --git a/examples/introExample/proguard-rules.pro b/examples/introExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/examples/introExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index f056fed0a9..fa46564f83 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -24,18 +24,20 @@
 import android.widget.TextView;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
+import io.realm.Sort;
 import io.realm.examples.intro.model.Cat;
 import io.realm.examples.intro.model.Dog;
 import io.realm.examples.intro.model.Person;
 
-
 public class IntroExampleActivity extends Activity {
 
     public static final String TAG = IntroExampleActivity.class.getName();
     private LinearLayout rootLayout = null;
 
     private Realm realm;
+    private RealmConfiguration realmConfig;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -47,8 +49,10 @@ protected void onCreate(Bundle savedInstanceState) {
         // These operations are small enough that
         // we can generally safely run them on the UI thread.
 
-        // Open the default realm ones for the UI thread.
-        realm = Realm.getInstance(this);
+        // Create the Realm configuration
+        realmConfig = new RealmConfiguration.Builder(this).build();
+        // Open the Realm for the UI thread.
+        realm = Realm.getInstance(realmConfig);
 
         basicCRUD(realm);
         basicQuery(realm);
@@ -58,7 +62,7 @@ protected void onCreate(Bundle savedInstanceState) {
         new AsyncTask<Void, Void, String>() {
             @Override
             protected String doInBackground(Void... voids) {
-                String info = null;
+                String info;
                 info = complexReadWrite();
                 info += complexQuery();
                 return info;
@@ -96,14 +100,14 @@ private void basicCRUD(Realm realm) {
         person.setName("Young Person");
         person.setAge(14);
 
-        // When the write transaction is committed, all changes a synced to disk.
+        // When the transaction is committed, all changes a synced to disk.
         realm.commitTransaction();
 
         // Find the first person (no query conditions) and read a field
         person = realm.where(Person.class).findFirst();
         showStatus(person.getName() + ":" + person.getAge());
 
-        // Update person in a write transaction
+        // Update person in a transaction
         realm.beginTransaction();
         person.setName("Senior Person");
         person.setAge(99);
@@ -139,12 +143,12 @@ private String complexReadWrite() {
 
         // Open the default realm. All threads must use it's own reference to the realm.
         // Those can not be transferred across threads.
-        Realm realm = Realm.getInstance(this);
+        Realm realm = Realm.getInstance(realmConfig);
 
-        // Add ten persons in one write transaction
+        // Add ten persons in one transaction
         realm.beginTransaction();
         Dog fido = realm.createObject(Dog.class);
-        fido.setName("fido");
+        fido.name = "fido";
         for (int i = 0; i < 10; i++) {
             Person person = realm.createObject(Person.class);
             person.setId(i);
@@ -160,7 +164,7 @@ private String complexReadWrite() {
 
             for (int j = 0; j < i; j++) {
                 Cat cat = realm.createObject(Cat.class);
-                cat.setName("Cat_" + j);
+                cat.name = "Cat_" + j;
                 person.getCats().add(cat);
             }
         }
@@ -175,21 +179,16 @@ private String complexReadWrite() {
             if (pers.getDog() == null) {
                 dogName = "None";
             } else {
-                dogName = pers.getDog().getName();
+                dogName = pers.getDog().name;
             }
             status += "\n" + pers.getName() + ":" + pers.getAge() + " : " + dogName + " : " + pers.getCats().size();
-
-            // The field tempReference is annotated with @Ignore
-            // Though we initially set its value to 42, it has
-            // not been saved as part of the Person RealmObject:
-            assert(pers.getTempReference() == 0);
         }
 
         // Sorting
         RealmResults<Person> sortedPersons = realm.allObjects(Person.class);
-        sortedPersons.sort("age", false);
-        assert(realm.allObjects(Person.class).last().getName() == sortedPersons.first().getName());
-        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.allObjects(Person.class).first().getName();
+        sortedPersons.sort("age", Sort.DESCENDING);
+        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.allObjects(Person.class).first()
+                .getName();
 
         realm.close();
         return status;
@@ -198,7 +197,7 @@ private String complexReadWrite() {
     private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
-        Realm realm = Realm.getInstance(this);
+        Realm realm = Realm.getInstance(realmConfig);
         status += "\nNumber of persons: " + realm.allObjects(Person.class).size();
 
         // Find all persons where age between 7 and 9 and name begins with "Person".
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/model/Cat.java b/examples/introExample/src/main/java/io/realm/examples/intro/model/Cat.java
index 64880371d2..c06ae48237 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/model/Cat.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/model/Cat.java
@@ -19,13 +19,5 @@
 import io.realm.RealmObject;
 
 public class Cat extends RealmObject {
-    private String name;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
+    public  String name;
 }
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/model/Dog.java b/examples/introExample/src/main/java/io/realm/examples/intro/model/Dog.java
index 8701f1d562..d6339bf300 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/model/Dog.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/model/Dog.java
@@ -19,13 +19,5 @@
 import io.realm.RealmObject;
 
 public class Dog extends RealmObject {
-    private String name;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
+    public String name;
 }
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/model/Person.java b/examples/introExample/src/main/java/io/realm/examples/intro/model/Person.java
index 05ba1db1e4..cf9975d269 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/model/Person.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/model/Person.java
@@ -40,10 +40,8 @@
 
     private long id;
 
-    // The standard getters and setters your IDE generates are fine.
-    // Realm will overload them and code inside them is ignored.
-    // So if you prefer you can also just have empty abstract methods.
-
+    // Let your IDE generate getters and setters for you!
+    // Or if you like you can even have public fields and no accessors! See Dog.java and Cat.java
     public String getName() {
         return name;
     }
diff --git a/examples/jsonExample/.gitignore b/examples/jsonExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/jsonExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index bdf7f8c44c..4dcc5d1350 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -1,20 +1,23 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
+apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
     defaultConfig {
         applicationId 'io.realm.examples.json'
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 19
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     productFlavors {
@@ -25,10 +28,7 @@ android {
     }
 }
 
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
 dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
+    provided 'org.projectlombok:lombok:1.16.6'
+    apt 'org.projectlombok:lombok:1.16.6'
 }
diff --git a/examples/jsonExample/lombok.config b/examples/jsonExample/lombok.config
new file mode 100644
index 0000000000..cac7bd5513
--- /dev/null
+++ b/examples/jsonExample/lombok.config
@@ -0,0 +1 @@
+lombok.addGeneratedAnnotation = false
\ No newline at end of file
diff --git a/examples/jsonExample/proguard-rules.pro b/examples/jsonExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/examples/jsonExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/City.java b/examples/jsonExample/src/main/java/io/realm/examples/json/City.java
index a583df868f..e55b3d4eb1 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/City.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/City.java
@@ -17,26 +17,12 @@
 package io.realm.examples.json;
 
 import io.realm.RealmObject;
+import lombok.Getter;
+import lombok.Setter;
 
+@Getter
+@Setter
 public class City extends RealmObject {
-
     private String name;
     private long votes;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public long getVotes() {
-        return votes;
-    }
-
-    public void setVotes(long votes) {
-        this.votes = votes;
-    }
-
 }
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/CityAdapter.java b/examples/jsonExample/src/main/java/io/realm/examples/json/CityAdapter.java
index d8226bd48e..73dbc279b7 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/CityAdapter.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/CityAdapter.java
@@ -78,7 +78,7 @@ public View getView(int position, View currentView, ViewGroup parent) {
 
         if (city != null) {
             ((TextView) currentView.findViewById(R.id.name)).setText(city.getName());
-            ((TextView) currentView.findViewById(R.id.votes)).setText(Long.toString(city.getVotes()));
+            ((TextView) currentView.findViewById(R.id.votes)).setText(String.valueOf(city.getVotes()));
         }
 
         return currentView;
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
index 4bcae72e71..e2fbb7bfbd 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 
 /**
  * This example demonstrates how to import RealmObjects as JSON. Realm supports JSON represented
@@ -36,8 +37,6 @@
  */
 public class JsonExampleActivity extends Activity {
 
-    public static final String TAG = JsonExampleActivity.class.getName();
-
     private GridView mGridView;
     private CityAdapter mAdapter;
     private Realm realm;
@@ -47,8 +46,9 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
-        Realm.deleteRealmFile(this);
-        realm = Realm.getInstance(this);
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfiguration);
+        realm = Realm.getInstance(realmConfiguration);
     }
 
     @Override
@@ -94,8 +94,7 @@ protected void onDestroy() {
     private void loadJsonFromStream() throws IOException {
         // Use streams if you are worried about the size of the JSON whether it was persisted on disk
         // or received from the network.
-        InputStream stream = null;
-        stream = getAssets().open("cities.json");
+        InputStream stream = getAssets().open("cities.json");
 
         // Open a transaction to store items into the realm
         realm.beginTransaction();
@@ -124,7 +123,7 @@ private void loadJsonFromJsonObject() {
     }
 
     private void loadJsonFromString() {
-        String json = "{ city: \"Aarhus\", votes: 99 }";
+        String json = "{ name: \"Aarhus\", votes: 99 }";
 
         realm.beginTransaction();
         realm.createObjectFromJson(City.class, json);
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
new file mode 100644
index 0000000000..5c64f700a9
--- /dev/null
+++ b/examples/kotlinExample/build.gradle
@@ -0,0 +1,53 @@
+buildscript {
+    ext.kotlin_version = '1.0.0-rc-1036'
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+    }
+}
+
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'kotlin-android'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.kotlin'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    command {
+        events 2000
+    }
+
+    // Incremental builds currently doesn't work with Kotlin
+    dexOptions {
+        incremental false
+    }
+
+    sourceSets {
+        main.java.srcDirs += 'src/main/kotlin'
+    }
+}
+
+dependencies {
+    compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
+    compile "org.jetbrains.kotlin:kotlin-reflect:${kotlin_version}"
+    compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
+}
diff --git a/examples/kotlinExample/src/main/AndroidManifest.xml b/examples/kotlinExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..877e97864f
--- /dev/null
+++ b/examples/kotlinExample/src/main/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<manifest package="io.realm.examples.kotlin"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity
+            android:name=".KotlinExampleActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
new file mode 100644
index 0000000000..2efaab1b9b
--- /dev/null
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin
+
+import android.app.Activity
+import android.os.Bundle
+import android.util.Log
+import android.widget.LinearLayout
+import android.widget.TextView
+import io.realm.Realm
+import io.realm.Sort
+import io.realm.RealmConfiguration
+import io.realm.examples.kotlin.model.Cat
+import io.realm.examples.kotlin.model.Dog
+import io.realm.examples.kotlin.model.Person
+import org.jetbrains.anko.async
+import org.jetbrains.anko.uiThread
+import kotlin.properties.Delegates
+
+
+public class KotlinExampleActivity : Activity() {
+
+    companion object {
+        public val TAG: String = KotlinExampleActivity::class.qualifiedName as String
+    }
+
+    private var rootLayout: LinearLayout by Delegates.notNull()
+    private var realm: Realm by Delegates.notNull()
+    private var realmConfig: RealmConfiguration by Delegates.notNull()
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.activity_realm_basic_example)
+        rootLayout = findViewById(R.id.container) as LinearLayout
+        rootLayout.removeAllViews()
+
+        // These operations are small enough that
+        // we can generally safely run them on the UI thread.
+
+        // Create configuration and reset Realm.
+        realmConfig = RealmConfiguration.Builder(this).build()
+        Realm.deleteRealm(realmConfig)
+
+        // Open the realm for the UI thread.
+        realm = Realm.getInstance(realmConfig)
+
+        basicCRUD(realm)
+        basicQuery(realm)
+        basicLinkQuery(realm)
+
+        // Delete all persons
+        // Using executeTransaction with a lambda reduces code size and makes it impossible
+        // to forget to commit the transaction.
+        realm.executeTransaction {
+            realm.allObjects(Person::class.java).clear()
+        }
+
+        // More complex operations can be executed on another thread, for example using
+        // Anko's async extension method.
+        async() {
+            var info: String
+            info = complexReadWrite()
+            info += complexQuery()
+
+            uiThread {
+                showStatus(info)
+            }
+        }
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        realm.close() // Remember to close Realm when done.
+    }
+
+    private fun showStatus(txt: String) {
+        Log.i(TAG, txt)
+        val tv = TextView(this)
+        tv.setText(txt)
+        rootLayout.addView(tv)
+    }
+
+    private fun basicCRUD(realm: Realm) {
+        showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...")
+
+        // All writes must be wrapped in a transaction to facilitate safe multi threading
+        realm.beginTransaction()
+
+        // Add a person
+        var person = realm.createObject(Person::class.java)
+        person.id = 1
+        person.name = "Young Person"
+        person.age = 14
+
+        // When the transaction is committed, all changes a synced to disk.
+        realm.commitTransaction()
+
+        // Find the first person (no query conditions) and read a field
+        person = realm.where(Person::class.java).findFirst()
+        showStatus(person.name + ": " + person.age)
+
+        // Update person in a transaction
+        realm.beginTransaction()
+        person.name = "Senior Person"
+        person.age = 99
+        showStatus(person.name + " got older: " + person.age)
+        realm.commitTransaction()
+    }
+
+    private fun basicQuery(realm: Realm) {
+        showStatus("\nPerforming basic Query operation...")
+        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+
+        val results = realm.where(Person::class.java).equalTo("age", 99).findAll()
+
+        showStatus("Size of result set: " + results.size)
+    }
+
+    private fun basicLinkQuery(realm: Realm) {
+        showStatus("\nPerforming basic Link Query operation...")
+        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+
+        val results = realm.where(Person::class.java).equalTo("cats.name", "Tiger").findAll()
+
+        showStatus("Size of result set: ${results.size}")
+    }
+
+    private fun complexReadWrite(): String {
+        var status = "\nPerforming complex Read/Write operation..."
+
+        // Open the default realm. All threads must use it's own reference to the realm.
+        // Those can not be transferred across threads.
+        val realm = Realm.getInstance(realmConfig)
+
+        // Add ten persons in one transaction
+        realm.beginTransaction()
+        val fido = realm.createObject(Dog::class.java)
+        fido.name = "fido"
+        for (i in 0..9) {
+            val person = realm.createObject(Person::class.java)
+            person.id = i.toLong()
+            person.name = "Person no. $i"
+            person.age = i
+            person.dog = fido
+
+            // The field tempReference is annotated with @Ignore.
+            // This means setTempReference sets the Person tempReference
+            // field directly. The tempReference is NOT saved as part of
+            // the RealmObject:
+            person.tempReference = 42
+
+            for (j in 0..i - 1) {
+                val cat = realm.createObject(Cat::class.java)
+                cat.name = "Cat_$j"
+                person.cats.add(cat)
+            }
+        }
+        realm.commitTransaction()
+
+        // Implicit read transactions allow you to access your objects
+        status += "\nNumber of persons: ${realm.allObjects(Person::class.java).size}"
+
+        // Iterate over all objects
+        for (pers in realm.allObjects(Person::class.java)) {
+            val dogName: String = pers?.dog?.name ?: "None"
+
+            status += "\n${pers.name}: ${pers.age} : $dogName : ${pers.cats.size}"
+
+            // The field tempReference is annotated with @Ignore
+            // Though we initially set its value to 42, it has
+            // not been saved as part of the Person RealmObject:
+            check(pers.tempReference == 0)
+        }
+
+        // Sorting
+        val sortedPersons = realm.allObjects(Person::class.java)
+        sortedPersons.sort("age", Sort.DESCENDING)
+        check(realm.allObjects(Person::class.java).last().name == sortedPersons.first().name)
+        status += "\nSorting ${sortedPersons.last().name} == ${realm.allObjects(Person::class.java).first().name}"
+
+        realm.close()
+        return status
+    }
+
+    private fun complexQuery(): String {
+        var status = "\n\nPerforming complex Query operation..."
+
+        // Realm implements the Closable interface, therefore we can make use of Kotlin's built-in
+        // extension method 'use' (pun intended).
+        Realm.getInstance(realmConfig).use {
+            // 'it' is the implicit lambda parameter of type Realm
+            status += "\nNumber of persons: ${it.allObjects(Person::class.java).size}"
+
+            // Find all persons where age between 7 and 9 and name begins with "Person".
+            val results = it
+                    .where(Person::class.java)
+                    .between("age", 7, 9)       // Notice implicit "and" operation
+                    .beginsWith("name", "Person")
+                    .findAll()
+
+            status += "\nSize of result set: ${results.size}"
+
+        }
+
+        return status
+    }
+
+
+}
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
new file mode 100644
index 0000000000..85cd17aac3
--- /dev/null
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmObject
+import io.realm.annotations.RealmClass
+
+public open class Cat : RealmObject() {
+    public open var name: String? = null
+}
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
new file mode 100644
index 0000000000..7fb0c4c235
--- /dev/null
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmObject
+import io.realm.annotations.RealmClass
+
+public open class Dog : RealmObject() {
+    public open var name: String? = null
+}
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
new file mode 100644
index 0000000000..8ad11e1650
--- /dev/null
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmList
+import io.realm.RealmObject
+import io.realm.annotations.Ignore
+import io.realm.annotations.PrimaryKey
+import io.realm.annotations.RealmClass
+
+// Your model has to extend RealmObject. Furthermore, the class and all of the
+// properties must be annotated with open (Kotlin classes and methods are final
+// by default).
+public open class Person(
+        // You can put properties in the constructor as long as all of them are initialized with
+        // default values. This ensures that an empty constructor is generated.
+        // All properties are by default persisted.
+        // Properties can be annotated with PrimaryKey or Index.
+        // If you use non-nullable types, properties must be initialized with non-null values.
+        @PrimaryKey public open var name: String = "",
+
+        public open var age: Int = 0,
+
+        // Other objects in a one-to-one relation must also subclass RealmObject
+        public open var dog: Dog? = null,
+
+        // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
+        public open var cats: RealmList<Cat> = RealmList(),
+
+        // You can instruct Realm to ignore a field and not persist it.
+        @Ignore public open var tempReference: Int = 0,
+
+        public open var id: Long = 0
+) : RealmObject() {
+    // The Kotlin compiler generates standard getters and setters.
+    // Realm will overload them and code inside them is ignored.
+    // So if you prefer you can also just have empty abstract methods.
+}
diff --git a/experimental/pathExperiment/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png
similarity index 100%
rename from experimental/pathExperiment/src/main/res/drawable-xxhdpi/ic_launcher.png
rename to examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png
diff --git a/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
new file mode 100644
index 0000000000..f7891e6991
--- /dev/null
+++ b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
@@ -0,0 +1,29 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:gravity="center_horizontal"
+            android:text="Status Output..."
+            android:textStyle="bold"
+            android:textSize="18sp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+        <LinearLayout
+            android:id="@+id/container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:paddingTop="10sp"
+            android:orientation="vertical"
+            tools:context=".RealmIntroExample"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/experimental/pathExperiment/src/main/res/values-w820dp/dimens.xml b/examples/kotlinExample/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from experimental/pathExperiment/src/main/res/values-w820dp/dimens.xml
rename to examples/kotlinExample/src/main/res/values-w820dp/dimens.xml
diff --git a/experimental/pathExperiment/src/main/res/values/dimens.xml b/examples/kotlinExample/src/main/res/values/dimens.xml
similarity index 100%
rename from experimental/pathExperiment/src/main/res/values/dimens.xml
rename to examples/kotlinExample/src/main/res/values/dimens.xml
diff --git a/experimental/pathExperiment/src/main/res/values/strings.xml b/examples/kotlinExample/src/main/res/values/strings.xml
similarity index 74%
rename from experimental/pathExperiment/src/main/res/values/strings.xml
rename to examples/kotlinExample/src/main/res/values/strings.xml
index f28fd52f2b..963831fd43 100644
--- a/experimental/pathExperiment/src/main/res/values/strings.xml
+++ b/examples/kotlinExample/src/main/res/values/strings.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 
-    <string name="app_name">PathRealmInteropTest</string>
+    <string name="app_name">Kotlin example</string>
     <string name="hello_world">Hello world!</string>
     <string name="action_settings">Settings</string>
 
diff --git a/test/concurrencyExample/src/main/res/values/styles.xml b/examples/kotlinExample/src/main/res/values/styles.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values/styles.xml
rename to examples/kotlinExample/src/main/res/values/styles.xml
diff --git a/examples/migrationExample/.gitignore b/examples/migrationExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/migrationExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index 19f7ee43ef..b15849923f 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -1,32 +1,25 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId "examples.realm.io.migration"
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 19
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     command {
         events 2000
     }
 }
-
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
-dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
-}
diff --git a/examples/migrationExample/proguard-rules.pro b/examples/migrationExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/examples/migrationExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index e772d42ccd..74c798bbd3 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -23,11 +23,13 @@
 import android.widget.TextView;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.examples.realmmigrationexample.model.Migration;
 import io.realm.examples.realmmigrationexample.model.Person;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -41,6 +43,7 @@
     public static final String TAG = MigrationExampleActivity.class.getName();
 
     private LinearLayout rootLayout = null;
+    private Realm realm;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -51,35 +54,51 @@ protected void onCreate(Bundle savedInstanceState) {
         rootLayout.removeAllViews();
 
         // 3 versions of the databases for testing. Normally you would only have one.
-        String path3 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0");
-        String path1 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1");
-        String path2 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2");
-
-        // If you try to open a file that doesn't match your model an exception is thrown:
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2");
+
+        // When you create a RealmConfiguration you can specify the version of the schema.
+        // If the schema does not have that version a RealmMigrationNeededException will be thrown.
+        RealmConfiguration config0 = new RealmConfiguration.Builder(this)
+                .name("default0")
+                .schemaVersion(3)
+                .build();
+
+        // You can then manually call Realm.migrateRealm().
         try {
-            // should throw as migration is required
-            Realm.getInstance(this, "default1");
-        } catch (RealmMigrationNeededException ex) {
-            Log.i(TAG, "Excellent! This is expected.");
+            Realm.migrateRealm(config0, new Migration());
+        } catch (FileNotFoundException ignored) {
+            // If the Realm file doesn't exist, just ignore.
         }
-
-        Realm realm;
-
-        // So you migrate your data
-        Realm.migrateRealmAtPath(path1, new Migration());
-        realm = Realm.getInstance(this, "default1");
+        realm = Realm.getInstance(config0);
+        showStatus("Default0");
         showStatus(realm);
         realm.close();
 
-        // Another migration test
-        Realm.migrateRealmAtPath(path2, new Migration());
-        realm = Realm.getInstance(this, "default2");
+        // Or you can add the migration code to the configuration. This will run the migration code without throwing
+        // a RealmMigrationNeededException.
+        RealmConfiguration config1 = new RealmConfiguration.Builder(this)
+                .name("default1")
+                .schemaVersion(3)
+                .migration(new Migration())
+                .build();
+
+        realm = Realm.getInstance(config1); // Automatically run migration if needed
+        showStatus("Default1");
         showStatus(realm);
         realm.close();
 
-        // and a third:
-        Realm.migrateRealmAtPath(path3, new Migration());
-        realm = Realm.getInstance(this, "default3");
+        // or you can set .deleteRealmIfMigrationNeeded() if you don't want to bother with migrations.
+        // WARNING: This will delete all data in the Realm though.
+        RealmConfiguration config2 = new RealmConfiguration.Builder(this)
+                .name("default2")
+                .schemaVersion(3)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+
+        realm = Realm.getInstance(config2);
+        showStatus("default2");
         showStatus(realm);
         realm.close();
     }
@@ -106,11 +125,15 @@ private String realmString(Realm realm) {
         for (Person person : realm.allObjects(Person.class)) {
             stringBuilder.append(person.toString()).append("\n");
         }
-        return stringBuilder.toString();
+
+        return (stringBuilder.length() == 0) ? "<data was deleted>" : stringBuilder.toString();
     }
 
     private void showStatus(Realm realm) {
-        String txt = realmString(realm);
+        showStatus(realmString(realm));
+    }
+
+    private void showStatus(String txt) {
         Log.i(TAG, txt);
         TextView tv = new TextView(this);
         tv.setText(txt);
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
index bf9fdbd173..e589375afa 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
@@ -16,121 +16,137 @@
 
 package io.realm.examples.realmmigrationexample.model;
 
-import io.realm.Realm;
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.FieldAttribute;
 import io.realm.RealmMigration;
-import io.realm.internal.ColumnType;
-import io.realm.internal.Table;
-
-/***************************** NOTE: *********************************************
- * The API for migration is currently using internal lower level classes that will
- * be replaced by a new API very soon! Until then you will have to explore and use
- * below example as inspiration.
- *********************************************************************************
- */
-
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 
+/**
+ * Example of migrating a Realm file from version 0 (initial version) to its last version (version 3).
+ */
 public class Migration implements RealmMigration {
+
     @Override
-    public long execute(Realm realm, long version) {
+    public void migrate(final DynamicRealm realm, long oldVersion, long newVersion) {
+        // During a migration, a DynamicRealm is exposed. A DynamicRealm is an untyped variant of a normal Realm, but
+        // with the same object creation and query capabilities.
+        // A DynamicRealm uses Strings instead of Class references because the Classes might not even exist or have been
+        // renamed.
+
+        // Access the Realm schema in order to create, modify or delete classes and their fields.
+        RealmSchema schema = realm.getSchema();
 
-        /*
+        /************************************************
             // Version 0
             class Person
-                String fullName;
+                @Required
+                String firstName;
+                @Required
                 String lastName;
                 int    age;
 
             // Version 1
             class Person
-                String fullName;        // combine firstName and lastName into single field
+                @Required
+                String fullName;            // combine firstName and lastName into single field.
                 int age;
-        */
-
+        ************************************************/
         // Migrate from version 0 to version 1
-        if (version == 0) {
-            Table personTable = realm.getTable(Person.class);
-
-            long fistNameIndex = getIndexForProperty(personTable, "firstName");
-            long lastNameIndex = getIndexForProperty(personTable, "lastName");
-            long fullNameIndex = personTable.addColumn(ColumnType.STRING, "fullName");
-            for (int i = 0; i < personTable.size(); i++) {
-                personTable.setString(fullNameIndex, i, personTable.getString(fistNameIndex, i) + " " +
-                        personTable.getString(lastNameIndex, i));
-            }
-            personTable.removeColumn(getIndexForProperty(personTable, "firstName"));
-            personTable.removeColumn(getIndexForProperty(personTable, "lastName"));
-            version++;
+        if (oldVersion == 0) {
+            RealmObjectSchema personSchema = schema.get("Person");
+
+            // Combine 'firstName' and 'lastName' in a new field called 'fullName'
+            personSchema
+                    .addField("fullName", String.class, FieldAttribute.REQUIRED)
+                    .transform(new RealmObjectSchema.Function() {
+                        @Override
+                        public void apply(DynamicRealmObject obj) {
+                            obj.set("fullName", obj.getString("firstName") + " " + obj.getString("lastName"));
+                        }
+                    })
+                    .removeField("firstName")
+                    .removeField("lastName");
+            oldVersion++;
         }
 
-        /*
+        /************************************************
             // Version 2
                 class Pet                   // add a new model class
+                    @Required
                     String name;
+                    @Required
                     String type;
 
                 class Person
+                    @Required
                     String fullName;
                     int age;
                     RealmList<Pet> pets;    // add an array property
 
-        */
+         ************************************************/
         // Migrate from version 1 to version 2
-        if (version == 1) {
-            Table personTable = realm.getTable(Person.class);
-            Table petTable = realm.getTable(Pet.class);
-            petTable.addColumn(ColumnType.STRING, "name");
-            petTable.addColumn(ColumnType.STRING, "type");
-            long petsIndex = personTable.addColumnLink(ColumnType.LINK_LIST, "pets", petTable);
-            long fullNameIndex = getIndexForProperty(personTable, "fullName");
-
-            for (int i = 0; i < personTable.size(); i++) {
-                if (personTable.getString(fullNameIndex, i).equals("JP McDonald")) {
-                    personTable.getRow(i).getLinkList(petsIndex).add(petTable.add("Jimbo", "dog"));
-                }
-            }
-            version++;
+        if (oldVersion == 1) {
+
+            // Create a new class
+            RealmObjectSchema petSchema = schema.create("Pet")
+                    .addField("name", String.class, FieldAttribute.REQUIRED)
+                    .addField("type", String.class, FieldAttribute.REQUIRED);
+
+            // Add a new field to an old class and populate it with initial data
+            schema.get("Person")
+                .addRealmListField("pets", petSchema)
+                .transform(new RealmObjectSchema.Function() {
+                    @Override
+                    public void apply(DynamicRealmObject obj) {
+                        if (obj.getString("fullName").equals("JP McDonald")) {
+                            DynamicRealmObject pet = realm.createObject("Pet");
+                            pet.setString("name", "Jimbo");
+                            pet.setString("type", "dog");
+                            obj.getList("pets").add(pet);
+                        }
+                    }
+                });
+            oldVersion++;
         }
 
-        /*
+        /************************************************
             // Version 3
                 class Pet
+                    @Required
                     String name;
                     int type;               // type becomes int
 
                 class Person
-                    String fullName;
-                    RealmList<Pet> pets;    // age and pets re-ordered
+                    String fullName;        // fullName is nullable now
+                    RealmList<Pet> pets;    // age and pets re-ordered (no action needed)
                     int age;
-        */
+         ************************************************/
         // Migrate from version 2 to version 3
-        if (version == 2) {
-            Table petTable = realm.getTable(Pet.class);
-            long oldTypeIndex = getIndexForProperty(petTable, "type");
-            long typeIndex = petTable.addColumn(ColumnType.INTEGER, "type");
-            for (int i = 0; i < petTable.size(); i++) {
-                String type = petTable.getString(oldTypeIndex, i);
-                if (type.equals("dog")) {
-                    petTable.setLong(typeIndex, i, 1);
-                }
-                else if (type.equals("cat")) {
-                    petTable.setLong(typeIndex, i, 2);
-                }
-                else if (type.equals("hamster")) {
-                    petTable.setLong(typeIndex, i, 3);
-                }
-            }
-            petTable.removeColumn(oldTypeIndex);
-            version++;
-        }
-        return version;
-    }
-
-    private long getIndexForProperty(Table table, String name) {
-        for (int i = 0; i < table.getColumnCount(); i++) {
-            if (table.getColumnName(i).equals(name)) {
-                return i;
-            }
+        if (oldVersion == 2) {
+            RealmObjectSchema personSchema = schema.get("Person");
+            personSchema.setNullable("fullName", true); // fullName is nullable now.
+
+            // Change type from String to int
+            schema.get("Pet")
+                .addField("type_tmp", int.class)
+                .transform(new RealmObjectSchema.Function() {
+                    @Override
+                    public void apply(DynamicRealmObject obj) {
+                        String oldType = obj.getString("type");
+                        if (oldType.equals("dog")) {
+                            obj.setLong("type_tmp", 1);
+                        } else if (oldType.equals("cat")) {
+                            obj.setInt("type_tmp", 2);
+                        } else if (oldType.equals("hamster")) {
+                            obj.setInt("type_tmp", 3);
+                        }
+                    }
+                })
+                .removeField("type")
+                .renameField("type_tmp", "type");
+            oldVersion++;
         }
-        return -1;
     }
 }
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Pet.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Pet.java
index 4a627725d0..acee00fccf 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Pet.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Pet.java
@@ -17,8 +17,10 @@
 package io.realm.examples.realmmigrationexample.model;
 
 import io.realm.RealmObject;
+import io.realm.annotations.Required;
 
 public class Pet extends RealmObject {
+    @Required
     private String name;
     private int type;
 
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
new file mode 100644
index 0000000000..b6e94ac171
--- /dev/null
+++ b/examples/moduleExample/app/build.gradle
@@ -0,0 +1,41 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.appmodules'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    signingConfigs {
+        release {
+            storeFile file("keystore/release.keystore")
+            storePassword "realm1234"
+            keyAlias "realm-introexample"
+            keyPassword "realm1234"
+        }
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled true
+            signingConfig signingConfigs.release
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+dependencies {
+    compile project(':moduleExample:library')
+}
diff --git a/examples/moduleExample/app/keystore/release.keystore b/examples/moduleExample/app/keystore/release.keystore
new file mode 100644
index 0000000000..939cfa830a
Binary files /dev/null and b/examples/moduleExample/app/keystore/release.keystore differ
diff --git a/examples/adapterExample/proguard-rules.pro b/examples/moduleExample/app/proguard-rules.pro
similarity index 100%
rename from examples/adapterExample/proguard-rules.pro
rename to examples/moduleExample/app/proguard-rules.pro
diff --git a/examples/moduleExample/app/src/main/AndroidManifest.xml b/examples/moduleExample/app/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9d2160c44e
--- /dev/null
+++ b/examples/moduleExample/app/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.appmodules" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".ModulesExampleActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
new file mode 100644
index 0000000000..b472e6d0cf
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.examples.appmodules.model.Cow;
+import io.realm.examples.appmodules.model.Pig;
+import io.realm.examples.appmodules.model.Snake;
+import io.realm.examples.appmodules.model.Spider;
+import io.realm.examples.appmodules.modules.CreepyAnimalsModule;
+import io.realm.examples.librarymodules.Zoo;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.model.Dog;
+import io.realm.examples.librarymodules.model.Elephant;
+import io.realm.examples.librarymodules.model.Lion;
+import io.realm.examples.librarymodules.model.Zebra;
+import io.realm.examples.librarymodules.modules.DomesticAnimalsModule;
+import io.realm.examples.librarymodules.modules.ZooAnimalsModule;
+import io.realm.exceptions.RealmException;
+
+/**
+* This example demonstrates how you can use modules to control which classes belong to which Realms and how you can
+ * work with multiple Realms at the same time.
+*/
+public class ModulesExampleActivity extends Activity {
+
+    public static final String TAG = ModulesExampleActivity.class.getName();
+    private LinearLayout rootLayout = null;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_modules_example);
+        rootLayout = ((LinearLayout) findViewById(R.id.container));
+        rootLayout.removeAllViews();
+
+        // The default Realm instance implicitly knows about all classes in the realmModuleAppExample Android Studio
+        // module. This does not include the classes from the realmModuleLibraryExample AS module so a Realm using this
+        // configuration would know about the following classes: { Cow, Pig, Snake, Spider }
+        RealmConfiguration defaultConfig = new RealmConfiguration.Builder(this).build();
+
+        // It is possible to extend the default schema by adding additional Realm modules using setModule(). This can
+        // also be Realm modules from libraries. The below Realm contains the following classes: { Cow, Pig, Snake,
+        // Spider, Cat, Dog }
+        RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
+                .name("farm.realm")
+                .setModules(Realm.getDefaultModule(), new DomesticAnimalsModule())
+                .build();
+
+        // Or you can completely replace the default schema.
+        // This Realm contains the following classes: { Elephant, Lion, Zebra, Snake, Spider }
+        RealmConfiguration exoticAnimalsConfig = new RealmConfiguration.Builder(this)
+                .name("exotic.realm")
+                .setModules(new ZooAnimalsModule(), new CreepyAnimalsModule())
+                .build();
+
+        // Multiple Realms can be open at the same time
+        showStatus("Opening multiple Realms");
+        Realm defaultRealm = Realm.getInstance(defaultConfig);
+        Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
+        Realm exoticRealm = Realm.getInstance(exoticAnimalsConfig);
+
+        // Objects can be added to each Realm independantly
+        showStatus("Create objects in the default Realm");
+        defaultRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Cow.class);
+                realm.createObject(Pig.class);
+                realm.createObject(Snake.class);
+                realm.createObject(Spider.class);
+            }
+        });
+
+        showStatus("Create objects in the farm Realm");
+        farmRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Cow.class);
+                realm.createObject(Pig.class);
+                realm.createObject(Cat.class);
+                realm.createObject(Dog.class);
+            }
+        });
+
+        showStatus("Create objects in the exotic Realm");
+        exoticRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Elephant.class);
+                realm.createObject(Lion.class);
+                realm.createObject(Zebra.class);
+                realm.createObject(Snake.class);
+                realm.createObject(Spider.class);
+            }
+        });
+
+        // You can copy objects between Realms
+        showStatus("Copy objects between Realms");
+        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+        showStatus("Copy pig from defaultRealm to farmRealm");
+        Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
+        farmRealm.beginTransaction();
+        farmRealm.copyToRealm(defaultPig);
+        farmRealm.commitTransaction();
+        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+
+        // Each Realm is restricted to only accept the classes in their schema.
+        showStatus("Trying to add an unsupported class");
+        defaultRealm.beginTransaction();
+        try {
+            defaultRealm.createObject(Elephant.class);
+        } catch (RealmException expected) {
+            showStatus("This throws a :" + expected.toString());
+        } finally {
+            defaultRealm.cancelTransaction();
+        }
+
+        // And Realms in library projects are independent from Realms in the app code
+        showStatus("Interacting with library code that uses Realm internally");
+        int animals = 5;
+        Zoo libraryZoo = new Zoo(this);
+        libraryZoo.open();
+        showStatus("Adding animals: " + animals);
+        libraryZoo.addAnimals(5);
+        showStatus("Number of animals in the library Realm:" + libraryZoo.getNoOfAnimals());
+        libraryZoo.close();
+
+        // Remember to close all open Realms
+        defaultRealm.close();
+        farmRealm.close();
+        exoticRealm.close();
+    }
+
+    private void showStatus(String txt) {
+        Log.i(TAG, txt);
+        TextView tv = new TextView(this);
+        tv.setText(txt);
+        rootLayout.addView(tv);
+    }
+}
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java
new file mode 100644
index 0000000000..b3cbcc6cd4
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Cow extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
new file mode 100644
index 0000000000..ef9e5ba860
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Pig extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/Simple.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java
similarity index 76%
rename from realm-annotations-processor/src/test/resources/some/test/Simple.java
rename to examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java
index 82fe180a0e..21e885e26e 100644
--- a/realm-annotations-processor/src/test/resources/some/test/Simple.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package some.test;
+package io.realm.examples.appmodules.model;
 
 import io.realm.RealmObject;
 
-public class Simple extends RealmObject {
+public class Snake extends RealmObject {
+
     private String name;
-    private int age;
 
     public String getName() {
         return name;
@@ -30,11 +30,4 @@ public void setName(String name) {
         this.name = name;
     }
 
-    public int getAge() {
-        return age;
-    }
-
-    public void setAge(int age) {
-        this.age = age;
-    }
-}
\ No newline at end of file
+}
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java
new file mode 100644
index 0000000000..77255ba087
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Spider extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java
new file mode 100644
index 0000000000..b3ebeb39a5
--- /dev/null
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.appmodules.model.Snake;
+import io.realm.examples.appmodules.model.Spider;
+
+@RealmModule(classes = {Snake.class, Spider.class})
+public class CreepyAnimalsModule {
+}
diff --git a/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
new file mode 100644
index 0000000000..f7891e6991
--- /dev/null
+++ b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
@@ -0,0 +1,29 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:gravity="center_horizontal"
+            android:text="Status Output..."
+            android:textStyle="bold"
+            android:textSize="18sp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+        <LinearLayout
+            android:id="@+id/container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:paddingTop="10sp"
+            android:orientation="vertical"
+            tools:context=".RealmIntroExample"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/gradle-plugin/sample/src/main/res/values-w820dp/dimens.xml b/examples/moduleExample/app/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from gradle-plugin/sample/src/main/res/values-w820dp/dimens.xml
rename to examples/moduleExample/app/src/main/res/values-w820dp/dimens.xml
diff --git a/gradle-plugin/sample/src/main/res/values/dimens.xml b/examples/moduleExample/app/src/main/res/values/dimens.xml
similarity index 100%
rename from gradle-plugin/sample/src/main/res/values/dimens.xml
rename to examples/moduleExample/app/src/main/res/values/dimens.xml
diff --git a/examples/moduleExample/app/src/main/res/values/strings.xml b/examples/moduleExample/app/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..d6848f4045
--- /dev/null
+++ b/examples/moduleExample/app/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">RealmModule example</string>
+
+</resources>
diff --git a/experimental/pathExperiment/src/main/res/values/styles.xml b/examples/moduleExample/app/src/main/res/values/styles.xml
similarity index 61%
rename from experimental/pathExperiment/src/main/res/values/styles.xml
rename to examples/moduleExample/app/src/main/res/values/styles.xml
index 766ab99304..ff6c9d2c0f 100644
--- a/experimental/pathExperiment/src/main/res/values/styles.xml
+++ b/examples/moduleExample/app/src/main/res/values/styles.xml
@@ -1,7 +1,7 @@
 <resources>
 
     <!-- Base application theme. -->
-    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
         <!-- Customize your theme here. -->
     </style>
 
diff --git a/examples/moduleExample/library/build.gradle b/examples/moduleExample/library/build.gradle
new file mode 100644
index 0000000000..c4e79639f9
--- /dev/null
+++ b/examples/moduleExample/library/build.gradle
@@ -0,0 +1,21 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.library'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
diff --git a/examples/moduleExample/library/src/main/AndroidManifest.xml b/examples/moduleExample/library/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9c9b59f7e0
--- /dev/null
+++ b/examples/moduleExample/library/src/main/AndroidManifest.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.librarymodules" >
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name" >
+    </application>
+
+</manifest>
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
new file mode 100644
index 0000000000..bddcffaaa3
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules;
+
+import android.content.Context;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.modules.AllAnimalsModule;
+
+/**
+ * Library projects can also use Realms, but some configuration options are mandatory to avoid clashing with Realms used
+ * in the app code.
+ */
+public class Zoo {
+
+    private final RealmConfiguration realmConfig;
+    private Realm realm;
+
+    public Zoo(Context context) {
+        realmConfig = new RealmConfiguration.Builder(context) // Beware this is the app context
+                .name("library.zoo.realm")                    // So always use a unique name
+                .setModules(new AllAnimalsModule())           // Always use explicit modules in library projects
+                .build();
+
+        // Reset Realm
+        Realm.deleteRealm(realmConfig);
+    }
+
+    public void open() {
+        // Don't use Realm.setDefaultInstance() in library projects. It is unsafe as app developers can override the
+        // default configuration. So always use explicit configurations in library projects.
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    public long getNoOfAnimals() {
+        return realm.where(Cat.class).count();
+    }
+
+    public void addAnimals(int count) {
+        realm.beginTransaction();
+        for (int i = 0; i < count; i++) {
+            Cat cat = realm.createObject(Cat.class);
+            cat.setName("Cat " + i);
+        }
+        realm.commitTransaction();
+    }
+
+    public void close() {
+        realm.close();
+    }
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
similarity index 79%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
rename to examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
index d497d08f68..fd3a999540 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service.model;
+package io.realm.examples.librarymodules.model;
 
 import io.realm.RealmObject;
 
 public class Cat extends RealmObject {
+
     private String name;
 
     public String getName() {
@@ -28,11 +29,4 @@ public String getName() {
     public void setName(String name) {
         this.name = name;
     }
-
-    @Override
-    public String toString() {
-        return "Cat{" +
-                "name='" + name + '\'' +
-                '}';
-    }
 }
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
similarity index 79%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
rename to examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
index 209e0ee885..92587f3c84 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service.model;
+package io.realm.examples.librarymodules.model;
 
 import io.realm.RealmObject;
 
 public class Dog extends RealmObject {
+
     private String name;
 
     public String getName() {
@@ -28,11 +29,4 @@ public String getName() {
     public void setName(String name) {
         this.name = name;
     }
-
-    @Override
-    public String toString() {
-        return "Dog{" +
-                "name='" + name + '\'' +
-                '}';
-    }
 }
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java
new file mode 100644
index 0000000000..4635b94417
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Elephant extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java
new file mode 100644
index 0000000000..89f75ba5f8
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Lion extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java
new file mode 100644
index 0000000000..3bb7da92cd
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Zebra extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java
new file mode 100644
index 0000000000..a1b1dd1f0f
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.modules;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, allClasses = true)
+public class AllAnimalsModule {
+}
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java
new file mode 100644
index 0000000000..bd50adbe90
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.model.Dog;
+
+@RealmModule(library = true, classes = {Cat.class, Dog.class})
+public class DomesticAnimalsModule {
+}
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java
new file mode 100644
index 0000000000..e572e86a9e
--- /dev/null
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.librarymodules.model.Elephant;
+import io.realm.examples.librarymodules.model.Lion;
+import io.realm.examples.librarymodules.model.Zebra;
+
+@RealmModule(library = true, classes = {Elephant.class, Lion.class, Zebra.class})
+public class ZooAnimalsModule {
+}
diff --git a/examples/moduleExample/library/src/main/res/values/strings.xml b/examples/moduleExample/library/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..051a90f592
--- /dev/null
+++ b/examples/moduleExample/library/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">RealmModule Library Example</string>
+
+</resources>
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
new file mode 100644
index 0000000000..021e3dd644
--- /dev/null
+++ b/examples/newsreaderExample/build.gradle
@@ -0,0 +1,47 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId "io.realm.examples.newsreader"
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+    command {
+        events 2000
+    }
+    lintOptions {
+        disable 'InvalidPackage'
+    }
+    packagingOptions {
+        exclude 'META-INF/services/javax.annotation.processing.Processor'
+        exclude 'META-INF/NOTICE'
+        exclude 'META-INF/LICENSE'
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile 'com.android.support:design:23.1.1'
+    compile 'io.reactivex:rxjava:1.1.0'
+    compile 'io.reactivex:rxandroid:1.1.0'
+    compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
+    compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
+    compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
+    compile 'com.jakewharton.timber:timber:4.1.0'
+    compile 'com.jakewharton:butterknife:7.0.1'
+    compile 'me.zhanghai.android.materialprogressbar:library:1.1.4'
+}
diff --git a/examples/newsreaderExample/src/debug/AndroidManifest.xml b/examples/newsreaderExample/src/debug/AndroidManifest.xml
new file mode 100644
index 0000000000..d044658dcf
--- /dev/null
+++ b/examples/newsreaderExample/src/debug/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.examples.newsreader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application android:name=".DebugNewsReaderApplication"/>
+</manifest>
diff --git a/examples/newsreaderExample/src/debug/java/io/realm/examples/newsreader/DebugNewsReaderApplication.java b/examples/newsreaderExample/src/debug/java/io/realm/examples/newsreader/DebugNewsReaderApplication.java
new file mode 100644
index 0000000000..23abd80815
--- /dev/null
+++ b/examples/newsreaderExample/src/debug/java/io/realm/examples/newsreader/DebugNewsReaderApplication.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader;
+
+import timber.log.Timber;
+
+/**
+ * Debug specific application setup.
+ */
+public class DebugNewsReaderApplication extends NewsReaderApplication {
+    @Override
+    protected void initializeTimber() {
+        Timber.plant(new Timber.DebugTree());
+    }
+}
diff --git a/examples/newsreaderExample/src/main/AndroidManifest.xml b/examples/newsreaderExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..c45071ebec
--- /dev/null
+++ b/examples/newsreaderExample/src/main/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.examples.newsreader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme.NoActionBar">
+        <activity
+            android:name=".ui.main.MainActivity"
+            android:label="@string/app_name"
+            android:theme="@style/AppTheme.NoActionBar">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+        <activity android:name=".ui.details.DetailsActivity" />
+    </application>
+
+</manifest>
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
new file mode 100644
index 0000000000..d8f575dd1a
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader;
+
+import android.app.Application;
+import android.content.Context;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import rx.plugins.RxJavaErrorHandler;
+import rx.plugins.RxJavaPlugins;
+import timber.log.Timber;
+
+public abstract class NewsReaderApplication extends Application {
+
+    private static Context context;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        context = this;
+
+        initializeTimber();
+        RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
+            @Override
+            public void handleError(Throwable e) {
+                super.handleError(e);
+                Timber.e(e.toString());
+            }
+        });
+
+        // Configure default configuration for Realm
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
+        Realm.setDefaultConfiguration(realmConfig);
+    }
+
+    /**
+     * Initialize Timber logging
+     */
+    protected abstract void initializeTimber();
+
+    public static Context getContext() {
+        return context;
+    }
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java
new file mode 100644
index 0000000000..bfd914f6ad
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model;
+
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.RealmResults;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import rx.Observable;
+import rx.functions.Func1;
+
+/**
+ * Model class for handling the business rules of the app.
+ */
+public class Model {
+
+    /**
+     * Map between section titles and their NYTimes API keys
+     */
+    private static final Map<String, String> sections;
+    static {
+        sections = new HashMap<>();
+        sections.put("home", "Home");
+        sections.put("world", "World");
+        sections.put("national", "National");
+        sections.put("politics", "Politics");
+        sections.put("nyregion", "NY Region");
+        sections.put("business", "Business");
+        sections.put("opinion", "Opinion");
+        sections.put("technology", "Technology");
+        sections.put("science", "Science");
+        sections.put("health", "Health");
+        sections.put("sports", "Sports");
+        sections.put("arts", "Arts");
+        sections.put("fashion", "Fashion");
+        sections.put("dining", "Dining");
+        sections.put("travel", "Travel");
+        sections.put("magazine", "Magazine");
+        sections.put("realestate", "Real Estate");
+    }
+
+    private static Model instance = null;
+    private final Repository repository;
+    private String selectedSection;
+
+    // This could be replaced by Dependency Injection for easier testing
+    public static synchronized Model getInstance() {
+        if (instance == null) {
+            Repository repository = new Repository();
+            instance = new Model(repository);
+        }
+        return instance;
+    }
+
+    private Model(Repository repository) {
+        this.repository = repository;
+        this.selectedSection = "home";
+    }
+
+    /**
+     * Returns the news feed for the currently selected category.
+     */
+    public Observable<RealmResults<NYTimesStory>> getSelectedNewsFeed() {
+        return repository.loadNewsFeed(selectedSection, false);
+    }
+
+    /**
+     * Forces a reload of the newsfeed
+     */
+    public void reloadNewsFeed() {
+        repository.loadNewsFeed(selectedSection, true);
+    }
+
+    /**
+     * Returns the current state of network usage.
+     */
+    public Observable<Boolean> isNetworkUsed() {
+        return repository.networkInUse().distinctUntilChanged();
+    }
+
+    /**
+     * Marks a story as being read.
+     */
+    public void markAsRead(@NonNull String storyId, boolean read) {
+        repository.updateStoryReadState(storyId, read);
+    }
+
+    /**
+     * Returns the story with the given Id
+     */
+    public Observable<NYTimesStory> getStory(@NonNull final String storyId) {
+        // Repository is only responsible for loading the data
+        // Any validation is done by the model
+        // See http://blog.danlew.net/2015/12/08/error-handling-in-rxjava/
+        if (TextUtils.isEmpty(storyId)) {
+            throw new IllegalArgumentException("Invalid storyId: " + storyId);
+        }
+        return repository.loadStory(storyId)
+                .filter(new Func1<NYTimesStory, Boolean>() {
+                    @Override
+                    public Boolean call(NYTimesStory story) {
+                        return story.isValid();
+                    }
+                });
+    }
+
+    /**
+     * Returns all sections available.
+     *
+     * @return A map of <key, title> pairs for all available sections.
+     */
+    public Map<String, String> getSections() {
+        return sections;
+    }
+
+    public void selectSection(@NonNull String key) {
+        selectedSection = key;
+        repository.loadNewsFeed(selectedSection, false);
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        repository.close();
+    }
+
+    public @NonNull String getCurrentSectionKey() {
+        return selectedSection;
+    }
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
new file mode 100644
index 0000000000..f93ce531cc
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.UiThread;
+
+import java.io.Closeable;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.Sort;
+import io.realm.examples.newsreader.NewsReaderApplication;
+import io.realm.examples.newsreader.R;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import io.realm.examples.newsreader.model.network.NYTimesDataLoader;
+import rx.Observable;
+import rx.functions.Func1;
+import rx.subjects.BehaviorSubject;
+import timber.log.Timber;
+
+/**
+ * Class for handling loading and saving data.
+ *
+ * A repository is a potentially expensive resource to have in memory, so should be closed when no longer needed/used.
+ *
+ * @see <a href="http://martinfowler.com/eaaCatalog/repository.html">Repository pattern</a>
+ */
+public class Repository implements Closeable {
+
+    private static final long MINIMUM_NETWORK_WAIT_SEC = 120; // Minimum 2 minutes between each network request
+
+    private final Realm realm;
+    private final NYTimesDataLoader dataLoader;
+    private final String apiKey;
+    private Map<String, Long> lastNetworkRequest = new HashMap<>();
+    private BehaviorSubject<Boolean> networkLoading = BehaviorSubject.create(false);
+
+    @UiThread
+    public Repository() {
+        realm = Realm.getDefaultInstance();
+        dataLoader = new NYTimesDataLoader();
+        apiKey = NewsReaderApplication.getContext().getString(R.string.nyc_top_stories_api_key);
+    }
+
+    /**
+     * Keeps track of the current network state.
+     *
+     * @return {@code true} if the network is currently being used, {@code false} otherwise.
+     */
+    @UiThread
+    public Observable<Boolean> networkInUse() {
+        return networkLoading.asObservable();
+    }
+
+    /**
+     * Loads the news feed as well as all future updates.
+     */
+    @UiThread
+    public Observable<RealmResults<NYTimesStory>> loadNewsFeed(@NonNull String sectionKey, boolean forceReload) {
+        // Start loading data from the network if needed
+        // It will put all data into Realm
+        if (forceReload || timeSinceLastNetworkRequest(sectionKey) > MINIMUM_NETWORK_WAIT_SEC) {
+            dataLoader.loadData(sectionKey, apiKey, realm, networkLoading);
+            lastNetworkRequest.put(sectionKey, System.currentTimeMillis());
+        }
+
+        // Return the data in Realm. The query result will be automatically updated when the network requests
+        // save data in Realm
+        return realm.where(NYTimesStory.class).equalTo(NYTimesStory.API_SECTION, sectionKey)
+                .findAllSortedAsync(NYTimesStory.PUBLISHED_DATE, Sort.DESCENDING)
+                .asObservable();
+    }
+
+    private long timeSinceLastNetworkRequest(@NonNull String sectionKey) {
+        Long lastRequest = lastNetworkRequest.get(sectionKey);
+        if (lastRequest != null) {
+            return TimeUnit.SECONDS.convert(System.currentTimeMillis() - lastRequest, TimeUnit.MILLISECONDS);
+        } else {
+            return Long.MAX_VALUE;
+        }
+    }
+
+    /**
+     * Updates a story.
+     *
+     * @param storyId story to update
+     * @param read {@code true} if the story has been read, {@code false} otherwise.
+     */
+    @UiThread
+    public void updateStoryReadState(final String storyId, final boolean read) {
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                NYTimesStory persistedStory = realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, storyId).findFirst();
+                if (persistedStory != null) {
+                    persistedStory.setRead(read);
+                } else {
+                    Timber.e("Trying to update a story that no longer exists: " + storyId);
+                }
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable throwable) {
+                Timber.e(throwable, "Failed to save data.");
+            }
+        });
+    }
+
+    /**
+     * Returns story details
+     */
+    @UiThread
+    public Observable<NYTimesStory> loadStory(final String storyId) {
+        return realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, storyId).findFirstAsync()
+                .<NYTimesStory>asObservable()
+                .filter(new Func1<NYTimesStory, Boolean>() {
+                    @Override
+                    public Boolean call(NYTimesStory story) {
+                        return story.isLoaded();
+                    }
+                });
+    }
+
+    /**
+     * Closes all underlying resources used by the Repository.
+     */
+    @UiThread
+    public void close() {
+        realm.close();
+    }
+
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesMultimedium.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesMultimedium.java
new file mode 100644
index 0000000000..14eb620634
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesMultimedium.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model.entity;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class NYTimesMultimedium extends RealmObject {
+
+    @PrimaryKey
+    @JsonProperty("url")
+    private String url;
+
+    @JsonProperty("format")
+    private String format;
+
+    @JsonProperty("height")
+    private int height;
+
+    @JsonProperty("width")
+    private int width;
+
+    @JsonProperty("type")
+    private String type;
+
+    @JsonProperty("subtype")
+    private String subtype;
+
+    @JsonProperty("caption")
+    private String caption;
+
+    @JsonProperty("copyright")
+    private String copyright;
+
+    public String getUrl() {
+        return url;
+    }
+
+    public void setUrl(String url) {
+        this.url = url;
+    }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public void setFormat(String format) {
+        this.format = format;
+    }
+
+    public int getHeight() {
+        return height;
+    }
+
+    public void setHeight(int height) {
+        this.height = height;
+    }
+
+    public int getWidth() {
+        return width;
+    }
+
+    public void setWidth(int width) {
+        this.width = width;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public String getSubtype() {
+        return subtype;
+    }
+
+    public void setSubtype(String subtype) {
+        this.subtype = subtype;
+    }
+
+    public String getCaption() {
+        return caption;
+    }
+
+    public void setCaption(String caption) {
+        this.caption = caption;
+    }
+
+    public String getCopyright() {
+        return copyright;
+    }
+
+    public void setCopyright(String copyright) {
+        this.copyright = copyright;
+    }
+}
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesStory.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesStory.java
new file mode 100644
index 0000000000..80c6866667
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/entity/NYTimesStory.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model.entity;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.examples.newsreader.model.network.RealmListNYTimesMultimediumDeserializer;
+
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class NYTimesStory extends RealmObject {
+
+    public static final String PUBLISHED_DATE = "publishedDate";
+    public static final String URL = "url";
+    public static final String API_SECTION = "apiSection";
+
+    private String apiSection;
+
+    @JsonProperty("section")
+    private String section;
+
+    @JsonProperty("subsection")
+    private String subsection;
+
+    @JsonProperty("title")
+    private String title;
+
+    @JsonProperty("abstract")
+    private String storyAbstract;
+
+    @PrimaryKey
+    @JsonProperty("url")
+    private String url;
+
+    @JsonProperty("byline")
+    private String byline;
+
+    @JsonProperty("item_type")
+    private String itemType;
+
+    @JsonProperty("updated_date")
+    private String updatedDate;
+
+    @JsonProperty("created_date")
+    private String createdDate;
+
+    @JsonProperty("published_date")
+    private String publishedDate;
+
+    @JsonProperty("material_type_facet")
+    private String materialTypeFacet;
+
+    @JsonProperty("kicker")
+    private String kicker;
+
+    @JsonProperty("multimedia")
+    private RealmList<NYTimesMultimedium> multimedia;
+
+    private long sortTimeStamp;
+    private boolean read;
+
+    public String getSection() {
+        return section;
+    }
+
+    public void setSection(String section) {
+        this.section = section;
+    }
+
+    public String getSubsection() {
+        return subsection;
+    }
+
+    public void setSubsection(String subsection) {
+        this.subsection = subsection;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getStoryAbstract() {
+        return storyAbstract;
+    }
+
+    public void setStoryAbstract(String storyAbstract) {
+        this.storyAbstract = storyAbstract;
+    }
+
+    public String getUrl() {
+        return url;
+    }
+
+    public void setUrl(String url) {
+        this.url = url;
+    }
+
+    public String getByline() {
+        return byline;
+    }
+
+    public void setByline(String byline) {
+        this.byline = byline;
+    }
+
+    public String getItemType() {
+        return itemType;
+    }
+
+    public void setItemType(String itemType) {
+        this.itemType = itemType;
+    }
+
+    public String getUpdatedDate() {
+        return updatedDate;
+    }
+
+    public void setUpdatedDate(String updatedDate) {
+        this.updatedDate = updatedDate;
+    }
+
+    public String getCreatedDate() {
+        return createdDate;
+    }
+
+    public void setCreatedDate(String createdDate) {
+        this.createdDate = createdDate;
+    }
+
+    public String getPublishedDate() {
+        return publishedDate;
+    }
+
+    public void setPublishedDate(String publishedDate) {
+        this.publishedDate = publishedDate;
+    }
+
+    public String getMaterialTypeFacet() {
+        return materialTypeFacet;
+    }
+
+    public void setMaterialTypeFacet(String materialTypeFacet) {
+        this.materialTypeFacet = materialTypeFacet;
+    }
+
+    public String getKicker() {
+        return kicker;
+    }
+
+    public void setKicker(String kicker) {
+        this.kicker = kicker;
+    }
+
+    public RealmList<NYTimesMultimedium> getMultimedia() {
+        return multimedia;
+    }
+
+    @JsonDeserialize(using = RealmListNYTimesMultimediumDeserializer.class)
+    public void setMultimedia(RealmList<NYTimesMultimedium> multimedia) {
+        this.multimedia = multimedia;
+    }
+
+    public long getSortTimeStamp() {
+        return sortTimeStamp;
+    }
+
+    public void setSortTimeStamp(long sortTimeStamp) {
+        this.sortTimeStamp = sortTimeStamp;
+    }
+
+    public boolean isRead() {
+        return read;
+    }
+
+    public void setRead(boolean read) {
+        this.read = read;
+    }
+
+    public String getApiSection() {
+        return apiSection;
+    }
+
+    public void setApiSection(String apiSection) {
+        this.apiSection = apiSection;
+    }
+}
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java
new file mode 100644
index 0000000000..c9be445097
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model.network;
+
+import android.support.annotation.NonNull;
+
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import io.realm.Realm;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import retrofit.JacksonConverterFactory;
+import retrofit.Retrofit;
+import retrofit.RxJavaCallAdapterFactory;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.functions.Action1;
+import rx.schedulers.Schedulers;
+import rx.subjects.BehaviorSubject;
+import timber.log.Timber;
+
+/**
+ * Class that handles network requests for the New York Times API
+ */
+public class NYTimesDataLoader {
+
+    private NYTimesService nyTimesService;
+    private SimpleDateFormat inputDateFormat = new SimpleDateFormat("yyyy-MM-d'T'HH:mm:ssZZZZZ", Locale.US);
+    private SimpleDateFormat outputDateFormat = new SimpleDateFormat("MM-dd-yyyy", Locale.US);
+    private String apiKey;
+    private Realm realm;
+    private BehaviorSubject<Boolean> networkInUse;
+
+    public NYTimesDataLoader() {
+        Retrofit retrofit = new Retrofit.Builder()
+                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .addConverterFactory(JacksonConverterFactory.create())
+                .baseUrl("http://api.nytimes.com/")
+                .build();
+        nyTimesService = retrofit.create(NYTimesService.class);
+    }
+
+    public void loadData(String sectionKey, String apiKey, Realm realm, BehaviorSubject<Boolean> networkLoading) {
+        this.apiKey = apiKey;
+        this.realm = realm;
+        this.networkInUse = networkLoading;
+        loadNextSection(sectionKey);
+    }
+
+    // Load all sections one by one.
+    private void loadNextSection(@NonNull final String sectionKey) {
+        networkInUse.onNext(true);
+        nyTimesService.topStories(sectionKey, apiKey)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Action1<NYTimesResponse<List<NYTimesStory>>>() {
+                    @Override
+                    public void call(NYTimesResponse<List<NYTimesStory>> response) {
+                        Timber.d("Success - Data received: %s", sectionKey);
+                        processAndAddData(realm, response.section, response.results);
+                        networkInUse.onNext(false);
+                    }
+                }, new Action1<Throwable>() {
+                    @Override
+                    public void call(Throwable throwable) {
+                        networkInUse.onNext(false);
+                        Timber.d("Failure: Data not loaded: %s - %s", sectionKey, throwable.toString());
+                    }
+                });
+    }
+
+    // Converts data into a usable format and save it to Realm
+    private void processAndAddData(final Realm realm, final String sectionKey, final List<NYTimesStory> stories) {
+        if (stories.isEmpty()) return;
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (NYTimesStory story : stories) {
+                    Date parsedPublishedDate = inputDateFormat.parse(story.getPublishedDate(), new ParsePosition(0));
+                    story.setSortTimeStamp(parsedPublishedDate.getTime());
+                    story.setPublishedDate(outputDateFormat.format(parsedPublishedDate));
+
+                    // Find existing story in Realm (if any)
+                    // If it exists, we need to merge the local state with the remote, because the local state
+                    // contains more info than is available on the server.
+                    NYTimesStory persistedStory = realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, story.getUrl()).findFirst();
+                    if (persistedStory != null) {
+                        // Only local state is the `read` boolean.
+                        story.setRead(persistedStory.isRead());
+                   }
+
+                    // Only create or update the local story if needed
+                    if (persistedStory == null || !persistedStory.getUpdatedDate().equals(story.getUpdatedDate())) {
+                        story.setApiSection(sectionKey);
+                        realm.copyToRealmOrUpdate(story);
+                    }
+                }
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable throwable) {
+                Timber.e(throwable, "Could not save data");
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/experimental/pathExperiment/src/main/java/io/realm/path/Person.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesResponse.java
similarity index 52%
rename from experimental/pathExperiment/src/main/java/io/realm/path/Person.java
rename to examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesResponse.java
index 934da502a6..1a00af80ac 100644
--- a/experimental/pathExperiment/src/main/java/io/realm/path/Person.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesResponse.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,28 +14,27 @@
  * limitations under the License.
  */
 
-package io.realm.path;
+package io.realm.examples.newsreader.model.network;
 
-import io.realm.RealmObject;
+import com.fasterxml.jackson.annotation.JsonProperty;
 
-public class Person extends RealmObject {
+public class NYTimesResponse<T> {
 
-    private String person;
-    private int age;
+    @JsonProperty("status")
+    public String status;
 
-    public String getPerson() {
-        return person;
-    }
+    @JsonProperty("copyright")
+    public String copyright;
 
-    public void setPerson(String person) {
-        this.person = person;
-    }
+    @JsonProperty("section")
+    public String section;
 
-    public int getAge() {
-        return age;
-    }
+    @JsonProperty("last_updated")
+    public String lastUpdated;
 
-    public void setAge(int age) {
-        this.age = age;
-    }
-}
+    @JsonProperty("num_results")
+    public Integer numResults;
+
+    @JsonProperty("results")
+    public T results;
+}
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java
new file mode 100644
index 0000000000..a234cfede0
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model.network;
+
+
+import java.util.List;
+
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import retrofit.http.GET;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import rx.Observable;
+
+/**
+ * Retrofit interface for the New York Times WebService
+ */
+public interface NYTimesService {
+    @GET("svc/topstories/v1/{section}.json")
+    Observable<NYTimesResponse<List<NYTimesStory>>> topStories(
+            @Path("section") String section,
+            @Query(value = "api-key", encoded = true) String apiKey);
+}
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
new file mode 100644
index 0000000000..03bfeb1f96
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.model.network;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.TreeNode;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+
+import java.io.IOException;
+import java.util.List;
+
+import io.realm.RealmList;
+import io.realm.examples.newsreader.model.entity.NYTimesMultimedium;
+
+public class RealmListNYTimesMultimediumDeserializer extends JsonDeserializer<List<NYTimesMultimedium>> {
+
+    ObjectMapper objectMapper;
+
+    public RealmListNYTimesMultimediumDeserializer() {
+        objectMapper = new ObjectMapper();
+    }
+
+    @Override
+    public List<NYTimesMultimedium> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
+        RealmList<NYTimesMultimedium> list = new RealmList<>();
+
+        TreeNode treeNode = jp.getCodec().readTree(jp);
+        if (!(treeNode instanceof ArrayNode)) {
+            return list;
+        }
+
+        ArrayNode arrayNode = (ArrayNode) treeNode;
+        for (JsonNode node : arrayNode) {
+            NYTimesMultimedium nyTimesMultimedium =
+                    objectMapper.treeToValue(node, NYTimesMultimedium.class);
+            list.add(nyTimesMultimedium);
+        }
+        return list;
+    }
+}
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/Presenter.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/Presenter.java
new file mode 100644
index 0000000000..277c91333d
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/Presenter.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.ui;
+
+/**
+ * Interface for all presenters. It should as a minimum be notified when important lifecycle events happen.
+ */
+public interface Presenter {
+    void onCreate();
+    void onPause();
+    void onResume();
+    void onDestroy();
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
new file mode 100644
index 0000000000..530590661e
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.ui.details;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.view.View;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+import io.realm.examples.newsreader.R;
+import io.realm.examples.newsreader.model.Model;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+
+public class DetailsActivity extends AppCompatActivity {
+
+    private static final String KEY_STORY_ID = "key.storyId";
+
+    @Bind(R.id.details_text) TextView detailsView;
+    @Bind(R.id.read_text) TextView readView;
+    @Bind(R.id.date_text) TextView dateView;
+    @Bind(R.id.loader_view) ProgressBar loaderView;
+
+    private Toolbar toolbar;
+    private DetailsPresenter presenter;
+
+    public static Intent getIntent(Context context, NYTimesStory story) {
+        Intent intent = new Intent(context, DetailsActivity.class);
+        intent.putExtra(KEY_STORY_ID, story.getUrl());
+        return intent;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Setup initial views
+        setContentView(R.layout.activity_details);
+        ButterKnife.bind(this);
+        toolbar = (Toolbar) findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+        loaderView.setVisibility(View.VISIBLE);
+
+        // After setup, notify presenter
+        String storyId = getIntent().getExtras().getString(KEY_STORY_ID);
+        presenter = new DetailsPresenter(this, Model.getInstance(), storyId);
+        presenter.onCreate();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        presenter.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        presenter.onPause();
+    }
+
+    public void showLoader() {
+        loaderView.setAlpha(1.0f);
+        loaderView.setVisibility(View.VISIBLE);
+    }
+
+    public void hideLoader() {
+        if (loaderView.getVisibility() != View.GONE) {
+            loaderView.animate().alpha(0f).setListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    loaderView.setVisibility(View.GONE);
+                }
+            });
+        }
+    }
+
+    public void showStory(NYTimesStory story) {
+        toolbar.setTitle(story.getTitle());
+        detailsView.setText(story.getStoryAbstract());
+        dateView.setText(story.getPublishedDate());
+    }
+
+    public void setRead(boolean read) {
+        if (read) {
+            readView.setText("READ");
+            readView.animate().alpha(1.0f);
+        } else {
+            readView.setText("");
+            readView.animate().alpha(0f);
+        }
+    }
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java
new file mode 100644
index 0000000000..0efde8359c
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.ui.details;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.examples.newsreader.model.Model;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import io.realm.examples.newsreader.ui.Presenter;
+import rx.Observable;
+import rx.Subscription;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.functions.Action1;
+import rx.subscriptions.CompositeSubscription;
+
+/**
+ * Presenter class for controlling the Main Activity
+ */
+public class DetailsPresenter implements Presenter {
+
+    private final DetailsActivity view;
+    private final Model model;
+    private final String storyId;
+    private CompositeSubscription subscriptions;
+
+    public DetailsPresenter(DetailsActivity detailsActivity, Model model, String storyId) {
+        this.storyId = storyId;
+        this.view = detailsActivity;
+        this.model = model;
+    }
+
+    @Override
+    public void onCreate() {
+        view.showLoader();
+    }
+
+    @Override
+    public void onResume() {
+        // Show story details
+        Subscription detailsSubscription = model.getStory(storyId)
+                .subscribe(new Action1<NYTimesStory>() {
+                    @Override
+                    public void call(NYTimesStory story) {
+                        view.hideLoader();
+                        view.showStory(story);
+                        view.setRead(story.isRead());
+                    }
+                });
+
+        // Mark story as read if screen is visible for 2 seconds
+        Subscription timerSubscription = Observable.timer(2, TimeUnit.SECONDS)
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Action1<Long>() {
+                    @Override
+                    public void call(Long aLong) {
+                        model.markAsRead(storyId, true);
+                    }
+                });
+        
+        subscriptions = new CompositeSubscription(detailsSubscription, timerSubscription);
+    }
+
+    @Override
+    public void onPause() {
+        subscriptions.unsubscribe();
+    }
+
+    @Override
+    public void onDestroy() {
+        // Do nothing
+    }
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
new file mode 100644
index 0000000000..26a293006f
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.ui.main;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.ColorInt;
+import android.support.annotation.LayoutRes;
+import android.support.v4.widget.SwipeRefreshLayout;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import java.util.List;
+
+import butterknife.Bind;
+import butterknife.ButterKnife;
+import io.realm.examples.newsreader.R;
+import io.realm.examples.newsreader.model.Model;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
+
+public class MainActivity extends AppCompatActivity {
+
+    @Bind(R.id.refresh_view) SwipeRefreshLayout refreshView;
+    @Bind(R.id.list_view) ListView listView;
+    @Bind(R.id.progressbar) MaterialProgressBar progressBar;
+    @Bind(R.id.spinner) Spinner spinner;
+
+    MainPresenter presenter = new MainPresenter(this, Model.getInstance());
+    private ArrayAdapter<NYTimesStory> adapter;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Setup initial views
+        setContentView(R.layout.activity_main);
+        ButterKnife.bind(this);
+        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+        getSupportActionBar().setDisplayShowTitleEnabled(false);
+
+        adapter = null;
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                presenter.listItemSelected(position);
+            }
+        });
+        listView.setEmptyView(getLayoutInflater().inflate(R.layout.common_emptylist, null, false));
+
+        refreshView.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
+            @Override
+            public void onRefresh() {
+                presenter.refreshList();
+            }
+        });
+        progressBar.setVisibility(View.INVISIBLE);
+
+        // After setup, notify presenter
+        presenter.onCreate();
+    }
+
+    /**
+     * Setup the toolbar spinner with the available sections
+     */
+    public void configureToolbar(List<String> sections) {
+        String[] sectionList = sections.toArray(new String[sections.size()]);
+        final ArrayAdapter adapter = new ArrayAdapter<CharSequence>(getApplicationContext(), android.R.layout.simple_spinner_dropdown_item, sectionList);
+        spinner.setAdapter(adapter);
+        spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                presenter.titleSpinnerSectionSelected((String) adapter.getItem(position));
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> parent) {
+
+            }
+        });
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        presenter.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        presenter.onPause();
+    }
+
+    public void hideRefreshing() {
+        refreshView.setRefreshing(false);
+    }
+
+    public void showList(List<NYTimesStory> items) {
+        if (adapter == null) {
+            adapter = new NewsListAdapter(MainActivity.this, items);
+            listView.setAdapter(adapter);
+        } else {
+            adapter.clear();
+            adapter.addAll(items);
+            adapter.notifyDataSetChanged();
+        }
+    }
+
+    public void showNetworkLoading(Boolean networkInUse) {
+        progressBar.setVisibility(networkInUse ? View.VISIBLE : View.INVISIBLE);
+    }
+
+    // ListView adapter class
+    public static class NewsListAdapter extends ArrayAdapter<NYTimesStory> {
+
+        private final LayoutInflater inflater;
+        @LayoutRes private final int layoutResource;
+        @ColorInt private final int readColor;
+        @ColorInt private final int unreadColor;
+
+        public NewsListAdapter(Context context, List<NYTimesStory> initialData) {
+            super(context, android.R.layout.simple_list_item_1);
+            setNotifyOnChange(false);
+            addAll(initialData);
+            inflater = LayoutInflater.from(context);
+            layoutResource = android.R.layout.simple_list_item_1;
+            readColor = context.getResources().getColor(android.R.color.darker_gray);
+            unreadColor = context.getResources().getColor(android.R.color.primary_text_light);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            View view = convertView;
+            if (view == null) {
+                view = inflater.inflate(layoutResource, parent, false);
+                ViewHolder holder = new ViewHolder(view);
+                view.setTag(holder);
+            }
+            ViewHolder holder = (ViewHolder) view.getTag();
+            NYTimesStory story = getItem(position);
+            holder.titleView.setText(story.getTitle());
+            holder.titleView.setTextColor(story.isRead() ? readColor : unreadColor);
+            return view;
+        }
+
+        static class ViewHolder {
+            @Bind(android.R.id.text1) TextView titleView;
+            public ViewHolder(View view) {
+                ButterKnife.bind(this, view);
+            }
+        }
+    }
+}
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java
new file mode 100644
index 0000000000..e9d3a840f4
--- /dev/null
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.newsreader.ui.main;
+
+import android.content.Intent;
+import android.support.annotation.NonNull;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.RealmResults;
+import io.realm.examples.newsreader.model.Model;
+import io.realm.examples.newsreader.model.entity.NYTimesStory;
+import io.realm.examples.newsreader.ui.Presenter;
+import io.realm.examples.newsreader.ui.details.DetailsActivity;
+import rx.Subscription;
+import rx.functions.Action1;
+
+/**
+ * Presenter class for controlling the Main Activity
+ */
+public class MainPresenter implements Presenter {
+
+    private final MainActivity view;
+    private final Model model;
+    private List<NYTimesStory> storiesData;
+    private Map<String, String> sections;
+    private Subscription loaderSubscription;
+    private Subscription listDataSubscription;
+
+    public MainPresenter(MainActivity mainActivity, Model model) {
+        this.view = mainActivity;
+        this.model = model;
+    }
+
+    @Override
+    public void onCreate() {
+        sections = model.getSections();
+        // Sort sections alphabetically, but always have Home at the top
+        ArrayList<String> sectionList = new ArrayList<>(sections.values());
+        Collections.sort(sectionList, new Comparator<String>() {
+            @Override
+            public int compare(String lhs, String rhs) {
+                if (lhs.equals("Home")) return -1;
+                if (rhs.equals("Home")) return 1;
+                return lhs.compareToIgnoreCase(rhs);
+            }
+        });
+        view.configureToolbar(sectionList);
+    }
+
+    @Override
+    public void onResume() {
+        loaderSubscription = model.isNetworkUsed()
+                .subscribe(new Action1<Boolean>() {
+                    @Override
+                    public void call(Boolean networkInUse) {
+                        view.showNetworkLoading(networkInUse);
+                    }
+                });
+
+        sectionSelected(model.getCurrentSectionKey());
+    }
+
+    @Override
+    public void onPause() {
+        loaderSubscription.unsubscribe();
+        listDataSubscription.unsubscribe();
+    }
+
+    @Override
+    public void onDestroy() {
+        // Do nothing
+    }
+
+    public void refreshList() {
+        model.reloadNewsFeed();
+        view.hideRefreshing();
+    }
+
+    public void listItemSelected(int position) {
+        Intent intent = DetailsActivity.getIntent(view, storiesData.get(position));
+        view.startActivity(intent);
+    }
+
+    public void titleSpinnerSectionSelected(@NonNull String sectionLabel) {
+        for (String key : sections.keySet()) {
+            if (sections.get(key).equals(sectionLabel)) {
+                sectionSelected(key);
+                break;
+            }
+        }
+    }
+
+    private void sectionSelected(@NonNull String sectionKey) {
+        model.selectSection(sectionKey);
+        if (listDataSubscription != null) {
+            listDataSubscription.unsubscribe();
+        }
+        listDataSubscription = model.getSelectedNewsFeed()
+                .subscribe(new Action1<RealmResults<NYTimesStory>>() {
+                    @Override
+                    public void call(RealmResults<NYTimesStory> stories) {
+                        storiesData = stories;
+                        view.showList(stories);
+                    }
+                });
+    }
+}
diff --git a/examples/newsreaderExample/src/main/res/layout/activity_details.xml b/examples/newsreaderExample/src/main/res/layout/activity_details.xml
new file mode 100644
index 0000000000..ad69d7da57
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/activity_details.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.design.widget.CoordinatorLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fitsSystemWindows="true"
+    tools:context=".ui.details.DetailsActivity">
+
+    <android.support.design.widget.AppBarLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:theme="@style/AppTheme.AppBarOverlay">
+
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            android:background="?attr/colorPrimary"
+            app:popupTheme="@style/AppTheme.PopupOverlay"/>
+
+    </android.support.design.widget.AppBarLayout>
+
+    <!-- Content -->
+    <include layout="@layout/content_details"/>
+
+</android.support.design.widget.CoordinatorLayout>
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/res/layout/activity_main.xml b/examples/newsreaderExample/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000000..bc00946723
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/activity_main.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.design.widget.CoordinatorLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fitsSystemWindows="true"
+    tools:context=".ui.main.MainActivity">
+
+    <android.support.design.widget.AppBarLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:theme="@style/AppTheme.AppBarOverlay">
+
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            android:background="?attr/colorPrimary"
+            app:popupTheme="@style/AppTheme.PopupOverlay">
+
+            <Spinner
+                android:id="@+id/spinner"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"/>
+
+        </android.support.v7.widget.Toolbar>
+
+        <me.zhanghai.android.materialprogressbar.MaterialProgressBar
+            android:id="@+id/progressbar"
+            style="@style/Widget.MaterialProgressBar.ProgressBar.Horizontal.NoPadding"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="bottom"
+            android:indeterminate="true"
+            app:mpb_progressStyle="horizontal"
+            app:mpb_showTrack="false"
+            app:mpb_useIntrinsicPadding="false"/>
+
+    </android.support.design.widget.AppBarLayout>
+
+    <include layout="@layout/content_main"/>
+
+</android.support.design.widget.CoordinatorLayout>
diff --git a/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml b/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml
new file mode 100644
index 0000000000..aeb5bee755
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/common_emptylist.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+          android:text="No news"
+          android:textColor="@android:color/darker_gray"
+          android:layout_width="match_parent"
+          android:layout_height="match_parent">
+</TextView>
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/res/layout/content_details.xml b/examples/newsreaderExample/src/main/res/layout/content_details.xml
new file mode 100644
index 0000000000..f0b9f39a3b
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/content_details.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    app:layout_behavior="@string/appbar_scrolling_view_behavior"
+    tools:context=".ui.details.DetailsActivity"
+    tools:showIn="@layout/activity_details">
+
+    <TextView
+        android:id="@+id/date_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:textColor="@android:color/darker_gray"/>
+
+    <TextView
+        android:id="@+id/read_text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentTop="true"
+        android:textColor="@android:color/holo_green_dark"/>
+
+    <TextView
+        android:id="@+id/details_text"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_below="@id/read_text"
+        android:paddingTop="16dp"/>
+
+    <ProgressBar
+        android:id="@+id/loader_view"
+        style="?android:attr/progressBarStyleLarge"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerInParent="true"/>
+
+</RelativeLayout>
diff --git a/examples/newsreaderExample/src/main/res/layout/content_main.xml b/examples/newsreaderExample/src/main/res/layout/content_main.xml
new file mode 100644
index 0000000000..5704d6c6a8
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/content_main.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="0dp"
+    android:paddingTop="0dp"
+    app:layout_behavior="@string/appbar_scrolling_view_behavior"
+    tools:context=".ui.main.MainActivity"
+    tools:showIn="@layout/activity_main">
+
+    <android.support.v4.widget.SwipeRefreshLayout
+        android:id="@+id/refresh_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <ListView
+            android:id="@+id/list_view"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent">
+        </ListView>
+
+    </android.support.v4.widget.SwipeRefreshLayout>
+</RelativeLayout>
diff --git a/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml b/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml
new file mode 100644
index 0000000000..814c75045a
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/layout/spinner_dropdown_item.xml
@@ -0,0 +1,8 @@
+<CheckedTextView xmlns:android="http://schemas.android.com/apk/res/android"
+                 android:id="@android:id/text1"
+                 style="?android:attr/spinnerDropDownItemStyle"
+                 android:singleLine="true"
+                 android:layout_width="match_parent"
+                 android:layout_height="?android:attr/listPreferredItemHeight"
+                 android:ellipsize="marquee"
+                 android:textColor="?android:attr/textColorSecondary"/>
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/values-v21/styles.xml b/examples/newsreaderExample/src/main/res/values-v21/styles.xml
new file mode 100644
index 0000000000..dbbdd40f49
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/values-v21/styles.xml
@@ -0,0 +1,9 @@
+<resources>
+
+    <style name="AppTheme.NoActionBar">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
+        <item name="android:statusBarColor">@android:color/transparent</item>
+    </style>
+</resources>
diff --git a/test/concurrencyExample/src/main/res/values-w820dp/dimens.xml b/examples/newsreaderExample/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values-w820dp/dimens.xml
rename to examples/newsreaderExample/src/main/res/values-w820dp/dimens.xml
diff --git a/examples/newsreaderExample/src/main/res/values/colors.xml b/examples/newsreaderExample/src/main/res/values/colors.xml
new file mode 100644
index 0000000000..90781a8edd
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/values/colors.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+    <color name="white">#ffffff</color>
+</resources>
diff --git a/examples/newsreaderExample/src/main/res/values/dimens.xml b/examples/newsreaderExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..812cb7be0a
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/values/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="fab_margin">16dp</dimen>
+</resources>
diff --git a/examples/newsreaderExample/src/main/res/values/strings.xml b/examples/newsreaderExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..72c43bc69d
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<resources>
+    <string name="app_name">NewsReader</string>
+    <!-- API Keys : Note they are throttled, so consider requesting your own: http://developer.nytimes.com/apps/register -->
+    <string name="nyc_top_stories_api_key">6fd358f33363137b6b5e0b5758bd9052:18:73641711</string>
+    <string name="action_toggle_read">Toggle read</string>
+</resources>
diff --git a/examples/newsreaderExample/src/main/res/values/styles.xml b/examples/newsreaderExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..177cefc895
--- /dev/null
+++ b/examples/newsreaderExample/src/main/res/values/styles.xml
@@ -0,0 +1,20 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+    <style name="AppTheme.NoActionBar">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+    </style>
+
+    <style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.Dark.ActionBar"/>
+
+    <style name="AppTheme.PopupOverlay" parent="ThemeOverlay.AppCompat.Light"/>
+
+</resources>
diff --git a/examples/newsreaderExample/src/release/AndroidManifest.xml b/examples/newsreaderExample/src/release/AndroidManifest.xml
new file mode 100644
index 0000000000..d044658dcf
--- /dev/null
+++ b/examples/newsreaderExample/src/release/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.examples.newsreader"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application android:name=".DebugNewsReaderApplication"/>
+</manifest>
diff --git a/examples/newsreaderExample/src/release/java/io/realm/examples/newsreader/ReleaseNewsReaderApplication.java b/examples/newsreaderExample/src/release/java/io/realm/examples/newsreader/ReleaseNewsReaderApplication.java
new file mode 100644
index 0000000000..f835d1a754
--- /dev/null
+++ b/examples/newsreaderExample/src/release/java/io/realm/examples/newsreader/ReleaseNewsReaderApplication.java
@@ -0,0 +1,11 @@
+package io.realm.examples.newsreader;
+
+/**
+ * Release specific application setup.
+ */
+public class ReleaseNewsReaderApplication extends NewsReaderApplication {
+    @Override
+    protected void initializeTimber() {
+        // No logging in Release mode.
+    }
+}
diff --git a/examples/rxJavaExample/README.md b/examples/rxJavaExample/README.md
new file mode 100644
index 0000000000..00ac5bc432
--- /dev/null
+++ b/examples/rxJavaExample/README.md
@@ -0,0 +1,16 @@
+# Examples combining RxJava and Realm
+
+# Things to keep in mind
+
+- Observables might have a default `Scheduler` they operate on that is different than the one 
+  the RealmObject was created on. Accessing Realm objects on the wrong thread will throw an 
+  `IllegalStateException`.
+  
+- RealmObjects are live objects that automatically stay up to date. Operators that expect
+  immutable objects will most likely not work as expected, e.g. `distinctUntilChanged`.
+
+- Retrofit 1.x automatically uses a worker thread.
+
+- Use the Realm async API instead of `subscribeOn` to move Realm work off the UI thread.
+
+- You can use `Realm.copyFromRealm` to make a copy of Realm data.
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
new file mode 100644
index 0000000000..be05c0a6b0
--- /dev/null
+++ b/examples/rxJavaExample/build.gradle
@@ -0,0 +1,34 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.rxjava'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+dependencies {
+    compile 'io.reactivex:rxandroid:1.1.0'
+    compile 'io.reactivex:rxjava:1.1.0'
+    compile 'com.jakewharton.rxbinding:rxbinding:0.3.0'
+    compile 'com.squareup.retrofit:retrofit:1.9.0'
+}
diff --git a/examples/rxJavaExample/src/main/AndroidManifest.xml b/examples/rxJavaExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..5029512a3e
--- /dev/null
+++ b/examples/rxJavaExample/src/main/AndroidManifest.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.rxjava" >
+
+    <uses-permission android:name="android.permission.INTERNET" />
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:name=".MyApplication"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name=".animation.AnimationActivity" />
+        <activity android:name=".retrofit.RetrofitExample" />
+        <activity android:name=".throttle.ThrottleSearchActivity" />
+        <activity android:name=".gotchas.GotchasActivity" />
+    </application>
+
+</manifest>
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
new file mode 100644
index 0000000000..dfcdb984cf
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+import io.realm.examples.rxjava.animation.AnimationActivity;
+import io.realm.examples.rxjava.gotchas.GotchasActivity;
+import io.realm.examples.rxjava.retrofit.RetrofitExample;
+import io.realm.examples.rxjava.throttle.ThrottleSearchActivity;
+
+public class MainActivity extends Activity {
+
+    private ViewGroup container;
+    private TreeMap<String, Class<? extends Activity>> buttons = new TreeMap<String, Class<? extends Activity>>() {{
+        put("Animation", AnimationActivity.class);
+        put("Throttle search", ThrottleSearchActivity.class);
+        put("Network", RetrofitExample.class);
+        put("Working with Realm", GotchasActivity.class);
+    }};
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+        container = (ViewGroup) findViewById(R.id.list);
+        setupButtons();
+    }
+
+    private void setupButtons() {
+        for (final Map.Entry<String, Class<? extends Activity>> entry : buttons.entrySet()) {
+            Button button = new Button(this);
+            button.setText(entry.getKey());
+            button.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    startActivity(entry.getValue());
+                }
+            });
+            container.addView(button);
+        }
+    }
+
+    private void startActivity(Class<? extends Activity> activityClass) {
+        startActivity(new Intent(this, activityClass));
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
new file mode 100644
index 0000000000..f7223cacc5
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava;
+
+import android.app.Application;
+
+import java.util.Map;
+import java.util.Random;
+import java.util.TreeMap;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.examples.rxjava.model.Person;
+
+public class MyApplication extends Application {
+
+    private static MyApplication context;
+    private static TreeMap<String, String> testPersons = new TreeMap<>();
+    static {
+        testPersons.put("Chris", null);
+        testPersons.put("Christian", "cmelchior");
+        testPersons.put("Christoffer", null);
+        testPersons.put("Emanuele", "emanuelez");
+        testPersons.put("Dan", null);
+        testPersons.put("Donn", "donnfelker");
+        testPersons.put("Nabil", "nhachicha");
+        testPersons.put("Ron", null);
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        context = this;
+        RealmConfiguration config = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(config);
+        Realm.setDefaultConfiguration(config);
+        createTestData();
+    }
+
+    // Create test data
+    private void createTestData() {
+        final Random r = new Random(42);
+        Realm realm = Realm.getDefaultInstance();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (Map.Entry<String, String> entry : testPersons.entrySet()) {
+                    Person p = realm.createObject(Person.class);
+                    p.setName(entry.getKey());
+                    p.setGithubUserName(entry.getValue());
+                    p.setAge(r.nextInt(100));
+                }
+            }
+        });
+        realm.close();
+    }
+
+    public static MyApplication getContext() {
+        return context;
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java
new file mode 100644
index 0000000000..ebcb5e1a05
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.animation;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.examples.rxjava.R;
+import io.realm.examples.rxjava.model.Person;
+import rx.Observable;
+import rx.Subscription;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.functions.Action1;
+import rx.functions.Func1;
+import rx.functions.Func2;
+
+public class AnimationActivity extends Activity {
+
+    private Realm realm;
+    private Subscription subscription;
+    private ViewGroup container;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_animations);
+        container = (ViewGroup) findViewById(R.id.list);
+        realm = Realm.getDefaultInstance();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // Load all persons and start inserting them with 1 sec. intervals.
+        // All RealmObject access has to be done on the same thread `findAllAsync` was called on.
+        // Warning: This example doesn't handle back pressure well.
+        subscription = realm.where(Person.class).findAllAsync().asObservable()
+                .flatMap(new Func1<RealmResults<Person>, Observable<Person>>() {
+                    @Override
+                    public Observable<Person> call(RealmResults<Person> persons) {
+                        return Observable.from(persons);
+                    }
+                })
+                .zipWith(Observable.interval(1, TimeUnit.SECONDS), new Func2<Person, Long, Person>() {
+                    @Override
+                    public Person call(Person person, Long tick) {
+                        return person;
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Action1<Person>() {
+                    @Override
+                    public void call(Person person) {
+                        TextView personView = new TextView(AnimationActivity.this);
+                        personView.setText(person.getName());
+                        container.addView(personView);
+                    }
+                });
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        subscription.unsubscribe();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close();
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
new file mode 100644
index 0000000000..59e25bace0
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.gotchas;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import java.util.List;
+import java.util.Random;
+
+import io.realm.Realm;
+import io.realm.Sort;
+import io.realm.examples.rxjava.R;
+import io.realm.examples.rxjava.model.Person;
+import rx.Observable;
+import rx.Subscription;
+import rx.functions.Action1;
+import rx.functions.Func1;
+import rx.schedulers.Schedulers;
+import rx.subscriptions.CompositeSubscription;
+
+/**
+ * This class shows some of the current obstacles when combining RxJava and Realm. 2 things are
+ * important to keep in mind.
+ *
+ * 1) Thread confinement: Realm objects are thread confined, so trying to access them from another thread will throw
+ *    an exception.
+ *
+ * 2) Realm objects are live objects. This means that the same object will alter it's state automatically over time to
+ *    automatically reflect the latest state in Realm.
+ *
+ * Both of these characteristics doesn't play well with RxJava's threading model which favor immutable thread-safe
+ * objects.
+ *
+ * Work is in progress to make it easier to work around these constraints. See
+ * - https://github.com/realm/realm-java/issues/1208
+ * - https://github.com/realm/realm-java/issues/931
+ */
+public class GotchasActivity extends Activity {
+    private Realm realm;
+    private Subscription subscription;
+    private ViewGroup container;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_gotchas);
+        container = (ViewGroup) findViewById(R.id.list);
+        realm = Realm.getDefaultInstance();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        Subscription distinctSubscription = testDistinct();
+        Subscription bufferSubscription = testBuffer();
+        Subscription subscribeOnSubscription = testSubscribeOn();
+
+        // Trigger updates
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.allObjectsSorted(Person.class, "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
+            }
+        });
+
+        subscription = new CompositeSubscription(
+                distinctSubscription,
+                bufferSubscription,
+                subscribeOnSubscription
+        );
+    }
+
+    /**
+     * Shows how to be careful with `subscribeOn()`
+     */
+    private Subscription testSubscribeOn() {
+        Subscription subscribeOn = realm.asObservable()
+                .map(new Func1<Realm, Person>() {
+                    @Override
+                    public Person call(Realm realm) {
+                        return realm.where(Person.class).findAllSorted("name").get(0);
+                    }
+                })
+                // The Realm was created on the UI thread. Accessing it on `Schedulers.io()` will crash.
+                // Avoid using subscribeOn() and use Realms `findAllAsync*()` methods instead.
+                .subscribeOn(Schedulers.io()) //
+                .subscribe(new Action1<Person>() {
+                    @Override
+                    public void call(Person person) {
+                        // Do nothing
+                    }
+                }, new Action1<Throwable>() {
+                    @Override
+                    public void call(Throwable throwable) {
+                        showStatus("subscribeOn: " + throwable.toString());
+                    }
+                });
+
+        // Use Realms Async API instead
+        Subscription asyncSubscribeOn = realm.where(Person.class).findAllSortedAsync("name").get(0).<Person>asObservable()
+                .subscribe(new Action1<Person>() {
+                    @Override
+                    public void call(Person person) {
+                        showStatus("subscribeOn/async: " + person.getName() + ":" + person.getAge());
+                    }
+                }, new Action1<Throwable>() {
+                    @Override
+                    public void call(Throwable throwable) {
+                        showStatus("subscribeOn/async: " + throwable.toString());
+                    }
+                });
+
+        return new CompositeSubscription(subscribeOn, asyncSubscribeOn);
+    }
+
+    /**
+     * Shows how to be careful with `buffer()`
+     */
+    private Subscription testBuffer() {
+        Observable<Person> personObserver = realm.asObservable().map(new Func1<Realm, Person>() {
+            @Override
+            public Person call(Realm realm) {
+                return realm.where(Person.class).findAllSorted("name").get(0);
+            }
+        });
+
+        // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
+        // that all objects in the cache will contain the same data.
+        // Either avoid using buffer or copy data into an un-managed object.
+        return personObserver
+                .buffer(2)
+                .subscribe(new Action1<List<Person>>() {
+                    @Override
+                    public void call(List<Person> persons) {
+                        showStatus("Buffer[0] : " + persons.get(0).getName() + ":" + persons.get(0).getAge());
+                        showStatus("Buffer[1] : " + persons.get(1).getName() + ":" + persons.get(1).getAge());
+                    }
+                });
+    }
+
+    /**
+     * Shows how to to be careful when using `distinct()`
+     */
+    private Subscription testDistinct() {
+        Observable<Person> personObserver = realm.asObservable().map(new Func1<Realm, Person>() {
+            @Override
+            public Person call(Realm realm) {
+                return realm.where(Person.class).findAllSorted("name").get(0);
+            }
+        });
+
+        // distinct() and distinctUntilChanged() uses standard equals with older objects stored in a HashMap.
+        // Realm objects auto-update which means the objects stored will also auto-update.
+        // This makes comparing against older objects impossible (even if the new object has changed) because the
+        // cached object will also have changed.
+        // Use a keySelector function to work around this.
+        Subscription distinctItemTest = personObserver
+                .distinct() // Because old == new. This will only allow the first version of the "Chris" object to pass.
+                .subscribe(new Action1<Person>() {
+                    @Override
+                    public void call(Person p) {
+                        showStatus("distinct(): " + p.getName() + ":" + p.getAge());
+                    }
+                });
+
+        Subscription distinctKeySelectorItemTest = personObserver
+                .distinct(new Func1<Person, Integer>() { // Use a keySelector function instead
+                    @Override
+                    public Integer call(Person p) {
+                        return p.getAge();
+                    }
+                })
+                .subscribe(new Action1<Person>() {
+                    @Override
+                    public void call(Person p) {
+                        showStatus("distinct(keySelector): " + p.getName() + ":" + p.getAge());
+                    }
+                });
+
+
+        return new CompositeSubscription(distinctItemTest, distinctKeySelectorItemTest);
+    }
+
+    private void showStatus(String message) {
+        TextView v = new TextView(this);
+        v.setText(message);
+        container.addView(v);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        subscription.unsubscribe();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close();
+    }
+
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
similarity index 56%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
rename to examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
index 4fae6d0053..a8644f69ec 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/model/Person.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,17 +14,23 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service.model;
+package io.realm.examples.rxjava.model;
 
-import io.realm.RealmList;
 import io.realm.RealmObject;
 
 public class Person extends RealmObject {
 
+    private long id;
+
+    // All fields are by default persisted.
     private String name;
     private int age;
-//    private Dog dog;
-//    private RealmList<Cat> cats;
+    private String githubUserName;
+
+
+    // The standard getters and setters your IDE generates are fine.
+    // Realm will overload them and code inside them is ignored.
+    // So if you prefer you can also just have empty abstract methods.
 
     public String getName() {
         return name;
@@ -42,29 +48,19 @@ public void setAge(int age) {
         this.age = age;
     }
 
-//    public Dog getDog() {
-//        return dog;
-//    }
-//
-//    public void setDog(Dog dog) {
-//        this.dog = dog;
-//    }
-//
-//    public RealmList<Cat> getCats() {
-//        return cats;
-//    }
-//
-//    public void setCats(RealmList<Cat> cats) {
-//        this.cats = cats;
-//    }
+    public long getId() {
+        return id;
+    }
 
-//    @Override
-//    public String toString() {
-//        return "Person{" +
-//                "name='" + name + '\'' +
-//                ", age=" + age +
-//                ", dog=" + dog +
-//                ", cats=" + cats +
-//                '}';
-//    }
-}
\ No newline at end of file
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    public String getGithubUserName() {
+        return githubUserName;
+    }
+
+    public void setGithubUserName(String githubUserName) {
+        this.githubUserName = githubUserName;
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
new file mode 100644
index 0000000000..973d2604f1
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.retrofit;
+
+/**
+ * Model class for GitHub users: https://developer.github.com/v3/users/#get-a-single-user
+ */
+public class GitHubUser {
+    public String name;
+    public String email;
+    public int public_repos;
+    public int public_gists;
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
new file mode 100644
index 0000000000..3edf46e7bc
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.retrofit;
+
+import retrofit.http.GET;
+import retrofit.http.Path;
+import rx.Observable;
+
+/**
+ * GitHub API definition
+ */
+public interface GithubApi {
+    /**
+     * See https://developer.github.com/v3/users/
+     */
+    @GET("/users/{user}")
+    Observable<GitHubUser> user(@Path("user") String user);
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
new file mode 100644
index 0000000000..380d111005
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.retrofit;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.examples.rxjava.R;
+import io.realm.examples.rxjava.model.Person;
+import retrofit.RequestInterceptor;
+import retrofit.RestAdapter;
+import rx.Observable;
+import rx.Subscription;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.functions.Action1;
+import rx.functions.Func1;
+
+import static android.text.TextUtils.isEmpty;
+import static java.lang.String.format;
+
+public class RetrofitExample extends Activity {
+
+    private Realm realm;
+    private Subscription subscription;
+    private ViewGroup container;
+    private GithubApi api;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_network);
+        container = (ViewGroup) findViewById(R.id.list);
+        realm = Realm.getDefaultInstance();
+        api = createGitHubApi();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // Load all persons and merge them with their latest stats from GitHub (if they have any)
+        subscription = realm.where(Person.class).isNotNull("githubUserName").findAllSortedAsync("name").asObservable()
+                .filter(new Func1<RealmResults<Person>, Boolean>() {
+                    @Override
+                    public Boolean call(RealmResults<Person> persons) {
+                        // We only want the list once it is loaded.
+                        return persons.isLoaded();
+                    }
+                })
+                .flatMap(new Func1<RealmResults<Person>, Observable<Person>>() {
+                    @Override
+                    public Observable<Person> call(RealmResults<Person> persons) {
+                        // Emit each person individually
+                        return Observable.from(persons);
+                    }
+                })
+                .flatMap(new Func1<Person, Observable<GitHubUser>>() {
+                    @Override
+                    public Observable<GitHubUser> call(Person person) {
+                        // get GitHub statistics. Retrofit automatically does this on a separate thread.
+                        return api.user(person.getGithubUserName());
+                    }
+                })
+                .map(new Func1<GitHubUser, UserViewModel>() {
+                    @Override
+                    public UserViewModel call(GitHubUser gitHubUser) {
+                        // Map Network model to our View model
+                        return new UserViewModel(gitHubUser.name, gitHubUser.public_repos, gitHubUser.public_gists);
+                    }
+                })
+                .observeOn(AndroidSchedulers.mainThread()) // Retrofit put us on a worker thread. Move back to UI
+                .subscribe(new Action1<UserViewModel>() {
+                    @Override
+                    public void call(UserViewModel user) {
+                        // Print user info.
+                        TextView userView = new TextView(RetrofitExample.this);
+                        userView.setText(String.format("%s : %d/%d",
+                                user.getUsername(), user.getPublicRepos(), user.getPublicGists()));
+                        container.addView(userView);
+                    }
+                }, new Action1<Throwable>() {
+                    @Override
+                    public void call(Throwable throwable) {
+                        throwable.printStackTrace();
+                    }
+                });
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        subscription.unsubscribe();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close();
+    }
+
+    private GithubApi createGitHubApi() {
+
+        RestAdapter.Builder builder = new RestAdapter.Builder().setEndpoint("https://api.github.com/");
+
+        final String githubToken = ""; // Set GitHub OAuth token to avoid throttling if example is used a lot
+        if (!isEmpty(githubToken)) {
+            builder.setRequestInterceptor(new RequestInterceptor() {
+                @Override
+                public void intercept(RequestFacade request) {
+                    request.addHeader("Authorization", format("token %s", githubToken));
+                }
+            });
+        }
+
+        return builder.build().create(GithubApi.class);
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/UserViewModel.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/UserViewModel.java
new file mode 100644
index 0000000000..467314407e
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/UserViewModel.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.retrofit;
+
+public class UserViewModel {
+
+    private final String username;
+    private final int publicRepos;
+    private final int publicGists;
+
+    public UserViewModel(String username, int publicRepos, int publicGists) {
+        this.username = username;
+        this.publicRepos = publicRepos;
+        this.publicGists = publicGists;
+    }
+
+    public String getUsername() {
+        return username;
+    }
+
+    public int getPublicRepos() {
+        return publicRepos;
+    }
+
+    public int getPublicGists() {
+        return publicGists;
+    }
+}
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
new file mode 100644
index 0000000000..15a792100c
--- /dev/null
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.rxjava.throttle;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.view.ViewGroup;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.jakewharton.rxbinding.widget.RxTextView;
+import com.jakewharton.rxbinding.widget.TextViewTextChangeEvent;
+
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.examples.rxjava.R;
+import io.realm.examples.rxjava.model.Person;
+import rx.Observable;
+import rx.Subscription;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.functions.Action1;
+import rx.functions.Func1;
+
+public class ThrottleSearchActivity extends Activity {
+
+    private Realm realm;
+    private Subscription subscription;
+    private EditText searchInputView;
+    private ViewGroup searchResultsView;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_throttlesearch);
+        searchInputView = (EditText) findViewById(R.id.search);
+        searchResultsView = (ViewGroup) findViewById(R.id.search_results);
+        realm = Realm.getDefaultInstance();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // Listen to key presses and only start search after user paused to avoid excessive redrawing on the screen.
+        subscription = RxTextView.textChangeEvents(searchInputView)
+                .debounce(200, TimeUnit.MILLISECONDS) // default Scheduler is Schedulers.computation()
+                .observeOn(AndroidSchedulers.mainThread()) // Needed to access Realm data
+                .flatMap(new Func1<TextViewTextChangeEvent, Observable<RealmResults<Person>>>() {
+                    @Override
+                    public Observable<RealmResults<Person>> call(TextViewTextChangeEvent event) {
+                        // Use Async API to move Realm queries off the main thread.
+                        // Realm currently doesn't support the standard Schedulers.
+                        return realm.where(Person.class)
+                                .beginsWith("name", event.text().toString())
+                                .findAllSortedAsync("name").asObservable();
+                    }
+                })
+                .filter(new Func1<RealmResults<Person>, Boolean>() {
+                    @Override
+                    public Boolean call(RealmResults<Person> persons) {
+                        // Only continue once data is actually loaded
+                        // RealmObservables will emit the unloaded (empty) list as it's first item
+                        return persons.isLoaded();
+                    }
+                })
+                .subscribe(new Action1<RealmResults<Person>>() {
+                    @Override
+                    public void call(RealmResults<Person> persons) {
+                        searchResultsView.removeAllViews();
+                        for (Person person : persons) {
+                            TextView view = new TextView(ThrottleSearchActivity.this);
+                            view.setText(person.getName());
+                            searchResultsView.addView(view);
+                        }
+                    }
+                }, new Action1<Throwable>() {
+                    @Override
+                    public void call(Throwable throwable) {
+                        throwable.printStackTrace();
+                    }
+                });
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        subscription.unsubscribe();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close();
+    }
+}
diff --git a/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_animations.xml b/examples/rxJavaExample/src/main/res/layout/activity_animations.xml
new file mode 100644
index 0000000000..d9c40b7116
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/layout/activity_animations.xml
@@ -0,0 +1,15 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:id="@+id/list"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml b/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml
new file mode 100644
index 0000000000..5dc9a970bd
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/layout/activity_gotchas.xml
@@ -0,0 +1,26 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin">
+
+    <LinearLayout
+        android:id="@+id/list"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/textView"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center_horizontal"
+            android:textStyle="italic"
+            android:paddingBottom="16dp"
+            android:text="Use the Source, Luke!"
+            android:textAppearance="?android:attr/textAppearanceMedium"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_main.xml b/examples/rxJavaExample/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000000..d9c40b7116
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/layout/activity_main.xml
@@ -0,0 +1,15 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:id="@+id/list"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_network.xml b/examples/rxJavaExample/src/main/res/layout/activity_network.xml
new file mode 100644
index 0000000000..d9c40b7116
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/layout/activity_network.xml
@@ -0,0 +1,15 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:id="@+id/list"
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml b/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml
new file mode 100644
index 0000000000..ccb12d2139
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/layout/activity_throttlesearch.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="vertical"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent">
+
+    <EditText
+        android:id="@+id/search"
+        android:layout_width="match_parent"
+        android:layout_height="48dp"/>
+
+    <LinearLayout
+        android:id="@+id/search_results"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+    </LinearLayout>
+</LinearLayout>
\ No newline at end of file
diff --git a/examples/rxJavaExample/src/main/res/values-w820dp/dimens.xml b/examples/rxJavaExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/test/concurrencyExample/src/main/res/values/dimens.xml b/examples/rxJavaExample/src/main/res/values/dimens.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values/dimens.xml
rename to examples/rxJavaExample/src/main/res/values/dimens.xml
diff --git a/examples/rxJavaExample/src/main/res/values/strings.xml b/examples/rxJavaExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..c7d68f36c4
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">RxJava examples</string>
+</resources>
diff --git a/gradle-plugin/sample/src/main/res/values/styles.xml b/examples/rxJavaExample/src/main/res/values/styles.xml
similarity index 61%
rename from gradle-plugin/sample/src/main/res/values/styles.xml
rename to examples/rxJavaExample/src/main/res/values/styles.xml
index 766ab99304..ff6c9d2c0f 100644
--- a/gradle-plugin/sample/src/main/res/values/styles.xml
+++ b/examples/rxJavaExample/src/main/res/values/styles.xml
@@ -1,7 +1,7 @@
 <resources>
 
     <!-- Base application theme. -->
-    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
         <!-- Customize your theme here. -->
     </style>
 
diff --git a/examples/settings.gradle b/examples/settings.gradle
new file mode 100644
index 0000000000..529a4f486c
--- /dev/null
+++ b/examples/settings.gradle
@@ -0,0 +1,17 @@
+include 'adapterExample'
+include 'encryptionExample'
+include 'gridViewExample'
+include 'introExample'
+include 'jsonExample'
+include 'kotlinExample'
+include 'migrationExample'
+include 'moduleExample:app'
+include 'moduleExample:library'
+include 'realmModuleExample'
+include 'threadExample'
+include 'unitTestExample'
+include 'newsreaderExample'
+include 'rxJavaExample'
+
+rootProject.name = 'realm-examples'
+
diff --git a/examples/threadExample/.gitignore b/examples/threadExample/.gitignore
deleted file mode 100644
index 796b96d1c4..0000000000
--- a/examples/threadExample/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-/build
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index a064db9bf7..c915b69447 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -1,21 +1,22 @@
+apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
+apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.1"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId "io.realm.examples.threads"
+        targetSdkVersion rootProject.sdkVersion
         minSdkVersion 15
-        targetSdkVersion 21
         versionCode 1
         versionName "1.0"
     }
     buildTypes {
         release {
             minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     command {
@@ -23,11 +24,6 @@ android {
     }
 }
 
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
 dependencies {
     compile 'com.android.support:appcompat-v7:21.0.+'
-    compile files("../../realm/build/libs/realm-${version}.jar")
 }
diff --git a/examples/threadExample/proguard-rules.pro b/examples/threadExample/proguard-rules.pro
deleted file mode 100644
index a965f9288f..0000000000
--- a/examples/threadExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/opt/android-sdk/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/examples/threadExample/src/main/AndroidManifest.xml b/examples/threadExample/src/main/AndroidManifest.xml
index 44b5bfca94..3f54c69592 100644
--- a/examples/threadExample/src/main/AndroidManifest.xml
+++ b/examples/threadExample/src/main/AndroidManifest.xml
@@ -1,21 +1,32 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.examples.threads" >
+<manifest package="io.realm.examples.threads"
+          xmlns:android="http://schemas.android.com/apk/res/android">
 
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    
     <application
+        android:name=".MyApplication"
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
+        android:theme="@style/AppTheme">
         <activity
             android:name=".ThreadExampleActivity"
-            android:label="@string/app_name" >
+            android:label="@string/app_name">
             <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
+                <action android:name="android.intent.action.MAIN"/>
 
-                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
+        <activity
+            android:name=".ReceivingActivity"
+            android:label="@string/title_activity_receiving">
+        </activity>
+        <service android:name=".ReceivingService"
+                 android:exported="false" />
+        <receiver android:name=".WakefulReceivingBroadcastReceiver" />
+        <service android:name=".WakefulReceivingService" />
     </application>
 
-</manifest>
+</manifest>
\ No newline at end of file
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
new file mode 100644
index 0000000000..de41b08fca
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.BaseAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import java.util.Collections;
+import java.util.List;
+
+import io.realm.Realm;
+import io.realm.RealmAsyncTask;
+import io.realm.RealmChangeListener;
+import io.realm.RealmResults;
+import io.realm.Sort;
+import io.realm.examples.threads.model.Dot;
+
+/**
+ * This fragment demonstrates how you can perform asynchronous queries with Realm.
+ */
+public class AsyncQueryFragment extends Fragment implements View.OnClickListener, RealmChangeListener {
+    private Realm realm;
+    private DotAdapter dotAdapter;
+    private RealmResults<Dot> allSortedDots;
+    private RealmAsyncTask asyncTransaction;
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View rootView = inflater.inflate(R.layout.fragment_async_query, container, false);
+        rootView.findViewById(R.id.translate_button).setOnClickListener(this);
+
+        ListView listView = (ListView) rootView.findViewById(android.R.id.list);
+        dotAdapter = new DotAdapter(getActivity());
+        listView.setAdapter(dotAdapter);
+        return rootView;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        // Create Realm instance for the UI thread
+        realm = Realm.getDefaultInstance();
+        allSortedDots = realm.where(Dot.class)
+                .between("x", 25, 75)
+                .between("y", 0, 50)
+                .findAllSortedAsync(
+                         "x", Sort.ASCENDING,
+                         "y", Sort.DESCENDING
+                 );
+        dotAdapter.updateList(allSortedDots);
+        allSortedDots.addChangeListener(this);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        // Remember to close the Realm instance when done with it.
+        cancelAsyncTransaction();
+        allSortedDots.removeChangeListener(this);
+        allSortedDots = null;
+        realm.close();
+    }
+
+    @Override
+    public void onClick(View view) {
+        switch (view.getId()) {
+            case R.id.translate_button: {
+                cancelAsyncTransaction();
+                // translate all points coordinates using an async transaction
+                asyncTransaction = realm.executeTransactionAsync(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // query for all points
+                        RealmResults<Dot> dots = realm.where(Dot.class).findAll();
+
+                        for (int i = dots.size() - 1; i >= 0; i--) {
+                            Dot dot = dots.get(i);
+                            if (dot.isValid()) {
+                                int x = dot.getX();
+                                int y = dot.getY();
+                                dot.setX(y);
+                                dot.setY(x);
+                            }
+                        }
+                    }
+                }, new Realm.Transaction.OnSuccess() {
+                    @Override
+                    public void onSuccess() {
+                        if (isAdded()) {
+                            Toast.makeText(getActivity(), "Translation completed", Toast.LENGTH_SHORT).show();
+                        }
+                    }
+                }, new Realm.Transaction.OnError() {
+
+                    @Override
+                    public void onError(Throwable e) {
+                        if (isAdded()) {
+                            Toast.makeText(getActivity(), "Error while translating dots", Toast.LENGTH_SHORT).show();
+                            e.printStackTrace();
+                        }
+                    }
+                });
+                break;
+            }
+        }
+    }
+
+    private void cancelAsyncTransaction() {
+        if (asyncTransaction != null && !asyncTransaction.isCancelled()) {
+            asyncTransaction.cancel();
+            asyncTransaction = null;
+        }
+    }
+
+    @Override
+    public void onChange() {
+        dotAdapter.notifyDataSetChanged();
+    }
+
+    // Using a generic Adapter instead of RealmBaseAdapter, because
+    // RealmBaseAdapter registers a listener against all Realm changes
+    // whereas in this scenario we're only interested on the changes of our query
+    private static class DotAdapter extends BaseAdapter {
+        private List<Dot> dots = Collections.emptyList();
+        private final LayoutInflater inflater;
+
+        DotAdapter(Context context) {
+            this.inflater = LayoutInflater.from(context);
+        }
+
+        void updateList(RealmResults<Dot> dots) {
+            this.dots = dots;
+            notifyDataSetChanged();
+        }
+
+        @Override
+        public int getCount() {
+            return dots.size();
+        }
+
+        @Override
+        public Dot getItem(int i) {
+            return dots.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = inflater.inflate(android.R.layout.simple_list_item_1, viewGroup, false);
+                ViewHolder viewHolder = new ViewHolder(view);
+                view.setTag(viewHolder);
+            }
+            ViewHolder vh = (ViewHolder) view.getTag();
+            vh.text.setText("[X= " + getItem(i).getX() + " Y= " + getItem(i).getY() + "]");
+
+            return view;
+        }
+
+        private class ViewHolder {
+            TextView text;
+
+            ViewHolder(View view) {
+                text = (TextView) view.findViewById(android.R.id.text1);
+            }
+        }
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index 43d469227d..73a177e8a3 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -84,7 +84,7 @@ private void showStatus(String txt) {
 
         @Override
         protected Integer doInBackground(Void... params) {
-            Realm realm = Realm.getInstance(getActivity());
+            Realm realm = Realm.getDefaultInstance();
 
             realm.beginTransaction();
             realm.clear(Score.class);
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
new file mode 100644
index 0000000000..7ced58b6c8
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.app.Application;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        // Configure Realm for the application
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfiguration); // Clean slate
+        Realm.setDefaultConfiguration(realmConfiguration); // Make this Realm the default
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
new file mode 100644
index 0000000000..8ce4838613
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import java.util.UUID;
+
+import io.realm.Realm;
+import io.realm.examples.threads.model.Person;
+
+public class PassingObjectsFragment extends Fragment {
+
+    private TextView textContent;
+
+    private Realm realm;
+    private Person person;
+
+    @Nullable
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.fragment_passing_objects, container, false);
+        textContent = (TextView) view.findViewById(R.id.text_content);
+
+        setListeners(view);
+        return view;
+    }
+
+    /**
+     * Sets the click listeners on the three buttons.
+     *
+     * RealmObjects are thread confined, therefore they cannot be passed through an intent. We
+     * recommend using an object identifier and passing that value through the intent. The
+     * receiving Android component will then obtain that value, open the Realm and query for
+     * that object.
+     *
+     * Below, each {@link android.view.View.OnClickListener} builds an {@link Intent} that
+     * accepts the {@link Person#getId()} value as a string extra. This is the value that will
+     * be retrieved in the receiving Android components ({@link ReceivingActivity},
+     * {@link ReceivingService} and {@link WakefulReceivingBroadcastReceiver}.
+     *
+     * @param view The view where the buttons are located.
+     */
+    private void setListeners(View view) {
+        view.findViewById(R.id.start_activity).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(getActivity(), ReceivingActivity.class);
+                intent.putExtra("person_id", person.getId());
+                startActivity(intent);
+            }
+        });
+
+        view.findViewById(R.id.start_intent_service).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(getActivity(), ReceivingService.class);
+                intent.putExtra("person_id", person.getId());
+                getActivity().startService(intent);
+            }
+        });
+
+        view.findViewById(R.id.start_receiver).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Intent intent = new Intent(getActivity(), WakefulReceivingBroadcastReceiver.class);
+                intent.putExtra("person_id", person.getId());
+                getActivity().sendBroadcast(intent);
+            }
+        });
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        realm = Realm.getDefaultInstance();
+        realm.beginTransaction();
+        person = realm.createObject(Person.class);
+        person.setName("Jane");
+        person.setAge(42);
+        person.setId(UUID.randomUUID().toString());
+        realm.commitTransaction();
+
+        textContent.setText(person.toString());
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        // Clear out all Person instances.
+        realm.clear(Person.class);
+        realm.close();
+    }
+}
+
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java
new file mode 100644
index 0000000000..5e2c6fa749
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingActivity.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.os.Bundle;
+import android.support.v7.app.ActionBarActivity;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.examples.threads.model.Person;
+
+public class ReceivingActivity extends ActionBarActivity {
+
+    private Realm realm;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_receiving);
+
+        realm = Realm.getDefaultInstance();
+
+        if (getIntent() != null) {
+            String personId = getIntent().getStringExtra("person_id");
+            if (personId != null) {
+                Person person = realm.where(Person.class).equalTo("id", personId).findFirst();
+                ((TextView) findViewById(R.id.received_content)).setText(String.format("Received person_id and loaded: %s", person.toString()));
+            }
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close();
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingService.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingService.java
new file mode 100644
index 0000000000..53f5ae41a2
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ReceivingService.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.os.Handler;
+import android.widget.Toast;
+
+import io.realm.Realm;
+import io.realm.examples.threads.model.Person;
+
+public class ReceivingService extends IntentService {
+
+    public ReceivingService() {
+        super("ReceivingService");
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        if (intent.getExtras() != null) {
+            String personId = intent.getStringExtra("person_id");
+            Realm realm = Realm.getDefaultInstance();
+            Person person = realm.where(Person.class).equalTo("id", personId).findFirst();
+            final String output = person.toString();
+            new Handler(getMainLooper()).post(new Runnable() {
+                @Override
+                public void run() {
+                    Toast.makeText(getApplicationContext(), "Loaded Person from intent service: " + output, Toast.LENGTH_LONG).show();
+                }
+            });
+            realm.close();
+        }
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
index 6c085cfcdf..c3774acca1 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadExampleActivity.java
@@ -30,7 +30,6 @@
 
 public class ThreadExampleActivity extends ActionBarActivity implements android.support.v7.app.ActionBar.TabListener {
 
-    private SectionsPagerAdapter pageAdapter;
     private ViewPager viewPager;
 
     @Override
@@ -42,7 +41,7 @@ protected void onCreate(Bundle savedInstanceState) {
         final android.support.v7.app.ActionBar actionBar = getSupportActionBar();
         actionBar.setNavigationMode(android.support.v7.app.ActionBar.NAVIGATION_MODE_TABS);
 
-        pageAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
+        SectionsPagerAdapter pageAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
         viewPager = (ViewPager) findViewById(R.id.pager);
         viewPager.setAdapter(pageAdapter);
 
@@ -87,13 +86,15 @@ public Fragment getItem(int position) {
             switch(position) {
                 case 0: return new ThreadFragment();
                 case 1: return new AsyncTaskFragment();
+                case 2: return new AsyncQueryFragment();
+                case 3: return new PassingObjectsFragment();
                 default: return null;
             }
         }
 
         @Override
         public int getCount() {
-            return 2;
+            return 4;
         }
 
         @Override
@@ -102,6 +103,8 @@ public CharSequence getPageTitle(int position) {
             switch (position) {
                 case 0: return getString(R.string.title_section1).toUpperCase(l);
                 case 1: return getString(R.string.title_section2).toUpperCase(l);
+                case 2: return getString(R.string.title_section3).toUpperCase(l);
+                case 3: return getString(R.string.title_section4).toUpperCase(l);
                 default: return null;
             }
         }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index 109213b972..7d0c1ba477 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -16,7 +16,6 @@
 
 package io.realm.examples.threads;
 
-import android.app.Activity;
 import android.os.Bundle;
 import android.os.SystemClock;
 import android.support.v4.app.Fragment;
@@ -58,28 +57,10 @@ public void onCreate(Bundle savedInstanceState) {
         setHasOptionsMenu(true);
     }
 
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        // Create Realm instance for the UI thread
-        realm = Realm.getInstance(getActivity());
-    }
-
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View rootView = inflater.inflate(R.layout.fragment_thread, container, false);
         dotsView = (DotsView) rootView.findViewById(R.id.dots);
-
-        // Create a RealmQuery on the UI thread and send the results to the custom view. The
-        // RealmResults will automatically be updated whenever the Realm data is changed.
-        // We still need to invalidate the UI to show the changes however. See the RealmChangeListener.
-        //
-        // Note that the query gets updated by rerunning it on the thread it was
-        // created. This can negatively effect frame rates if it is a complicated query or a very
-        // large data set.
-        dotsView.setRealmResults(realm.allObjects(Dot.class));
-
         return rootView;
     }
 
@@ -114,6 +95,22 @@ public boolean onOptionsItemSelected(MenuItem item) {
         }
     }
 
+    @Override
+    public void onStart() {
+        super.onStart();
+        // Create Realm instance for the UI thread
+        realm = Realm.getDefaultInstance();
+
+        // Create a RealmQuery on the UI thread and send the results to the custom view. The
+        // RealmResults will automatically be updated whenever the Realm data is changed.
+        // We still need to invalidate the UI to show the changes however. See the RealmChangeListener.
+        //
+        // Note that the query gets updated by rerunning it on the thread it was
+        // created. This can negatively effect frame rates if it is a complicated query or a very
+        // large data set.
+        dotsView.setRealmResults(realm.allObjects(Dot.class));
+    }
+
     @Override
     public void onResume() {
         super.onResume();
@@ -129,7 +126,7 @@ public void run() {
                 // Realm instances cannot be shared between threads, so we need to create a new
                 // instance on the background thread.
                 int redColor = getResources().getColor(R.color.realm_red);
-                Realm backgroundThreadRealm = Realm.getInstance(getActivity());
+                Realm backgroundThreadRealm = Realm.getDefaultInstance();
                 while (!backgroundThread.isInterrupted()) {
                     backgroundThreadRealm.beginTransaction();
 
@@ -161,8 +158,8 @@ public void onPause() {
     }
 
     @Override
-    public void onDestroy() {
-        super.onDestroy();
+    public void onStop() {
+        super.onStop();
         // Remember to close the Realm instance when done with it.
         realm.close();
     }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingBroadcastReceiver.java b/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingBroadcastReceiver.java
new file mode 100644
index 0000000000..1c96463d3f
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingBroadcastReceiver.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.content.Context;
+import android.content.Intent;
+import android.support.v4.content.WakefulBroadcastReceiver;
+
+public class WakefulReceivingBroadcastReceiver extends WakefulBroadcastReceiver {
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // Do not do work in onReceive as it can cause an ANR. Perform work in a
+        // service as to avoid the ANR.
+        Intent serviceIntent = new Intent(context, WakefulReceivingService.class);
+        serviceIntent.putExtra("person_id", intent.getStringExtra("person_id"));
+        startWakefulService(context, serviceIntent);
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingService.java b/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingService.java
new file mode 100644
index 0000000000..22f60d4a42
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/WakefulReceivingService.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.os.Handler;
+import android.support.v4.content.WakefulBroadcastReceiver;
+import android.widget.Toast;
+
+import io.realm.Realm;
+import io.realm.examples.threads.model.Person;
+
+public class WakefulReceivingService extends IntentService {
+
+    public WakefulReceivingService() {
+        super("WakefulReceivingService");
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        if (intent.getExtras() != null) {
+            String personId = intent.getStringExtra("person_id");
+            Realm realm = Realm.getDefaultInstance();
+            Person person = realm.where(Person.class).equalTo("id", personId).findFirst();
+            final String output = person.toString();
+            new Handler(getMainLooper()).post(new Runnable() {
+                @Override
+                public void run() {
+                    Toast.makeText(getApplicationContext(), "Loaded Person from broadcast-receiver->intent-service: " + output, Toast.LENGTH_LONG).show();
+                }
+            });
+            realm.close();
+        }
+
+        // All the work is done, release the wake locks/etc
+        WakefulBroadcastReceiver.completeWakefulIntent(intent);
+    }
+}
diff --git a/gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java b/examples/threadExample/src/main/java/io/realm/examples/threads/model/Person.java
similarity index 79%
rename from gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java
rename to examples/threadExample/src/main/java/io/realm/examples/threads/model/Person.java
index f3f7b9505f..7793d8994b 100644
--- a/gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/model/Person.java
@@ -13,14 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.example.sample.models;
+
+package io.realm.examples.threads.model;
 
 import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
 
 public class Person extends RealmObject {
+
+    @PrimaryKey
+    private String id;
     private String name;
     private int age;
 
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
     public String getName() {
         return name;
     }
diff --git a/examples/threadExample/src/main/res/layout/activity_main.xml b/examples/threadExample/src/main/res/layout/activity_main.xml
index 0cfa754eba..e318efbc6a 100644
--- a/examples/threadExample/src/main/res/layout/activity_main.xml
+++ b/examples/threadExample/src/main/res/layout/activity_main.xml
@@ -1,19 +1,3 @@
-<!--
-  ~ Copyright 2014 Realm Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~ http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
 <android.support.v4.view.ViewPager xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:id="@+id/pager"
diff --git a/examples/threadExample/src/main/res/layout/activity_receiving.xml b/examples/threadExample/src/main/res/layout/activity_receiving.xml
new file mode 100644
index 0000000000..17e6a13ea7
--- /dev/null
+++ b/examples/threadExample/src/main/res/layout/activity_receiving.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/screen_background"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    tools:context="io.realm.examples.threads.ReceivingActivity">
+
+    <TextView
+        android:id="@+id/received_content"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textColor="@android:color/white"/>
+
+</RelativeLayout>
diff --git a/examples/threadExample/src/main/res/layout/fragment_async_query.xml b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
new file mode 100644
index 0000000000..f695941fca
--- /dev/null
+++ b/examples/threadExample/src/main/res/layout/fragment_async_query.xml
@@ -0,0 +1,27 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:background="@color/screen_background"
+                android:orientation="vertical"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                tools:context=".MainActivity$PlaceholderFragment">
+
+    <Button
+        android:id="@+id/translate_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/translate"/>
+
+    <ListView
+        android:id="@android:id/list"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp">
+    </ListView>
+
+
+</LinearLayout>
diff --git a/examples/threadExample/src/main/res/layout/fragment_asynctask.xml b/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
index 2fa2bca694..7e8ef2078b 100644
--- a/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_asynctask.xml
@@ -1,24 +1,8 @@
-<!--
-  ~ Copyright 2014 Realm Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~ http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                 xmlns:tools="http://schemas.android.com/tools"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
-                android:background="@color/fragment_background"
+                android:background="@color/screen_background"
                 android:orientation="vertical"
                 android:paddingBottom="@dimen/activity_vertical_margin"
                 android:paddingLeft="@dimen/activity_horizontal_margin"
diff --git a/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml b/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml
new file mode 100644
index 0000000000..b92612d6a5
--- /dev/null
+++ b/examples/threadExample/src/main/res/layout/fragment_passing_objects.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="match_parent"
+              android:layout_height="match_parent"
+              android:layout_margin="@dimen/activity_horizontal_margin"
+              android:background="@color/screen_background"
+              android:orientation="vertical">
+
+    <TextView
+        android:id="@+id/text_content"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textColor="@android:color/white"/>
+
+    <Button
+        android:id="@+id/start_activity"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/start_activity"/>
+
+    <Button
+        android:id="@+id/start_intent_service"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/start_intent_service"/>
+
+    <Button
+        android:id="@+id/start_receiver"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/start_receiver"/>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/examples/threadExample/src/main/res/layout/fragment_thread.xml b/examples/threadExample/src/main/res/layout/fragment_thread.xml
index da6ce9f539..b065c2f12e 100644
--- a/examples/threadExample/src/main/res/layout/fragment_thread.xml
+++ b/examples/threadExample/src/main/res/layout/fragment_thread.xml
@@ -1,24 +1,8 @@
-<!--
-  ~ Copyright 2014 Realm Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~ http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
 <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:background="@color/fragment_background"
+    android:background="@color/screen_background"
     tools:context=".MainActivity$PlaceholderFragment">
 
     <io.realm.examples.threads.widget.DotsView
diff --git a/examples/threadExample/src/main/res/values/colors.xml b/examples/threadExample/src/main/res/values/colors.xml
index fed83633d3..9d34e34353 100644
--- a/examples/threadExample/src/main/res/values/colors.xml
+++ b/examples/threadExample/src/main/res/values/colors.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    <color name="fragment_background">#333333</color>
+    <color name="screen_background">#333333</color>
     <color name="realm_red">#f0727d</color>
     <color name="realm_blue">#428bca</color>
 </resources>
\ No newline at end of file
diff --git a/examples/threadExample/src/main/res/values/dimens.xml b/examples/threadExample/src/main/res/values/dimens.xml
index 47c8224673..812cb7be0a 100644
--- a/examples/threadExample/src/main/res/values/dimens.xml
+++ b/examples/threadExample/src/main/res/values/dimens.xml
@@ -2,4 +2,5 @@
     <!-- Default screen margins, per the Android Design guidelines. -->
     <dimen name="activity_horizontal_margin">16dp</dimen>
     <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="fab_margin">16dp</dimen>
 </resources>
diff --git a/examples/threadExample/src/main/res/values/strings.xml b/examples/threadExample/src/main/res/values/strings.xml
index 8c5fcdd4e4..bf547346f6 100644
--- a/examples/threadExample/src/main/res/values/strings.xml
+++ b/examples/threadExample/src/main/res/values/strings.xml
@@ -5,7 +5,14 @@
     <string name="action_settings">Settings</string>
     <string name="title_section1">Threads</string>
     <string name="title_section2">AsyncTask</string>
+    <string name="title_section3">Async Query</string>
     <string name="add_dot">Add blue dot</string>
     <string name="clear_dots">Clear dots</string>
+    <string name="translate">Translate Dots</string>
+    <string name="start_activity">Passing to Activity</string>
+    <string name="title_activity_receiving">Receiving Activity</string>
+    <string name="title_section4">Object Passing</string>
+    <string name="start_intent_service">Passing to Intent Service</string>
+    <string name="start_receiver">Passing To Receiver</string>
 
 </resources>
diff --git a/examples/unitTestExample/README.md b/examples/unitTestExample/README.md
new file mode 100644
index 0000000000..59ae35746a
--- /dev/null
+++ b/examples/unitTestExample/README.md
@@ -0,0 +1,27 @@
+# Running The Tests
+Run them in Android Studio or run them via Gradle: 
+
+Instrumentation Tests
+`./gradlew connectedCheck`
+
+Unit Tests
+`./gradlew test` 
+
+# Troubleshooting
+
+Depending on what version of Java you have installed you may encounter the following errors: 
+
+`initializationError(com.your.ClassHere): Bad <init> method call from inside of a branch`
+  
+or
+ 
+`Exception in thread "main" java.lang.annotation.AnnotationFormatError: Invalid default: public abstract java.lang.Class org.robolectric.annotation.Config.application()` 
+
+These issues manifest themselves because of changes to the Java bytecode verifier. 
+A workaround is to set the `-noverify` flag on the the JVM. 
+
+
+Typically, the tests can be run via the command line without fail, however, to get them to run in Android Studio you will need to perform the following steps in your run configurations in Android Studio:
+![Unit Test Config Settings](unittest-config-settings.png)
+
+[Source 1](http://stackoverflow.com/a/25428318/5210) [Source 2](https://code.google.com/p/powermock/issues/detail?id=504)
\ No newline at end of file
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
new file mode 100644
index 0000000000..b2a09b1677
--- /dev/null
+++ b/examples/unitTestExample/build.gradle
@@ -0,0 +1,54 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+apply plugin: 'com.neenbedankt.android-apt'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId 'io.realm.examples.unittesting'
+        targetSdkVersion rootProject.sdkVersion
+        minSdkVersion 15
+        versionCode 1
+        versionName "1.0"
+
+        // Needed for jUnit4 support.
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+
+dependencies {
+    testCompile 'io.reactivex:rxjava:1.1.0'
+
+    // Testing
+    testCompile 'junit:junit:4.12'
+    testCompile "org.robolectric:robolectric:3.0"
+    testCompile "org.mockito:mockito-core:1.10.19"
+    testCompile 'org.robolectric:shadows-support-v4:3.0'
+
+    testCompile "org.powermock:powermock-module-junit4:1.6.4"
+    testCompile "org.powermock:powermock-module-junit4-rule:1.6.4"
+    testCompile "org.powermock:powermock-api-mockito:1.6.4"
+    testCompile "org.powermock:powermock-classloading-xstream:1.6.4"
+
+
+    androidTestCompile 'com.android.support.test:runner:0.4.1'
+    // Set this dependency to use JUnit 4 rules
+    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    // Set this dependency to build and run Espresso tests
+    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1'
+}
diff --git a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit3ExampleTest.java b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit3ExampleTest.java
new file mode 100644
index 0000000000..37d27ded51
--- /dev/null
+++ b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit3ExampleTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting;
+
+import android.test.ActivityInstrumentationTestCase2;
+
+import static android.support.test.espresso.Espresso.onView;
+import static android.support.test.espresso.assertion.ViewAssertions.matches;
+import static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static android.support.test.espresso.matcher.ViewMatchers.withText;
+
+public class jUnit3ExampleTest extends ActivityInstrumentationTestCase2<ExampleActivity> {
+
+    public jUnit3ExampleTest() {
+        super(ExampleActivity.class);
+    }
+
+    public void testShouldBeAbleToLaunchActivityAndSeeRealmResults() {
+        getActivity();
+        onView(withText("John Senior got older: 89")).check(matches(isDisplayed()));
+    }
+}
diff --git a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
new file mode 100644
index 0000000000..ff85292aa6
--- /dev/null
+++ b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting;
+
+
+import android.support.test.rule.ActivityTestRule;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static android.support.test.espresso.Espresso.onView;
+import static android.support.test.espresso.assertion.ViewAssertions.matches;
+import static android.support.test.espresso.matcher.ViewMatchers.isDisplayed;
+import static android.support.test.espresso.matcher.ViewMatchers.withText;
+
+@RunWith(AndroidJUnit4.class)
+public class jUnit4ExampleTest {
+
+    @Rule
+    public ActivityTestRule<ExampleActivity> mActivityRule = new ActivityTestRule(ExampleActivity.class);
+
+    @Test
+    public void testShouldBeAbleToLaunchActivityAndSeeRealmResults() {
+        onView(withText("John Senior got older: 89")).check(matches(isDisplayed()));
+    }
+}
diff --git a/gradle-plugin/sample/src/main/AndroidManifest.xml b/examples/unitTestExample/src/main/AndroidManifest.xml
similarity index 80%
rename from gradle-plugin/sample/src/main/AndroidManifest.xml
rename to examples/unitTestExample/src/main/AndroidManifest.xml
index 7ace7f5483..bdb9f97441 100644
--- a/gradle-plugin/sample/src/main/AndroidManifest.xml
+++ b/examples/unitTestExample/src/main/AndroidManifest.xml
@@ -1,14 +1,14 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.example.sample" >
+    package="io.realm.examples.unittesting" >
 
     <application
         android:allowBackup="true"
-        android:icon="@mipmap/ic_launcher"
+        android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
-            android:name=".MainActivity"
+            android:name=".ExampleActivity"
             android:label="@string/app_name" >
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
new file mode 100644
index 0000000000..4743a84b1e
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting;
+
+import android.app.Activity;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.examples.unittesting.model.Person;
+
+
+public class ExampleActivity extends Activity {
+
+    public static final String TAG = ExampleActivity.class.getName();
+    private LinearLayout rootLayout = null;
+
+    private Realm realm;
+    private static RealmConfiguration realmConfig;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_example);
+        rootLayout = ((LinearLayout) findViewById(R.id.container));
+        rootLayout.removeAllViews();
+
+        // Create Realm configuration if it doesn't exist.
+        realmConfig = new RealmConfiguration.Builder(this).build();
+        // Open the default Realm for the UI thread.
+        realm = Realm.getInstance(realmConfig);
+
+        // Clean up from previous run
+        cleanUp();
+
+        // Small operation that is ok to run on the main thread
+        basicCRUD(realm);
+
+        // More complex operations can be executed on another thread.
+        AsyncTask<Void, Void, String> foo = new AsyncTask<Void, Void, String>() {
+            @Override
+            protected String doInBackground(Void... voids) {
+                String info = "";
+                info += complexQuery();
+                return info;
+            }
+
+            @Override
+            protected void onPostExecute(String result) {
+                showStatus(result);
+            }
+        };
+
+        foo.execute();
+
+        findViewById(R.id.clean_up).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                v.setEnabled(false);
+                cleanUp();
+                v.setEnabled(true);
+            }
+        });
+    }
+
+    private void cleanUp() {
+        // Delete all persons
+        realm.beginTransaction();
+        realm.allObjects(Person.class).clear();
+        realm.commitTransaction();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        realm.close(); // Remember to close Realm when done.
+    }
+
+    private void showStatus(String txt) {
+        Log.i(TAG, txt);
+        TextView tv = new TextView(this);
+        tv.setText(txt);
+        rootLayout.addView(tv);
+    }
+
+    private void basicCRUD(Realm realm) {
+        showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
+
+        // All writes must be wrapped in a transaction to facilitate safe multi threading
+        realm.beginTransaction();
+
+        // Add a person
+        Person person = realm.createObject(Person.class);
+        person.setId(1);
+        person.setName("John Young");
+        person.setAge(14);
+
+        // When the transaction is committed, all changes a synced to disk.
+        realm.commitTransaction();
+
+        // Find the first person (no query conditions) and read a field
+        person = realm.where(Person.class).findFirst();
+        showStatus(person.getName() + ":" + person.getAge());
+
+        // Update person in a transaction
+        realm.beginTransaction();
+        person.setName("John Senior");
+        person.setAge(89);
+        showStatus(person.getName() + " got older: " + person.getAge());
+        realm.commitTransaction();
+
+        // Add two more people
+        realm.beginTransaction();
+
+        Person jane = realm.createObject(Person.class);
+        jane.setName("Jane");
+        jane.setAge(27);
+
+        Person doug = realm.createObject(Person.class);
+        doug.setName("Robert");
+        doug.setAge(42);
+
+        realm.commitTransaction();
+
+        RealmResults<Person> people = realm.where(Person.class).findAll();
+        showStatus(String.format("Found %s people", people.size()));
+        for (Person p : people) {
+            showStatus("Found " + p.getName());
+        }
+    }
+
+    private String complexQuery() {
+        String status = "\n\nPerforming complex Query operation...";
+
+        Realm realm = Realm.getInstance(realmConfig);
+        status += "\nNumber of people in the DB: " + realm.allObjects(Person.class).size();
+
+        // Find all persons where age between 1 and 99 and name begins with "J".
+        RealmResults<Person> results = realm.where(Person.class)
+                .between("age", 1, 99)       // Notice implicit "and" operation
+                .beginsWith("name", "J").findAll();
+        status += "\nNumber of people aged between 1 and 99 who's name start with 'J': " + results.size();
+
+        realm.close();
+        return status;
+    }
+}
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Cat.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Cat.java
new file mode 100644
index 0000000000..d59ea2efd8
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Cat.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting.model;
+
+import io.realm.RealmObject;
+
+public class Cat extends RealmObject {
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Dog.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Dog.java
new file mode 100644
index 0000000000..fc52980dcd
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Dog.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting.model;
+
+import io.realm.RealmObject;
+
+public class Dog extends RealmObject {
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Person.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Person.java
new file mode 100644
index 0000000000..30ae2721a6
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/model/Person.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting.model;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+
+// Your model just have to extend RealmObject.
+// This will inherit an annotation which produces proxy getters and setters for all fields.
+public class Person extends RealmObject {
+
+    // All fields are by default persisted.
+    private String name;
+    private int age;
+
+    // Other objects in a one-to-one relation must also subclass RealmObject
+    private Dog dog;
+
+    // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
+    private RealmList<Cat> cats;
+
+    // You can instruct Realm to ignore a field and not persist it.
+    @Ignore
+    private int tempReference;
+
+    private long id;
+
+    // The standard getters and setters your IDE generates are fine.
+    // Realm will overload them and code inside them is ignored.
+    // So if you prefer you can also just have empty abstract methods.
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return age;
+    }
+
+    public void setAge(int age) {
+        this.age = age;
+    }
+
+    public Dog getDog() {
+        return dog;
+    }
+
+    public void setDog(Dog dog) {
+        this.dog = dog;
+    }
+
+    public RealmList<Cat> getCats() {
+        return cats;
+    }
+
+    public void setCats(RealmList<Cat> cats) {
+        this.cats = cats;
+    }
+
+    public int getTempReference() {
+        return tempReference;
+    }
+
+    public void setTempReference(int tempReference) {
+        this.tempReference = tempReference;
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+}
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepository.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepository.java
new file mode 100644
index 0000000000..9a66534a0c
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepository.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting.repository;
+
+public interface DogRepository {
+    void createDog(String name);
+}
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
new file mode 100644
index 0000000000..d9ba05e744
--- /dev/null
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting.repository;
+
+import io.realm.Realm;
+import io.realm.examples.unittesting.model.Dog;
+
+
+public class DogRepositoryImpl implements DogRepository {
+    @Override
+    public void createDog(String name) {
+        Realm realm = Realm.getDefaultInstance();
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName(name);
+        realm.commitTransaction();
+        realm.close();
+    }
+}
diff --git a/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/layout/activity_example.xml b/examples/unitTestExample/src/main/res/layout/activity_example.xml
new file mode 100644
index 0000000000..f82b79be96
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/layout/activity_example.xml
@@ -0,0 +1,35 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <Button
+            android:id="@+id/clean_up"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:text="@string/clean_up"
+            />
+        <TextView
+            android:gravity="center_horizontal"
+            android:text="Status Output..."
+            android:textStyle="bold"
+            android:textSize="18sp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+        <LinearLayout
+            android:id="@+id/container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:paddingTop="10sp"
+            android:orientation="vertical"
+            tools:context=".RealmIntroExample"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/unitTestExample/src/main/res/values-w820dp/dimens.xml b/examples/unitTestExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/examples/unitTestExample/src/main/res/values/dimens.xml b/examples/unitTestExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/unitTestExample/src/main/res/values/strings.xml b/examples/unitTestExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..fc3035ca36
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/values/strings.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Unit Test Example</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+    <string name="clean_up">Clean Up</string>
+
+</resources>
diff --git a/examples/unitTestExample/src/main/res/values/styles.xml b/examples/unitTestExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ff6c9d2c0f
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
new file mode 100644
index 0000000000..83c5e3c4b2
--- /dev/null
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting;
+
+import android.content.Context;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ActivityController;
+
+import java.lang.Exception;
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmObject;
+import io.realm.RealmQuery;
+import io.realm.RealmResults;
+import io.realm.examples.unittesting.ExampleActivity;
+import io.realm.examples.unittesting.model.Person;
+import io.realm.internal.RealmCore;
+
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.mock;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.verifyStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+import static org.powermock.api.mockito.PowerMockito.whenNew;
+import static org.powermock.api.mockito.PowerMockito.doNothing;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = BuildConfig.class, sdk = 21)
+@PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
+@PrepareForTest({Realm.class, RealmConfiguration.class, RealmResults.class, RealmCore.class})
+public class ExampleActivityTest {
+
+    // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
+
+    @Rule
+    public PowerMockRule rule = new PowerMockRule();
+
+    private Realm mockRealm;
+    private RealmResults<Person> people;
+
+    @Before
+    public void setup() throws Exception {
+
+        // Setup Realm to be mocked
+        mockStatic(Realm.class);
+        mockStatic(RealmConfiguration.class);
+        mockStatic(RealmCore.class);
+
+        // Create the mock
+        final Realm mockRealm = mock(Realm.class);
+        final RealmConfiguration mockRealmConfig = mock(RealmConfiguration.class);
+
+        // TODO: Better solution would be just mock the RealmConfiguration.Builder class. But it seems there is some
+        // problems for powermock to mock it (static inner class). We just mock the RealmCore.loadLibrary(Context) which
+        // will be called by RealmConfiguration.Builder's constructor.
+        doNothing().when(RealmCore.class);
+        RealmCore.loadLibrary(any(Context.class));
+
+        // TODO: Mock the RealmConfiguration's constructor. If the RealmConfiguration.Builder.build can be mocked, this
+        // is not necessary anymore.
+        whenNew(RealmConfiguration.class).withAnyArguments().thenReturn(mockRealmConfig);
+
+        // Anytime getInstance is called with any configuration, then return the mockRealm
+        when(Realm.getInstance(any(RealmConfiguration.class))).thenReturn(mockRealm);
+
+        // Anytime we ask Realm to create a Person, return a new instance.
+        when(mockRealm.createObject(Person.class)).thenReturn(new Person());
+
+        // Set up some naive stubs
+        Person p1 = new Person();
+        p1.setAge(14);
+        p1.setName("John Young");
+
+        Person p2 = new Person();
+        p2.setAge(89);
+        p2.setName("John Senior");
+
+        Person p3 = new Person();
+        p3.setAge(27);
+        p3.setName("Jane");
+
+        Person p4 = new Person();
+        p4.setAge(42);
+        p4.setName("Robert");
+
+        List<Person> personList = Arrays.asList(p1, p2, p3, p4);
+
+        // Create a mock RealmQuery
+        RealmQuery<Person> personQuery = mockRealmQuery();
+
+        // When the RealmQuery performs findFirst, return the first record in the list.
+        when(personQuery.findFirst()).thenReturn(personList.get(0));
+
+        // When the where clause is called on the Realm, return the mock query.
+        when(mockRealm.where(Person.class)).thenReturn(personQuery);
+
+        // When the RealmQuery is filtered on any string and any integer, return the person query
+        when(personQuery.equalTo(anyString(), anyInt())).thenReturn(personQuery);
+
+        // RealmResults is final, must mock static and also place this in the PrepareForTest annotation array.
+        mockStatic(RealmResults.class);
+
+        // Create a mock RealmResults
+        RealmResults<Person> people = mockRealmResults();
+
+        // When we ask Realm for all of the Person instances, return the mock RealmResults
+        when(mockRealm.allObjects(Person.class)).thenReturn(people);
+
+        // When a between query is performed with any string as the field and any int as the
+        // value, then return the personQuery itself
+        when(personQuery.between(anyString(), anyInt(), anyInt())).thenReturn(personQuery);
+
+        // When a beginsWith clause is performed with any string field and any string value
+        // return the same person query
+        when(personQuery.beginsWith(anyString(), anyString())).thenReturn(personQuery);
+
+        // When we ask the RealmQuery for all of the Person objects, return the mock RealmResults
+        when(personQuery.findAll()).thenReturn(people);
+
+
+        // The for(...) loop in Java needs an iterator, so we're giving it one that has items,
+        // since the mock RealmResults does not provide an implementation. Therefore, anytime
+        // anyone asks for the RealmResults Iterator, give them a functioning iterator from the
+        // ArrayList of Persons we created above. This will allow the loop to execute.
+        when(people.iterator()).thenReturn(personList.iterator());
+
+        // Return the size of the mock list.
+        when(people.size()).thenReturn(personList.size());
+
+        this.mockRealm = mockRealm;
+        this.people = people;
+    }
+
+
+    @Test
+    public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
+        // Create activity
+        ActivityController<ExampleActivity> controller =
+                Robolectric.buildActivity(ExampleActivity.class).setup();
+        ExampleActivity activity = controller.get();
+
+        assertThat(activity.getTitle().toString(), is("Unit Test Example"));
+
+        // Verify that two Realm.getInstance() calls took place.
+        verifyStatic(times(2));
+        Realm.getInstance(any(RealmConfiguration.class));
+
+        // verify that we have four begin and commit transaction calls
+        verify(mockRealm, times(4)).beginTransaction();
+        verify(mockRealm, times(4)).commitTransaction();
+
+        // Click the clean up button
+        activity.findViewById(R.id.clean_up).performClick();
+
+        // Verify that begin and commit transaction were called (been called a total of 5 times now)
+        verify(mockRealm, times(5)).beginTransaction();
+        verify(mockRealm, times(5)).commitTransaction();
+
+        // Verify that we queried for all Person instance two times in this run (in the original
+        // onCreate, and then again in the button click). Was called two times previously in the
+        // setup, therefore we need to check if it was called again.
+        verify(mockRealm, times(3)).allObjects(Person.class);
+
+        // Verify that the clear method was called. Clear is also called in the start of the
+        // activity to ensure we start with a clean db.
+        verify(people, times(2)).clear();
+
+        // Call the destroy method so we can verify that the .close() method was called (below)
+        controller.destroy();
+
+        // Verify that the realm got closed 2 separate times. Once in the AsyncTask, once
+        // in onDestroy
+        verify(mockRealm, times(2)).close();
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T extends RealmObject> RealmQuery<T> mockRealmQuery() {
+        return mock(RealmQuery.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T extends RealmObject> RealmResults<T> mockRealmResults() {
+        return mock(RealmResults.class);
+    }
+}
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
new file mode 100644
index 0000000000..8aef6265e8
--- /dev/null
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.unittesting;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.rule.PowerMockRule;
+import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.annotation.Config;
+
+import io.realm.Realm;
+import io.realm.examples.unittesting.model.Dog;
+import io.realm.examples.unittesting.repository.DogRepository;
+import io.realm.examples.unittesting.repository.DogRepositoryImpl;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.internal.verification.VerificationModeFactory.times;
+import static org.powermock.api.mockito.PowerMockito.mockStatic;
+import static org.powermock.api.mockito.PowerMockito.when;
+
+@RunWith(RobolectricGradleTestRunner.class)
+@Config(constants = BuildConfig.class, sdk = 19)
+@PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
+@PrepareForTest({Realm.class})
+public class ExampleRealmTest {
+    // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
+
+    @Rule
+    public PowerMockRule rule = new PowerMockRule();
+    Realm mockRealm;
+
+    @Before
+    public void setup() {
+        mockStatic(Realm.class);
+
+        Realm mockRealm = PowerMockito.mock(Realm.class);
+
+        when(Realm.getDefaultInstance()).thenReturn(mockRealm);
+
+        this.mockRealm = mockRealm;
+    }
+
+    @Test
+    public void shouldBeAbleToGetDefaultInstance() {
+        assertThat(Realm.getDefaultInstance(), is(mockRealm));
+    }
+
+    @Test
+    public void shouldBeAbleToMockRealmMethods() {
+        when(mockRealm.isAutoRefresh()).thenReturn(true);
+        assertThat(mockRealm.isAutoRefresh(), is(true));
+
+        when(mockRealm.isAutoRefresh()).thenReturn(false);
+        assertThat(mockRealm.isAutoRefresh(), is(false));
+    }
+
+    @Test
+    public void shouldBeAbleToCreateARealmObject() {
+        Dog dog = new Dog();
+        when(mockRealm.createObject(Dog.class)).thenReturn(dog);
+
+        Dog output = mockRealm.createObject(Dog.class);
+
+        assertThat(output, is(dog));
+    }
+
+    /**
+     * This test verifies the behavior in the {@link DogRepositoryImpl} class.
+     */
+    @Test
+    public void shouldVerifyTransactionWasCreated() {
+
+        Dog dog = mock(Dog.class);
+        when(mockRealm.createObject(Dog.class)).thenReturn(dog);
+
+        DogRepository dogRepo = new DogRepositoryImpl();
+        dogRepo.createDog("Spot");
+
+        // Verify that the begin transaction was called only once
+        verify(mockRealm, times(1)).beginTransaction();
+
+        // Verify that Realm#createObject was called only once
+        verify(mockRealm, times(1)).createObject(Dog.class); // Verify that a Dog was in fact created.
+
+        // Verify that Dog#setName() is called only once
+        verify(dog, times(1)).setName(Mockito.anyString()); // Any string will do
+
+        // Verify that the transaction was committed only once
+        verify(mockRealm, times(1)).commitTransaction();
+
+        // Verify that the Realm was closed only once.
+        verify(mockRealm, times(1)).close();
+    }
+}
diff --git a/examples/unitTestExample/unittest-config-settings.png b/examples/unitTestExample/unittest-config-settings.png
new file mode 100644
index 0000000000..95317178c6
Binary files /dev/null and b/examples/unitTestExample/unittest-config-settings.png differ
diff --git a/experimental/pathExperiment/README.md b/experimental/pathExperiment/README.md
deleted file mode 100644
index f8d468ec11..0000000000
--- a/experimental/pathExperiment/README.md
+++ /dev/null
@@ -1,14 +0,0 @@
-## Path/EventBus interoperability test
-
-This project tests how well Realm works with Paths' Android Priority Job Queue and greenrobot's EventBus
-
-Path: https://github.com/path/android-priority-jobqueue
-
-Eventbus: http://greenrobot.github.io/EventBus/
-
-## Conclusion
-
-- There should be no problem with Path as long as Realm interaction is contained within each Job.
-
-- Eventbus works fine with the default settings, but care must be taken by users not to pass Realm objects
-  between threads, ie. using onEventMainThread() instead of onEvent().
diff --git a/experimental/pathExperiment/build.gradle b/experimental/pathExperiment/build.gradle
deleted file mode 100644
index ea992a99d8..0000000000
--- a/experimental/pathExperiment/build.gradle
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'com.android.application'
-
-android {
-    compileSdkVersion 21
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.pathrealminteroptest"
-        minSdkVersion 15
-        targetSdkVersion 21
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-
-    packagingOptions {
-        exclude 'META-INF/services/javax.annotation.processing.Processor'
-    }
-}
-
-dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile 'com.android.support:appcompat-v7:21.0.0'
-    compile 'com.path:android-priority-jobqueue:1.1.2'
-    compile 'com.jakewharton:butterknife:6.0.0'
-    compile 'de.greenrobot:eventbus:2.2.1'
-}
-
-
-tasks.preBuild {
-    dependsOn ":realm:androidJar"
-}
-
-dependencies {
-    compile files("../../realm/build/libs/realm-${version}.jar")
-}
diff --git a/experimental/pathExperiment/proguard-rules.pro b/experimental/pathExperiment/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/experimental/pathExperiment/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/experimental/pathExperiment/src/main/AndroidManifest.xml b/experimental/pathExperiment/src/main/AndroidManifest.xml
deleted file mode 100644
index c3fb992f8d..0000000000
--- a/experimental/pathExperiment/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright 2014 Realm Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~ http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.path" >
-
-    <!-- Required by Android Job Queue -->
-    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-
-    <application
-        android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name"
-        android:theme="@style/AppTheme" >
-        <activity
-            android:name="io.realm.path.MainActivity"
-            android:label="@string/app_name" >
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-
-</manifest>
diff --git a/experimental/pathExperiment/src/main/java/io/realm/path/AddPersonJob.java b/experimental/pathExperiment/src/main/java/io/realm/path/AddPersonJob.java
deleted file mode 100644
index 4105e331f5..0000000000
--- a/experimental/pathExperiment/src/main/java/io/realm/path/AddPersonJob.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.path;
-
-import android.os.Looper;
-import android.util.Log;
-
-import com.path.android.jobqueue.Job;
-import com.path.android.jobqueue.Params;
-
-import java.util.Random;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import de.greenrobot.event.EventBus;
-import io.realm.Realm;
-
-public class AddPersonJob extends Job {
-    private static final AtomicInteger jobCounter = new AtomicInteger(0);
-
-    private final int id;
-    private final Random random = new Random();
-
-    MainActivity context;
-
-    public AddPersonJob(MainActivity context) {
-        super(new Params(1));
-        id = jobCounter.incrementAndGet();
-        this.context = context;
-    }
-
-    @Override
-    public void onAdded() {
-
-    }
-
-    @Override
-    public void onRun() throws Throwable {
-        if (id != jobCounter.get()) {
-            //looks like other fetch jobs has been added after me. no reason to keep fetching
-            //many times, cancel me, let the other one fetch tweets.
-            return;
-        }
-        Log.d("Job Manager", "Job Started, Main Thread:" + (Looper.myLooper() == Looper.getMainLooper()));
-
-        Realm realm = Realm.getInstance(context);
-        realm.beginTransaction();
-        Person p = realm.createObject(Person.class);
-        p.setPerson(getRandomName());
-        p.setAge(getRandomAge());
-        realm.commitTransaction();
-
-        // Beware of this. EventHandler might be on another thread, but as long as you use
-        // onEvent(Person person) you should be fine
-        EventBus.getDefault().post(p);
-    }
-
-    private int getRandomAge() {
-        return random.nextInt(100);
-    }
-
-    private String getRandomName() {
-        String[] names = new String[] { "John", "Frank", "Niels"};
-        return names[random.nextInt(names.length)];
-    }
-
-    @Override
-    protected void onCancel() {
-        // Ignore
-    }
-
-    @Override
-    protected boolean shouldReRunOnThrowable(Throwable throwable) {
-        return false;
-    }
-}
diff --git a/experimental/pathExperiment/src/main/java/io/realm/path/MainActivity.java b/experimental/pathExperiment/src/main/java/io/realm/path/MainActivity.java
deleted file mode 100644
index 0218383f54..0000000000
--- a/experimental/pathExperiment/src/main/java/io/realm/path/MainActivity.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.path;
-
-import android.os.Bundle;
-import android.support.v7.app.ActionBarActivity;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.path.android.jobqueue.JobManager;
-
-import butterknife.ButterKnife;
-import butterknife.InjectView;
-import butterknife.OnClick;
-import de.greenrobot.event.EventBus;
-
-
-public class MainActivity extends ActionBarActivity {
-
-    @InjectView(R.id.list) LinearLayout list;
-
-    private EventBus bus;
-    private JobManager jobManager;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-        ButterKnife.inject(this);
-        bus = EventBus.getDefault();
-        bus.register(this);
-        jobManager = new JobManager(this);
-    }
-
-    @OnClick(R.id.button)
-    public void addPerson() {
-        jobManager.addJob(new AddPersonJob(this));
-    }
-
-    // Callback from EventBus on the same thread as the job which posted the event. This is not executed on the UI thread.
-    public void onEvent(Person person) {
-        final String description = person.toString();
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Toast.makeText(MainActivity.this, description, Toast.LENGTH_SHORT).show();
-                TextView view = new TextView(MainActivity.this);
-                view.setText(description);
-                list.addView(view);
-            }
-        });
-    }
-}
diff --git a/experimental/pathExperiment/src/main/res/layout/activity_main.xml b/experimental/pathExperiment/src/main/res/layout/activity_main.xml
deleted file mode 100644
index b1a89d544b..0000000000
--- a/experimental/pathExperiment/src/main/res/layout/activity_main.xml
+++ /dev/null
@@ -1,38 +0,0 @@
-<!--
-  ~ Copyright 2014 Realm Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~ http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin"
-    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">
-
-    <Button
-        android:id="@+id/button"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:text="Load person" />
-
-    <LinearLayout
-        android:id="@+id/list"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical"></LinearLayout>
-
-</LinearLayout>
diff --git a/experimental/pathExperiment/src/main/res/menu/menu_main.xml b/experimental/pathExperiment/src/main/res/menu/menu_main.xml
deleted file mode 100644
index b1cb90811d..0000000000
--- a/experimental/pathExperiment/src/main/res/menu/menu_main.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools" tools:context=".MainActivity">
-    <item android:id="@+id/action_settings" android:title="@string/action_settings"
-        android:orderInCategory="100" app:showAsAction="never" />
-</menu>
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index e69de29bb2..dec61401ca 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -0,0 +1,150 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+    }
+}
+
+apply plugin: 'groovy'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'com.jfrog.bintray'
+
+def props = new Properties()
+props.load(new FileInputStream("${rootDir}/../realm.properties"))
+props.each { key, val ->
+    project.set(key, val)
+}
+
+repositories {
+    mavenLocal()
+    jcenter()
+}
+
+sourceCompatibility = 1.6
+targetCompatibility = 1.6
+
+group = 'io.realm'
+version = file("${projectDir}/../version.txt").text.trim();
+
+configurations {
+    provided
+    compile.extendsFrom provided
+}
+
+sourceSets {
+    main {
+        compileClasspath += configurations.provided
+    }
+}
+
+dependencies {
+    compile gradleApi()
+    compile localGroovy()
+    compile "io.realm:realm-transformer:${version}"
+    compile 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+    provided 'com.android.tools.build:gradle:1.5.0'
+
+    testCompile gradleTestKit()
+    testCompile 'junit:junit:4.12'
+}
+
+//for Ant filter
+import org.apache.tools.ant.filters.ReplaceTokens
+
+task generateVersionClass(type: Copy) {
+    from 'src/main/templates/Version.java'
+    into 'build/generated-src/main/java/io/realm'
+    filter(ReplaceTokens, tokens: [version: version])
+    outputs.upToDateWhen { false }
+}
+
+// Include the generated Version file
+sourceSets {
+    main {
+        java {
+            srcDir 'build/generated-src/main/java'
+        }
+    }
+}
+
+compileJava.dependsOn generateVersionClass
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+}
+
+def commonPom = {
+    licenses {
+        license {
+            name 'The Apache Software License, Version 2.0'
+            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+            distribution 'repo'
+        }
+    }
+    issueManagement {
+        system 'github'
+        url 'https://github.com/realm/realm-java/issues'
+    }
+    scm {
+        url 'scm:https://github.com/realm/realm-java'
+        connection 'scm:git@github.com:realm/realm-java.git'
+        developerConnection 'scm:git@github.com:realm/realm-java.git'
+    }
+}
+
+publishing {
+    publications {
+        realmPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId = 'realm-gradle-plugin'
+            from components.java
+            pom.withXml {
+                Node root = asNode()
+                root.appendNode('name', 'realm-gradle-plugin')
+                root.appendNode('description', 'Gradle plugin for Realm. Realm is a mobile database: a replacement for SQLite & ORMs.')
+                root.appendNode('url', 'http://realm.io')
+                root.children().last() + commonPom
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+
+    dryRun = false
+    publish = false
+
+    publications = ['realmPublication']
+    pkg {
+        repo = 'maven'
+        name = 'realm-gradle-plugin'
+        desc = 'Realm for Android'
+        websiteUrl = 'http://realm.io'
+        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
+        vcsUrl = 'https://github.com/realm/realm-java.git'
+        licenses = ['Apache-2.0']
+        labels = ['android', 'realm']
+        publicDownloadNumbers = false
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+        }
+        defaults {
+            publications ('realmPublication')
+        }
+    }
+}
diff --git a/gradle-plugin/buildSrc/build.gradle b/gradle-plugin/buildSrc/build.gradle
deleted file mode 100644
index 362a110e65..0000000000
--- a/gradle-plugin/buildSrc/build.gradle
+++ /dev/null
@@ -1,7 +0,0 @@
-repositories {
-    mavenCentral()
-}
-
-rootProject.dependencies {
-    compile project(':plugin')
-}
diff --git a/gradle-plugin/buildSrc/settings.gradle b/gradle-plugin/buildSrc/settings.gradle
deleted file mode 100644
index adade62679..0000000000
--- a/gradle-plugin/buildSrc/settings.gradle
+++ /dev/null
@@ -1,2 +0,0 @@
-include ':plugin'
-project(':plugin').projectDir = new File('../plugin')
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 81dec0a9e0..587246a1a4 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Mon May 04 12:41:37 CEST 2015
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/gradle-plugin/plugin/build.gradle b/gradle-plugin/plugin/build.gradle
deleted file mode 100644
index 129a80f1d3..0000000000
--- a/gradle-plugin/plugin/build.gradle
+++ /dev/null
@@ -1,6 +0,0 @@
-apply plugin: 'groovy'
-
-dependencies {
-    compile gradleApi()
-    compile localGroovy()
-}
diff --git a/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
deleted file mode 100644
index ae0629396e..0000000000
--- a/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ /dev/null
@@ -1,13 +0,0 @@
-package io.realm.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-
-class Realm implements Plugin<Project> {
-
-    @Override
-    void apply(Project project) {
-    	project.repositories.add(project.repositories.jcenter())
-        project.dependencies.add('compile', 'io.realm:realm-android:0.80.3') // TODO: make version dynamic
-    }
-}
diff --git a/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties b/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties
deleted file mode 100644
index ff071ff56f..0000000000
--- a/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties
+++ /dev/null
@@ -1 +0,0 @@
-implementation-class=io.realm.gradle.Realm
diff --git a/gradle-plugin/sample/.gitignore b/gradle-plugin/sample/.gitignore
deleted file mode 100644
index 9c4de5825b..0000000000
--- a/gradle-plugin/sample/.gitignore
+++ /dev/null
@@ -1,7 +0,0 @@
-.gradle
-/local.properties
-/.idea/workspace.xml
-/.idea/libraries
-.DS_Store
-/build
-/captures
diff --git a/gradle-plugin/sample/build.gradle b/gradle-plugin/sample/build.gradle
deleted file mode 100644
index 051982e69f..0000000000
--- a/gradle-plugin/sample/build.gradle
+++ /dev/null
@@ -1,37 +0,0 @@
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.android.tools.build:gradle:1.1.0'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.+'
-    }
-}
-
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'realm'
-
-android {
-    compileSdkVersion 22
-    buildToolsVersion "21.1.2"
-
-    defaultConfig {
-        applicationId "io.realm.example.sample"
-        minSdkVersion 15
-        targetSdkVersion 22
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-}
-
-dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    compile 'com.android.support:appcompat-v7:22.0.0'
-}
diff --git a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index 8c0fb64a86..0000000000
Binary files a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java b/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java
deleted file mode 100644
index cc30e9f85b..0000000000
--- a/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.example.sample;
-
-import android.os.Bundle;
-import android.support.v7.app.ActionBarActivity;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.widget.Toast;
-
-import io.realm.Realm;
-import io.realm.RealmResults;
-import io.realm.example.sample.models.Person;
-
-
-public class MainActivity extends ActionBarActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_main);
-
-        Realm realm = Realm.getInstance(this);
-        RealmResults<Person> persons = realm.allObjects(Person.class);
-        if (persons.isEmpty()) {
-            Toast toast = Toast.makeText(this, "No persons in the Realm file", Toast.LENGTH_SHORT);
-            toast.show();
-        }
-        realm.close();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        // Inflate the menu; this adds items to the action bar if it is present.
-        getMenuInflater().inflate(R.menu.menu_main, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        // Handle action bar item clicks here. The action bar will
-        // automatically handle clicks on the Home/Up button, so long
-        // as you specify a parent activity in AndroidManifest.xml.
-        int id = item.getItemId();
-
-        //noinspection SimplifiableIfStatement
-        if (id == R.id.action_settings) {
-            return true;
-        }
-
-        return super.onOptionsItemSelected(item);
-    }
-}
diff --git a/gradle-plugin/sample/src/main/res/layout/activity_main.xml b/gradle-plugin/sample/src/main/res/layout/activity_main.xml
deleted file mode 100644
index 53ce5577b5..0000000000
--- a/gradle-plugin/sample/src/main/res/layout/activity_main.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-                xmlns:tools="http://schemas.android.com/tools"
-                android:layout_width="match_parent"
-                android:layout_height="match_parent"
-                android:paddingLeft="@dimen/activity_horizontal_margin"
-                android:paddingRight="@dimen/activity_horizontal_margin"
-                android:paddingTop="@dimen/activity_vertical_margin"
-                android:paddingBottom="@dimen/activity_vertical_margin"
-                tools:context=".MainActivity">
-
-    <TextView
-        android:text="@string/hello_world"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"/>
-
-</RelativeLayout>
diff --git a/gradle-plugin/sample/src/main/res/menu/menu_main.xml b/gradle-plugin/sample/src/main/res/menu/menu_main.xml
deleted file mode 100644
index a459e0a540..0000000000
--- a/gradle-plugin/sample/src/main/res/menu/menu_main.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-      xmlns:app="http://schemas.android.com/apk/res-auto"
-      xmlns:tools="http://schemas.android.com/tools"
-      tools:context=".MainActivity">
-    <item android:id="@+id/action_settings"
-          android:title="@string/action_settings"
-          android:orderInCategory="100"
-          app:showAsAction="never"/>
-</menu>
diff --git a/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png
deleted file mode 100644
index 284223f4b4..0000000000
Binary files a/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png
deleted file mode 100644
index 701b3e88df..0000000000
Binary files a/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png
deleted file mode 100644
index cf218ff34c..0000000000
Binary files a/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
deleted file mode 100644
index 1713efc4e5..0000000000
Binary files a/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
deleted file mode 100644
index c66b37ef61..0000000000
Binary files a/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/gradle-plugin/sample/src/main/res/values/strings.xml b/gradle-plugin/sample/src/main/res/values/strings.xml
deleted file mode 100644
index e0d4f68746..0000000000
--- a/gradle-plugin/sample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<resources>
-    <string name="app_name">sample</string>
-
-    <string name="hello_world">Hello world!</string>
-    <string name="action_settings">Settings</string>
-</resources>
diff --git a/gradle-plugin/settings.gradle b/gradle-plugin/settings.gradle
index 0e9d5443e0..e547635bbd 100644
--- a/gradle-plugin/settings.gradle
+++ b/gradle-plugin/settings.gradle
@@ -1,4 +1 @@
-rootProject.name = 'gradle-plugin'
-include 'plugin'
-include 'sample'
-
+rootProject.name = 'realm-gradle-plugin'
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
new file mode 100644
index 0000000000..f5f9419e05
--- /dev/null
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.gradle
+
+import com.android.build.gradle.AppPlugin
+import com.android.build.gradle.LibraryPlugin
+import com.neenbedankt.gradle.androidapt.AndroidAptPlugin
+import io.realm.transformer.RealmTransformer
+import org.gradle.api.GradleException
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+
+class Realm implements Plugin<Project> {
+
+    @Override
+    void apply(Project project) {
+        // Make sure the project is either an Android application or library
+        def isAndroidApp = project.plugins.withType(AppPlugin)
+        def isAndroidLib = project.plugins.withType(LibraryPlugin)
+        if (!isAndroidApp && !isAndroidLib) {
+            throw new GradleException("'com.android.application' or 'com.android.library' plugin required.")
+        }
+
+        if (!isTransformAvailable()) {
+            throw new GradleException('Realm gradle plugin only supports android gradle plugin 1.5.0 or later.')
+        }
+
+        def isKotlinProject = project.plugins.find {
+            it.getClass().name == 'org.jetbrains.kotlin.gradle.plugin.KotlinAndroidPluginWrapper'
+        }
+
+        if (!isKotlinProject) {
+            project.plugins.apply(AndroidAptPlugin)
+        }
+
+        project.android.registerTransform(new RealmTransformer())
+        project.repositories.add(project.getRepositories().jcenter())
+        project.repositories.add(project.repositories.maven { url "https://jitpack.io" })
+        project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
+        project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
+        if (isKotlinProject) {
+            project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+        } else {
+            project.dependencies.add("apt", "io.realm:realm-annotations:${Version.VERSION}")
+            project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
+        }
+    }
+
+    private static boolean isTransformAvailable() {
+        try {
+            Class.forName('com.android.build.api.transform.Transform')
+            return true
+        } catch (Exception ignored) {
+            return false
+        }
+    }
+}
diff --git a/gradle-plugin/src/main/resources/META-INF/gradle-plugins/realm-android.properties b/gradle-plugin/src/main/resources/META-INF/gradle-plugins/realm-android.properties
new file mode 100644
index 0000000000..0e110fa0c7
--- /dev/null
+++ b/gradle-plugin/src/main/resources/META-INF/gradle-plugins/realm-android.properties
@@ -0,0 +1,16 @@
+#
+# Copyright 2016 Realm Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+implementation-class=io.realm.gradle.Realm
diff --git a/realm-annotations-processor/src/main/templates/Version.java b/gradle-plugin/src/main/templates/Version.java
similarity index 73%
rename from realm-annotations-processor/src/main/templates/Version.java
rename to gradle-plugin/src/main/templates/Version.java
index 81d96b5fe5..330285c5a5 100644
--- a/realm-annotations-processor/src/main/templates/Version.java
+++ b/gradle-plugin/src/main/templates/Version.java
@@ -1,4 +1,4 @@
-package io.realm.processor;
+package io.realm.gradle;
 
 public class Version {
 	public static final String VERSION = "@version@";
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
new file mode 100644
index 0000000000..e7be7c0de8
--- /dev/null
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.gradle
+
+import com.android.build.api.transform.Transform
+import org.gradle.api.GradleException
+import org.gradle.api.Project
+import org.gradle.api.artifacts.Dependency
+import org.gradle.api.artifacts.DependencySet
+import org.gradle.api.artifacts.dsl.DependencyHandler
+import org.gradle.api.artifacts.dsl.RepositoryHandler
+import org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler
+import org.gradle.api.internal.plugins.PluginApplicationException
+import org.gradle.testfixtures.ProjectBuilder
+import org.junit.Before
+import org.junit.Test
+
+import static org.junit.Assert.assertEquals
+import static org.junit.Assert.assertTrue
+import static org.junit.Assert.fail
+
+class PluginTest {
+
+    private Project project
+    private String currentVersion
+
+    @Before
+    public void setUp() {
+        project = ProjectBuilder.builder().build()
+        currentVersion = new File("../version.txt").text.trim()
+    }
+
+    @Test
+    public void pluginAddsRightDependencies() {
+        project.buildscript {
+            repositories {
+                mavenLocal()
+                jcenter()
+            }
+            dependencies {
+                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+                classpath "io.realm:realm-gradle-plugin:${currentVersion}"
+            }
+        }
+
+        project.apply plugin: 'com.android.application'
+        project.apply plugin: 'realm-android'
+
+        assertTrue(containsUrl(project.repositories, 'https://jitpack.io'))
+
+        assertTrue(containsDependency(project.dependencies, 'io.realm', 'realm-android-library', currentVersion))
+        assertTrue(containsDependency(project.dependencies, 'io.realm', 'realm-annotations', currentVersion))
+
+        assertTrue(containsTransform(project.android.transforms, RealmTransformer.class))
+    }
+
+    @Test
+    public void pluginFailsWithoutAndroidPlugin() {
+        project.buildscript {
+            repositories {
+                mavenLocal()
+                jcenter()
+            }
+            dependencies {
+                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+                classpath "io.realm:realm-gradle-plugin:${currentVersion}"
+            }
+        }
+
+        try {
+            project.apply plugin: 'realm-android'
+            fail()
+        } catch (PluginApplicationException e) {
+            assertEquals(e.getCause().class, GradleException.class)
+            assertTrue(e.getCause().getMessage().contains("'com.android.application' or 'com.android.library' plugin required."))
+        }
+    }
+
+    private static boolean containsUrl(RepositoryHandler repositories, String url) {
+        for (repo in repositories) {
+            if (repo.properties.get('url').toString() == url) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private static boolean containsDependency(DependencyHandler dependencies,
+                                              String group, String name, String version) {
+        def configurationContainerField = DefaultDependencyHandler.class.getDeclaredField("configurationContainer")
+        configurationContainerField.setAccessible(true)
+        def configurationContainer = configurationContainerField.get(dependencies)
+        def compileConfiguration = configurationContainer.findByName("compile")
+
+        def DependencySet dependencySet = compileConfiguration.getDependencies()
+        for (Dependency dependency in dependencySet) {
+            if (dependency.properties.group == group
+                    && dependency.properties.name == name
+                    && dependency.properties.version == version) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private static boolean containsTransform(List<Transform> transformList, Class<? extends Transform> targetClass) {
+        for (Transform t : transformList) {
+            if (t.getClass() == targetClass) {
+                return true
+            }
+        }
+        return false
+    }
+}
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000000..00ce074090
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1 @@
+org.gradle.jvmargs=-XX:MaxPermSize=512m
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index b761216703..e8c6bf7bb4 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 8e249d4007..587246a1a4 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,22 +1,6 @@
-#
-# Copyright 2014 Realm Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-#Fri Dec 05 09:22:17 CET 2014
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/gradlew b/gradlew
index 91a7e269e1..97fac783e1 100755
--- a/gradlew
+++ b/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/realm-annotations-processor/build.gradle b/realm-annotations-processor/build.gradle
deleted file mode 100644
index 710ac6ef5a..0000000000
--- a/realm-annotations-processor/build.gradle
+++ /dev/null
@@ -1,83 +0,0 @@
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.1'
-    }
-}
-
-apply plugin: 'java'
-apply plugin: 'com.github.johnrengelman.shadow'
-
-version = new File("${projectDir}/../version.txt").text.trim();
-sourceCompatibility = '1.6'
-targetCompatibility = '1.6'
-
-repositories {
-    jcenter()
-}
-
-Properties localProperties = new Properties()
-localProperties.load(new FileInputStream("${projectDir}/../local.properties"))
-localProperties.entrySet().each() { entry ->
-    project.ext[entry.getKey()] = localProperties.setProperty(entry.getKey(), entry.getValue())
-}
-
-dependencies {
-    compile group:'com.squareup', name:'javawriter', version:'2.5.0'
-    compile files("../realm-annotations/build/libs/realm-annotations-${version}.jar")
-    testCompile files('../realm/build/intermediates/bundles/debug/classes.jar')
-    testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
-    testCompile group:'junit', name:'junit', version:'4.11'
-    testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(new File(project.ext["sdk.dir"], '/platforms/android-21/android.jar'))
-}
-
-jar {
-    from configurations.compile.findAll {it.name.contains('javawriter')}.collect { zipTree(it) }
-}
-
-shadowJar {
-    relocate 'com.squareup.javawriter', 'io.realm.processor.javawriter'
-    exclude 'io/realm/annotations/**'
-    classifier = ''
-}
-
-//for Ant filter
-import org.apache.tools.ant.filters.ReplaceTokens
-
-task generateVersionClass(type: Copy) {
-    from 'src/main/templates/Version.java'
-    into 'build/generated-src/main/java/io/realm/processor'
-    filter(ReplaceTokens, tokens: [version: version])
-    outputs.upToDateWhen { false }
-}
-
-compileJava.dependsOn generateVersionClass
-
-sourceSets {
-    main {
-        java {
-            srcDir 'build/generated-src/main/java'
-        }
-    }
-}
-
-task compileAnnotations(type: GradleBuild) {
-    dir = file('../realm-annotations')
-    tasks = ['assemble']
-}
-
-task assembleRealm(type: GradleBuild) {
-    dir = file('../realm')
-    tasks = ['assemble']
-}
-
-tasks.compileJava {
-    dependsOn compileAnnotations
-}
-
-tasks.check {
-    dependsOn assembleRealm
-}
diff --git a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.jar b/realm-annotations-processor/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index b761216703..0000000000
Binary files a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties b/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 35b8fa2d3c..0000000000
--- a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Aug 27 08:43:24 CEST 2014
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/realm-annotations-processor/gradlew b/realm-annotations-processor/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/realm-annotations-processor/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/realm-annotations-processor/gradlew.bat b/realm-annotations-processor/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/realm-annotations-processor/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
deleted file mode 100644
index 378bf428d3..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ /dev/null
@@ -1,398 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
-
-import io.realm.annotations.Ignore;
-import io.realm.annotations.Index;
-import io.realm.annotations.PrimaryKey;
-
-/**
- * Utility class for holding metadata for RealmProxy classes.
- */
-public class ClassMetaData {
-
-    private final TypeElement classType; // Reference to model class.
-    private String className; // Model class simple name.
-    private String packageName; // package name for model class.
-    private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
-    private VariableElement primaryKey; // Reference to field used as primary key, if any.
-    private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
-    private List<String> fieldNames = new ArrayList<String>();
-    private List<String> ignoreFieldNames = new ArrayList<String>();
-    private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
-    private Set<String> expectedGetters = new HashSet<String>(); // Set of fieldnames that are expected to have a getter
-    private Set<String> expectedSetters = new HashSet<String>(); // Set of fieldnames that are expected to have a setter
-    private Set<ExecutableElement> methods = new HashSet<ExecutableElement>(); // List of all methods in the model class
-    private Map<String, String> getters = new HashMap<String, String>(); // Map between fieldnames and their getters
-    private Map<String, String> setters = new HashMap<String, String>(); // Map between fieldname and their setters
-
-    private final List<TypeMirror> validPrimaryKeyTypes;
-    private final Types typeUtils;
-
-    public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
-        this.classType = clazz;
-        this.className = clazz.getSimpleName().toString();
-        typeUtils = env.getTypeUtils();
-        TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
-        validPrimaryKeyTypes = Arrays.asList(
-                stringType,
-                typeUtils.getPrimitiveType(TypeKind.SHORT),
-                typeUtils.getPrimitiveType(TypeKind.INT),
-                typeUtils.getPrimitiveType(TypeKind.LONG)
-        );
-    }
-
-    /**
-     * Build the meta data structures for this class. Any errors or messages will be
-     * posted on the provided Messager.
-     *
-     * @return True if meta data was correctly created and processing can continue, false otherwise.
-     */
-    public boolean generate() {
-
-        // Get the package of the class
-        Element enclosingElement = classType.getEnclosingElement();
-        if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
-            Utils.error("The RealmClass annotation does not support nested classes", classType);
-            return false;
-        }
-
-        TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
-        if (!parentElement.toString().endsWith(".RealmObject")) {
-            Utils.error("A RealmClass annotated object must be derived from RealmObject", classType);
-            return false;
-        }
-
-        PackageElement packageElement = (PackageElement) enclosingElement;
-        packageName = packageElement.getQualifiedName().toString();
-
-        if (!categorizeClassElements()) return false;
-        if (!checkMethods()) return false;
-        if (!checkDefaultConstructor()) return false;
-        if (!checkRequiredGetters()) return false;
-        if (!checkRequireSetters()) return false;
-
-        return true; // Meta data was successfully generated
-    }
-
-    // Check that only allowed methods are present in the model class
-    private boolean checkMethods() {
-        for (ExecutableElement executableElement : methods) {
-            String methodName = executableElement.getSimpleName().toString();
-
-            // Check the modifiers of the method
-            Set<Modifier> modifiers = executableElement.getModifiers();
-            if (modifiers.contains(Modifier.STATIC)) {
-                continue; // We're cool with static methods. Move along!
-            } else if (!modifiers.contains(Modifier.PUBLIC)) {
-                Utils.error("The methods of the model must be public", executableElement);
-                return false;
-            }
-
-            // Check that getters and setters are valid
-            if (methodName.startsWith("get") || methodName.startsWith("is")) {
-                if (!checkGetterMethod(methodName)) {
-                    Utils.error(String.format("Getter %s is not associated to any field", methodName), executableElement);
-                    return false;
-                }
-            } else if (methodName.startsWith("set")) {
-                if (!checkSetterMethod(methodName)) {
-                    Utils.error(String.format("Setter %s is not associated to any field", methodName), executableElement);
-                    return false;
-                }
-            } else {
-                Utils.error("Only getters and setters should be defined in model classes", executableElement);
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    // Verify that a setter is used to set a field in the model class.
-    // Note: This is done heuristically by comparing the name of setter with the name of the field.
-    // Annotation processors does not allow us to inspect individual statements.
-    private boolean checkSetterMethod(String methodName) {
-        boolean found = false;
-
-        String methodMinusSet = methodName.substring(3);
-        String methodMinusSetCapitalised = Utils.lowerFirstChar(methodMinusSet);
-        String methodMenusSetPlusIs = "is" + methodMinusSet;
-
-        if (fieldNames.contains(methodMinusSet)) { // mPerson -> setmPerson
-            expectedSetters.remove(methodMinusSet);
-            if (!ignoreFieldNames.contains(methodMinusSet)) {
-                setters.put(methodMinusSet, methodName);
-            }
-            found = true;
-        } else if (fieldNames.contains(methodMinusSetCapitalised)) { // person -> setPerson
-            expectedSetters.remove(methodMinusSetCapitalised);
-            if (!ignoreFieldNames.contains(methodMinusSetCapitalised)) {
-                setters.put(methodMinusSetCapitalised, methodName);
-            }
-            found = true;
-        } else if (fieldNames.contains(methodMenusSetPlusIs)) { // isReady -> setReady
-            expectedSetters.remove(methodMenusSetPlusIs);
-            if (!ignoreFieldNames.contains(methodMenusSetPlusIs)) {
-                setters.put(methodMenusSetPlusIs, methodName);
-            }
-            found = true;
-        }
-
-        return found;
-    }
-
-    // Verify that a getter is used to get a field in the model class.
-    // Note: This is done heuristically by comparing the name of getter with the name of the field.
-    // Annotation processors does not allow us to inspect individual statements.
-    private boolean checkGetterMethod(String methodName) {
-        boolean found = false;
-
-        if (methodName.startsWith("is")) {
-            String methodMinusIs = methodName.substring(2);
-            String methodMinusIsCapitalised = Utils.lowerFirstChar(methodMinusIs);
-            if (fieldNames.contains(methodName)) { // isDone -> isDone
-                expectedGetters.remove(methodName);
-                if (!ignoreFieldNames.contains(methodName)) {
-                    getters.put(methodName, methodName);
-                }
-                found = true;
-            } else if (fieldNames.contains(methodMinusIs)) {  // mDone -> ismDone
-                expectedGetters.remove(methodMinusIs);
-                if (!ignoreFieldNames.contains(methodMinusIs)) {
-                    getters.put(methodMinusIs, methodName);
-                }
-                found = true;
-            } else if (fieldNames.contains(methodMinusIsCapitalised)) { // done -> isDone
-                expectedGetters.remove(methodMinusIsCapitalised);
-                if (!ignoreFieldNames.contains(methodMinusIsCapitalised)) {
-                    getters.put(methodMinusIsCapitalised, methodName);
-                }
-                found = true;
-            }
-        }
-
-        if (!found && methodName.startsWith("get")) {
-            String methodMinusGet = methodName.substring(3);
-            String methodMinusGetCapitalised = Utils.lowerFirstChar(methodMinusGet);
-            if (fieldNames.contains(methodMinusGet)) { // mPerson -> getmPerson
-                expectedGetters.remove(methodMinusGet);
-                if (!ignoreFieldNames.contains(methodMinusGet)) {
-                    getters.put(methodMinusGet, methodName);
-                }
-                found = true;
-            } else if (fieldNames.contains(methodMinusGetCapitalised)) { // person -> getPerson
-                expectedGetters.remove(methodMinusGetCapitalised);
-                if (!ignoreFieldNames.contains(methodMinusGetCapitalised)) {
-                    getters.put(methodMinusGetCapitalised, methodName);
-                }
-                found = true;
-            }
-        }
-
-        return found;
-    }
-
-    // Report any setters that are missing
-    private boolean checkRequireSetters() {
-        for (String expectedSetter : expectedSetters) {
-            Utils.error("No setter found for field " + expectedSetter);
-        }
-        return expectedSetters.size() == 0;
-    }
-
-    // Report any getters that are missing
-    private boolean checkRequiredGetters() {
-        for (String expectedGetter : expectedGetters) {
-            Utils.error("No getter found for field " + expectedGetter);
-        }
-        return expectedGetters.size() == 0;
-    }
-
-    // Report if the default constructor is missing
-    private boolean checkDefaultConstructor() {
-        if (!hasDefaultConstructor) {
-            Utils.error("A default public constructor with no argument must be declared if a custom constructor is declared.");
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    // Iterate through all class elements and add them to the appropriate internal data structures.
-    // Returns true if all elements could be false if elements could not be categorized,
-    private boolean categorizeClassElements() {
-        for (Element element : classType.getEnclosedElements()) {
-            ElementKind elementKind = element.getKind();
-
-            if (elementKind.equals(ElementKind.FIELD)) {
-                VariableElement variableElement = (VariableElement) element;
-                String fieldName = variableElement.getSimpleName().toString();
-
-                Set<Modifier> modifiers = variableElement.getModifiers();
-                if (modifiers.contains(Modifier.STATIC)) {
-                    continue; // completely ignore any static fields
-                }
-
-                if (variableElement.getAnnotation(Ignore.class) != null) {
-                    // The field has the @Ignore annotation. No need to go any further.
-                    String ignoredFieldName = variableElement.getSimpleName().toString();
-                    fieldNames.add(ignoredFieldName);
-                    ignoreFieldNames.add(ignoredFieldName);
-                    continue;
-                }
-
-                if (variableElement.getAnnotation(Index.class) != null) {
-                    // The field has the @Index annotation. It's only valid for:
-                    // * String
-                    String elementTypeCanonicalName = variableElement.asType().toString();
-                    if (elementTypeCanonicalName.equals("java.lang.String")) {
-                        indexedFields.add(variableElement);
-                    } else {
-                        Utils.error("@Index is only applicable to String fields - got " + element);
-                        return false;
-                    }
-                }
-
-                if (variableElement.getAnnotation(PrimaryKey.class) != null) {
-                    // The field has the @PrimaryKey annotation. It is only valid for
-                    // String, short, int, long and must only be present one time
-                    if (primaryKey != null) {
-                        Utils.error(String.format("@PrimaryKey cannot be defined more than once. It was found here \"%s\" and here \"%s\"",
-                                primaryKey.getSimpleName().toString(),
-                                variableElement.getSimpleName().toString()));
-                        return false;
-                    }
-
-                    TypeMirror fieldType = variableElement.asType();
-                    if (!isValidPrimaryKeyType(fieldType)) {
-                        Utils.error("\"" + variableElement.getSimpleName().toString() + "\" is not allowed as primary key. See @PrimaryKey for allowed types.");
-                        return false;
-                    }
-
-                    primaryKey = variableElement;
-
-                    // Also add as index if the primary key is a string
-                    if (Utils.isString(variableElement) && !indexedFields.contains(variableElement)) {
-                        indexedFields.add(variableElement);
-                    }
-                }
-
-                if (!variableElement.getModifiers().contains(Modifier.PRIVATE)) {
-                    Utils.error("The fields of the model must be private", variableElement);
-                    return false;
-                }
-
-                fields.add(variableElement);
-                expectedGetters.add(fieldName);
-                expectedSetters.add(fieldName);
-            } else if (elementKind.equals(ElementKind.CONSTRUCTOR)) {
-                hasDefaultConstructor =  hasDefaultConstructor || Utils.isDefaultConstructor(element);
-
-            } else if (elementKind.equals(ElementKind.METHOD)) {
-                ExecutableElement executableElement = (ExecutableElement) element;
-                methods.add(executableElement);
-            }
-        }
-
-        for (VariableElement field : fields) {
-            fieldNames.add(field.getSimpleName().toString());
-        }
-
-        if (fields.size() == 0) {
-            Utils.error(className + " must contain at least 1 persistable field");
-        }
-
-        return true;
-    }
-
-    public String getSimpleClassName() {
-        return className;
-    }
-
-    /**
-     * Returns true if the model class is considered to be a true model class.
-     * RealmObject and Proxy classes also has the the @RealmClass annotation but is not considered true
-     * model classes.
-     */
-    public boolean isModelClass() {
-        return (!classType.toString().endsWith(".RealmObject") && !classType.toString().endsWith("RealmProxy"));
-    }
-
-    public String getFullyQualifiedClassName() {
-        return packageName + "." + className;
-    }
-
-    public List<VariableElement> getFields() {
-        return fields;
-    }
-
-    public String getGetter(String fieldName) {
-        return getters.get(fieldName);
-    }
-
-    public String getSetter(String fieldName) {
-        return setters.get(fieldName);
-    }
-
-    public List<VariableElement> getIndexedFields() {
-        return indexedFields;
-    }
-
-    public boolean hasPrimaryKey() {
-        return primaryKey != null;
-    }
-
-    public VariableElement getPrimaryKey() {
-        return primaryKey;
-    }
-
-    public String getPrimaryKeyGetter() {
-        return getters.get(primaryKey.getSimpleName().toString());
-    }
-
-    private boolean isValidPrimaryKeyType(TypeMirror type) {
-        for (TypeMirror validType : validPrimaryKeyTypes) {
-            if (typeUtils.isAssignable(type, validType)) {
-                return true;
-            }
-        }
-        return false;
-    }
-}
-
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
deleted file mode 100644
index 2e689afbf1..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-public class Constants {
-    public static final String REALM_PACKAGE_NAME = "io.realm";
-    public static final String PROXY_SUFFIX = "RealmProxy";
-    public static final String TABLE_PREFIX = "class_";
-    public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
-}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
deleted file mode 100644
index c04722c74d..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Helper class for converting between Json types and data types in Java that are supported by Realm.
- */
-public class RealmJsonTypeHelper {
-
-    private static final Map<String, JsonToRealmTypeConverter> JAVA_TO_JSON_TYPES;
-    static {
-        JAVA_TO_JSON_TYPES = new HashMap<String, JsonToRealmTypeConverter>();
-        JAVA_TO_JSON_TYPES.put("byte", new SimpleTypeConverter("byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("short", new SimpleTypeConverter("short", "Int"));
-        JAVA_TO_JSON_TYPES.put("int", new SimpleTypeConverter("int", "Int"));
-        JAVA_TO_JSON_TYPES.put("long", new SimpleTypeConverter("long", "Long"));
-        JAVA_TO_JSON_TYPES.put("float", new SimpleTypeConverter("float", "Double"));
-        JAVA_TO_JSON_TYPES.put("double", new SimpleTypeConverter("double", "Double"));
-        JAVA_TO_JSON_TYPES.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("Byte", new SimpleTypeConverter("Byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("Short", new SimpleTypeConverter("Short", "Int"));
-        JAVA_TO_JSON_TYPES.put("Integer", new SimpleTypeConverter("Integer", "Int"));
-        JAVA_TO_JSON_TYPES.put("Long", new SimpleTypeConverter("Long", "Long"));
-        JAVA_TO_JSON_TYPES.put("Float", new SimpleTypeConverter("Float", "Double"));
-        JAVA_TO_JSON_TYPES.put("Double", new SimpleTypeConverter("Double", "Double"));
-        JAVA_TO_JSON_TYPES.put("Boolean", new SimpleTypeConverter("Boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
-        JAVA_TO_JSON_TYPES.put("java.util.Date", new JsonToRealmTypeConverter() {
-            @Override
-            public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
-                        .beginControlFlow("if (timestamp instanceof String)")
-                           .emitStatement("obj.%s(JsonUtils.stringToDate((String) timestamp))", setter)
-                        .nextControlFlow("else")
-                            .emitStatement("obj.%s(new Date(json.getLong(\"%s\")))", setter, fieldName)
-                        .endControlFlow()
-                    .endControlFlow();
-            }
-
-            @Override
-            public void emitStreamTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (reader.peek() == JsonToken.NUMBER)")
-                        .emitStatement("long timestamp = reader.nextLong()", fieldName)
-                        .beginControlFlow("if (timestamp > -1)")
-                            .emitStatement("obj.%s(new Date(timestamp))", setter)
-                        .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("obj.%s(JsonUtils.stringToDate(reader.nextString()))", setter)
-                    .endControlFlow();
-            }
-        });
-        JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmTypeConverter() {
-            @Override
-            public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("obj.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", setter, fieldName)
-                    .endControlFlow();
-            }
-
-            @Override
-            public void emitStreamTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-                writer.emitStatement("obj.%s(JsonUtils.stringToBytes(reader.nextString()))", setter);
-            }
-        });
-    }
-
-    public static void emitFillJavaTypeWithJsonValue(String setter, String fieldName, String qualifiedFieldType, JavaWriter writer) throws IOException {
-        JsonToRealmTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitTypeConversion(setter, fieldName, qualifiedFieldType, writer);
-        }
-    }
-
-    public static void emitFillRealmObjectWithJsonValue(String setter, String fieldName, String qualifiedFieldType,
-                                                        String proxyClass, JavaWriter writer) throws IOException {
-        writer
-            .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
-                        qualifiedFieldType, fieldName, proxyClass, fieldName)
-                .emitStatement("obj.%s(%sObj)", setter, fieldName)
-            .endControlFlow();
-    }
-
-    public static void emitFillRealmListWithJsonValue(String getter, String setter, String fieldName,
-                                                      String fieldTypeCanonicalName, String proxyClass,
-                                                      JavaWriter writer) throws IOException {
-        writer
-            .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .emitStatement("obj.%s().clear()", getter)
-                .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
-                .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                    .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
-                            fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
-                    .emitStatement("obj.%s().add(item)", getter)
-                .endControlFlow()
-            .endControlFlow();
-    }
-
-
-    public static void emitFillJavaTypeFromStream(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
-            JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(setter, fieldName, fieldType, writer);
-        }
-    }
-
-    public static void emitFillRealmObjectFromStream(String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
-        writer
-            .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName, proxyClass)
-            .emitStatement("obj.%s(%sObj)", setter, fieldName);
-    }
-
-    public static void emitFillRealmListFromStream(String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
-        writer
-            .emitStatement("reader.beginArray()")
-            .beginControlFlow("while (reader.hasNext())")
-                .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
-                .emitStatement("obj.%s().add(item)", getter)
-            .endControlFlow()
-            .emitStatement("reader.endArray()");
-    }
-
-    private static class SimpleTypeConverter implements JsonToRealmTypeConverter {
-
-        private final String castType;
-        private final String jsonType;
-
-        /**
-         * Create a conversion between simple types which can be expressed as
-         * RealmObject.setFieldName((<castType>) json.get<jsonType>) or
-         * RealmObject.setFieldName((<castType>) reader.next<jsonType>
-         *
-         * @param castType  Java type to cast to.
-         * @param jsonType  JsonType to get data from.
-         */
-        private SimpleTypeConverter(String castType, String jsonType) {
-            this.castType = castType;
-            this.jsonType = jsonType;
-        }
-
-        @Override
-        public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-            writer
-                .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("obj.%s((%s) json.get%s(\"%s\"))",
-                        setter,
-                        castType,
-                        jsonType,
-                        fieldName)
-                .endControlFlow();
-        }
-
-        @Override
-        public void emitStreamTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-            writer.emitStatement("obj.%s((%s) reader.next%s())",
-                    setter,
-                    castType,
-                    jsonType);
-        }
-    }
-
-    private interface JsonToRealmTypeConverter {
-        public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException;
-        public void emitStreamTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException;
-    }
-}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
deleted file mode 100644
index 039140af17..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ /dev/null
@@ -1,123 +0,0 @@
-package io.realm.processor;
-
-import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
-/**
- * Utility methods working with the Realm processor.
- */
-public class Utils {
-
-    public static Types typeUtils;
-    private static Messager messager;
-    private static DeclaredType realmList;
-
-    public static void initialize(ProcessingEnvironment env) {
-        typeUtils = env.getTypeUtils();
-        messager = env.getMessager();
-        realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
-    }
-
-    /**
-     * Returns true if the given element is the default public no arg constructor for a class.
-     */
-    public static boolean isDefaultConstructor(Element constructor) {
-        if (constructor.getModifiers().contains(Modifier.PUBLIC)) {
-            return ((ExecutableElement) constructor).getParameters().isEmpty();
-        }
-        return false;
-    }
-
-    public static String lowerFirstChar(String input) {
-        return input.substring(0, 1).toLowerCase() + input.substring(1);
-    }
-
-    public static String getProxyClassSimpleName(VariableElement field) {
-        if (typeUtils.isAssignable(field.asType(), realmList)) {
-            return getProxyClassName(getGenericType(field));
-        } else {
-            return getProxyClassName(getFieldTypeSimpleName(field));
-        }
-    }
-
-    /**
-     * Return the proxy class name for a given clazz
-     */
-    public static String getProxyClassName(String clazz) {
-        return clazz + Constants.PROXY_SUFFIX;
-    }
-
-    /**
-     * Returns true if a field is of type "java.lang.String", false otherwise.
-     */
-    public static boolean isString(VariableElement field) {
-        if (field == null) {
-            return false;
-        }
-        return getFieldTypeSimpleName(field).equals("String");
-    }
-
-    /**
-     * Returns the simple type name for a field.
-     */
-    public static String getFieldTypeSimpleName(VariableElement field) {
-        String fieldTypeCanonicalName = field.asType().toString();
-        String fieldTypeName;
-        if (fieldTypeCanonicalName.contains(".")) {
-            fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
-        } else {
-            fieldTypeName = fieldTypeCanonicalName;
-        }
-        return fieldTypeName;
-    }
-
-    /**
-     * Returns the generic type for Lists of the form {@code List<type>}
-     */
-    public static String getGenericType(VariableElement field) {
-        String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
-        String genericType;
-        if (genericCanonicalType.contains(".")) {
-            genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
-        } else {
-            genericType = genericCanonicalType;
-        }
-        return genericType;
-    }
-
-    /**
-     * Strips the package name from a fully qualified class name.
-     */
-    public static String stripPackage(String fullyQualifiedClassName) {
-        String[] parts = fullyQualifiedClassName.split("\\.");
-        if (parts.length > 0) {
-            return parts[parts.length - 1];
-        } else {
-            return fullyQualifiedClassName;
-        }
-    }
-
-    public static void error(String message, Element element) {
-        messager.printMessage(Diagnostic.Kind.ERROR, message, element);
-    }
-
-    public static void error(String message) {
-        messager.printMessage(Diagnostic.Kind.ERROR, message);
-    }
-
-    public static void note(String message) {
-        messager.printMessage(Diagnostic.Kind.NOTE, message);
-    }
-
-    public static Element getSuperClass(TypeElement classType) {
-        return typeUtils.asElement(classType.getSuperclass());
-    }
-}
diff --git a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
deleted file mode 100644
index 4eac882f0c..0000000000
--- a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.google.testing.compile.JavaFileObjects;
-import org.junit.Test;
-
-import javax.tools.JavaFileObject;
-
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static org.truth0.Truth.ASSERT;
-
-public class RealmProcessorTest {
-
-    private JavaFileObject simpleModel = JavaFileObjects.forResource("some/test/Simple.java");
-    private JavaFileObject simpleProxy = JavaFileObjects.forResource("io/realm/SimpleRealmProxy.java");
-    private JavaFileObject allTypesModel = JavaFileObjects.forResource("some/test/AllTypes.java");
-    private JavaFileObject allTypesProxy = JavaFileObjects.forResource("io/realm/AllTypesRealmProxy.java");
-    private JavaFileObject allTypesDefaultModule = JavaFileObjects.forResource("io/realm/RealmDefaultModule.java");
-    private JavaFileObject allTypesDefaultMediator = JavaFileObjects.forResource("io/realm/RealmDefaultModuleMediator.java");
-    private JavaFileObject booleansModel = JavaFileObjects.forResource("some/test/Booleans.java");
-    private JavaFileObject booleansProxy = JavaFileObjects.forResource("io/realm/BooleansRealmProxy.java");
-    private JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
-    private JavaFileObject noAccessorsModel = JavaFileObjects.forResource("some/test/NoAccessors.java");
-    private JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
-    private JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
-
-    @Test
-    public void compileSimpleFile() {
-        ASSERT.about(javaSource())
-                .that(simpleModel)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileProcessedSimpleFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(simpleModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileProcessedEmptyFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(emptyModel)
-                .processedWith(new RealmProcessor())
-                .failsToCompile();
-    }
-
-    @Test
-    public void compileSimpleProxyFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(simpleProxy)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compareProcessedSimpleFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(simpleModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError()
-                .and()
-                .generatesSources(simpleProxy);
-    }
-
-    @Test
-    public void compileAllTypesFile() {
-        ASSERT.about(javaSource())
-                .that(allTypesModel)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileProcessedAllTypesFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(allTypesModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileAllTypesProxyFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(allTypesModel)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compareProcessedAllTypesFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(allTypesModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError()
-                .and()
-                .generatesSources(allTypesDefaultMediator, allTypesDefaultModule, allTypesDefaultMediator);
-    }
-
-    @Test
-    public void compileBooleanFile() {
-        ASSERT.about(javaSource())
-                .that(booleansModel)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileProcessedBooleansFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(booleansModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileBooleansProxyFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(booleansModel)
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compareProcessedBooleansFile() throws Exception {
-        ASSERT.about(javaSource())
-                .that(booleansModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError()
-                .and()
-                .generatesSources(booleansProxy);
-    }
-
-    @Test
-    public void compileNoAccessorsFile() {
-        ASSERT.about(javaSource())
-                .that(noAccessorsModel)
-                .processedWith(new RealmProcessor())
-                .failsToCompile();
-    }
-
-    @Test
-    public void compileFieldNamesFiles() {
-        ASSERT.about(javaSource())
-                .that(fieldNamesModel)
-                .processedWith(new RealmProcessor())
-                .compilesWithoutError();
-    }
-
-    @Test
-    public void compileCustomAccessor() {
-        ASSERT.about(javaSource())
-                .that(customAccessorModel)
-                .processedWith(new RealmProcessor())
-                .failsToCompile();
-    }
-}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
deleted file mode 100644
index 0edb35ef82..0000000000
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ /dev/null
@@ -1,612 +0,0 @@
-package io.realm;
-
-
-import android.util.JsonReader;
-import android.util.JsonToken;
-import io.realm.RealmObject;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.ColumnType;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.LinkView;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-import io.realm.internal.android.JsonUtils;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import some.test.AllTypes;
-
-public class AllTypesRealmProxy extends AllTypes
-        implements RealmObjectProxy {
-
-    private static long INDEX_COLUMNSTRING;
-    private static long INDEX_COLUMNLONG;
-    private static long INDEX_COLUMNFLOAT;
-    private static long INDEX_COLUMNDOUBLE;
-    private static long INDEX_COLUMNBOOLEAN;
-    private static long INDEX_COLUMNDATE;
-    private static long INDEX_COLUMNBINARY;
-    private static long INDEX_COLUMNOBJECT;
-    private static long INDEX_COLUMNREALMLIST;
-    private static Map<String, Long> columnIndices;
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>();
-        fieldNames.add("columnString");
-        fieldNames.add("columnLong");
-        fieldNames.add("columnFloat");
-        fieldNames.add("columnDouble");
-        fieldNames.add("columnBoolean");
-        fieldNames.add("columnDate");
-        fieldNames.add("columnBinary");
-        fieldNames.add("columnObject");
-        fieldNames.add("columnRealmList");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
-
-    @Override
-    public String getColumnString() {
-        realm.checkIfValid();
-        return (java.lang.String) row.getString(INDEX_COLUMNSTRING);
-    }
-
-    @Override
-    public void setColumnString(String value) {
-        realm.checkIfValid();
-        row.setString(INDEX_COLUMNSTRING, (String) value);
-    }
-
-    @Override
-    public long getColumnLong() {
-        realm.checkIfValid();
-        return (long) row.getLong(INDEX_COLUMNLONG);
-    }
-
-    @Override
-    public void setColumnLong(long value) {
-        realm.checkIfValid();
-        row.setLong(INDEX_COLUMNLONG, (long) value);
-    }
-
-    @Override
-    public float getColumnFloat() {
-        realm.checkIfValid();
-        return (float) row.getFloat(INDEX_COLUMNFLOAT);
-    }
-
-    @Override
-    public void setColumnFloat(float value) {
-        realm.checkIfValid();
-        row.setFloat(INDEX_COLUMNFLOAT, (float) value);
-    }
-
-    @Override
-    public double getColumnDouble() {
-        realm.checkIfValid();
-        return (double) row.getDouble(INDEX_COLUMNDOUBLE);
-    }
-
-    @Override
-    public void setColumnDouble(double value) {
-        realm.checkIfValid();
-        row.setDouble(INDEX_COLUMNDOUBLE, (double) value);
-    }
-
-    @Override
-    public boolean isColumnBoolean() {
-        realm.checkIfValid();
-        return (boolean) row.getBoolean(INDEX_COLUMNBOOLEAN);
-    }
-
-    @Override
-    public void setColumnBoolean(boolean value) {
-        realm.checkIfValid();
-        row.setBoolean(INDEX_COLUMNBOOLEAN, (boolean) value);
-    }
-
-    @Override
-    public Date getColumnDate() {
-        realm.checkIfValid();
-        return (java.util.Date) row.getDate(INDEX_COLUMNDATE);
-    }
-
-    @Override
-    public void setColumnDate(Date value) {
-        realm.checkIfValid();
-        row.setDate(INDEX_COLUMNDATE, (Date) value);
-    }
-
-    @Override
-    public byte[] getColumnBinary() {
-        realm.checkIfValid();
-        return (byte[]) row.getBinaryByteArray(INDEX_COLUMNBINARY);
-    }
-
-    @Override
-    public void setColumnBinary(byte[] value) {
-        realm.checkIfValid();
-        row.setBinaryByteArray(INDEX_COLUMNBINARY, (byte[]) value);
-    }
-
-    @Override
-    public AllTypes getColumnObject() {
-        if (row.isNullLink(INDEX_COLUMNOBJECT)) {
-            return null;
-        }
-        return realm.get(some.test.AllTypes.class, row.getLink(INDEX_COLUMNOBJECT));
-    }
-
-    @Override
-    public void setColumnObject(AllTypes value) {
-        if (value == null) {
-            row.nullifyLink(INDEX_COLUMNOBJECT);
-            return;
-        }
-        row.setLink(INDEX_COLUMNOBJECT, value.row.getIndex());
-    }
-
-    @Override
-    public RealmList<AllTypes> getColumnRealmList() {
-        return new RealmList<AllTypes>(AllTypes.class, row.getLinkList(INDEX_COLUMNREALMLIST), realm);
-    }
-
-    @Override
-    public void setColumnRealmList(RealmList<AllTypes> value) {
-        LinkView links = row.getLinkList(INDEX_COLUMNREALMLIST);
-        if (value == null) {
-            return;
-        }
-        links.clear();
-        for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value) {
-            links.add(linkedObject.row.getIndex());
-        }
-    }
-
-    public static Table initTable(ImplicitTransaction transaction) {
-        if(!transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
-            table.addColumn(ColumnType.STRING, "columnString");
-            table.addColumn(ColumnType.INTEGER, "columnLong");
-            table.addColumn(ColumnType.FLOAT, "columnFloat");
-            table.addColumn(ColumnType.DOUBLE, "columnDouble");
-            table.addColumn(ColumnType.BOOLEAN, "columnBoolean");
-            table.addColumn(ColumnType.DATE, "columnDate");
-            table.addColumn(ColumnType.BINARY, "columnBinary");
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
-            }
-            table.addColumnLink(ColumnType.LINK, "columnObject", transaction.getTable("class_AllTypes"));
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
-            }
-            table.addColumnLink(ColumnType.LINK_LIST, "columnRealmList", transaction.getTable("class_AllTypes"));
-            table.addSearchIndex(table.getColumnIndex("columnString"));
-            table.setPrimaryKey("columnString");
-            return table;
-        }
-        return transaction.getTable("class_AllTypes");
-    }
-
-    public static void validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
-
-            if(table.getColumnCount() != 9) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 9 but was " + table.getColumnCount());
-            }
-
-            Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for (long i = 0; i < 9; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-            }
-
-            columnIndices = new HashMap<String, Long>();
-            for (String fieldName : getFieldNames()) {
-                long index = table.getColumnIndex(fieldName);
-                if (index == -1) {
-                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type AllTypes");
-                }
-                columnIndices.put(fieldName, index);
-            }
-            INDEX_COLUMNSTRING = table.getColumnIndex("columnString");
-            INDEX_COLUMNLONG = table.getColumnIndex("columnLong");
-            INDEX_COLUMNFLOAT = table.getColumnIndex("columnFloat");
-            INDEX_COLUMNDOUBLE = table.getColumnIndex("columnDouble");
-            INDEX_COLUMNBOOLEAN = table.getColumnIndex("columnBoolean");
-            INDEX_COLUMNDATE = table.getColumnIndex("columnDate");
-            INDEX_COLUMNBINARY = table.getColumnIndex("columnBinary");
-            INDEX_COLUMNOBJECT = table.getColumnIndex("columnObject");
-            INDEX_COLUMNREALMLIST = table.getColumnIndex("columnRealmList");
-
-            if (!columnTypes.containsKey("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnString'");
-            }
-            if (columnTypes.get("columnString") != ColumnType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString'");
-            }
-            if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString'");
-            }
-            if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Index not defined for field 'columnString'");
-            }
-            if (!columnTypes.containsKey("columnLong")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnLong'");
-            }
-            if (columnTypes.get("columnLong") != ColumnType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong'");
-            }
-            if (!columnTypes.containsKey("columnFloat")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat'");
-            }
-            if (columnTypes.get("columnFloat") != ColumnType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat'");
-            }
-            if (!columnTypes.containsKey("columnDouble")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble'");
-            }
-            if (columnTypes.get("columnDouble") != ColumnType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble'");
-            }
-            if (!columnTypes.containsKey("columnBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean'");
-            }
-            if (columnTypes.get("columnBoolean") != ColumnType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean'");
-            }
-            if (!columnTypes.containsKey("columnDate")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate'");
-            }
-            if (columnTypes.get("columnDate") != ColumnType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate'");
-            }
-            if (!columnTypes.containsKey("columnBinary")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary'");
-            }
-            if (columnTypes.get("columnBinary") != ColumnType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary'");
-            }
-            if (!columnTypes.containsKey("columnObject")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject'");
-            }
-            if (columnTypes.get("columnObject") != ColumnType.LINK) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
-            }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
-            }
-
-            Table table_7 = transaction.getTable("class_AllTypes");
-            if (!table.getLinkTarget(INDEX_COLUMNOBJECT).equals(table_7)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'columnObject': '" +
-                table.getLinkTarget(INDEX_COLUMNOBJECT).getName() + "' - was '" +
-                table_7.getName() + "'");
-            }
-            if (!columnTypes.containsKey("columnRealmList")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
-            }
-            if (columnTypes.get("columnRealmList") != ColumnType.LINK_LIST) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
-            }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
-            }
-            Table table_8 = transaction.getTable("class_AllTypes");
-            if (!table.getLinkTarget(INDEX_COLUMNREALMLIST).equals(table_8)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmList for field 'columnRealmList'. '" +
-                        table.getLinkTarget(INDEX_COLUMNREALMLIST).getName() + "' expected - was '"
-                        table_8.getName() + "'");
-            }
-        } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The AllTypes class is missing from the schema for this Realm.");
-        }
-    }
-
-    public static String getTableName() {
-        return "class_AllTypes";
-    }
-
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
-    public static Map<String,Long> getColumnIndices() {
-        return columnIndices;
-    }
-
-    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
-            throws JSONException {
-        AllTypes obj = null;
-        if (update) {
-            Table table = realm.getTable(AllTypes.class);
-            long pkColumnIndex = table.getPrimaryKey();
-            if (!json.isNull("columnString")) {
-                long rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
-                if (rowIndex != TableOrView.NO_MATCH) {
-                    obj = new AllTypesRealmProxy();
-                    obj.realm = realm;
-                    obj.row = table.getRow(rowIndex);
-                }
-            }
-        }
-        if (obj == null) {
-            obj = realm.createObject(AllTypes.class);
-        }
-        if (!json.isNull("columnString")) {
-            obj.setColumnString((String) json.getString("columnString"));
-        }
-        if (!json.isNull("columnLong")) {
-            obj.setColumnLong((long) json.getLong("columnLong"));
-        }
-        if (!json.isNull("columnFloat")) {
-            obj.setColumnFloat((float) json.getDouble("columnFloat"));
-        }
-        if (!json.isNull("columnDouble")) {
-            obj.setColumnDouble((double) json.getDouble("columnDouble"));
-        }
-        if (!json.isNull("columnBoolean")) {
-            obj.setColumnBoolean((boolean) json.getBoolean("columnBoolean"));
-        }
-        if (!json.isNull("columnDate")) {
-            Object timestamp = json.get("columnDate");
-            if (timestamp instanceof String) {
-                obj.setColumnDate(JsonUtils.stringToDate((String) timestamp));
-            } else {
-                obj.setColumnDate(new Date(json.getLong("columnDate")));
-            }
-        }
-        if (!json.isNull("columnBinary")) {
-            obj.setColumnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
-        }
-        if (!json.isNull("columnObject")) {
-            some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
-            obj.setColumnObject(columnObjectObj);
-        }
-        if (!json.isNull("columnRealmList")) {
-            obj.getColumnRealmList().clear();
-            JSONArray array = json.getJSONArray("columnRealmList");
-            for (int i = 0; i < array.length(); i++) {
-                some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
-                obj.getColumnRealmList().add(item);
-            }
-        }
-        return obj;
-    }
-
-    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
-            throws IOException {
-        AllTypes obj = realm.createObject(AllTypes.class);
-        reader.beginObject();
-        while (reader.hasNext()) {
-            String name = reader.nextName();
-            if (name.equals("columnString") && reader.peek() != JsonToken.NULL) {
-                obj.setColumnString((String) reader.nextString());
-            } else if (name.equals("columnLong")  && reader.peek() != JsonToken.NULL) {
-                obj.setColumnLong((long) reader.nextLong());
-            } else if (name.equals("columnFloat")  && reader.peek() != JsonToken.NULL) {
-                obj.setColumnFloat((float) reader.nextDouble());
-            } else if (name.equals("columnDouble")  && reader.peek() != JsonToken.NULL) {
-                obj.setColumnDouble((double) reader.nextDouble());
-            } else if (name.equals("columnBoolean")  && reader.peek() != JsonToken.NULL) {
-                obj.setColumnBoolean((boolean) reader.nextBoolean());
-            } else if (name.equals("columnDate")  && reader.peek() != JsonToken.NULL) {
-                if (reader.peek() == JsonToken.NUMBER) {
-                    long timestamp = reader.nextLong();
-                    if (timestamp > -1) {
-                        obj.setColumnDate(new Date(timestamp));
-                    }
-                } else {
-                    obj.setColumnDate(JsonUtils.stringToDate(reader.nextString()));
-                }
-            } else if (name.equals("columnBinary")  && reader.peek() != JsonToken.NULL) {
-                obj.setColumnBinary(JsonUtils.stringToBytes(reader.nextString()));
-            } else if (name.equals("columnObject")  && reader.peek() != JsonToken.NULL) {
-                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                obj.setColumnObject(columnObjectObj);
-            } else if (name.equals("columnRealmList")  && reader.peek() != JsonToken.NULL) {
-                reader.beginArray();
-                while (reader.hasNext()) {
-                    some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                    obj.getColumnRealmList().add(item);
-                }
-                reader.endArray();
-            } else {
-                reader.skipValue();
-            }
-        }
-        reader.endObject();
-        return obj;
-    }
-
-    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
-            return object;
-        }
-        AllTypes realmObject = null;
-        boolean canUpdate = update;
-        if (canUpdate) {
-            Table table = realm.getTable(AllTypes.class);
-            long pkColumnIndex = table.getPrimaryKey();
-            if (object.getColumnString() == null) {
-                throw new IllegalArgumentException("Primary key value must not be null.");
-            }
-            long rowIndex = table.findFirstString(pkColumnIndex, object.getColumnString());
-            if (rowIndex != TableOrView.NO_MATCH) {
-                realmObject = new AllTypesRealmProxy();
-                realmObject.realm = realm;
-                realmObject.row = table.getRow(rowIndex);
-                cache.put(object, (RealmObjectProxy) realmObject);
-            } else {
-                canUpdate = false;
-            }
-        }
-
-        if (canUpdate) {
-            return update(realm, realmObject, object, cache);
-        } else {
-            return copy(realm, object, update, cache);
-        }
-    }
-
-    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        realmObject.setColumnString(newObject.getColumnString() != null ? newObject.getColumnString() : "");
-        realmObject.setColumnLong(newObject.getColumnLong());
-        realmObject.setColumnFloat(newObject.getColumnFloat());
-        realmObject.setColumnDouble(newObject.getColumnDouble());
-        realmObject.setColumnBoolean(newObject.isColumnBoolean());
-        realmObject.setColumnDate(newObject.getColumnDate() != null ? newObject.getColumnDate() : new Date(0));
-        realmObject.setColumnBinary(newObject.getColumnBinary() != null ? newObject.getColumnBinary() : new byte[0]);
-
-        some.test.AllTypes columnObjectObj = newObject.getColumnObject();
-        if (columnObjectObj != null) {
-            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
-            if (cachecolumnObject != null) {
-                realmObject.setColumnObject(cachecolumnObject);
-            } else {
-                realmObject.setColumnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
-            }
-        }
-
-        RealmList<AllTypes> columnRealmListList = newObject.getColumnRealmList();
-        if (columnRealmListList != null) {
-            RealmList<AllTypes> columnRealmListRealmList = realmObject.getColumnRealmList();
-            for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
-                if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
-                } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
-                }
-            }
-        }
-
-        return realmObject;
-    }
-
-    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmObject, RealmObjectProxy> cache) {
-        realmObject.setColumnLong(newObject.getColumnLong());
-        realmObject.setColumnFloat(newObject.getColumnFloat());
-        realmObject.setColumnDouble(newObject.getColumnDouble());
-        realmObject.setColumnBoolean(newObject.isColumnBoolean());
-        realmObject.setColumnDate(newObject.getColumnDate() != null ? newObject.getColumnDate() : new Date(0));
-        realmObject.setColumnBinary(newObject.getColumnBinary() != null ? newObject.getColumnBinary() : new byte[0]);
-        AllTypes columnObjectObj = newObject.getColumnObject();
-        if (columnObjectObj != null) {
-            AllTypes cachecolumnObject = (AllTypes) cache.get(columnObjectObj);
-            if (cachecolumnObject != null) {
-                realmObject.setColumnObject(cachecolumnObject);
-            } else {
-                realmObject.setColumnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
-            }
-        } else {
-            realmObject.setColumnObject(null);
-        }
-        RealmList<AllTypes> columnRealmListList = newObject.getColumnRealmList();
-        RealmList<AllTypes> columnRealmListRealmList = realmObject.getColumnRealmList();
-        columnRealmListRealmList.clear();
-        if (columnRealmListList != null) {
-            for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
-                if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
-                } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), true, cache));
-                }
-            }
-        }
-        return realmObject;
-    }
-
-    @Override
-    public String toString() {
-        if (!isValid()) {
-            return "Invalid object";
-        }
-        StringBuilder stringBuilder = new StringBuilder("AllTypes = [");
-        stringBuilder.append("{columnString:");
-        stringBuilder.append(getColumnString());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnLong:");
-        stringBuilder.append(getColumnLong());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnFloat:");
-        stringBuilder.append(getColumnFloat());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnDouble:");
-        stringBuilder.append(getColumnDouble());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnBoolean:");
-        stringBuilder.append(isColumnBoolean());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnDate:");
-        stringBuilder.append(getColumnDate());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnBinary:");
-        stringBuilder.append(getColumnBinary());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnObject:");
-        stringBuilder.append(getColumnObject() != null ? "AllTypes" : "null");
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{columnRealmList:");
-        stringBuilder.append("RealmList<AllTypes>[").append(getColumnRealmList().size()).append("]");
-        stringBuilder.append("}");
-        stringBuilder.append("]");
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public int hashCode() {
-        String realmName = realm.getPath();
-        String tableName = row.getTable().getName();
-        long rowIndex = row.getIndex();
-
-        int result = 17;
-        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
-        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
-        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;
-
-        String path = realm.getPath();
-        String otherPath = aAllTypes.realm.getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
-
-        String tableName = row.getTable().getName();
-        String otherTableName = aAllTypes.row.getTable().getName();
-        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
-
-        if (row.getIndex() != aAllTypes.row.getIndex()) return false;
-
-        return true;
-    }
-
-}
- 
diff --git a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
deleted file mode 100644
index bc386b5c37..0000000000
--- a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ /dev/null
@@ -1,296 +0,0 @@
-package io.realm;
-
-
-import android.util.JsonReader;
-import android.util.JsonToken;
-import io.realm.RealmObject;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.ColumnType;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.LinkView;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-import io.realm.internal.android.JsonUtils;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import some.test.Booleans;
-
-public class BooleansRealmProxy extends Booleans implements RealmObjectProxy {
-
-    private static long INDEX_DONE;
-    private static long INDEX_ISREADY;
-    private static long INDEX_MCOMPLETED;
-    private static long INDEX_ANOTHERBOOLEAN;
-    private static Map<String, Long> columnIndices;
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>();
-        fieldNames.add("done");
-        fieldNames.add("isReady");
-        fieldNames.add("mCompleted");
-        fieldNames.add("anotherBoolean");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
-
-    @Override
-    public boolean isDone() {
-        realm.checkIfValid();
-        return (boolean) row.getBoolean(INDEX_DONE);
-    }
-
-    @Override
-    public void setDone(boolean value) {
-        realm.checkIfValid();
-        row.setBoolean(INDEX_DONE, (boolean) value);
-    }
-
-    @Override
-    public boolean isReady() {
-        realm.checkIfValid();
-        return (boolean) row.getBoolean(INDEX_ISREADY);
-    }
-
-    @Override
-    public void setReady(boolean value) {
-        realm.checkIfValid();
-        row.setBoolean(INDEX_ISREADY, (boolean) value);
-    }
-
-    @Override
-    public boolean ismCompleted() {
-        realm.checkIfValid();
-        return (boolean) row.getBoolean(INDEX_MCOMPLETED);
-    }
-
-    @Override
-    public void setmCompleted(boolean value) {
-        realm.checkIfValid();
-        row.setBoolean(INDEX_MCOMPLETED, (boolean) value);
-    }
-
-    @Override
-    public boolean getAnotherBoolean() {
-        realm.checkIfValid();
-        return (boolean) row.getBoolean(INDEX_ANOTHERBOOLEAN);
-    }
-
-    @Override
-    public void setAnotherBoolean(boolean value) {
-        realm.checkIfValid();
-        row.setBoolean(INDEX_ANOTHERBOOLEAN, (boolean) value);
-    }
-
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
-            table.addColumn(ColumnType.BOOLEAN, "done");
-            table.addColumn(ColumnType.BOOLEAN, "isReady");
-            table.addColumn(ColumnType.BOOLEAN, "mCompleted");
-            table.addColumn(ColumnType.BOOLEAN, "anotherBoolean");
-            table.setPrimaryKey("");
-            return table;
-        }
-        return transaction.getTable("class_Booleans");
-    }
-
-    public static void validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
-
-            if (table.getColumnCount() != 4) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 4 but was " + table.getColumnCount());
-            }
-
-            Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for (long i = 0; i < 4; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-            }
-
-            columnIndices = new HashMap<String, Long>();
-            for (String fieldName : getFieldNames()) {
-                long index = table.getColumnIndex(fieldName);
-                if (index == -1) {
-                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type Booleans");
-                }
-                columnIndices.put(fieldName, index);
-            }
-            INDEX_DONE = table.getColumnIndex("done");
-            INDEX_ISREADY = table.getColumnIndex("isReady");
-            INDEX_MCOMPLETED = table.getColumnIndex("mCompleted");
-            INDEX_ANOTHERBOOLEAN = table.getColumnIndex("anotherBoolean")
-
-            if (!columnTypes.containsKey("done")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'done'");
-            }
-            if (columnTypes.get("done") != ColumnType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done'");
-            }
-            if (!columnTypes.containsKey("isReady")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady'");
-            }
-            if (columnTypes.get("isReady") != ColumnType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady'");
-            }
-            if (!columnTypes.containsKey("mCompleted")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted'");
-            }
-            if (columnTypes.get("mCompleted") != ColumnType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted'");
-            }
-            if (!columnTypes.containsKey("anotherBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean'");
-            }
-            if (columnTypes.get("anotherBoolean") != ColumnType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean'");
-            }
-        } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Booleans class is missing from the schema for this Realm.");
-        }
-    }
-
-    public static String getTableName() {
-        return "class_Booleans";
-    }
-
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
-    public static Map<String,Long> getColumnIndices() {
-        return columnIndices;
-    }
-
-    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
-            throws JSONException {
-        Booleans obj = realm.createObject(Booleans.class);
-        if (!json.isNull("done")) {
-            obj.setDone((boolean) json.getBoolean("done"));
-        }
-        if (!json.isNull("isReady")) {
-            obj.setReady((boolean) json.getBoolean("isReady"));
-        }
-        if (!json.isNull("mCompleted")) {
-            obj.setmCompleted((boolean) json.getBoolean("mCompleted"));
-        }
-        if (!json.isNull("anotherBoolean")) {
-            obj.setAnotherBoolean((boolean) json.getBoolean("anotherBoolean"));
-        }
-        return obj;
-    }
-
-    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
-            throws IOException {
-        Booleans obj = realm.createObject(Booleans.class);
-        reader.beginObject();
-        while (reader.hasNext()) {
-            String name = reader.nextName();
-            if (name.equals("done") && reader.peek() != JsonToken.NULL) {
-                obj.setDone((boolean) reader.nextBoolean());
-            } else if (name.equals("isReady")  && reader.peek() != JsonToken.NULL) {
-                obj.setReady((boolean) reader.nextBoolean());
-            } else if (name.equals("mCompleted")  && reader.peek() != JsonToken.NULL) {
-                obj.setmCompleted((boolean) reader.nextBoolean());
-            } else if (name.equals("anotherBoolean")  && reader.peek() != JsonToken.NULL) {
-                obj.setAnotherBoolean((boolean) reader.nextBoolean());
-            } else {
-                reader.skipValue();
-            }
-        }
-        reader.endObject();
-        return obj;
-    }
-
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
-            return object;
-        }
-        return copy(realm, object, update, cache);
-    }
-
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        Booleans realmObject = realm.createObject(Booleans.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        realmObject.setDone(newObject.isDone());
-        realmObject.setReady(newObject.isReady());
-        realmObject.setmCompleted(newObject.ismCompleted());
-        realmObject.setAnotherBoolean(newObject.getAnotherBoolean());
-        return realmObject;
-    }
-
-    static Booleans update(Realm realm, Booleans realmObject, Booleans newObject, Map<RealmObject, RealmObjectProxy> cache) {
-        realmObject.setDone(newObject.isDone());
-        realmObject.setReady(newObject.isReady());
-        realmObject.setmCompleted(newObject.ismCompleted());
-        realmObject.setAnotherBoolean(newObject.getAnotherBoolean());
-        return realmObject;
-    }
-
-    @Override
-    public String toString() {
-        if (!isValid()) {
-            return "Invalid object";
-        }
-        StringBuilder stringBuilder = new StringBuilder("Booleans = [");
-        stringBuilder.append("{done:");
-        stringBuilder.append(isDone());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{isReady:");
-        stringBuilder.append(isReady());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{mCompleted:");
-        stringBuilder.append(ismCompleted());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{anotherBoolean:");
-        stringBuilder.append(getAnotherBoolean());
-        stringBuilder.append("}");
-        stringBuilder.append("]");
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public int hashCode() {
-        String realmName = realm.getPath();
-        String tableName = row.getTable().getName();
-        long rowIndex = row.getIndex();
-
-        int result = 17;
-        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
-        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
-        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        BooleansRealmProxy aBooleans = (BooleansRealmProxy)o;
-
-        String path = realm.getPath();
-        String otherPath = aBooleans.realm.getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
-
-        String tableName = row.getTable().getName();
-        String otherTableName = aBooleans.row.getTable().getName();
-        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
-
-        if (row.getIndex() != aBooleans.row.getIndex()) return false;
-
-        return true;
-    }
-
-}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java b/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
deleted file mode 100644
index 301601ff83..0000000000
--- a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package io.realm;
-
-
-@io.realm.annotations.internal.RealmModule(allClasses = true)
-class DefaultRealmModule {
-
-}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
deleted file mode 100644
index 4c54eb3c62..0000000000
--- a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ /dev/null
@@ -1,231 +0,0 @@
-package io.realm;
-
-
-import android.util.JsonReader;
-import android.util.JsonToken;
-import io.realm.RealmObject;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.ColumnType;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.LinkView;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-import io.realm.internal.android.JsonUtils;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import some.test.Simple;
-
-public class SimpleRealmProxy extends Simple
-        implements RealmObjectProxy {
-
-    private static long INDEX_NAME;
-    private static long INDEX_AGE;
-    private static Map<String, Long> columnIndices;
-    private static final List<String> FIELD_NAMES;
-    static {
-        List<String> fieldNames = new ArrayList<String>();
-        fieldNames.add("name");
-        fieldNames.add("age");
-        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
-    }
-
-    @Override
-    public String getName() {
-        realm.checkIfValid();
-        return (java.lang.String) row.getString(INDEX_NAME);
-    }
-
-    @Override
-    public void setName(String value) {
-        realm.checkIfValid();
-        row.setString(INDEX_NAME, (String) value);
-    }
-
-    @Override
-    public int getAge() {
-        realm.checkIfValid();
-        return (int) row.getLong(INDEX_AGE);
-    }
-
-    @Override
-    public void setAge(int value) {
-        realm.checkIfValid();
-        row.setLong(INDEX_AGE, (long) value);
-    }
-
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
-            table.addColumn(ColumnType.STRING, "name");
-            table.addColumn(ColumnType.INTEGER, "age");
-            table.setPrimaryKey("");
-            return table;
-        }
-        return transaction.getTable("class_Simple");
-    }
-
-    public static void validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
-
-            if (table.getColumnCount() != 2) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 2 but was " + table.getColumnCount());
-            }
-
-            Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for (long i = 0; i < 2; i++) {
-                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-            }
-
-            columnIndices = new HashMap<String, Long>();
-            for (String fieldName : getFieldNames()) {
-                long index = table.getColumnIndex(fieldName);
-                if (index == -1) {
-                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type Simple");
-                }
-                columnIndices.put(fieldName, index);
-            }
-            INDEX_NAME = table.getColumnIndex("name");
-            INDEX_AGE = table.getColumnIndex("age");
-
-            if (!columnTypes.containsKey("name")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'name'");
-            }
-            if (columnTypes.get("name") != ColumnType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name'");
-            }
-            if (!columnTypes.containsKey("age")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age'");
-            }
-            if (columnTypes.get("age") != ColumnType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age'");
-            }
-        } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Simple class is missing from the schema for this Realm.");
-        }
-    }
-
-    public static String getTableName() {
-        return "class_Simple";
-    }
-
-    public static List<String> getFieldNames() {
-        return FIELD_NAMES;
-    }
-
-    public static Map<String,Long> getColumnIndices() {
-        return columnIndices;
-    }
-
-    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
-            throws JSONException {
-        Simple obj = realm.createObject(Simple.class);
-        if (!json.isNull("name")) {
-            obj.setName((String) json.getString("name"));
-        }
-        if (!json.isNull("age")) {
-            obj.setAge((int) json.getInt("age"));
-        }
-        return obj;
-    }
-
-    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
-            throws IOException {
-        Simple obj = realm.createObject(Simple.class);
-        reader.beginObject();
-        while (reader.hasNext()) {
-            String name = reader.nextName();
-            if (name.equals("name") && reader.peek() != JsonToken.NULL) {
-                obj.setName((String) reader.nextString());
-            } else if (name.equals("age")  && reader.peek() != JsonToken.NULL) {
-                obj.setAge((int) reader.nextInt());
-            } else {
-                reader.skipValue();
-            }
-        }
-        reader.endObject();
-        return obj;
-    }
-
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
-            return object;
-        }
-        return copy(realm, object, update, cache);
-    }
-
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
-        Simple realmObject = realm.createObject(Simple.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
-        realmObject.setAge(newObject.getAge());
-        return realmObject;
-    }
-
-    static Simple update(Realm realm, Simple realmObject, Simple newObject, Map<RealmObject, RealmObjectProxy> cache) {
-        realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
-        realmObject.setAge(newObject.getAge());
-        return realmObject;
-    }
-
-    @Override
-    public String toString() {
-        if (!isValid()) {
-            return "Invalid object";
-        }
-        StringBuilder stringBuilder = new StringBuilder("Simple = [");
-        stringBuilder.append("{name:");
-        stringBuilder.append(getName());
-        stringBuilder.append("}");
-        stringBuilder.append(",");
-        stringBuilder.append("{age:");
-        stringBuilder.append(getAge());
-        stringBuilder.append("}");
-        stringBuilder.append("]");
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public int hashCode() {
-        String realmName = realm.getPath();
-        String tableName = row.getTable().getName();
-        long rowIndex = row.getIndex();
-
-        int result = 17;
-        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
-        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
-        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        SimpleRealmProxy aSimple = (SimpleRealmProxy)o;
-
-        String path = realm.getPath();
-        String otherPath = aSimple.realm.getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
-
-        String tableName = row.getTable().getName();
-        String otherTableName = aSimple.row.getTable().getName();
-        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
-
-        if (row.getIndex() != aSimple.row.getIndex()) return false;
-
-        return true;
-    }
-
-}
diff --git a/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java b/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
deleted file mode 100644
index 4b52b53766..0000000000
--- a/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package io.realm.entities;
-
-import java.util.Date;
-
-import io.realm.RealmList;
-import io.realm.RealmObject;
-import some.test.AllTypes;
-
-public class NoAccessors extends RealmObject {
-    private String columnString;
-    private long columnLong;
-    private float columnFloat;
-    private double columnDouble;
-    private boolean columnBoolean;
-    private Date columnDate;
-    private byte[] columnBinary;
-    private AllTypes columnRealmObject;
-    private RealmList<AllTypes> columnRealmList;
-}
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 2076503aa4..5fd63be38b 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -1,9 +1,92 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+    }
+}
+
 apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'com.jfrog.bintray'
 
-version = new File("${projectDir}/../version.txt").text.trim()
 sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
-repositories {
-    jcenter()
+group = 'io.realm'
+version = file("${projectDir}/../version.txt").text.trim();
+
+def commonPom = {
+    licenses {
+        license {
+            name 'The Apache Software License, Version 2.0'
+            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+            distribution 'repo'
+        }
+    }
+    issueManagement {
+        system 'github'
+        url 'https://github.com/realm/realm-java/issues'
+    }
+    scm {
+        url 'scm:https://github.com/realm/realm-java'
+        connection 'scm:git@github.com:realm/realm-java.git'
+        developerConnection 'scm:git@github.com:realm/realm-java.git'
+    }
+}
+
+publishing {
+    publications {
+        realmPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId = 'realm-annotations'
+            from components.java
+            pom.withXml {
+                Node root = asNode()
+                root.appendNode('name', 'realm-annotations')
+                root.appendNode('description', 'Annotations for Realm. Realm is a mobile database: a replacement for SQLite & ORMs')
+                root.appendNode('url', 'http://realm.io')
+                root.children().last() + commonPom
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+
+    dryRun = false
+    publish = false
+
+    publications = ['realmPublication']
+    pkg {
+        repo = 'maven'
+        name = 'realm-annotations'
+        desc = 'Realm for Android'
+        websiteUrl = 'http://realm.io'
+        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
+        vcsUrl = 'https://github.com/realm/realm-java.git'
+        licenses = ['Apache-2.0']
+        labels = ['android', 'realm']
+        publicDownloadNumbers = false
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+        }
+        defaults {
+            publications ('realmPublication')
+        }
+    }
 }
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index b761216703..e8c6bf7bb4 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 3462ee85eb..587246a1a4 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Nov 06 12:47:59 CET 2014
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/realm-annotations/gradlew b/realm-annotations/gradlew
index 91a7e269e1..97fac783e1 100755
--- a/realm-annotations/gradlew
+++ b/realm-annotations/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/realm-annotations/gradlew.bat b/realm-annotations/gradlew.bat
index aec99730b4..8a0b282aa6 100644
--- a/realm-annotations/gradlew.bat
+++ b/realm-annotations/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-annotations/settings.gradle b/realm-annotations/settings.gradle
deleted file mode 100644
index 47298f7a28..0000000000
--- a/realm-annotations/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'realm-annotations'
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
index 518b9a0975..784f6c7676 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
@@ -16,6 +16,13 @@
 
 package io.realm.annotations;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.FIELD)
 public @interface Ignore {
 
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Index.java b/realm-annotations/src/main/java/io/realm/annotations/Index.java
index be50d1c6bc..bb4f9e1b17 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Index.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Index.java
@@ -16,12 +16,19 @@
 
 package io.realm.annotations;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
 /**
  * This annotation will add a search index to the field. A search index will make the
  * Realm file larger and inserts slower but queries will be faster. 
- *
- * NOTICE: only String fields can be indexed.
+ * <p>
+ * NOTICE: Only String, int, byte, short, long, boolean and Date fields can be indexed.
  */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.FIELD)
 public @interface Index {
 
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index 708b039f9e..a0cf1174e8 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -26,12 +26,12 @@
  * should uniquely identify the object. Trying to insert an object with an existing primary key
  * will result in an {@link io.realm.exceptions.RealmException}.
  *
- * Primary keys on Strings also counts as having the {@link io.realm.annotations.Index} annotation.
+ * Primary keys also count as having the {@link Index} and {@link Required} annotations.
  *
- * Only one field pr. model class can have this annotation and it is only allowed on the following
- * types: String, short, int, long
+ * Only one field pr. RealmObject class can have this annotation and it is only allowed on the following
+ * types: String, short, int, long, byte
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
 public @interface PrimaryKey {
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
new file mode 100644
index 0000000000..5f3cf9b738
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * By default a Realm can stores all classes extending RealmObject in a project. However, if you want to restrict a
+ * Realm to only contain a subset of classes or want to share them between a library project and an app project you must
+ * use a RealmModule.
+ * <p>
+ * A RealmModule is a collection of classes extending RealmObject that can be combined with other RealmModules to create
+ * the schema for a Realm. This makes it easier to control versioning and migration of those Realms.
+ * <p>
+ * A RealmModule can either be a library module or an app module. The distinction is made by setting
+ * {@code library = true}. Setting {@code library = true} is normally only relevant for library authors. See below for
+ * further details.
+ *
+ *
+ * <h2>RealmModules and libraries</h2>
+ *
+ * Realms default behavior is to automatically create a RealmModule called {@code DefaultRealmModule} which contains all
+ * classes extending RealmObject in a project. This module is automatically known by Realm.
+ * <p>
+ * This behavior is problematic when combining a library project and an app project that both uses Realm. This is
+ * because the {@code DefaultRealmModule} will be created for both the library project and the app project, which will
+ * cause the project to fail with duplicate class definition errors.
+ * <p>
+ * Library authors are responsible for avoiding this conflict by using explicit modules where {@code library = true} is
+ * set. This disables the generation of the DefaultRealmModule for the library project and allows the library to be
+ * included in the app project that also uses Realm. This means that library projects that uses Realm internally are
+ * required to specify a specific module using {@code RealmConfiguration.setModules()}.
+ * <p>
+ * App developers are not required to specify any modules, as they implicitly use the {@code DefaultRealmModule}, but
+ * they now has the option of adding the library project classes to their schema using
+ * {@code RealmConfiguration.addModule()}.
+ *
+ * @see <a href="https://github.com/realm/realm-java/tree/master/examples/realmModuleAppExample">Example of a project using modules</a>
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Inherited
+public @interface RealmModule {
+
+    /**
+     * Setting this to true will mark this module as a library module. This will prevent Realm from generating the
+     * {@code DefaultRealmModule} containing all classes. This is required by libraries so they do not interfere with
+     * Realms running in app code, but it also means that all libraries using Realm must explicitly use a module and
+     * cannot  rely on the default module being present.
+     *
+     * Creating library modules and normal modules in the same project is not allowed and will result in the annotation
+     * processor throwing an exception.
+     */
+    boolean library() default false;
+
+    /**
+     * Instead of adding all Realm classes manually to a module, set this boolean to true to automatically include all
+     * Realm classes in this project. This does not include classes from other libraries which must be exposed using
+     * their own module.
+     *
+     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
+     * an exception.
+     */
+    boolean allClasses() default false;
+
+    /**
+     * Specifies the classes extending RealmObject that should be part of this module. Only classes in this project can
+     * be included. Classes from other libraries must be exposed using their own module.
+     *
+     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
+     * an exception.
+     */
+    Class<?>[] classes() default {};
+}
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Required.java b/realm-annotations/src/main/java/io/realm/annotations/Required.java
new file mode 100644
index 0000000000..a6e500c637
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/Required.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation will mark the field as not nullable. When the field is {@link Required},
+ * it cannot be set to {@code null}.
+ * <p>
+ * Only {@code Boolean, Byte, Short, Integer, Long, Float, Double, String, byte[], Date} can be annotated
+ * with {@link Required}. Compiling will fail when fields with other types have {@link Required} annotation.
+ * Fields with primitive types and the {@link io.realm.RealmList} type are required implicitly.
+ * Fields with {@link io.realm.RealmObject} type are always nullable.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.FIELD)
+public @interface Required {
+
+}
\ No newline at end of file
diff --git a/realm-annotations/src/main/java/io/realm/annotations/internal/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/internal/RealmModule.java
deleted file mode 100644
index 23a186c8af..0000000000
--- a/realm-annotations/src/main/java/io/realm/annotations/internal/RealmModule.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.annotations.internal;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * By default a Realm can stores all classes that extends RealmClass in a project.
- * However, if you want to restrict a Realm to contain only certain classes or want
- * to share them between a library project and an app project you specify that with
- * a RealmModule.
- * <p>
- * A RealmModule is a collection of RealmClass'es that can be combined with other
- * RealmModules to create the object schema for a Realm. This makes it easier to
- * control versioning and migration of those Realms.
- * <p>
- * A RealmModule can either be a library module or an app module. This distinction
- * is made by setting {@code library = true}. Creating a library module will prevent
- * Realm from creating the default Realm module, which would otherwise conflict with
- * same class being created by app projects.
- * <p>
- * This means that library projects are <bold>required</bold> to use library modules
- * to allow the library to work seemlessly with app code. App developers can then
- * reuse the modules exposed by the library if they want to use RealmClass'es from
- * that library.
- */
-@Retention(RetentionPolicy.CLASS)
-@Target(ElementType.TYPE)
-@Inherited
-public @interface RealmModule {
-
-    /**
-     * Setting this to true will mark this module as a library module. This will prevent Realm from generating the
-     * default realm module containing all classes. This is required by libraries as not to intefer with Realms running
-     * in app code, but also means that all libraries using Realm must explicitly use a module and cannot rely on the
-     * default module being present.
-     *
-     * Creating library modules and normal modules in the same project is not allowed and will result in the annotation
-     * processor throwing an error.
-     */
-    boolean library() default false;
-
-    /**
-     * Instead of adding all Realm classes manually to a module, set this boolean to true to automatically include all
-     * Realm classes in this project. This does not include classes from other libraries which must be  exposed using
-     * their own module.
-     *
-     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
-     * an error.
-     */
-    boolean allClasses() default false;
-
-    /**
-     * Specify the Realm classes part of this module. Only classes in this project can be included. Realm classes
-     * from other libraries must be exposed using their own module.
-     *
-     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
-     * an error.
-     */
-    Class<?>[] classes() default { };
-}
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
deleted file mode 100644
index cf9e4486a0..0000000000
--- a/realm-jni/build.gradle
+++ /dev/null
@@ -1,198 +0,0 @@
-ext.coreVersion = '0.89.2'
-ext.clang = false // gcc is default for the NDK. It also produces smaller binaries
-
-def commonCflags = [ '-std=c++11', '-ffunction-sections', '-fdata-sections', '-flto' ]
-
-enum Compiler {
-    GCC, CLANG
-}
-
-// Unfortunately the NDK has no consistency when it comes to naming.
-// This Class holds all the different names used and some more informations
-class Toolchain {
-    // The standard name: arm, arm64, mips, x86
-    String name
-
-    // The name used when generating the standalone toolchain
-    String fullName
-
-    // The prefix commands use. i.e. arm-linux-androideabi-gcc
-    String commandPrefix
-
-    // Which version of each compiler to use
-    Map<Compiler, String> version
-
-    // The first Android platform to support this toolchain
-    int platform
-}
-
-// This class describes the specific target
-class Target {
-    // The name of the target. This is used for the task names
-    String name
-
-    // The name of the folder the Android Gradle plugin expects to find the shared library
-    String jniFolder
-
-    // The toolchain associated to this target
-    Toolchain toolchain
-
-    // The CFLAGS specific to this target
-    List<String> cflags
-}
-
-// We are using gcc 4.8 for 32 bits targets and 4.9 for 64 bits targets, as the NDK defaults.
-def toolchains = [
-    new Toolchain( name:'arm', fullName:'arm-linux-androideabi', commandPrefix:'arm-linux-androideabi', version:[ (Compiler.GCC):'4.8', (Compiler.CLANG):'3.5' ], platform:8 ),
-    new Toolchain( name:'arm64', fullName:'aarch64-linux-android', commandPrefix:'aarch64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 ),
-    new Toolchain( name:'mips', fullName:'mipsel-linux-android', commandPrefix:'mipsel-linux-android', version:[ (Compiler.GCC):'4.8', (Compiler.CLANG):'3.5' ], platform:9 ),
-    new Toolchain( name:'x86', fullName:'x86', commandPrefix:'i686-linux-android', version:[ (Compiler.GCC):'4.8', (Compiler.CLANG):'3.5' ], platform:9 )
-]
-
-def targets = [
-    new Target( name:'arm', jniFolder:'armeabi', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb' ] ),
-    new Target( name:'arm-v7a', jniFolder:'armeabi-v7a', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
-    new Target( name:'arm64', jniFolder:'arm64-v8a', toolchain:toolchains.find{it.name == 'arm64'}, cflags:[] ),
-    new Target( name:'mips', jniFolder:'mips', toolchain:toolchains.find{it.name == 'mips'}, cflags:[] ),
-    new Target( name:'x86', jniFolder:'x86', toolchain:toolchains.find{it.name == 'x86'}, cflags:[] )
-]
-
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'de.undercouch:gradle-download-task:1.0'
-    }
-}
-
-apply plugin: 'download-task'
-
-Properties localProperties = new Properties()
-localProperties.load(new FileInputStream("${projectDir}/../local.properties"))
-localProperties.entrySet().each() { entry ->
-    project.ext[entry.getKey()] = localProperties.setProperty(entry.getKey(), entry.getValue())
-}
-
-task checkProperties(group: 'check', description: 'Check the user provided gradle.properties') << {
-    if (!project.ext['ndk.dir']) {
-        throw new GradleException('The ndkDir property in the gradle.properties file is not set.')
-    } else if (project.ext['ndk.dir'].endsWith('/')) {
-        throw new GradleException('The path provided in the ndkProperty in the gradle.properties ends with /')
-    } else if (!file(project.ext['ndk.dir']).directory) {
-        throw new GradleException('The path provided in the ndkDir property in the gradle.properties is not a folder.')
-    } else if (!file(new File(project.ext['ndk.dir'], 'RELEASE.TXT')).file) {
-        throw new GradleException('The path provided in the ndkDir property in the gradle.properties does not seem to be an Android NDK.')
-    }
-    if (project.ext.has('encryption') && project.ext['encryption'] == 'true') {
-        project.coreVersion += '-encryption'
-    }
-}
-
-// TODO: Split this task into smaller subtasks
-task downloadCore(group: 'build setup', description: 'Download the latest version of realm core', dependsOn: checkProperties) {
-    outputs.dir "../core-${project.coreVersion}"
-    doLast {
-        download {
-            src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
-            dest new File(buildDir, "core-android-${project.coreVersion}.tar.gz")
-            onlyIfNewer true
-        }
-        copy {
-            from tarTree(new File(buildDir, "core-android-${project.coreVersion}.tar.gz"))
-            into "../core-${project.coreVersion}"
-        }
-        for (target in targets) {
-            exec {
-                commandLine = [
-                        'make',
-                        '-C', "${projectDir}/src",
-                        "BASE_DENOM=${target.name}",
-                        'LIB_SUFFIX_SHARED=.so',
-                        'clean'
-                ]
-            }
-        }
-        exec {
-            commandLine = [
-                    'rm',
-                    '-rf',
-                    "${projectDir}/build/*"
-            ]
-        }
-    }
-}
-
-toolchains.each { toolchain ->
-    task "generateNdkToolchain${toolchain.name.capitalize()}"(type: Exec) {
-        group 'build setup'
-        description "Generate the NDK standalone toolchain for the ${toolchain.name.capitalize()} platform"
-        dependsOn { checkProperties }
-        outputs.dir new File("${buildDir}/standalone-toolchains/${toolchain.name}")
-        commandLine = [
-            "bash",
-            "${project.ext['ndk.dir']}/build/tools/make-standalone-toolchain.sh",
-            "--platform=android-${toolchain.platform}",
-            "--install-dir=${buildDir}/standalone-toolchains/${toolchain.name}",
-            "--toolchain=${toolchain.fullName}-${clang?'clang'+toolchain.version[Compiler.CLANG]:toolchain.version[Compiler.GCC]}"
-        ]
-    }
-}
-
-targets.each { target ->
-    task "buildAndroidJni${target.name.capitalize()}"(type: Exec) {
-        group 'build'
-        description "Build the Android JNI shared library for the ${target.name.capitalize()} platform"
-        dependsOn downloadCore
-        dependsOn "generateNdkToolchain${target.toolchain.name.capitalize()}"
-        environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
-        environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
-        environment STRIP: "${target.toolchain.commandPrefix}-strip"
-        environment REALM_ANDROID: '1'
-        commandLine = [
-            'make',
-            '-C', "${projectDir}/src",
-            "CC_IS=${clang?'clang':'gcc'}",
-            "REALM_CFLAGS=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${projectDir}/../core-${project.coreVersion}/include",
-            "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
-            "BASE_DENOM=${target.name}",
-            "REALM_LDFLAGS=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${projectDir}/../core-${project.coreVersion} -Wl,--gc-sections -flto",
-            'LIB_SUFFIX_SHARED=.so',
-            "librealm-jni-${target.name}.so"
-        ]
-    }
-
-    task "copyAndroidJni${target.name.capitalize()}"(type: Copy) {
-        dependsOn "buildAndroidJni${target.name.capitalize()}"
-        from "${projectDir}/src/librealm-jni-${target.name}.so"
-        into "${projectDir}/../realm/src/main/jniLibs/${target.jniFolder}"
-        rename "librealm-jni-${target.name}.so", 'librealm-jni.so'
-    }
-}
-
-task buildAndroidJni(group: 'build', description: 'Build the Android JNI shared library for all the supported platforms') {
-    targets.each { target ->
-        dependsOn "copyAndroidJni${target.name.capitalize()}"
-    }
-}
-
-task clean(group: 'build', description: 'Clean the make artifacts') << {
-    targets.each { target ->
-        exec {
-            commandLine = [
-                'make',
-                '-C', "${projectDir}/src",
-                "BASE_DENOM=${target.name}",
-                'LIB_SUFFIX_SHARED=.so',
-                'clean'
-            ]
-        }
-    }
-    exec {
-        commandLine = [
-            'rm',
-            '-rf',
-            "${projectDir}/build/*"
-        ]
-    }
-}
diff --git a/realm-jni/gradle/wrapper/gradle-wrapper.jar b/realm-jni/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index b761216703..0000000000
Binary files a/realm-jni/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/realm-jni/gradle/wrapper/gradle-wrapper.properties b/realm-jni/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 35b8fa2d3c..0000000000
--- a/realm-jni/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Wed Aug 27 08:43:24 CEST 2014
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/realm-jni/gradlew b/realm-jni/gradlew
deleted file mode 100755
index 91a7e269e1..0000000000
--- a/realm-jni/gradlew
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/usr/bin/env bash
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn ( ) {
-    echo "$*"
-}
-
-die ( ) {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-esac
-
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin, switch paths to Windows format before running java
-if $cygwin ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=$((i+1))
-    done
-    case $i in
-        (0) set -- ;;
-        (1) set -- "$args0" ;;
-        (2) set -- "$args0" "$args1" ;;
-        (3) set -- "$args0" "$args1" "$args2" ;;
-        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
-}
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
-
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/realm-jni/gradlew.bat b/realm-jni/gradlew.bat
deleted file mode 100644
index aec99730b4..0000000000
--- a/realm-jni/gradlew.bat
+++ /dev/null
@@ -1,90 +0,0 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
diff --git a/realm-jni/src/io_realm_internal_Row.h b/realm-jni/src/io_realm_internal_Row.h
deleted file mode 100644
index 1e4db7d73d..0000000000
--- a/realm-jni/src/io_realm_internal_Row.h
+++ /dev/null
@@ -1,245 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Row */
-
-#ifndef _Included_io_realm_internal_Row
-#define _Included_io_realm_internal_Row
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetIndex
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetDateTime
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetDate
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
deleted file mode 100644
index bb26d54e11..0000000000
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ /dev/null
@@ -1,1176 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "io_realm_internal_TableQuery.h"
-#include "tablequery.hpp"
-
-using namespace realm;
-
-#if 1
-#define COL_TYPE_VALID(env,ptr,col, type)           TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)
-#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)
-#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
-#define QUERY_VALID(env, pQuery)                    query_valid(env, pQuery)
-#else
-#define COL_TYPE_VALID(env,ptr,col, type)           (true)
-#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      (true)
-#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
-#define QUERY_VALID(env, pQuery)                    (true)
-#endif
-
-inline bool query_valid(JNIEnv* env, Query* pQuery)
-{
-    return TABLE_VALID(env, pQuery->get_table().get());
-}
-
-inline bool query_col_type_valid(JNIEnv* env, jlong nativeQueryPtr, jlong colIndex, DataType type)
-{
-    return COL_TYPE_VALID(env, TQ(nativeQueryPtr)->get_current_table().get(), colIndex, type);
-}
-
-//-------------------------------------------------------
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv *, jclass, jlong nativeQueryPtr) {
-    TR_ENTER_PTR(nativeQueryPtr)
-    delete Q(nativeQueryPtr);
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
-(JNIEnv *env, jobject, jlong nativeQueryPtr)
-{
-    try {
-        return to_jstring(env, Q(nativeQueryPtr)->validate());
-    } CATCH_STD();
-    return NULL;
-}
-
-
-// helper functions and macros
-#define GET_ARRAY() \
-    jsize arr_len = env->GetArrayLength(columnIndexes); \
-    jlong *arr = env->GetLongArrayElements(columnIndexes, NULL);
-
-
-#define RELEASE_ARRAY() \
-    env->ReleaseLongArrayElements(columnIndexes, arr, 0);
-
-Table* getTableLink(jlong nativeQueryPtr, jlong *arr, jsize arr_len) {
-    Table* tbl = Q(nativeQueryPtr)->get_table().get();
-    for (int i=0; i<arr_len-1; i++) {
-        tbl->link(size_t(arr[i]));
-    }
-    return tbl;
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_equal(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_notequal(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) != cpptype(value);
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_greater(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) > cpptype(value);
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_greaterequal(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) >= cpptype(value);
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_less(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) < cpptype(value);
-}
-
-template <typename coretype, typename cpptype, typename javatype>
-Query numeric_link_lessequal(Table* tbl, jlong columnIndex, javatype value) {
-    return tbl->column<coretype>(size_t(columnIndex)) <= cpptype(value);
-}
-
-
-// Integer
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<int64_t>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int))
-                return;
-            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<int64_t>(value1), static_cast<int64_t>(value2));
-        }
-        else {
-            Q(nativeQueryPtr)->group();
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value1));
-            tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value2));
-            Q(nativeQueryPtr)->end_group();
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-// Float
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<float>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Float, float, jfloat>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value1, jfloat value2)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float))
-                return;
-            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<float>(value1), static_cast<float>(value2));
-        }
-        else {
-            Q(nativeQueryPtr)->group();
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Float, float, jfloat>(tbl, arr[arr_len-1], value1));
-            tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Float, float, jfloat>(tbl, arr[arr_len-1], value2));
-            Q(nativeQueryPtr)->end_group();
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-
-// Double
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<double>(value));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Double, double, jdouble>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value1, jdouble value2)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double))
-                return;
-            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<double>(value1), static_cast<double>(value2));
-        }
-        else {
-            Q(nativeQueryPtr)->group();
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Double, double, jdouble>(tbl, arr[arr_len-1], value1));
-            tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Double, double, jdouble>(tbl, arr[arr_len-1], value2));
-            Q(nativeQueryPtr)->end_group();
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-
-// DateTime
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->equal_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->not_equal_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->greater_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->greater_equal_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->less_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->less_equal_datetime(S(arr[0]), DateTime(static_cast<time_t>(value)));
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime))
-                return;
-            Q(nativeQueryPtr)->between_datetime(S(arr[0]), DateTime(static_cast<time_t>(value1)), DateTime(static_cast<time_t>(value2)));
-        }
-        else {
-            Q(nativeQueryPtr)->group();
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value1));
-            tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(tbl, arr[arr_len-1], value2));
-            Q(nativeQueryPtr)->end_group();
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-// Bool
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(
-  JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jboolean value)
-{
-    GET_ARRAY()
-    try {
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Bool))
-                return;
-            Q(nativeQueryPtr)->equal(S(arr[0]), value != 0 ? true : false);
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Bool, bool, jboolean>(tbl, arr[arr_len-1], value));
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-// String
-
-enum StringPredicate {
-    StringEqual,
-    StringNotEqual,
-    StringContains,
-    StringBeginsWith,
-    StringEndsWith
-};
-
-
-void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
-    GET_ARRAY()
-    try {
-        bool isCaseSensitive = caseSensitive ? true : false;
-        JStringAccessor value2(env, value); // throws
-        if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_String))
-                return;
-            switch (predicate) {
-            case StringEqual:
-                Q(nativeQueryPtr)->equal(S(arr[0]), value2, isCaseSensitive);
-                break;
-            case StringNotEqual:
-                Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, isCaseSensitive);
-                break;
-            case StringContains:
-                Q(nativeQueryPtr)->contains(S(arr[0]), value2, isCaseSensitive);
-                break;
-            case StringBeginsWith:
-                Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, isCaseSensitive);
-                break;
-            case StringEndsWith:
-                Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, isCaseSensitive);
-                break;
-            }
-        }
-        else {
-            Table* tbl = getTableLink(nativeQueryPtr, arr, arr_len);
-            switch (predicate) {
-            case StringEqual:
-                Q(nativeQueryPtr)->and_query(tbl->column<String>(size_t(arr[arr_len-1])).equal(StringData(value2), isCaseSensitive));
-                break;
-            case StringNotEqual:
-                Q(nativeQueryPtr)->and_query(tbl->column<String>(size_t(arr[arr_len-1])).not_equal(StringData(value2), isCaseSensitive));
-                break;
-            case StringContains:
-                Q(nativeQueryPtr)->and_query(tbl->column<String>(size_t(arr[arr_len-1])).contains(StringData(value2), isCaseSensitive));
-                break;
-            case StringBeginsWith:
-                Q(nativeQueryPtr)->and_query(tbl->column<String>(size_t(arr[arr_len-1])).begins_with(StringData(value2), isCaseSensitive));
-                break;
-            case StringEndsWith:
-                Q(nativeQueryPtr)->and_query(tbl->column<String>(size_t(arr[arr_len-1])).ends_with(StringData(value2), isCaseSensitive));
-                break;
-            }
-        }
-    } CATCH_STD()
-    RELEASE_ARRAY()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
-{
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEqual);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
-{
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringNotEqual);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
-{
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringBeginsWith);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
-{
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
-{
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
-}
-
-
-// General ----------------------------------------------------
-// TODO:
-// Some of these methods may not need the check for Table/Query validity,
-// as they are called for each method when building up the query.
-// Consider to reduce to just the "action" methods on Query
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeTableview(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong nativeTableViewPtr)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->get_table()->where(TV(nativeTableViewPtr));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->group();
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->end_group();
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    // No verification of parameters needed?
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->Or();
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->Not();
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong columnIndex)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-
-    try {
-        Table* pTable = pTQuery->get_current_table().get();
-        pTQuery->push_subtable(S(columnIndex));
-        if (!COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Table))
-            return;
- 
-        pTQuery->subtable(S(columnIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-    try {
-        if (pTQuery->pop_subtable()) {
-            pTQuery->end_subtable();
-        }
-        else {
-            ThrowException(env, UnsupportedOperation, "No matching subtable().");
-        }
-    } CATCH_STD()
-}
-
-
-// Find --------------------------------------
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong fromTableRow)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery))
-        return -1;
-    // It's valid to go 1 past the end index
-    if ((fromTableRow < 0) || (S(fromTableRow) > pTable->size())) {
-        // below check will fail with appropriate exception
-        (void) ROW_INDEX_VALID(env, pTable, fromTableRow);
-        return -1;
-    }
-
-    try {
-        size_t r = pQuery->find( S(fromTableRow) );
-        return (r == not_found) ? jlong(-1) : jlong(r);
-    } CATCH_STD()
-    return -1;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return -1;
-    try {
-        TableView* pResultView = new TableView( pQuery->find_all(S(start), S(end), S(limit)) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return -1;
-}
-
-
-// Integer Aggregates
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->sum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        size_t resultcount;
-        //TODO: return resultcount?
-        double avg = pQuery->average_int(S(columnIndex), &resultcount, S(start), S(end), S(limit));
-        //fprintf(stderr, "!!!Average(%d, %d) = %f (%d results)\n", start, end, avg, resultcount); fflush(stderr);
-        return avg;
-    } CATCH_STD()
-    return 0;
-}
-
-
-// float Aggregates
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->sum_float(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->maximum_float(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->minimum_float(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        size_t resultcount;
-        double avg = pQuery->average_float(S(columnIndex), &resultcount, S(start), S(end), S(limit));
-        return avg;
-    } CATCH_STD()
-    return 0;
-}
-
-// double Aggregates
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->sum_double(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->maximum_double(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->minimum_double(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        //TODO: Return resultcount
-        size_t resultcount;
-        double avg = pQuery->average_double(S(columnIndex), &resultcount, S(start), S(end), S(limit));
-        return avg;
-    } CATCH_STD()
-    return 0;
-}
-
-
-// date aggregates
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        // This exploits the fact that dates are stored as int in core
-        return pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate(
-    JNIEnv* env, jobject, jlong nativeQueryPtr,
-    jlong columnIndex, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        // This exploits the fact that dates are stored as int in core
-        return pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-// Count, Remove
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->count(S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
-        return 0;
-    try {
-        return pQuery->remove(S(start), S(end), S(limit));
-    } CATCH_STD()
-    return 0;
-}
-
-// isNull and isNotNull
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
-    JNIEnv *env, jobject, jlong nativeQueryPtr, jlong columnIndex)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    try {
-        Table* pTable = pQuery->get_table().get();
-        if (!COL_TYPE_LINK_OR_LINKLIST(env, pTable, columnIndex))
-            return;
-        Query query = pTable->column<Link>(S(columnIndex)).is_null();
-        pQuery->and_query(query);
-    } CATCH_STD()
-}
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
new file mode 100644
index 0000000000..0871dca467
--- /dev/null
+++ b/realm-transformer/build.gradle
@@ -0,0 +1,120 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+    }
+}
+
+apply plugin: 'groovy'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'com.jfrog.bintray'
+
+group = 'io.realm'
+version = file("${projectDir}/../version.txt").text.trim();
+
+sourceCompatibility = '1.6'
+targetCompatibility = '1.6'
+
+repositories {
+    mavenLocal()
+    jcenter()
+}
+
+configurations {
+    provided
+    compile.extendsFrom provided
+}
+
+sourceSets {
+    main {
+        compileClasspath += configurations.provided
+    }
+}
+
+dependencies {
+    compile localGroovy()
+    compile gradleApi()
+    compile "io.realm:realm-annotations:${version}"
+    provided 'com.android.tools.build:gradle:1.5.0'
+    compile 'org.javassist:javassist:3.20.0-GA'
+
+    testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
+        exclude module: 'groovy-all'
+    }
+}
+
+def commonPom = {
+    licenses {
+        license {
+            name 'The Apache Software License, Version 2.0'
+            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+            distribution 'repo'
+        }
+    }
+    issueManagement {
+        system 'github'
+        url 'https://github.com/realm/realm-java/issues'
+    }
+    scm {
+        url 'scm:https://github.com/realm/realm-java'
+        connection 'scm:git@github.com:realm/realm-java.git'
+        developerConnection 'scm:git@github.com:realm/realm-java.git'
+    }
+}
+
+publishing {
+    publications {
+        realmPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId = 'realm-transformer'
+            from components.java
+            pom.withXml {
+                Node root = asNode()
+                root.appendNode('name', 'realm-transformer')
+                root.appendNode('description', 'Android Gradle Transformer for Realm. Realm is a mobile database: a replacement for SQLite & ORMs')
+                root.appendNode('url', 'http://realm.io')
+                root.children().last() + commonPom
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+
+    dryRun = false
+    publish = false
+
+    publications = ['realmPublication']
+    pkg {
+        repo = 'maven'
+        name = 'realm-transformer'
+        desc = 'Realm for Android'
+        websiteUrl = 'http://realm.io'
+        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
+        vcsUrl = 'https://github.com/realm/realm-java.git'
+        licenses = ['Apache-2.0']
+        labels = ['android', 'realm']
+        publicDownloadNumbers = false
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+        }
+        defaults {
+            publications ('realmPublication')
+        }
+    }
+}
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..e8c6bf7bb4
Binary files /dev/null and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
similarity index 52%
rename from distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.properties
rename to realm-transformer/gradle/wrapper/gradle-wrapper.properties
index 0c44860eea..587246a1a4 100644
--- a/distribution/RealmEncryptionExample/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Apr 10 15:27:10 PDT 2013
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/distribution/RealmEncryptionExample/gradlew b/realm-transformer/gradlew
similarity index 96%
rename from distribution/RealmEncryptionExample/gradlew
rename to realm-transformer/gradlew
index 91a7e269e1..97fac783e1 100755
--- a/distribution/RealmEncryptionExample/gradlew
+++ b/realm-transformer/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/distribution/RealmGridViewExample/gradlew.bat b/realm-transformer/gradlew.bat
similarity index 96%
rename from distribution/RealmGridViewExample/gradlew.bat
rename to realm-transformer/gradlew.bat
index aec99730b4..8a0b282aa6 100644
--- a/distribution/RealmGridViewExample/gradlew.bat
+++ b/realm-transformer/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/realm-transformer/settings.gradle b/realm-transformer/settings.gradle
new file mode 100644
index 0000000000..dfae22fab0
--- /dev/null
+++ b/realm-transformer/settings.gradle
@@ -0,0 +1 @@
+rootProject.name = 'realm-transformer'
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
new file mode 100644
index 0000000000..595384997c
--- /dev/null
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+import javassist.*
+import javassist.expr.ExprEditor
+import javassist.expr.FieldAccess
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+/**
+ * This class encapsulates the bytecode manipulation code needed to transform model classes
+ * and the classes using them.
+ */
+class BytecodeModifier {
+
+    private static final Logger logger = LoggerFactory.getLogger('realm-logger')
+
+    /**
+     * Adds Realm specific accessors to a model class.
+     * All the declared fields will be associated with a getter and a setter.
+     *
+     * @param clazz the CtClass to add accessors to.
+     */
+    public static void addRealmAccessors(CtClass clazz) {
+        logger.info "  Realm: Adding accessors to ${clazz.simpleName}"
+        def methods = clazz.getDeclaredMethods()*.name
+        clazz.declaredFields.each { CtField field ->
+            if (!Modifier.isStatic(field.getModifiers())) {
+                if (!methods.contains("realmGet\$${field.name}")) {
+                    clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
+                }
+                if (!methods.contains("realmSet\$${field.name}")) {
+                    clazz.addMethod(CtNewMethod.setter("realmSet\$${field.name}", field))
+                }
+            }
+        }
+    }
+
+    /**
+     * Modifies a class replacing field accesses with the appropriate Realm accessors.
+     *
+     * @param clazz The CtClass to modify
+     * @param managedFields List of fields whose access should be replaced
+     */
+    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields, List<CtClass> modelClasses) {
+        clazz.getDeclaredBehaviors().each { behavior ->
+            logger.info "    Behavior: ${behavior.name}"
+            if (
+                (
+                    behavior instanceof CtMethod &&
+                    !behavior.name.startsWith('realmGet$') &&
+                    !behavior.name.startsWith('realmSet$')
+                ) || (
+                    behavior instanceof CtConstructor &&
+                    !modelClasses.contains(clazz)
+                )
+            ) {
+                behavior.instrument(new FieldAccessToAccessorConverter(managedFields, clazz, behavior))
+            }
+        }
+    }
+
+    /**
+     * Modifies a class adding its RealmProxy interface.
+     *
+     * @param clazz The CtClass to modify
+     * @param classPool the Javassist class pool
+     */
+    public static void addRealmProxyInterface(CtClass clazz, ClassPool classPool) {
+        def proxyInterface = classPool.get("io.realm.${clazz.getSimpleName()}RealmProxyInterface")
+        clazz.addInterface(proxyInterface)
+    }
+
+    /**
+     * This class goes through all the field access behaviours of a class and replaces field accesses with
+     * the appropriate accessor.
+     */
+    private static class FieldAccessToAccessorConverter extends ExprEditor {
+        final List<CtField> managedFields
+        final CtClass ctClass
+        final CtBehavior behavior
+
+        FieldAccessToAccessorConverter(List<CtField> managedFields, CtClass ctClass, CtBehavior behavior) {
+            this.managedFields = managedFields
+            this.ctClass = ctClass
+            this.behavior = behavior
+        }
+
+        @Override
+        void edit(FieldAccess fieldAccess) throws CannotCompileException {
+            logger.info "      Field being accessed: ${fieldAccess.className}.${fieldAccess.fieldName}"
+            def isRealmFieldAccess = managedFields.find {
+                fieldAccess.className.equals(it.declaringClass.name) && fieldAccess.fieldName.equals(it.name)
+            }
+            if (isRealmFieldAccess != null) {
+                logger.info "        Realm: Manipulating ${ctClass.simpleName}.${behavior.name}(): ${fieldAccess.fieldName}"
+                logger.info "        Methods: ${ctClass.declaredMethods}"
+                def fieldName = fieldAccess.fieldName
+                if (fieldAccess.isReader()) {
+                    fieldAccess.replace('$_ = $0.realmGet$' + fieldName + '();')
+                } else if (fieldAccess.isWriter()) {
+                    fieldAccess.replace('$0.realmSet$' + fieldName + '($1);')
+                }
+            }
+        }
+    }
+
+    /**
+     * Adds a method to indicate that Realm transformer has been applied.
+     *
+     * @param clazz The CtClass to modify.
+     */
+    public static void overrideTransformedMarker(CtClass clazz) {
+        logger.info "  Realm: Marking as transformed ${clazz.simpleName}"
+        try {
+            clazz.getDeclaredMethod("transformerApplied", new CtClass[0])
+        } catch (NotFoundException ignored) {
+            clazz.addMethod(CtNewMethod.make(Modifier.PUBLIC, CtClass.booleanType, "transformerApplied",
+                    new CtClass[0], new CtClass[0], "{return true;}", clazz))
+        }
+    }
+}
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
new file mode 100644
index 0000000000..566924de68
--- /dev/null
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import com.android.SdkConstants
+import com.android.build.api.transform.*
+import com.google.common.collect.ImmutableSet
+import com.google.common.collect.Sets
+import com.google.common.io.Files
+import groovy.io.FileType
+import io.realm.annotations.Ignore
+import javassist.ClassPool
+import javassist.LoaderClassPath
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+
+import java.lang.reflect.Modifier
+import java.util.jar.JarFile
+import java.util.regex.Pattern
+
+import static com.android.build.api.transform.QualifiedContent.*
+
+/**
+ * This class implements the Transform API provided by the Android Gradle plugin.
+ */
+@SuppressWarnings("GroovyUnusedDeclaration")
+class RealmTransformer extends Transform {
+
+    private Logger logger = LoggerFactory.getLogger('realm-logger')
+
+    @Override
+    String getName() {
+        return "RealmTransformer"
+    }
+
+    @Override
+    Set<ContentType> getInputTypes() {
+        return ImmutableSet.<ContentType> of(DefaultContentType.CLASSES)
+    }
+
+    @Override
+    Set<Scope> getScopes() {
+        return Sets.immutableEnumSet(Scope.PROJECT)
+    }
+
+    @Override
+    Set<Scope> getReferencedScopes() {
+        return Sets.immutableEnumSet(Scope.EXTERNAL_LIBRARIES, Scope.PROJECT_LOCAL_DEPS,
+                Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.TESTED_CODE)
+    }
+
+    @Override
+    boolean isIncremental() {
+        return false
+    }
+
+    @Override
+    void transform(Context context, Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs,
+                   TransformOutputProvider outputProvider, boolean isIncremental)
+            throws IOException, TransformException, InterruptedException {
+
+        def tic = System.currentTimeMillis()
+
+        // Find all the class names
+        def inputClassNames = getClassNames(inputs)
+        def referencedClassNames = getClassNames(referencedInputs)
+        def allClassNames = merge(inputClassNames, referencedClassNames);
+
+        // Create and populate the Javassist class pool
+        ClassPool classPool = createClassPool(inputs, referencedInputs)
+
+        logger.info "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
+
+        // mark as transformed
+        def baseProxyMediator = classPool.get('io.realm.internal.RealmProxyMediator')
+        def mediatorPattern = Pattern.compile('^io\\.realm\\.[^.]+Mediator$')
+        def proxyMediatorClasses = inputClassNames
+                .findAll { it.matches(mediatorPattern) }
+                .collect { classPool.getCtClass(it) }
+                .findAll { it.superclass?.equals(baseProxyMediator) }
+        logger.info "Proxy Mediator Classes: ${proxyMediatorClasses*.name}"
+        proxyMediatorClasses.each {
+            BytecodeModifier.overrideTransformedMarker(it);
+        }
+
+        // Find the model classes
+        def realmObject = classPool.get('io.realm.RealmObject')
+        def allModelClasses = allClassNames
+                .findAll { it.endsWith('RealmProxy') }
+                .collect { classPool.getCtClass(it).superclass }
+                .findAll { it.superclass?.equals(realmObject) }
+        def inputModelClasses = allModelClasses.findAll {
+            inputClassNames.contains(it.name)
+        }
+        logger.info "Model Classes: ${allModelClasses*.name}"
+
+        // Populate a list of the fields that need to be managed with bytecode manipulation
+        def allManagedFields = []
+        allModelClasses.each {
+            allManagedFields.addAll(it.declaredFields.findAll {
+                it.getAnnotations()
+                it.getAnnotation(Ignore.class) == null && !Modifier.isStatic(it.getModifiers())
+            })
+        }
+        logger.info "Managed Fields: ${allManagedFields*.name}"
+
+        // Add accessors to the model classes in the target project
+        inputModelClasses.each {
+            BytecodeModifier.addRealmAccessors(it)
+            BytecodeModifier.addRealmProxyInterface(it, classPool)
+        }
+
+        // Use accessors instead of direct field access
+        inputClassNames.each {
+            logger.info "  Modifying class ${it}"
+            def ctClass = classPool.getCtClass(it)
+            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields, allModelClasses)
+            ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
+        }
+
+        copyResourceFiles(inputs, outputProvider)
+
+        def toc = System.currentTimeMillis()
+        logger.info "Realm Transform time: ${toc-tic} milliseconds"
+    }
+
+    /**
+     * Creates and populates the Javassist class pool.
+     *
+     * @param inputs the inputs provided by the Transform API
+     * @param referencedInputs the referencedInputs provided by the Transform API
+     * @return the populated ClassPool instance
+     */
+    private ClassPool createClassPool(Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs) {
+        // Don't use ClassPool.getDefault(). Doing consecutive builds in the same run (e.g. debug+release)
+        // will use a cached object and all the classes will be frozen.
+        ClassPool classPool = new ClassPool(null)
+        classPool.appendSystemPath()
+        classPool.appendClassPath(new LoaderClassPath(getClass().getClassLoader()))
+
+        inputs.each {
+            it.directoryInputs.each {
+                classPool.appendClassPath(it.file.absolutePath)
+            }
+
+            it.jarInputs.each {
+                classPool.appendClassPath(it.file.absolutePath)
+            }
+        }
+
+        referencedInputs.each {
+            it.directoryInputs.each {
+                classPool.appendClassPath(it.file.absolutePath)
+            }
+
+            it.jarInputs.each {
+                classPool.appendClassPath(it.file.absolutePath)
+            }
+        }
+
+        return classPool
+    }
+
+    private static Set<String> getClassNames(Collection<TransformInput> inputs) {
+        Set<String> classNames = new HashSet<String>()
+
+        inputs.each {
+            it.directoryInputs.each {
+                def dirPath = it.file.absolutePath
+                it.file.eachFileRecurse(FileType.FILES) {
+                    if (it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
+                        def className =
+                                it.absolutePath.substring(
+                                        dirPath.length() + 1,
+                                        it.absolutePath.length() - SdkConstants.DOT_CLASS.length()
+                                ).replace(File.separatorChar, '.' as char)
+                        classNames.add(className)
+                    }
+                }
+            }
+
+            it.jarInputs.each {
+                def jarFile = new JarFile(it.file)
+                jarFile.entries().findAll {
+                    !it.directory && it.name.endsWith(SdkConstants.DOT_CLASS)
+                }.each {
+                    def path = it.name
+                    def className = path.substring(0, path.length() - SdkConstants.DOT_CLASS.length())
+                            .replace(File.separatorChar, '.' as char)
+                    classNames.add(className)
+                }
+            }
+        }
+        return classNames
+    }
+
+    private copyResourceFiles(Collection<TransformInput> inputs, TransformOutputProvider outputProvider) {
+        inputs.each {
+            it.directoryInputs.each {
+                def dirPath = it.file.absolutePath
+                it.file.eachFileRecurse(FileType.FILES) {
+                    if (!it.absolutePath.endsWith(SdkConstants.DOT_CLASS)) {
+                        logger.info "  Copying resource ${it}"
+                        def dest = new File(getOutputFile(outputProvider),
+                                it.absolutePath.substring(dirPath.length()))
+                        dest.parentFile.mkdirs()
+                        Files.copy(it, dest)
+                    }
+                }
+            }
+
+            // no need to implement the code for `it.jarInputs.each` since PROJECT SCOPE does not use jar input.
+        }
+    }
+
+    private File getOutputFile(TransformOutputProvider outputProvider) {
+        return outputProvider.getContentLocation(
+                'realm', getInputTypes(), getScopes(), Format.DIRECTORY)
+    }
+
+    private static Set<String> merge(Set<String> set1, Set<String> set2) {
+        Set<String> merged = new HashSet<String>()
+        merged.addAll(set1)
+        merged.addAll(set2)
+        return merged;
+    }
+}
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
new file mode 100644
index 0000000000..db9508ca4b
--- /dev/null
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import javassist.ClassPool
+import javassist.CtClass
+import javassist.CtField
+import javassist.CtNewMethod
+import javassist.bytecode.CodeIterator
+import javassist.bytecode.Opcode
+import spock.lang.Specification
+
+import java.lang.reflect.Modifier
+
+class BytecodeModifierTest extends Specification {
+    def "AddRealmAccessors"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        when: 'the accessors are added'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        then: 'the accessors are generated'
+        def ctMethods = ctClass.getDeclaredMethods()
+        def methodNames = ctMethods.name
+        methodNames.contains('realmGet$age')
+        methodNames.contains('realmSet$age')
+
+        and: 'the accessors are public'
+        ctMethods.each {
+            it.getModifiers() == Modifier.PUBLIC
+        }
+    }
+
+    def "UseRealmAccessors"() {
+        setup: 'generate an empty class'
+        def classPool = ClassPool.getDefault()
+        def ctClass = classPool.makeClass('testClass')
+
+        and: 'add a field'
+        def ctField = new CtField(CtClass.intType, 'age', ctClass)
+        ctClass.addField(ctField)
+
+        and: 'add a method that uses such field'
+        def ctMethod = CtNewMethod.make('public boolean canDrive() { return this.age >= 18; }', ctClass)
+        ctClass.addMethod(ctMethod)
+
+        and: 'realm accessors are added'
+        BytecodeModifier.addRealmAccessors(ctClass)
+
+        when: 'the field use is replaced by the accessor'
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+
+        then: 'the field is not used in the method anymore'
+        def methodInfo = ctMethod.getMethodInfo()
+        def codeAttribute = methodInfo.getCodeAttribute()
+        def fieldIsUsed = false
+        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
+            int index = ci.next();
+            int op = ci.byteAt(index);
+            if (op == Opcode.GETFIELD) {
+                fieldIsUsed = true
+            }
+        }
+        !fieldIsUsed
+    }
+}
diff --git a/realm.properties b/realm.properties
new file mode 100644
index 0000000000..60d64cf12c
--- /dev/null
+++ b/realm.properties
@@ -0,0 +1,2 @@
+gradleVersion=2.7
+ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index ba1b1d9d95..7426dc5df9 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,298 +1,38 @@
-apply plugin: 'com.android.library'
-apply plugin: 'com.neenbedankt.android-apt'
-apply plugin: 'maven-publish'
-apply plugin: 'com.jfrog.bintray'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion '20.0.0'
-
-    defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 20
-    }
-
-// TODO: re-enable once bug-fix is released
-//    jacoco {
-//        version = '0.7.2.201409121644'
-//    }
-//
-//    buildTypes {
-//        debug {
-//            testCoverageEnabled true
-//        }
-//    }
-
-}
-
-dependencies {
-    compile 'com.intellij:annotations:+@jar'
-    compile files("../realm-annotations/build/libs/realm-annotations-${version}.jar")
-    androidTestApt files("../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    androidTestApt files("../realm-annotations/build/libs/realm-annotations-${version}.jar")
-}
-
-android.libraryVariants.all { variant ->
-    def name = variant.buildType.name
-
-    if (name.equalsIgnoreCase("debug")) {
-        return; // Skip debug builds.
-    }
-
-    def javadocTask = task("javadoc${variant.name.capitalize()}", type: Javadoc) {
-        description "Generates Javadoc for $variant.name."
-        group 'Docs'
-        source = variant.javaCompile.source
-        source "../realm-annotations/src/main/java"
-        ext.androidJar = files(project.android.getBootClasspath())
-        classpath = files(variant.javaCompile.classpath.files) + ext.androidJar
-        exclude '**/internal/**'
-        exclude '**/BuildConfig.java'
-        exclude '**/R.java'
-    }
-
-    task("bundleJavadoc${variant.name.capitalize()}", type: Jar) {
-        description "Bundles Javadoc into zip for $variant.name."
-        group 'Docs'
-        classifier = "javadoc"
-        from javadocTask
-    }
-}
-
-task androidJar(type: Jar, dependsOn: ['assemble']) {
-    group 'Build'
-    description 'Generates a jar file containing Realm and its annotation processor'
-    from zipTree('build/intermediates/bundles/release/classes.jar')
-    from zipTree("../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    from zipTree("../realm-annotations/build/libs/realm-annotations-${version}.jar")
-    from(file('src/main/jniLibs')) {
-        into 'lib'
-    }
-}
-
-task androidSourcesJar(type: Jar) {
-    from android.sourceSets.main.java.srcDirs
-}
-
-artifacts {
-    archives file("build/libs/realm-${version}.jar")
-    archives androidSourcesJar
-}
-
-publishing {
-    publications {
-        mavenAndroid(MavenPublication) {
-            groupId 'io.realm'
-            artifactId 'realm-android'
-            version version
-            artifact androidJar
-            artifact androidSourcesJar {
-                classifier "sources"
-            }
-            pom.withXml {
-                Node root = asNode()
-                root.appendNode('name', 'realm-android')
-                root.appendNode('description', 'Realm is a mobile database: a replacement for SQLite & ORMs.')
-                root.appendNode('url', 'http://realm.io')
-
-                def issues = root.appendNode('issueManagement')
-                issues.appendNode('system', 'github')
-                issues.appendNode('url', 'https://github.com/realm/realm-java/issues')
-
-                def scm = root.appendNode('scm')
-                scm.appendNode('url', 'scm:https://github.com/realm/realm-java')
-                scm.appendNode('connection', 'scm:git@github.com:realm/realm-java.git')
-                scm.appendNode('developerConnection', 'scm:git@github.com:realm/realm-java.git')
-
-                def license = root.appendNode('licenses').appendNode('license')
-                license.appendNode('name', 'The Apache Software License, Version 2.0')
-                license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
-                license.appendNode('distribution', 'repo')
-            }
-        }
-    }
-}
-
-if (version.endsWith('-SNAPSHOT')) { // Only publish if it's a snapshot version
-    publishing {
-        repositories {
-            maven {
-                url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
-                credentials {
-                    // user and password come from the gradle.properties file in ~/.gradle
-                    username project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
-                    password project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
-                }
-            }
-        }
-    }
-} else {
-    bintray {
-        // user and key come from the gradle.properties file in ~/.gradle
-        user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
-        key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
-        publications = ['mavenAndroid']
-        publish = true
-        pkg {
-            repo = 'maven'
-            name = 'realm-android'
-            licenses = ['Apache-2.0']
-        }
-    }
-}
-
-task buildApt(type: GradleBuild) {
-    dir = file('../realm-annotations-processor')
-    tasks = ['shadowJar']
-}
-
-task compileJni(type: GradleBuild) {
-    dir = file('../realm-jni')
-    tasks = ['buildAndroidJni']
-}
-
-task compileAnnotations(type: GradleBuild) {
-    dir = file('../realm-annotations')
-    tasks = ['assemble']
-}
-
-project.afterEvaluate {
-    preBuild.dependsOn(['compileJni', 'compileAnnotations', 'buildApt'])
-}
-
-def examples = [
-    introExample: "RealmIntroExample",
-    gridViewExample: "RealmGridViewExample",
-    migrationExample: "RealmMigrationExample",
-    adapterExample: "RealmAdapterExample",
-    threadExample: "RealmThreadExample",
-    jsonExample: "RealmJsonExample",
-    encryptionExample: "RealmEncryptionExample"
-]
-
-def abi = [ 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86' ]
-
-//for Ant filter
-import org.apache.tools.ant.filters.ReplaceTokens
-
-task generateDistributionExamplesBuildFiles << {
-    examples.each() { src, dest ->
-        copy {
-            from "${rootDir}/tools/templates/${dest}/build.gradle"
-            into "${rootDir}/distribution/${dest}/app"
-            filter(ReplaceTokens, tokens: [version: version])
-        }
-    }
-}
-
-task populateDistributionFolder(dependsOn: ['androidJar', 'bundleJavadocRelease']) << {
-    copy {
-        from '../changelog.txt'
-        from "build/libs/realm-${version}.jar"
-        from "build/libs/realm-${version}-javadoc.jar"
-        into '../distribution'
-    }
-    copy {
-        from 'build/docs/javadoc'
-        into '../distribution/javadoc'
-    }
-    examples.each() { src, dest ->
-        copy {
-            from "../examples/${src}/src"
-            into "../distribution/${dest}/app/src"
-        }
-    }
-}
-
-task copyLibrariesToEclipseFolder(dependsOn: 'androidJar') << {
-    copy {
-        from zipTree("build/libs/realm-${version}.jar")
-        into 'build/intermediates/eclipse'
-    }
-    abi.each() { abiName ->
-        copy {
-            from "build/intermediates/eclipse/lib/${abiName}/librealm-jni.so"
-            into "../distribution/eclipse/${abiName}"
-        }
+buildscript {
+    repositories {
+        mavenLocal()
+        jcenter()
     }
-}
 
-task createEclipseJar(type: Zip) {
-    dependsOn 'copyLibrariesToEclipseFolder'
-    from 'build/intermediates/eclipse'
-    exclude 'lib'
-    destinationDir = new File("${rootDir}/distribution/eclipse")
-    archiveName = "realm-${version}.jar"
-}
-
-task createDistributionFolder() {
-    dependsOn 'generateDistributionExamplesBuildFiles'
-    dependsOn 'populateDistributionFolder'
-    dependsOn 'createEclipseJar'
-}
-
-task createDistributionPackage(type: Zip) {
-    group 'Release'
-    description 'Build the release distribution package'
-    dependsOn 'createDistributionFolder'
-    from "${rootDir}/distribution"
-    into "realm-java-${version}"
-    destinationDir = new File("${rootDir}")
-    archiveName = "realm-java-${version}.zip"
-}
-
-examples.each() { src, dest ->
-    task "distributionMonkey${dest}"(type: GradleBuild) {
-        dependsOn createDistributionPackage
-        //dependsOn bintrayUpload
-        dir = file("${rootDir}/distribution/${dest}")
-        tasks = ['monkeyRelease']
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.5.0'
+        classpath 'de.undercouch:gradle-download-task:2.0.0'
+        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
+        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
+        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.0.1'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
     }
 }
 
-apply plugin: 's3'
-
-import com.github.skhatri.s3aws.plugin.S3UploadTask
-
-// This is an ugly hack because we have two links to the latest version.
-// The right solution here would be to contribute a change to the S3 Gradle plugin
-// to allow link to be a list of strings.
-['java', 'android'].each() { link ->
-    task "upload${link.capitalize()}DistributionPackage"(type: S3UploadTask) {
-        examples.each { src, dest ->
-            dependsOn "distributionMonkey${dest}"
-        }
-        bucket = 'static.realm.io'
-        file = "${rootDir}/realm-java-${version}.zip"
-        key = 'downloads/java/realm-java-${version}.zip'
-        link = "downloads/${link}/latest"
+allprojects {
+    def props = new Properties()
+    props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.each { key, val ->
+        project.set(key, val)
     }
-}
 
-task uploadUpdateVersion(type: S3UploadTask) {
-    ['java', 'android'].each() { link ->
-        dependsOn "upload${link.capitalize()}DistributionPackage"
+    group = 'io.realm'
+    version = file("${rootDir}/../version.txt").text.trim();
+    repositories {
+        mavenLocal()
+        jcenter()
     }
-    bucket = 'static.realm.io'
-    file = "${rootDir}/version.txt"
-    key = 'update/java'
-    link = 'downloads/temp/update-java'
-}
-
-task tagRepo(type: Exec) {
-    dependsOn uploadUpdateVersion
-    workingDir rootDir
-    commandLine 'git', 'tag', '-a', "v${version}", '-m', "v${version}"
-}
-
-task pushTag(type: Exec) {
-    dependsOn tagRepo
-    workingDir rootDir
-    commandLine 'git', 'push', '--tags'
 }
 
-task release {
-    group 'Release'
-    description 'Release realm-java'
-    dependsOn pushTag
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
 }
diff --git a/realm/config/checkstyle/checkstyle-suppressions.xml b/realm/config/checkstyle/checkstyle-suppressions.xml
new file mode 100644
index 0000000000..6e71089d31
--- /dev/null
+++ b/realm/config/checkstyle/checkstyle-suppressions.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0"?>
+<!DOCTYPE suppressions PUBLIC
+    "-//Puppy Crawl//DTD Suppressions 1.1//EN"
+    "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
+<suppressions>
+    <suppress checks="[a-zA-Z0-9]*" files="R\.java" />
+    <suppress checks="." files="BuildConfig.java" />
+    <suppress checks="." files=".*\.properties" />
+    <suppress checks="FileLength" files="RealmTests.java" />
+    <suppress checks="FileLengthCheck" files="Realm.java|RealmAsyncQueryTests.java|RealmQuery.java|RealmQueryTests.java"/>
+</suppressions>
diff --git a/realm/config/checkstyle/checkstyle.xml b/realm/config/checkstyle/checkstyle.xml
new file mode 100644
index 0000000000..b3903724c8
--- /dev/null
+++ b/realm/config/checkstyle/checkstyle.xml
@@ -0,0 +1,154 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <!-- There are non-ascii test cases -->
+    <property name="charset" value="UTF-8"/>
+    <!-- Files to ignore -->
+    <module name="SuppressionFilter">
+        <property name="file" value="${proj.module.dir}/../config/checkstyle/checkstyle-suppressions.xml"/>
+    </module>
+
+    <module name="NewlineAtEndOfFile">
+        <property name="lineSeparator" value="lf"/>
+    </module>
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <!-- TODO: UNCOMMENT
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module> -->
+
+    <!-- Space after 'for', 'if', 'while', 'try' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if|while|try)[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="bin/cachefile"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <!-- TODO: UNCOMMENT
+        <module name="JavadocStyle"/> -->
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!-- TODO: UNCOMMENT
+        <module name="ConstantName"/>
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/> -->
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <!--<module name="AvoidStarImport"/>-->
+        <!--<module name="IllegalImport"/>--> <!-- defaults to sun.* packages -->
+        <!--<module name="RedundantImport"/>-->
+        <!--<module name="UnusedImports"/>-->
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <!-- TODO: UNCOMMENT
+        <module name="LineLength">
+            <property name="max" value="120"/>
+            <property name="severity" value="warning"/>
+        </module> -->
+        <!--<module name="MethodLength"/>-->
+        <!--<module name="ParameterNumber"/>-->
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <!-- TODO: UNCOMMENT
+        <module name="GenericWhitespace"/>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/> -->
+        <module name="WhitespaceAround">
+            <property name="tokens" value="LITERAL_DO"/>
+        </module>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!-- TODO: UNCOMMENT
+        <module name="ModifierOrder"/>
+        <module name="RedundantModifier"/> -->
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <!-- <module name="AvoidNestedBlocks"/> -->
+        <!--module name="EmptyBlock"/-->
+        <!-- <module name="LeftCurly"/> -->
+        <!--module name="NeedBraces"/-->
+        <!-- <module name="RightCurly"/> -->
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <!-- TODO: UNCOMMENT
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <module name="EqualsAvoidNull"/>
+        <module name="EqualsHashCode"/>
+        <module name="HiddenField"/>
+        <module name="IllegalInstantiation"/>
+        <module name="InnerAssignment"/>
+        <module name="MagicNumber">
+            <property name="severity" value="warning"/>
+        </module>
+        <module name="MissingSwitchDefault"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/> -->
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!-- TODO: UNCOMMENT
+        <module name="FinalClass">
+            <property name="severity" value="warning"/>
+        </module>
+        <module name="HideUtilityClassConstructor"/>
+        <module name="InterfaceIsType"/> -->
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <!-- TODO: UNCOMMENT <module name="ArrayTypeStyle"/> -->
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <!-- TODO: UNCOMMENT <module name="UpperEll"/> -->
+    </module>
+</module>
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
new file mode 100644
index 0000000000..071ca3c6c6
--- /dev/null
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<FindBugsFilter>
+    <Match>
+        <!-- ignore all issues in resource generation -->
+        <Class name="~.*\.R\$.*"/>
+    </Match>
+    <Match>
+        <Class name="~.*\.Manifest\$.*"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.ImplicitTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.ReadTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.WriteTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.Realm" />
+        <Method name="checkHasPrimaryKey" />
+        <Bug pattern="UPM_UNCALLED_PRIVATE_METHOD" />
+    </Match>
+    <Match>
+        <Class name="io.realm.RealmBaseAdapter" />
+        <Field name="context" />
+        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
+    </Match>
+    <Match>
+        <Class name="io.realm.RealmBaseAdapter" />
+        <Field name="inflater" />
+        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.RealmObjectProxy$CacheData" />
+        <Field name="minDepth" />
+        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
+    </Match>
+
+    <!-- Unit tests -->
+    <Match>
+        <Class name="io.realm.RealmTests" />
+        <Method name="getInstance_writeProtectedDir" />
+        <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />
+    </Match>
+    <Match>
+        <Class name="io.realm.RealmTests" />
+        <Class name="~.*Tests?$"/>
+        <Bug pattern="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS"/>
+    </Match>
+    <Match>
+        <Class name="~.*Tests?$"/>
+        <Bug pattern="DM_GC"/>
+    </Match>
+
+</FindBugsFilter>
diff --git a/realm/config/pmd/ruleset.xml b/realm/config/pmd/ruleset.xml
new file mode 100644
index 0000000000..a3596aa24e
--- /dev/null
+++ b/realm/config/pmd/ruleset.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0"?>
+<ruleset name="RealmRuleset"
+         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
+
+    <description>
+        Realm PMD ruleset
+    </description>
+
+    <rule ref="rulesets/java/basic.xml">
+        <exclude name="UselessParentheses"/>
+    </rule>
+
+    <rule ref="rulesets/java/android.xml"/>
+
+</ruleset>
\ No newline at end of file
diff --git a/realm/gradle.properties b/realm/gradle.properties
new file mode 100644
index 0000000000..7d70fda02c
--- /dev/null
+++ b/realm/gradle.properties
@@ -0,0 +1 @@
+org.gradle.jvmargs=-Xms256m -Xmx1024m
\ No newline at end of file
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..e8c6bf7bb4
Binary files /dev/null and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
similarity index 52%
rename from distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.properties
rename to realm/gradle/wrapper/gradle-wrapper.properties
index 0c44860eea..587246a1a4 100644
--- a/distribution/RealmGridViewExample/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Apr 10 15:27:10 PDT 2013
+#Tue Jan 05 14:18:17 CET 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/distribution/RealmGridViewExample/gradlew b/realm/gradlew
similarity index 96%
rename from distribution/RealmGridViewExample/gradlew
rename to realm/gradlew
index 91a7e269e1..97fac783e1 100755
--- a/distribution/RealmGridViewExample/gradlew
+++ b/realm/gradlew
@@ -42,11 +42,6 @@ case "`uname`" in
     ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
 # Attempt to set APP_HOME
 # Resolve links: $0 may be a link
 PRG="$0"
@@ -114,6 +109,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
diff --git a/distribution/RealmEncryptionExample/gradlew.bat b/realm/gradlew.bat
similarity index 100%
rename from distribution/RealmEncryptionExample/gradlew.bat
rename to realm/gradlew.bat
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
new file mode 100644
index 0000000000..4f2b60bc50
--- /dev/null
+++ b/realm/realm-annotations-processor/build.gradle
@@ -0,0 +1,112 @@
+apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'com.jfrog.bintray'
+
+sourceCompatibility = '1.6'
+targetCompatibility = '1.6'
+
+dependencies {
+    compile group:'com.squareup', name:'javawriter', version:'2.5.0'
+    compile "io.realm:realm-annotations:${version}"
+
+    testCompile files('../realm-library/build/intermediates/bundles/release/classes.jar') // Java projects cannot depend on AAR files
+    testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
+    testCompile group:'junit', name:'junit', version:'4.11'
+    testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-21/android.jar"))
+}
+
+// for Ant filter
+import org.apache.tools.ant.filters.ReplaceTokens
+
+task generateVersionClass(type: Copy) {
+    from 'src/main/templates/Version.java'
+    into 'build/generated-src/main/java/io/realm/processor'
+    filter(ReplaceTokens, tokens: [version: version])
+    outputs.upToDateWhen { false }
+}
+
+// Include the generated Version file
+sourceSets {
+    main {
+        java {
+            srcDir 'build/generated-src/main/java'
+        }
+    }
+}
+
+compileJava.dependsOn generateVersionClass
+compileTestJava.dependsOn ':realm-library:assemble'
+
+def commonPom = {
+    licenses {
+        license {
+            name 'The Apache Software License, Version 2.0'
+            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+            distribution 'repo'
+        }
+    }
+    issueManagement {
+        system 'github'
+        url 'https://github.com/realm/realm-java/issues'
+    }
+    scm {
+        url 'scm:https://github.com/realm/realm-java'
+        connection 'scm:git@github.com:realm/realm-java.git'
+        developerConnection 'scm:git@github.com:realm/realm-java.git'
+    }
+}
+
+publishing {
+    publications {
+        realmPublication(MavenPublication) {
+            groupId 'io.realm'
+            artifactId = 'realm-annotations-processor'
+            from components.java
+            pom.withXml {
+                Node root = asNode()
+                root.appendNode('name', 'realm-gradle-plugin')
+                root.appendNode('description', 'Annotation Processor for Realm. Realm is a mobile database: a replacement for SQLite & ORMs')
+                root.appendNode('url', 'http://realm.io')
+                root.children().last() + commonPom
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+
+    dryRun = false
+    publish = false
+
+    publications = ['realmPublication']
+    pkg {
+        repo = 'maven'
+        name = 'realm-annotations-processor'
+        desc = 'Realm for Android'
+        websiteUrl = 'http://realm.io'
+        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
+        vcsUrl = 'https://github.com/realm/realm-java.git'
+        licenses = ['Apache-2.0']
+        labels = ['android', 'realm']
+        publicDownloadNumbers = false
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+        }
+        defaults {
+            publications ('realmPublication')
+        }
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
new file mode 100644
index 0000000000..89820817c0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+
+/**
+ * Utility class for holding metadata for RealmProxy classes.
+ */
+public class ClassMetaData {
+
+    private final TypeElement classType; // Reference to model class.
+    private String className; // Model class simple name.
+    private String packageName; // package name for model class.
+    private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
+    private VariableElement primaryKey; // Reference to field used as primary key, if any.
+    private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
+    private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
+    private boolean containsToString;
+    private boolean containsEquals;
+    private boolean containsHashCode;
+
+    private final List<TypeMirror> validPrimaryKeyTypes;
+    private final Types typeUtils;
+
+    public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
+        this.classType = clazz;
+        this.className = clazz.getSimpleName().toString();
+        typeUtils = env.getTypeUtils();
+        TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
+        validPrimaryKeyTypes = Arrays.asList(
+                stringType,
+                typeUtils.getPrimitiveType(TypeKind.SHORT),
+                typeUtils.getPrimitiveType(TypeKind.INT),
+                typeUtils.getPrimitiveType(TypeKind.LONG),
+                typeUtils.getPrimitiveType(TypeKind.BYTE)
+        );
+
+        for (Element element : classType.getEnclosedElements()) {
+            if (element instanceof ExecutableElement) {
+                Name name = element.getSimpleName();
+                if (name.contentEquals("toString")) {
+                    this.containsToString = true;
+                } else if (name.contentEquals("equals")) {
+                    this.containsEquals = true;
+                } else if (name.contentEquals("hashCode")) {
+                    this.containsHashCode = true;
+                }
+            }
+        }
+    }
+
+    /**
+     * Build the meta data structures for this class. Any errors or messages will be
+     * posted on the provided Messager.
+     *
+     * @return True if meta data was correctly created and processing can continue, false otherwise.
+     */
+    public boolean generate() {
+
+        // Get the package of the class
+        Element enclosingElement = classType.getEnclosingElement();
+        if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
+            Utils.error("The RealmClass annotation does not support nested classes", classType);
+            return false;
+        }
+
+        TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
+        if (!parentElement.toString().endsWith(".RealmObject")) {
+            Utils.error("A RealmClass annotated object must be derived from RealmObject", classType);
+            return false;
+        }
+
+        PackageElement packageElement = (PackageElement) enclosingElement;
+        packageName = packageElement.getQualifiedName().toString();
+
+        if (!categorizeClassElements()) return false;
+        if (!checkListTypes()) return  false;
+        if (!checkDefaultConstructor()) return false;
+        if (!checkForFinalFields()) return false;
+        if (!checkForTransientFields()) return false;
+        if (!checkForVolatileFields()) return false;
+
+        return true; // Meta data was successfully generated
+    }
+
+    private boolean checkForTransientFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.TRANSIENT)) {
+                Utils.error("Transient fields are not allowed. Class: " + className + ", Field: " +
+                        field.getSimpleName().toString());
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private boolean checkForVolatileFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.VOLATILE)) {
+                Utils.error("Volatile fields are not allowed. Class: " + className + ", Field: " +
+                        field.getSimpleName().toString());
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private boolean checkForFinalFields() {
+        for (VariableElement field : fields) {
+            if (field.getModifiers().contains(Modifier.FINAL)) {
+                Utils.error("Final fields are not allowed. Class: " + className + ", Field: " +
+                        field.getSimpleName().toString());
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private boolean checkListTypes() {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmList(field)) {
+                if (Utils.getGenericType(field) == null) {
+                    Utils.error("No generic type supplied for field", field);
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    // Report if the default constructor is missing
+    private boolean checkDefaultConstructor() {
+        if (!hasDefaultConstructor) {
+            Utils.error("A default public constructor with no argument must be declared if a custom constructor is declared.");
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    // Iterate through all class elements and add them to the appropriate internal data structures.
+    // Returns true if all elements could be false if elements could not be categorized,
+    private boolean categorizeClassElements() {
+        for (Element element : classType.getEnclosedElements()) {
+            ElementKind elementKind = element.getKind();
+
+            if (elementKind.equals(ElementKind.FIELD)) {
+                VariableElement variableElement = (VariableElement) element;
+
+                Set<Modifier> modifiers = variableElement.getModifiers();
+                if (modifiers.contains(Modifier.STATIC)) {
+                    continue; // completely ignore any static fields
+                }
+
+                if (variableElement.getAnnotation(Ignore.class) != null) {
+                    continue;
+                }
+
+                if (variableElement.getAnnotation(Index.class) != null) {
+                    // The field has the @Index annotation. It's only valid for column types:
+                    // STRING, DATE, INTEGER, BOOLEAN
+                    String elementTypeCanonicalName = variableElement.asType().toString();
+                    String columnType = Constants.JAVA_TO_COLUMN_TYPES.get(elementTypeCanonicalName);
+                    if (columnType != null && (columnType.equals("RealmFieldType.STRING") ||
+                            columnType.equals("RealmFieldType.DATE") ||
+                            columnType.equals("RealmFieldType.INTEGER") ||
+                            columnType.equals("RealmFieldType.BOOLEAN"))) {
+                        indexedFields.add(variableElement);
+                    } else {
+                        Utils.error("@Index is not applicable to this field " + element + ".");
+                        return false;
+                    }
+                }
+
+                if (variableElement.getAnnotation(Required.class) == null) {
+                    // The field doesn't have the @Required annotation.
+                    // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
+                    // nullableFields.
+                    // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
+                    if (!Utils.isPrimitiveType(variableElement) && !Utils.isRealmList(variableElement)) {
+                        nullableFields.add(variableElement);
+                    }
+                } else {
+                    // The field has the @Required annotation
+                    if (Utils.isPrimitiveType(variableElement)) {
+                        Utils.error("@Required is not needed for field " + element +
+                                " with the type " + element.asType());
+                    } else if (Utils.isRealmList(variableElement)) {
+                        Utils.error("@Required is invalid for field " + element +
+                                " with the type " + element.asType());
+                    } else if (Utils.isRealmObject(variableElement)) {
+                        Utils.error("@Required is invalid for field " + element +
+                                " with the type " + element.asType());
+                    } else {
+                        // Should never get here - user should remove @Required
+                        if (nullableFields.contains(variableElement)) {
+                            Utils.error("Annotated field " + element + " with type " + element.asType() +
+                                    " has been added to the nullableFields before. Consider to remove @Required.");
+                        }
+                    }
+                }
+
+                if (variableElement.getAnnotation(PrimaryKey.class) != null) {
+                    // The field has the @PrimaryKey annotation. It is only valid for
+                    // String, short, int, long and must only be present one time
+                    if (primaryKey != null) {
+                        Utils.error(String.format("@PrimaryKey cannot be defined more than once. It was found here \"%s\" and here \"%s\"",
+                                primaryKey.getSimpleName().toString(),
+                                variableElement.getSimpleName().toString()));
+                        return false;
+                    }
+
+                    TypeMirror fieldType = variableElement.asType();
+                    if (!isValidPrimaryKeyType(fieldType)) {
+                        Utils.error("\"" + variableElement.getSimpleName().toString() + "\" is not allowed as primary key. See @PrimaryKey for allowed types.");
+                        return false;
+                    }
+
+                    primaryKey = variableElement;
+
+                    // Also add as index. All types of primary key can be indexed.
+                    if (!indexedFields.contains(variableElement)) {
+                        indexedFields.add(variableElement);
+                    }
+                }
+
+                fields.add(variableElement);
+            } else if (elementKind.equals(ElementKind.CONSTRUCTOR)) {
+                hasDefaultConstructor =  hasDefaultConstructor || Utils.isDefaultConstructor(element);
+
+            }
+        }
+
+        if (fields.size() == 0) {
+            Utils.error(className + " must contain at least 1 persistable field");
+        }
+
+        return true;
+    }
+
+    public String getSimpleClassName() {
+        return className;
+    }
+
+    /**
+     * Returns {@code true} if the class is considered to be a valid RealmObject class.
+     * RealmObject and Proxy classes also have the @RealmClass annotation but are not considered valid
+     * RealmObject classes.
+     */
+    public boolean isModelClass() {
+        String type = classType.toString();
+        if (type.equals("io.realm.dynamic.DynamicRealmObject")) {
+            return false;
+        }
+        return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+
+    public String getFullyQualifiedClassName() {
+        return packageName + "." + className;
+    }
+
+    public List<VariableElement> getFields() {
+        return fields;
+    }
+
+    public String getGetter(String fieldName) {
+        return "realmGet$" + fieldName;
+    }
+
+    public String getSetter(String fieldName) {
+        return "realmSet$" + fieldName;
+    }
+
+    public List<VariableElement> getIndexedFields() {
+        return indexedFields;
+    }
+
+    public boolean hasPrimaryKey() {
+        return primaryKey != null;
+    }
+
+    public VariableElement getPrimaryKey() {
+        return primaryKey;
+    }
+
+    public String getPrimaryKeyGetter() {
+        return getGetter(primaryKey.getSimpleName().toString());
+    }
+
+    public boolean isNullable(VariableElement variableElement) {
+        // primary keys cannot be nullable
+        if (hasPrimaryKey()) {
+            if (variableElement.equals(getPrimaryKey())) {
+                return false;
+            }
+        }
+        return nullableFields.contains(variableElement);
+    }
+
+    private boolean isValidPrimaryKeyType(TypeMirror type) {
+        for (TypeMirror validType : validPrimaryKeyTypes) {
+            if (typeUtils.isAssignable(type, validType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean containsToString() {
+        return containsToString;
+    }
+
+    public boolean containsEquals() {
+        return containsEquals;
+    }
+
+    public boolean containsHashCode() {
+        return containsHashCode;
+    }
+}
+
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
new file mode 100644
index 0000000000..8cb7ec6ea8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class Constants {
+    public static final String REALM_PACKAGE_NAME = "io.realm";
+    public static final String PROXY_SUFFIX = "RealmProxy";
+    public static final String INTERFACE_SUFFIX = "RealmProxyInterface";
+    public static final String INDENT = "    ";
+    public static final String TABLE_PREFIX = "class_";
+    public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
+    static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
+            "throw new IllegalArgumentException(\"Trying to set non-nullable field %s to null.\")";
+
+    static final Map<String, String> JAVA_TO_REALM_TYPES;
+    static {
+        JAVA_TO_REALM_TYPES = new HashMap<String, String>();
+        JAVA_TO_REALM_TYPES.put("byte", "Long");
+        JAVA_TO_REALM_TYPES.put("short", "Long");
+        JAVA_TO_REALM_TYPES.put("int", "Long");
+        JAVA_TO_REALM_TYPES.put("long", "Long");
+        JAVA_TO_REALM_TYPES.put("float", "Float");
+        JAVA_TO_REALM_TYPES.put("double", "Double");
+        JAVA_TO_REALM_TYPES.put("boolean", "Boolean");
+        JAVA_TO_REALM_TYPES.put("java.lang.Byte", "Long");
+        JAVA_TO_REALM_TYPES.put("java.lang.Short", "Long");
+        JAVA_TO_REALM_TYPES.put("java.lang.Integer", "Long");
+        JAVA_TO_REALM_TYPES.put("java.lang.Long", "Long");
+        JAVA_TO_REALM_TYPES.put("java.lang.Float", "Float");
+        JAVA_TO_REALM_TYPES.put("java.lang.Double", "Double");
+        JAVA_TO_REALM_TYPES.put("java.lang.Boolean", "Boolean");
+        JAVA_TO_REALM_TYPES.put("java.lang.String", "String");
+        JAVA_TO_REALM_TYPES.put("java.util.Date", "Date");
+        JAVA_TO_REALM_TYPES.put("byte[]", "BinaryByteArray");
+        // TODO: add support for char and Char
+    }
+
+    static final Map<String, String> JAVA_TO_COLUMN_TYPES;
+    static {
+        JAVA_TO_COLUMN_TYPES = new HashMap<String, String>();
+        JAVA_TO_COLUMN_TYPES.put("byte", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("short", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("int", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("long", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("float", "RealmFieldType.FLOAT");
+        JAVA_TO_COLUMN_TYPES.put("double", "RealmFieldType.DOUBLE");
+        JAVA_TO_COLUMN_TYPES.put("boolean", "RealmFieldType.BOOLEAN");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Byte", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Short", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Integer", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Long", "RealmFieldType.INTEGER");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Float", "RealmFieldType.FLOAT");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Double", "RealmFieldType.DOUBLE");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.Boolean", "RealmFieldType.BOOLEAN");
+        JAVA_TO_COLUMN_TYPES.put("java.lang.String", "RealmFieldType.STRING");
+        JAVA_TO_COLUMN_TYPES.put("java.util.Date", "RealmFieldType.DATE");
+        JAVA_TO_COLUMN_TYPES.put("byte[]", "RealmFieldType.BINARY");
+    }
+
+    static final Map<String, String> JAVA_TO_FIELD_SETTER;
+    static {
+        JAVA_TO_FIELD_SETTER = new HashMap<String, String>();
+        JAVA_TO_FIELD_SETTER.put("byte", "setByte");
+        JAVA_TO_FIELD_SETTER.put("short", "setShort");
+        JAVA_TO_FIELD_SETTER.put("int", "setInt");
+        JAVA_TO_FIELD_SETTER.put("long", "setLong");
+        JAVA_TO_FIELD_SETTER.put("float", "setFloat");
+        JAVA_TO_FIELD_SETTER.put("double", "setDouble");
+        JAVA_TO_FIELD_SETTER.put("boolean", "setBoolean");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Byte", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Short", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Integer", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Long", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Float", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Double", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.Boolean", "set");
+        JAVA_TO_FIELD_SETTER.put("java.lang.String", "set");
+        JAVA_TO_FIELD_SETTER.put("java.util.Date", "set");
+        JAVA_TO_FIELD_SETTER.put("byte[]", "set");
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
similarity index 96%
rename from realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
index 12f4ca38ad..7e546127d7 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
@@ -21,16 +21,14 @@
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.Collections;
-import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
-import io.realm.annotations.internal.RealmModule;
+import io.realm.annotations.RealmModule;
 
 /**
  * This class is responsible for creating the DefaultRealmModule that contains all known
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
similarity index 58%
rename from realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
index 91b09ec3f2..2433fc7b8d 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -16,19 +16,12 @@
 
 package io.realm.processor;
 
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+import io.realm.annotations.RealmModule;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-
-import io.realm.annotations.internal.RealmModule;
+import javax.lang.model.element.*;
+import java.util.*;
 
 /**
  * Utility class for holding metadata for the Realm modules.
@@ -39,7 +32,7 @@
     private final RoundEnvironment env;
     private Map<String, Set<ClassMetaData>> modules = new HashMap<String, Set<ClassMetaData>>();
     private Map<String, Set<ClassMetaData>> libraryModules = new HashMap<String, Set<ClassMetaData>>();
-    private Map<String, ClassMetaData> classMetaData = new HashMap<String, ClassMetaData>();
+    private Map<String, ClassMetaData> classMetaData = new HashMap<String, ClassMetaData>(); // <FullyQualifiedClassName, ClassMetaData>
     private boolean shouldCreateDefaultModule;
 
     public ModuleMetaData(RoundEnvironment env, Set<ClassMetaData> availableClasses) {
@@ -69,8 +62,8 @@ public boolean generate(ProcessingEnvironment processingEnv) {
 
             // Check that allClasses and classes are not set at the same time
             RealmModule module = classElement.getAnnotation(RealmModule.class);
-            Utils.note("Processing " + classSimpleName);
-            if (module.allClasses() && module.classes().length > 0) {
+            Utils.note("Processing module " + classSimpleName);
+            if (module.allClasses() && hasCustomClassList(classElement)) {
                 Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in " + classSimpleName);
                 return false;
             }
@@ -82,16 +75,12 @@ public boolean generate(ProcessingEnvironment processingEnv) {
                 classes = availableClasses;
             } else {
                 classes = new HashSet<ClassMetaData>();
-                for (Class<?> clazz : module.classes()) {
-                    if (!clazz.getSuperclass().toString().endsWith("RealmObject")) {
-                        Utils.error(clazz.getSimpleName() + " is not extending RealmObject. Only RealmObjects can be " +
-                                "part of a module.");
-                        return false;
-                    }
-                    ClassMetaData metadata = classMetaData.get(clazz.getName());
+                Set<String> classNames = getClassMetaDataFromModule(classElement);
+                for (String fullyQualifiedClassName : classNames) {
+                    ClassMetaData metadata = classMetaData.get(fullyQualifiedClassName);
                     if (metadata == null) {
-                        Utils.error(Utils.stripPackage(qualifiedName) + " could not be added to the module. It is not " +
-                                "possible to add classes which are part of another library.");
+                        Utils.error(Utils.stripPackage(fullyQualifiedClassName) + " could not be added to the module. " +
+                                "Only classes extending RealmObject, which are part of this project, can be added.");
                         return false;
                     }
                     classes.add(metadata);
@@ -122,6 +111,58 @@ public boolean generate(ProcessingEnvironment processingEnv) {
         return true;
     }
 
+    // Detour needed to access the class elements in the array
+    // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
+    private Set<String> getClassMetaDataFromModule(Element classElement) {
+        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
+        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
+        Set<String> classes = new HashSet<String>();
+        List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
+        for (AnnotationValue classMirror : moduleClasses) {
+            String fullyQualifiedClassName = classMirror.getValue().toString();
+            classes.add(fullyQualifiedClassName);
+        }
+        return classes;
+    }
+
+    // Work around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
+    // https://community.oracle.com/thread/1184190
+    private boolean hasCustomClassList(Element classElement) {
+        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
+        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
+        if (annotationValue == null) {
+            return false;
+        } else {
+            List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
+            return moduleClasses.size() > 0;
+        }
+    }
+
+    private AnnotationMirror getAnnotationMirror(Element classElement) {
+        AnnotationMirror annotationMirror = null;
+        for (AnnotationMirror am : classElement.getAnnotationMirrors()) {
+            if (am.getAnnotationType().toString().equals(RealmModule.class.getCanonicalName())) {
+                annotationMirror = am;
+                break;
+            }
+        }
+        return annotationMirror;
+    }
+
+    private AnnotationValue getAnnotationValue(AnnotationMirror annotationMirror) {
+        if (annotationMirror == null) {
+            return null;
+        }
+        AnnotationValue annotationValue = null;
+        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
+            if (entry.getKey().getSimpleName().toString().equals("classes")) {
+                annotationValue = entry.getValue();
+                break;
+            }
+        }
+        return annotationValue;
+    }
+
     /**
      * Returns all module classes and the RealmObjects they know of.
      */
@@ -133,7 +174,7 @@ public boolean generate(ProcessingEnvironment processingEnv) {
     }
 
     /**
-     * Returns true if the DefaultRealmModule.java file should be created.
+     * Returns {@code true} if the DefaultRealmModule.java file should be created.
      */
     public boolean shouldCreateDefaultModule() {
         return shouldCreateDefaultModule;
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
new file mode 100644
index 0000000000..866495ab02
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmAnalytics.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.net.URL;
+import java.security.NoSuchAlgorithmException;
+import java.util.Enumeration;
+import java.util.Set;
+
+// Asynchronously submits build information to Realm when the annotation
+// processor is running
+//
+// To be clear: this does *not* run when your app is in production or on
+// your end-user's devices; it will only run when you build your app from source.
+//
+// Why are we doing this? Because it helps us build a better product for you.
+// None of the data personally identifies you, your employer or your app, but it
+// *will* help us understand what Realm version you use, what host OS you use,
+// etc. Having this info will help with prioritizing our time, adding new
+// features and deprecating old features. Collecting an anonymized bundle &
+// anonymized MAC is the only way for us to count actual usage of the other
+// metrics accurately. If we don't have a way to deduplicate the info reported,
+// it will be useless, as a single developer building their app on Windows ten
+// times would report 10 times more than a single developer that only builds
+// once from Mac OS X, making the data all but useless. No one likes sharing
+// data unless it's necessary, we get it, and we've debated adding this for a
+// long long time. Since Realm is a free product without an email signup, we
+// feel this is a necessary step so we can collect relevant data to build a
+// better product for you.
+//
+// Currently the following information is reported:
+// - What version of Realm is being used
+// - What OS you are running on
+// - An anonymized MAC address and bundle ID to aggregate the other information on.
+public class RealmAnalytics {
+    private static RealmAnalytics instance;
+    private static final int READ_TIMEOUT = 2000;
+    private static final int CONNECT_TIMEOUT = 4000;
+    private static final String ADDRESS_PREFIX = "https://api.mixpanel.com/track/?data=";
+    private static final String ADDRESS_SUFFIX = "&ip=1";
+    private static final String TOKEN = "ce0fac19508f6c8f20066d345d360fd0";
+    private static final String EVENT_NAME = "Run";
+    private static final String JSON_TEMPLATE
+            = "{\n"
+            + "   \"event\": \"%EVENT%\",\n"
+            + "   \"properties\": {\n"
+            + "      \"token\": \"%TOKEN%\",\n"
+            + "      \"distinct_id\": \"%USER_ID%\",\n"
+            + "      \"Anonymized MAC Address\": \"%USER_ID%\",\n"
+            + "      \"Anonymized Bundle ID\": \"%APP_ID%\",\n"
+            + "      \"Binding\": \"java\",\n"
+            + "      \"Realm Version\": \"%REALM_VERSION%\",\n"
+            + "      \"Host OS Type\": \"%OS_TYPE%\",\n"
+            + "      \"Host OS Version\": \"%OS_VERSION%\",\n"
+            + "      \"Target OS Type\": \"android\"\n"
+            + "   }\n"
+            + "}";
+
+    // The list of packages the model classes reside in
+    private Set<String> packages;
+
+    private RealmAnalytics(Set<String> packages) {
+        this.packages = packages;
+    }
+
+    public static RealmAnalytics getInstance(Set<String> packages) {
+        if (instance == null) {
+            instance = new RealmAnalytics(packages);
+        }
+        return instance;
+    }
+
+    private void send() {
+        try {
+            URL url = getUrl();
+            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod("GET");
+            connection.connect();
+            connection.getResponseCode();
+        } catch (Exception ignored) {
+        }
+    }
+
+    public void execute() {
+        Thread backgroundThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                send();
+            }
+        });
+        backgroundThread.start();
+        try {
+            backgroundThread.join(CONNECT_TIMEOUT + READ_TIMEOUT);
+        } catch (InterruptedException ignored) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        } catch (IllegalArgumentException ignored) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        }
+    }
+
+    public URL getUrl() throws
+            MalformedURLException,
+            SocketException,
+            NoSuchAlgorithmException,
+            UnsupportedEncodingException {
+        return new URL(ADDRESS_PREFIX + Utils.base64Encode(generateJson()) + ADDRESS_SUFFIX);
+    }
+
+    public String generateJson() throws SocketException, NoSuchAlgorithmException {
+        return JSON_TEMPLATE
+                .replaceAll("%EVENT%", EVENT_NAME)
+                .replaceAll("%TOKEN%", TOKEN)
+                .replaceAll("%USER_ID%", getAnonymousUserId())
+                .replaceAll("%APP_ID%", getAnonymousAppId())
+                .replaceAll("%REALM_VERSION%", Version.VERSION)
+                .replaceAll("%OS_TYPE%", System.getProperty("os.name"))
+                .replaceAll("%OS_VERSION%", System.getProperty("os.version"));
+    }
+
+    /**
+     * Compute an anonymous user id from the hashed MAC address of the first network interface
+     * @return the anonymous user id
+     * @throws NoSuchAlgorithmException
+     * @throws SocketException
+     */
+    public static String getAnonymousUserId() throws NoSuchAlgorithmException, SocketException {
+        Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+
+        if (!networkInterfaces.hasMoreElements()) {
+            throw new IllegalStateException("No network interfaces detected");
+        }
+
+        NetworkInterface networkInterface = networkInterfaces.nextElement();
+        byte[] hardwareAddress = networkInterface.getHardwareAddress(); // Normally this is the MAC address
+
+        return Utils.hexStringify(Utils.sha256Hash(hardwareAddress));
+    }
+
+    /**
+     * Compute an anonymous app/library id from the packages containing RealmObject classes
+     * @return the anonymous app/library id
+     * @throws NoSuchAlgorithmException
+     */
+    public String getAnonymousAppId() throws NoSuchAlgorithmException {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (String modelPackage : packages) {
+            stringBuilder.append(modelPackage).append(":");
+        }
+        byte[] packagesBytes = stringBuilder.toString().getBytes();
+
+        return Utils.hexStringify(Utils.sha256Hash(packagesBytes));
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
new file mode 100644
index 0000000000..6fc488c70c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Helper class for converting between Json types and data types in Java that are supported by Realm.
+ */
+public class RealmJsonTypeHelper {
+    private static final Map<String, JsonToRealmFieldTypeConverter> JAVA_TO_JSON_TYPES;
+    static {
+        JAVA_TO_JSON_TYPES = new HashMap<String, JsonToRealmFieldTypeConverter>();
+        JAVA_TO_JSON_TYPES.put("byte", new SimpleTypeConverter("byte", "Int"));
+        JAVA_TO_JSON_TYPES.put("short", new SimpleTypeConverter("short", "Int"));
+        JAVA_TO_JSON_TYPES.put("int", new SimpleTypeConverter("int", "Int"));
+        JAVA_TO_JSON_TYPES.put("long", new SimpleTypeConverter("long", "Long"));
+        JAVA_TO_JSON_TYPES.put("float", new SimpleTypeConverter("float", "Double"));
+        JAVA_TO_JSON_TYPES.put("double", new SimpleTypeConverter("double", "Double"));
+        JAVA_TO_JSON_TYPES.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Byte", new SimpleTypeConverter("byte", "Int"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Short", new SimpleTypeConverter("short", "Int"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Integer", new SimpleTypeConverter("int", "Int"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Long", new SimpleTypeConverter("long", "Long"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Float", new SimpleTypeConverter("float", "Double"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Double", new SimpleTypeConverter("double", "Double"));
+        JAVA_TO_JSON_TYPES.put("java.lang.Boolean", new SimpleTypeConverter("boolean", "Boolean"));
+        JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
+        JAVA_TO_JSON_TYPES.put("java.util.Date", new JsonToRealmFieldTypeConverter() {
+            @Override
+            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                                           JavaWriter writer)
+                    throws IOException {
+                writer
+                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                        .nextControlFlow("else")
+                            .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
+                            .beginControlFlow("if (timestamp instanceof String)")
+                               .emitStatement("((%s) obj).%s(JsonUtils.stringToDate((String) timestamp))",
+                                       interfaceName, setter)
+                            .nextControlFlow("else")
+                                .emitStatement("((%s) obj).%s(new Date(json.getLong(\"%s\")))", interfaceName, setter,
+                                        fieldName)
+                            .endControlFlow()
+                        .endControlFlow()
+                    .endControlFlow();
+            }
+
+            @Override
+            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
+                    fieldType, JavaWriter writer)
+                    throws IOException {
+                writer
+                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                        .emitStatement("reader.skipValue()")
+                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
+                        .emitStatement("long timestamp = reader.nextLong()", fieldName)
+                        .beginControlFlow("if (timestamp > -1)")
+                            .emitStatement("((%s) obj).%s(new Date(timestamp))", interfaceName, setter)
+                        .endControlFlow()
+                    .nextControlFlow("else")
+                        .emitStatement("((%s) obj).%s(JsonUtils.stringToDate(reader.nextString()))", interfaceName,
+                                setter)
+                    .endControlFlow();
+            }
+
+            @Override
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("Date is not allowed as a primary key value.");
+            }
+        });
+        JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmFieldTypeConverter() {
+            @Override
+            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                                           JavaWriter writer)
+                    throws IOException {
+                writer
+                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                        .nextControlFlow("else")
+                            .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(json.getString(\"%s\")))",
+                                    interfaceName, setter, fieldName)
+                        .endControlFlow()
+                    .endControlFlow();
+            }
+
+            @Override
+            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
+                    fieldType, JavaWriter writer)
+                    throws IOException {
+                writer
+                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                        .emitStatement("reader.skipValue()")
+                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .nextControlFlow("else")
+                        .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(reader.nextString()))", interfaceName,
+                                setter)
+                    .endControlFlow();
+            }
+
+            @Override
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("byte[] is not allowed as a primary key value.");
+            }
+        });
+    }
+
+    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedFieldType,
+                                                           String fieldName, JavaWriter writer) throws IOException {
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, fieldName, writer);
+        }
+    }
+
+    public static void emitFillJavaTypeWithJsonValue(String interfaceName, String setter, String fieldName, String
+            qualifiedFieldType,
+                                                     JavaWriter writer) throws IOException {
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitTypeConversion(interfaceName, setter, fieldName, qualifiedFieldType, writer);
+        }
+    }
+
+    public static void emitFillRealmObjectWithJsonValue(String interfaceName, String setter, String fieldName, String
+            qualifiedFieldType, String proxyClass, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .nextControlFlow("else")
+                    .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                            qualifiedFieldType, fieldName, proxyClass, fieldName)
+                    .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+                .endControlFlow()
+            .endControlFlow();
+    }
+
+    public static void emitFillRealmListWithJsonValue(String interfaceName, String getter, String setter, String
+            fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .nextControlFlow("else")
+                    .emitStatement("((%s) obj).%s().clear()", interfaceName, getter)
+                    .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
+                    .beginControlFlow("for (int i = 0; i < array.length(); i++)")
+                        .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
+                                fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
+                        .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                    .endControlFlow()
+                .endControlFlow()
+            .endControlFlow();
+    }
+
+
+    public static void emitFillJavaTypeFromStream(String interfaceName, String setter, String fieldName, String
+            fieldType, JavaWriter writer) throws IOException {
+        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
+            JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType,
+                    writer);
+        }
+    }
+
+    public static void emitFillRealmObjectFromStream(String interfaceName, String setter, String fieldName, String
+            fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                .emitStatement("reader.skipValue()")
+                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+            .nextControlFlow("else")
+                .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName,
+                        proxyClass)
+                .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+            .endControlFlow();
+    }
+
+    public static void emitFillRealmListFromStream(String interfaceName, String getter, String setter, String
+            fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+        writer
+            .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                .emitStatement("reader.skipValue()")
+                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+            .nextControlFlow("else")
+                .emitStatement("reader.beginArray()")
+                .beginControlFlow("while (reader.hasNext())")
+                    .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
+                    .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                .endControlFlow()
+                .emitStatement("reader.endArray()")
+            .endControlFlow();
+    }
+
+    private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
+
+        private final String castType;
+        private final String jsonType;
+
+        /**
+         * Creates a conversion between simple types which can be expressed as
+         * RealmObject.setFieldName((<castType>) json.get<jsonType>) or
+         * RealmObject.setFieldName((<castType>) reader.next<jsonType>
+         *
+         * @param castType  Java type to cast to.
+         * @param jsonType  JsonType to get data from.
+         */
+        private SimpleTypeConverter(String castType, String jsonType) {
+            this.castType = castType;
+            this.jsonType = jsonType;
+        }
+
+        @Override
+        public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                                       JavaWriter
+                writer)
+                throws IOException {
+            String statementSetNullOrThrow;
+            if (Utils.isPrimitiveType(fieldType)) {
+                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
+                // the setter.
+                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
+            } else {
+                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
+            }
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement(statementSetNullOrThrow)
+                    .nextControlFlow("else")
+                        .emitStatement("((%s) obj).%s((%s) json.get%s(\"%s\"))", interfaceName, setter, castType,
+                                jsonType, fieldName)
+                    .endControlFlow()
+                .endControlFlow();
+        }
+
+        @Override
+        public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                                             JavaWriter writer)
+                throws IOException {
+            String statementSetNullOrThrow;
+            if (Utils.isPrimitiveType(fieldType)) {
+                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
+                // the setter.
+                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
+            } else {
+                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
+            }
+            writer
+                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement(statementSetNullOrThrow)
+                .nextControlFlow("else")
+                    .emitStatement("((%s) obj).%s((%s) reader.next%s())", interfaceName, setter, castType, jsonType)
+                .endControlFlow();
+        }
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
+            // No error checking is done here for valid primary key types. This should be done by the annotation
+            // processor
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, null)", qualifiedRealmObjectClass)
+                    .nextControlFlow("else")
+                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, json.get%2$s(\"%3$s\"))",
+                                qualifiedRealmObjectClass, jsonType, fieldName)
+                    .endControlFlow()
+                .nextControlFlow("else")
+                    .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class)", qualifiedRealmObjectClass)
+                .endControlFlow();
+        }
+    }
+
+    private interface JsonToRealmFieldTypeConverter {
+        void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType, JavaWriter
+                writer) throws IOException;
+        void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
+                                      JavaWriter writer) throws IOException;
+        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException;
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
similarity index 84%
rename from realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index f7dd18c9c7..d23c164192 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -20,6 +20,7 @@
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
@@ -43,15 +44,15 @@
  *  <li>Minimize reflection.</li>
  *  <li>Realm code can be obfuscated as much as possible.</li>
  *  <li>Library projects must be able to use Realm without interfering with app code.</li>
- *  <li>App code must be able to use model classes provided by library code.</li>
+ *  <li>App code must be able to use RealmObject classes provided by library code.</li>
  *  <li>It should work for app developers out of the box (ie. put the burden on the library developer)</li>
  * </ul>
  *
  * <h1>SUMMARY</h1>
  *
  * <ol>
- *  <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;modelClass&gt;RealmProxy.java</li>
- *  <li>Create a DefaultRealmModule containing all model classes (if needed).</li>
+ *  <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;className&gt;RealmProxy.java</li>
+ *  <li>Create a DefaultRealmModule containing all RealmObject classes (if needed).</li>
  *  <li>Create a RealmProxyMediator class for all classes marked with @RealmModule. They are named <moduleName>Mediator.java</li>
  * </ol>
  *
@@ -59,7 +60,7 @@
  *
  * <ol>
  * <li>A RealmObjectProxy object is created for each class annotated with {@link io.realm.annotations.RealmClass}. This
- * proxy extends the original model class and rewires all field access to point to the native Realm memory instead of
+ * proxy extends the original RealmObject class and rewires all field access to point to the native Realm memory instead of
  * Java memory. It also adds some static helper methods to the class.</li>
  *
  * <li>The annotation processor is either in "library" mode or in "app" mode. This is defined by having a class
@@ -74,7 +75,7 @@
  * helper methods should be done through this Mediator.</li>
  * </ol>
  *
- * This allows ProGuard to obfuscate all model and proxy classes as all access to the static methods now happens through
+ * This allows ProGuard to obfuscate all RealmObject and proxy classes as all access to the static methods now happens through
  * the Mediator, and the only requirement is now that only RealmModule and Mediator class names cannot be obfuscated.
  *
  *
@@ -85,7 +86,7 @@
  * <ol>
  *  <li>Open a Realm.</li>
  *  <li>Assign one or more modules (that are allowed to overlap). If no module is assigned, the default module is used.</li>
- *  <li>The Realm schema is now defined as all model classes known by these modules.</li>
+ *  <li>The Realm schema is now defined as all RealmObject classes known by these modules.</li>
  *  <li>Each time a static helper method is needed, Realm can now delegate these method calls to the appropriate
  *    Mediator which in turn will delegate the method call to the appropriate RealmObjectProxy class.</li>
  * </ol>
@@ -95,7 +96,8 @@
         "io.realm.annotations.Ignore",
         "io.realm.annotations.Index",
         "io.realm.annotations.PrimaryKey",
-        "io.realm.annotations.internal.RealmModule"
+        "io.realm.annotations.RealmModule",
+        "io.realm.annotations.Required"
 })
 public class RealmProcessor extends AbstractProcessor {
 
@@ -111,10 +113,14 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         if (hasProcessedModules) {
             return true;
         }
+
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
+
         Utils.initialize(processingEnv);
 
+        Set<String> packages = new TreeSet<String>();
+
         // Create all proxy classes
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
@@ -132,6 +138,14 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 return true; // Abort processing by claiming all annotations
             }
             classesToValidate.add(metadata);
+            packages.add(metadata.getPackageName());
+
+            RealmProxyInterfaceGenerator interfaceGenerator = new RealmProxyInterfaceGenerator(processingEnv, metadata);
+            try {
+                interfaceGenerator.generate();
+            } catch (IOException e) {
+                Utils.error(e.getMessage(), classElement);
+            }
 
             RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, metadata);
             try {
@@ -141,7 +155,13 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             } catch (UnsupportedOperationException e) {
                 Utils.error(e.getMessage(), classElement);
             }
-	    }
+        }
+
+        String environmentVariable = System.getenv("REALM_DISABLE_ANALYTICS");
+        if (environmentVariable == null || !environmentVariable.equals("true")) {
+            RealmAnalytics analytics = RealmAnalytics.getInstance(packages);
+            analytics.execute();
+        }
 
         hasProcessedModules = true;
         return processModules(roundEnv);
@@ -159,7 +179,7 @@ private boolean processModules(RoundEnvironment roundEnv) {
         if (moduleMetaData.shouldCreateDefaultModule()) {
             if (!createDefaultModule()) {
                 return false;
-            };
+            }
         }
 
         // Create RealmProxyMediators for all Realm modules
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
similarity index 56%
rename from realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 6da3f7d72c..1d4b10d937 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -18,123 +18,41 @@
 
 import com.squareup.javawriter.JavaWriter;
 
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.JavaFileObject;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.*;
 
 public class RealmProxyClassGenerator {
     private ProcessingEnvironment processingEnvironment;
     private ClassMetaData metadata;
     private final String className;
-
-    // Class metadata for generating proxy classes
-    private Elements elementUtils;
-    private Types typeUtils;
-    private TypeMirror realmObject;
-    private DeclaredType realmList;
+    private final String interfaceName;
 
     public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
         this.metadata = metadata;
         this.className = metadata.getSimpleClassName();
-    }
-
-    private static final Map<String, String> JAVA_TO_REALM_TYPES;
-    static {
-        JAVA_TO_REALM_TYPES = new HashMap<String, String>();
-        JAVA_TO_REALM_TYPES.put("byte", "Long");
-        JAVA_TO_REALM_TYPES.put("short", "Long");
-        JAVA_TO_REALM_TYPES.put("int", "Long");
-        JAVA_TO_REALM_TYPES.put("long", "Long");
-        JAVA_TO_REALM_TYPES.put("float", "Float");
-        JAVA_TO_REALM_TYPES.put("double", "Double");
-        JAVA_TO_REALM_TYPES.put("boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("Byte", "Long");
-        JAVA_TO_REALM_TYPES.put("Short", "Long");
-        JAVA_TO_REALM_TYPES.put("Integer", "Long");
-        JAVA_TO_REALM_TYPES.put("Long", "Long");
-        JAVA_TO_REALM_TYPES.put("Float", "Float");
-        JAVA_TO_REALM_TYPES.put("Double", "Double");
-        JAVA_TO_REALM_TYPES.put("Boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("java.lang.String", "String");
-        JAVA_TO_REALM_TYPES.put("java.util.Date", "Date");
-        JAVA_TO_REALM_TYPES.put("byte[]", "BinaryByteArray");
-        // TODO: add support for char and Char
-    }
-
-    // Types in this array are guarded by if != null and use default value if trying to insert null
-    private static final Map<String, String> NULLABLE_JAVA_TYPES;
-    static {
-        NULLABLE_JAVA_TYPES = new HashMap<String, String>();
-        NULLABLE_JAVA_TYPES.put("java.util.Date", "new Date(0)");
-        NULLABLE_JAVA_TYPES.put("java.lang.String", "\"\"");
-        NULLABLE_JAVA_TYPES.put("byte[]", "new byte[0]");
-    }
-
-    private static final Map<String, String> JAVA_TO_COLUMN_TYPES;
-    static {
-        JAVA_TO_COLUMN_TYPES = new HashMap<String, String>();
-        JAVA_TO_COLUMN_TYPES.put("byte", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("short", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("int", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("long", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("float", "ColumnType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("double", "ColumnType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("boolean", "ColumnType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("Byte", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("Short", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("Integer", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("Long", "ColumnType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("Float", "ColumnType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("Double", "ColumnType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("Boolean", "ColumnType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.String", "ColumnType.STRING");
-        JAVA_TO_COLUMN_TYPES.put("java.util.Date", "ColumnType.DATE");
-        JAVA_TO_COLUMN_TYPES.put("byte[]", "ColumnType.BINARY");
-    }
-
-    private static final Map<String, String> CASTING_TYPES;
-    static {
-        CASTING_TYPES = new HashMap<String, String>();
-        CASTING_TYPES.put("byte", "long");
-        CASTING_TYPES.put("short", "long");
-        CASTING_TYPES.put("int", "long");
-        CASTING_TYPES.put("long", "long");
-        CASTING_TYPES.put("float", "float");
-        CASTING_TYPES.put("double", "double");
-        CASTING_TYPES.put("boolean", "boolean");
-        CASTING_TYPES.put("Byte", "long");
-        CASTING_TYPES.put("Short", "long");
-        CASTING_TYPES.put("Integer", "long");
-        CASTING_TYPES.put("Long", "long");
-        CASTING_TYPES.put("Float", "float");
-        CASTING_TYPES.put("Double", "double");
-        CASTING_TYPES.put("Boolean", "boolean");
-        CASTING_TYPES.put("java.lang.String", "String");
-        CASTING_TYPES.put("java.util.Date", "Date");
-        CASTING_TYPES.put("byte[]", "byte[]");
+        this.interfaceName = Utils.getProxyInterfaceName(className);
     }
 
     public void generate() throws IOException, UnsupportedOperationException {
-        elementUtils = processingEnvironment.getElementUtils();
-        typeUtils = processingEnvironment.getTypeUtils();
-        realmObject = elementUtils.getTypeElement("io.realm.RealmObject").asType();
-        realmList = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
-
         String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
-        // Set source code indent to 4 spaces
-        writer.setIndent("    ");
+        // Set source code indent
+        writer.setIndent(Constants.INDENT);
 
         writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                 .emitEmptyLine();
@@ -142,10 +60,9 @@ public void generate() throws IOException, UnsupportedOperationException {
         ArrayList<String> imports = new ArrayList<String>();
         imports.add("android.util.JsonReader");
         imports.add("android.util.JsonToken");
-        imports.add("io.realm.RealmObject");
-        imports.add("io.realm.exceptions.RealmException");
+        imports.add("io.realm.RealmFieldType");
         imports.add("io.realm.exceptions.RealmMigrationNeededException");
-        imports.add("io.realm.internal.ColumnType");
+        imports.add("io.realm.internal.ColumnInfo");
         imports.add("io.realm.internal.RealmObjectProxy");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
@@ -156,7 +73,6 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("java.util.ArrayList");
         imports.add("java.util.Collections");
         imports.add("java.util.List");
-        imports.add("java.util.Arrays");
         imports.add("java.util.Date");
         imports.add("java.util.Map");
         imports.add("java.util.HashMap");
@@ -167,9 +83,9 @@ public void generate() throws IOException, UnsupportedOperationException {
 
         for (VariableElement field : metadata.getFields()) {
             String fieldTypeName = "";
-            if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
+            if (Utils.isRealmObject(field)) { // Links
                 fieldTypeName = field.asType().toString();
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // LinkLists
+            } else if (Utils.isRealmList(field)) { // LinkLists
                 fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
             }
             if (!fieldTypeName.isEmpty() && !imports.contains(fieldTypeName)) {
@@ -186,20 +102,24 @@ public void generate() throws IOException, UnsupportedOperationException {
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
                 className,                   // class to extend
-                "RealmObjectProxy")          // interfaces to implement
+                "RealmObjectProxy",          // interfaces to implement
+                interfaceName)
                 .emitEmptyLine();
 
+        emitColumnIndicesClass(writer);
+
         emitClassFields(writer);
+        emitConstructor(writer);
         emitAccessors(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
-        emitGetColumnIndicesMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
+        emitCreateDetachedCopyMethod(writer);
         emitUpdateMethod(writer);
         emitToStringMethod(writer);
         emitHashcodeMethod(writer);
@@ -210,11 +130,51 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.close();
     }
 
+    private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
+        writer.beginType(
+                columnInfoClassName(),                       // full qualified name of the item to generate
+                "class",                                     // the type of the item
+                EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
+                "ColumnInfo")                                // base class
+                .emitEmptyLine();
+
+        // fields
+        for (VariableElement variableElement : metadata.getFields()) {
+            writer.emitField("long", columnIndexVarName(variableElement),
+                    EnumSet.of(Modifier.PUBLIC, Modifier.FINAL));
+        }
+        writer.emitEmptyLine();
+
+        // constructor
+        writer.beginConstructor(EnumSet.noneOf(Modifier.class),
+                "String", "path",
+                "Table", "table");
+        writer.emitStatement("final Map<String, Long> indicesMap = new HashMap<String, Long>(%s)",
+                metadata.getFields().size());
+        for (VariableElement variableElement : metadata.getFields()) {
+            final String columnName = variableElement.getSimpleName().toString();
+            final String columnIndexVarName = columnIndexVarName(variableElement);
+            writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
+                    columnIndexVarName, className, columnName);
+            writer.emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
+            writer.emitEmptyLine();
+        }
+        writer.emitStatement("setIndicesMap(indicesMap)");
+        writer.endConstructor();
+
+        writer.endType();
+        writer.emitEmptyLine();
+    }
+
     private void emitClassFields(JavaWriter writer) throws IOException {
+        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
         for (VariableElement variableElement : metadata.getFields()) {
-            writer.emitField("long", staticFieldIndexVarName(variableElement), EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+            if (Utils.isRealmList(variableElement)) {
+                String genericType = Utils.getGenericType(variableElement);
+                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
+            }
         }
-        writer.emitField("Map<String, Long>", "columnIndices", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+
         writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
         writer.emitStatement("List<String> fieldNames = new ArrayList<String>()");
@@ -226,91 +186,141 @@ private void emitClassFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    private void emitConstructor(JavaWriter writer) throws IOException {
+        // FooRealmProxy(ColumnInfo)
+        writer.beginConstructor(EnumSet.noneOf(Modifier.class), "ColumnInfo", "columnInfo");
+        writer.emitStatement("this.columnInfo = (%s) columnInfo", columnInfoClassName());
+        writer.endConstructor();
+        writer.emitEmptyLine();
+    }
+
     private void emitAccessors(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldTypeCanonicalName = field.asType().toString();
 
-            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 /**
                  * Primitives and boxed types
                  */
-                String realmType = JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
-                String castingType = CASTING_TYPES.get(fieldTypeCanonicalName);
+                String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
 
                 // Getter
-                writer.emitAnnotation("Override");
+                writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+
+                // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
+                if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
+                    writer.beginControlFlow("if (((RealmObject) this).row.isNull(%s))", fieldIndexVariableReference(field));
+                    writer.emitStatement("return null");
+                    writer.endControlFlow();
+                }
+
+                // For Boxed types, this should be the corresponding primitive types. Others remain the same.
+                String castingBackType;
+                if (Utils.isBoxedType(field.asType().toString())) {
+                    Types typeUtils = processingEnvironment.getTypeUtils();
+                    castingBackType = typeUtils.unboxedType(field.asType()).toString();
+                } else {
+                    castingBackType = fieldTypeCanonicalName;
+                }
                 writer.emitStatement(
-                        "realm.checkIfValid()"
-                );
-                writer.emitStatement(
-                        "return (%s) row.get%s(%s)",
-                        fieldTypeCanonicalName, realmType, staticFieldIndexVarName(field));
+                        "return (%s) ((RealmObject) this).row.get%s(%s)",
+                        castingBackType, realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
-                writer.emitAnnotation("Override");
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
+                // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
+                if (metadata.isNullable(field)) {
+                    writer.beginControlFlow("if (value == null)")
+                        .emitStatement("((RealmObject) this).row.setNull(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                    .endControlFlow();
+                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                    // Same reason, throw IAE earlier.
+                    writer
+                        .beginControlFlow("if (value == null)")
+                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        .endControlFlow();
+                }
                 writer.emitStatement(
-                        "realm.checkIfValid()"
-                );
-                writer.emitStatement(
-                        "row.set%s(%s, (%s) value)",
-                        realmType, staticFieldIndexVarName(field), castingType);
+                        "((RealmObject) this).row.set%s(%s, value)",
+                        realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
-            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            } else if (Utils.isRealmObject(field)) {
                 /**
                  * Links
                  */
 
                 // Getter
-                writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.beginControlFlow("if (row.isNullLink(%s))", staticFieldIndexVarName(field));
-                writer.emitStatement("return null");
-                writer.endControlFlow();
-                writer.emitStatement(
-                        "return realm.get(%s.class, row.getLink(%s))",
-                        fieldTypeCanonicalName, staticFieldIndexVarName(field));
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.beginControlFlow("if (((RealmObject) this).row.isNullLink(%s))", fieldIndexVariableReference(field));
+                        writer.emitStatement("return null");
+                        writer.endControlFlow();
+                writer.emitStatement("return ((RealmObject) this).realm.get(%s.class, ((RealmObject) this).row.getLink(%s))",
+                        fieldTypeCanonicalName, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
-                writer.emitAnnotation("Override");
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
                 writer.beginControlFlow("if (value == null)");
-                writer.emitStatement("row.nullifyLink(%s)", staticFieldIndexVarName(field));
-                writer.emitStatement("return");
+                    writer.emitStatement("((RealmObject) this).row.nullifyLink(%s)", fieldIndexVariableReference(field));
+                    writer.emitStatement("return");
+                writer.endControlFlow();
+                writer.beginControlFlow("if (!value.isValid())");
+                    writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
+                writer.endControlFlow();
+                writer.beginControlFlow("if (value.realm != this.realm)");
+                    writer.emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")");
                 writer.endControlFlow();
-                writer.emitStatement("row.setLink(%s, value.row.getIndex())", staticFieldIndexVarName(field));
+                writer.emitStatement("((RealmObject) this).row.setLink(%s, ((RealmObject) value).row.getIndex())", fieldIndexVariableReference(field));
                 writer.endMethod();
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 /**
                  * LinkLists
                  */
                 String genericType = Utils.getGenericType(field);
 
                 // Getter
-                writer.emitAnnotation("Override");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.emitStatement(
-                        "return new RealmList<%s>(%s.class, row.getLinkList(%s), realm)",
-                        genericType, genericType, staticFieldIndexVarName(field));
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitSingleLineComment("use the cached value if available");
+                writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
+                        writer.emitStatement("return " + fieldName + "RealmList");
+                writer.nextControlFlow("else");
+                    writer.emitStatement("LinkView linkView = ((RealmObject) this).row.getLinkList(%s)", fieldIndexVariableReference(field));
+                    writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, realm)",
+                        genericType, genericType);
+                    writer.emitStatement("return " + fieldName + "RealmList");
+                writer.endControlFlow();
+
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
-                writer.emitAnnotation("Override");
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("LinkView links = row.getLinkList(%s)", staticFieldIndexVarName(field));
+                writer.emitStatement("((RealmObject) this).realm.checkIfValid()");
+                writer.emitStatement("LinkView links = ((RealmObject) this).row.getLinkList(%s)", fieldIndexVariableReference(field));
+                writer.emitStatement("links.clear()");
                 writer.beginControlFlow("if (value == null)");
-                writer.emitStatement("return"); // TODO: delete all the links instead
+                    writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.emitStatement("links.clear()");
                 writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
-                writer.emitStatement("links.add(linkedObject.row.getIndex())");
+                    writer.beginControlFlow("if (!linkedObject.isValid())");
+                        writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")");
+                    writer.endControlFlow();
+                    writer.beginControlFlow("if (linkedObject.realm != this.realm)");
+                        writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")");
+                    writer.endControlFlow();
+                    writer.emitStatement("links.add(((RealmObject) linkedObject).row.getIndex())");
                 writer.endControlFlow();
                 writer.endMethod();
             } else {
@@ -337,22 +347,28 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
             String fieldTypeCanonicalName = field.asType().toString();
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                writer.emitStatement("table.addColumn(%s, \"%s\")",
-                        JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
-                        fieldName);
-            } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+                String nullableFlag;
+                if (metadata.isNullable(field)) {
+                    nullableFlag = "Table.NULLABLE";
+                } else {
+                    nullableFlag = "Table.NOT_NULLABLE";
+                }
+                writer.emitStatement("table.addColumn(%s, \"%s\", %s)",
+                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
+                        fieldName, nullableFlag);
+            } else if (Utils.isRealmObject(field)) {
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
+                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", transaction.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 String genericType = Utils.getGenericType(field);
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
                 writer.emitStatement("%s%s.initTable(transaction)", genericType, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
+                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", transaction.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, genericType);
             }
         }
@@ -378,7 +394,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "void", // Return type
+                columnInfoClassName(), // Return type
                 "validateTable", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
@@ -393,25 +409,14 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.endControlFlow();
 
         // create type dictionary for lookup
-        writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
+        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
         writer.beginControlFlow("for (long i = 0; i < " + metadata.getFields().size() + "; i++)");
         writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
         writer.endControlFlow();
-
-        // Populate column indices
         writer.emitEmptyLine();
-        writer.emitStatement("columnIndices = new HashMap<String, Long>()");
-        writer
-                .beginControlFlow("for (String fieldName : getFieldNames())")
-                    .emitStatement("long index = table.getColumnIndex(fieldName)")
-                    .beginControlFlow("if (index == -1)")
-                        .emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field '\" + fieldName + \"' not found for type %s\")", metadata.getSimpleClassName())
-                    .endControlFlow()
-                    .emitStatement("columnIndices.put(fieldName, index)")
-                .endControlFlow();
-        for (VariableElement field : metadata.getFields()) {
-            writer.emitStatement("%s = table.getColumnIndex(\"%s\")", staticFieldIndexVarName(field), field.getSimpleName().toString());
-        }
+
+        // create an instance of ColumnInfo
+        writer.emitStatement("final %1$s columnInfo = new %1$s(transaction.getPath(), table)", columnInfoClassName());
         writer.emitEmptyLine();
 
         // For each field verify there is a corresponding
@@ -421,35 +426,74 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
             String fieldTypeCanonicalName = field.asType().toString();
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 // make sure types align
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                        "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
+                        "\")", fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
+                writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
+                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
+                // make sure that nullability matches
+                if (metadata.isNullable(field)) {
+                    writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+                    if (Utils.isBoxedType(fieldTypeCanonicalName)) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                "\"Field '%s' does not support null values in the existing Realm file. " +
+                                "Either set @Required, use the primitive type for field '%s' " +
+                                "or migrate using io.realm.internal.Table.convertColumnToNullable()." +
+                                "\")",
+                                fieldName, fieldName);
+                    } else {
+                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                " \"Field '%s' is required. Either set @Required to field '%s' " +
+                                "or migrate using io.realm.internal.Table.convertColumnToNullable()." +
+                                "\")",
+                                fieldName, fieldName);
+                    }
+                    writer.endControlFlow();
+                } else {
+                    writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+                    if (Utils.isPrimitiveType(fieldTypeCanonicalName)) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                " \"Field '%s' does support null values in the existing Realm file. " +
+                                "Use corresponding boxed type for field '%s' or migrate using io.realm.internal.Table.convertColumnToNotNullable().\")",
+                                fieldName, fieldName);
+                    } else {
+                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                                " \"Field '%s' does support null values in the existing Realm file. " +
+                                "Remove @Required or @PrimaryKey from field '%s' or migrate using io.realm.internal.Table.convertColumnToNotNullable().\")",
+                                fieldName, fieldName);
+                    }
+                    writer.endControlFlow();
+                }
+
                 // Validate @PrimaryKey
                 if (field.equals(metadata.getPrimaryKey())) {
                     writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Primary key not defined for field '%s'\")", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
                     writer.endControlFlow();
                 }
 
                 // Validate @Index
                 if (metadata.getIndexedFields().contains(field)) {
                     writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Index not defined for field '%s'\")", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
+                            "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
                     writer.endControlFlow();
                 }
 
-            } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
+            } else if (Utils.isRealmObject(field)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                        "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
+                writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
@@ -459,16 +503,17 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.endControlFlow();
 
                 writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.beginControlFlow("if (!table.getLinkTarget(%s).equals(table_%d))", staticFieldIndexVarName(field), fieldIndex);
+                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+                        fieldIndexVariableReference(field), fieldIndex);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                        fieldName, staticFieldIndexVarName(field), fieldIndex);
+                        fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
+            } else if (Utils.isRealmList(field)) { // Link Lists
                 String genericType = Utils.getGenericType(field);
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
+                writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
                         genericType, fieldName);
                 writer.endControlFlow();
@@ -478,14 +523,17 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.endControlFlow();
 
                 writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericType);
-                writer.beginControlFlow("if (!table.getLinkTarget(%s).equals(table_%d))", staticFieldIndexVarName(field), fieldIndex);
+                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+                        fieldIndexVariableReference(field), fieldIndex);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                        fieldName, staticFieldIndexVarName(field), fieldIndex);
+                        fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             }
             fieldIndex++;
         }
 
+        writer.emitStatement("return %s", "columnInfo");
+
         writer.nextControlFlow("else");
         writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
@@ -507,13 +555,6 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitGetColumnIndicesMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("Map<String,Long>", "getColumnIndices", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        writer.emitStatement("return columnIndices");
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 className, // Return type
@@ -524,7 +565,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
 
         // If object is already in the Realm there is nothing to update
         writer
-            .beginControlFlow("if (object.realm != null && object.realm.getPath().equals(realm.getPath()))")
+            .beginControlFlow("if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath()))")
                 .emitStatement("return object")
             .endControlFlow();
 
@@ -538,21 +579,26 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     .emitStatement("Table table = realm.getTable(%s.class)", className)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
 
+            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
             if (Utils.isString(metadata.getPrimaryKey())) {
                 writer
-                    .beginControlFlow("if (object.%s() == null)", metadata.getPrimaryKeyGetter())
+                    .beginControlFlow("if (((%s) object).%s() == null)", interfaceName, primaryKeyGetter)
                         .emitStatement("throw new IllegalArgumentException(\"Primary key value must not be null.\")")
                     .endControlFlow()
-                    .emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
+                    .emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, ((%s) object).%s())",
+                            interfaceName, primaryKeyGetter);
             } else {
-                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
+                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, ((%s) object).%s())",
+                        interfaceName, primaryKeyGetter);
             }
 
             writer
                 .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                    .emitStatement("realmObject = new %s()", Utils.getProxyClassName(className))
-                    .emitStatement("realmObject.realm = realm")
-                    .emitStatement("realmObject.row = table.getRow(rowIndex)")
+                    .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
+                            Utils.getProxyClassName(className),
+                            className)
+                    .emitStatement("((RealmObject) realmObject).realm = realm")
+                    .emitStatement("((RealmObject) realmObject).row = table.getUncheckedRow(rowIndex)")
                     .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                 .nextControlFlow("else")
                     .emitStatement("canUpdate = false")
@@ -581,7 +627,8 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache"); // Argument type & argument name
 
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s realmObject = realm.createObject(%s.class, newObject.%s())", className, className, metadata.getPrimaryKeyGetter());
+            writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
+                    className, className, interfaceName, metadata.getPrimaryKeyGetter());
         } else {
             writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
         }
@@ -589,27 +636,36 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            String setter = metadata.getSetter(fieldName);
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmObject(field)) {
                 writer
                     .emitEmptyLine()
-                    .emitStatement("%s %sObj = newObject.%s()", fieldType, fieldName, metadata.getGetter(fieldName))
+                    .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
                     .beginControlFlow("if (%sObj != null)", fieldName)
                         .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("realmObject.%s(cache%s)", metadata.getSetter(fieldName), fieldName)
+                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                    metadata.getSetter(fieldName),
+                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
+                                    interfaceName,
+                                    setter,
                                     Utils.getProxyClassSimpleName(field),
                                     fieldName)
                         .endControlFlow()
+                    .nextControlFlow("else")
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                     .endControlFlow();
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 writer
                     .emitEmptyLine()
-                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
+                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
+                            Utils.getGenericType(field), fieldName, interfaceName, getter)
                     .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
+                        .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                                Utils.getGenericType(field), fieldName, interfaceName, getter)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                                 .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
                                 .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
@@ -623,15 +679,8 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                     .emitEmptyLine();
 
             } else {
-                if (NULLABLE_JAVA_TYPES.containsKey(fieldType)) {
-                    writer.emitStatement("realmObject.%s(newObject.%s() != null ? newObject.%s() : %s)",
-                            metadata.getSetter(fieldName),
-                            metadata.getGetter(fieldName),
-                            metadata.getGetter(fieldName),
-                            NULLABLE_JAVA_TYPES.get(fieldType));
-                } else {
-                    writer.emitStatement("realmObject.%s(newObject.%s())", metadata.getSetter(fieldName), metadata.getGetter(fieldName));
-                }
+                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
+                        interfaceName, setter, interfaceName, getter);
             }
         }
 
@@ -640,7 +689,76 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                className, // Return type
+                "createDetachedCopy", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                className, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmObject, CacheData<RealmObject>>", "cache");
+        writer
+            .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
+                .emitStatement("return null")
+            .endControlFlow()
+            .emitStatement("CacheData<RealmObject> cachedObject = cache.get(realmObject)")
+            .emitStatement("%s standaloneObject", className)
+            .beginControlFlow("if (cachedObject != null)")
+                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
+                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
+                    .emitStatement("return (%s)cachedObject.object", className)
+                .nextControlFlow("else")
+                    .emitStatement("standaloneObject = (%s)cachedObject.object", className)
+                    .emitStatement("cachedObject.minDepth = currentDepth")
+                .endControlFlow()
+            .nextControlFlow("else")
+                .emitStatement("standaloneObject = new %s()", className)
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject))")
+            .endControlFlow();
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String setter = metadata.getSetter(fieldName);
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmObject(field)) {
+                writer
+                    .emitEmptyLine()
+                    .emitSingleLineComment("Deep copy of %s", fieldName)
+                    .emitStatement("((%s) standaloneObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
+                                interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
+            } else if (Utils.isRealmList(field)) {
+                writer
+                    .emitEmptyLine()
+                    .emitSingleLineComment("Deep copy of %s", fieldName)
+                    .beginControlFlow("if (currentDepth == maxDepth)")
+                        .emitStatement("((%s) standaloneObject).%s(null)", interfaceName, setter)
+                    .nextControlFlow("else")
+                        .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
+                                Utils.getGenericType(field), fieldName, interfaceName, getter)
+                        .emitStatement("RealmList<%1$s> standalone%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
+                        .emitStatement("((%s) standaloneObject).%s(standalone%sList)", interfaceName, setter, fieldName)
+                        .emitStatement("int nextDepth = currentDepth + 1")
+                        .emitStatement("int size = managed%sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < size; i++)")
+                            .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
+                                    Utils.getGenericType(field), Utils.getProxyClassSimpleName(field), fieldName)
+                            .emitStatement("standalone%sList.add(item)", fieldName)
+                        .endControlFlow()
+                    .endControlFlow();
+            } else {
+                writer.emitStatement("((%s) standaloneObject).%s(((%s) realmObject).%s())",
+                        interfaceName, setter, interfaceName, getter);
+            }
+        }
+
+        writer.emitStatement("return standaloneObject");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitUpdateMethod(JavaWriter writer) throws IOException {
+        if (!metadata.hasPrimaryKey()) {
+            return;
+        }
 
         writer.beginMethod(
                 className, // Return type
@@ -650,28 +768,35 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            String setter = metadata.getSetter(fieldName);
+            String getter = metadata.getGetter(fieldName);
+            if (Utils.isRealmObject(field)) {
                 writer
-                    .emitStatement("%s %sObj = newObject.%s()", Utils.getFieldTypeSimpleName(field), fieldName, metadata.getGetter(fieldName))
+                    .emitStatement("%s %sObj = ((%s) newObject).%s()",
+                            Utils.getFieldTypeSimpleName(field), fieldName, interfaceName, getter)
                     .beginControlFlow("if (%sObj != null)", fieldName)
                         .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("realmObject.%s(cache%s)", metadata.getSetter(fieldName), fieldName)
+                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
-                                    metadata.getSetter(fieldName),
+                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
+                                    interfaceName,
+                                    setter,
                                     Utils.getProxyClassSimpleName(field),
                                     fieldName,
                                     Utils.getFieldTypeSimpleName(field)
                             )
                         .endControlFlow()
                     .nextControlFlow("else")
-                        .emitStatement("realmObject.%s(null)", metadata.getSetter(fieldName))
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                     .endControlFlow();
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 writer
-                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
-                    .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
+                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
+                            Utils.getGenericType(field), fieldName, interfaceName, getter)
+                    .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                            Utils.getGenericType(field), fieldName, interfaceName, getter)
                     .emitStatement("%sRealmList.clear()", fieldName)
                     .beginControlFlow("if (%sList != null)", fieldName)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
@@ -689,17 +814,8 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 if (field == metadata.getPrimaryKey()) {
                     continue;
                 }
-
-                String fieldType = field.asType().toString();
-                if (NULLABLE_JAVA_TYPES.containsKey(fieldType)) {
-                    writer.emitStatement("realmObject.%s(newObject.%s() != null ? newObject.%s() : %s)",
-                            metadata.getSetter(fieldName),
-                            metadata.getGetter(fieldName),
-                            metadata.getGetter(fieldName),
-                            NULLABLE_JAVA_TYPES.get(fieldType));
-                } else {
-                    writer.emitStatement("realmObject.%s(newObject.%s())", metadata.getSetter(fieldName), metadata.getGetter(fieldName));
-                }
+                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
+                        interfaceName, setter, interfaceName, getter);
             }
         }
 
@@ -721,20 +837,27 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
             String fieldName = field.getSimpleName().toString();
 
             writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
-            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            if (Utils.isRealmObject(field)) {
                 String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                 writer.emitStatement(
                         "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
                         metadata.getGetter(fieldName),
                         fieldTypeSimpleName
                 );
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 String genericType = Utils.getGenericType(field);
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                         genericType,
                         metadata.getGetter(fieldName));
             } else {
-                writer.emitStatement("stringBuilder.append(%s())", metadata.getGetter(fieldName));
+                if (metadata.isNullable(field)) {
+                    writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
+                            metadata.getGetter(fieldName),
+                            metadata.getGetter(fieldName)
+                    );
+                } else {
+                    writer.emitStatement("stringBuilder.append(%s())", metadata.getGetter(fieldName));
+                }
             }
             writer.emitStatement("stringBuilder.append(\"}\")");
 
@@ -752,9 +875,9 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
     private void emitHashcodeMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC));
-        writer.emitStatement("String realmName = realm.getPath()");
-        writer.emitStatement("String tableName = row.getTable().getName()");
-        writer.emitStatement("long rowIndex = row.getIndex()");
+        writer.emitStatement("String realmName = ((RealmObject) this).realm.getPath()");
+        writer.emitStatement("String tableName = ((RealmObject) this).row.getTable().getName()");
+        writer.emitStatement("long rowIndex = ((RealmObject) this).row.getIndex()");
         writer.emitEmptyLine();
         writer.emitStatement("int result = 17");
         writer.emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)");
@@ -773,15 +896,15 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
         writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
         writer.emitEmptyLine();
-        writer.emitStatement("String path = realm.getPath()");
-        writer.emitStatement("String otherPath = a%s.realm.getPath()", className);
+        writer.emitStatement("String path = ((RealmObject) this).realm.getPath()");
+        writer.emitStatement("String otherPath = ((RealmObject) a%s).realm.getPath()", className);
         writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
         writer.emitEmptyLine();
-        writer.emitStatement("String tableName = row.getTable().getName()");
-        writer.emitStatement("String otherTableName = a%s.row.getTable().getName()", className);
+        writer.emitStatement("String tableName = ((RealmObject) this).row.getTable().getName()");
+        writer.emitStatement("String otherTableName = ((RealmObject) a%s).row.getTable().getName()", className);
         writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
         writer.emitEmptyLine();
-        writer.emitStatement("if (row.getIndex() != a%s.row.getIndex()) return false", className);
+        writer.emitStatement("if (((RealmObject) this).row.getIndex() != ((RealmObject) a%s).row.getIndex()) return false", className);
         writer.emitEmptyLine();
         writer.emitStatement("return true");
         writer.endMethod();
@@ -790,12 +913,13 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
 
 
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
                 className,
                 "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
-                Arrays.asList("JSONException"));
+                Collections.singletonList("JSONException"));
 
         if (!metadata.hasPrimaryKey()) {
             writer.emitStatement("%s obj = realm.createObject(%s.class)", className, className);
@@ -807,33 +931,41 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                     .emitStatement("Table table = realm.getTable(%s.class)", className)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                     .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                        .emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
-                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                        .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                            .emitStatement("obj = new %s()", Utils.getProxyClassName(className))
-                            .emitStatement("obj.realm = realm")
-                            .emitStatement("obj.row = table.getRow(rowIndex)")
+                    .emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                            pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                    .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                            .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
+                                    Utils.getProxyClassName(className),
+                                    className)
+                            .emitStatement("((RealmObject) obj).realm = realm")
+                            .emitStatement("((RealmObject) obj).row = table.getUncheckedRow(rowIndex)")
                         .endControlFlow()
                     .endControlFlow()
-                .endControlFlow()
-                .beginControlFlow("if (obj == null)")
-                    .emitStatement("obj = realm.createObject(%s.class)", className)
                 .endControlFlow();
+
+            writer.beginControlFlow("if (obj == null)");
+            String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
+            String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
+            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(className, primaryKeyFieldType, primaryKeyFieldName, writer);
+            writer.endControlFlow();
         }
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
-            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            if (Utils.isRealmObject(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
+                        interfaceName,
                         metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
-                        writer);
+                        writer
+                );
 
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
+                        interfaceName,
                         metadata.getGetter(fieldName),
                         metadata.getSetter(fieldName),
                         fieldName,
@@ -843,10 +975,12 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
 
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                        interfaceName,
                         metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
-                        writer);
+                        writer
+                );
             }
         }
 
@@ -856,12 +990,13 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
     }
 
     private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
                 className,
                 "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JsonReader", "reader"),
-                Arrays.asList("IOException"));
+                Collections.singletonList("IOException"));
 
         writer.emitStatement("%s obj = realm.createObject(%s.class)",className, className);
         writer.emitStatement("reader.beginObject()");
@@ -875,20 +1010,23 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             String qualifiedFieldType = field.asType().toString();
 
             if (i == 0) {
-                writer.beginControlFlow("if (name.equals(\"%s\") && reader.peek() != JsonToken.NULL)", fieldName);
+                writer.beginControlFlow("if (name.equals(\"%s\"))", fieldName);
             } else {
-                writer.nextControlFlow("else if (name.equals(\"%s\")  && reader.peek() != JsonToken.NULL)", fieldName);
+                writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
             }
-            if (typeUtils.isAssignable(field.asType(), realmObject)) {
+            if (Utils.isRealmObject(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
+                        interfaceName,
                         metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
-                        writer);
+                        writer
+                );
 
-            } else if (typeUtils.isAssignable(field.asType(), realmList)) {
+            } else if (Utils.isRealmList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
+                        interfaceName,
                         metadata.getGetter(fieldName),
                         metadata.getSetter(fieldName),
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
@@ -897,10 +1035,12 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
 
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                        interfaceName,
                         metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
-                        writer);
+                        writer
+                );
             }
         }
 
@@ -916,7 +1056,15 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private String staticFieldIndexVarName(VariableElement variableElement) {
-        return "INDEX_" + variableElement.getSimpleName().toString().toUpperCase();
+    private String columnInfoClassName() {
+        return className + "ColumnInfo";
+    }
+
+    private String columnIndexVarName(VariableElement variableElement) {
+        return variableElement.getSimpleName().toString() + "Index";
+    }
+
+    private String fieldIndexVariableReference(VariableElement variableElement) {
+        return "columnInfo." + columnIndexVarName(variableElement);
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
new file mode 100644
index 0000000000..9613b09df9
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.EnumSet;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.tools.JavaFileObject;
+
+import io.realm.annotations.Ignore;
+
+public class RealmProxyInterfaceGenerator {
+    private ProcessingEnvironment processingEnvironment;
+    private ClassMetaData metaData;
+    private final String className;
+
+    public RealmProxyInterfaceGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metaData) {
+        this.processingEnvironment = processingEnvironment;
+        this.metaData = metaData;
+        this.className = metaData.getSimpleClassName();
+    }
+
+    public void generate() throws IOException {
+        String qualifiedGeneratedInterfaceName =
+                String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
+        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedInterfaceName);
+        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
+
+        writer.setIndent(Constants.INDENT);
+
+        writer
+                .emitPackage(Constants.REALM_PACKAGE_NAME)
+                .emitEmptyLine()
+                .beginType(qualifiedGeneratedInterfaceName, "interface", EnumSet.of(Modifier.PUBLIC));
+        for (VariableElement field : metaData.getFields()) {
+            // The field is neither static nor ignored
+            if (!field.getModifiers().contains(Modifier.STATIC) && field.getAnnotation(Ignore.class) == null) {
+                String fieldName = field.getSimpleName().toString();
+                String fieldTypeCanonicalName = field.asType().toString();
+                writer
+                        .beginMethod(
+                                fieldTypeCanonicalName,
+                                metaData.getGetter(fieldName),
+                                EnumSet.of(Modifier.PUBLIC))
+                        .endMethod()
+                        .beginMethod(
+                                "void",
+                                metaData.getSetter(fieldName),
+                                EnumSet.of(Modifier.PUBLIC),
+                                fieldTypeCanonicalName,
+                                "value")
+                        .endMethod();
+            }
+        }
+        writer.endType();
+        writer.close();
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
similarity index 81%
rename from realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index a8c6e56e82..28510955bd 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -31,7 +31,7 @@
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
-import io.realm.annotations.internal.RealmModule;
+import io.realm.annotations.RealmModule;
 
 public class RealmProxyMediatorGenerator {
     private final String className;
@@ -67,11 +67,13 @@ public void generate() throws IOException {
         writer.emitImports(
                 "android.util.JsonReader",
                 "java.io.IOException",
-                "java.util.ArrayList",
                 "java.util.Collections",
+                "java.util.HashMap",
+                "java.util.HashSet",
                 "java.util.List",
                 "java.util.Map",
-                "io.realm.exceptions.RealmException",
+                "java.util.Set",
+                "io.realm.internal.ColumnInfo",
                 "io.realm.internal.ImplicitTransaction",
                 "io.realm.internal.RealmObjectProxy",
                 "io.realm.internal.RealmProxyMediator",
@@ -88,7 +90,7 @@ public void generate() throws IOException {
                 qualifiedGeneratedClassName,        // full qualified name of the item to generate
                 "class",                            // the type of the item
                 Collections.<Modifier>emptySet(),   // modifiers to apply
-                "RealmProxyMediator");               // class to extend
+                "RealmProxyMediator");              // class to extend
         writer.emitEmptyLine();
 
         emitFields(writer);
@@ -98,23 +100,22 @@ public void generate() throws IOException {
         emitGetTableNameMethod(writer);
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
-        emitGetColumnIndices(writer);
         emitCopyToRealmMethod(writer);
         emitCreteOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
-
+        emitCreateDetachedCopyMethod(writer);
         writer.endType();
         writer.close();
     }
 
     private void emitFields(JavaWriter writer) throws IOException {
-        writer.emitField("List<Class<? extends RealmObject>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.emitField("Set<Class<? extends RealmObject>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
-        writer.emitStatement("List<Class<? extends RealmObject>> modelClasses = new ArrayList<Class<? extends RealmObject>>()");
+        writer.emitStatement("Set<Class<? extends RealmObject>> modelClasses = new HashSet<Class<? extends RealmObject>>()");
         for (String clazz : simpleModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
-        writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableList(modelClasses)");
+        writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableSet(modelClasses)");
         writer.endInitializer();
         writer.emitEmptyLine();
     }
@@ -140,7 +141,7 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "void",
+                "ColumnInfo",
                 "validateTable",
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmObject>", "clazz", "ImplicitTransaction", "transaction"
@@ -148,7 +149,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.validateTable(transaction)", proxyClasses.get(i));
+                writer.emitStatement("return %s.validateTable(transaction)", proxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -197,12 +198,12 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
                 "<E extends RealmObject> E",
                 "newInstance",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<E>", "clazz"
+                "Class<E>", "clazz", "ColumnInfo", "columnInfo"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return (E) new %s()", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(new %s(columnInfo))", proxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -211,30 +212,12 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
 
     private void emitGetClassModelList(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
-        writer.beginMethod("List<Class<? extends RealmObject>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
+        writer.beginMethod("Set<Class<? extends RealmObject>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
         writer.emitStatement("return MODEL_CLASSES");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitGetColumnIndices(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "Map<String, Long>",
-                "getColumnIndices",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmObject>", "clazz"
-        );
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getColumnIndices()", proxyClasses.get(i));
-            }
-        }, writer, true);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
     private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
@@ -243,13 +226,14 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmObject, RealmObjectProxy>",  "cache"
         );
-
-        writer.emitStatement("Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
         writer.emitEmptyLine();
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return (E) %s.copyOrUpdate(realm, (%s) obj, update, cache)", proxyClasses.get(i), simpleModelClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", proxyClasses.get(i), simpleModelClasses.get(i));
             }
         }, writer, false);
         writer.endMethod();
@@ -268,7 +252,7 @@ private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcept
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return (E) %s.createOrUpdateUsingJsonObject(realm, json, update)", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", proxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -287,13 +271,36 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return (E) %s.createUsingJsonStream(realm, reader)", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", proxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
+    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmObject> E",
+                "createDetachedCopy",
+                EnumSet.of(Modifier.PUBLIC),
+                "E", "realmObject", "int", "maxDepth", "Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>>", "cache"
+        );
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass()");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
+                        proxyClasses.get(i), simpleModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     // Emits the control flow for selecting the appropriate proxy class based on the model class
     // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
     // Consider switching to HashMap or similar.
@@ -327,6 +334,6 @@ private String getProxyClassName(String clazz) {
     }
 
     private interface ProxySwitchStatement {
-        public void emitStatement(int i, JavaWriter writer) throws IOException;
+        void emitStatement(int i, JavaWriter writer) throws IOException;
     }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
similarity index 90%
rename from realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
index bfe92d41d2..09b7792bf0 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
@@ -30,6 +30,7 @@
 
     private static final String VERSION_URL = "http://static.realm.io/update/java?";
     private static final String REALM_VERSION = Version.VERSION;
+    private static final String REALM_VERSION_PATTERN = "\\d+\\.\\d+\\.\\d+";
     private static final int READ_TIMEOUT = 2000;
     private static final int CONNECT_TIMEOUT = 4000;
 
@@ -80,7 +81,11 @@ private String checkLatestVersion() {
             conn.setConnectTimeout(CONNECT_TIMEOUT);
             conn.setReadTimeout(READ_TIMEOUT);
             BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
-            result = rd.readLine();
+            String latestVersion = rd.readLine();
+            // if the obtained string does not match the pattern, we are in a separate network.
+            if (latestVersion.matches(REALM_VERSION_PATTERN)) {
+                result = latestVersion;
+            }
             rd.close();
         } catch (IOException e) {
             // We ignore this exception on purpose not to break the build system if this class fails
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
new file mode 100644
index 0000000000..ace661befe
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -0,0 +1,252 @@
+package io.realm.processor;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.List;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+import javax.xml.bind.DatatypeConverter;
+
+/**
+ * Utility methods working with the Realm processor.
+ */
+public class Utils {
+
+    public static Types typeUtils;
+    private static Messager messager;
+    private static DeclaredType realmList;
+    private static TypeMirror realmObject;
+
+    public static void initialize(ProcessingEnvironment env) {
+        typeUtils = env.getTypeUtils();
+        messager = env.getMessager();
+        realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
+                typeUtils.getWildcardType(null, null));
+        realmObject = env.getElementUtils().getTypeElement("io.realm.RealmObject").asType();
+    }
+
+    /**
+     * @return true if the given element is the default public no arg constructor for a class.
+     */
+    public static boolean isDefaultConstructor(Element constructor) {
+        if (constructor.getModifiers().contains(Modifier.PUBLIC)) {
+            return ((ExecutableElement) constructor).getParameters().isEmpty();
+        }
+        return false;
+    }
+
+    public static String lowerFirstChar(String input) {
+        return input.substring(0, 1).toLowerCase() + input.substring(1);
+    }
+
+    public static String getProxyClassSimpleName(VariableElement field) {
+        if (typeUtils.isAssignable(field.asType(), realmList)) {
+            return getProxyClassName(getGenericType(field));
+        } else {
+            return getProxyClassName(getFieldTypeSimpleName(field));
+        }
+    }
+
+    /**
+     * @return the proxy class name for a given clazz
+     */
+    public static String getProxyClassName(String clazz) {
+        return clazz + Constants.PROXY_SUFFIX;
+    }
+
+    /**
+     * @return {@code true} if a field is of type "java.lang.String", {@code false} otherwise.
+     * @throws IllegalArgumentException if the field is {@code null}.
+     */
+    public static boolean isString(VariableElement field) {
+        if (field == null) {
+            throw new IllegalArgumentException("Argument 'field' cannot be null.");
+        }
+        return getFieldTypeSimpleName(field).equals("String");
+    }
+
+    /**
+     * @return {@code true} if a field is a primitive type, {@code false} otherwise.
+     * @throws IllegalArgumentException if the typeString is {@code null}.
+     */
+    public static boolean isPrimitiveType(String typeString) {
+        if (typeString == null) {
+            throw new IllegalArgumentException("Argument 'typeString' cannot be null.");
+        }
+        return typeString.equals("byte") || typeString.equals("short") || typeString.equals("int") ||
+                typeString.equals("long") || typeString.equals("float") || typeString.equals("double") ||
+                typeString.equals("boolean") || typeString.equals("char");
+    }
+
+    /**
+     * @return {@code true} if a field is a boxed type, {@code false} otherwise.
+     * @throws IllegalArgumentException if the typeString is {@code null}.
+     */
+    public static boolean isBoxedType(String typeString) {
+        if (typeString == null) {
+            throw new IllegalArgumentException("Argument 'typeString' cannot be null.");
+        }
+        return typeString.equals(Byte.class.getName()) || typeString.equals(Short.class.getName()) ||
+                typeString.equals(Integer.class.getName()) || typeString.equals(Long.class.getName()) ||
+                typeString.equals(Float.class.getName()) || typeString.equals(Double.class.getName()) ||
+                typeString.equals(Boolean.class.getName());
+    }
+
+    /**
+     * @return {@code true} if a field is a type of primitive types, {@code false} otherwise.
+     * @throws IllegalArgumentException if the field is {@code null}.
+     */
+    public static boolean isPrimitiveType(VariableElement field) {
+        if (field == null) {
+            throw new IllegalArgumentException("Argument 'field' cannot be null.");
+        }
+        return field.asType().getKind().isPrimitive();
+    }
+
+    /**
+     * @return {@code true} if a field is of type "byte[]", {@code false} otherwise.
+     * @throws IllegalArgumentException if the field is {@code null}.
+     */
+    public static boolean isByteArray(VariableElement field) {
+        if (field == null) {
+            throw new IllegalArgumentException("Argument 'field' cannot be null.");
+        }
+        return getFieldTypeSimpleName(field).equals("byte[]");
+    }
+
+    /**
+     * @return {@code true} if a given field type string is "java.lang.String", {@code false} otherwise.
+     * @throws IllegalArgumentException if the fieldType is {@code null}.
+     */
+    public static boolean isString(String fieldType) {
+        if (fieldType == null) {
+            throw new IllegalArgumentException("Argument 'fieldType' cannot be null.");
+        }
+        return String.class.getName().equals(fieldType);
+    }
+
+    /**
+     * @return {@code true} if a given field type is "RealmList", {@code false} otherwise.
+     */
+    public static boolean isRealmList(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmList);
+    }
+
+    /**
+     * @return {@code true} if a given field type is "RealmObject", {@code false} otherwise.
+     */
+    public static boolean isRealmObject(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmObject);
+    }
+
+    /**
+     * @return the simple type name for a field.
+     */
+    public static String getFieldTypeSimpleName(VariableElement field) {
+        String fieldTypeCanonicalName = field.asType().toString();
+        String fieldTypeName;
+        if (fieldTypeCanonicalName.contains(".")) {
+            fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
+        } else {
+            fieldTypeName = fieldTypeCanonicalName;
+        }
+        return fieldTypeName;
+    }
+
+    /**
+     * @return the generic type for Lists of the form {@code List<type>}
+     */
+    public static String getGenericType(VariableElement field) {
+        TypeMirror fieldType = field.asType();
+        List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
+        if (typeArguments.size() == 0) {
+            return null;
+        }
+        String genericCanonicalType = (String) typeArguments.get(0).toString();
+        String genericType;
+        if (genericCanonicalType.contains(".")) {
+            genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
+        } else {
+            genericType = genericCanonicalType;
+        }
+        return genericType;
+    }
+
+    /**
+     * Strips the package name from a fully qualified class name.
+     */
+    public static String stripPackage(String fullyQualifiedClassName) {
+        String[] parts = fullyQualifiedClassName.split("\\.");
+        if (parts.length > 0) {
+            return parts[parts.length - 1];
+        } else {
+            return fullyQualifiedClassName;
+        }
+    }
+
+    public static void error(String message, Element element) {
+        messager.printMessage(Diagnostic.Kind.ERROR, message, element);
+    }
+
+    public static void error(String message) {
+        messager.printMessage(Diagnostic.Kind.ERROR, message);
+    }
+
+    public static void note(String message) {
+        messager.printMessage(Diagnostic.Kind.NOTE, message);
+    }
+
+    public static Element getSuperClass(TypeElement classType) {
+        return typeUtils.asElement(classType.getSuperclass());
+    }
+
+    /**
+     * Encode the given string with Base64
+     * @param data the string to encode
+     * @return the encoded string
+     * @throws UnsupportedEncodingException
+     */
+    public static String base64Encode(String data) throws UnsupportedEncodingException {
+        return DatatypeConverter.printBase64Binary(data.getBytes("UTF-8"));
+    }
+
+    /**
+     * Compute the SHA-256 hash of the given byte array
+     * @param data the byte array to hash
+     * @return the hashed byte array
+     * @throws NoSuchAlgorithmException
+     */
+    public static byte[] sha256Hash(byte[] data) throws NoSuchAlgorithmException {
+        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+        return messageDigest.digest(data);
+    }
+
+    /**
+     * Convert a byte array to its hex-string
+     * @param data the byte array to convert
+     * @return the hex-string of the byte array
+     */
+    public static String hexStringify(byte[] data) {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (byte singleByte : data) {
+            stringBuilder.append(Integer.toString((singleByte & 0xff) + 0x100, 16).substring(1));
+        }
+
+        return stringBuilder.toString();
+    }
+
+    public static String getProxyInterfaceName(String className) {
+        return className + Constants.INTERFACE_SUFFIX;
+    }
+}
diff --git a/realm-annotations-processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/realm/realm-annotations-processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor
similarity index 100%
rename from realm-annotations-processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor
rename to realm/realm-annotations-processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor
diff --git a/realm/realm-annotations-processor/src/main/templates/Version.java b/realm/realm-annotations-processor/src/main/templates/Version.java
new file mode 100644
index 0000000000..2f0fbc75f9
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/templates/Version.java
@@ -0,0 +1,5 @@
+package io.realm.processor;
+
+public class Version {
+    public static final String VERSION = "@version@";
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
new file mode 100644
index 0000000000..b7b8f064b0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -0,0 +1,389 @@
+/*
+ * Copyright 2014-2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import javax.tools.JavaFileObject;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+public class RealmProcessorTest {
+
+    private JavaFileObject simpleModel = JavaFileObjects.forResource("some/test/Simple.java");
+    private JavaFileObject simpleProxy = JavaFileObjects.forResource("io/realm/SimpleRealmProxy.java");
+    private JavaFileObject allTypesModel = JavaFileObjects.forResource("some/test/AllTypes.java");
+    private JavaFileObject allTypesProxy = JavaFileObjects.forResource("io/realm/AllTypesRealmProxy.java");
+    private JavaFileObject allTypesDefaultModule = JavaFileObjects.forResource("io/realm/RealmDefaultModule.java");
+    private JavaFileObject allTypesDefaultMediator = JavaFileObjects.forResource("io/realm/RealmDefaultModuleMediator.java");
+    private JavaFileObject booleansModel = JavaFileObjects.forResource("some/test/Booleans.java");
+    private JavaFileObject booleansProxy = JavaFileObjects.forResource("io/realm/BooleansRealmProxy.java");
+    private JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
+    private JavaFileObject finalModel = JavaFileObjects.forResource("some/test/Final.java");
+    private JavaFileObject transientModel = JavaFileObjects.forResource("some/test/Transient.java");
+    private JavaFileObject volatileModel = JavaFileObjects.forResource("some/test/Volatile.java");
+    private JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
+    private JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
+    private JavaFileObject nullTypesModel = JavaFileObjects.forResource("some/test/NullTypes.java");
+    private JavaFileObject nullTypesProxy = JavaFileObjects.forResource("io/realm/NullTypesRealmProxy.java");
+    private JavaFileObject missingGenericTypeModel = JavaFileObjects.forResource("some/test/MissingGenericType.java");
+    private JavaFileObject conflictingFieldNameModel = JavaFileObjects.forResource("some/test/ConflictingFieldName.java");
+
+    @Test
+    public void compileSimpleFile() {
+        ASSERT.about(javaSource())
+                .that(simpleModel)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileProcessedSimpleFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(simpleModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileProcessedEmptyFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(emptyModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    // Disabled because it does not seem to find the generated interface file @Test
+    public void compileSimpleProxyFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(simpleProxy)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compareProcessedSimpleFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(simpleModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(simpleProxy);
+    }
+
+    @Test
+    public void compileProcessedNullTypesFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(nullTypesModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compareProcessedNullTypesFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(nullTypesModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(nullTypesProxy);
+    }
+
+    @Test
+    public void compileAllTypesFile() {
+        ASSERT.about(javaSource())
+                .that(allTypesModel)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileProcessedAllTypesFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(allTypesModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileAllTypesProxyFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(allTypesModel)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compareProcessedAllTypesFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(allTypesModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(allTypesDefaultMediator, allTypesDefaultModule,
+                        allTypesDefaultMediator, allTypesProxy);
+    }
+
+    @Test
+    public void compileAppModuleCustomClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleCustomClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileAppModuleAllClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleAllClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileLibraryModulesAllClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleAllClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileLibraryModulesCustomClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleCustomClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileAppModuleMixedParametersFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleMixedParameters.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileAppModuleWrongTypeFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleWrongType.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileLibraryModuleMixedParametersFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleMixedParameters.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileLibraryModuleWrongTypeFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleWrongType.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileBooleanFile() {
+        ASSERT.about(javaSource())
+                .that(booleansModel)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileProcessedBooleansFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(booleansModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileBooleansProxyFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(booleansModel)
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compareProcessedBooleansFile() throws Exception {
+        ASSERT.about(javaSource())
+                .that(booleansModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError()
+                .and()
+                .generatesSources(booleansProxy);
+    }
+
+    @Test
+    public void compileMissingGenericType() {
+        ASSERT.about(javaSource())
+                .that(missingGenericTypeModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    // Disabled because it does not seem to find the generated Interface file @Test
+    public void compileFieldNamesFiles() {
+        ASSERT.about(javaSource())
+                .that(fieldNamesModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileCustomAccessor() {
+        ASSERT.about(javaSource())
+                .that(customAccessorModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    // Supported "Index" annotation types
+    @Test
+    public void compileIndexTypes() throws IOException {
+        final String[] validIndexFieldTypes = {"byte", "short", "int", "long", "boolean", "String", "java.util.Date",
+                "Byte", "Short", "Integer", "Long", "Boolean"};
+
+        for (String fieldType : validIndexFieldTypes) {
+            TestRealmObjectFileObject javaFileObject =
+                    TestRealmObjectFileObject.getSingleFieldInstance("ValidIndexType", "Index", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .compilesWithoutError();
+        }
+    }
+
+    // Unsupported "Index" annotation types
+    @Test
+    public void compileInvalidIndexTypes() throws IOException {
+        final String[] invalidIndexFieldTypes = {"float", "double", "byte[]", "Simple", "RealmList", "Float", "Double"};
+
+        for (String fieldType : invalidIndexFieldTypes) {
+            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
+                    "InvalidIndexType", "Index", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .failsToCompile();
+        }
+    }
+
+    // Supported "PrimaryKey" annotation types
+    @Test
+    public void compilePrimaryKeyTypes() throws IOException {
+        final String[] validPrimaryKeyFieldTypes = {"byte", "short", "int", "long", "String", "Byte", "Short", "Integer", "Long"};
+
+        for (String fieldType : validPrimaryKeyFieldTypes) {
+            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
+                    "ValidPrimaryKeyType", "PrimaryKey", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .compilesWithoutError();
+        }
+    }
+
+    // Unsupported "PrimaryKey" annotation types
+    @Test
+    public void compileInvalidPrimaryKeyTypes() throws IOException {
+        final String[] invalidPrimaryKeyFieldTypes = {"boolean", "java.util.Date", "Simple", "RealmList<Simple>", "Boolean"};
+
+        for (String fieldType : invalidPrimaryKeyFieldTypes) {
+            TestRealmObjectFileObject javaFileObject =
+                    TestRealmObjectFileObject.getSingleFieldInstance(
+                            "InvalidPrimaryKeyType", "PrimaryKey", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .failsToCompile();
+        }
+    }
+
+    // Supported "Required" annotation types
+    @Test
+    public void compileRequiredTypes() throws IOException {
+        final String[] validPrimaryKeyFieldTypes = {"Byte", "Short", "Integer", "Long", "String",
+                "Float", "Double", "Boolean", "java.util.Date"};
+
+        for (String fieldType : validPrimaryKeyFieldTypes) {
+            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
+                    "ValidPrimaryKeyType", "Required", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .compilesWithoutError();
+        }
+    }
+
+    // Not supported "Required" annotation types
+    @Test
+    public void compileInvalidRequiredTypes() throws IOException {
+        final String[] validPrimaryKeyFieldTypes = {"byte", "short", "int", "long", "float", "double",
+                "boolean", "RealmList<Simple>", "Simple"};
+
+        for (String fieldType : validPrimaryKeyFieldTypes) {
+            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
+                    "ValidPrimaryKeyType", "Required", fieldType, "testField");
+            ASSERT.about(javaSource())
+                    .that(javaFileObject)
+                    .processedWith(new RealmProcessor())
+                    .failsToCompile();
+        }
+    }
+
+    @Test
+    public void compileConflictingFieldName() throws Exception {
+        ASSERT.about(javaSource())
+                .that(conflictingFieldNameModel)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failOnFinalFields() throws Exception {
+        ASSERT.about(javaSource())
+                .that(finalModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void failOnTransientFields() throws Exception {
+        ASSERT.about(javaSource())
+                .that(transientModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void failOnVolatileFields() throws Exception {
+        ASSERT.about(javaSource())
+                .that(volatileModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java
new file mode 100644
index 0000000000..60114a4e07
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.net.URI;
+import java.util.EnumSet;
+
+import javax.lang.model.element.Modifier;
+import javax.tools.SimpleJavaFileObject;
+
+// Helper class for creating RealmObject java files
+public class TestRealmObjectFileObject extends SimpleJavaFileObject {
+    private StringWriter stringWriter;
+
+    private TestRealmObjectFileObject(String name, StringWriter stringWriter) {
+        super(URI.create(name + ".java"), Kind.SOURCE);
+        this.stringWriter = stringWriter;
+    }
+
+    @Override
+    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+        return stringWriter.getBuffer();
+    }
+
+    // Helper function to create a Realm object java file with a single field.
+    public static TestRealmObjectFileObject getSingleFieldInstance(String className,
+                                                            String annotationToField,
+                                                            String fieldType,
+                                                            String fieldName) throws IOException {
+        String FieldName = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1, fieldName.length());
+        StringWriter stringWriter = new StringWriter();
+        JavaWriter writer = new JavaWriter(stringWriter);
+
+        // Package name
+        writer.emitPackage("some.test");
+
+        // Import Realm classes
+        writer.emitImports("io.realm.*");
+        writer.emitImports("io.realm.annotations.*");
+
+        // Begin the class definition
+        writer.beginType(
+                className, // full qualified name of the item to generate
+                "class",                     // the type of the item
+                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
+                "RealmObject")                   // class to extend
+                .emitEmptyLine();
+
+        // Declaration of field
+        writer.emitAnnotation(annotationToField);
+        writer.emitField(fieldType, fieldName, EnumSet.of(Modifier.PRIVATE));
+
+        // Getter
+        writer.beginMethod(
+                fieldType, // Return type
+                "get" + FieldName, // Method name
+                EnumSet.of(Modifier.PUBLIC)); // Modifiers
+        writer.emitStatement("return realmGet$" +  fieldName + "()");
+        writer.endMethod();
+
+        // Setter
+        writer.beginMethod(
+                "void", // Return type
+                "set"+ FieldName, // Method name
+                EnumSet.of(Modifier.PUBLIC),
+                fieldType, fieldName); // Modifiers
+        writer.emitStatement("realmSet$" + fieldName + "(" + fieldName + ")");
+        writer.endMethod();
+
+        // Realm Getter
+        writer.beginMethod(
+                fieldType, // Return type
+                "realmGet$" + fieldName, // Method name
+                EnumSet.of(Modifier.PUBLIC)); // Modifiers
+        writer.emitStatement("return " +  fieldName);
+        writer.endMethod();
+
+        // Realm Setter
+        writer.beginMethod(
+                "void", // Return type
+                "realmSet$"+ fieldName, // Method name
+                EnumSet.of(Modifier.PUBLIC),
+                fieldType, fieldName); // Modifiers
+        writer.emitStatement("this." + fieldName + "=" + fieldName);
+        writer.endMethod();
+
+        writer.endType();
+
+        return new TestRealmObjectFileObject(className, stringWriter);
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
new file mode 100644
index 0000000000..a0f31d9152
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -0,0 +1,803 @@
+package io.realm;
+
+
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.android.JsonUtils;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import some.test.AllTypes;
+
+public class AllTypesRealmProxy extends AllTypes
+    implements RealmObjectProxy, AllTypesRealmProxyInterface {
+
+    static final class AllTypesColumnInfo extends ColumnInfo {
+
+        public final long columnStringIndex;
+        public final long columnLongIndex;
+        public final long columnFloatIndex;
+        public final long columnDoubleIndex;
+        public final long columnBooleanIndex;
+        public final long columnDateIndex;
+        public final long columnBinaryIndex;
+        public final long columnObjectIndex;
+        public final long columnRealmListIndex;
+
+        AllTypesColumnInfo(String path, Table table) {
+            final Map<String, Long> indicesMap = new HashMap<String, Long>(9);
+            this.columnStringIndex = getValidColumnIndex(path, table, "AllTypes", "columnString");
+            indicesMap.put("columnString", this.columnStringIndex);
+
+            this.columnLongIndex = getValidColumnIndex(path, table, "AllTypes", "columnLong");
+            indicesMap.put("columnLong", this.columnLongIndex);
+
+            this.columnFloatIndex = getValidColumnIndex(path, table, "AllTypes", "columnFloat");
+            indicesMap.put("columnFloat", this.columnFloatIndex);
+
+            this.columnDoubleIndex = getValidColumnIndex(path, table, "AllTypes", "columnDouble");
+            indicesMap.put("columnDouble", this.columnDoubleIndex);
+
+            this.columnBooleanIndex = getValidColumnIndex(path, table, "AllTypes", "columnBoolean");
+            indicesMap.put("columnBoolean", this.columnBooleanIndex);
+
+            this.columnDateIndex = getValidColumnIndex(path, table, "AllTypes", "columnDate");
+            indicesMap.put("columnDate", this.columnDateIndex);
+
+            this.columnBinaryIndex = getValidColumnIndex(path, table, "AllTypes", "columnBinary");
+            indicesMap.put("columnBinary", this.columnBinaryIndex);
+
+            this.columnObjectIndex = getValidColumnIndex(path, table, "AllTypes", "columnObject");
+            indicesMap.put("columnObject", this.columnObjectIndex);
+
+            this.columnRealmListIndex = getValidColumnIndex(path, table, "AllTypes", "columnRealmList");
+            indicesMap.put("columnRealmList", this.columnRealmListIndex);
+
+            setIndicesMap(indicesMap);
+        }
+    }
+
+    private final AllTypesColumnInfo columnInfo;
+    private RealmList<AllTypes> columnRealmListRealmList;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("columnString");
+        fieldNames.add("columnLong");
+        fieldNames.add("columnFloat");
+        fieldNames.add("columnDouble");
+        fieldNames.add("columnBoolean");
+        fieldNames.add("columnDate");
+        fieldNames.add("columnBinary");
+        fieldNames.add("columnObject");
+        fieldNames.add("columnRealmList");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
+    AllTypesRealmProxy(ColumnInfo columnInfo) {
+        this.columnInfo = (AllTypesColumnInfo) columnInfo;
+    }
+
+    @SuppressWarnings("cast")
+    public String realmGet$columnString() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.columnStringIndex);
+    }
+
+    public void realmSet$columnString(String value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field columnString to null.");
+        }
+        ((RealmObject) this).row.setString(columnInfo.columnStringIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public long realmGet$columnLong() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (long) ((RealmObject) this).row.getLong(columnInfo.columnLongIndex);
+    }
+
+    public void realmSet$columnLong(long value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setLong(columnInfo.columnLongIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public float realmGet$columnFloat() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (float) ((RealmObject) this).row.getFloat(columnInfo.columnFloatIndex);
+    }
+
+    public void realmSet$columnFloat(float value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setFloat(columnInfo.columnFloatIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public double realmGet$columnDouble() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (double) ((RealmObject) this).row.getDouble(columnInfo.columnDoubleIndex);
+    }
+
+    public void realmSet$columnDouble(double value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setDouble(columnInfo.columnDoubleIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public boolean realmGet$columnBoolean() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.columnBooleanIndex);
+    }
+
+    public void realmSet$columnBoolean(boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setBoolean(columnInfo.columnBooleanIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Date realmGet$columnDate() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.columnDateIndex);
+    }
+
+    public void realmSet$columnDate(Date value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field columnDate to null.");
+        }
+        ((RealmObject) this).row.setDate(columnInfo.columnDateIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public byte[] realmGet$columnBinary() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.columnBinaryIndex);
+    }
+
+    public void realmSet$columnBinary(byte[] value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field columnBinary to null.");
+        }
+        ((RealmObject) this).row.setBinaryByteArray(columnInfo.columnBinaryIndex, value);
+    }
+
+    public AllTypes realmGet$columnObject() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNullLink(columnInfo.columnObjectIndex)) {
+            return null;
+        }
+        return ((RealmObject) this).realm.get(some.test.AllTypes.class, ((RealmObject) this).row.getLink(columnInfo.columnObjectIndex));
+    }
+
+    public void realmSet$columnObject(AllTypes value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.nullifyLink(columnInfo.columnObjectIndex);
+            return;
+        }
+        if (!value.isValid()) {
+            throw new IllegalArgumentException("'value' is not a valid managed object.");
+        }
+        if (value.realm != this.realm) {
+            throw new IllegalArgumentException("'value' belongs to a different Realm.");
+        }
+        ((RealmObject) this).row.setLink(columnInfo.columnObjectIndex, ((RealmObject) value).row.getIndex());
+    }
+
+    public RealmList<AllTypes> realmGet$columnRealmList() {
+        ((RealmObject) this).realm.checkIfValid();
+        // use the cached value if available
+        if (columnRealmListRealmList != null) {
+            return columnRealmListRealmList;
+        } else {
+            LinkView linkView = ((RealmObject) this).row.getLinkList(columnInfo.columnRealmListIndex);
+            columnRealmListRealmList = new RealmList<AllTypes>(AllTypes.class, linkView, realm);
+            return columnRealmListRealmList;
+        }
+    }
+
+    public void realmSet$columnRealmList(RealmList<AllTypes> value) {
+        ((RealmObject) this).realm.checkIfValid();
+        LinkView links = ((RealmObject) this).row.getLinkList(columnInfo.columnRealmListIndex);
+        links.clear();
+        if (value == null) {
+            return;
+        }
+        for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value) {
+            if (!linkedObject.isValid()) {
+                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
+            }
+            if (linkedObject.realm != this.realm) {
+                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
+            }
+            links.add(((RealmObject) linkedObject).row.getIndex());
+        }
+    }
+
+    public static Table initTable(ImplicitTransaction transaction) {
+        if (!transaction.hasTable("class_AllTypes")) {
+            Table table = transaction.getTable("class_AllTypes");
+            table.addColumn(RealmFieldType.STRING, "columnString", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.DOUBLE, "columnDouble", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "columnBoolean", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.DATE, "columnDate", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BINARY, "columnBinary", Table.NOT_NULLABLE);
+            if (!transaction.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(transaction);
+            }
+            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", transaction.getTable("class_AllTypes"));
+            if (!transaction.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(transaction);
+            }
+            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", transaction.getTable("class_AllTypes"));
+            table.addSearchIndex(table.getColumnIndex("columnString"));
+            table.setPrimaryKey("columnString");
+            return table;
+        }
+        return transaction.getTable("class_AllTypes");
+    }
+
+    public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction) {
+        if (transaction.hasTable("class_AllTypes")) {
+            Table table = transaction.getTable("class_AllTypes");
+            if (table.getColumnCount() != 9) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 9 but was " + table.getColumnCount());
+            }
+            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+            for (long i = 0; i < 9; i++) {
+                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            }
+
+            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(transaction.getPath(), table);
+
+            if (!columnTypes.containsKey("columnString")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnString") != RealmFieldType.STRING) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnStringIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnString' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnString' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
+            }
+            if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
+            }
+            if (!columnTypes.containsKey("columnLong")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnLongIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnFloat")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnDouble")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnBoolean")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnDate")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnDateIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnBinary")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("columnObject")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
+            }
+            if (!transaction.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
+            }
+            Table table_7 = transaction.getTable("class_AllTypes");
+            if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+            }
+            if (!columnTypes.containsKey("columnRealmList")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
+            }
+            if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
+            }
+            if (!transaction.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
+            }
+            Table table_8 = transaction.getTable("class_AllTypes");
+            if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+            }
+            return columnInfo;
+        } else {
+            throw new RealmMigrationNeededException(transaction.getPath(), "The AllTypes class is missing from the schema for this Realm.");
+        }
+    }
+
+    public static String getTableName() {
+        return "class_AllTypes";
+    }
+
+    public static List<String> getFieldNames() {
+        return FIELD_NAMES;
+    }
+
+    @SuppressWarnings("cast")
+    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        AllTypes obj = null;
+        if (update) {
+            Table table = realm.getTable(AllTypes.class);
+            long pkColumnIndex = table.getPrimaryKey();
+            if (!json.isNull("columnString")) {
+                long rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
+                if (rowIndex != TableOrView.NO_MATCH) {
+                    obj = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
+                    ((RealmObject) obj).realm = realm;
+                    ((RealmObject) obj).row = table.getUncheckedRow(rowIndex);
+                }
+            }
+        }
+        if (obj == null) {
+            if (json.has("columnString")) {
+                if (json.isNull("columnString")) {
+                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, null);
+                } else {
+                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, json.getString("columnString"));
+                }
+            } else {
+                obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class);
+            }
+        }
+        if (json.has("columnString")) {
+            if (json.isNull("columnString")) {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) json.getString("columnString"));
+            }
+        }
+        if (json.has("columnLong")) {
+            if (json.isNull("columnLong")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) json.getLong("columnLong"));
+            }
+        }
+        if (json.has("columnFloat")) {
+            if (json.isNull("columnFloat")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) json.getDouble("columnFloat"));
+            }
+        }
+        if (json.has("columnDouble")) {
+            if (json.isNull("columnDouble")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) json.getDouble("columnDouble"));
+            }
+        }
+        if (json.has("columnBoolean")) {
+            if (json.isNull("columnBoolean")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
+            }
+        }
+        if (json.has("columnDate")) {
+            if (json.isNull("columnDate")) {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+            } else {
+                Object timestamp = json.get("columnDate");
+                if (timestamp instanceof String) {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(json.getLong("columnDate")));
+                }
+            }
+        }
+        if (json.has("columnBinary")) {
+            if (json.isNull("columnBinary")) {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
+            }
+        }
+        if (json.has("columnObject")) {
+            if (json.isNull("columnObject")) {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+            } else {
+                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+            }
+        }
+        if (json.has("columnRealmList")) {
+            if (json.isNull("columnRealmList")) {
+                ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+            } else {
+                ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().clear();
+                JSONArray array = json.getJSONArray("columnRealmList");
+                for (int i = 0; i < array.length(); i++) {
+                    some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
+                    ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                }
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        AllTypes obj = realm.createObject(AllTypes.class);
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("columnString")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) reader.nextString());
+                }
+            } else if (name.equals("columnLong")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) reader.nextLong());
+                }
+            } else if (name.equals("columnFloat")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) reader.nextDouble());
+                }
+            } else if (name.equals("columnDouble")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) reader.nextDouble());
+                }
+            } else if (name.equals("columnBoolean")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("columnDate")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+                } else if (reader.peek() == JsonToken.NUMBER) {
+                    long timestamp = reader.nextLong();
+                    if (timestamp > -1) {
+                        ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(timestamp));
+                    }
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
+                }
+            } else if (name.equals("columnBinary")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+                } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
+                }
+            } else if (name.equals("columnObject")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+                } else {
+                    some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+                }
+            } else if (name.equals("columnRealmList")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+                } else {
+                    reader.beginArray();
+                    while (reader.hasNext()) {
+                        some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
+                        ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                    }
+                    reader.endArray();
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return obj;
+    }
+
+    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+            return object;
+        }
+        AllTypes realmObject = null;
+        boolean canUpdate = update;
+        if (canUpdate) {
+            Table table = realm.getTable(AllTypes.class);
+            long pkColumnIndex = table.getPrimaryKey();
+            if (((AllTypesRealmProxyInterface) object).realmGet$columnString() == null) {
+                throw new IllegalArgumentException("Primary key value must not be null.");
+            }
+            long rowIndex = table.findFirstString(pkColumnIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnString());
+            if (rowIndex != TableOrView.NO_MATCH) {
+                realmObject = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
+                ((RealmObject) realmObject).realm = realm;
+                ((RealmObject) realmObject).row = table.getUncheckedRow(rowIndex);
+                cache.put(object, (RealmObjectProxy) realmObject);
+            } else {
+                canUpdate = false;
+            }
+        }
+
+        if (canUpdate) {
+            return update(realm, realmObject, object, cache);
+        } else {
+            return copy(realm, object, update, cache);
+        }
+    }
+
+    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        AllTypes realmObject = realm.createObject(AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+        if (columnObjectObj != null) {
+            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
+            if (cachecolumnObject != null) {
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
+            } else {
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+            }
+        } else {
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
+        }
+
+        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        if (columnRealmListList != null) {
+            RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+            for (int i = 0; i < columnRealmListList.size(); i++) {
+                AllTypes columnRealmListItem = columnRealmListList.get(i);
+                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
+                if (cachecolumnRealmList != null) {
+                    columnRealmListRealmList.add(cachecolumnRealmList);
+                } else {
+                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
+                }
+            }
+        }
+
+        return realmObject;
+    }
+
+    public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        AllTypes standaloneObject;
+        if (cachedObject != null) {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (AllTypes)cachedObject.object;
+            } else {
+                standaloneObject = (AllTypes)cachedObject.object;
+                cachedObject.minDepth = currentDepth;
+            }
+        } else {
+            standaloneObject = new AllTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+        }
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
+
+        // Deep copy of columnObject
+        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
+
+        // Deep copy of columnRealmList
+        if (currentDepth == maxDepth) {
+            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(null);
+        } else {
+            RealmList<AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+            RealmList<AllTypes> standalonecolumnRealmListList = new RealmList<AllTypes>();
+            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(standalonecolumnRealmListList);
+            int nextDepth = currentDepth + 1;
+            int size = managedcolumnRealmListList.size();
+            for (int i = 0; i < size; i++) {
+                AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
+                standalonecolumnRealmListList.add(item);
+            }
+        }
+        return standaloneObject;
+    }
+
+    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmObject, RealmObjectProxy> cache) {
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+        AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+        if (columnObjectObj != null) {
+            AllTypes cachecolumnObject = (AllTypes) cache.get(columnObjectObj);
+            if (cachecolumnObject != null) {
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
+            } else {
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
+            }
+        } else {
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
+        }
+        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+        columnRealmListRealmList.clear();
+        if (columnRealmListList != null) {
+            for (int i = 0; i < columnRealmListList.size(); i++) {
+                AllTypes columnRealmListItem = columnRealmListList.get(i);
+                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
+                if (cachecolumnRealmList != null) {
+                    columnRealmListRealmList.add(cachecolumnRealmList);
+                } else {
+                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), true, cache));
+                }
+            }
+        }
+        return realmObject;
+    }
+
+    @Override
+    public String toString() {
+        if (!isValid()) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("AllTypes = [");
+        stringBuilder.append("{columnString:");
+        stringBuilder.append(realmGet$columnString());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnLong:");
+        stringBuilder.append(realmGet$columnLong());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnFloat:");
+        stringBuilder.append(realmGet$columnFloat());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDouble:");
+        stringBuilder.append(realmGet$columnDouble());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBoolean:");
+        stringBuilder.append(realmGet$columnBoolean());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDate:");
+        stringBuilder.append(realmGet$columnDate());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBinary:");
+        stringBuilder.append(realmGet$columnBinary());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnObject:");
+        stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnRealmList:");
+        stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = ((RealmObject) this).realm.getPath();
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        long rowIndex = ((RealmObject) this).row.getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        AllTypesRealmProxy aAllTypes = (AllTypesRealmProxy)o;
+
+        String path = ((RealmObject) this).realm.getPath();
+        String otherPath = ((RealmObject) aAllTypes).realm.getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        String otherTableName = ((RealmObject) aAllTypes).row.getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (((RealmObject) this).row.getIndex() != ((RealmObject) aAllTypes).row.getIndex()) return false;
+
+        return true;
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
new file mode 100644
index 0000000000..c87b718a67
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -0,0 +1,367 @@
+package io.realm;
+
+
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.android.JsonUtils;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import some.test.Booleans;
+
+public class BooleansRealmProxy extends Booleans
+    implements RealmObjectProxy, BooleansRealmProxyInterface {
+
+    static final class BooleansColumnInfo extends ColumnInfo {
+
+        public final long doneIndex;
+        public final long isReadyIndex;
+        public final long mCompletedIndex;
+        public final long anotherBooleanIndex;
+
+        BooleansColumnInfo(String path, Table table) {
+            final Map<String, Long> indicesMap = new HashMap<String, Long>(4);
+            this.doneIndex = getValidColumnIndex(path, table, "Booleans", "done");
+            indicesMap.put("done", this.doneIndex);
+
+            this.isReadyIndex = getValidColumnIndex(path, table, "Booleans", "isReady");
+            indicesMap.put("isReady", this.isReadyIndex);
+
+            this.mCompletedIndex = getValidColumnIndex(path, table, "Booleans", "mCompleted");
+            indicesMap.put("mCompleted", this.mCompletedIndex);
+
+            this.anotherBooleanIndex = getValidColumnIndex(path, table, "Booleans", "anotherBoolean");
+            indicesMap.put("anotherBoolean", this.anotherBooleanIndex);
+
+            setIndicesMap(indicesMap);
+        }
+    }
+
+    private final BooleansColumnInfo columnInfo;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("done");
+        fieldNames.add("isReady");
+        fieldNames.add("mCompleted");
+        fieldNames.add("anotherBoolean");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
+    BooleansRealmProxy(ColumnInfo columnInfo) {
+        this.columnInfo = (BooleansColumnInfo) columnInfo;
+    }
+
+    @SuppressWarnings("cast")
+    public boolean realmGet$done() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.doneIndex);
+    }
+
+    public void realmSet$done(boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setBoolean(columnInfo.doneIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public boolean realmGet$isReady() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.isReadyIndex);
+    }
+
+    public void realmSet$isReady(boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setBoolean(columnInfo.isReadyIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public boolean realmGet$mCompleted() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.mCompletedIndex);
+    }
+
+    public void realmSet$mCompleted(boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setBoolean(columnInfo.mCompletedIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public boolean realmGet$anotherBoolean() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.anotherBooleanIndex);
+    }
+
+    public void realmSet$anotherBoolean(boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setBoolean(columnInfo.anotherBooleanIndex, value);
+    }
+
+    public static Table initTable(ImplicitTransaction transaction) {
+        if (!transaction.hasTable("class_Booleans")) {
+            Table table = transaction.getTable("class_Booleans");
+            table.addColumn(RealmFieldType.BOOLEAN, "done", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "isReady", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "mCompleted", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "anotherBoolean", Table.NOT_NULLABLE);
+            table.setPrimaryKey("");
+            return table;
+        }
+        return transaction.getTable("class_Booleans");
+    }
+
+    public static BooleansColumnInfo validateTable(ImplicitTransaction transaction) {
+        if (transaction.hasTable("class_Booleans")) {
+            Table table = transaction.getTable("class_Booleans");
+            if (table.getColumnCount() != 4) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 4 but was " + table.getColumnCount());
+            }
+            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+            for (long i = 0; i < 4; i++) {
+                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            }
+
+            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(transaction.getPath(), table);
+
+            if (!columnTypes.containsKey("done")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.doneIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("isReady")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.isReadyIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("mCompleted")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("anotherBoolean")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            return columnInfo;
+        } else {
+            throw new RealmMigrationNeededException(transaction.getPath(), "The Booleans class is missing from the schema for this Realm.");
+        }
+    }
+
+    public static String getTableName() {
+        return "class_Booleans";
+    }
+
+    public static List<String> getFieldNames() {
+        return FIELD_NAMES;
+    }
+
+    @SuppressWarnings("cast")
+    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        Booleans obj = realm.createObject(Booleans.class);
+        if (json.has("done")) {
+            if (json.isNull("done")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+            } else {
+                ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) json.getBoolean("done"));
+            }
+        }
+        if (json.has("isReady")) {
+            if (json.isNull("isReady")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+            } else {
+                ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) json.getBoolean("isReady"));
+            }
+        }
+        if (json.has("mCompleted")) {
+            if (json.isNull("mCompleted")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+            } else {
+                ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
+            }
+        }
+        if (json.has("anotherBoolean")) {
+            if (json.isNull("anotherBoolean")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+            } else {
+                ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        Booleans obj = realm.createObject(Booleans.class);
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("done")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+                } else {
+                    ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("isReady")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+                } else {
+                    ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("mCompleted")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+                } else {
+                    ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("anotherBoolean")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+                } else {
+                    ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) reader.nextBoolean());
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return obj;
+    }
+
+    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+            return object;
+        }
+        return copy(realm, object, update, cache);
+    }
+
+    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        Booleans realmObject = realm.createObject(Booleans.class);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+        ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
+        ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
+        ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
+        ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
+        return realmObject;
+    }
+
+    public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        Booleans standaloneObject;
+        if (cachedObject != null) {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (Booleans)cachedObject.object;
+            } else {
+                standaloneObject = (Booleans)cachedObject.object;
+                cachedObject.minDepth = currentDepth;
+            }
+        } else {
+            standaloneObject = new Booleans();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+        }
+        ((BooleansRealmProxyInterface) standaloneObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
+        ((BooleansRealmProxyInterface) standaloneObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
+        ((BooleansRealmProxyInterface) standaloneObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
+        ((BooleansRealmProxyInterface) standaloneObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
+        return standaloneObject;
+    }
+
+    @Override
+    public String toString() {
+        if (!isValid()) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("Booleans = [");
+        stringBuilder.append("{done:");
+        stringBuilder.append(realmGet$done());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{isReady:");
+        stringBuilder.append(realmGet$isReady());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{mCompleted:");
+        stringBuilder.append(realmGet$mCompleted());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{anotherBoolean:");
+        stringBuilder.append(realmGet$anotherBoolean());
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = ((RealmObject) this).realm.getPath();
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        long rowIndex = ((RealmObject) this).row.getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        BooleansRealmProxy aBooleans = (BooleansRealmProxy)o;
+
+        String path = ((RealmObject) this).realm.getPath();
+        String otherPath = ((RealmObject) aBooleans).realm.getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        String otherTableName = ((RealmObject) aBooleans).row.getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (((RealmObject) this).row.getIndex() != ((RealmObject) aBooleans).row.getIndex()) return false;
+
+        return true;
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
new file mode 100644
index 0000000000..a096482d3a
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -0,0 +1,1297 @@
+package io.realm;
+
+
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.android.JsonUtils;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import some.test.NullTypes;
+
+public class NullTypesRealmProxy extends NullTypes
+    implements RealmObjectProxy, NullTypesRealmProxyInterface {
+
+    static final class NullTypesColumnInfo extends ColumnInfo {
+
+        public final long fieldStringNotNullIndex;
+        public final long fieldStringNullIndex;
+        public final long fieldBooleanNotNullIndex;
+        public final long fieldBooleanNullIndex;
+        public final long fieldBytesNotNullIndex;
+        public final long fieldBytesNullIndex;
+        public final long fieldByteNotNullIndex;
+        public final long fieldByteNullIndex;
+        public final long fieldShortNotNullIndex;
+        public final long fieldShortNullIndex;
+        public final long fieldIntegerNotNullIndex;
+        public final long fieldIntegerNullIndex;
+        public final long fieldLongNotNullIndex;
+        public final long fieldLongNullIndex;
+        public final long fieldFloatNotNullIndex;
+        public final long fieldFloatNullIndex;
+        public final long fieldDoubleNotNullIndex;
+        public final long fieldDoubleNullIndex;
+        public final long fieldDateNotNullIndex;
+        public final long fieldDateNullIndex;
+        public final long fieldObjectNullIndex;
+
+        NullTypesColumnInfo(String path, Table table) {
+            final Map<String, Long> indicesMap = new HashMap<String, Long>(21);
+            this.fieldStringNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNotNull");
+            indicesMap.put("fieldStringNotNull", this.fieldStringNotNullIndex);
+
+            this.fieldStringNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNull");
+            indicesMap.put("fieldStringNull", this.fieldStringNullIndex);
+
+            this.fieldBooleanNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNotNull");
+            indicesMap.put("fieldBooleanNotNull", this.fieldBooleanNotNullIndex);
+
+            this.fieldBooleanNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNull");
+            indicesMap.put("fieldBooleanNull", this.fieldBooleanNullIndex);
+
+            this.fieldBytesNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNotNull");
+            indicesMap.put("fieldBytesNotNull", this.fieldBytesNotNullIndex);
+
+            this.fieldBytesNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNull");
+            indicesMap.put("fieldBytesNull", this.fieldBytesNullIndex);
+
+            this.fieldByteNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNotNull");
+            indicesMap.put("fieldByteNotNull", this.fieldByteNotNullIndex);
+
+            this.fieldByteNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNull");
+            indicesMap.put("fieldByteNull", this.fieldByteNullIndex);
+
+            this.fieldShortNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNotNull");
+            indicesMap.put("fieldShortNotNull", this.fieldShortNotNullIndex);
+
+            this.fieldShortNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNull");
+            indicesMap.put("fieldShortNull", this.fieldShortNullIndex);
+
+            this.fieldIntegerNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNotNull");
+            indicesMap.put("fieldIntegerNotNull", this.fieldIntegerNotNullIndex);
+
+            this.fieldIntegerNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNull");
+            indicesMap.put("fieldIntegerNull", this.fieldIntegerNullIndex);
+
+            this.fieldLongNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNotNull");
+            indicesMap.put("fieldLongNotNull", this.fieldLongNotNullIndex);
+
+            this.fieldLongNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNull");
+            indicesMap.put("fieldLongNull", this.fieldLongNullIndex);
+
+            this.fieldFloatNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNotNull");
+            indicesMap.put("fieldFloatNotNull", this.fieldFloatNotNullIndex);
+
+            this.fieldFloatNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNull");
+            indicesMap.put("fieldFloatNull", this.fieldFloatNullIndex);
+
+            this.fieldDoubleNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNotNull");
+            indicesMap.put("fieldDoubleNotNull", this.fieldDoubleNotNullIndex);
+
+            this.fieldDoubleNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNull");
+            indicesMap.put("fieldDoubleNull", this.fieldDoubleNullIndex);
+
+            this.fieldDateNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNotNull");
+            indicesMap.put("fieldDateNotNull", this.fieldDateNotNullIndex);
+
+            this.fieldDateNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNull");
+            indicesMap.put("fieldDateNull", this.fieldDateNullIndex);
+
+            this.fieldObjectNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldObjectNull");
+            indicesMap.put("fieldObjectNull", this.fieldObjectNullIndex);
+
+            setIndicesMap(indicesMap);
+        }
+    }
+
+    private final NullTypesColumnInfo columnInfo;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("fieldStringNotNull");
+        fieldNames.add("fieldStringNull");
+        fieldNames.add("fieldBooleanNotNull");
+        fieldNames.add("fieldBooleanNull");
+        fieldNames.add("fieldBytesNotNull");
+        fieldNames.add("fieldBytesNull");
+        fieldNames.add("fieldByteNotNull");
+        fieldNames.add("fieldByteNull");
+        fieldNames.add("fieldShortNotNull");
+        fieldNames.add("fieldShortNull");
+        fieldNames.add("fieldIntegerNotNull");
+        fieldNames.add("fieldIntegerNull");
+        fieldNames.add("fieldLongNotNull");
+        fieldNames.add("fieldLongNull");
+        fieldNames.add("fieldFloatNotNull");
+        fieldNames.add("fieldFloatNull");
+        fieldNames.add("fieldDoubleNotNull");
+        fieldNames.add("fieldDoubleNull");
+        fieldNames.add("fieldDateNotNull");
+        fieldNames.add("fieldDateNull");
+        fieldNames.add("fieldObjectNull");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
+    NullTypesRealmProxy(ColumnInfo columnInfo) {
+        this.columnInfo = (NullTypesColumnInfo) columnInfo;
+    }
+
+    @SuppressWarnings("cast")
+    public String realmGet$fieldStringNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.fieldStringNotNullIndex);
+    }
+
+    public void realmSet$fieldStringNotNull(String value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldStringNotNull to null.");
+        }
+        ((RealmObject) this).row.setString(columnInfo.fieldStringNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public String realmGet$fieldStringNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.fieldStringNullIndex);
+    }
+
+    public void realmSet$fieldStringNull(String value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldStringNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setString(columnInfo.fieldStringNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Boolean realmGet$fieldBooleanNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.fieldBooleanNotNullIndex);
+    }
+
+    public void realmSet$fieldBooleanNotNull(Boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldBooleanNotNull to null.");
+        }
+        ((RealmObject) this).row.setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Boolean realmGet$fieldBooleanNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldBooleanNullIndex)) {
+            return null;
+        }
+        return (boolean) ((RealmObject) this).row.getBoolean(columnInfo.fieldBooleanNullIndex);
+    }
+
+    public void realmSet$fieldBooleanNull(Boolean value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldBooleanNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setBoolean(columnInfo.fieldBooleanNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public byte[] realmGet$fieldBytesNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
+    }
+
+    public void realmSet$fieldBytesNotNull(byte[] value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldBytesNotNull to null.");
+        }
+        ((RealmObject) this).row.setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public byte[] realmGet$fieldBytesNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (byte[]) ((RealmObject) this).row.getBinaryByteArray(columnInfo.fieldBytesNullIndex);
+    }
+
+    public void realmSet$fieldBytesNull(byte[] value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldBytesNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setBinaryByteArray(columnInfo.fieldBytesNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Byte realmGet$fieldByteNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (byte) ((RealmObject) this).row.getLong(columnInfo.fieldByteNotNullIndex);
+    }
+
+    public void realmSet$fieldByteNotNull(Byte value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldByteNotNull to null.");
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldByteNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Byte realmGet$fieldByteNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldByteNullIndex)) {
+            return null;
+        }
+        return (byte) ((RealmObject) this).row.getLong(columnInfo.fieldByteNullIndex);
+    }
+
+    public void realmSet$fieldByteNull(Byte value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldByteNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldByteNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Short realmGet$fieldShortNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (short) ((RealmObject) this).row.getLong(columnInfo.fieldShortNotNullIndex);
+    }
+
+    public void realmSet$fieldShortNotNull(Short value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldShortNotNull to null.");
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldShortNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Short realmGet$fieldShortNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldShortNullIndex)) {
+            return null;
+        }
+        return (short) ((RealmObject) this).row.getLong(columnInfo.fieldShortNullIndex);
+    }
+
+    public void realmSet$fieldShortNull(Short value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldShortNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldShortNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Integer realmGet$fieldIntegerNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (int) ((RealmObject) this).row.getLong(columnInfo.fieldIntegerNotNullIndex);
+    }
+
+    public void realmSet$fieldIntegerNotNull(Integer value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldIntegerNotNull to null.");
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldIntegerNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Integer realmGet$fieldIntegerNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldIntegerNullIndex)) {
+            return null;
+        }
+        return (int) ((RealmObject) this).row.getLong(columnInfo.fieldIntegerNullIndex);
+    }
+
+    public void realmSet$fieldIntegerNull(Integer value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldIntegerNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldIntegerNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Long realmGet$fieldLongNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (long) ((RealmObject) this).row.getLong(columnInfo.fieldLongNotNullIndex);
+    }
+
+    public void realmSet$fieldLongNotNull(Long value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldLongNotNull to null.");
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldLongNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Long realmGet$fieldLongNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldLongNullIndex)) {
+            return null;
+        }
+        return (long) ((RealmObject) this).row.getLong(columnInfo.fieldLongNullIndex);
+    }
+
+    public void realmSet$fieldLongNull(Long value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldLongNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setLong(columnInfo.fieldLongNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Float realmGet$fieldFloatNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (float) ((RealmObject) this).row.getFloat(columnInfo.fieldFloatNotNullIndex);
+    }
+
+    public void realmSet$fieldFloatNotNull(Float value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldFloatNotNull to null.");
+        }
+        ((RealmObject) this).row.setFloat(columnInfo.fieldFloatNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Float realmGet$fieldFloatNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldFloatNullIndex)) {
+            return null;
+        }
+        return (float) ((RealmObject) this).row.getFloat(columnInfo.fieldFloatNullIndex);
+    }
+
+    public void realmSet$fieldFloatNull(Float value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldFloatNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setFloat(columnInfo.fieldFloatNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Double realmGet$fieldDoubleNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (double) ((RealmObject) this).row.getDouble(columnInfo.fieldDoubleNotNullIndex);
+    }
+
+    public void realmSet$fieldDoubleNotNull(Double value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldDoubleNotNull to null.");
+        }
+        ((RealmObject) this).row.setDouble(columnInfo.fieldDoubleNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Double realmGet$fieldDoubleNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldDoubleNullIndex)) {
+            return null;
+        }
+        return (double) ((RealmObject) this).row.getDouble(columnInfo.fieldDoubleNullIndex);
+    }
+
+    public void realmSet$fieldDoubleNull(Double value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldDoubleNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setDouble(columnInfo.fieldDoubleNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Date realmGet$fieldDateNotNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.fieldDateNotNullIndex);
+    }
+
+    public void realmSet$fieldDateNotNull(Date value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            throw new IllegalArgumentException("Trying to set non-nullable field fieldDateNotNull to null.");
+        }
+        ((RealmObject) this).row.setDate(columnInfo.fieldDateNotNullIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public Date realmGet$fieldDateNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNull(columnInfo.fieldDateNullIndex)) {
+            return null;
+        }
+        return (java.util.Date) ((RealmObject) this).row.getDate(columnInfo.fieldDateNullIndex);
+    }
+
+    public void realmSet$fieldDateNull(Date value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.fieldDateNullIndex);
+            return;
+        }
+        ((RealmObject) this).row.setDate(columnInfo.fieldDateNullIndex, value);
+    }
+
+    public NullTypes realmGet$fieldObjectNull() {
+        ((RealmObject) this).realm.checkIfValid();
+        if (((RealmObject) this).row.isNullLink(columnInfo.fieldObjectNullIndex)) {
+            return null;
+        }
+        return ((RealmObject) this).realm.get(some.test.NullTypes.class, ((RealmObject) this).row.getLink(columnInfo.fieldObjectNullIndex));
+    }
+
+    public void realmSet$fieldObjectNull(NullTypes value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.nullifyLink(columnInfo.fieldObjectNullIndex);
+            return;
+        }
+        if (!value.isValid()) {
+            throw new IllegalArgumentException("'value' is not a valid managed object.");
+        }
+        if (value.realm != this.realm) {
+            throw new IllegalArgumentException("'value' belongs to a different Realm.");
+        }
+        ((RealmObject) this).row.setLink(columnInfo.fieldObjectNullIndex, ((RealmObject) value).row.getIndex());
+    }
+
+    public static Table initTable(ImplicitTransaction transaction) {
+        if (!transaction.hasTable("class_NullTypes")) {
+            Table table = transaction.getTable("class_NullTypes");
+            table.addColumn(RealmFieldType.STRING, "fieldStringNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.STRING, "fieldStringNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.BINARY, "fieldBytesNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.BINARY, "fieldBytesNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldByteNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldByteNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldShortNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldShortNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldLongNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "fieldLongNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNull", Table.NULLABLE);
+            table.addColumn(RealmFieldType.DATE, "fieldDateNotNull", Table.NOT_NULLABLE);
+            table.addColumn(RealmFieldType.DATE, "fieldDateNull", Table.NULLABLE);
+            if (!transaction.hasTable("class_NullTypes")) {
+                NullTypesRealmProxy.initTable(transaction);
+            }
+            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", transaction.getTable("class_NullTypes"));
+            table.setPrimaryKey("");
+            return table;
+        }
+        return transaction.getTable("class_NullTypes");
+    }
+
+    public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction) {
+        if (transaction.hasTable("class_NullTypes")) {
+            Table table = transaction.getTable("class_NullTypes");
+            if (table.getColumnCount() != 21) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 21 but was " + table.getColumnCount());
+            }
+            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+            for (long i = 0; i < 21; i++) {
+                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            }
+
+            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(transaction.getPath(), table);
+
+            if (!columnTypes.containsKey("fieldStringNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldStringNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldBooleanNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldBooleanNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldBytesNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldBytesNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldByteNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldByteNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldShortNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldShortNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldIntegerNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldIntegerNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldLongNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldLongNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldFloatNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldFloatNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldDoubleNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldDoubleNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldDateNotNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            if (!columnTypes.containsKey("fieldDateNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("fieldObjectNull")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
+            }
+            if (!transaction.hasTable("class_NullTypes")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
+            }
+            Table table_20 = transaction.getTable("class_NullTypes");
+            if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
+            }
+            return columnInfo;
+        } else {
+            throw new RealmMigrationNeededException(transaction.getPath(), "The NullTypes class is missing from the schema for this Realm.");
+        }
+    }
+
+    public static String getTableName() {
+        return "class_NullTypes";
+    }
+
+    public static List<String> getFieldNames() {
+        return FIELD_NAMES;
+    }
+
+    @SuppressWarnings("cast")
+    public static NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        NullTypes obj = realm.createObject(NullTypes.class);
+        if (json.has("fieldStringNotNull")) {
+            if (json.isNull("fieldStringNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) json.getString("fieldStringNotNull"));
+            }
+        }
+        if (json.has("fieldStringNull")) {
+            if (json.isNull("fieldStringNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) json.getString("fieldStringNull"));
+            }
+        }
+        if (json.has("fieldBooleanNotNull")) {
+            if (json.isNull("fieldBooleanNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) json.getBoolean("fieldBooleanNotNull"));
+            }
+        }
+        if (json.has("fieldBooleanNull")) {
+            if (json.isNull("fieldBooleanNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) json.getBoolean("fieldBooleanNull"));
+            }
+        }
+        if (json.has("fieldBytesNotNull")) {
+            if (json.isNull("fieldBytesNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(json.getString("fieldBytesNotNull")));
+            }
+        }
+        if (json.has("fieldBytesNull")) {
+            if (json.isNull("fieldBytesNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(json.getString("fieldBytesNull")));
+            }
+        }
+        if (json.has("fieldByteNotNull")) {
+            if (json.isNull("fieldByteNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) json.getInt("fieldByteNotNull"));
+            }
+        }
+        if (json.has("fieldByteNull")) {
+            if (json.isNull("fieldByteNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) json.getInt("fieldByteNull"));
+            }
+        }
+        if (json.has("fieldShortNotNull")) {
+            if (json.isNull("fieldShortNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) json.getInt("fieldShortNotNull"));
+            }
+        }
+        if (json.has("fieldShortNull")) {
+            if (json.isNull("fieldShortNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) json.getInt("fieldShortNull"));
+            }
+        }
+        if (json.has("fieldIntegerNotNull")) {
+            if (json.isNull("fieldIntegerNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) json.getInt("fieldIntegerNotNull"));
+            }
+        }
+        if (json.has("fieldIntegerNull")) {
+            if (json.isNull("fieldIntegerNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) json.getInt("fieldIntegerNull"));
+            }
+        }
+        if (json.has("fieldLongNotNull")) {
+            if (json.isNull("fieldLongNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) json.getLong("fieldLongNotNull"));
+            }
+        }
+        if (json.has("fieldLongNull")) {
+            if (json.isNull("fieldLongNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) json.getLong("fieldLongNull"));
+            }
+        }
+        if (json.has("fieldFloatNotNull")) {
+            if (json.isNull("fieldFloatNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) json.getDouble("fieldFloatNotNull"));
+            }
+        }
+        if (json.has("fieldFloatNull")) {
+            if (json.isNull("fieldFloatNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) json.getDouble("fieldFloatNull"));
+            }
+        }
+        if (json.has("fieldDoubleNotNull")) {
+            if (json.isNull("fieldDoubleNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) json.getDouble("fieldDoubleNotNull"));
+            }
+        }
+        if (json.has("fieldDoubleNull")) {
+            if (json.isNull("fieldDoubleNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+            } else {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) json.getDouble("fieldDoubleNull"));
+            }
+        }
+        if (json.has("fieldDateNotNull")) {
+            if (json.isNull("fieldDateNotNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+            } else {
+                Object timestamp = json.get("fieldDateNotNull");
+                if (timestamp instanceof String) {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate((String) timestamp));
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(json.getLong("fieldDateNotNull")));
+                }
+            }
+        }
+        if (json.has("fieldDateNull")) {
+            if (json.isNull("fieldDateNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+            } else {
+                Object timestamp = json.get("fieldDateNull");
+                if (timestamp instanceof String) {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate((String) timestamp));
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(json.getLong("fieldDateNull")));
+                }
+            }
+        }
+        if (json.has("fieldObjectNull")) {
+            if (json.isNull("fieldObjectNull")) {
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+            } else {
+                some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("fieldObjectNull"), update);
+                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        NullTypes obj = realm.createObject(NullTypes.class);
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("fieldStringNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) reader.nextString());
+                }
+            } else if (name.equals("fieldStringNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) reader.nextString());
+                }
+            } else if (name.equals("fieldBooleanNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("fieldBooleanNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) reader.nextBoolean());
+                }
+            } else if (name.equals("fieldBytesNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(reader.nextString()));
+                }
+            } else if (name.equals("fieldBytesNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(reader.nextString()));
+                }
+            } else if (name.equals("fieldByteNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) reader.nextInt());
+                }
+            } else if (name.equals("fieldByteNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) reader.nextInt());
+                }
+            } else if (name.equals("fieldShortNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) reader.nextInt());
+                }
+            } else if (name.equals("fieldShortNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) reader.nextInt());
+                }
+            } else if (name.equals("fieldIntegerNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) reader.nextInt());
+                }
+            } else if (name.equals("fieldIntegerNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) reader.nextInt());
+                }
+            } else if (name.equals("fieldLongNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) reader.nextLong());
+                }
+            } else if (name.equals("fieldLongNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) reader.nextLong());
+                }
+            } else if (name.equals("fieldFloatNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) reader.nextDouble());
+                }
+            } else if (name.equals("fieldFloatNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) reader.nextDouble());
+                }
+            } else if (name.equals("fieldDoubleNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) reader.nextDouble());
+                }
+            } else if (name.equals("fieldDoubleNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) reader.nextDouble());
+                }
+            } else if (name.equals("fieldDateNotNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+                } else if (reader.peek() == JsonToken.NUMBER) {
+                    long timestamp = reader.nextLong();
+                    if (timestamp > -1) {
+                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(timestamp));
+                    }
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate(reader.nextString()));
+                }
+            } else if (name.equals("fieldDateNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+                } else if (reader.peek() == JsonToken.NUMBER) {
+                    long timestamp = reader.nextLong();
+                    if (timestamp > -1) {
+                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(timestamp));
+                    }
+                } else {
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate(reader.nextString()));
+                }
+            } else if (name.equals("fieldObjectNull")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+                } else {
+                    some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createUsingJsonStream(realm, reader);
+                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return obj;
+    }
+
+    public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+            return object;
+        }
+        return copy(realm, object, update, cache);
+    }
+
+    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        NullTypes realmObject = realm.createObject(NullTypes.class);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
+        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull != null) {
+                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
+            } else {
+                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
+            }
+        } else {
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+        }
+        return realmObject;
+    }
+
+    public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        NullTypes standaloneObject;
+        if (cachedObject != null) {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (NullTypes)cachedObject.object;
+            } else {
+                standaloneObject = (NullTypes)cachedObject.object;
+                cachedObject.minDepth = currentDepth;
+            }
+        } else {
+            standaloneObject = new NullTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+        }
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
+
+        // Deep copy of fieldObjectNull
+        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+        return standaloneObject;
+    }
+
+    @Override
+    public String toString() {
+        if (!isValid()) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("NullTypes = [");
+        stringBuilder.append("{fieldStringNotNull:");
+        stringBuilder.append(realmGet$fieldStringNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldStringNull:");
+        stringBuilder.append(realmGet$fieldStringNull() != null ? realmGet$fieldStringNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanNotNull:");
+        stringBuilder.append(realmGet$fieldBooleanNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanNull:");
+        stringBuilder.append(realmGet$fieldBooleanNull() != null ? realmGet$fieldBooleanNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBytesNotNull:");
+        stringBuilder.append(realmGet$fieldBytesNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBytesNull:");
+        stringBuilder.append(realmGet$fieldBytesNull() != null ? realmGet$fieldBytesNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteNotNull:");
+        stringBuilder.append(realmGet$fieldByteNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteNull:");
+        stringBuilder.append(realmGet$fieldByteNull() != null ? realmGet$fieldByteNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortNotNull:");
+        stringBuilder.append(realmGet$fieldShortNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortNull:");
+        stringBuilder.append(realmGet$fieldShortNull() != null ? realmGet$fieldShortNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerNotNull:");
+        stringBuilder.append(realmGet$fieldIntegerNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerNull:");
+        stringBuilder.append(realmGet$fieldIntegerNull() != null ? realmGet$fieldIntegerNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongNotNull:");
+        stringBuilder.append(realmGet$fieldLongNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongNull:");
+        stringBuilder.append(realmGet$fieldLongNull() != null ? realmGet$fieldLongNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatNotNull:");
+        stringBuilder.append(realmGet$fieldFloatNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatNull:");
+        stringBuilder.append(realmGet$fieldFloatNull() != null ? realmGet$fieldFloatNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleNotNull:");
+        stringBuilder.append(realmGet$fieldDoubleNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleNull:");
+        stringBuilder.append(realmGet$fieldDoubleNull() != null ? realmGet$fieldDoubleNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateNotNull:");
+        stringBuilder.append(realmGet$fieldDateNotNull());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateNull:");
+        stringBuilder.append(realmGet$fieldDateNull() != null ? realmGet$fieldDateNull() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldObjectNull:");
+        stringBuilder.append(realmGet$fieldObjectNull() != null ? "NullTypes" : "null");
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = ((RealmObject) this).realm.getPath();
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        long rowIndex = ((RealmObject) this).row.getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        NullTypesRealmProxy aNullTypes = (NullTypesRealmProxy)o;
+
+        String path = ((RealmObject) this).realm.getPath();
+        String otherPath = ((RealmObject) aNullTypes).realm.getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        String otherTableName = ((RealmObject) aNullTypes).row.getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (((RealmObject) this).row.getIndex() != ((RealmObject) aNullTypes).row.getIndex()) return false;
+
+        return true;
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
new file mode 100644
index 0000000000..3763538ddc
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
@@ -0,0 +1,7 @@
+package io.realm;
+
+
+@io.realm.annotations.RealmModule(allClasses = true)
+class DefaultRealmModule {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
similarity index 61%
rename from realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
rename to realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 520739c0c0..3b43065494 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,28 +2,30 @@
 
 
 import android.util.JsonReader;
-import io.realm.exceptions.RealmException;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import org.json.JSONException;
 import org.json.JSONObject;
 import some.test.AllTypes;
 
-@io.realm.annotations.internal.RealmModule
+@io.realm.annotations.RealmModule
 class DefaultRealmModuleMediator extends RealmProxyMediator {
 
-    private static final List<Class<? extends RealmObject>> MODEL_CLASSES;
+    private static final Set<Class<? extends RealmObject>> MODEL_CLASSES;
     static {
-        List<Class<? extends RealmObject>> modelClasses = new ArrayList<Class<? extends RealmObject>>();
+        Set<Class<? extends RealmObject>> modelClasses = new HashSet<Class<? extends RealmObject>>();
         modelClasses.add(AllTypes.class);
-        MODEL_CLASSES = Collections.unmodifiableList(modelClasses);
+        MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
     @Override
@@ -38,11 +40,11 @@ public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction
     }
 
     @Override
-    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
-            AllTypesRealmProxy.validateTable(transaction);
+            return AllTypesRealmProxy.validateTable(transaction);
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -71,65 +73,69 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
-            return (E) new AllTypesRealmProxy();
+            return clazz.cast(new AllTypesRealmProxy(columnInfo));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public List<Class<? extends RealmObject>> getModelClasses() {
+    public Set<Class<? extends RealmObject>> getModelClasses() {
         return MODEL_CLASSES;
     }
 
     @Override
-    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
-        checkClass(clazz);
+    public <E extends RealmObject> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
 
         if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.getColumnIndices();
+            return clazz.cast(AllTypesRealmProxy.copyOrUpdate(realm, (AllTypes) obj, update, cache));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public <E extends RealmObject> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
-        Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
+    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
-            return (E) AllTypesRealmProxy.copyOrUpdate(realm, (AllTypes) obj, update, cache);
+            return clazz.cast(AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
-            throws JSONException {
+    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader)
+            throws IOException {
         checkClass(clazz);
 
         if (clazz.equals(AllTypes.class)) {
-            return (E) AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update);
+            return clazz.cast(AllTypesRealmProxy.createUsingJsonStream(realm, reader));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader)
-            throws IOException {
-        checkClass(clazz);
+    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass();
 
         if (clazz.equals(AllTypes.class)) {
-            return (E) AllTypesRealmProxy.createUsingJsonStream(realm, reader);
+            return clazz.cast(AllTypesRealmProxy.createDetachedCopy((AllTypes) realmObject, 0, maxDepth, cache));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
-}
+}
\ No newline at end of file
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
new file mode 100644
index 0000000000..99354900a0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -0,0 +1,279 @@
+package io.realm;
+
+
+import android.util.JsonReader;
+import android.util.JsonToken;
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.android.JsonUtils;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import some.test.Simple;
+
+public class SimpleRealmProxy extends Simple
+    implements RealmObjectProxy, SimpleRealmProxyInterface {
+
+    static final class SimpleColumnInfo extends ColumnInfo {
+
+        public final long nameIndex;
+        public final long ageIndex;
+
+        SimpleColumnInfo(String path, Table table) {
+            final Map<String, Long> indicesMap = new HashMap<String, Long>(2);
+            this.nameIndex = getValidColumnIndex(path, table, "Simple", "name");
+            indicesMap.put("name", this.nameIndex);
+
+            this.ageIndex = getValidColumnIndex(path, table, "Simple", "age");
+            indicesMap.put("age", this.ageIndex);
+
+            setIndicesMap(indicesMap);
+        }
+    }
+
+    private final SimpleColumnInfo columnInfo;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("name");
+        fieldNames.add("age");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
+    SimpleRealmProxy(ColumnInfo columnInfo) {
+        this.columnInfo = (SimpleColumnInfo) columnInfo;
+    }
+
+    @SuppressWarnings("cast")
+    public String realmGet$name() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (java.lang.String) ((RealmObject) this).row.getString(columnInfo.nameIndex);
+    }
+
+    public void realmSet$name(String value) {
+        ((RealmObject) this).realm.checkIfValid();
+        if (value == null) {
+            ((RealmObject) this).row.setNull(columnInfo.nameIndex);
+            return;
+        }
+        ((RealmObject) this).row.setString(columnInfo.nameIndex, value);
+    }
+
+    @SuppressWarnings("cast")
+    public int realmGet$age() {
+        ((RealmObject) this).realm.checkIfValid();
+        return (int) ((RealmObject) this).row.getLong(columnInfo.ageIndex);
+    }
+
+    public void realmSet$age(int value) {
+        ((RealmObject) this).realm.checkIfValid();
+        ((RealmObject) this).row.setLong(columnInfo.ageIndex, value);
+    }
+
+    public static Table initTable(ImplicitTransaction transaction) {
+        if (!transaction.hasTable("class_Simple")) {
+            Table table = transaction.getTable("class_Simple");
+            table.addColumn(RealmFieldType.STRING, "name", Table.NULLABLE);
+            table.addColumn(RealmFieldType.INTEGER, "age", Table.NOT_NULLABLE);
+            table.setPrimaryKey("");
+            return table;
+        }
+        return transaction.getTable("class_Simple");
+    }
+
+    public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
+        if (transaction.hasTable("class_Simple")) {
+            Table table = transaction.getTable("class_Simple");
+            if (table.getColumnCount() != 2) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 2 but was " + table.getColumnCount());
+            }
+            Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
+            for (long i = 0; i < 2; i++) {
+                columnTypes.put(table.getColumnName(i), table.getColumnType(i));
+            }
+
+            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(transaction.getPath(), table);
+
+            if (!columnTypes.containsKey("name")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("name") != RealmFieldType.STRING) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
+            }
+            if (!table.isColumnNullable(columnInfo.nameIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using io.realm.internal.Table.convertColumnToNullable().");
+            }
+            if (!columnTypes.containsKey("age")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+            }
+            if (columnTypes.get("age") != RealmFieldType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
+            }
+            if (table.isColumnNullable(columnInfo.ageIndex)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using io.realm.internal.Table.convertColumnToNotNullable().");
+            }
+            return columnInfo;
+        } else {
+            throw new RealmMigrationNeededException(transaction.getPath(), "The Simple class is missing from the schema for this Realm.");
+        }
+    }
+
+    public static String getTableName() {
+        return "class_Simple";
+    }
+
+    public static List<String> getFieldNames() {
+        return FIELD_NAMES;
+    }
+
+    @SuppressWarnings("cast")
+    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        Simple obj = realm.createObject(Simple.class);
+        if (json.has("name")) {
+            if (json.isNull("name")) {
+                ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+            } else {
+                ((SimpleRealmProxyInterface) obj).realmSet$name((String) json.getString("name"));
+            }
+        }
+        if (json.has("age")) {
+            if (json.isNull("age")) {
+                throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+            } else {
+                ((SimpleRealmProxyInterface) obj).realmSet$age((int) json.getInt("age"));
+            }
+        }
+        return obj;
+    }
+
+    @SuppressWarnings("cast")
+    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
+            throws IOException {
+        Simple obj = realm.createObject(Simple.class);
+        reader.beginObject();
+        while (reader.hasNext()) {
+            String name = reader.nextName();
+            if (name.equals("name")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+                } else {
+                    ((SimpleRealmProxyInterface) obj).realmSet$name((String) reader.nextString());
+                }
+            } else if (name.equals("age")) {
+                if (reader.peek() == JsonToken.NULL) {
+                    reader.skipValue();
+                    throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+                } else {
+                    ((SimpleRealmProxyInterface) obj).realmSet$age((int) reader.nextInt());
+                }
+            } else {
+                reader.skipValue();
+            }
+        }
+        reader.endObject();
+        return obj;
+    }
+
+    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (((RealmObject) object).realm != null && ((RealmObject) object).realm.getPath().equals(realm.getPath())) {
+            return object;
+        }
+        return copy(realm, object, update, cache);
+    }
+
+    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        Simple realmObject = realm.createObject(Simple.class);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+        ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
+        ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
+        return realmObject;
+    }
+
+    public static Simple createDetachedCopy(Simple realmObject, int currentDepth, int maxDepth, Map<RealmObject, CacheData<RealmObject>> cache) {
+        if (currentDepth > maxDepth || realmObject == null) {
+            return null;
+        }
+        CacheData<RealmObject> cachedObject = cache.get(realmObject);
+        Simple standaloneObject;
+        if (cachedObject != null) {
+            // Reuse cached object or recreate it because it was encountered at a lower depth.
+            if (currentDepth >= cachedObject.minDepth) {
+                return (Simple)cachedObject.object;
+            } else {
+                standaloneObject = (Simple)cachedObject.object;
+                cachedObject.minDepth = currentDepth;
+            }
+        } else {
+            standaloneObject = new Simple();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmObject>(currentDepth, standaloneObject));
+        }
+        ((SimpleRealmProxyInterface) standaloneObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
+        ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
+        return standaloneObject;
+    }
+
+    @Override
+    public String toString() {
+        if (!isValid()) {
+            return "Invalid object";
+        }
+        StringBuilder stringBuilder = new StringBuilder("Simple = [");
+        stringBuilder.append("{name:");
+        stringBuilder.append(realmGet$name() != null ? realmGet$name() : "null");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{age:");
+        stringBuilder.append(realmGet$age());
+        stringBuilder.append("}");
+        stringBuilder.append("]");
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = ((RealmObject) this).realm.getPath();
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        long rowIndex = ((RealmObject) this).row.getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        SimpleRealmProxy aSimple = (SimpleRealmProxy)o;
+
+        String path = ((RealmObject) this).realm.getPath();
+        String otherPath = ((RealmObject) aSimple).realm.getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+
+        String tableName = ((RealmObject) this).row.getTable().getName();
+        String otherTableName = ((RealmObject) aSimple).row.getTable().getName();
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false;
+
+        if (((RealmObject) this).row.getIndex() != ((RealmObject) aSimple).row.getIndex()) return false;
+
+        return true;
+    }
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
similarity index 59%
rename from realm-annotations-processor/src/test/resources/some/test/AllTypes.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index cdd623ea19..b0961f76de 100644
--- a/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -21,6 +21,7 @@
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
 
 public class AllTypes extends RealmObject {
 
@@ -32,80 +33,155 @@
     private float columnFloat;
     private double columnDouble;
     private boolean columnBoolean;
+    @Required
     private Date columnDate;
+    @Required
     private byte[] columnBinary;
     private AllTypes columnObject;
     private RealmList<AllTypes> columnRealmList;
 
     public String getColumnString() {
-        return columnString;
+        return realmGet$columnString();
     }
 
     public void setColumnString(String columnString) {
+        realmSet$columnString(columnString);
+    }
+
+    public String realmGet$columnString() {
+        return columnString;
+    }
+
+    public void realmSet$columnString(String columnString) {
         this.columnString = columnString;
     }
 
     public long getColumnLong() {
-        return columnLong;
+        return realmGet$columnLong();
     }
 
     public void setColumnLong(long columnLong) {
+        realmSet$columnLong(columnLong);
+    }
+
+    public long realmGet$columnLong() {
+        return columnLong;
+    }
+
+    public void realmSet$columnLong(long columnLong) {
         this.columnLong = columnLong;
     }
 
     public float getColumnFloat() {
-        return columnFloat;
+        return realmGet$columnFloat();
     }
 
     public void setColumnFloat(float columnFloat) {
+        realmSet$columnFloat(columnFloat);
+    }
+
+    public float realmGet$columnFloat() {
+        return columnFloat;
+    }
+
+    public void realmSet$columnFloat(float columnFloat) {
         this.columnFloat = columnFloat;
     }
 
     public double getColumnDouble() {
-        return columnDouble;
+        return realmGet$columnDouble();
     }
 
     public void setColumnDouble(double columnDouble) {
+        realmSet$columnDouble(columnDouble);
+    }
+
+    public double realmGet$columnDouble() {
+        return columnDouble;
+    }
+
+    public void realmSet$columnDouble(double columnDouble) {
         this.columnDouble = columnDouble;
     }
 
     public boolean isColumnBoolean() {
-        return columnBoolean;
+        return realmGet$columnBoolean();
     }
 
     public void setColumnBoolean(boolean columnBoolean) {
+        realmSet$columnBoolean(columnBoolean);
+    }
+
+    public boolean realmGet$columnBoolean() {
+        return columnBoolean;
+    }
+
+    public void realmSet$columnBoolean(boolean columnBoolean) {
         this.columnBoolean = columnBoolean;
     }
 
     public Date getColumnDate() {
-        return columnDate;
+        return realmGet$columnDate();
     }
 
     public void setColumnDate(Date columnDate) {
+        realmSet$columnDate(columnDate);
+    }
+
+    public Date realmGet$columnDate() {
+        return columnDate;
+    }
+
+    public void realmSet$columnDate(Date columnDate) {
         this.columnDate = columnDate;
     }
 
     public byte[] getColumnBinary() {
-        return columnBinary;
+        return realmGet$columnBinary();
     }
 
     public void setColumnBinary(byte[] columnBinary) {
+        realmSet$columnBinary(columnBinary);
+    }
+
+    public byte[] realmGet$columnBinary() {
+        return columnBinary;
+    }
+
+    public void realmSet$columnBinary(byte[] columnBinary) {
         this.columnBinary = columnBinary;
     }
 
     public AllTypes getColumnObject() {
-        return columnObject;
+        return realmGet$columnObject();
     }
 
     public void setColumnObject(AllTypes columnObject) {
+        realmSet$columnObject(columnObject);
+    }
+
+    public AllTypes realmGet$columnObject() {
+        return columnObject;
+    }
+
+    public void realmSet$columnObject(AllTypes columnObject) {
         this.columnObject = columnObject;
     }
 
     public RealmList<AllTypes> getColumnRealmList() {
-        return columnRealmList;
+        return realmGet$columnRealmList();
     }
 
     public void setColumnRealmList(RealmList<AllTypes> columnRealmList) {
+        realmSet$columnRealmList(columnRealmList);
+    }
+
+    public RealmList<AllTypes> realmGet$columnRealmList() {
+        return columnRealmList;
+    }
+
+    public void realmSet$columnRealmList(RealmList<AllTypes> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
+
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java
new file mode 100644
index 0000000000..3b19a4905a
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(allClasses = true)
+public class AppModuleAllClasses {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java
new file mode 100644
index 0000000000..ab933a0a23
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = { AllTypes.class })
+public class AppModuleCustomClasses {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/Booleans.java b/realm/realm-annotations-processor/src/test/resources/some/test/Booleans.java
similarity index 61%
rename from realm-annotations-processor/src/test/resources/some/test/Booleans.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/Booleans.java
index 4db137c1dd..11c43dd949 100644
--- a/realm-annotations-processor/src/test/resources/some/test/Booleans.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Booleans.java
@@ -25,34 +25,66 @@
     private boolean anotherBoolean;
 
     public boolean isDone() {
-        return done;
+        return realmGet$done();
     }
 
     public void setDone(boolean done) {
+        realmSet$done(done);
+    }
+
+    public boolean realmGet$done() {
+        return done;
+    }
+
+    public void realmSet$done(boolean done) {
         this.done = done;
     }
 
     public boolean isReady() {
+        return realmGet$isReady();
+    }
+
+    public void setIsReady(boolean isReady) {
+        realmSet$isReady(isReady);
+    }
+
+    public boolean realmGet$isReady() {
         return isReady;
     }
 
-    public void setReady(boolean isReady) {
+    public void realmSet$isReady(boolean isReady) {
         this.isReady = isReady;
     }
 
     public boolean ismCompleted() {
+        return realmGet$mCompleted();
+    }
+
+    public void setMCompleted(boolean mCompleted) {
+        realmSet$mCompleted(mCompleted);
+    }
+
+    public boolean realmGet$mCompleted() {
         return mCompleted;
     }
 
-    public void setmCompleted(boolean mCompleted) {
+    public void realmSet$mCompleted(boolean mCompleted) {
         this.mCompleted = mCompleted;
     }
 
     public boolean getAnotherBoolean() {
-        return anotherBoolean;
+        return realmGet$anotherBoolean();
     }
 
     public void setAnotherBoolean(boolean anotherBoolean) {
+        realmSet$anotherBoolean(anotherBoolean);
+    }
+
+    public boolean realmGet$anotherBoolean() {
+        return anotherBoolean;
+    }
+
+    public void realmSet$anotherBoolean(boolean anotherBoolean) {
         this.anotherBoolean = anotherBoolean;
     }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
new file mode 100644
index 0000000000..d0f94eeeea
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+
+import io.realm.RealmObject;
+
+public class ConflictingFieldName extends RealmObject {
+    private String realm;
+    private String row;
+    private String listeners;
+    private String pendingQuery;
+    private String isCompleted;
+    private String currentTableVersion;
+
+    public String getRealm() {
+        return realm;
+    }
+
+    public void setRealm(String realm) {
+        this.realm = realm;
+    }
+
+    public String getRow() {
+        return row;
+    }
+
+    public void setRow(String row) {
+        this.row = row;
+    }
+
+    public String getListeners() {
+        return listeners;
+    }
+
+    public void setListeners(String listeners) {
+        this.listeners = listeners;
+    }
+
+    public String getPendingQuery() {
+        return pendingQuery;
+    }
+
+    public void setPendingQuery(String pendingQuery) {
+        this.pendingQuery = pendingQuery;
+    }
+
+    public String getIsCompleted() {
+        return isCompleted;
+    }
+
+    public void setIsCompleted(String isCompleted) {
+        this.isCompleted = isCompleted;
+    }
+
+    public String getCurrentTableVersion() {
+        return currentTableVersion;
+    }
+
+    public void setCurrentTableVersion(String currentTableVersion) {
+        this.currentTableVersion = currentTableVersion;
+    }
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java b/realm/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java
similarity index 100%
rename from realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java
diff --git a/realm-annotations-processor/src/test/resources/some/test/Empty.java b/realm/realm-annotations-processor/src/test/resources/some/test/Empty.java
similarity index 100%
rename from realm-annotations-processor/src/test/resources/some/test/Empty.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/Empty.java
diff --git a/realm-annotations-processor/src/test/resources/some/test/FieldNames.java b/realm/realm-annotations-processor/src/test/resources/some/test/FieldNames.java
similarity index 75%
rename from realm-annotations-processor/src/test/resources/some/test/FieldNames.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/FieldNames.java
index 4537cf4cc4..62e688c35d 100644
--- a/realm-annotations-processor/src/test/resources/some/test/FieldNames.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/FieldNames.java
@@ -26,24 +26,40 @@
  *
  * This class list field names that has caused problems.
  */
-public class FieldNames extends RealmObject {
+public class FieldNames extends RealmObject implements FieldNamesRealmProxyInterface {
 
     private Simple name;
     private Simple cache;
 
     public Simple getName() {
-        return name;
+        return realmGet$name();
     }
 
     public void setName(Simple name) {
+        realmSet$name(name);
+    }
+
+    public Simple realmGet$name() {
+        return name;
+    }
+
+    public void realmSet$name(Simple name) {
         this.name = name;
     }
 
     public Simple getCache() {
-        return cache;
+        return realmGet$cache();
     }
 
     public void setCache(Simple cache) {
+        realmSet$cache(cache);
+    }
+
+    public Simple realmGet$cache() {
+        return cache;
+    }
+
+    public void realmSet$cache(Simple cache) {
         this.cache = cache;
     }
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Final.java b/realm/realm-annotations-processor/src/test/resources/some/test/Final.java
new file mode 100644
index 0000000000..c201dba62c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Final.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+public class Final extends RealmObject {
+    private final String name;
+    private int age;
+
+    public String getName() {
+        return realmGet$name();
+    }
+
+    public void setName(String name) {
+        realmSet$name(name);
+    }
+
+    public String realmGet$name() {
+        return name;
+    }
+
+    public void realmSet$name(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return realmGet$age();
+    }
+
+    public void setAge(int age) {
+        realmSet$age(age);
+    }
+
+    public int realmGet$age() {
+        return age;
+    }
+
+    public void realmSet$age(int age) {
+        this.age = age;
+    }
+
+    @Override
+    public String toString() {
+        return "Simple{" +
+                "name='" + name + '\'' +
+                ", age=" + age +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Simple simple = (Simple) o;
+
+        if (age != simple.age) return false;
+        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = name != null ? name.hashCode() : 0;
+        result = 31 * result + age;
+        return result;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java
new file mode 100644
index 0000000000..af99786ac1
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Setting both allClasses and classes is not allowed at the same time
+@RealmModule(allClasses = true, classes = { AllTypes.class })
+public class InvalidAllTypesModuleMixedParameters {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java
new file mode 100644
index 0000000000..f8ed03eac8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Object is not a RealmObject which the Annotation Processor should be able to detect.
+@RealmModule(classes = { Object.class, AllTypes.class })
+public class InvalidAllTypesModuleWrongType {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java
new file mode 100644
index 0000000000..a3e66aec5d
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Setting both allClasses and classes is not allowed at the same time
+@RealmModule(library = true, allClasses = true, classes = { AllTypes.class })
+public class InvalidLibraryModuleMixedParameters {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java
new file mode 100644
index 0000000000..727d0dbd84
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Object is not a RealmObject which the Annotation Processor should be able to detect.
+@RealmModule(library = true, classes = { Object.class, AllTypes.class })
+public class InvalidLibraryModuleWrongType {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java
new file mode 100644
index 0000000000..5ece7f99cc
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, allClasses = true)
+public class LibraryModuleAllClasses {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java b/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java
new file mode 100644
index 0000000000..5863353cd4
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, classes = { AllTypes.class })
+public class LibraryModuleCustomClasses {
+
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java b/realm/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java
new file mode 100644
index 0000000000..4636c06159
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmList;
+
+class MissingGenericType extends RealmObject {
+    private RealmList list; // this is an error!
+
+    public RealmList getList() {
+        return list;
+    }
+
+    public void setList(RealmList list) {
+        this.list = list;
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java b/realm/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
new file mode 100644
index 0000000000..6c703e830e
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import some.test.AllTypes;
+
+public class NoAccessors extends RealmObject {
+    private String columnString;
+    private long columnLong;
+    private float columnFloat;
+    private double columnDouble;
+    private boolean columnBoolean;
+    private Date columnDate;
+    private byte[] columnBinary;
+    private AllTypes columnRealmObject;
+    private RealmList<AllTypes> columnRealmList;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
new file mode 100644
index 0000000000..1904076340
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
@@ -0,0 +1,405 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.lang.String;
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Required;
+
+public class NullTypes extends RealmObject {
+    @Required
+    private String fieldStringNotNull;
+    private String fieldStringNull;
+
+    @Required
+    private Boolean fieldBooleanNotNull;
+    private Boolean fieldBooleanNull;
+
+    @Required
+    private byte[] fieldBytesNotNull;
+    private byte[] fieldBytesNull;
+
+    @Required
+    private Byte fieldByteNotNull;
+    private Byte fieldByteNull;
+
+    @Required
+    private Short fieldShortNotNull;
+    private Short fieldShortNull;
+
+    @Required
+    private Integer fieldIntegerNotNull;
+    private Integer fieldIntegerNull;
+
+    @Required
+    private Long fieldLongNotNull;
+    private Long fieldLongNull;
+
+    @Required
+    private Float fieldFloatNotNull;
+    private Float fieldFloatNull;
+
+    @Required
+    private Double fieldDoubleNotNull;
+    private Double fieldDoubleNull;
+
+    @Required
+    private Date fieldDateNotNull;
+    private Date fieldDateNull;
+
+    private NullTypes fieldObjectNull;
+
+
+    public String getFieldStringNotNull() {
+        return realmGet$fieldStringNotNull();
+    }
+
+    public void setFieldStringNotNull(String fieldStringNotNull) {
+        realmSet$fieldStringNotNull(fieldStringNotNull);
+    }
+
+    public String realmGet$fieldStringNotNull() {
+        return fieldStringNotNull;
+    }
+
+    public void realmSet$fieldStringNotNull(String fieldStringNotNull) {
+        this.fieldStringNotNull = fieldStringNotNull;
+    }
+
+    public String getFieldStringNull() {
+        return realmGet$fieldStringNull();
+    }
+
+    public void setFieldStringNull(String fieldStringNull) {
+        realmSet$fieldStringNull(fieldStringNull);
+    }
+
+    public String realmGet$fieldStringNull() {
+        return fieldStringNull;
+    }
+
+    public void realmSet$fieldStringNull(String fieldStringNull) {
+        this.fieldStringNull = fieldStringNull;
+    }
+
+    public Boolean getFieldBooleanNotNull() {
+        return realmGet$fieldBooleanNotNull();
+    }
+
+    public void setFieldBooleanNotNull(Boolean fieldBooleanNotNull) {
+        realmSet$fieldBooleanNotNull(fieldBooleanNotNull);
+    }
+
+    public Boolean realmGet$fieldBooleanNotNull() {
+        return fieldBooleanNotNull;
+    }
+
+    public void realmSet$fieldBooleanNotNull(Boolean fieldBooleanNotNull) {
+        this.fieldBooleanNotNull = fieldBooleanNotNull;
+    }
+
+    public Boolean getFieldBooleanNull() {
+        return realmGet$fieldBooleanNull();
+    }
+
+    public void setFieldBooleanNull(Boolean fieldBooleanNull) {
+        realmSet$fieldBooleanNull(fieldBooleanNull);
+    }
+
+    public Boolean realmGet$fieldBooleanNull() {
+        return fieldBooleanNull;
+    }
+
+    public void realmSet$fieldBooleanNull(Boolean fieldBooleanNull) {
+        this.fieldBooleanNull = fieldBooleanNull;
+    }
+
+    public byte[] getFieldBytesNotNull() {
+        return realmGet$fieldBytesNotNull();
+    }
+
+    public void setFieldBytesNotNull(byte[] fieldBytesNotNull) {
+        realmSet$fieldBytesNotNull(fieldBytesNotNull);
+    }
+
+    public byte[] realmGet$fieldBytesNotNull() {
+        return fieldBytesNotNull;
+    }
+
+    public void realmSet$fieldBytesNotNull(byte[] fieldBytesNotNull) {
+        this.fieldBytesNotNull = fieldBytesNotNull;
+    }
+
+    public byte[] getFieldBytesNull() {
+        return realmGet$fieldBytesNull();
+    }
+
+    public void setFieldBytesNull(byte[] fieldBytesNull) {
+        realmSet$fieldBytesNull(fieldBytesNull);
+    }
+
+    public byte[] realmGet$fieldBytesNull() {
+        return fieldBytesNull;
+    }
+
+    public void realmSet$fieldBytesNull(byte[] fieldBytesNull) {
+        this.fieldBytesNull = fieldBytesNull;
+    }
+
+    public Byte getFieldByteNotNull() {
+        return realmGet$fieldByteNotNull();
+    }
+
+    public void setFieldByteNotNull(Byte fieldByteNotNull) {
+        realmSet$fieldByteNotNull(fieldByteNotNull);
+    }
+
+    public Byte realmGet$fieldByteNotNull() {
+        return fieldByteNotNull;
+    }
+
+    public void realmSet$fieldByteNotNull(Byte fieldByteNotNull) {
+        this.fieldByteNotNull = fieldByteNotNull;
+    }
+
+    public Byte getFieldByteNull() {
+        return realmGet$fieldByteNull();
+    }
+
+    public void setFieldByteNull(Byte fieldByteNull) {
+        realmSet$fieldByteNull(fieldByteNull);
+    }
+
+    public Byte realmGet$fieldByteNull() {
+        return fieldByteNull;
+    }
+
+    public void realmSet$fieldByteNull(Byte fieldByteNull) {
+        this.fieldByteNull = fieldByteNull;
+    }
+
+    public Short getFieldShortNotNull() {
+        return realmGet$fieldShortNotNull();
+    }
+
+    public void setFieldShortNotNull(Short fieldShortNotNull) {
+        realmSet$fieldShortNotNull(fieldShortNotNull);
+    }
+
+    public Short realmGet$fieldShortNotNull() {
+        return fieldShortNotNull;
+    }
+
+    public void realmSet$fieldShortNotNull(Short fieldShortNotNull) {
+        this.fieldShortNotNull = fieldShortNotNull;
+    }
+
+    public Short getFieldShortNull() {
+        return realmGet$fieldShortNull();
+    }
+
+    public void setFieldShortNull(Short fieldShortNull) {
+        realmSet$fieldShortNull(fieldShortNull);
+    }
+
+    public Short realmGet$fieldShortNull() {
+        return fieldShortNull;
+    }
+
+    public void realmSet$fieldShortNull(Short fieldShortNull) {
+        this.fieldShortNull = fieldShortNull;
+    }
+
+    public Integer getFieldIntegerNotNull() {
+        return realmGet$fieldIntegerNotNull();
+    }
+
+    public void setFieldIntegerNotNull(Integer fieldIntegerNotNull) {
+        realmSet$fieldIntegerNotNull(fieldIntegerNotNull);
+    }
+
+    public Integer realmGet$fieldIntegerNotNull() {
+        return fieldIntegerNotNull;
+    }
+
+    public void realmSet$fieldIntegerNotNull(Integer fieldIntegerNotNull) {
+        this.fieldIntegerNotNull = fieldIntegerNotNull;
+    }
+
+    public Integer getFieldIntegerNull() {
+        return realmGet$fieldIntegerNull();
+    }
+
+    public void setFieldIntegerNull(Integer fieldIntegerNull) {
+        realmSet$fieldIntegerNull(fieldIntegerNull);
+    }
+
+    public Integer realmGet$fieldIntegerNull() {
+        return fieldIntegerNull;
+    }
+
+    public void realmSet$fieldIntegerNull(Integer fieldIntegerNull) {
+        this.fieldIntegerNull = fieldIntegerNull;
+    }
+
+    public Long getFieldLongNotNull() {
+        return realmGet$fieldLongNotNull();
+    }
+
+    public void setFieldLongNotNull(Long fieldLongNotNull) {
+        realmSet$fieldLongNotNull(fieldLongNotNull);
+    }
+
+    public Long realmGet$fieldLongNotNull() {
+        return fieldLongNotNull;
+    }
+
+    public void realmSet$fieldLongNotNull(Long fieldLongNotNull) {
+        this.fieldLongNotNull = fieldLongNotNull;
+    }
+
+    public Long getFieldLongNull() {
+        return realmGet$fieldLongNull();
+    }
+
+    public void setFieldLongNull(Long fieldLongNull) {
+        realmSet$fieldLongNull(fieldLongNull);
+    }
+
+    public Long realmGet$fieldLongNull() {
+        return fieldLongNull;
+    }
+
+    public void realmSet$fieldLongNull(Long fieldLongNull) {
+        this.fieldLongNull = fieldLongNull;
+    }
+
+    public Float getFieldFloatNotNull() {
+        return realmGet$fieldFloatNotNull();
+    }
+
+    public void setFieldFloatNotNull(Float fieldFloatNotNull) {
+        realmSet$fieldFloatNotNull(fieldFloatNotNull);
+    }
+
+    public Float realmGet$fieldFloatNotNull() {
+        return fieldFloatNotNull;
+    }
+
+    public void realmSet$fieldFloatNotNull(Float fieldFloatNotNull) {
+        this.fieldFloatNotNull = fieldFloatNotNull;
+    }
+
+    public Float getFieldFloatNull() {
+        return realmGet$fieldFloatNull();
+    }
+
+    public void setFieldFloatNull(Float fieldFloatNull) {
+        realmSet$fieldFloatNull(fieldFloatNull);
+    }
+
+    public Float realmGet$fieldFloatNull() {
+        return fieldFloatNull;
+    }
+
+    public void realmSet$fieldFloatNull(Float fieldFloatNull) {
+        this.fieldFloatNull = fieldFloatNull;
+    }
+
+    public Double getFieldDoubleNotNull() {
+        return realmGet$fieldDoubleNotNull();
+    }
+
+    public void setFieldDoubleNotNull(Double fieldDoubleNotNull) {
+        realmSet$fieldDoubleNotNull(fieldDoubleNotNull);
+    }
+
+    public Double realmGet$fieldDoubleNotNull() {
+        return fieldDoubleNotNull;
+    }
+
+    public void realmSet$fieldDoubleNotNull(Double fieldDoubleNotNull) {
+        this.fieldDoubleNotNull = fieldDoubleNotNull;
+    }
+
+    public Double getFieldDoubleNull() {
+        return realmGet$fieldDoubleNull();
+    }
+
+    public void setFieldDoubleNull(Double fieldDoubleNull) {
+        realmSet$fieldDoubleNull(fieldDoubleNull);
+    }
+
+    public Double realmGet$fieldDoubleNull() {
+        return fieldDoubleNull;
+    }
+
+    public void realmSet$fieldDoubleNull(Double fieldDoubleNull) {
+        this.fieldDoubleNull = fieldDoubleNull;
+    }
+
+    public Date getFieldDateNotNull() {
+        return realmGet$fieldDateNotNull();
+    }
+
+    public void setFieldDateNotNull(Date fieldDateNotNull) {
+        realmSet$fieldDateNotNull(fieldDateNotNull);
+    }
+
+    public Date realmGet$fieldDateNotNull() {
+        return fieldDateNotNull;
+    }
+
+    public void realmSet$fieldDateNotNull(Date fieldDateNotNull) {
+        this.fieldDateNotNull = fieldDateNotNull;
+    }
+
+    public Date getFieldDateNull() {
+        return realmGet$fieldDateNull();
+    }
+
+    public void setFieldDateNull(Date fieldDateNull) {
+        realmSet$fieldDateNull(fieldDateNull);
+    }
+
+    public Date realmGet$fieldDateNull() {
+        return fieldDateNull;
+    }
+
+    public void realmSet$fieldDateNull(Date fieldDateNull) {
+        this.fieldDateNull = fieldDateNull;
+    }
+
+    public NullTypes getFieldObjectNull() {
+        return realmGet$fieldObjectNull();
+    }
+
+    public void setFieldObjectNull(NullTypes fieldObjectNull) {
+        realmSet$fieldObjectNull(fieldObjectNull);
+    }
+
+    public NullTypes realmGet$fieldObjectNull() {
+        return fieldObjectNull;
+    }
+
+    public void realmSet$fieldObjectNull(NullTypes fieldObjectNull) {
+        this.fieldObjectNull = fieldObjectNull;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Simple.java b/realm/realm-annotations-processor/src/test/resources/some/test/Simple.java
new file mode 100644
index 0000000000..b5aac38cf1
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Simple.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+public class Simple extends RealmObject {
+    private String name;
+    private int age;
+
+    public String getName() {
+        return realmGet$name();
+    }
+
+    public void setName(String name) {
+        realmSet$name(name);
+    }
+
+    public String realmGet$name() {
+        return name;
+    }
+
+    public void realmSet$name(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return realmGet$age();
+    }
+
+    public void setAge(int age) {
+        realmSet$age(age);
+    }
+
+    public int realmGet$age() {
+        return age;
+    }
+
+    public void realmSet$age(int age) {
+        this.age = age;
+    }
+
+    @Override
+    public String toString() {
+        return "Simple{" +
+                "name='" + name + '\'' +
+                ", age=" + age +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Simple simple = (Simple) o;
+
+        if (age != simple.age) return false;
+        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = name != null ? name.hashCode() : 0;
+        result = 31 * result + age;
+        return result;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
new file mode 100644
index 0000000000..c130b20f7f
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+public class Transient extends RealmObject {
+    private transient String name;
+    private int age;
+
+    public String getName() {
+        return realmGet$name();
+    }
+
+    public void setName(String name) {
+        realmSet$name(name);
+    }
+
+    public String realmGet$name() {
+        return name;
+    }
+
+    public void realmSet$name(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return realmGet$age();
+    }
+
+    public void setAge(int age) {
+        realmSet$age(age);
+    }
+
+    public int realmGet$age() {
+        return age;
+    }
+
+    public void realmSet$age(int age) {
+        this.age = age;
+    }
+
+    @Override
+    public String toString() {
+        return "Simple{" +
+                "name='" + name + '\'' +
+                ", age=" + age +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Simple simple = (Simple) o;
+
+        if (age != simple.age) return false;
+        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = name != null ? name.hashCode() : 0;
+        result = 31 * result + age;
+        return result;
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Volatile.java b/realm/realm-annotations-processor/src/test/resources/some/test/Volatile.java
new file mode 100644
index 0000000000..fc38b48c27
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Volatile.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+
+public class Volatile extends RealmObject {
+    private volatile String name;
+    private int age;
+
+    public String getName() {
+        return realmGet$name();
+    }
+
+    public void setName(String name) {
+        realmSet$name(name);
+    }
+
+    public String realmGet$name() {
+        return name;
+    }
+
+    public void realmSet$name(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return realmGet$age();
+    }
+
+    public void setAge(int age) {
+        realmSet$age(age);
+    }
+
+    public int realmGet$age() {
+        return age;
+    }
+
+    public void realmSet$age(int age) {
+        this.age = age;
+    }
+
+    @Override
+    public String toString() {
+        return "Simple{" +
+                "name='" + name + '\'' +
+                ", age=" + age +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Simple simple = (Simple) o;
+
+        if (age != simple.age) return false;
+        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = name != null ? name.hashCode() : 0;
+        result = 31 * result + age;
+        return result;
+    }
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
new file mode 100644
index 0000000000..ad3bd38b18
--- /dev/null
+++ b/realm/realm-jni/build.gradle
@@ -0,0 +1,347 @@
+import java.security.MessageDigest
+
+ext.coreVersion = '0.97.0'
+// empty or comment out this to disable hash checking
+ext.coreSha256Hash = 'b864547b6dea65cb36818d9ae52e72bb5b912759675ab2707cb956f73137424c'
+ext.forceDownloadCore =
+        project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
+// gcc is default for the NDK. It also produces smaller binaries
+ext.clang = project.hasProperty('clang') ? project.getProperty('clang').toBoolean() : false
+// Build with debug symbols
+ext.debugBuild = project.hasProperty('debugBuild') ? project.getProperty('debugBuild').toBoolean() : false
+// Strip the symbols from the so file or not. If debugBuild is true, this one will be always false.
+ext.stripSymbols = project.hasProperty('stripSymbols') ? project.getProperty('stripSymbols').toBoolean() : true
+// Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
+// core source code.
+ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
+// The location of core archive.
+ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
+
+def commonCflags = [ '-Os', '-std=c++11' ]
+// LTO and debugging don't play well together
+if (!ext.debugBuild) {
+    commonCflags += [ '-fvisibility=hidden', '-ffunction-sections', '-fdata-sections', '-flto' ]
+}
+
+enum Compiler {
+    GCC, CLANG
+}
+
+// Unfortunately the NDK has no consistency when it comes to naming.
+// This Class holds all the different names used and some more information
+class Toolchain {
+    // The standard name: arm, arm64, mips, x86
+    String name
+
+    // The name used when generating the standalone toolchain
+    String fullName
+
+    // The prefix commands use. i.e. arm-linux-androideabi-gcc
+    String commandPrefix
+
+    // Which version of each compiler to use
+    Map<Compiler, String> version
+
+    // The first Android platform to support this toolchain
+    int platform
+}
+
+// This class describes the specific target
+class Target {
+    // The name of the target. This is used for the task names
+    String name
+
+    // The name of the folder the Android Gradle plugin expects to find the shared library
+    String jniFolder
+
+    // The toolchain associated to this target
+    Toolchain toolchain
+
+    // The CFLAGS specific to this target
+    List<String> cflags
+}
+
+// We are using gcc 4.9 for all architectures
+def toolchains = [
+    new Toolchain( name:'arm', fullName:'arm-linux-androideabi', commandPrefix:'arm-linux-androideabi', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:8 ),
+    new Toolchain( name:'arm64', fullName:'aarch64-linux-android', commandPrefix:'aarch64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 ),
+    new Toolchain( name:'mips', fullName:'mipsel-linux-android', commandPrefix:'mipsel-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
+    new Toolchain( name:'x86', fullName:'x86', commandPrefix:'i686-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
+    new Toolchain( name:'x86_64', fullName:'x86_64', commandPrefix:'x86_64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 )
+]
+
+def targets = [
+    new Target( name:'arm', jniFolder:'armeabi', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb' ] ),
+    new Target( name:'arm-v7a', jniFolder:'armeabi-v7a', toolchain:toolchains.find{it.name == 'arm'}, cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
+    new Target( name:'arm64', jniFolder:'arm64-v8a', toolchain:toolchains.find{it.name == 'arm64'}, cflags:[] ),
+    new Target( name:'mips', jniFolder:'mips', toolchain:toolchains.find{it.name == 'mips'}, cflags:[] ),
+    new Target( name:'x86', jniFolder:'x86', toolchain:toolchains.find{it.name == 'x86'}, cflags:[] ),
+    new Target( name:'x86_64', jniFolder:'x86_64', toolchain:toolchains.find{it.name == 'x86_64'}, cflags:[] )
+]
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'de.undercouch:gradle-download-task:2.0.0'
+    }
+}
+
+apply plugin: 'de.undercouch.download'
+
+if (ext.debugBuild) {
+    // Debug build should never strip symbols
+    ext.stripSymbols = false
+}
+if (ext.coreSourcePath) {
+    // Run the "sh build.sh get-version" to get the core version.
+    ext.coreVersion = "sh build.sh get-version".execute([], file(coreSourcePath)).text.trim()
+}
+
+def getNdk() {
+    if (!System.env.NDK_HOME) {
+        throw new GradleException('The NDK_HOME environment variable is not set.')
+    }
+    def ndkDir = file(System.env.NDK_HOME)
+    if (!ndkDir.directory) {
+        throw new GradleException('The path provided in the NDK_HOME environment variable is not a folder.')
+    }
+    if (!file("${ndkDir}/RELEASE.TXT").file) {
+        throw new GradleException('The path provided in the NDK_HOME environment variable does not seem to be an Android NDK.')
+    }
+    def detectedNdkVersion = file("${ndkDir}/RELEASE.TXT").text.trim().split()[0].split('-')[0]
+    if (detectedNdkVersion != ndkVersion) {
+        throw new GradleException("Your NDK version: ${detectedNdkVersion}. Realm JNI should be compiled with the version ${ndkVersion} of NDK.")
+    }
+    return ndkDir
+}
+
+def getStrippedExt() {
+    return stripSymbols ? "-stripped" : ""
+}
+
+def getDebugExt() {
+    return debugBuild ? "-dbg" : ""
+}
+
+if (!ext.coreArchiveDir) {
+    ext.coreArchiveDir = ".."
+}
+ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/core-android-${project.coreVersion}.tar.gz")
+ext.coreDir = file("${buildDir}/core-${project.coreVersion}")
+
+def coreDownloaded = false
+
+task downloadCore(group: 'build setup', description: 'Download the latest version of realm core') {
+    def isHashCheckingEnabled = {
+        return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
+    }
+
+    def calcSha256Hash = {File targetFile ->
+        MessageDigest sha = MessageDigest.getInstance("SHA-256");
+        Formatter hexHash = new Formatter()
+        sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
+        return hexHash.toString()
+    }
+
+    def shouldDownloadCore = {
+        if (!project.coreArchiveFile.exists()) {
+            return true
+        }
+        if (project.forceDownloadCore) {
+            return true;
+        }
+        if (!isHashCheckingEnabled()) {
+            println "Skipping hash check(empty \'coreSha256Hash\')."
+            return false
+        }
+
+        def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+        if (project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+            return false
+        }
+
+        println "Existing archive hash mismatch(Expected: ${project.coreSha256Hash.toLowerCase()}" +
+                " but got ${calculatedHash.toLowerCase()}). Download new version."
+        return true
+    }
+
+    doLast {
+        if (shouldDownloadCore()) {
+            download {
+                src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
+                dest project.coreArchiveFile
+                onlyIfNewer false
+            }
+            coreDownloaded = true
+
+            if (isHashCheckingEnabled()) {
+                def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+                if (!project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+                    throw new GradleException("Invalid checksum for file '" +
+                            "${project.coreArchiveFile.getName()}'. Expected " +
+                            "${project.coreSha256Hash.toLowerCase()} but got " +
+                            "${calculatedHash.toLowerCase()}.");
+                }
+            } else {
+                println 'Skipping hash check(empty \'coreSha256Hash\').'
+            }
+        }
+    }
+}
+
+task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
+    // Build the library from core source code
+    doFirst {
+        if (!coreSourcePath) {
+            throw new GradleException('The coreSourcePath is not set.')
+        }
+        exec {
+            workingDir = coreSourcePath
+            commandLine = [
+                    "bash",
+                    "build.sh",
+                    "build-android"
+            ]
+        }
+    }
+
+    // Copy the core tar ball
+    doLast {
+        copy {
+            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
+            into project.coreArchiveFile.parent
+            rename "realm-core-android-${coreVersion}.tar.gz", "core-android-${coreVersion}.tar.gz"
+        }
+    }
+}
+
+task deployCore(group: 'build setup', description: 'Deploy the latest version of realm core') {
+    dependsOn {
+        coreSourcePath ? compileCore : downloadCore
+    }
+
+    outputs.upToDateWhen {
+        // Clean up the coreDir if it is newly downloaded or compiled from source
+        if (coreDownloaded || coreSourcePath) {
+            return false
+        }
+
+        return project.coreDir.exists()
+    }
+
+    doLast {
+        exec {
+            commandLine = [
+                    'rm',
+                    '-rf',
+                    project.coreDir.getAbsolutePath()
+            ]
+        }
+        copy {
+            from tarTree(project.coreArchiveFile)
+            into project.coreDir
+        }
+        for (target in targets) {
+            exec {
+                commandLine = [
+                        'make',
+                        '-C', "${projectDir}/src",
+                        "BASE_DENOM=${target.name}",
+                        'LIB_SUFFIX_SHARED=.so',
+                        'clean'
+                ]
+            }
+        }
+    }
+}
+
+toolchains.each { toolchain ->
+    def ndkDir = getNdk()
+    task "generateNdkToolchain${toolchain.name.capitalize()}"(type: Exec) {
+        group 'build setup'
+        description "Generate the NDK standalone toolchain for the ${toolchain.name.capitalize()} platform"
+        outputs.dir file("${buildDir}/standalone-toolchains/${toolchain.name}")
+        commandLine = [
+            "bash",
+            "${ndkDir}/build/tools/make-standalone-toolchain.sh",
+            "--platform=android-${toolchain.platform}",
+            "--install-dir=${buildDir}/standalone-toolchains/${toolchain.name}",
+            "--toolchain=${toolchain.fullName}-${clang?'clang'+toolchain.version[Compiler.CLANG]:toolchain.version[Compiler.GCC]}"
+        ]
+    }
+}
+
+targets.each { target ->
+    task "buildAndroidJni${target.name.capitalize()}"(type: Exec) {
+        group 'build'
+        description "Build the Android JNI shared library for the ${target.name.capitalize()} platform"
+        dependsOn deployCore
+        dependsOn "generateNdkToolchain${target.toolchain.name.capitalize()}"
+        environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
+        environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
+        environment STRIP: "${target.toolchain.commandPrefix}-strip -o librealm-jni-${target.name}-stripped.so"
+        environment REALM_ANDROID: '1'
+        commandLine = [
+            'make',
+            "-j${Runtime.getRuntime().availableProcessors() * 2}",
+            "-l${Runtime.getRuntime().availableProcessors()}",
+            '-C', "${projectDir}/src",
+            "CC_IS=${clang?'clang':'gcc'}",
+            "REALM_CFLAGS_COMMON=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${project.coreDir}/include",
+            "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
+            "BASE_DENOM=${target.name}",
+            "REALM_LDFLAGS_COMMON=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${project.coreDir} -Wl,--gc-sections",
+            'LIB_SUFFIX_SHARED=.so',
+            "librealm-jni-${target.name}${getDebugExt()}.so"
+        ]
+    }
+
+    task "copyAndroidJni${target.name.capitalize()}"(dependsOn: "buildAndroidJni${target.name.capitalize()}") << {
+        copy {
+            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so"
+            into "${projectDir}/../realm-library/src/main/jniLibs/${target.jniFolder}"
+            rename "librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so", 'librealm-jni.so'
+        }
+
+        // Store the unstripped version
+        copy {
+            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
+            into "${projectDir}/../build/output/jniLibs-unstripped/${target.jniFolder}"
+            rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
+        }
+    }
+}
+
+task buildAndroidJni(group: 'build', description: 'Build the Android JNI shared library for all the supported platforms') {
+    targets.each { target ->
+        dependsOn "copyAndroidJni${target.name.capitalize()}"
+    }
+}
+
+task clean(type: Delete) {
+    outputs.upToDateWhen {
+        project.hasProperty('dontCleanJniFiles')
+    }
+
+    delete project.buildDir
+
+    delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
+    delete fileTree(dir: "${projectDir}/../build/output/jniLibs-unstripped/", include: '**/librealm-jni*.so')
+    delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
+
+    doLast {
+        targets.each { target ->
+            exec {
+                commandLine = [
+                        'make',
+                        '-C', "${projectDir}/src",
+                        "BASE_DENOM=${target.name}",
+                        'LIB_SUFFIX_SHARED=.so',
+                        'clean'
+                ]
+            }
+        }
+    }
+}
diff --git a/realm-jni/generate-jni-headers.sh b/realm/realm-jni/generate-jni-headers.sh
similarity index 100%
rename from realm-jni/generate-jni-headers.sh
rename to realm/realm-jni/generate-jni-headers.sh
diff --git a/realm-jni/generic.mk b/realm/realm-jni/generic.mk
similarity index 100%
rename from realm-jni/generic.mk
rename to realm/realm-jni/generic.mk
diff --git a/realm-jni/project.mk b/realm/realm-jni/project.mk
similarity index 78%
rename from realm-jni/project.mk
rename to realm/realm-jni/project.mk
index 7d6ac268f6..cf9b0e6b95 100644
--- a/realm-jni/project.mk
+++ b/realm/realm-jni/project.mk
@@ -52,13 +52,13 @@ ifeq ($(REALM_ANDROID),)
     endif
   endif
 else
-  PROJECT_CFLAGS += -fvisibility=hidden -DANDROID
+  PROJECT_CFLAGS += -DANDROID
   CFLAGS_OPTIM = -Os -DNDEBUG
 endif
 
-PROJECT_CFLAGS_OPTIM  += $(REALM_CFLAGS)
-PROJECT_CFLAGS_DEBUG  += $(REALM_CFLAGS_DBG)
-PROJECT_CFLAGS_COVER  += $(REALM_CFLAGS_DBG)
-PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS)
-PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_DBG)
-PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_DBG)
+PROJECT_CFLAGS_OPTIM  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS)
+PROJECT_CFLAGS_DEBUG  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
+PROJECT_CFLAGS_COVER  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
+PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS)
+PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
+PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
diff --git a/realm-jni/src/Makefile b/realm/realm-jni/src/Makefile
similarity index 52%
rename from realm-jni/src/Makefile
rename to realm/realm-jni/src/Makefile
index 089e82bf0c..4a8eabdd10 100644
--- a/realm-jni/src/Makefile
+++ b/realm/realm-jni/src/Makefile
@@ -3,8 +3,4 @@ lib_LIBRARIES = librealm-jni.a
 JNI_SOURCES := $(wildcard *.cpp)
 librealm_jni_a_SOURCES = $(JNI_SOURCES)
 
-# Used by ../../build.sh
-get-inst-libraries:
-	@echo $(filter-out librealm-jni-cov.%,$(TARGETS_LIB_SHARED_ALIASES))
-
 include ../generic.mk
diff --git a/realm-jni/src/TableSpecUtil.cpp b/realm/realm-jni/src/TableSpecUtil.cpp
similarity index 98%
rename from realm-jni/src/TableSpecUtil.cpp
rename to realm/realm-jni/src/TableSpecUtil.cpp
index f7f9588717..ed028cfd5f 100644
--- a/realm-jni/src/TableSpecUtil.cpp
+++ b/realm/realm-jni/src/TableSpecUtil.cpp
@@ -51,7 +51,7 @@ jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv* env, jobject jTableSpec)
 
 jobject Java_io_realm_TableSpec_getColumnType(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
 {
-    static jmethodID jGetColumnTypeMethodId = GetTableSpecMethodID(env, "getColumnType", "(J)Lio/realm/internal/ColumnType;");
+    static jmethodID jGetColumnTypeMethodId = GetTableSpecMethodID(env, "getColumnType", "(J)Lio/realm/RealmFieldType;");
     if (jGetColumnTypeMethodId)
         return env->CallObjectMethod(jTableSpec, jGetColumnTypeMethodId, columnIndex);
     return NULL;
diff --git a/realm-jni/src/TableSpecUtil.hpp b/realm/realm-jni/src/TableSpecUtil.hpp
similarity index 100%
rename from realm-jni/src/TableSpecUtil.hpp
rename to realm/realm-jni/src/TableSpecUtil.hpp
diff --git a/realm-jni/src/columntypeutil.cpp b/realm/realm-jni/src/columntypeutil.cpp
similarity index 94%
rename from realm-jni/src/columntypeutil.cpp
rename to realm/realm-jni/src/columntypeutil.cpp
index 2dcc19564a..44e3af06d1 100644
--- a/realm-jni/src/columntypeutil.cpp
+++ b/realm/realm-jni/src/columntypeutil.cpp
@@ -20,7 +20,7 @@
 
 static jfieldID GetFieldIDColumnType(JNIEnv* env, const char* methodStr, const char* typeStr)
 {
-    static jclass myClass = GetClass(env, "io/realm/internal/ColumnType");
+    static jclass myClass = GetClass(env, "io/realm/RealmFieldType");
     if (myClass == NULL)
         return NULL;
 
@@ -45,7 +45,7 @@ DataType GetColumnTypeFromJColumnType(JNIEnv* env, jobject jColumnType)
 jobject GetJColumnTypeFromColumnType(JNIEnv* env, DataType columnType)
 {
     TR("enter GetJColumnTypeFromColumnType(%d)", columnType)
-    static jclass jColumnTypeClass = GetClass(env, "io/realm/internal/ColumnType");
+    static jclass jColumnTypeClass = GetClass(env, "io/realm/RealmFieldType");
 
     if (jColumnTypeClass == NULL) {
         TR("--class is NULL");
diff --git a/realm-jni/src/columntypeutil.hpp b/realm/realm-jni/src/columntypeutil.hpp
similarity index 100%
rename from realm-jni/src/columntypeutil.hpp
rename to realm/realm-jni/src/columntypeutil.hpp
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
new file mode 100644
index 0000000000..031afa39f0
--- /dev/null
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_CheckedRow.h"
+#include "io_realm_internal_UncheckedRow.h"
+
+#include "util.hpp"
+#include "mixedutil.hpp"
+#include "tablebase_tpl.hpp"
+
+using namespace realm;
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr)
+{
+    if (!ROW(nativeRowPtr)->is_attached())
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnCount(env, obj, nativeRowPtr);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+        return NULL;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnName(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jstring columnName)
+{
+    if (!ROW(nativeRowPtr)->is_attached())
+        return 0;
+
+    jlong ndx = Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex(env, obj, nativeRowPtr, columnName);
+    if (ndx == to_jlong_or_not_found(realm::not_found)) {
+        JStringAccessor column_name(env, columnName);
+        ThrowException(env, IllegalArgument, concat_stringdata("Field not found: ", column_name));
+        return 0;
+    }
+    else {
+        return ndx;
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnType(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLong(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetBoolean(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetFloat(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetDouble(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetDateTime(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetString(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetMixedType(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return NULL;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetMixed(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLink(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLinkView(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetLong(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jboolean value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetBoolean(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jfloat value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetFloat(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jdouble value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetDouble(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetDate(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jstring value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetString(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetByteArray(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetMixed(env, obj, nativeRowPtr, columnIndex, jMixedValue);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetLink(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeNullifyLink(env, obj, nativeRowPtr, columnIndex);
+}
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.h b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
new file mode 100644
index 0000000000..230aa03d0a
--- /dev/null
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
@@ -0,0 +1,229 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class io_realm_internal_CheckedRow */
+
+#ifndef _Included_io_realm_internal_CheckedRow
+#define _Included_io_realm_internal_CheckedRow
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnCount
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnName
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnIndex
+ * Signature: (JLjava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLong
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetBoolean
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetFloat
+ * Signature: (JJ)F
+ */
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetDouble
+ * Signature: (JJ)D
+ */
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetDateTime
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetString
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeIsNullLink
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetByteArray
+ * Signature: (JJ)[B
+ */
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetMixedType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetMixed
+ * Signature: (JJ)Lio/realm/internal/Mixed;
+ */
+JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLinkView
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetLong
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetBoolean
+ * Signature: (JJZ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
+  (JNIEnv *, jobject, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetFloat
+ * Signature: (JJF)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
+  (JNIEnv *, jobject, jlong, jlong, jfloat);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLink
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetDouble
+ * Signature: (JJD)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
+  (JNIEnv *, jobject, jlong, jlong, jdouble);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetDate
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetString
+ * Signature: (JJLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
+  (JNIEnv *, jobject, jlong, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetByteArray
+ * Signature: (JJ[B)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
+  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetMixed
+ * Signature: (JJLio/realm/internal/Mixed;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
+  (JNIEnv *, jobject, jlong, jlong, jobject);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetLink
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeNullifyLink
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeIsNull
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNull
+  (JNIEnv *, jobject, jlong, jlong);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/realm-jni/src/io_realm_internal_Group.cpp b/realm/realm-jni/src/io_realm_internal_Group.cpp
similarity index 87%
rename from realm-jni/src/io_realm_internal_Group.cpp
rename to realm/realm-jni/src/io_realm_internal_Group.cpp
index 9b85e9faf6..d2e289e020 100644
--- a/realm-jni/src/io_realm_internal_Group.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Group.cpp
@@ -158,6 +158,27 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName(
     return 0;
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable(
+    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring name)
+{
+    TR_ENTER_PTR(nativeGroupPtr)
+    try {
+        JStringAccessor table_name(env, name);
+        G(nativeGroupPtr)->remove_table(table_name);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable(
+    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring oldName, jstring newName)
+{
+    TR_ENTER_PTR(nativeGroupPtr)
+    try {
+        JStringAccessor old_name(env, oldName);
+        JStringAccessor new_name(env, newName);
+        G(nativeGroupPtr)->rename_table(old_name, new_name);
+    } CATCH_STD()
+}
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr(
     JNIEnv *env, jobject, jlong nativeGroupPtr, jstring name)
 {
@@ -289,3 +310,20 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeEquals(
     } CATCH_STD()
     return false;
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
+    JNIEnv*, jobject, jlong nativeGroupPtr)
+{
+    Group* grp = G(nativeGroupPtr);
+    const string table_prefix(TABLE_PREFIX);
+    const size_t table_prefix_length = table_prefix.length();
+
+    for (size_t i = 0; i < grp->size(); ++i) {
+        ConstTableRef table = grp->get_table(i);
+        const string table_name = table->get_name();
+        if (table_name.compare(0, table_prefix_length, table_prefix) == 0 && !table->is_empty()) {
+            return false;
+        }
+    }
+    return true;
+}
diff --git a/realm-jni/src/io_realm_internal_Group.h b/realm/realm-jni/src/io_realm_internal_Group.h
similarity index 84%
rename from realm-jni/src/io_realm_internal_Group.h
rename to realm/realm-jni/src/io_realm_internal_Group.h
index 46ee4e75fb..6f78409cdb 100644
--- a/realm-jni/src/io_realm_internal_Group.h
+++ b/realm/realm-jni/src/io_realm_internal_Group.h
@@ -71,6 +71,22 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName
   (JNIEnv *, jobject, jlong, jint);
 
+/*
+ * Class:     io_realm_internal_Group
+ * Method:    nativeRemoveTable
+ * Signature: (JLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_Group
+ * Method:    nativeRenameTable
+ * Signature: (JLjava/lang/String;Ljava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable
+  (JNIEnv *, jobject, jlong, jstring, jstring);
+
 /*
  * Class:     io_realm_internal_Group
  * Method:    nativeGetTableNativePtr
@@ -129,11 +145,11 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString
 
 /*
  * Class:     io_realm_internal_Group
- * Method:    nativeEquals
- * Signature: (JJ)Z
+ * Method:    nativeIsEmpty
+ * Signature: (J)Z
  */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeEquals
-  (JNIEnv *, jobject, jlong, jlong);
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
+    JNIEnv*, jobject, jlong nativeGroupPtr);
 
 #ifdef __cplusplus
 }
diff --git a/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
similarity index 74%
rename from realm-jni/src/io_realm_internal_LinkView.cpp
rename to realm/realm-jni/src/io_realm_internal_LinkView.cpp
index 9fd98b44b9..82776f3e4b 100644
--- a/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -102,8 +102,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
             ThrowException(env, IndexOutOfBounds,
                 "Indices must be within range [0, " + num_to_string(size) + "[. " +
                 "Yours were (" + num_to_string(old_pos) + "," + num_to_string(new_pos) + ")");
+            return;
         }
-        return LV(nativeLinkViewPtr)->move( S(old_pos), S(new_pos) );
+        LV(nativeLinkViewPtr)->move( S(old_pos), S(new_pos) );
     } CATCH_STD()
 }
 
@@ -158,10 +159,58 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr); 
-        Query query = lv->get_target_table().where(lv);
+        LinkView *lv = LV(nativeLinkViewPtr);
+        Query query = lv->get_target_table().where(LinkViewRef(lv));
         TableQuery* queryPtr = new TableQuery(query);
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
+  (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
+{
+    TR_ENTER_PTR(nativeLinkViewPtr)
+    try {
+        return LV(nativeLinkViewPtr)->is_attached();
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
+  (JNIEnv *env, jobject, jlong nativeLinkViewPtr, jlong targetRowIndex)
+{
+    TR_ENTER_PTR(nativeLinkViewPtr)
+    try {
+        LinkView *lv = LV(nativeLinkViewPtr);
+        if (!ROW_INDEX_VALID(env, &lv->get_target_table(), targetRowIndex)) {
+            return -1;
+        }
+        size_t ndx = lv->find(targetRowIndex);
+        return to_jlong_or_not_found(ndx);
+    } CATCH_STD()
+    return -1;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
+  (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
+{
+    TR_ENTER_PTR(nativeLinkViewPtr)
+    try {
+        LinkView *lv = LV(nativeLinkViewPtr);
+        lv->remove_all_target_rows();
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
+  (JNIEnv*, jobject, jlong nativeLinkViewPtr)
+{
+    TR_ENTER_PTR(nativeLinkViewPtr)
+
+    LinkView* lv = LV(nativeLinkViewPtr);
+    Table* pTable = &(lv->get_target_table());
+    LangBindHelper::bind_table_ptr(pTable);
+
+    return reinterpret_cast<jlong>(pTable);
+}
+
diff --git a/realm-jni/src/io_realm_internal_LinkView.h b/realm/realm-jni/src/io_realm_internal_LinkView.h
similarity index 76%
rename from realm-jni/src/io_realm_internal_LinkView.h
rename to realm/realm-jni/src/io_realm_internal_LinkView.h
index 0b5f810638..173fa010cf 100644
--- a/realm-jni/src/io_realm_internal_LinkView.h
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.h
@@ -103,6 +103,38 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_LinkView
+ * Method:    nativeIsAttached
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_LinkView
+ * Method:    nativeFind
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_LinkView
+ * Method:    nativeRemoveAllTargetRows
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_LinkView
+ * Method:    nativeGetTargetTable
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
+  (JNIEnv *, jobject, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
similarity index 72%
rename from realm-jni/src/io_realm_internal_SharedGroup.cpp
rename to realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
index 97734cb3f5..a85bc7105f 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -28,7 +28,24 @@
 using namespace std;
 using namespace realm;
 
-#define SG(ptr) reinterpret_cast<SharedGroup*>(ptr)
+inline static bool jint_to_durability_level(JNIEnv* env, jint durability, SharedGroup::DurabilityLevel &level) {
+    if (durability == 0)
+        level = SharedGroup::durability_Full;
+    else if (durability == 1)
+        level = SharedGroup::durability_MemOnly;
+    else if (durability == 2)
+#ifdef _WIN32
+        level = SharedGroup::durability_Full;   // For Windows, use Full instead of Async
+#else
+        level = SharedGroup::durability_Async;
+#endif
+    else {
+        ThrowException(env, UnsupportedOperation, "Unsupported durability.");
+        return false;
+    }
+
+    return true;
+}
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
     JNIEnv* env, jobject, jstring jfile_name, jint durability, jboolean no_create, jboolean enable_replication, jbyteArray keyArray)
@@ -53,26 +70,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
         }
         else {
             SharedGroup::DurabilityLevel level;
-            if (durability == 0)
-                level = SharedGroup::durability_Full;
-            else if (durability == 1)
-                level = SharedGroup::durability_MemOnly;
-            else if (durability == 2)
-#ifdef _WIN32
-                level = SharedGroup::durability_Full;   // For Windows, use Full instead of Async
-#else
-                level = SharedGroup::durability_Async;
-#endif
-            else {
-                ThrowException(env, UnsupportedOperation, "Unsupported durability.");
+            // Exception thrown for wrong durability value
+            if (!jint_to_durability_level(env, durability, level)) {
                 return 0;
             }
 
             KeyBuffer key(env, keyArray);
 #ifdef REALM_ENABLE_ENCRYPTION
-            db = new SharedGroup(file_name, no_create!=0, level, key.data());
+            db = new SharedGroup(file_name, no_create != 0, level, key.data());
 #else
-            db = new SharedGroup(file_name, no_create!=0, level);
+            db = new SharedGroup(file_name, no_create != 0, level);
 #endif
         }
         return reinterpret_cast<jlong>(db);
@@ -83,17 +90,23 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv* env, jobject, jlong native_replication_ptr, jbyteArray keyArray)
+  (JNIEnv* env, jobject, jlong native_replication_ptr, jint durability, jbyteArray keyArray)
 {
     TR_ENTER()
+
+    SharedGroup::DurabilityLevel level;
+    // Exception thrown for wrong durability value
+    if (!jint_to_durability_level(env, durability, level)) {
+        return 0;
+    }
+
     try {
         KeyBuffer key(env, keyArray);
 #ifdef REALM_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr), SharedGroup::durability_Full, key.data());
+        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level, key.data());
 #else
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr));
+        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level);
 #endif
-
         return reinterpret_cast<jlong>(db);
     }
     CATCH_FILE()
@@ -111,11 +124,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
         file_name = StringData(file_name_tmp);
         KeyBuffer key(env, keyArray);
 #ifdef REALM_ENABLE_ENCRYPTION
-        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name, false, key.data());
+        std::unique_ptr<Replication> hist = make_client_history(file_name, key.data());
 #else
-        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name);
+        std::unique_ptr<Replication> hist = make_client_history(file_name);
 #endif
-        return reinterpret_cast<jlong>(repl.release());
+        return reinterpret_cast<jlong>(hist.release());
     }
     CATCH_FILE(file_name)
     CATCH_STD()
@@ -139,7 +152,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
 {
     TR_ENTER_PTR(native_ptr)
     try {
-        LangBindHelper::advance_read( *SG(native_ptr) );
+        LangBindHelper::advance_read(*SG(native_ptr));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
+(JNIEnv *env, jobject, jlong native_ptr, jlong version, jlong index)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        SharedGroup::VersionID versionId(version, index);
+        LangBindHelper::advance_read(*SG(native_ptr), versionId);
     }
     CATCH_STD()
 }
@@ -149,7 +173,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
 {
     TR_ENTER_PTR(native_ptr) 
     try {
-        LangBindHelper::promote_to_write( *SG(native_ptr) );
+        LangBindHelper::promote_to_write(*SG(native_ptr));
     }
     CATCH_STD()
 }
@@ -168,7 +192,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
   (JNIEnv *, jobject, jlong native_replication_ptr)
 {
     TR_ENTER_PTR(native_replication_ptr)
-    delete reinterpret_cast<Replication*>(native_replication_ptr);
+    delete CH(native_replication_ptr);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose(
@@ -280,3 +304,23 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
     CATCH_STD()
     return false;
 }
+
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
+        (JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER()
+    SharedGroup::VersionID version_id = SG(native_ptr)->get_version_of_current_transaction();
+
+    jlong version_array [2];
+    version_array[0] = static_cast<jlong>(version_id.version);
+    version_array[1] = static_cast<jlong>(version_id.index);
+
+    jlongArray version_data = env->NewLongArray(2);
+    if (version_data == NULL) {
+        ThrowException(env, OutOfMemory, "Could not allocate memory to return versionID.");
+        return NULL;
+    }
+    env->SetLongArrayRegion(version_data, 0, 2, version_array);
+
+    return version_data;
+}
\ No newline at end of file
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.h b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
similarity index 87%
rename from realm-jni/src/io_realm_internal_SharedGroup.h
rename to realm/realm-jni/src/io_realm_internal_SharedGroup.h
index 2f6cfda0be..d41e817899 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -10,10 +10,10 @@ extern "C" {
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    createNativeWithImplicitTransactions
- * Signature: (J[B)J
+ * Signature: (JI[B)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv *, jobject, jlong, jbyteArray);
+  (JNIEnv *, jobject, jlong, jint, jbyteArray);
 
 /*
  * Class:     io_realm_internal_SharedGroup
@@ -26,15 +26,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeAdvanceRead
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeAdvanceReadToVersion
+ * Signature: (JJJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
+(JNIEnv *, jobject, jlong, jlong, jlong);
+
+
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativePromoteToWrite
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
   (JNIEnv *, jobject, jlong);
@@ -50,7 +59,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinu
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeRollbackAndContinueAsRead
- * Signature: (J)V
+ * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
   (JNIEnv *, jobject, jlong);
@@ -69,7 +78,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
  * Signature: ()Ljava/lang/String;
  */
 JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName
-  (JNIEnv *, jclass);
+  (JNIEnv *, jobject);
 
 /*
  * Class:     io_realm_internal_SharedGroup
@@ -135,6 +144,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate
   (JNIEnv *, jobject, jstring, jint, jboolean, jboolean, jbyteArray);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeCompact
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
+  (JNIEnv *, jobject, jlong);
+
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeClose
@@ -153,11 +170,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
 
 /*
  * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCompact
- * Signature: (J)Z
+ * Method:    nativeGetVersionID
+ * Signature: (J)[J
  */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
-  (JNIEnv *, jobject, jlong);
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
+        (JNIEnv *, jobject, jlong);
 
 #ifdef __cplusplus
 }
diff --git a/realm-jni/src/io_realm_internal_SubtableSchema.cpp b/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
similarity index 100%
rename from realm-jni/src/io_realm_internal_SubtableSchema.cpp
rename to realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
diff --git a/realm-jni/src/io_realm_internal_SubtableSchema.h b/realm/realm-jni/src/io_realm_internal_SubtableSchema.h
similarity index 100%
rename from realm-jni/src/io_realm_internal_SubtableSchema.h
rename to realm/realm-jni/src/io_realm_internal_SubtableSchema.h
diff --git a/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
similarity index 88%
rename from realm-jni/src/io_realm_internal_Table.h
rename to realm/realm-jni/src/io_realm_internal_Table.h
index b6829f79fd..5064e191e4 100644
--- a/realm-jni/src/io_realm_internal_Table.h
+++ b/realm/realm-jni/src/io_realm_internal_Table.h
@@ -17,6 +17,10 @@ extern "C" {
 #define io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX 1LL
 #undef io_realm_internal_Table_NO_PRIMARY_KEY
 #define io_realm_internal_Table_NO_PRIMARY_KEY -2LL
+#undef io_realm_internal_Table_NULLABLE
+#define io_realm_internal_Table_NULLABLE 1L
+#undef io_realm_internal_Table_NOT_NULLABLE
+#define io_realm_internal_Table_NOT_NULLABLE 0L
 /*
  * Class:     io_realm_internal_Table
  * Method:    createNative
@@ -41,14 +45,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeEquals
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeIsRootTable
@@ -60,10 +56,10 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeAddColumn
- * Signature: (JILjava/lang/String;)J
+ * Signature: (JILjava/lang/String;Z)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
-  (JNIEnv *, jobject, jlong, jint, jstring);
+  (JNIEnv *, jobject, jlong, jint, jstring, jboolean);
 
 /*
  * Class:     io_realm_internal_Table
@@ -89,6 +85,30 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
   (JNIEnv *, jobject, jlong, jlong, jstring);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeIsColumnNullable
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeConvertColumnToNullable
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeConvertColumnToNotNullable
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeUpdateFromSpec
@@ -185,14 +205,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow
   (JNIEnv *, jobject, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertLinkList
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertLinkList
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeGetSortedView
@@ -209,86 +221,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti
   (JNIEnv *, jobject, jlong, jlongArray, jbooleanArray);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertFloat
- * Signature: (JJJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertDouble
- * Signature: (JJJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertLong
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertLong
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertBoolean
- * Signature: (JJJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertDate
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDate
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertString
- * Signature: (JJJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertString
-  (JNIEnv *, jobject, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertMixed
- * Signature: (JJJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertSubtable
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeInsertDone
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDone
-  (JNIEnv *, jobject, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeGetLong
@@ -489,14 +421,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddInt
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeSetPrimaryKey
@@ -505,6 +429,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddInt
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey
   (JNIEnv *, jobject, jlong, jlong, jstring);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeMigratePrimaryKeyTableIfNeeded
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeAddSearchIndex
@@ -867,12 +799,21 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeMigratePrimaryKeyTableIfNeeded
- * Signature: (JJ)V;
+ * Method:    nativeHasSameSchema
+ * Signature: (JJ)Z
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeVersion
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
+        JNIEnv*, jobject, jlong);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
new file mode 100644
index 0000000000..a1e0550271
--- /dev/null
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -0,0 +1,1867 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <realm.hpp>
+#include <realm/group_shared.hpp>
+#include <realm/commit_log.hpp>
+#include "util.hpp"
+#include "io_realm_internal_TableQuery.h"
+#include "tablequery.hpp"
+
+using namespace realm;
+
+#if 1
+#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
+#define QUERY_VALID(env, pQuery)                    query_valid(env, pQuery)
+#else
+#define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
+#define QUERY_VALID(env, pQuery)                    (true)
+#endif
+
+inline bool query_valid(JNIEnv* env, Query* pQuery)
+{
+    return TABLE_VALID(env, pQuery->get_table().get());
+}
+
+inline bool query_col_type_valid(JNIEnv* env, jlong nativeQueryPtr, jlong colIndex, DataType type)
+{
+    return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TQ(nativeQueryPtr)->get_current_table().get(), colIndex, type);
+}
+
+
+const char* ERR_IMPORT_CLOSED_REALM = "Can not import results from a closed Realm";
+const char* ERR_SORT_NOT_SUPPORTED = "Sort is not supported on binary data, object references and RealmList";
+//-------------------------------------------------------
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv *, jclass, jlong nativeQueryPtr) {
+    TR_ENTER_PTR(nativeQueryPtr)
+    delete Q(nativeQueryPtr);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
+(JNIEnv *env, jobject, jlong nativeQueryPtr)
+{
+    try {
+        return to_jstring(env, Q(nativeQueryPtr)->validate());
+    } CATCH_STD();
+    return NULL;
+}
+
+
+// helper functions
+
+// Return TableRef used for build link queries
+static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indicesArray) {
+    TableRef table_ref = Q(nativeQueryPtr)->get_table();
+    jsize link_element_count = indicesArray.len() - 1;
+    for (int i = 0; i < link_element_count; i++) {
+        table_ref->link(size_t(indicesArray[i]));
+    }
+    return table_ref;
+}
+
+// Return TableRef point to original table or the link table
+static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray) {
+    TableRef table_ref = Q(nativeQueryPtr)->get_table();
+    jsize link_element_count = indicesArray.len() - 1;
+    for (int i = 0; i < link_element_count; i++) {
+        table_ref = table_ref->get_link_target(size_t(indicesArray[i]));
+    }
+    return table_ref;
+}
+
+static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
+{
+    TR_ENTER()
+    TableRef table = query.get()->get_table();
+    if (!QUERY_VALID(env, query.get()) ||
+        !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
+        return 0;
+    }
+    // run the query
+    TableView tableView(query->find_all(S(start), S(end), S(limit)));
+
+    // handover the result
+    std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
+            bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+    return reinterpret_cast<jlong>(handover.release());
+}
+
+static jlong getDistinctViewWithHandover
+        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong columnIndex)
+{
+        TableRef table = query->get_table();
+        if (!QUERY_VALID(env, query.get()) ||
+            !TBL_AND_COL_INDEX_VALID(env, table.get(), columnIndex)) {
+            return 0;
+        }
+        switch (table->get_column_type(S(columnIndex))) {
+            case type_Bool:
+            case type_Int:
+            case type_DateTime:
+            case type_String: {
+                TableView tableView(table->get_distinct_view(S(columnIndex)) );
+
+                // handover the result
+                std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
+                        bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+                return reinterpret_cast<jlong>(handover.release());
+            }
+            default:
+                ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, short, int, long and their boxed variants are supported.");
+                return 0;
+        }
+    return 0;
+}
+
+static jlong findAllSortedWithHandover
+        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+{
+        TableRef table =  query->get_table();
+
+        if (!(QUERY_VALID(env, query.get()) && ROW_INDEXES_VALID(env, table.get(), start, end, limit))) {
+            return 0;
+        }
+
+        // run the query
+        TableView tableView( query->find_all(S(start), S(end), S(limit)) );
+
+        // sorting the results
+        if (!COL_INDEX_VALID(env, &tableView, columnIndex)) {
+            return 0;
+        }
+
+        int colType = tableView.get_column_type( S(columnIndex) );
+        switch (colType) {
+            case type_Bool:
+            case type_Int:
+            case type_DateTime:
+            case type_Float:
+            case type_Double:
+            case type_String:
+                tableView.sort( S(columnIndex), ascending != 0);
+                break;
+            default:
+                ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
+                return 0;
+        }
+
+        // handover the result
+        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+        return reinterpret_cast<jlong>(handover.release());
+}
+
+static jlong findAllMultiSortedWithHandover
+        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+{
+        JniLongArray long_arr(env, columnIndices);
+        JniBooleanArray bool_arr(env, ascending);
+        jsize arr_len = long_arr.len();
+        jsize asc_len = bool_arr.len();
+
+        if (arr_len == 0) {
+            ThrowException(env, IllegalArgument, "You must provide at least one field name.");
+            return 0;
+        }
+        if (asc_len == 0) {
+            ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
+            return 0;
+        }
+        if (arr_len != asc_len) {
+            ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
+            return 0;
+        }
+
+        TableRef table = query->get_table();
+
+        if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
+            return 0;
+        }
+
+        // run the query
+        TableView tableView( query->find_all(S(start), S(end), S(limit)) );
+
+        // sorting the results
+        std::vector<size_t> indices;
+        std::vector<bool> ascendings;
+
+        for (int i = 0; i < arr_len; ++i) {
+            if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
+                return -1;
+            }
+            int colType = tableView.get_column_type( S(long_arr[i]) );
+            switch (colType) {
+                case type_Bool:
+                case type_Int:
+                case type_DateTime:
+                case type_Float:
+                case type_Double:
+                case type_String:
+                    indices.push_back( S(long_arr[i]) );
+                    ascendings.push_back( B(bool_arr[i]) );
+                    break;
+                default:
+                    ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
+                    return 0;
+            }
+        }
+
+        tableView.sort(indices, ascendings);
+
+        // handover the result
+        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+        return reinterpret_cast<jlong>(handover.release());
+}
+
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
+}
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_notequal(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) != cpptype(value);
+}
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_greater(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) > cpptype(value);
+}
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_greaterequal(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) >= cpptype(value);
+}
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_less(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) < cpptype(value);
+}
+
+template <typename coretype, typename cpptype, typename javatype>
+Query numeric_link_lessequal(TableRef tbl, jlong columnIndex, javatype value) {
+    return tbl->column<coretype>(size_t(columnIndex)) <= cpptype(value);
+}
+
+
+// Integer
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<int64_t>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    if (arr_len == 1) {
+        if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            return;
+        }
+        try {
+            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<int64_t>(value1), static_cast<int64_t>(value2));
+        } CATCH_STD()
+    }
+    else {
+        ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
+    }
+}
+
+// Float
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<float>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jfloat value1, jfloat value2)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+                return;
+            }
+            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<float>(value1), static_cast<float>(value2));
+        }
+        else {
+            ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
+        }
+    } CATCH_STD()
+}
+
+
+// Double
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<double>(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jdouble value1, jdouble value2)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+                return;
+            }
+            Q(nativeQueryPtr)->between(S(arr[0]), static_cast<double>(value1), static_cast<double>(value2));
+        }
+        else {
+            ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
+        }
+    } CATCH_STD()
+}
+
+
+// DateTime
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->equal_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(
+                    numeric_link_equal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->not_equal_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(
+                    numeric_link_notequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->greater_equal_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->less_equal_datetime(S(arr[0]), DateTime(value));
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+                return;
+            }
+            Q(nativeQueryPtr)->between_datetime(S(arr[0]), DateTime(value1), DateTime(value2));
+        }
+        else {
+            ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
+        }
+    } CATCH_STD()
+}
+
+// Bool
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(
+  JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jboolean value)
+{
+    JniLongArray arr(env, columnIndexes);
+    try {    jsize arr_len = arr.len();
+
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Bool)) {
+                return;
+            }
+            Q(nativeQueryPtr)->equal(S(arr[0]), value != 0 ? true : false);
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, arr[arr_len-1], value));
+        }
+    } CATCH_STD()
+}
+
+// String
+
+enum StringPredicate {
+    StringEqual,
+    StringNotEqual,
+    StringContains,
+    StringBeginsWith,
+    StringEndsWith
+};
+
+
+void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    try {
+        if (value == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len-1])) {
+                return;
+            }
+        }
+        bool is_case_sensitive = caseSensitive ? true : false;
+        JStringAccessor value2(env, value); // throws
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_String)) {
+                return;
+            }
+            switch (predicate) {
+            case StringEqual:
+                Q(nativeQueryPtr)->equal(S(arr[0]), value2, is_case_sensitive);
+                break;
+            case StringNotEqual:
+                Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, is_case_sensitive);
+                break;
+            case StringContains:
+                Q(nativeQueryPtr)->contains(S(arr[0]), value2, is_case_sensitive);
+                break;
+            case StringBeginsWith:
+                Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, is_case_sensitive);
+                break;
+            case StringEndsWith:
+                Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
+                break;
+            }
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            switch (predicate) {
+            case StringEqual:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).equal(StringData(value2), is_case_sensitive));
+                break;
+            case StringNotEqual:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).not_equal(StringData(value2), is_case_sensitive));
+                break;
+            case StringContains:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).contains(StringData(value2), is_case_sensitive));
+                break;
+            case StringBeginsWith:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).begins_with(StringData(value2), is_case_sensitive));
+                break;
+            case StringEndsWith:
+                Q(nativeQueryPtr)->and_query(table_ref->column<String>(size_t(arr[arr_len-1])).ends_with(StringData(value2), is_case_sensitive));
+                break;
+            }
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z(
+    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEqual);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z(
+    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringNotEqual);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringBeginsWith);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+{
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
+}
+
+
+// General ----------------------------------------------------
+// TODO:
+// Some of these methods may not need the check for Table/Query validity,
+// as they are called for each method when building up the query.
+// Consider to reduce to just the "action" methods on Query
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeTableview(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong nativeTableViewPtr)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return;
+    try {
+        pQuery->get_table()->where(TV(nativeTableViewPtr));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup(
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return;
+    try {
+        pQuery->group();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup(
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return;
+    try {
+        pQuery->end_group();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr(
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
+{
+    // No verification of parameters needed?
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return;
+    try {
+        pQuery->Or();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return;
+    try {
+        pQuery->Not();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong columnIndex)
+{
+    TableQuery* pTQuery = TQ(nativeQueryPtr);
+    if (!QUERY_VALID(env, pTQuery))
+        return;
+
+    try {
+        Table* pTable = pTQuery->get_current_table().get();
+        pTQuery->push_subtable(S(columnIndex));
+        if (!COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Table))
+            return;
+
+        pTQuery->subtable(S(columnIndex));
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent(
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
+{
+    TableQuery* pTQuery = TQ(nativeQueryPtr);
+    if (!QUERY_VALID(env, pTQuery))
+        return;
+    try {
+        if (pTQuery->pop_subtable()) {
+            pTQuery->end_subtable();
+        }
+        else {
+            ThrowException(env, UnsupportedOperation, "No matching subtable().");
+        }
+    } CATCH_STD()
+}
+
+
+// Find --------------------------------------
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong fromTableRow)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery))
+        return -1;
+    // It's valid to go 1 past the end index
+    if ((fromTableRow < 0) || (S(fromTableRow) > pTable->size())) {
+        // below check will fail with appropriate exception
+        (void) ROW_INDEX_VALID(env, pTable, fromTableRow);
+        return -1;
+    }
+
+    try {
+        size_t r = pQuery->find( S(fromTableRow) );
+        return (r == not_found) ? jlong(-1) : jlong(r);
+    } CATCH_STD()
+    return -1;
+}
+
+std::unique_ptr<Query> getHandoverQuery (jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
+{
+    SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
+    std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
+
+    SG(bgSharedGroupPtr)->end_read();
+
+    SharedGroup::VersionID currentVersion = SG(bgSharedGroupPtr)->get_version_of_current_transaction();
+    bool isDifferentVersions = (currentVersion != handoverQuery->version);
+    if (isDifferentVersions) {
+        SG(bgSharedGroupPtr)->begin_read(handoverQuery->version);
+    } else {
+        SG(bgSharedGroupPtr)->begin_read();
+    }
+
+    std::unique_ptr<Query> query = SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery));
+    if (advanceToLatestVersion && isDifferentVersions) {
+        LangBindHelper::advance_read(*SG(bgSharedGroupPtr));
+    }
+
+    return query;
+}
+
+// queryPtr would be owned and released by this function
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
+    JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong fromTableRow)
+{
+    TR_ENTER()
+    try {
+        std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, false);
+        TableRef table = query->get_table();
+
+        if (!QUERY_VALID(env, query.get())) {
+            return 0;
+        }
+
+        // It's valid to go 1 past the end index
+        if ((fromTableRow < 0) || (S(fromTableRow) > table->size())) {
+            // below check will fail with appropriate exception
+            (void) ROW_INDEX_VALID(env, table.get(), fromTableRow);
+            return 0;
+        }
+
+        size_t r = query->find(S(fromTableRow));
+        if (r == not_found) {
+            return 0;
+        } else {
+            // handover the result
+            Row row = (*table)[r];
+            std::unique_ptr<SharedGroup::Handover<Row>> handover = SG(
+                    bgSharedGroupPtr)->export_for_handover(row);
+            return reinterpret_cast<jlong>(handover.release());
+        }
+
+    } CATCH_STD()
+    return 0;
+}
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+{
+    TR_ENTER()
+    Query* query = Q(nativeQueryPtr);
+    TableRef table =  query->get_table();
+    if (!QUERY_VALID(env, query) ||
+        !ROW_INDEXES_VALID(env, table.get(), start, end, limit))
+        return -1;
+    try {
+        TableView* tableView = new TableView( query->find_all(S(start), S(end), S(limit)) );
+        return reinterpret_cast<jlong>(tableView);
+    } CATCH_STD()
+    return -1;
+}
+
+// queryPtr would be owned and released by this function
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
+  (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
+  {
+      TR_ENTER()
+      try {
+          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          return findAllWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit);
+      } CATCH_STD()
+      return 0;
+  }
+
+
+
+// Should match the values in Java ArgumentsHolder class
+enum query_type {QUERY_TYPE_FIND_ALL = 0, QUERY_TYPE_DISTINCT = 4, QUERY_TYPE_FIND_ALL_SORTED = 1, QUERY_TYPE_FIND_ALL_MULTI_SORTED = 2};
+
+// batch update of async queries
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
+        (JNIEnv *env, jobject, jlong bgSharedGroupPtr,
+         jlongArray  handover_queries_array /*list of handover queries*/,
+         jobjectArray  query_param_matrix /*type & params of the query to be updated*/,
+         jobjectArray  multi_sorted_indices_matrix,
+         jobjectArray  multi_sorted_order_matrix)
+{
+    TR_ENTER()
+    try {
+        JniLongArray handover_queries_pointer_array(env, handover_queries_array);
+
+        const size_t number_of_queries = env->GetArrayLength(query_param_matrix);
+
+        std::vector<jlong> exported_handover_tableview_array(number_of_queries);
+
+        // Step1: Position the shared group at the handover query version so we can import all queries
+
+        // read the first query to determine the version we should use
+        SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, handover_queries_pointer_array[0]);
+        std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
+        // position this shared group at the specified version
+        SG(bgSharedGroupPtr)->begin_read(handoverQuery->version);
+
+        std::vector<std::unique_ptr<Query>> queries(number_of_queries);
+
+        // import the first query
+        queries[0] = std::move(SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery)));
+
+        // import the rest of the queries
+        for (size_t i = 1; i < number_of_queries; ++i) {
+            std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
+            queries[i] = std::move(SG(bgSharedGroupPtr)->import_from_handover(std::move(handoverQuery)));
+        }
+
+        // Step2: Bring the queries into the latest shared group version
+        LangBindHelper::advance_read(*SG(bgSharedGroupPtr));
+
+        // Step3: Run & export the queries against the latest shared group
+        for (size_t i = 0; i < number_of_queries; ++i) {
+            JniLongArray query_param_array(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            switch (query_param_array[0]) { // 0, index of the type of query, the next indicies are parameters
+                case QUERY_TYPE_FIND_ALL: {// nativeFindAllWithHandover
+                    exported_handover_tableview_array[i] =
+                            findAllWithHandover
+                                    (env,
+                                     bgSharedGroupPtr,
+                                     std::move(queries[i]),
+                                     query_param_array[1]/*start*/,
+                                     query_param_array[2]/*end*/,
+                                     query_param_array[3]/*limit*/);
+                    break;
+                }
+                case QUERY_TYPE_DISTINCT: {// nativeGetDistinctViewWithHandover
+                    exported_handover_tableview_array[i] =
+                            getDistinctViewWithHandover
+                                    (env,
+                                     bgSharedGroupPtr,
+                                     std::move(queries[i]),
+                                     query_param_array[1]/*columnIndex*/);
+                    break;
+                }
+                case QUERY_TYPE_FIND_ALL_SORTED: {// nativeFindAllSortedWithHandover
+                    exported_handover_tableview_array[i] =
+                            findAllSortedWithHandover
+                                    (env,
+                                     bgSharedGroupPtr,
+                                     std::move(queries[i]),
+                                     query_param_array[1]/*start*/,
+                                     query_param_array[2]/*end*/,
+                                     query_param_array[3]/*limit*/,
+                                     query_param_array[4]/*columnIndex*/,
+                                     query_param_array[5] == 1/*ascending order*/);
+                    break;
+                }
+                case QUERY_TYPE_FIND_ALL_MULTI_SORTED: {// nativeFindAllMultiSortedWithHandover
+                    jlongArray column_indices_array = (jlongArray) env->GetObjectArrayElement(
+                            multi_sorted_indices_matrix, i);
+                    jbooleanArray column_order_array = (jbooleanArray) env->GetObjectArrayElement(
+                            multi_sorted_order_matrix, i);
+                    exported_handover_tableview_array[i] =
+                            findAllMultiSortedWithHandover
+                                    (env,
+                                     bgSharedGroupPtr,
+                                     std::move(queries[i]),
+                                     query_param_array[1]/*start*/,
+                                     query_param_array[2]/*end*/,
+                                     query_param_array[3]/*limit*/,
+                                     column_indices_array/*columnIndices*/,
+                                     column_order_array/*ascending orders*/);
+                    break;
+                }
+                default:
+                    ThrowException(env, FatalError, "Unknown type of query.");
+                    return NULL;
+            }
+        }
+
+        jlongArray exported_handover_tableview = env->NewLongArray(number_of_queries);
+        if (exported_handover_tableview == NULL) {
+            ThrowException(env, OutOfMemory, "Could not allocate memory to return updated queries.");
+            return NULL;
+        }
+        env->SetLongArrayRegion(exported_handover_tableview, 0, number_of_queries,
+                exported_handover_tableview_array.data());
+        return exported_handover_tableview;
+
+    } CATCH_STD()
+    return NULL;
+}
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
+        (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong columnIndex)
+{
+    TR_ENTER()
+    try {
+        std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+        return getDistinctViewWithHandover(env, bgSharedGroupPtr, std::move(query), columnIndex);
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
+  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+  {
+      TR_ENTER()
+      try {
+          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          return findAllSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit, columnIndex, ascending);
+      } CATCH_STD()
+      return 0;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
+  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+  {
+      TR_ENTER()
+      try {
+          // import the handover query pointer using the background SharedGroup
+          std::unique_ptr<Query> query = getHandoverQuery(bgSharedGroupPtr, queryPtr, true);
+          return findAllMultiSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit,columnIndices, ascending);
+      } CATCH_STD()
+      return 0;
+  }
+
+// Integer Aggregates
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        return pQuery->sum_int(S(columnIndex), NULL, S(start), S(end), S(limit));
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        int64_t result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        int64_t result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Int) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        size_t resultcount;
+        //TODO: return resultcount?
+        double avg = pQuery->average_int(S(columnIndex), &resultcount, S(start), S(end), S(limit));
+        //fprintf(stderr, "!!!Average(%d, %d) = %f (%d results)\n", start, end, avg, resultcount); fflush(stderr);
+        return avg;
+    } CATCH_STD()
+    return 0;
+}
+
+
+// float Aggregates
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        return pQuery->sum_float(S(columnIndex), NULL, S(start), S(end), S(limit));
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        float result = pQuery->maximum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewFloat(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        float result = pQuery->minimum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewFloat(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Float) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        size_t resultcount;
+        double avg = pQuery->average_float(S(columnIndex), &resultcount, S(start), S(end), S(limit));
+        return avg;
+    } CATCH_STD()
+    return 0;
+}
+
+// double Aggregates
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        return pQuery->sum_double(S(columnIndex), NULL, S(start), S(end), S(limit));
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        double result = pQuery->maximum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewDouble(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        double result = pQuery->minimum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewDouble(env, result);
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Double) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        //TODO: Return resultcount
+        size_t resultcount;
+        double avg = pQuery->average_double(S(columnIndex), &resultcount, S(start), S(end), S(limit));
+        return avg;
+    } CATCH_STD()
+    return 0;
+}
+
+
+// date aggregates
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        DateTime result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result.get_datetime());
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate(
+    JNIEnv* env, jobject, jlong nativeQueryPtr,
+    jlong columnIndex, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return NULL;
+    try {
+        size_t return_ndx;
+        DateTime result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result.get_datetime());
+        }
+    } CATCH_STD()
+    return NULL;
+}
+
+// Count, Remove
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        return pQuery->count(S(start), S(end), S(limit));
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    Table* pTable = pQuery->get_table().get();
+    if (!QUERY_VALID(env, pQuery) ||
+        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+        return 0;
+    try {
+        return pQuery->remove(S(start), S(end), S(limit));
+    } CATCH_STD()
+    return 0;
+}
+
+// isNull and isNotNull
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
+    JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes)
+{
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    Query* pQuery = Q(nativeQueryPtr);
+
+    try {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+        jlong column_idx = arr[arr_len-1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+            return;
+        }
+
+        int col_type = table_ref->get_column_type(S(column_idx));
+        if (arr_len == 1) {
+            switch (col_type) {
+                case type_Link:
+                    pQuery->and_query(src_table_ref->column<Link>(S(column_idx)).is_null());
+                    break;
+                case type_LinkList:
+                    // Cannot get here. Exception will be thrown in TBL_AND_COL_NULLABLE
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    break;
+                case type_Binary:
+                    pQuery->equal(S(column_idx), BinaryData());
+                    break;
+                case type_String:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_DateTime:
+                    Q(nativeQueryPtr)->equal(S(column_idx), realm::null());
+                    break;
+                default:
+                    // this point is unreachable
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    return;
+            }
+        } else {
+            switch (col_type) {
+                case type_Link:
+                    ThrowException(env, IllegalArgument, "isNull() by nested query for link field is not supported.");
+                    break;
+                case type_LinkList:
+                    // Cannot get here. Exception will be thrown in TBL_AND_COL_NULLABLE
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    break;
+                case type_String:
+                    pQuery->and_query(src_table_ref->column<String>(S(column_idx)) == realm::null());
+                    break;
+                case type_Binary:
+                    pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) == BinaryData());
+                    break;
+                case type_Bool:
+                    pQuery->and_query(src_table_ref->column<Bool>(S(column_idx)) == realm::null());
+                    break;
+                case type_Int:
+                    pQuery->and_query(src_table_ref->column<Int>(S(column_idx)) == realm::null());
+                    break;
+                case type_Float:
+                    pQuery->and_query(src_table_ref->column<Float>(S(column_idx)) == realm::null());
+                    break;
+                case type_Double:
+                    pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) == realm::null());
+                    break;
+                case type_DateTime:
+                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) == realm::null());
+                    break;
+                default:
+                    // this point is unreachable
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    return;
+            }
+        }
+    } CATCH_STD()
+}
+
+// handoverPtr will be released in this function
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
+  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  {
+    TR_ENTER_PTR(handoverPtr)
+    SharedGroup::Handover<TableView> *handoverTableViewPtr = HO(TableView, handoverPtr);
+    std::unique_ptr<SharedGroup::Handover<TableView> > handoverTableView(handoverTableViewPtr);
+
+    try {
+        // import_from_handover will free (delete) the handover
+        if (SG(callerSharedGrpPtr)->is_attached()) {
+            std::unique_ptr<TableView> tableView = SG(callerSharedGrpPtr)->import_from_handover(
+                    std::move(handoverTableView));
+            return reinterpret_cast<jlong>(tableView.release());
+        } else {
+            ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
+        }
+    } CATCH_STD()
+    return 0;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
+  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  {
+      TR_ENTER_PTR(handoverPtr)
+      SharedGroup::Handover<Row> *handoverRowPtr = HO(Row, handoverPtr);
+      std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
+
+      try {
+          // import_from_handover will free (delete) the handover
+          if (SG(callerSharedGrpPtr)->is_attached()) {
+              std::unique_ptr<Row> row = SG(callerSharedGrpPtr)->import_from_handover(
+                      std::move(handoverRow));
+              return reinterpret_cast<jlong>(row.release());
+          } else {
+              ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
+          }
+      } CATCH_STD()
+      return 0;
+  }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
+   (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong nativeQueryPtr)
+{
+    TR_ENTER_PTR(nativeQueryPtr)
+    Query* pQuery = Q(nativeQueryPtr);
+    if (!QUERY_VALID(env, pQuery))
+        return 0;
+    try {
+        std::unique_ptr<SharedGroup::Handover<Query> > handoverQueryPtr = SG(bgSharedGroupPtr)->export_for_handover(*pQuery, ConstSourcePayload::Copy);
+        return reinterpret_cast<jlong>(handoverQueryPtr.release());
+    } CATCH_STD()
+    return 0;
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
+  (JNIEnv *, jobject, jlong nativeHandoverQuery)
+  {
+    TR_ENTER_PTR(nativeHandoverQuery)
+    delete HO(Query, nativeHandoverQuery);
+  }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
+  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes) {
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    Query* pQuery = Q(nativeQueryPtr);
+    try {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+        jlong column_idx = arr[arr_len-1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+
+        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+            return;
+        }
+
+        int col_type = table_ref->get_column_type(S(column_idx));
+        if (arr_len == 1) {
+            switch (col_type) {
+                case type_Link:
+                    pQuery->and_query(src_table_ref->column<Link>(S(column_idx)).is_not_null());
+                    break;
+                case type_LinkList:
+                    // Cannot get here. Exception will be thrown in TBL_AND_COL_NULLABLE
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    break;
+                case type_Binary:
+                    pQuery->not_equal(S(column_idx), realm::BinaryData());
+                    break;
+                case type_String:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_DateTime:
+                    pQuery->not_equal(S(column_idx), realm::null());
+                    break;
+                default:
+                    // this point is unreachable
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    return;
+            }
+        }
+        else {
+            switch (col_type) {
+                case type_Link:
+                    ThrowException(env, IllegalArgument, "isNotNull() by nested query for link field is not supported.");
+                    break;
+                case type_LinkList:
+                    // Cannot get here. Exception will be thrown in TBL_AND_COL_NULLABLE
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    break;
+                case type_String:
+                    pQuery->and_query(src_table_ref->column<String>(S(column_idx)) != realm::null());
+                    break;
+                case type_Binary:
+                    pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) != realm::BinaryData());
+                    break;
+                case type_Bool:
+                    pQuery->and_query(src_table_ref->column<Bool>(S(column_idx)) != realm::null());
+                    break;
+                case type_Int:
+                    pQuery->and_query(src_table_ref->column<Int>(S(column_idx)) != realm::null());
+                    break;
+                case type_Float:
+                    pQuery->and_query(src_table_ref->column<Float>(S(column_idx)) != realm::null());
+                    break;
+                case type_Double:
+                    pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) != realm::null());
+                    break;
+                case type_DateTime:
+                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) != realm::null());
+                    break;
+                default:
+                    // this point is unreachable
+                    ThrowException(env, FatalError, "This is not reachable.");
+                    return;
+            }
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
+    (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes) {
+
+    JniLongArray arr(env, columnIndexes);
+    jsize arr_len = arr.len();
+    Query* pQuery = Q(nativeQueryPtr);
+    try {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+        jlong column_idx = arr[arr_len - 1];
+        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+
+        int col_type = table_ref->get_column_type(S(column_idx));
+        if (arr_len == 1) {
+            // Field queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->equal(S(column_idx), BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    break;
+                case type_String:
+                    pQuery->equal(S(column_idx), "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_DateTime:
+                default:
+                    ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList.");
+                    return;
+            }
+        }
+        else {
+            // Linked queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) == BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(src_table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    break;
+                case type_String:
+                    pQuery->and_query(src_table_ref->column<String>(S(column_idx)) == "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_DateTime:
+                default:
+                    ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList across links.");
+                    return;
+            }
+        }
+    } CATCH_STD()
+}
diff --git a/realm-jni/src/io_realm_internal_TableQuery.h b/realm/realm-jni/src/io_realm_internal_TableQuery.h
similarity index 77%
rename from realm-jni/src/io_realm_internal_TableQuery.h
rename to realm/realm-jni/src/io_realm_internal_TableQuery.h
index 5ccb9eeb7e..943f9a2227 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.h
@@ -359,6 +359,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindWithHandover
+ * Signature: (JJJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeFindAll
@@ -367,6 +375,62 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllWithHandover
+ * Signature: (JJJJJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeGetDistinctViewWithHandover
+ * Signature: (JJJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
+        (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllSortedWithHandover
+ * Signature: (JJJJJJJZ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllMultiSortedWithHandover
+ * Signature: (JJJJJJ[J[Z)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
+  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeImportHandoverTableViewIntoSharedGroup
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeImportHandoverRowIntoSharedGroup
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeHandoverQuery
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeSumInt
@@ -378,17 +442,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMaximumInt
- * Signature: (JJJJJ)J
+ * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMinimumInt
- * Signature: (JJJJJ)J
+ * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
@@ -410,17 +474,17 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMaximumFloat
- * Signature: (JJJJJ)F
+ * Signature: (JJJJJ)Ljava/lang/Float;
  */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMinimumFloat
- * Signature: (JJJJJ)F
+ * Signature: (JJJJJ)Ljava/lang/Float;
  */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
@@ -442,17 +506,17 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMaximumDouble
- * Signature: (JJJJJ)D
+ * Signature: (JJJJJ)Ljava/lang/Double;
  */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMinimumDouble
- * Signature: (JJJJJ)D
+ * Signature: (JJJJJ)Ljava/lang/Double;
  */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
@@ -466,26 +530,50 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMaximumDate
- * Signature: (JJJJJ)J
+ * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeMinimumDate
- * Signature: (JJJJJ)J
+ * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeIsNull
- * Signature: (JJ)V
+ * Signature: (J[J)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jobject, jlong, jlongArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeIsEmpty
+ * Signature: (J[J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
+  (JNIEnv *, jobject, jlong, jlongArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeIsNonEmpty
+ * Signature: (J[J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNonEmpty
+  (JNIEnv *, jobject, jlong, jlongArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeIsNotNull
+ * Signature: (J[J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
+  (JNIEnv *, jobject, jlong, jlongArray);
 
 /*
  * Class:     io_realm_internal_TableQuery
@@ -503,6 +591,28 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseQueryHandover
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseQueryHandover
+ * Signature: (JJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeAcceptHandoverQuery
+        (JNIEnv *, jlong, jlong , jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeBatchUpdateQueries
+ */
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
+        (JNIEnv *,jobject,jlong ,jlongArray,jobjectArray,jobjectArray,jobjectArray);
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
similarity index 90%
rename from realm-jni/src/io_realm_internal_TableView.h
rename to realm/realm-jni/src/io_realm_internal_TableView.h
index 3b1d14de6a..63c986e52a 100644
--- a/realm-jni/src/io_realm_internal_TableView.h
+++ b/realm/realm-jni/src/io_realm_internal_TableView.h
@@ -255,14 +255,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNullLink
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeNullifyLink
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAddInt
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeAddInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeClear
@@ -386,17 +378,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSumInt
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMaximumInt
- * Signature: (JJ)J
+ * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMaximumInt
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumInt
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMinimumInt
- * Signature: (JJ)J
+ * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMinimumInt
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumInt
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -418,17 +410,17 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumFloat
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMaximumFloat
- * Signature: (JJ)F
+ * Signature: (JJ)Ljava/lang/Float;
  */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMinimumFloat
- * Signature: (JJ)F
+ * Signature: (JJ)Ljava/lang/Float;
  */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -450,17 +442,17 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumDouble
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMaximumDouble
- * Signature: (JJ)D
+ * Signature: (JJ)Ljava/lang/Double;
  */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMinimumDouble
- * Signature: (JJ)D
+ * Signature: (JJ)Ljava/lang/Double;
  */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -474,17 +466,17 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMaximumDate
- * Signature: (JJ)J
+ * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMinimumDate
- * Signature: (JJ)J
+ * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -543,6 +535,22 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_TableView
+ * Method:    nativeDistinct
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableView
+ * Method:    nativeMultiDistinct
+ * Signature: (J[J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti
+  (JNIEnv *, jobject, jlong, jlongArray);
+
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativePivot
@@ -559,6 +567,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_TableView
+ * Method:    nativeFindBySourceNdx
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
+        (JNIEnv *, jobject, jlong, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_Row.cpp b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
similarity index 56%
rename from realm-jni/src/io_realm_internal_Row.cpp
rename to realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
index 44140a7886..2c126a5db0 100644
--- a/realm-jni/src/io_realm_internal_Row.cpp
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
@@ -14,40 +14,43 @@
  * limitations under the License.
  */
 
-#include "io_realm_internal_Row.h"
+#include "io_realm_internal_UncheckedRow.h"
 #include "util.hpp"
 #include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
 
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
   (JNIEnv *, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
+
     return ROW(nativeRowPtr)->get_column_count(); // noexcept
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetColumnName
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
-        return NULL;
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+        return 0;
+
     try {
         return to_jstring(env, ROW(nativeRowPtr)->get_column_name( S(columnIndex)));
     } CATCH_STD();
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr, jstring columnName)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
+
     try {
         JStringAccessor columnName2(env, columnName); // throws
         return to_jlong_or_not_found( ROW(nativeRowPtr)->get_column_index(columnName2) ); // noexcept
@@ -55,17 +58,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
     return 0;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
-        return 0;
-
     return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -75,78 +75,82 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
     return ROW(nativeRowPtr)->get_index();
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_int( S(columnIndex) );
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_bool( S(columnIndex) );
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_float( S(columnIndex) );
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_double( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->get_datetime( S(columnIndex) ).get_datetime();
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     try {
-        return to_jstring(env, ROW(nativeRowPtr)->get_string( S(columnIndex) ));
+        StringData value = ROW(nativeRowPtr)->get_string( S(columnIndex) );
+        return to_jstring(env,  value);
     } CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     BinaryData bin = ROW(nativeRowPtr)->get_binary( S(columnIndex) );
-    if (bin.size() <= MAX_JSIZE) {
+    if (bin.is_null()) {
+        return NULL;
+    }
+    else if (bin.size() <= MAX_JSIZE) {
         jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
         if (jresult)
             env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()), reinterpret_cast<const jbyte*>(bin.data()));  // throws
@@ -158,23 +162,23 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
     }
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     DataType mixedType = ROW(nativeRowPtr)->get_mixed_type( S(columnIndex) );  // noexcept
     return static_cast<jint>(mixedType);
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
+JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return NULL;
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
+        return 0;
 
     Mixed value = ROW(nativeRowPtr)->get_mixed( S(columnIndex) );  // noexcept
     try {
@@ -183,44 +187,45 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
-    if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) )) {
+
+    if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) ))
         return jlong(-1);
-    }
+
     return ROW(nativeRowPtr)->get_link( S(columnIndex) );
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     return ROW(nativeRowPtr)->is_null_link( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
     LinkView* link_view_ptr = LangBindHelper::get_linklist_ptr( *ROW( nativeRowPtr ), S( columnIndex) );
     return reinterpret_cast<jlong>(link_view_ptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -228,11 +233,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -240,11 +245,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -252,11 +257,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -264,11 +269,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if(!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -276,52 +281,73 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
+        if ((value == NULL) && !(ROW(nativeRowPtr)->get_table()->is_nullable( S(columnIndex) ))) {
+            ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
+            return;
+        }
         JStringAccessor value2(env, value); // throws
         ROW(nativeRowPtr)->set_string( S(columnIndex), value2);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
-        return;
 
-    jbyte* bytePtr = env->GetByteArrayElements(value, NULL);
-    if (!bytePtr) {
-        ThrowException(env, IllegalArgument, "doByteArray");
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
+
+    jbyte* bytePtr = NULL;
+    try {
+        if (value == NULL) {
+            if (!(ROW(nativeRowPtr)->get_table()->is_nullable(S(columnIndex)))) {
+                ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
+                return;
+            }
+            ROW(nativeRowPtr)->set_binary(S(columnIndex), BinaryData());
+        }
+        else {
+            bytePtr = env->GetByteArrayElements(value, NULL);
+            if (!bytePtr) {
+                ThrowException(env, IllegalArgument, "doByteArray");
+                return;
+            }
+            size_t dataLen = S(env->GetArrayLength(value));
+            ROW(nativeRowPtr)->set_binary( S(columnIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
+        }
+    } CATCH_STD()
+
+    if (bytePtr) {
+        env->ReleaseByteArrayElements(value, bytePtr, JNI_ABORT);
     }
-    size_t dataLen = S(env->GetArrayLength(value));
-    ROW(nativeRowPtr)->set_binary( S(columnIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
-    env->ReleaseByteArrayElements(value, bytePtr, 0);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
+
     try {
         row_nativeSetMixed(ROW(nativeRowPtr), env, columnIndex, jMixedValue);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -329,11 +355,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+    if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
     try {
@@ -341,17 +367,35 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeClose
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
   (JNIEnv *, jclass, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     delete ROW(nativeRowPtr);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsAttached
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
   (JNIEnv *, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_attached();
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jstring columnName)
+{
+    jlong ndx = Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex(env, obj, nativeRowPtr, columnName);
+    return ndx != to_jlong_or_not_found(realm::not_found);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
+  (JNIEnv *, jobject, jlong nativeRowPtr, jlong columnIndex) {
+    TR_ENTER_PTR(nativeRowPtr)
+    return ROW(nativeRowPtr)->is_null(columnIndex);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
+  (JNIEnv *, jobject, jlong nativeRowPtr, jlong columnIndex) {
+    TR_ENTER_PTR(nativeRowPtr)
+    ROW(nativeRowPtr)->set_null(columnIndex);
+}
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
new file mode 100644
index 0000000000..b714145ce3
--- /dev/null
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
@@ -0,0 +1,269 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class io_realm_internal_UncheckedRow */
+
+#ifndef _Included_io_realm_internal_UncheckedRow
+#define _Included_io_realm_internal_UncheckedRow
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnCount
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnName
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnIndex
+ * Signature: (JLjava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetIndex
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLong
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetBoolean
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetFloat
+ * Signature: (JJ)F
+ */
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetDouble
+ * Signature: (JJ)D
+ */
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetDateTime
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetString
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeIsNullLink
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetByteArray
+ * Signature: (JJ)[B
+ */
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetMixedType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetMixed
+ * Signature: (JJ)Lio/realm/internal/Mixed;
+ */
+JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLinkView
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetLong
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetBoolean
+ * Signature: (JJZ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
+  (JNIEnv *, jobject, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetFloat
+ * Signature: (JJF)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
+  (JNIEnv *, jobject, jlong, jlong, jfloat);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLink
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetDouble
+ * Signature: (JJD)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
+  (JNIEnv *, jobject, jlong, jlong, jdouble);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetDate
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetString
+ * Signature: (JJLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
+  (JNIEnv *, jobject, jlong, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetByteArray
+ * Signature: (JJ[B)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
+  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetMixed
+ * Signature: (JJLio/realm/internal/Mixed;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
+  (JNIEnv *, jobject, jlong, jlong, jobject);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetLink
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeNullifyLink
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeClose
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeIsAttached
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeHasColumn
+ * Signature: (JLjava/lang/String;)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeIsNull
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetNull
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
+  (JNIEnv *, jobject, jlong, jlong);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/realm-jni/src/io_realm_internal_Util.cpp b/realm/realm-jni/src/io_realm_internal_Util.cpp
similarity index 68%
rename from realm-jni/src/io_realm_internal_Util.cpp
rename to realm/realm-jni/src/io_realm_internal_Util.cpp
index 101af77390..03d298af02 100644
--- a/realm-jni/src/io_realm_internal_Util.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Util.cpp
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+#include <jni.h>
+
 #include "util.hpp"
 #include "mem_usage.hpp"
 #include "io_realm_internal_Util.h"
@@ -27,13 +29,42 @@ using std::string;
 
 // used by logging
 int trace_level = 0;
-const char *log_tag = "REALM";
+const char* log_tag = "REALM";
+
+const char* const TABLE_PREFIX = "class_";
 
-JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM*, void*)
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return JNI_ERR;
+    }
+    else {
+        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
+        java_lang_long        = GetClass(env, "java/lang/Long");
+        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
+        java_lang_float       = GetClass(env, "java/lang/Float");
+        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
+        java_lang_double      = GetClass(env, "java/lang/Double");
+        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
+    }
+
     return JNI_VERSION_1_6;
 }
 
+JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
+{
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return;
+    }
+    else {
+        env->DeleteGlobalRef(java_lang_long);
+        env->DeleteGlobalRef(java_lang_float);
+        env->DeleteGlobalRef(java_lang_double);
+    }
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel(JNIEnv*, jclass, jint level)
 {
     trace_level = level;
@@ -44,6 +75,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, j
     return GetMemUsage();
 }
 
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
+    JNIEnv* env, jclass)
+{
+    return to_jstring(env, string(TABLE_PREFIX));
+}
+
 // -------------------------- Testcases for exception handling
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
@@ -102,16 +139,15 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
             if (dotest)
                 ThrowException(env, UnsupportedOperation, "parm1", "parm2");
             break;
-                ThrowException(env, OutOfMemory, "parm1", "parm2");
         case OutOfMemory:
             expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
             if (dotest)
                 ThrowException(env, OutOfMemory, "parm1", "parm2");
             break;
-        case Unspecified:
-            expect = "java.lang.RuntimeException: Unspecified exception. parm1";
+        case FatalError:
+            expect = "io.realm.exceptions.RealmError: Unrecoverable error. parm1";
             if (dotest)
-                ThrowException(env, Unspecified, "parm1", "parm2");
+                ThrowException(env, FatalError, "parm1", "parm2");
             break;
         case RuntimeError:
             expect = "java.lang.RuntimeException: parm1";
@@ -121,8 +157,19 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
         case RowInvalid:
             expect = "java.lang.IllegalStateException: Illegal State: parm1";
             if (dotest)
-                ThrowException(env, TableInvalid, "parm1", "parm2");
+                ThrowException(env, RowInvalid, "parm1", "parm2");
             break;
+        case CrossTableLink:
+            expect = "java.lang.IllegalStateException: This class is referenced by other classes. Remove those fields first before removing this class.";
+            if (dotest)
+                ThrowException(env, CrossTableLink, "parm1");
+            break;
+        case BadVersion:
+            expect = "io.realm.internal.async.BadVersionException: parm1";
+            if (dotest)
+                ThrowException(env, BadVersion, "parm1", "parm2");
+            break;
+
     }
     if (dotest) {
         return NULL;
diff --git a/realm-jni/src/io_realm_internal_Util.h b/realm/realm-jni/src/io_realm_internal_Util.h
similarity index 80%
rename from realm-jni/src/io_realm_internal_Util.h
rename to realm/realm-jni/src/io_realm_internal_Util.h
index 6309b24aa6..8a41d65d19 100644
--- a/realm-jni/src/io_realm_internal_Util.h
+++ b/realm/realm-jni/src/io_realm_internal_Util.h
@@ -23,6 +23,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage
 JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel
   (JNIEnv *, jclass, jint);
 
+/*
+ * Class:     io_realm_internal_Util
+ * Method:    nativeGetTablePrefix
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix
+  (JNIEnv *, jclass);
+
 /*
  * Class:     io_realm_internal_Util
  * Method:    nativeTestcase
diff --git a/realm-jni/src/io_realm_internal_Version.cpp b/realm/realm-jni/src/io_realm_internal_Version.cpp
similarity index 100%
rename from realm-jni/src/io_realm_internal_Version.cpp
rename to realm/realm-jni/src/io_realm_internal_Version.cpp
diff --git a/realm-jni/src/io_realm_internal_Version.h b/realm/realm-jni/src/io_realm_internal_Version.h
similarity index 100%
rename from realm-jni/src/io_realm_internal_Version.h
rename to realm/realm-jni/src/io_realm_internal_Version.h
diff --git a/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_table.cpp
similarity index 76%
rename from realm-jni/src/io_realm_internal_table.cpp
rename to realm/realm-jni/src/io_realm_internal_table.cpp
index 55f5d8cbc3..f04541417d 100644
--- a/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_table.cpp
@@ -29,22 +29,41 @@
 using namespace std;
 using namespace realm;
 
+inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
+    if (!(column_type == type_String ||
+                column_type == type_Int ||
+                column_type == type_Bool ||
+                column_type == type_DateTime)) {
+        ThrowException(env, IllegalArgument,
+                "This field cannot be indexed - "
+                "Only String/byte/short/int/long/boolean/Date fields are supported.");
+        return false;
+    }
+    return true;
+}
+
 // Note: Don't modify spec on a table which has a shared_spec.
 // A spec is shared on subtables that are not in Mixed columns.
 //
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
-  (JNIEnv *env, jobject, jlong nativeTablePtr, jint colType, jstring name)
+  (JNIEnv *env, jobject, jlong nativeTablePtr, jint colType, jstring name, jboolean isNullable)
 {
     if (!TABLE_VALID(env, TBL(nativeTablePtr)))
         return 0;
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to add column in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation, "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
         return 0;
     }
     try {
         JStringAccessor name2(env, name); // throws
-        return TBL(nativeTablePtr)->add_column(DataType(colType), name2);
+        bool is_column_nullable = isNullable != 0 ? true : false;
+
+        DataType dataType = DataType(colType);
+        if (is_column_nullable && dataType == type_LinkList) {
+             ThrowException(env, IllegalArgument, "List fields cannot be nullable.");
+        }
+        return TBL(nativeTablePtr)->add_column(dataType, name2, is_column_nullable);
     } CATCH_STD()
     return 0;
 }
@@ -55,7 +74,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink
     if (!TABLE_VALID(env, TBL(nativeTablePtr)))
             return 0;
         if (TBL(nativeTablePtr)->has_shared_type()) {
-            ThrowException(env, UnsupportedOperation, "Not allowed to add column in subtable. Use getSubtableSchema() on root table instead.");
+            ThrowException(env, UnsupportedOperation, "Not allowed to add field in subtable. Use getSubtableSchema() on root table instead.");
             return 0;
         }
         if (!TBL(targetTablePtr)->is_group_level()) {
@@ -108,7 +127,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
     if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
         return;
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to remove column in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation, "Not allowed to remove field in subtable. Use getSubtableSchema() on root table instead.");
         return;
     }
     try {
@@ -122,7 +141,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
     if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
         return;
     if (TBL(nativeTablePtr)->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to rename column in subtable. Use getSubtableSchema() on root table instead.");
+        ThrowException(env, UnsupportedOperation, "Not allowed to rename field in subtable. Use getSubtableSchema() on root table instead.");
         return;
     }
     try {
@@ -131,6 +150,239 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
     } CATCH_STD()
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
+  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+{
+    Table *table = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
+        return false;
+    }
+    if (table->has_shared_type()) {
+        ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+        return false;
+    }
+    size_t column_index = S(columnIndex);
+    return table->is_nullable(column_index);
+}
+
+
+// General comments about the implementation of 
+// Java_io_realm_internal_Table_nativeConvertColumnToNullable and Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
+//
+// 1. converting a (not-)nullable column is idempotent (and is implemented as a no-op)
+// 2. not all column types can be converted (cannot be (not-)nullable)
+// 3. converting to not-nullable, null values are converted to (core's) default values of the type
+// 4. as temporary column is __inserted__ just before the column to be converted
+// 4a. __TMP__number is used as name of the temporary column
+// 4b. with N columns, at most N __TMP__i (0 <= i < N) must be tried, and while (true) { .. } will always terminate
+// 4c. the temporary column will have index columnIndex (or column_index)
+// 4d. the column to be converted will index shifted one place to column_index + 1
+// 5. search indexing must be preserved
+// 6. removing the original column and renaming the temporary column will make it look like original is being modified
+
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable
+  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+{
+    Table *table = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
+        return;
+    }
+    if (table->has_shared_type()) {
+        ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+        return;
+    }
+    try {
+        size_t column_index = S(columnIndex);
+        if (table->is_nullable(column_index)) {
+            return; // column is already nullable
+        }
+
+        std::string column_name = table->get_column_name(column_index);
+        DataType column_type = table->get_column_type(column_index);
+        if (column_type == type_Link ||
+            column_type == type_LinkList ||
+            column_type == type_Mixed ||
+            column_type == type_Table) {
+            ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
+        }
+
+        std::string tmp_column_name;
+
+        size_t j = 0;
+        while (true) {
+            std::ostringstream ss;
+            ss << std::string("__TMP__") << j;
+            if (table->get_column_index(ss.str()) == realm::not_found) {
+                table->insert_column(column_index, column_type, ss.str(), true);
+                tmp_column_name = ss.str();
+                break;
+            }
+            j++;
+        }
+
+        for (size_t i = 0; i < table->size(); ++i) {
+            switch (column_type) {
+                case type_String:
+                    // Payload copy is needed
+                    table->set_string(column_index, i, std::string(table->get_string(column_index + 1, i)));
+                    break;
+                case type_Binary: {
+                    // Payload copy is needed
+                    BinaryData bd = table->get_binary(column_index + 1, i);
+                    std::vector<char> binary_copy(bd.data(), bd.data() + bd.size());
+                    table->set_binary(column_index, i, BinaryData(binary_copy.data(), binary_copy.size()));
+                    break;
+                }
+                case type_Int:
+                    table->set_int(column_index, i, table->get_int(column_index + 1, i));
+                    break;
+                case type_Bool:
+                    table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
+                    break;
+                case type_DateTime:
+                    table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                    break;
+                case type_Float:
+                    table->set_float(column_index, i, table->get_float(column_index + 1, i));
+                    break;
+                case type_Double:
+                    table->set_double(column_index, i, table->get_double(column_index + 1, i));
+                    break;
+                case type_Link:
+                case type_LinkList:
+                case type_Mixed:
+                case type_Table:
+                    // checked previously
+                    break;
+            }
+        }
+        if (table->has_search_index(column_index + 1)) {
+            table->add_search_index(column_index);
+        }
+        table->remove_column(column_index + 1);
+        table->rename_column(table->get_column_index(tmp_column_name), column_name);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
+  (JNIEnv *env, jobject, jlong nativeTablePtr, jlong columnIndex)
+{
+    Table *table = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
+        return;
+    }
+    if (table->has_shared_type()) {
+        ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+        return;
+    }
+    try {
+        size_t column_index = S(columnIndex);
+        if (!table->is_nullable(column_index)) {
+            return; // column is already not nullable
+        } 
+
+        std::string column_name = table->get_column_name(column_index);
+        DataType column_type = table->get_column_type(column_index);
+        if (column_type == type_Link ||
+            column_type == type_LinkList ||
+            column_type == type_Mixed ||
+            column_type == type_Table) {
+            ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
+        }
+
+        std::string tmp_column_name;
+        size_t j = 0;
+        while (true) {
+            std::ostringstream ss;
+            ss << std::string("__TMP__") << j;
+            if (table->get_column_index(ss.str()) == realm::not_found) {
+                table->insert_column(column_index, column_type, ss.str(), false);
+                tmp_column_name = ss.str();
+                break;
+            }
+            j++;
+        }
+
+        for (size_t i = 0; i < table->size(); ++i) {
+            switch (column_type) { // FIXME: respect user-specified default values
+                case type_String: {
+                    StringData sd = table->get_string(column_index + 1, i);
+                    if (sd == realm::null()) {
+                        table->set_string(column_index, i, "");
+                    }
+                    else {
+                        // Payload copy is needed
+                        table->set_string(column_index, i, std::string(sd));
+                    }
+                    break;
+                }
+                case type_Binary: {
+                    BinaryData bd = table->get_binary(column_index + 1, i);
+                    if (bd.is_null()) {
+                        table->set_binary(column_index, i, BinaryData(""));
+                    }
+                    else {
+                        // Payload copy is needed
+                        std::vector<char> bd_copy(bd.data(), bd.data() + bd.size());
+                        table->set_binary(column_index, i, BinaryData(bd_copy.data(), bd_copy.size()));
+                    }
+                    break;
+                }
+                case type_Int:
+                    if (table->is_null(column_index + 1, i)) {
+                        table->set_int(column_index, i, 0);
+                    }
+                    else {
+                        table->set_int(column_index, i, table->get_int(column_index + 1, i));
+                    }
+                    break;
+                case type_Bool:
+                    if (table->is_null(column_index + 1, i)) {
+                        table->set_bool(column_index, i, false);
+                    }
+                    else {
+                        table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
+                    }
+                    break;
+                case type_DateTime:
+                    if (table->is_null(column_index + 1, i)) {
+                        table->set_datetime(column_index, i, static_cast<time_t>(0));
+                    }
+                    else {
+                        table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                    }
+                    break;
+                case type_Float:
+                    if (table->is_null(column_index + 1, i)) {
+                        table->set_float(column_index, i, 0.0);
+                    }
+                    else {
+                        table->set_float(column_index, i, table->get_float(column_index + 1, i));
+                    }
+                    break;
+                case type_Double:
+                    if (table->is_null(column_index + 1, i)) {
+                        table->set_double(column_index, i, 0.0);
+                    }
+                    else {
+                        table->set_double(column_index, i, table->get_double(column_index + 1, i));
+                    }
+                    break;
+                case type_Link:
+                case type_LinkList:
+                case type_Mixed:
+                case type_Table:
+                    // checked previously
+                    break;
+            }
+        }
+        if (table->has_search_index(column_index + 1)) {
+            table->add_search_index(column_index);
+        }
+        table->remove_column(column_index + 1);
+        table->rename_column(table->get_column_index(tmp_column_name), column_name);
+    } CATCH_STD()
+}
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
   (JNIEnv *, jobject, jlong nativeTablePtr)
@@ -263,15 +515,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertLinkList
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_LinkList))
-        return;
-
-    TBL(nativeTablePtr)->insert_linklist( S(columnIndex), S(rowIndex) );
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong rowIndex)
 {
@@ -302,80 +545,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
     } CATCH_STD()
 }
 
-
-// ----------------- Insert cell
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertLong(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_int( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertBoolean(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_bool( S(columnIndex), S(rowIndex), value != 0 ? true : false);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_float( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_double( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDate(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong dateTimeValue)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_DateTime))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_datetime( S(columnIndex), S(rowIndex), static_cast<time_t>(dateTimeValue));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
-        return;
-    try {
-        JStringAccessor value2(env, value); // throws
-        TBL(nativeTablePtr)->insert_string( S(columnIndex), S(rowIndex), value2);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertMixed(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    if (!TBL_AND_INDEX_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex))
-        return;
-    try {
-        tbl_nativeDoMixed(&Table::insert_mixed, TBL(nativeTablePtr), env, columnIndex, rowIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
 {
@@ -386,30 +555,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertSubtable(
-    JNIEnv* env, jobject jTable, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
-        return;
-
-    TR("nativeInsertSubtable(jTable:%p, nativeTablePtr: %p, colIdx: %" PRId64 ", rowIdx: %" PRId64 ")",
-        VOID_PTR(jTable), VOID_PTR(nativeTablePtr),  S64(columnIndex), S64(rowIndex))
-    try {
-        TBL(nativeTablePtr)->insert_subtable( S(columnIndex), S(rowIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertDone(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return;
-    try {
-        TBL(nativeTablePtr)->insert_done();
-    } CATCH_STD()
-}
-
-
 // ----------------- Get cell
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong(
@@ -628,6 +773,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
         return;
     try {
+        if (value == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+                return;
+            }
+        }
         JStringAccessor value2(env, value); // throws
         TBL(nativeTablePtr)->set_string( S(columnIndex), S(rowIndex), value2);
     } CATCH_STD()
@@ -654,17 +804,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
     } CATCH_STD()
 }
 */
-/*
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertByteBuffer(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
-        return;
-    try {
-        tbl_nativeDoBinary(&Table::insert_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, byteBuffer);
-    } CATCH_STD()
-}
-*/
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
@@ -672,37 +811,18 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
         return;
     try {
-        tbl_nativeDoByteArray(&Table::set_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, dataArray);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertByteArray(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
-        return;
-    try {
-        tbl_nativeDoByteArray(&Table::insert_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, dataArray);
-    } CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
-        return;
-    if (pTable->get_column_type (S(columnIndex)) != type_Int) {
-        ThrowException(env, IllegalArgument, "Invalid columntype - only Long columns are supported at the moment.");
-        return;
-    }
-    try {
-        TBL(nativeTablePtr)->add_int( S(columnIndex), value);
+        if (dataArray == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+                return;
+            }
+            TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), BinaryData());
+        }
+        else {
+            tbl_nativeDoByteArray(&Table::set_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, dataArray);
+        }
     } CATCH_STD()
 }
 
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
@@ -731,10 +851,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex(
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
         return;
-    if (pTable->get_column_type (S(columnIndex)) != type_String) {
-        ThrowException(env, IllegalArgument, "Invalid columntype - only string columns are supported at the moment.");
+
+    DataType column_type = pTable->get_column_type (S(columnIndex));
+    if (!is_allowed_to_index(env, column_type)) {
         return;
     }
+
     try {
         pTable->add_search_index( S(columnIndex));
     } CATCH_STD()
@@ -746,8 +868,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex(
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
         return;
-    if (pTable->get_column_type (S(columnIndex)) != type_String) {
-        ThrowException(env, IllegalArgument, "Invalid columntype - only string columns are supported at the moment.");
+    DataType column_type = pTable->get_column_type (S(columnIndex));
+    if (!is_allowed_to_index(env, column_type)) {
         return;
     }
     try {
@@ -1066,7 +1188,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate(
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
         return 0;
     try {
-        size_t res = TBL(nativeTablePtr)->find_first_datetime( S(columnIndex), (time_t)dateTimeValue);
+        size_t res = TBL(nativeTablePtr)->find_first_datetime( S(columnIndex), DateTime(dateTimeValue));
         return to_jlong_or_not_found( res );
     } CATCH_STD()
     return 0;
@@ -1141,7 +1263,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDate(
         return 0;
     try {
         TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_datetime( S(columnIndex),
-                                            static_cast<time_t>(dateTimeValue)) );
+                                            DateTime(dateTimeValue)) );
         return reinterpret_cast<jlong>(pTableView);
     } CATCH_STD()
     return 0;
@@ -1201,17 +1323,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
         return 0;
     if (!pTable->has_search_index(S(columnIndex))) {
-        ThrowException(env, UnsupportedOperation, "The column must be indexed before distinct() can be used.");
+        ThrowException(env, UnsupportedOperation, "The field must be indexed before distinct() can be used.");
         return 0;
     }
-    if (pTable->get_column_type(S(columnIndex)) != type_String) {
-        ThrowException(env, IllegalArgument, "Invalid columntype - only string columns are supported.");
-        return 0;
+    switch (pTable->get_column_type(S(columnIndex))) {
+        case type_Bool:
+        case type_Int:
+        case type_DateTime:
+        case type_String:
+            try {
+                TableView* pTableView = new TableView( pTable->get_distinct_view(S(columnIndex)) );
+                return reinterpret_cast<jlong>(pTableView);
+            } CATCH_STD()
+            break;
+        default:
+            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, short, int, long and their boxed variants are supported.");
+            return 0;
+        break;
     }
-    try {
-        TableView* pTableView = new TableView( pTable->get_distinct_view(S(columnIndex)) );
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
     return 0;
 }
 
@@ -1246,8 +1375,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
 {
     Table* pTable = TBL(nativeTablePtr);
 
-    jsize arr_len = env->GetArrayLength(columnIndices);
-    jsize asc_len = env->GetArrayLength(ascending);
+    JniLongArray long_arr(env, columnIndices);
+    JniBooleanArray bool_arr(env, ascending);
+    jsize arr_len = long_arr.len();
+    jsize asc_len = bool_arr.len();
+
     if (arr_len == 0) {
         ThrowException(env, IllegalArgument, "You must provide at least one field name.");
         return 0;
@@ -1261,15 +1393,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
         return 0;
     }
 
-    jlong *long_arr = env->GetLongArrayElements(columnIndices, NULL);
-    jboolean *bool_arr = env->GetBooleanArrayElements(ascending, NULL);
-
     std::vector<size_t> indices(S(arr_len));
     std::vector<bool> ascendings(S(arr_len));
 
     for (int i = 0; i < arr_len; ++i) {
-        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]) ))
+        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]) )) {
             return 0;
+        }
         int colType = pTable->get_column_type( S(long_arr[i]) );
         switch (colType) {
             case type_Int:
@@ -1287,9 +1417,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
         }
     }
 
-    env->ReleaseLongArrayElements(columnIndices, long_arr, 0);
-    env->ReleaseBooleanArrayElements(ascending, bool_arr, 0);
-
     try {
         TableView* pTableView = new TableView(pTable->get_sorted_view(indices, ascendings));
         return reinterpret_cast<jlong>(pTableView);
@@ -1424,7 +1551,7 @@ bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column
                     int64_t next_val = results.get_int(column_index, i);
                     if (val == next_val) {
                         std::ostringstream error_msg;
-                        error_msg << "Field \"" << table->get_column_name(column_index).data() << "\" cannot be a primary key, ";
+                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
                         error_msg << "it already contains duplicate values: " << val;
                         ThrowException(env, IllegalArgument, error_msg.str());
                         return false;
@@ -1443,7 +1570,7 @@ bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column
                     string next_str = results.get_string(column_index, i);
                     if (str.compare(next_str) == 0) {
                         std::ostringstream error_msg;
-                        error_msg << "Field \"" << table->get_column_name(column_index).data() << "\" cannot be a primary key, ";
+                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
                         error_msg << "it already contains duplicate values: " << str;
                         ThrowException(env, IllegalArgument, error_msg.str());
                         return false;
@@ -1467,7 +1594,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     try {
         Table* table = TBL(nativeTablePtr);
         Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const char* table_name = table->get_name().data();
+        const std::string table_name(table->get_name().substr(6)); // Remove "class_" prefix
         size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
@@ -1506,33 +1633,80 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     return 0;
 }
 
-// Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
+// 1) Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
 // This affects:
 // - All Realms created by Cocoa and used by Realm-android up to 0.80.1
 // - All Realms created by Realm-Android 0.80.1 and below
 // See https://github.com/realm/realm-java/issues/1059
-// This methods converts the old (wrong) table format (string, integer) to the right (string,string) format.
+//
+// 2) Fix interop issue with Cocoa Realm where primary key tables on Cocoa doesn't have the "class_" prefix.
+// This affects:
+// - All Realms created by Cocoa and used by Realm-android up to 0.84.1
+// - All Realms created by Realm-Android 0.84.1 and below
+// See https://github.com/realm/realm-java/issues/1703
+
+// This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
+// any class names in the col[0] of their "class_" prefix
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
     (JNIEnv*, jobject, jlong groupNativePtr, jlong privateKeyTableNativePtr)
 {
+    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
+    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
+
     Group* group = G(groupNativePtr);
     Table* pk_table = TBL(privateKeyTableNativePtr);
-    if (pk_table->get_column_type(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX) == type_Int) {
+
+    // Fix wrong types (string, int) -> (string, string)
+    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
         StringData tmp_col_name = StringData("tmp_field_name");
         size_t tmp_col_ndx = pk_table->add_column(DataType(type_String), tmp_col_name);
 
         // Create tmp string column with field name instead of column index
         size_t number_of_rows = pk_table->size();
         for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
-            StringData table_name = pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_ndx);
-            size_t col_ndx = static_cast<size_t>(pk_table->get_int(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_ndx));
+            StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+            size_t col_ndx = static_cast<size_t>(pk_table->get_int(FIELD_COLUMN_INDEX, row_ndx));
             StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
-            pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
+            // Make a copy of the string
+            pk_table->set_string(tmp_col_ndx, row_ndx, std::string(col_name));
         }
 
         // Delete old int column, and rename tmp column to same name
         // The column index for the renamed column will then be the same as the deleted old column
-        pk_table->remove_column(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX);
+        pk_table->remove_column(FIELD_COLUMN_INDEX);
         pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
     }
+
+    // If needed remove "class_" prefix from class names
+    size_t number_of_rows = pk_table->size();
+    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+        if (table_name.begins_with("class_")) {
+            // New string copy is needed, since the original memory will be changed.
+            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, std::string(table_name.substr(6)));
+        }
+    }
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
+  (JNIEnv *, jobject, jlong thisTablePtr, jlong otherTablePtr)
+{
+    return *TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor();
+}
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
+        JNIEnv* env, jobject, jlong nativeTablePtr)
+{
+    bool valid = (TBL(nativeTablePtr) != NULL);
+    if (valid) {
+        if (!TBL(nativeTablePtr)->is_attached()) {
+            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            return 0;
+        }
+    }
+    try {
+        return (jlong) TBL(nativeTablePtr)->get_version_counter();
+    } CATCH_STD()
+    return 0;
 }
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-jni/src/io_realm_internal_tableview.cpp
similarity index 83%
rename from realm-jni/src/io_realm_internal_tableview.cpp
rename to realm/realm-jni/src/io_realm_internal_tableview.cpp
index f138569147..93d2fd07dd 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-jni/src/io_realm_internal_tableview.cpp
@@ -19,6 +19,7 @@
 #include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
 #include "tablequery.hpp"
+#include "realm/array.hpp"
 #include <ostream>
 
 using namespace realm;
@@ -27,10 +28,10 @@ using namespace realm;
 #define VIEW_VALID_AND_IN_SYNC(env, ptr) view_valid_and_in_sync(env, ptr)
 
 inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
-    bool valid = (nativeViewPtr != 0);
+    bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "Table is closed, and no longer valid to operate on.");
+            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
             return false;
         }
         TV(nativeViewPtr)->sync_if_needed();
@@ -48,6 +49,65 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView(
     return 0;
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct(
+    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
+{
+    if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
+        return;
+    if (!COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
+        return;
+    if (!TV(nativeViewPtr)->get_parent().has_search_index(S(columnIndex))) {
+        ThrowException(env, UnsupportedOperation, "The field must be indexed before distinct() can be used.");
+        return;
+    }
+    try {
+        switch (TV(nativeViewPtr)->get_column_type(S(columnIndex))) {
+            case type_Bool:
+            case type_Int:
+            case type_DateTime:
+            case type_String:
+                TV(nativeViewPtr)->distinct(S(columnIndex));
+                break;
+            default:
+                ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
+                break;
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti(
+    JNIEnv* env, jobject, jlong nativeViewPtr, jlongArray columnIndexes)
+{
+    if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
+        return;
+    try {
+        JniLongArray indexes(env, columnIndexes);
+        jsize indexes_len = indexes.len();
+        std::vector<size_t> columns;
+        for (int i = 0; i < indexes_len; ++i) {
+            if (!COL_INDEX_VALID(env, TV(nativeViewPtr), indexes[i])) {
+                return;
+            }
+            if (!TV(nativeViewPtr)->get_parent().has_search_index(S(indexes[i]))) {
+                ThrowException(env, IllegalArgument, "The field must be indexed before distinct(...) can be used.");
+                return;
+            }
+            switch (TV(nativeViewPtr)->get_column_type(S(indexes[i]))) {
+                case type_Bool:
+                case type_Int:
+                case type_DateTime:
+                case type_String:
+                    columns.push_back(S(indexes[i]));
+                    break;
+                default:
+                    ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
+                    return;
+            }
+        }
+        TV(nativeViewPtr)->distinct(columns);
+    } CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot(
     JNIEnv *env, jobject, jlong dataTablePtr, jlong stringCol, jlong intCol, jint operation, jlong resultTablePtr)
 {
@@ -105,9 +165,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSourceRowIndex
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
+            return npos;
         if (!ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return 0;
+            return npos;
     } CATCH_STD()
     return TV(nativeViewPtr)->get_source_ndx(S(rowIndex));   // noexcept
 }
@@ -385,6 +445,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_String))
             return;
+        if (!TV(nativeViewPtr)->get_parent().is_nullable(S(columnIndex))) {
+            ThrowNullValueException(env, &(TV(nativeViewPtr)->get_parent()), S(columnIndex));
+            return;
+        }
         JStringAccessor value2(env, value);  // throws
         TV(nativeViewPtr)->set_string( S(columnIndex), S(rowIndex), value2);
     } CATCH_STD()
@@ -459,25 +523,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeNullifyLink
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeAddInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
-            return;
-        TV(nativeViewPtr)->add_int( S(columnIndex), value);
-    } CATCH_STD()
-}
-
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClear(
     JNIEnv* env, jobject, jlong nativeViewPtr)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return;
-        TV(nativeViewPtr)->clear();
+        TV(nativeViewPtr)->clear(RemoveMode::unordered);
     } CATCH_STD()
 }
 
@@ -488,7 +540,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeRemoveRow(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
             return;
-        TV(nativeViewPtr)->remove( S(rowIndex));
+        TV(nativeViewPtr)->remove( S(rowIndex), RemoveMode::unordered);
     } CATCH_STD()
 }
 
@@ -550,7 +602,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
             return 0;
-        return to_jlong_or_not_found( TV(nativeViewPtr)->find_first_datetime( S(columnIndex), (time_t)dateTimeValue) );
+        return to_jlong_or_not_found( TV(nativeViewPtr)->find_first_datetime( S(columnIndex), DateTime(dateTimeValue)) );
     } CATCH_STD()
     return 0;
 }
@@ -632,7 +684,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
             return 0;
         TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_datetime( S(columnIndex),
-                                                static_cast<time_t>(dateTimeValue)) );
+                                                DateTime(dateTimeValue)) );
         return reinterpret_cast<jlong>(pResultView);
     } CATCH_STD()
     return 0;
@@ -680,28 +732,36 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageInt(
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMaximumInt(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumInt(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        return TV(nativeViewPtr)->maximum_int( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        int64_t result = TV(nativeViewPtr)->maximum_int( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMinimumInt(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumInt(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        return TV(nativeViewPtr)->minimum_int( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        int64_t result = TV(nativeViewPtr)->minimum_int( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
 // float aggregates
@@ -730,28 +790,36 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageFloat(
     return 0;
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        return TV(nativeViewPtr)->maximum_float( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        float result = TV(nativeViewPtr)->maximum_float( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewFloat(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        return TV(nativeViewPtr)->minimum_float( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        float result = TV(nativeViewPtr)->minimum_float( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewFloat(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
 // double aggregates
@@ -780,57 +848,73 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble(
     return 0;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        return TV(nativeViewPtr)->maximum_double( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        double result = TV(nativeViewPtr)->maximum_double( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewDouble(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        return TV(nativeViewPtr)->minimum_double( S(columnIndex));
+            return NULL;
+        size_t return_ndx;
+        double result = TV(nativeViewPtr)->minimum_double( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewDouble(env, result);
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
 
 // date aggregates
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMaximumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
-            return 0;
-        // This exploits the fact that dates are stored as int in core
-        return TV(nativeViewPtr)->maximum_int( S(columnIndex));
+            return NULL;
+
+        size_t return_ndx;
+        DateTime result = TV(nativeViewPtr)->maximum_datetime( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result.get_datetime());
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeMinimumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
-            return 0;
-        // This exploits the fact that dates are stored as int in core
-        return TV(nativeViewPtr)->minimum_int( S(columnIndex));
+            return NULL;
+
+        size_t return_ndx;
+        DateTime result = TV(nativeViewPtr)->minimum_datetime( S(columnIndex), &return_ndx);
+        if (return_ndx != npos) {
+            return NewLong(env, result.get_datetime());
+        }
     } CATCH_STD()
-    return 0;
+    return NULL;
 }
 
 // sort
@@ -854,7 +938,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
                 TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
                 break;
             default:
-                ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, float, double, boolean, Date, and String columns.");
+                ThrowException(env, IllegalArgument, "Sort is not supported on binary data, object references and RealmList.");
                 return;
         }
     } CATCH_STD()
@@ -867,11 +951,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return;
 
-        jsize arr_len = env->GetArrayLength(columnIndices);
-        jsize asc_len = env->GetArrayLength(ascending);
-
-        jlong *long_arr = env->GetLongArrayElements(columnIndices, NULL);
-        jboolean *bool_arr = env->GetBooleanArrayElements(ascending, NULL);
+        JniLongArray long_arr(env, columnIndices);
+        JniBooleanArray bool_arr(env, ascending);
+        jsize arr_len = long_arr.len();
+        jsize asc_len = bool_arr.len();
 
         if (arr_len == 0) {
             ThrowException(env, IllegalArgument, "You must provide at least one field name.");
@@ -882,7 +965,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
             return;
         }
         if (arr_len != asc_len) {
-            ThrowException(env, IllegalArgument, "Number of column indices and sort orders do not match.");
+            ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
             return;
         }
 
@@ -890,8 +973,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
         std::vector<bool> ascendings;
 
         for (int i = 0; i < arr_len; ++i) {
-            if (!COL_INDEX_VALID(env, TV(nativeViewPtr), long_arr[i]))
+            if (!COL_INDEX_VALID(env, TV(nativeViewPtr), long_arr[i])) {
                 return;
+            }
             int colType = TV(nativeViewPtr)->get_column_type( S(long_arr[i]) );
             switch (colType) {
                 case type_Bool:
@@ -904,13 +988,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
                 default:
-                    ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, float, double, boolean, Date, and String columns.");
+                    ThrowException(env, IllegalArgument, "Sort is not supported on binary data, object references and RealmList.");
                     return;
             }
         }
         TV(nativeViewPtr)->sort(indices, ascendings);
-        env->ReleaseLongArrayElements(columnIndices, long_arr, 0);
-        env->ReleaseBooleanArrayElements(ascending, bool_arr, 0);
     } CATCH_STD()
 }
 
@@ -962,9 +1044,10 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
-  (JNIEnv *env, jobject, jlong nativeViewPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
+    JNIEnv *env, jobject, jlong nativeViewPtr)
 {
+    TR_ENTER_PTR(nativeViewPtr)
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return 0;
@@ -979,10 +1062,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync(
     JNIEnv* env, jobject, jlong nativeViewPtr)
 {
-    bool valid = (nativeViewPtr != 0);
+    bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "Table is closed, and no longer valid to operate on.");
+            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
             return 0;
         }
     }
@@ -991,3 +1074,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync(
     } CATCH_STD()
     return 0;
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
+        (JNIEnv *env, jobject, jlong nativeViewPtr, jlong sourceIndex)
+{
+    TR_ENTER_PTR(nativeViewPtr);
+    try {
+        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, &(TV(nativeViewPtr)->get_parent()), sourceIndex))
+            return -1;
+
+        size_t ndx = TV(nativeViewPtr)->find_by_source_ndx(sourceIndex);
+        return to_jlong_or_not_found(ndx);
+    } CATCH_STD()
+    return -1;
+}
diff --git a/realm-jni/src/java_lang_List_Util.cpp b/realm/realm-jni/src/java_lang_List_Util.cpp
similarity index 100%
rename from realm-jni/src/java_lang_List_Util.cpp
rename to realm/realm-jni/src/java_lang_List_Util.cpp
diff --git a/realm-jni/src/java_lang_List_Util.hpp b/realm/realm-jni/src/java_lang_List_Util.hpp
similarity index 100%
rename from realm-jni/src/java_lang_List_Util.hpp
rename to realm/realm-jni/src/java_lang_List_Util.hpp
diff --git a/realm-jni/src/mem_usage.cpp b/realm/realm-jni/src/mem_usage.cpp
similarity index 100%
rename from realm-jni/src/mem_usage.cpp
rename to realm/realm-jni/src/mem_usage.cpp
diff --git a/realm-jni/src/mem_usage.hpp b/realm/realm-jni/src/mem_usage.hpp
similarity index 100%
rename from realm-jni/src/mem_usage.hpp
rename to realm/realm-jni/src/mem_usage.hpp
diff --git a/realm-jni/src/mixedutil.cpp b/realm/realm-jni/src/mixedutil.cpp
similarity index 97%
rename from realm-jni/src/mixedutil.cpp
rename to realm/realm-jni/src/mixedutil.cpp
index 98f3852d4c..ce80c43cb7 100644
--- a/realm-jni/src/mixedutil.cpp
+++ b/realm/realm-jni/src/mixedutil.cpp
@@ -43,7 +43,7 @@ jmethodID GetMixedMethodID(JNIEnv* env, const char* methodStr, const char* typeS
 DataType GetMixedObjectType(JNIEnv* env, jobject jMixed)
 {
     // Call Java "Mixed.getType"
-    static jmethodID jGetTypeMethodId = GetMixedMethodID(env, "getType", "()Lio/realm/internal/ColumnType;");
+    static jmethodID jGetTypeMethodId = GetMixedMethodID(env, "getType", "()Lio/realm/RealmFieldType;");
     if (jGetTypeMethodId == NULL)
         return DataType(0);
 
@@ -92,7 +92,7 @@ jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
     }
     case type_DateTime:
         {
-            time_t timeValue = mixed.get_datetime().get_datetime();
+            int_fast64_t timeValue = mixed.get_datetime().get_datetime();
             jclass jDateClass = env->FindClass("java/util/Date");
             if (jDateClass == NULL) {
                 ThrowException(env, ClassNotFound, "Date");
@@ -121,7 +121,7 @@ jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
         {
             // param input: Table* t.
             TR("   --Mixed(type_Table)")
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Lio/realm/internal/ColumnType;)V");
+            jmethodID consId = GetMixedMethodID(env, "<init>", "(Lio/realm/RealmFieldType;)V");
 
             jobject jColumnType = NULL; // GetJColumnTypeFromColumnType(env, type_Table);
             if (consId)
diff --git a/realm-jni/src/mixedutil.hpp b/realm/realm-jni/src/mixedutil.hpp
similarity index 100%
rename from realm-jni/src/mixedutil.hpp
rename to realm/realm-jni/src/mixedutil.hpp
diff --git a/realm-jni/src/tablebase_tpl.hpp b/realm/realm-jni/src/tablebase_tpl.hpp
similarity index 99%
rename from realm-jni/src/tablebase_tpl.hpp
rename to realm/realm-jni/src/tablebase_tpl.hpp
index 47cf30769f..afd1089d48 100644
--- a/realm-jni/src/tablebase_tpl.hpp
+++ b/realm/realm-jni/src/tablebase_tpl.hpp
@@ -25,6 +25,9 @@ jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex
         return NULL;
 
     BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
+    if (bin.is_null()) {
+        return NULL;
+    }
     if (bin.size() <= MAX_JSIZE) {
         jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
         if (jresult)
diff --git a/realm-jni/src/tablequery.hpp b/realm/realm-jni/src/tablequery.hpp
similarity index 90%
rename from realm-jni/src/tablequery.hpp
rename to realm/realm-jni/src/tablequery.hpp
index 0c79b7d3d1..11ab2891eb 100644
--- a/realm-jni/src/tablequery.hpp
+++ b/realm/realm-jni/src/tablequery.hpp
@@ -23,12 +23,12 @@
 
 class TableQuery : public realm::Query {
     // 'subtables' is used to figure out which subtable the query
-    // is currectly working on, so that we can lookup the correct
+    // is currently working on, so that we can lookup the correct
     // table and verify the parameters related to that table.
-    std::vector<size_t> subtables;  // holds subtable column indeces 
+    std::vector<size_t> subtables;  // holds subtable column indices
 
 public:
-    TableQuery(const Query& copy) : realm::Query(copy, realm::Query::TCopyExpressionTag{}) {};
+    TableQuery(const Query& copy) : realm::Query(copy) {};
  
     void push_subtable(size_t index) {
         subtables.push_back(index);
diff --git a/realm-jni/src/utf8.hpp b/realm/realm-jni/src/utf8.hpp
similarity index 95%
rename from realm-jni/src/utf8.hpp
rename to realm/realm-jni/src/utf8.hpp
index 5811cd93b0..3f76edefe4 100644
--- a/realm-jni/src/utf8.hpp
+++ b/realm/realm-jni/src/utf8.hpp
@@ -1,22 +1,19 @@
-/*************************************************************************
+/*
+ * Copyright 2011 Realm Inc.
  *
- * REALM CONFIDENTIAL
- * __________________
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- *  [2011] - [2012] Realm Inc
- *  All Rights Reserved.
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- * NOTICE:  All information contained herein is, and remains
- * the property of Realm Incorporated and its suppliers,
- * if any.  The intellectual and technical concepts contained
- * herein are proprietary to Realm Incorporated
- * and its suppliers and may be covered by U.S. and Foreign Patents,
- * patents in process, and are protected by trade secret or copyright law.
- * Dissemination of this information or reproduction of this material
- * is strictly forbidden unless prior written permission is obtained
- * from Realm Incorporated.
- *
- **************************************************************************/
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef REALM_UTIL_UTF8_HPP
 #define REALM_UTIL_UTF8_HPP
 
diff --git a/realm-jni/src/util.cpp b/realm/realm-jni/src/util.cpp
similarity index 81%
rename from realm-jni/src/util.cpp
rename to realm/realm-jni/src/util.cpp
index aa3a2fc04d..a2daeaec90 100644
--- a/realm-jni/src/util.cpp
+++ b/realm/realm-jni/src/util.cpp
@@ -27,26 +27,41 @@ using namespace std;
 using namespace realm;
 using namespace realm::util;
 
+// Caching classes and constructors for boxed types.
+jclass java_lang_long;
+jmethodID java_lang_long_init;
+jclass java_lang_float;
+jmethodID java_lang_float_init;
+jclass java_lang_double;
+jmethodID java_lang_double_init;
+
 void ConvertException(JNIEnv* env, const char *file, int line)
 {
-    std::ostringstream ss;
+    ostringstream ss;
     try {
         throw;
     }
-    catch (std::bad_alloc& e) {
+    catch (bad_alloc& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, OutOfMemory, ss.str());
     }
-    catch (std::exception& e) {
+    catch (CrossTableLinkTarget& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, CrossTableLink, ss.str());
+    }
+    catch (SharedGroup::BadVersion& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, BadVersion, ss.str());
+    }
+    catch (invalid_argument& e) {
         ss << e.what() << " in " << file << " line " << line;
-        ThrowException(env, Unspecified, ss.str());
+        ThrowException(env, IllegalArgument, ss.str());
     }
-    catch (...) { \
-        REALM_ASSERT(false);
-        ss << "Exception in " << file << " line " << line;
-        ThrowException(env, RuntimeError, ss.str());
+    catch (exception& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, FatalError, ss.str());
     }
-    /* above (...) is not needed if we only throw exceptions derived from std::exception */
+    /* catch (...) is not needed if we only throw exceptions derived from std::exception */
 }
 
 void ThrowException(JNIEnv* env, ExceptionKind exception, const char *classStr)
@@ -56,7 +71,7 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const char *classStr)
 
 void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& classStr, const std::string& itemStr)
 {
-    std::string message;
+    string message;
     jclass jExceptionClass = NULL;
 
     TR_ERR("jni: ThrowingException %d, %s, %s.", exception, classStr.c_str(), itemStr.c_str())
@@ -117,9 +132,9 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             message = classStr + " " + itemStr;
             break;
 
-        case Unspecified:
-            jExceptionClass = env->FindClass("java/lang/RuntimeException");
-            message = "Unspecified exception. " + classStr;
+        case FatalError:
+            jExceptionClass = env->FindClass("io/realm/exceptions/RealmError");
+            message = "Unrecoverable error. " + classStr;
             break;
 
         case RuntimeError:
@@ -131,6 +146,16 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             jExceptionClass = env->FindClass("java/lang/IllegalStateException");
             message = "Illegal State: " + classStr;
             break;
+
+        case CrossTableLink:
+            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
+            message = "This class is referenced by other classes. Remove those fields first before removing this class.";
+            break;
+
+        case BadVersion:
+            jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
+            message = classStr;
+            break;
     }
     if (jExceptionClass != NULL) {
         env->ThrowNew(jExceptionClass, message.c_str());
@@ -171,6 +196,16 @@ void jprint(JNIEnv *env, char *txt)
 #endif
 }
 
+void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
+    std::ostringstream ss;
+    ss << "Trying to set a non-nullable field '"
+       << table->get_column_name(col_ndx)
+       << "' in '"
+       << table->get_name()
+       << "' to null.";
+    ThrowException(env, IllegalArgument, ss.str());
+}
+
 void jprintf(JNIEnv *env, const char *format, ...)
 {
     va_list argptr;
@@ -209,8 +244,8 @@ namespace {
 // non-sign value bits, that is, an unsigned 16-bit integer, or any
 // signed or unsigned integer with more than 16 bits.
 struct JcharTraits {
-    static jchar to_int_type(jchar c)  REALM_NOEXCEPT { return c; }
-    static jchar to_char_type(jchar i) REALM_NOEXCEPT { return i; }
+    static jchar to_int_type(jchar c)  noexcept { return c; }
+    static jchar to_char_type(jchar i) noexcept { return i; }
 };
 
 struct JStringCharsAccessor {
@@ -220,8 +255,8 @@ struct JStringCharsAccessor {
     {
         m_env->ReleaseStringChars(m_string, m_data);
     }
-    const jchar* data() const REALM_NOEXCEPT { return m_data; }
-    size_t size() const REALM_NOEXCEPT { return m_size; }
+    const jchar* data() const noexcept { return m_data; }
+    size_t size() const noexcept { return m_size; }
 
 private:
     JNIEnv* const m_env;
@@ -249,7 +284,7 @@ string string_to_hex(const string& message, StringData& str, const char* in_begi
     ret << "error_code = " << error_code << "; ";
     ret << "retcode = " << retcode << "; ";
     ret << "StringData.size = " << str.size() << "; ";
-    ret << "StringData.data = " << str.data() << "; ";
+    ret << "StringData.data = " << str << "; ";
     ret << "StringData as hex = ";
     for (string::size_type i = 0; i < str.size(); ++i)
         ret << " 0x" << std::hex << std::setfill('0') << std::setw(2) << (int)s[i];
@@ -273,11 +308,18 @@ string string_to_hex(const string& message, const jchar *str, size_t size, size_
 
 string concat_stringdata(const char *message, StringData strData)
 {
-    return std::string(message) + (strData != NULL ? strData.data() : "");
+    if (strData.is_null()) {
+        return std::string(message);
+    }
+    return std::string(message) + std::string(strData.data(), strData.size());
 }
 
 jstring to_jstring(JNIEnv* env, StringData str)
 {
+    if (str.is_null()) {
+        return NULL;
+    }
+
     // For efficiency, if the incoming UTF-8 string is sufficiently
     // small, we will attempt to store the UTF-16 output into a stack
     // allocated buffer of static size. Otherwise we will have to
@@ -308,7 +350,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
         const char* in_begin2 = in_begin;
         size_t error_code;
         size_t size = Xcode::find_utf16_buf_size(in_begin2, in_end, error_code);
-        if (in_begin2 != in_end) 
+        if (in_begin2 != in_end)
             throw runtime_error(string_to_hex("Failure when computing UTF-16 size", str, in_begin, in_end, out_curr, out_end, size, error_code));
         if (int_add_with_overflow_detect(size, stack_buf_size))
             throw runtime_error("String size overflow");
@@ -317,7 +359,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
         out_begin = dyn_buf.get();
         out_end   = dyn_buf.get() + size;
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
-        if (retcode != 0) 
+        if (retcode != 0)
             throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end, out_curr, out_end, size_t(0), retcode));
         REALM_ASSERT(in_begin == in_end);
     }
@@ -342,6 +384,12 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
     // excessive over allocation, this is not done for larger input
     // strings.
 
+    if (str == NULL) {
+        m_is_null = true;
+        return;
+    }
+    m_is_null = false;
+
     JStringCharsAccessor chars(env, str);
 
     typedef Utf8x16<jchar, JcharTraits> Xcode;
@@ -365,10 +413,10 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         char* out_end   = m_data.get() + buf_size;
         size_t error_code;
         if (!Xcode::to_utf8(in_begin, in_end, out_begin, out_end, error_code)) {
-            throw runtime_error(string_to_hex("Failure when converting to UTF-8", chars.data(), chars.size(), error_code));
+            throw invalid_argument(string_to_hex("Failure when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         if (in_begin != in_end) {
-            throw runtime_error(string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
+            throw invalid_argument(string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         m_size = out_begin - m_data.get();
     }
diff --git a/realm-jni/src/util.hpp b/realm/realm-jni/src/util.hpp
similarity index 77%
rename from realm-jni/src/util.hpp
rename to realm/realm-jni/src/util.hpp
index ac5e3f58c4..c96fd26a48 100644
--- a/realm-jni/src/util.hpp
+++ b/realm/realm-jni/src/util.hpp
@@ -100,14 +100,15 @@ std::string num_to_string(T pNumber)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
 #define G(x)    reinterpret_cast<realm::Group*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
+#define SG(ptr) reinterpret_cast<realm::SharedGroup*>(ptr)
+#define CH(ptr) reinterpret_cast<realm::Replication*>(ptr)
+#define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
 
 // Exception handling
-
 enum ExceptionKind {
     ClassNotFound = 0,
     NoSuchField = 1,
     NoSuchMethod = 2,
-
     IllegalArgument = 3,
     IOFailed = 4,
     FileNotFound = 5,
@@ -116,21 +117,25 @@ enum ExceptionKind {
     TableInvalid = 8,
     UnsupportedOperation = 9,
     OutOfMemory = 10,
-    Unspecified = 11,
+    FatalError = 11,
     RuntimeError = 12,
-    RowInvalid = 13
+    RowInvalid = 13,
+    CrossTableLink = 15,
+    BadVersion = 16
+// NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
 };
 
 void ConvertException(JNIEnv* env, const char *file, int line);
 void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& classStr, const std::string& itemStr="");
 void ThrowException(JNIEnv* env, ExceptionKind exception, const char *classStr);
+void ThrowNullValueException(JNIEnv* env, realm::Table *table, size_t col_ndx);
 
 jclass GetClass(JNIEnv* env, const char* classStr);
 
 
 // Debug trace
 extern int trace_level;
-extern const char *log_tag;
+extern const char* log_tag;
 
 #if TRACE
   #if defined(ANDROID)
@@ -174,6 +179,7 @@ extern const char *log_tag;
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              ColIndexAndTypeValid(env, ptr, col, type)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     TblColIndexAndTypeValid(env, ptr, col, type)
 #define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     TblColIndexAndLinkOrLinkList(env, ptr, col)
+#define TBL_AND_COL_NULLABLE(env,ptr,col)                       TblColIndexAndNullable(env, ptr, col)
 #define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
@@ -190,7 +196,7 @@ extern const char *log_tag;
 
 #define ROW_INDEXES_VALID(env,ptr,start,end, range)             (true)
 #define ROW_INDEX_VALID(env,ptr,row)                            (true)
-#defibe ROW_INDEX_VALID_OFFSET(env,ptr,row)                     (true)
+#define ROW_INDEX_VALID_OFFSET(env,ptr,row)                     (true)
 #define TBL_AND_ROW_INDEX_VALID(env,ptr,row)                    (true)
 #define TBL_AND_ROW_INDEX_VALID_OFFSET(env,ptr,row, offset)     (true)
 #define COL_INDEX_VALID(env,ptr,col)                            (true)
@@ -198,6 +204,7 @@ extern const char *log_tag;
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              (true)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
 #define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     (true)
+#define TBL_AND_COL_NULLABLE(env,ptr,col)                       (true)
 #define INDEX_VALID(env,ptr,col,row)                            (true)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    (true)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
@@ -223,7 +230,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     bool valid = (objPtr != NULL);
     if (valid) {
         // Check if Table is valid
-        if (realm::util::SameType<realm::Table, T>::value) {
+        if (std::is_same<realm::Table, T>::value) {
             valid = TBL(objPtr)->is_attached();
         }
         // TODO: Add check for TableView
@@ -236,12 +243,12 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     return valid;
 }
 
-inline bool RowIsValid(JNIEnv* env, Row* rowPtr)
+inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
 {
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
         TR_ERR("Row %p is no longer attached!", VOID_PTR(rowPtr))
-        ThrowException(env, RowInvalid, "Row/Object is no longer valid to operate on. Was it deleted?");
+        ThrowException(env, RowInvalid, "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
 }
@@ -307,7 +314,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
 template <class T>
 inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
 {
-    if (realm::util::SameType<realm::Table, T>::value) {
+    if (std::is_same<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -332,14 +339,14 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 template <class T>
 inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 {
-    if (realm::util::SameType<realm::Table, T>::value) {
+    if (std::is_same<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
     return ColIndexValid(env, pTable, columnIndex);
 }
 
-inline bool RowColIndexValid(JNIEnv* env, Row* pRow, jlong columnIndex)
+inline bool RowColIndexValid(JNIEnv* env, realm::Row* pRow, jlong columnIndex)
 {
     return RowIsValid(env, pRow) && ColIndexValid(env, pRow->get_table(), columnIndex);
 }
@@ -397,15 +404,38 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
 {
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
-    if (colType == type_Link || colType == type_LinkList) {
+    if (colType == realm::type_Link || colType == realm::type_LinkList) {
         return true;
     }
 
-    TR_ERR("Expected columnType %d or %d, but got %d", type_Link, type_LinkList, colType)
+    TR_ERR("Expected columnType %d or %d, but got %d", realm::type_Link, realm::type_LinkList, colType)
     ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
     return false;
 }
 
+template <class T>
+inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
+{
+    size_t col = static_cast<size_t>(columnIndex);
+    int colType = pTable->get_column_type(col);
+    if (colType == realm::type_Link) {
+        return true;
+    }
+
+    if (colType == realm::type_LinkList) {
+        ThrowException(env, IllegalArgument, "RealmList is not nullable.");
+        return false;
+    }
+
+    if (pTable->is_nullable(col)) {
+        return true;
+    }
+
+    TR_ERR("Expected nullable column type")
+    ThrowException(env, IllegalArgument, "This field is not nullable.");
+    return false;
+}
+
 template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
@@ -425,13 +455,18 @@ inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnInd
         && TypeIsLinkLike(env, pTable, columnIndex);
 }
 
-inline bool RowColIndexAndTypeValid(JNIEnv* env, Row* pRow, jlong columnIndex, int expectColType)
+template <class T>
+inline bool TblColIndexAndNullable(JNIEnv* env, T* pTable, jlong columnIndex) {
+    return TableIsValid(env, pTable)
+        && ColIsNullable(env, pTable, columnIndex);
+}
+
+inline bool RowColIndexAndTypeValid(JNIEnv* env, realm::Row* pRow, jlong columnIndex, int expectColType)
 {
     return RowIsValid(env, pRow)
         && ColIndexAndTypeValid(env, pRow->get_table(), columnIndex, expectColType);
 }
 
-
 template <class T>
 inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
 {
@@ -444,7 +479,6 @@ inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlon
     return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
 }
 
-
 template <class T>
 inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
@@ -457,7 +491,7 @@ bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
 
 // Utility function for appending StringData, which is returned
 // by a lot of core functions, and might potentially be NULL.
-std::string concat_stringdata(const char *message, StringData data);
+std::string concat_stringdata(const char *message, realm::StringData data);
 
 // Note: JNI offers methods to convert between modified UTF-8 and
 // UTF-16. Unfortunately these methods are not appropriate in this
@@ -476,12 +510,18 @@ class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring);  // throws
 
-    operator realm::StringData() const REALM_NOEXCEPT
+    operator realm::StringData() const noexcept
     {
-        return realm::StringData(m_data.get(), m_size);
+        if (m_is_null) {
+            return realm::StringData(NULL);
+        }
+        else {
+            return realm::StringData(m_data.get(), m_size);
+        }
     }
 
 private:
+    bool m_is_null;
     std::unique_ptr<char[]> m_data;
     std::size_t m_size;
 };
@@ -521,5 +561,114 @@ class KeyBuffer {
     jbyte* m_ptr;
 };
 
+class JniLongArray {
+public:
+    JniLongArray(JNIEnv* env, jlongArray javaArray)
+        : m_env(env)
+        , m_javaArray(javaArray)
+        , m_arrayLength(env->GetArrayLength(javaArray))
+        , m_array(env->GetLongArrayElements(javaArray, NULL))
+        , m_releaseMode(JNI_ABORT) {
+    }
+
+    ~JniLongArray()
+    {
+        m_env->ReleaseLongArrayElements(m_javaArray, m_array, m_releaseMode);
+    }
+
+    inline jsize len() const noexcept
+    {
+        return m_arrayLength;
+    }
+
+    inline jlong* ptr() const noexcept
+    {
+        return m_array;
+    }
+
+    inline jlong& operator[](const int index) noexcept
+    {
+        return m_array[index];
+    }
+
+    inline void updateOnRelease() noexcept
+    {
+        m_releaseMode = 0;
+    }
+
+private:
+    JNIEnv*    const m_env;
+    jlongArray const m_javaArray;
+    jsize      const m_arrayLength;
+    jlong*     const m_array;
+    jint             m_releaseMode;
+};
+
+class JniBooleanArray {
+public:
+    JniBooleanArray(JNIEnv* env, jbooleanArray javaArray)
+        : m_env(env)
+        , m_javaArray(javaArray)
+        , m_arrayLength(env->GetArrayLength(javaArray))
+        , m_array(env->GetBooleanArrayElements(javaArray, NULL))
+        , m_releaseMode(JNI_ABORT) {
+    }
+
+    ~JniBooleanArray()
+    {
+        m_env->ReleaseBooleanArrayElements(m_javaArray, m_array, m_releaseMode);
+    }
+
+    inline jsize len() const noexcept
+    {
+        return m_arrayLength;
+    }
+
+    inline jboolean* ptr() const noexcept
+    {
+        return m_array;
+    }
+
+    inline jboolean& operator[](const int index) noexcept
+    {
+        return m_array[index];
+    }
+
+    inline void updateOnRelease() noexcept
+    {
+        m_releaseMode = 0;
+    }
+
+private:
+    JNIEnv*       const m_env;
+    jbooleanArray const m_javaArray;
+    jsize         const m_arrayLength;
+    jboolean*     const m_array;
+    jint                m_releaseMode;
+};
+
+extern jclass java_lang_long;
+extern jmethodID java_lang_long_init;
+extern jclass java_lang_float;
+extern jmethodID java_lang_float_init;
+extern jclass java_lang_double;
+extern jmethodID java_lang_double_init;
+
+inline jobject NewLong(JNIEnv* env, int64_t value)
+{
+    return env->NewObject(java_lang_long, java_lang_long_init, value);
+}
+
+inline jobject NewDouble(JNIEnv* env, double value)
+{
+    return env->NewObject(java_lang_double, java_lang_double_init, value);
+}
+
+inline jobject NewFloat(JNIEnv* env, float value)
+{
+    return env->NewObject(java_lang_float, java_lang_float_init, value);
+}
+
+extern const char* const TABLE_PREFIX;
 
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
new file mode 100644
index 0000000000..e99a451927
--- /dev/null
+++ b/realm/realm-library/build.gradle
@@ -0,0 +1,223 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.library'
+apply plugin: 'com.neenbedankt.android-apt'
+apply plugin: 'com.github.dcendents.android-maven'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'com.jfrog.bintray'
+apply plugin: 'findbugs'
+apply plugin: 'pmd'
+apply plugin: 'checkstyle'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion '23.0.0'
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+        project.archivesBaseName = "realm-android-library"
+        consumerProguardFiles 'proguard-rules.pro'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        debug {
+            testCoverageEnabled = true
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+import io.realm.transformer.RealmTransformer
+
+android.registerTransform(new RealmTransformer())
+
+repositories {
+    maven { url "https://jitpack.io" }
+}
+
+dependencies {
+    provided 'io.reactivex:rxjava:1.1.0'
+    compile "io.realm:realm-annotations:${version}"
+    compile 'com.github.KeepSafe:ReLinker:1.1'
+
+    androidTestCompile 'io.reactivex:rxjava:1.1.0'
+    androidTestCompile 'com.android.support:support-annotations:23.1.1'
+    androidTestCompile 'com.android.support.test:runner:0.4.1'
+    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
+    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+
+    androidTestApt project(':realm-annotations-processor')
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    source android.sourceSets.main.java.srcDirs
+    source "../../realm-annotations/src/main/java"
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    options {
+        title = "Realm ${project.version}"
+        memberLevel = JavadocMemberLevel.PUBLIC
+        docEncoding = 'UTF-8'
+        encoding = 'UTF-8'
+        charSet = 'UTF-8'
+        locale = 'en_US'
+        overview = 'src/overview.html'
+    }
+    exclude '**/internal/**'
+    exclude '**/BuildConfig.java'
+    exclude '**/R.java'
+    doLast {
+        copy {
+            from "src/realm-overview.png"
+            into "$buildDir/docs/javadoc"
+        }
+    }
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+
+preBuild.dependsOn ':realm-jni:buildAndroidJni'
+
+task findbugs(type: FindBugs) {
+    dependsOn assembleDebug
+    group = 'Verification'
+
+    ignoreFailures = false
+    effort = "default"
+    reportLevel = "medium"
+    excludeFilter = file("${projectDir}/../config/findbugs/findbugs-filter.xml")
+    classes = files("${projectDir}/build/intermediates/classes")
+    source = fileTree('src/main/java/')
+    classpath = files()
+    reports {
+        xml.enabled = false
+        html.enabled = true
+        xml {
+            destination "$project.buildDir/findbugs/findbugs-output.xml"
+        }
+        html {
+            destination "$project.buildDir/findbugs/findbugs-output.html"
+        }
+    }
+}
+
+task pmd(type: Pmd) {
+    group = 'Verification'
+
+    source = fileTree('src/main/java')
+    ruleSetFiles = files("${projectDir}/../config/pmd/ruleset.xml")
+    ruleSets = [] // This needs to be here to remove the default checks
+
+    reports {
+        xml.enabled = false
+        html.enabled = true
+    }
+}
+
+task checkstyle(type: Checkstyle) {
+    group = 'Test'
+
+    source 'src'
+    include '**/*.java'
+    exclude '**/gen/**'
+    exclude '**/R.java'
+    exclude '**/BuildConfig.java'
+
+    def configProps = ['proj.module.dir': projectDir.absolutePath]
+    configProperties configProps
+
+    configFile = file("${projectDir}/../config/checkstyle/checkstyle.xml")
+
+    // empty classpath
+    classpath = files()
+}
+
+install {
+    repositories.mavenInstaller {
+        pom {
+            project {
+                packaging 'aar'
+
+                // Add your description here
+                name 'realm-android-library'
+                description 'Realm is a mobile database: a replacement for SQLite & ORMs.'
+                url 'http://realm.io'
+
+                // Set your license
+                licenses {
+                    license {
+                        name 'The Apache Software License, Version 2.0'
+                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                        distribution 'repo'
+                    }
+                }
+                issueManagement {
+                    system 'github'
+                    url 'https://github.com/realm/realm-java/issues'
+                }
+                scm {
+                    url 'scm:https://github.com/realm/realm-java'
+                    connection 'scm:git@github.com:realm/realm-java.git'
+                    developerConnection 'scm:git@github.com:realm/realm-java.git'
+                }
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+    key = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+
+    dryRun = false
+    publish = false
+
+    configurations = ['archives']
+
+    pkg {
+        repo = 'maven'
+        name = 'realm-android-library'
+        desc = 'Realm for Android'
+        websiteUrl = 'http://realm.io'
+        issueTrackerUrl = 'https://github.com/realm/realm-java/issues'
+        vcsUrl = 'https://github.com/realm/realm-java.git'
+        licenses = ['Apache-2.0']
+        labels = ['android', 'realm']
+        publicDownloadNumbers = false
+    }
+}
+
+artifactory {
+    contextUrl = 'https://oss.jfrog.org/artifactory'
+    publish {
+        repository {
+            repoKey = 'oss-snapshot-local'
+            username = project.hasProperty('bintrayUser') ? bintrayUser : 'noUser'
+            password = project.hasProperty('bintrayKey') ? bintrayKey : 'noKey'
+            maven = true
+        }
+        defaults {
+            publishConfigs('archives')
+            publishPom = true
+            publishIvy = false
+        }
+    }
+}
+
+artifacts {
+    archives javadocJar
+    archives sourcesJar
+}
diff --git a/realm/realm-library/latest b/realm/realm-library/latest
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules.pro
new file mode 100644
index 0000000000..980b5b3ce2
--- /dev/null
+++ b/realm/realm-library/proguard-rules.pro
@@ -0,0 +1,6 @@
+-keep class io.realm.annotations.RealmModule
+-keep @io.realm.annotations.RealmModule class *
+-keep class io.realm.internal.Keep
+-keep @io.realm.internal.Keep class * { *; }
+-dontwarn javax.**
+-dontwarn io.realm.**
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..d7fa5a811c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm">
+
+    <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+        <service
+            android:name=".services.RemoteProcessService"
+            android:enabled="true"
+            android:exported="true"
+            android:process=":remote" >
+        </service>
+    </application>
+
+</manifest>
diff --git a/realm/src/androidTest/assets/080_annotationtypes.realm b/realm/realm-library/src/androidTest/assets/080_annotationtypes.realm
similarity index 100%
rename from realm/src/androidTest/assets/080_annotationtypes.realm
rename to realm/realm-library/src/androidTest/assets/080_annotationtypes.realm
diff --git a/realm/src/androidTest/assets/ios/0.90.4-alltypes-default.realm b/realm/realm-library/src/androidTest/assets/0841_annotationtypes.realm
similarity index 68%
rename from realm/src/androidTest/assets/ios/0.90.4-alltypes-default.realm
rename to realm/realm-library/src/androidTest/assets/0841_annotationtypes.realm
index d049e3bdb8..c605500aab 100644
Binary files a/realm/src/androidTest/assets/ios/0.90.4-alltypes-default.realm and b/realm/realm-library/src/androidTest/assets/0841_annotationtypes.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/0841_pk_migration.realm b/realm/realm-library/src/androidTest/assets/0841_pk_migration.realm
new file mode 100644
index 0000000000..2b55bc51aa
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/0841_pk_migration.realm differ
diff --git a/realm/src/androidTest/assets/all_simple_types.json b/realm/realm-library/src/androidTest/assets/all_simple_types.json
similarity index 100%
rename from realm/src/androidTest/assets/all_simple_types.json
rename to realm/realm-library/src/androidTest/assets/all_simple_types.json
diff --git a/realm/src/androidTest/assets/all_types_null.json b/realm/realm-library/src/androidTest/assets/all_types_null.json
similarity index 100%
rename from realm/src/androidTest/assets/all_types_null.json
rename to realm/realm-library/src/androidTest/assets/all_types_null.json
diff --git a/realm/realm-library/src/androidTest/assets/all_types_primary_key_field_only.json b/realm/realm-library/src/androidTest/assets/all_types_primary_key_field_only.json
new file mode 100644
index 0000000000..20210aa023
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/all_types_primary_key_field_only.json
@@ -0,0 +1,3 @@
+{
+	"columnLong" : 1
+}
diff --git a/realm/realm-library/src/androidTest/assets/all_types_primary_key_null.json b/realm/realm-library/src/androidTest/assets/all_types_primary_key_null.json
new file mode 100644
index 0000000000..fd1536e4c4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/all_types_primary_key_null.json
@@ -0,0 +1,11 @@
+{
+	"columnString" : null,
+	"columnLong" : 1,
+	"columnFloat" : null,
+	"columnDouble" : null,
+	"columnBoolean" : null,
+	"columnBinary" : null,
+	"columnDate" : null,
+	"columnRealmObject" : null,
+	"columnRealmList" : null
+}
diff --git a/realm/src/androidTest/assets/array.json b/realm/realm-library/src/androidTest/assets/array.json
similarity index 100%
rename from realm/src/androidTest/assets/array.json
rename to realm/realm-library/src/androidTest/assets/array.json
diff --git a/realm/realm-library/src/androidTest/assets/date_as_iso8601_string.json b/realm/realm-library/src/androidTest/assets/date_as_iso8601_string.json
new file mode 100644
index 0000000000..6b2354d4da
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/date_as_iso8601_string.json
@@ -0,0 +1,3 @@
+{
+    "columnDate" : "2007-08-13T215123.789+02:00"
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/date_as_long.json b/realm/realm-library/src/androidTest/assets/date_as_long.json
similarity index 100%
rename from realm/src/androidTest/assets/date_as_long.json
rename to realm/realm-library/src/androidTest/assets/date_as_long.json
diff --git a/realm/src/androidTest/assets/date_as_string.json b/realm/realm-library/src/androidTest/assets/date_as_string.json
similarity index 100%
rename from realm/src/androidTest/assets/date_as_string.json
rename to realm/realm-library/src/androidTest/assets/date_as_string.json
diff --git a/realm/src/androidTest/assets/default-before-migration.realm b/realm/realm-library/src/androidTest/assets/default-before-migration.realm
similarity index 100%
rename from realm/src/androidTest/assets/default-before-migration.realm
rename to realm/realm-library/src/androidTest/assets/default-before-migration.realm
diff --git a/realm/src/androidTest/assets/default0.realm b/realm/realm-library/src/androidTest/assets/default0.realm
similarity index 100%
rename from realm/src/androidTest/assets/default0.realm
rename to realm/realm-library/src/androidTest/assets/default0.realm
diff --git a/realm/realm-library/src/androidTest/assets/encrypted.realm b/realm/realm-library/src/androidTest/assets/encrypted.realm
new file mode 100644
index 0000000000..d61e5677e0
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/encrypted.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default-encrypted.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default-encrypted.realm
new file mode 100644
index 0000000000..6ef6a6ea4d
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default-encrypted.realm differ
diff --git a/realm/src/androidTest/assets/ios/0.90.4-alltypes-min.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default.realm
similarity index 64%
rename from realm/src/androidTest/assets/ios/0.90.4-alltypes-min.realm
rename to realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default.realm
index 1002549413..300c912ebf 100644
Binary files a/realm/src/androidTest/assets/ios/0.90.4-alltypes-min.realm and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-default.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-max.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-max.realm
new file mode 100644
index 0000000000..e798f85b68
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-max.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-min.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-min.realm
new file mode 100644
index 0000000000..0bb0cb607a
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-min.realm differ
diff --git a/realm/src/androidTest/assets/ios/0.90.4-alltypes-max.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-null-value.realm
similarity index 64%
rename from realm/src/androidTest/assets/ios/0.90.4-alltypes-max.realm
rename to realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-null-value.realm
index 0660c84b58..1cac2cacd3 100644
Binary files a/realm/src/androidTest/assets/ios/0.90.4-alltypes-max.realm and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes-null-value.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes.realm b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes.realm
new file mode 100644
index 0000000000..1c8b35f494
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/ios/0.98.0-alltypes.realm differ
diff --git a/realm/src/androidTest/assets/ios/README b/realm/realm-library/src/androidTest/assets/ios/README.md
similarity index 53%
rename from realm/src/androidTest/assets/ios/README
rename to realm/realm-library/src/androidTest/assets/ios/README.md
index 68e2899efc..b385f78bb6 100644
--- a/realm/src/androidTest/assets/ios/README
+++ b/realm/realm-library/src/androidTest/assets/ios/README.md
@@ -1,11 +1,30 @@
 This folder contains various Realm databases created on iOS and can be used to test interop with
-Realm-Android.
+Realm-Android. The databases are generated using the below iOS code.
 
-The databases are generated using the following iOS code:
+(02/18-2016) Note that we should match the core version (0.96.0) used in Cocoa (0.98.0) for Java (0.87.4).
 
+### HOWTO
+
+1. Checkout realm-cocoa.
+2. Open ~/realm-cocoa/RealmExamples.xcodeproj in Xcode.
+3. Rename `/Simple/AppDelegate.m` to `/Simple/AppDelegate.mm` and replace the content with the below code.  
+4. Run Simple project.
+5. Copy/paste output Realm files into Java unit tests asset directory.
+
+### DISABLE DEBUGGING:
+
+1. Click on spinner that chooses which Example to run.
+2. At the bottom should be a button called "Edit Scheme".
+3. Choose "Run" if not selected already.
+4. Remove check in "Debug executable".
+5. Save and run.
+
+See the Log for where the output files are located.
+
+```objective-c  
 ////////////////////////////////////////////////////////////////////////////
 //
-// Copyright 2014 Realm Inc.
+// Copyright 2016 Realm Inc.
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -23,9 +42,11 @@ The databases are generated using the following iOS code:
 
 #import "AppDelegate.h"
 #import <Realm/Realm.h>
+#include <limits>
+using namespace std;
 
 @interface IOSChild : RLMObject
-@property NSString      *name;
+@property NSString *name;
 @end
 RLM_ARRAY_TYPE(IOSChild)
 
@@ -33,10 +54,12 @@ RLM_ARRAY_TYPE(IOSChild)
 @end
 
 @interface IOSAllTypes : RLMObject
+@property long id;
 @property bool boolCol;
 @property short shortCol;
 @property int intCol;
 @property long longCol;
+@property int64_t longLongCol;
 @property float floatCol;
 @property double doubleCol;
 @property NSData *byteCol;
@@ -48,31 +71,51 @@ RLM_ARRAY_TYPE(IOSChild)
 RLM_ARRAY_TYPE(AllTypes)
 
 @implementation IOSAllTypes
-//+ (NSString *)primaryKey {
-//    return @"longCol";
-//}
++ (NSString *)primaryKey {
+    return @"id";
+}
 @end
 
 @implementation AppDelegate
 
-- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
-{
++ (int64_t) realm_from_nsdate:(NSDate *)nsdate {
+    return static_cast<int64_t>([nsdate timeIntervalSince1970]);
+}
+
++ (NSString *)getRealmFilePath:(NSString *)realmName {
+    NSString *documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)objectAtIndex:0];
+    return [documentsDirectory stringByAppendingPathComponent:realmName];
+}
+
++ (RLMRealm *)appDefaultRealm:(NSString *) realmName {
+    NSString* allTypesRealm = [AppDelegate getRealmFilePath:realmName];
+    [[NSFileManager defaultManager] removeItemAtPath:allTypesRealm error:nil];
+    RLMRealm *realm = [RLMRealm realmWithPath:allTypesRealm];
+    return realm;
+}
+
+- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
+
     self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
     self.window.rootViewController = [[UIViewController alloc] init];
     [self.window makeKeyAndVisible];
 
+    NSLog(@"Documents Directory: %@", [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject]);
+
+    const NSString *version = @"0.98.0";
     const unsigned char no_bytes[] = {};
     const unsigned char bytes[] = {1,2,3};
 
-    [AppDelegate setDefaultRealm: @"0.90.4-alltypes.realm"];
-    RLMRealm *realm = [RLMRealm defaultRealm];
+    RLMRealm *realm = [AppDelegate appDefaultRealm:[NSString stringWithFormat:@"%@-alltypes.realm", version]];
     [realm beginWriteTransaction];
     for (int i = 0; i < 10; i++) {
         IOSAllTypes *obj = [[IOSAllTypes alloc] init];
+        obj.id = i + 1;
         obj.boolCol = TRUE;
         obj.shortCol = 1 + i;
         obj.intCol = 10 + i;
         obj.longCol = 100 + i;
+        obj.longLongCol = 100000000 + i;
         obj.floatCol = 1.23 + i;
         obj.doubleCol = 1.234 + i;
         obj.byteCol = [NSData dataWithBytes:bytes length:sizeof(bytes)];
@@ -90,8 +133,7 @@ RLM_ARRAY_TYPE(AllTypes)
     }
     [realm commitWriteTransaction];
 
-    [AppDelegate setDefaultRealm: @"0.90.4-alltypes-default.realm"];
-    realm = [RLMRealm defaultRealm];
+    realm = [AppDelegate appDefaultRealm:[NSString stringWithFormat:@"%@-alltypes-default.realm", version]];
     [realm beginWriteTransaction];
     IOSAllTypes *obj = [[IOSAllTypes alloc] init];
     obj.byteCol = [NSData dataWithBytes:no_bytes length:sizeof(no_bytes)];
@@ -100,49 +142,64 @@ RLM_ARRAY_TYPE(AllTypes)
     [realm addObject:obj];
     [realm commitWriteTransaction];
 
+    realm = [AppDelegate appDefaultRealm:[NSString stringWithFormat:@"%@-alltypes-null-value.realm", version]];
+    [realm beginWriteTransaction];
+    obj = [[IOSAllTypes alloc] init];
+    obj.byteCol = nil;
+    obj.stringCol = nil;
+    obj.dateCol = nil;
+    obj.child = nil;
+    obj.children = nil;
+    [realm addObject:obj];
+    [realm commitWriteTransaction];
 
-    [AppDelegate setDefaultRealm: @"0.90.4-alltypes-min.realm"];
-    realm = [RLMRealm defaultRealm];
+    realm = [AppDelegate appDefaultRealm:[NSString stringWithFormat:@"%@-alltypes-min.realm", version]];
     [realm beginWriteTransaction];
     obj = [[IOSAllTypes alloc] init];
     obj.boolCol = FALSE;
     obj.shortCol = SHRT_MIN;
     obj.intCol = INT_MIN;
     obj.longCol = LONG_MIN;
-    obj.floatCol = FLT_MIN;
-    obj.doubleCol = DBL_MIN;
+    obj.longLongCol = std::numeric_limits<int64_t>::min();
+    obj.floatCol = -FLT_MAX;
+    obj.doubleCol = -DBL_MAX;
     obj.byteCol = [NSData dataWithBytes:no_bytes length:sizeof(no_bytes)];
     obj.stringCol = @"";
-    obj.dateCol = [NSDate dateWithTimeIntervalSince1970: 0];
+    obj.dateCol = [NSDate dateWithTimeIntervalSinceReferenceDate:-DBL_MAX];
     [realm addObject:obj];
     [realm commitWriteTransaction];
+    NSLog(@"%@, obj.longLongCol : 0x%llx\n",[NSString stringWithFormat:@"%@-alltypes-min.realm", version], obj.longLongCol);
+    NSLog(@"%@, obj.dateCol : 0x%llx\n",[NSString stringWithFormat:@"%@-alltypes-min.realm", version], [AppDelegate realm_from_nsdate:obj.dateCol]);
 
-
-    [AppDelegate setDefaultRealm: @"0.90.4-alltypes-max.realm"];
-    realm = [RLMRealm defaultRealm];
+    realm = [AppDelegate appDefaultRealm:[NSString stringWithFormat:@"%@-alltypes-max.realm", version]];
     [realm beginWriteTransaction];
     obj = [[IOSAllTypes alloc] init];
     obj.boolCol = TRUE;
     obj.shortCol = SHRT_MAX;
     obj.intCol = INT_MAX;
     obj.longCol = LONG_MAX;
+    obj.longLongCol = std::numeric_limits<int64_t>::max();
     obj.floatCol = FLT_MAX;
     obj.doubleCol = DBL_MAX;
     obj.byteCol = [NSData dataWithBytes:no_bytes length:sizeof(no_bytes)];
     obj.stringCol = @"";
-    obj.dateCol = [NSDate dateWithTimeIntervalSince1970: LONG_MAX];
+    obj.dateCol = [NSDate dateWithTimeIntervalSinceReferenceDate:DBL_MAX];
     [realm addObject:obj];
     [realm commitWriteTransaction];
+    NSLog(@"%@, obj.longLongCol : 0x%llx\n",[NSString stringWithFormat:@"%@-alltypes-max.realm", version], obj.longLongCol);
+    NSLog(@"%@, obj.dateCol : 0x%llx\n",[NSString stringWithFormat:@"%@-alltypes-max.realm", version], [AppDelegate realm_from_nsdate:obj.dateCol]);
 
-
-    [AppDelegate setDefaultRealm: @"0.90.5-alltypes-default-encrypted.realm"];
     uint8_t buffer[64];
     for (int i = 0; i < sizeof(buffer); i++) {
         buffer[i] = 1;
     }
     NSData *keyData = [[NSData alloc] initWithBytes:buffer length:sizeof(buffer)]; // Zerofilled byte array
     NSError *error;
-    realm = [RLMRealm realmWithPath:[RLMRealm defaultRealmPath] encryptionKey:keyData readOnly:NO error:&error];
+    RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];
+    config.path = [AppDelegate getRealmFilePath:[NSString stringWithFormat:@"%@-alltypes-default-encrypted.realm", version]];
+    config.encryptionKey = keyData;
+    config.readOnly = NO;
+    realm = [RLMRealm realmWithConfiguration:config error:&error];
     [realm beginWriteTransaction];
     obj = [[IOSAllTypes alloc] init];
     obj.byteCol = [NSData dataWithBytes:no_bytes length:sizeof(no_bytes)];
@@ -154,12 +211,5 @@ RLM_ARRAY_TYPE(AllTypes)
     NSLog(@"Done");
     return YES;
 }
-
-+ (void)setDefaultRealm:(NSString *) realmName
-{
-    NSString *documentsDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)objectAtIndex:0];
-    NSString* allTypesRealm = [documentsDirectory stringByAppendingPathComponent:realmName];
-    [RLMRealm setDefaultRealmPath:allTypesRealm];
-    [[NSFileManager defaultManager] removeItemAtPath:[RLMRealm defaultRealmPath] error:nil];
-}
 @end
+```
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/list_alltypes_primarykey.json b/realm/realm-library/src/androidTest/assets/list_alltypes_primarykey.json
similarity index 100%
rename from realm/src/androidTest/assets/list_alltypes_primarykey.json
rename to realm/realm-library/src/androidTest/assets/list_alltypes_primarykey.json
diff --git a/realm/realm-library/src/androidTest/assets/nulltypes.json b/realm/realm-library/src/androidTest/assets/nulltypes.json
new file mode 100644
index 0000000000..7067ffc8f1
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/nulltypes.json
@@ -0,0 +1,73 @@
+[
+  {
+    "id": 1,
+    "fieldStringNotNull": "",
+    "fieldStringNull": null,
+    "fieldBytesNotNull": "",
+    "fieldBytesNull": null,
+    "fieldBooleanNotNull": false,
+    "fieldBooleanNull": null,
+    "fieldByteNotNull": 0,
+    "fieldByteNull": null,
+    "fieldShortNotNull": 0,
+    "fieldShortNull": null,
+    "fieldIntegerNotNull": 0,
+    "fieldIntegerNull": null,
+    "fieldLongNotNull": 0,
+    "fieldLongNull": null,
+    "fieldFloatNotNull": 0,
+    "fieldFloatNull": null,
+    "fieldDoubleNotNull": 0,
+    "fieldDoubleNull":null,
+    "fieldDateNotNull": 0,
+    "fieldDateNull": null,
+    "fieldObjectNull": null
+  },
+  {
+    "id": 2,
+    "fieldStringNotNull": "",
+    "fieldStringNull": "",
+    "fieldBytesNotNull": "",
+    "fieldBytesNull": "",
+    "fieldBooleanNotNull": false,
+    "fieldBooleanNull": false,
+    "fieldByteNotNull": 0,
+    "fieldByteNull": 0,
+    "fieldShortNotNull": 0,
+    "fieldShortNull": 0,
+    "fieldIntegerNotNull": 0,
+    "fieldIntegerNull": 0,
+    "fieldLongNotNull": 0,
+    "fieldLongNull": 0,
+    "fieldFloatNotNull": 0,
+    "fieldFloatNull": 0,
+    "fieldDoubleNotNull": 0,
+    "fieldDoubleNull":0,
+    "fieldDateNotNull": 0,
+    "fieldDateNull": 0,
+    "fieldObjectNull": {
+      "id": 3,
+      "fieldStringNotNull": "",
+      "fieldStringNull": "",
+      "fieldBytesNotNull": "",
+      "fieldBytesNull": "",
+      "fieldBooleanNotNull": false,
+      "fieldBooleanNull": false,
+      "fieldByteNotNull": 0,
+      "fieldByteNull": 0,
+      "fieldShortNotNull": 0,
+      "fieldShortNull": 0,
+      "fieldIntegerNotNull": 0,
+      "fieldIntegerNull": 0,
+      "fieldLongNotNull": 0,
+      "fieldLongNull": 0,
+      "fieldFloatNotNull": 0,
+      "fieldFloatNull": 0,
+      "fieldDoubleNotNull": 0,
+      "fieldDoubleNull":0,
+      "fieldDateNotNull": 0,
+      "fieldDateNull": 0,
+      "fieldObjectNull": null
+    }
+  }
+]
diff --git a/realm/realm-library/src/androidTest/assets/nulltypes_invalid.json b/realm/realm-library/src/androidTest/assets/nulltypes_invalid.json
new file mode 100644
index 0000000000..1ae85a2127
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/nulltypes_invalid.json
@@ -0,0 +1,42 @@
+[
+  {
+    "id": 1,
+    "fieldStringNotNull": null
+  },
+  {
+    "id": 2,
+    "fieldBytesNotNull": null
+  },
+  {
+    "id": 3,
+    "fieldBooleanNotNull": null
+  },
+  {
+    "id": 4,
+    "fieldByteNotNull": null
+  },
+  {
+    "id": 5,
+    "fieldShortNotNull": null
+  },
+  {
+    "id": 6,
+    "fieldIntegerNotNull": null
+  },
+  {
+    "id": 7,
+    "fieldLongNotNull": null
+  },
+  {
+    "id": 8,
+    "fieldFloatNotNull": null
+  },
+  {
+    "id": 9,
+    "fieldDoubleNotNull": null
+  },
+  {
+    "id": 10,
+    "fieldDateNotNull": null
+  }
+]
diff --git a/realm/realm-library/src/androidTest/assets/other_json_object.json b/realm/realm-library/src/androidTest/assets/other_json_object.json
new file mode 100644
index 0000000000..3b40cdaea7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/other_json_object.json
@@ -0,0 +1,7 @@
+{
+	"I" : null,
+	"aM" : null,
+	"nOt" : null,
+	"a" : null,
+	"fiElD" : null
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/assets/realmlist.json b/realm/realm-library/src/androidTest/assets/realmlist.json
similarity index 100%
rename from realm/src/androidTest/assets/realmlist.json
rename to realm/realm-library/src/androidTest/assets/realmlist.json
diff --git a/realm/src/androidTest/assets/realmlist_empty.json b/realm/realm-library/src/androidTest/assets/realmlist_empty.json
similarity index 100%
rename from realm/src/androidTest/assets/realmlist_empty.json
rename to realm/realm-library/src/androidTest/assets/realmlist_empty.json
diff --git a/realm/src/androidTest/assets/single_child_object.json b/realm/realm-library/src/androidTest/assets/single_child_object.json
similarity index 100%
rename from realm/src/androidTest/assets/single_child_object.json
rename to realm/realm-library/src/androidTest/assets/single_child_object.json
diff --git a/realm/src/androidTest/assets/unicode_codepoints.csv b/realm/realm-library/src/androidTest/assets/unicode_codepoints.csv
similarity index 100%
rename from realm/src/androidTest/assets/unicode_codepoints.csv
rename to realm/realm-library/src/androidTest/assets/unicode_codepoints.csv
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
new file mode 100644
index 0000000000..6d84b78e2c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -0,0 +1,892 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.text.ParseException;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.CyclicType;
+import io.realm.entities.Dog;
+import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class DynamicRealmObjectTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+    private AllJavaTypes typedObj;
+    // DynamicRealmObject constructed from a typed RealmObject
+    private DynamicRealmObject dObjTyped;
+    // DynamicRealmObject queried from DynamicRealm
+    private DynamicRealmObject dObjDynamic;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        typedObj = realm.createObject(AllJavaTypes.class);
+        typedObj.setFieldString("str");
+        typedObj.setFieldShort((short) 1);
+        typedObj.setFieldInt(1);
+        typedObj.setFieldLong(1);
+        typedObj.setFieldByte((byte) 4);
+        typedObj.setFieldFloat(1.23f);
+        typedObj.setFieldDouble(1.234d);
+        typedObj.setFieldBinary(new byte[]{1, 2, 3});
+        typedObj.setFieldBoolean(true);
+        typedObj.setFieldDate(new Date(1000));
+        typedObj.setFieldObject(typedObj);
+        typedObj.getFieldList().add(typedObj);
+        dObjTyped = new DynamicRealmObject(typedObj);
+        realm.commitTransaction();
+
+        dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dObjDynamic = dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+        if (dynamicRealm != null) {
+            dynamicRealm.close();
+        }
+    }
+
+    // Types supported by the DynamicRealmObject.
+    private enum SupportedType {
+        BOOLEAN, SHORT, INT, LONG, BYTE, FLOAT, DOUBLE, STRING, BINARY, DATE, OBJECT, LIST
+    }
+
+    @Test (expected = IllegalArgumentException.class)
+    public void constructor_nullThrows () {
+        new DynamicRealmObject((RealmObject)null);
+    }
+
+    @Test (expected = IllegalArgumentException.class)
+    public void constructor_dynamicObjectThrows () {
+        new DynamicRealmObject(dObjTyped);
+    }
+
+    @Test
+    public void constructor_deletedObjectThrows() {
+        realm.beginTransaction();
+        typedObj.removeFromRealm();
+        realm.commitTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        new DynamicRealmObject(typedObj);
+    }
+
+    // Test that all getters fail if given invalid field name
+    @Test
+    public void typedGetter_illegalFieldNameThrows() {
+        // Set arguments
+        String linkedField = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING;
+        List<String> arguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_STRING, linkedField);
+        List<String> stringArguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_BOOLEAN, linkedField);
+
+        // Test all getters
+        for (SupportedType type : SupportedType.values()) {
+
+            // We cannot modularize everything, so STRING is a special case with its own set
+            // of failing values. Only difference is the wrong type column has to be different.
+            List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
+            try {
+                callGetter(type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // Helper method for calling getters with different field names
+    private void callGetter(SupportedType type, List<String> fieldNames) {
+        for (String fieldName : fieldNames) {
+            switch (type) {
+                case BOOLEAN: dObjTyped.getBoolean(fieldName); break;
+                case SHORT: dObjTyped.getShort(fieldName); break;
+                case INT: dObjTyped.getInt(fieldName); break;
+                case LONG: dObjTyped.getLong(fieldName); break;
+                case BYTE: dObjTyped.getByte(fieldName); break;
+                case FLOAT: dObjTyped.getFloat(fieldName); break;
+                case DOUBLE: dObjTyped.getDouble(fieldName); break;
+                case STRING: dObjTyped.getString(fieldName); break;
+                case BINARY: dObjTyped.getBlob(fieldName); break;
+                case DATE: dObjTyped.getDate(fieldName); break;
+                case OBJECT: dObjTyped.getObject(fieldName); break;
+                case LIST: dObjTyped.getList(fieldName); break;
+                default:
+                    fail();
+            }
+        }
+    }
+
+    // Test that all getters fail if given an invalid field name
+    @Test
+    public void typedSetter_illegalFieldNameThrows() {
+
+        // Set arguments
+        String linkedField = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING;
+        List<String> arguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_STRING, linkedField);
+        List<String> stringArguments = Arrays.asList(null, "foo", AllJavaTypes.FIELD_BOOLEAN, linkedField);
+
+        // Test all getters
+        for (SupportedType type : SupportedType.values()) {
+            List<String> args = (type == SupportedType.STRING) ? stringArguments : arguments;
+            try {
+                callSetter(type, args);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // Helper method for calling setters with different field names
+    private void callSetter(SupportedType type, List<String> fieldNames) {
+        for (String fieldName : fieldNames) {
+            switch (type) {
+                case BOOLEAN: dObjTyped.setBoolean(fieldName, false); break;
+                case SHORT: dObjTyped.setShort(fieldName, (short) 1); break;
+                case INT: dObjTyped.setInt(fieldName, 1); break;
+                case LONG: dObjTyped.setLong(fieldName, 1L); break;
+                case BYTE: dObjTyped.setByte(fieldName, (byte) 4); break;
+                case FLOAT: dObjTyped.setFloat(fieldName, 1.23f); break;
+                case DOUBLE: dObjTyped.setDouble(fieldName, 1.23d); break;
+                case STRING: dObjTyped.setString(fieldName, "foo"); break;
+                case BINARY: dObjTyped.setBlob(fieldName, new byte[]{}); break;
+                case DATE: dObjTyped.getDate(fieldName); break;
+                case OBJECT: dObjTyped.setObject(fieldName, null); break;
+                case LIST: dObjTyped.setList(fieldName, null); break;
+                default:
+                    fail();
+            }
+        }
+    }
+
+    // Test all typed setters/setters
+    @Test
+    public void typedGettersAndSetters() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                switch (type) {
+                    case BOOLEAN:
+                        dObj.setBoolean(AllJavaTypes.FIELD_BOOLEAN, true);
+                        assertTrue(dObj.getBoolean(AllJavaTypes.FIELD_BOOLEAN));
+                        break;
+                    case SHORT:
+                        dObj.setShort(AllJavaTypes.FIELD_SHORT, (short) 42);
+                        assertEquals(42, dObj.getShort(AllJavaTypes.FIELD_SHORT));
+                        break;
+                    case INT:
+                        dObj.setInt(AllJavaTypes.FIELD_INT, 42);
+                        assertEquals(42, dObj.getInt(AllJavaTypes.FIELD_INT));
+                        break;
+                    case LONG:
+                        dObj.setLong(AllJavaTypes.FIELD_LONG, 42L);
+                        assertEquals(42, dObj.getLong(AllJavaTypes.FIELD_LONG));
+                        break;
+                    case BYTE:
+                        dObj.setByte(AllJavaTypes.FIELD_BYTE, (byte) 4);
+                        assertEquals(4, dObj.getByte(AllJavaTypes.FIELD_BYTE));
+                        break;
+                    case FLOAT:
+                        dObj.setFloat(AllJavaTypes.FIELD_FLOAT, 1.23f);
+                        assertEquals(1.23f, dObj.getFloat(AllJavaTypes.FIELD_FLOAT), 0f);
+                        break;
+                    case DOUBLE:
+                        dObj.setDouble(AllJavaTypes.FIELD_DOUBLE, 1.234d);
+                        assertEquals(1.234d, dObj.getDouble(AllJavaTypes.FIELD_DOUBLE), 0d);
+                        break;
+                    case STRING:
+                        dObj.setString(AllJavaTypes.FIELD_STRING, "str");
+                        assertEquals("str", dObj.getString(AllJavaTypes.FIELD_STRING));
+                        break;
+                    case BINARY:
+                        dObj.setBlob(AllJavaTypes.FIELD_BINARY, new byte[]{1, 2, 3});
+                        assertArrayEquals(new byte[]{1, 2, 3}, dObj.getBlob(AllJavaTypes.FIELD_BINARY));
+                        break;
+                    case DATE:
+                        dObj.setDate(AllJavaTypes.FIELD_DATE, new Date(1000));
+                        assertEquals(new Date(1000), dObj.getDate(AllJavaTypes.FIELD_DATE));
+                        break;
+                    case OBJECT:
+                        dObj.setObject(AllJavaTypes.FIELD_OBJECT, dObj);
+                        assertEquals(dObj, dObj.getObject(AllJavaTypes.FIELD_OBJECT));
+                        break;
+                    case LIST:
+                        // ignore, see testGetList/testSetList
+                        break;
+                    default:
+                        fail();
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_null() {
+        realm.beginTransaction();
+        NullTypes obj = realm.createObject(NullTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                switch (type) {
+                    case OBJECT:
+                        NullTypes childObj = new NullTypes();
+                        childObj.setId(1);
+                        DynamicRealmObject dynamicChildObject = new DynamicRealmObject(realm.copyToRealm(childObj));
+                        dObj.setObject(NullTypes.FIELD_OBJECT_NULL, dynamicChildObject);
+                        assertNotNull(dObj.getObject(NullTypes.FIELD_OBJECT_NULL));
+                        dObj.setNull(NullTypes.FIELD_OBJECT_NULL);
+                        assertNull(dObj.getObject(NullTypes.FIELD_OBJECT_NULL));
+                        break;
+                    case LIST:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case BOOLEAN:
+                        dObj.setNull(NullTypes.FIELD_BOOLEAN_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_BOOLEAN_NULL));
+                        break;
+                    case BYTE:
+                        dObj.setNull(NullTypes.FIELD_BYTE_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_BYTE_NULL));
+                        break;
+                    case SHORT:
+                        dObj.setNull(NullTypes.FIELD_SHORT_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_SHORT_NULL));
+                        break;
+                    case INT:
+                        dObj.setNull(NullTypes.FIELD_INTEGER_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_INTEGER_NULL));
+                        break;
+                    case LONG:
+                        dObj.setNull(NullTypes.FIELD_LONG_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_LONG_NULL));
+                        break;
+                    case FLOAT:
+                        dObj.setNull(NullTypes.FIELD_FLOAT_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_FLOAT_NULL));
+                        break;
+                    case DOUBLE:
+                        dObj.setNull(NullTypes.FIELD_DOUBLE_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_DOUBLE_NULL));
+                        break;
+                    case STRING:
+                        dObj.setNull(NullTypes.FIELD_STRING_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_STRING_NULL));
+                        break;
+                    case BINARY:
+                        dObj.setNull(NullTypes.FIELD_BYTES_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_BYTES_NULL));
+                        break;
+                    case DATE:
+                        dObj.setNull(NullTypes.FIELD_DATE_NULL);
+                        assertTrue(dObj.isNull(NullTypes.FIELD_DATE_NULL));
+                        break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_nullOnRequiredFieldsThrows() {
+        realm.beginTransaction();
+        NullTypes obj = realm.createObject(NullTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                try {
+                    switch (type) {
+                        case OBJECT: continue; // Ignore
+                        case LIST: dObj.setNull(NullTypes.FIELD_LIST_NULL); break;
+                        case BOOLEAN: dObj.setNull(NullTypes.FIELD_BOOLEAN_NOT_NULL); break;
+                        case BYTE: dObj.setNull(NullTypes.FIELD_BYTE_NOT_NULL); break;
+                        case SHORT: dObj.setNull(NullTypes.FIELD_SHORT_NOT_NULL); break;
+                        case INT: dObj.setNull(NullTypes.FIELD_INTEGER_NOT_NULL); break;
+                        case LONG: dObj.setNull(NullTypes.FIELD_LONG_NOT_NULL); break;
+                        case FLOAT: dObj.setNull(NullTypes.FIELD_FLOAT_NOT_NULL); break;
+                        case DOUBLE: dObj.setNull(NullTypes.FIELD_DOUBLE_NOT_NULL); break;
+                        case STRING: dObj.setNull(NullTypes.FIELD_STRING_NOT_NULL); break;
+                        case BINARY: dObj.setNull(NullTypes.FIELD_BYTES_NOT_NULL); break;
+                        case DATE: dObj.setNull(NullTypes.FIELD_DATE_NOT_NULL); break;
+                        default:
+                            fail("Unknown type: " + type);
+                    }
+                    fail("Setting value to null should throw: " + type);
+                } catch (IllegalArgumentException ignored) {
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    // Test types where you can set null using the typed setter instead of using setNull().
+    @Test
+    public void typedSetter_null() {
+        realm.beginTransaction();
+        NullTypes obj = realm.createObject(NullTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                switch (type) {
+                    case OBJECT:
+                        dObj.setObject(NullTypes.FIELD_OBJECT_NULL, null);
+                        assertNull(dObj.getObject(NullTypes.FIELD_OBJECT_NULL));
+                        break;
+                    case LIST:
+                        try {
+                            dObj.setList(NullTypes.FIELD_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case DATE:
+                        dObj.setDate(NullTypes.FIELD_DATE_NULL, null);
+                        assertNull(dObj.getDate(NullTypes.FIELD_DATE_NULL));
+                        break;
+                    case STRING:
+                        dObj.setString(NullTypes.FIELD_STRING_NULL, null);
+                        assertNull(dObj.getString(NullTypes.FIELD_STRING_NULL));
+                        break;
+                    case BINARY:
+                        dObj.setBlob(NullTypes.FIELD_BYTES_NULL, null);
+                        assertNull(dObj.getBlob(NullTypes.FIELD_BYTES_NULL));
+                        break;
+                    case BOOLEAN:
+                    case SHORT:
+                    case INT:
+                    case LONG:
+                    case FLOAT:
+                    case DOUBLE:
+                    default:
+                        // The typed setters for these cannot accept null as input.
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setObject_differentType() {
+        realm.beginTransaction();
+        DynamicRealmObject dog = new DynamicRealmObject(realm.createObject(Dog.class));
+        DynamicRealmObject owner = new DynamicRealmObject(realm.createObject(Owner.class));
+        owner.setString("name", "John");
+        dog.setObject("owner", owner);
+        realm.commitTransaction();
+
+        owner = dog.getObject("owner");
+        assertNotNull(owner);
+        assertEquals("John", owner.getString("name"));
+    }
+
+    @Test
+    public void setObject_wrongTypeThrows() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        Dog otherObj = realm.createObject(Dog.class);
+        DynamicRealmObject dynamicObj = new DynamicRealmObject(obj);
+        DynamicRealmObject dynamicWrongType = new DynamicRealmObject(otherObj);
+        thrown.expect(IllegalArgumentException.class);
+        dynamicObj.setObject(AllJavaTypes.FIELD_OBJECT, dynamicWrongType);
+    }
+
+    @Test
+    public void setObject_objectBelongToTypedRealmThrows() {
+        dynamicRealm.beginTransaction();
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Cannot add an object from another Realm instance.");
+        dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst().setObject(AllJavaTypes.FIELD_OBJECT, dObjTyped);
+
+        dynamicRealm.cancelTransaction();
+    }
+
+    @Test
+    public void setObject_objectBelongToDiffThreadRealmThrows() {
+        final CountDownLatch finishedLatch = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+                dynamicRealm.beginTransaction();
+
+                try {
+                    // ExpectedException doesn't work in another thread.
+                    dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst()
+                            .setObject(AllJavaTypes.FIELD_OBJECT, dObjDynamic);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals(expected.getMessage(), "Cannot add an object from another Realm instance.");
+                }
+
+                dynamicRealm.cancelTransaction();
+                dynamicRealm.close();
+                finishedLatch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(finishedLatch);
+    }
+
+    @Test
+    public void setList_listWithDynamicRealmObject() {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.configuration);
+        dynamicRealm.beginTransaction();
+
+        DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        allTypes.setString(AllTypes.FIELD_STRING, "bender");
+
+        DynamicRealmObject dog = dynamicRealm.createObject(Dog.CLASS_NAME);
+        dog.setString(Dog.FIELD_NAME, "nibbler");
+
+        RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
+        list.add(dog);
+        allTypes.setList(AllTypes.FIELD_REALMLIST, list);
+
+        dynamicRealm.commitTransaction();
+
+        allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .equalTo(AllTypes.FIELD_STRING, "bender")
+                .findFirst();
+        assertEquals("nibbler", allTypes.getList(AllTypes.FIELD_REALMLIST).first().get(Dog.FIELD_NAME));
+        dynamicRealm.close();
+    }
+
+    @Test
+    public void setList_elementBelongToTypedRealmThrows() {
+        RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
+        list.add(dObjTyped);
+
+        dynamicRealm.beginTransaction();
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Each element in 'list' must belong to the same Realm instance.");
+        dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst().setList(AllJavaTypes.FIELD_LIST, list);
+
+        dynamicRealm.cancelTransaction();
+    }
+
+    @Test
+    public void setList_elementBelongToDiffThreadRealmThrows() {
+        final CountDownLatch finishedLatch = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+                RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
+                list.add(dObjDynamic);
+
+                dynamicRealm.beginTransaction();
+
+                try {
+                    // ExpectedException doesn't work in another thread.
+                    dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst().setList(AllJavaTypes.FIELD_LIST, list);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals(expected.getMessage(),
+                            "Each element in 'list' must belong to the same Realm instance.");
+                }
+
+                dynamicRealm.cancelTransaction();
+                dynamicRealm.close();
+                finishedLatch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(finishedLatch);
+    }
+
+    @Test
+    public void setList_wrongTypeThrows() {
+        realm.beginTransaction();
+        AllTypes wrongObj = realm.createObject(AllTypes.class);
+        DynamicRealmObject wrongDynamicObject = new DynamicRealmObject(wrongObj);
+        RealmList<DynamicRealmObject> wrongDynamicList = wrongDynamicObject.getList(AllTypes.FIELD_REALMLIST);
+        thrown.expect(IllegalArgumentException.class);
+        dObjTyped.setList(AllJavaTypes.FIELD_LIST, wrongDynamicList);
+    }
+
+    @Test
+    public void untypedSetter_listWrongTypeThrows() {
+        realm.beginTransaction();
+        AllTypes wrongObj = realm.createObject(AllTypes.class);
+        thrown.expect(IllegalArgumentException.class);
+        dObjTyped.set(AllJavaTypes.FIELD_LIST, wrongObj.getColumnRealmList());
+    }
+
+    @Test
+    public void untypedSetter_listMixedTypesThrows() {
+        realm.beginTransaction();
+        AllJavaTypes obj1 = realm.createObject(AllJavaTypes.class);
+        obj1.setFieldLong(2);
+        CyclicType obj2 = realm.createObject(CyclicType.class);
+
+        RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
+        list.add(new DynamicRealmObject(obj1));
+        list.add(new DynamicRealmObject(obj2));
+        thrown.expect(IllegalArgumentException.class);
+        dObjTyped.set(AllJavaTypes.FIELD_LIST, list);
+    }
+
+    // List is not a simple getter, test separately.
+    @Test
+    public void getList() {
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName("fido");
+        obj.getColumnRealmList().add(dog);
+        realm.commitTransaction();
+
+        DynamicRealmObject dynamicAllTypes = new DynamicRealmObject(obj);
+        RealmList<DynamicRealmObject> list = dynamicAllTypes.getList(AllTypes.FIELD_REALMLIST);
+        DynamicRealmObject listObject = list.get(0);
+
+        assertEquals(1, list.size());
+        assertEquals(Dog.CLASS_NAME, listObject.getType());
+        assertEquals("fido", listObject.getString(Dog.FIELD_NAME));
+    }
+
+    @Test
+    public void untypedGetterSetter() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                switch (type) {
+                    case BOOLEAN:
+                        dObj.set(AllJavaTypes.FIELD_BOOLEAN, true);
+                        assertTrue((Boolean) dObj.get(AllJavaTypes.FIELD_BOOLEAN));
+                        break;
+                    case SHORT:
+                        dObj.set(AllJavaTypes.FIELD_SHORT, (short) 42);
+                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_SHORT));
+                        break;
+                    case INT:
+                        dObj.set(AllJavaTypes.FIELD_INT, 42);
+                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_INT));
+                        break;
+                    case LONG:
+                        dObj.set(AllJavaTypes.FIELD_LONG, 42L);
+                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_LONG));
+                        break;
+                    case BYTE:
+                        dObj.set(AllJavaTypes.FIELD_BYTE, (byte) 4);
+                        assertEquals(Long.parseLong("4"), dObj.get(AllJavaTypes.FIELD_BYTE));
+                        break;
+                    case FLOAT:
+                        dObj.set(AllJavaTypes.FIELD_FLOAT, 1.23f);
+                        assertEquals(Float.parseFloat("1.23"), dObj.get(AllJavaTypes.FIELD_FLOAT));
+                        break;
+                    case DOUBLE:
+                        dObj.set(AllJavaTypes.FIELD_DOUBLE, 1.234d);
+                        assertEquals(Double.parseDouble("1.234"), dObj.get(AllJavaTypes.FIELD_DOUBLE));
+                        break;
+                    case STRING:
+                        dObj.set(AllJavaTypes.FIELD_STRING, "str");
+                        assertEquals("str", dObj.get(AllJavaTypes.FIELD_STRING));
+                        break;
+                    case BINARY:
+                        dObj.set(AllJavaTypes.FIELD_BINARY, new byte[]{1, 2, 3});
+                        assertArrayEquals(new byte[]{1, 2, 3}, (byte[]) dObj.get(AllJavaTypes.FIELD_BINARY));
+                        break;
+                    case DATE:
+                        dObj.set(AllJavaTypes.FIELD_DATE, new Date(1000));
+                        assertEquals(new Date(1000), dObj.get(AllJavaTypes.FIELD_DATE));
+                        break;
+                    case OBJECT:
+                        dObj.set(AllJavaTypes.FIELD_OBJECT, dObj);
+                        assertEquals(dObj, dObj.get(AllJavaTypes.FIELD_OBJECT));
+                        break;
+                    case LIST:
+                        RealmList<DynamicRealmObject> newList = new RealmList<DynamicRealmObject>();
+                        newList.add(dObj);
+                        dObj.set(AllJavaTypes.FIELD_LIST, newList);
+                        RealmList<DynamicRealmObject> list = dObj.getList(AllJavaTypes.FIELD_LIST);
+                        assertEquals(1, list.size());
+                        assertEquals(dObj, list.get(0));
+                        break;
+                    default:
+                        fail();
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void untypedSetter_usingStringConversion() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                switch (type) {
+                    case BOOLEAN:
+                        dObj.set(AllJavaTypes.FIELD_BOOLEAN, "true");
+                        assertTrue(dObj.getBoolean(AllJavaTypes.FIELD_BOOLEAN));
+                        break;
+                    case SHORT:
+                        dObj.set(AllJavaTypes.FIELD_SHORT, "42");
+                        assertEquals((short) 42, dObj.getShort(AllJavaTypes.FIELD_SHORT));
+                        break;
+                    case INT:
+                        dObj.set(AllJavaTypes.FIELD_INT, "42");
+                        assertEquals(42, dObj.getInt(AllJavaTypes.FIELD_INT));
+                        break;
+                    case LONG:
+                        dObj.set(AllJavaTypes.FIELD_LONG, "42");
+                        assertEquals((long) 42, dObj.getLong(AllJavaTypes.FIELD_LONG));
+                        break;
+                    case FLOAT:
+                        dObj.set(AllJavaTypes.FIELD_FLOAT, "1.23");
+                        assertEquals(1.23f, dObj.getFloat(AllJavaTypes.FIELD_FLOAT), 0f);
+                        break;
+                    case DOUBLE:
+                        dObj.set(AllJavaTypes.FIELD_DOUBLE, "1.234");
+                        assertEquals(1.234d, dObj.getDouble(AllJavaTypes.FIELD_DOUBLE), 0f);
+                        break;
+                    case DATE:
+                        dObj.set(AllJavaTypes.FIELD_DATE, "1000");
+                        assertEquals(new Date(1000), dObj.getDate(AllJavaTypes.FIELD_DATE));
+                        break;
+                    // These types don't have a string representation that can be parsed.
+                    case OBJECT:
+                    case LIST:
+                    case STRING:
+                    case BINARY:
+                    case BYTE:
+                        break;
+
+                    default:
+                        fail("Unknown type: " + type);
+                        break;
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void untypedSetter_illegalImplicitConversionThrows() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+        try {
+            for (SupportedType type : SupportedType.values()) {
+                try {
+                    switch (type) {
+                        case SHORT:
+                            dObj.set(AllJavaTypes.FIELD_SHORT, "foo");
+                            break;
+                        case INT:
+                            dObj.set(AllJavaTypes.FIELD_INT, "foo");
+                            break;
+                        case LONG:
+                            dObj.set(AllJavaTypes.FIELD_LONG, "foo");
+                            break;
+                        case FLOAT:
+                            dObj.set(AllJavaTypes.FIELD_FLOAT, "foo");
+                            break;
+                        case DOUBLE:
+                            dObj.set(AllJavaTypes.FIELD_DOUBLE, "foo");
+                            break;
+                        case DATE:
+                            dObj.set(AllJavaTypes.FIELD_DATE, "foo");
+                            break;
+
+                        // These types don't have a string representation that can be parsed.
+                        case BOOLEAN: // Boolean is special as it returns false for all strings != "true"
+                        case BYTE:
+                        case OBJECT:
+                        case LIST:
+                        case STRING:
+                        case BINARY:
+                            continue;
+
+                        default:
+                            fail("Unknown type: " + type);
+                    }
+                    fail(type + " failed");
+                } catch (IllegalArgumentException ignored) {
+                } catch (RealmException e) {
+                    if (!(e.getCause() instanceof ParseException)) {
+                        // providing "foo" to the date parser will blow up with a RealmException
+                        // and the cause will be a ParseException.
+                        fail(type + " failed");
+                    }
+                }
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void isNull_nullNotSupportedField() {
+        assertFalse(dObjTyped.isNull(AllJavaTypes.FIELD_INT));
+    }
+
+    @Test
+    public void isNull_true() {
+        realm.beginTransaction();
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        realm.commitTransaction();
+
+        assertTrue(new DynamicRealmObject(obj).isNull(AllJavaTypes.FIELD_OBJECT));
+    }
+
+    @Test
+    public void isNull_false() {
+        assertFalse(dObjTyped.isNull(AllJavaTypes.FIELD_OBJECT));
+    }
+
+    @Test
+    public void getFieldNames() {
+        String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT,
+                AllJavaTypes.FIELD_LONG, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT, AllJavaTypes.FIELD_DOUBLE,
+                AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE, AllJavaTypes.FIELD_BINARY,
+                AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
+        String[] keys = dObjTyped.getFieldNames();
+        assertArrayEquals(expectedKeys, keys);
+    }
+
+    @Test
+    public void hasField_false() {
+        assertFalse(dObjTyped.hasField(null));
+        assertFalse(dObjTyped.hasField(""));
+        assertFalse(dObjTyped.hasField("foo"));
+        assertFalse(dObjTyped.hasField("foo.bar"));
+        assertFalse(dObjTyped.hasField(TestHelper.getRandomString(65)));
+    }
+
+    @Test
+    public void hasField_true() {
+        assertTrue(dObjTyped.hasField(AllJavaTypes.FIELD_STRING));
+    }
+
+    @Test
+    public void getFieldType() {
+        assertEquals(RealmFieldType.STRING, dObjTyped.getFieldType(AllJavaTypes.FIELD_STRING));
+        assertEquals(RealmFieldType.BINARY, dObjTyped.getFieldType(AllJavaTypes.FIELD_BINARY));
+        assertEquals(RealmFieldType.BOOLEAN, dObjTyped.getFieldType(AllJavaTypes.FIELD_BOOLEAN));
+        assertEquals(RealmFieldType.DATE, dObjTyped.getFieldType(AllJavaTypes.FIELD_DATE));
+        assertEquals(RealmFieldType.DOUBLE, dObjTyped.getFieldType(AllJavaTypes.FIELD_DOUBLE));
+        assertEquals(RealmFieldType.FLOAT, dObjTyped.getFieldType(AllJavaTypes.FIELD_FLOAT));
+        assertEquals(RealmFieldType.OBJECT, dObjTyped.getFieldType(AllJavaTypes.FIELD_OBJECT));
+        assertEquals(RealmFieldType.LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_LIST));
+        assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_BYTE));
+        assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_SHORT));
+        assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_INT));
+        assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_LONG));
+    }
+
+    @Test
+    public void equals() {
+        AllJavaTypes obj1 = realm.where(AllJavaTypes.class).findFirst();
+        AllJavaTypes obj2 = realm.where(AllJavaTypes.class).findFirst();
+        DynamicRealmObject dObj1 = new DynamicRealmObject(obj1);
+        DynamicRealmObject dObj2 = new DynamicRealmObject(obj2);
+        assertTrue(dObj1.equals(dObj2));
+    }
+
+    @Test
+    public void equals_standardAndDynamicObjectsNotEqual() {
+        AllJavaTypes standardObj = realm.where(AllJavaTypes.class).findFirst();
+        //noinspection EqualsBetweenInconvertibleTypes
+        assertFalse(dObjTyped.equals(standardObj));
+    }
+
+    @Test
+    public void hashcode() {
+        AllJavaTypes standardObj = realm.where(AllJavaTypes.class).findFirst();
+        DynamicRealmObject dObj1 = new DynamicRealmObject(standardObj);
+        assertEquals(standardObj.hashCode(), dObj1.hashCode());
+    }
+
+    @Test
+    public void toString_test() {
+        // Check that toString() doesn't crash. And do simple formatting checks. We cannot compare to a set String as
+        // eg. the byte array will be allocated each time it is accessed.
+        String str = dObjTyped.toString();
+        assertTrue(str.startsWith("class_AllJavaTypes = ["));
+        assertTrue(str.endsWith("}]"));
+    }
+
+    public void testExceptionMessage() {
+        // test for https://github.com/realm/realm-java/issues/2141
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        DynamicRealmObject o = new DynamicRealmObject(obj);
+        try {
+            o.getFloat("nonExisting"); // Note that "o" does not have "nonExisting" field.
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals("Illegal Argument: Field not found: nonExisting", e.getMessage());
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
new file mode 100644
index 0000000000..62fccaf864
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -0,0 +1,999 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.os.Handler;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.Owner;
+import io.realm.internal.log.RealmLog;
+import io.realm.proxy.HandlerProxy;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class DynamicRealmTests {
+
+    private final static int TEST_DATA_SIZE = 10;
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private RealmConfiguration defaultConfig;
+    private DynamicRealm realm;
+
+    @Before
+    public void setUp() {
+        defaultConfig = configFactory.createConfiguration();
+
+        // Initialize schema. DynamicRealm will not do that, so let a normal Realm create the file first.
+        Realm.getInstance(defaultConfig).close();
+        realm = DynamicRealm.getInstance(defaultConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void populateTestRealm(DynamicRealm realm, int objects) {
+        boolean autoRefreshEnabled = realm.isAutoRefresh();
+        if (autoRefreshEnabled) {
+            realm.setAutoRefresh(false);
+        }
+        realm.beginTransaction();
+        realm.allObjects(AllTypes.CLASS_NAME).clear();
+        for (int i = 0; i < objects; ++i) {
+            DynamicRealmObject allTypes = realm.createObject(AllTypes.CLASS_NAME);
+            allTypes.setBoolean(AllTypes.FIELD_BOOLEAN, (i % 3) == 0);
+            allTypes.setBlob(AllTypes.FIELD_BINARY, new byte[]{1, 2, 3});
+            allTypes.setDate(AllTypes.FIELD_DATE, new Date());
+            allTypes.setDouble(AllTypes.FIELD_DOUBLE, 3.1415D + i);
+            allTypes.setFloat(AllTypes.FIELD_FLOAT, 1.234567F + i);
+            allTypes.setString(AllTypes.FIELD_STRING, "test data " + i);
+            allTypes.setLong(AllTypes.FIELD_LONG, i);
+            allTypes.getList(AllTypes.FIELD_REALMLIST).add(realm.createObject(Dog.CLASS_NAME));
+            allTypes.getList(AllTypes.FIELD_REALMLIST).add(realm.createObject(Dog.CLASS_NAME));
+        }
+        realm.commitTransaction();
+        if (autoRefreshEnabled) {
+            realm.setAutoRefresh(true);
+        }
+    }
+
+    private void populateTestRealm() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+    }
+
+    // Test that the SharedGroupManager is not reused across Realm/DynamicRealm on the same thread.
+    // This is done by starting a write transaction in one Realm and verifying that none of the data
+    // written (but not committed) is available in the other Realm.
+    @Test
+    public void separateSharedGroups() {
+        Realm typedRealm = Realm.getInstance(defaultConfig);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+        assertEquals(0, typedRealm.where(AllTypes.class).count());
+        assertEquals(0, dynamicRealm.where(AllTypes.CLASS_NAME).count());
+
+        typedRealm.beginTransaction();
+        try {
+            typedRealm.createObject(AllTypes.class);
+            assertEquals(1, typedRealm.where(AllTypes.class).count());
+            assertEquals(0, dynamicRealm.where(AllTypes.CLASS_NAME).count());
+            typedRealm.cancelTransaction();
+        } finally {
+            typedRealm.close();
+            dynamicRealm.close();
+        }
+    }
+
+    // Test that Realms can only be deleted after all Typed and Dynamic instances are closed
+    @Test
+    public void deleteRealm_ThrowsIfDynamicRealmIsOpen() {
+        realm.close(); // Close Realm opened in setUp();
+        Realm typedRealm = Realm.getInstance(defaultConfig);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+        typedRealm.close();
+        try {
+            Realm.deleteRealm(defaultConfig);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        dynamicRealm.close();
+        assertTrue(Realm.deleteRealm(defaultConfig));
+    }
+
+    // Test that Realms can only be deleted after all Typed and Dynamic instances are closed.
+    @Test
+    public void deleteRealm_throwsIfTypedRealmIsOpen() {
+        realm.close(); // Close Realm opened in setUp();
+        Realm typedRealm = Realm.getInstance(defaultConfig);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+        dynamicRealm.close();
+        try {
+            Realm.deleteRealm(defaultConfig);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        typedRealm.close();
+        assertTrue(Realm.deleteRealm(defaultConfig));
+    }
+
+    @Test
+    public void createObject() {
+        realm.beginTransaction();
+        DynamicRealmObject obj = realm.createObject(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+        assertTrue(obj.isValid());
+    }
+
+    @Test
+    public void createObject_withPrimaryKey() {
+        realm.beginTransaction();
+        DynamicRealmObject dog = realm.createObject(DogPrimaryKey.CLASS_NAME, 42);
+        assertEquals(42, dog.getLong("id"));
+        realm.cancelTransaction();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void createObject_illegalPrimaryKeyValue() {
+        realm.beginTransaction();
+        realm.createObject(DogPrimaryKey.CLASS_NAME, "bar");
+    }
+
+    @Test
+    public void where() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+
+        RealmResults<DynamicRealmObject> results = realm.where(AllTypes.CLASS_NAME).findAll();
+        assertEquals(1, results.size());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void clear_invalidName() {
+        realm.beginTransaction();
+        realm.clear("I don't exist");
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void clear_outsideTransactionClearOutsideTransactionThrows() {
+        realm.clear(AllTypes.CLASS_NAME);
+    }
+
+    @Test
+    public void clear() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());
+        realm.beginTransaction();
+        realm.clear(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+        assertEquals(0, realm.where(AllTypes.CLASS_NAME).count());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void executeTransaction_null() {
+        realm.executeTransaction(null);
+    }
+
+    @Test
+    public void executeTransaction() {
+        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        realm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);
+                owner.setString("name", "Owner");
+            }
+        });
+
+        RealmResults<DynamicRealmObject> allObjects = realm.allObjects(Owner.CLASS_NAME);
+        assertEquals(1, allObjects.size());
+        assertEquals("Owner", allObjects.get(0).getString("name"));
+    }
+
+    @Test
+    public void executeTransaction_cancelled() {
+        final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
+
+        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+        try {
+            realm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);
+                    owner.setString("name", "Owner");
+                    thrownException.set(new RuntimeException("Boom"));
+                    throw thrownException.get();
+                }
+            });
+        } catch (RuntimeException e) {
+            //noinspection ThrowableResultOfMethodCallIgnored
+            assertTrue(e == thrownException.get());
+        }
+        assertEquals(0, realm.allObjects(Owner.CLASS_NAME).size());
+    }
+
+    @Test
+    public void executeTransaction_warningIfManuallyCancelled() {
+        assertEquals(0, realm.allObjects("Owner").size());
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        try {
+            RealmLog.add(testLogger);
+            realm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    DynamicRealmObject owner = realm.createObject("Owner");
+                    owner.setString("name", "Owner");
+                    realm.cancelTransaction();
+                    throw new RuntimeException("Boom");
+                }
+            });
+        } catch (RuntimeException ignored) {
+            // Ensure that we pass a valuable error message to the logger for developers.
+            assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
+        } finally {
+            RealmLog.remove(testLogger);
+        }
+        assertEquals(0, realm.allObjects("Owner").size());
+    }
+
+    @Test
+    public void allObjectsSorted() {
+        populateTestRealm();
+        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("test data 0", sortedList.first().getString(AllTypes.FIELD_STRING));
+
+        RealmResults<DynamicRealmObject> reverseList = realm.allObjectsSorted(AllTypes.CLASS_NAME, AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("test data 0", reverseList.last().getString(AllTypes.FIELD_STRING));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void allObjectsSorted_wrongFieldName() {
+        realm.allObjectsSorted(AllTypes.CLASS_NAME, "invalid", Sort.ASCENDING);
+    }
+
+    @Test
+    public void allObjectsSorted_sortTwoFields() {
+        TestHelper.populateForMultiSort(realm);
+
+        RealmResults<DynamicRealmObject> results1 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
+                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
+                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+
+        assertEquals(3, results1.size());
+
+        assertEquals("Adam", results1.get(0).getString(AllTypes.FIELD_STRING));
+        assertEquals(4, results1.get(0).getLong(AllTypes.FIELD_LONG));
+
+        assertEquals("Adam", results1.get(1).getString(AllTypes.FIELD_STRING));
+        assertEquals(5, results1.get(1).getLong(AllTypes.FIELD_LONG));
+
+        assertEquals("Brian", results1.get(2).getString(AllTypes.FIELD_STRING));
+        assertEquals(4, results1.get(2).getLong(AllTypes.FIELD_LONG));
+
+        RealmResults<DynamicRealmObject> results2 = realm.allObjectsSorted(AllTypes.CLASS_NAME,
+                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
+                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+
+        assertEquals(3, results2.size());
+
+        assertEquals("Adam", results2.get(0).getString(AllTypes.FIELD_STRING));
+        assertEquals(4, results2.get(0).getLong(AllTypes.FIELD_LONG));
+
+        assertEquals("Brian", results2.get(1).getString(AllTypes.FIELD_STRING));
+        assertEquals(4, results2.get(1).getLong(AllTypes.FIELD_LONG));
+
+        assertEquals("Adam", results2.get(2).getString(AllTypes.FIELD_STRING));
+        assertEquals(5, results2.get(2).getLong(AllTypes.FIELD_LONG));
+    }
+
+    @Test
+    public void allObjectsSorted_failures() {
+        // zero fields specified
+        try {
+            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{}, new Sort[]{});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // number of fields and sorting orders don't match
+        try {
+            realm.allObjectsSorted(AllTypes.CLASS_NAME,
+                    new String[]{AllTypes.FIELD_STRING},
+                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // null is not allowed
+        try {
+            realm.allObjectsSorted(AllTypes.CLASS_NAME, null, (Sort[]) null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.allObjectsSorted(AllTypes.CLASS_NAME, new String[]{AllTypes.FIELD_STRING}, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // non-existing field name
+        try {
+            realm.allObjectsSorted(AllTypes.CLASS_NAME,
+                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
+                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void allObjectsSorted_singleField() {
+        populateTestRealm();
+        RealmResults<DynamicRealmObject> sortedList = realm.allObjectsSorted(AllTypes.CLASS_NAME,
+                new String[]{AllTypes.FIELD_LONG},
+                new Sort[]{Sort.DESCENDING});
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getLong(AllTypes.FIELD_LONG));
+        assertEquals(0, sortedList.last().getLong(AllTypes.FIELD_LONG));
+    }
+
+    private void populateForDistinct(DynamicRealm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
+        boolean autoRefreshEnabled = realm.isAutoRefresh();
+        if (autoRefreshEnabled) {
+            realm.setAutoRefresh(false);
+        }
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
+            for (int j = 0; j < numberOfBlocks; j++) {
+                DynamicRealmObject obj = realm.createObject("AnnotationIndexTypes");
+                obj.setBoolean("indexBoolean", j % 2 == 0);
+                obj.setLong("indexLong", j);
+                obj.setDate("indexDate", withNull ? null : new Date(1000 * ((long) j)));
+                obj.setString("indexString", withNull ? null : "Test " + j);
+                obj.setBoolean("notIndexBoolean", j % 2 == 0);
+                obj.setLong("notIndexLong", j);
+                obj.setDate("notIndexDate", withNull ? null : new Date(1000 * ((long) j)));
+                obj.setString("notIndexString", withNull ? null : "Test " + j);
+            }
+        }
+        realm.commitTransaction();
+        if (autoRefreshEnabled) {
+            realm.setAutoRefresh(true);
+        }
+    }
+
+    private void populateForDistinctInvalidTypesLinked(DynamicRealm realm) {
+        realm.beginTransaction();
+        DynamicRealmObject notEmpty = realm.createObject(AllJavaTypes.CLASS_NAME);
+        notEmpty.setBlob(AllJavaTypes.FIELD_BINARY, new byte[]{1, 2, 3});
+        notEmpty.setObject(AllJavaTypes.FIELD_OBJECT, notEmpty);
+        notEmpty.setList(AllJavaTypes.FIELD_LIST, new RealmList<DynamicRealmObject>(notEmpty));
+        realm.commitTransaction();
+    }
+
+    /*
+     * Fields order test for Chained or Multi-Arguments Distinct()
+     *
+     * The idea is to interweave different values in 2's multiplier and 3's multiplier in a way that
+     * the outcome is different if the order of distinct* operations alternates. More numbers of
+     * fields can be constructed with the combination of multipliers in prime numbers such as 2, 3,
+     * and 5.
+     *
+     * An example is illustrated below.
+     *
+     * Object      : O1| O2| O3| O4| O5| O6
+     * indexString : A | A | B | B | A | A
+     * indexLong   : 1 | 1 | 1 | 2 | 2 | 2
+     */
+    private void populateForDistinctFieldsOrder(DynamicRealm realm, long numberOfBlocks) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfBlocks; i++) {
+            for (int j = 0; j < 6; j++) {
+                DynamicRealmObject obj = realm.createObject(AnnotationIndexTypes.CLASS_NAME);
+                obj.setString("indexString", (((j / 2) % 2) == 0) ? "A" : "B");
+                obj.setLong("indexLong", (j < 3) ? 1 : 2);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void distinct_invalidClassNames() {
+        String[] classNames = new String[]{null, "", "foo", "foo.bar"};
+        for (String className : classNames) {
+            try {
+                realm.distinct(className, "foo");
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_invalidFieldNames() {
+        String[] fieldNames = new String[]{null, "", "foo", "foo.bar"};
+        for (String fieldName : fieldNames) {
+            try {
+                realm.distinct(AnnotationIndexTypes.CLASS_NAME, fieldName);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
+    @Test
+    public void distinct() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<DynamicRealmObject> distinctBool = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<DynamicRealmObject> distinct = realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
+            assertEquals(field, numberOfBlocks, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.distinct(AnnotationIndexTypes.CLASS_NAME, field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_invalidTypes() {
+        populateTestRealm();
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.distinct(AllTypes.CLASS_NAME, field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        assertEquals(numberOfBlocks, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_switchedFieldsOrder() {
+        final long numberOfBlocks = 25;
+        populateForDistinctFieldsOrder(realm, numberOfBlocks);
+
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        RealmResults<DynamicRealmObject> distinctStringLong = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
+        RealmResults<DynamicRealmObject> distinctLongString = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(4, distinctStringLong.size());
+        assertEquals(4, distinctLongString.size());
+        assertEquals(distinctStringLong.size(), distinctLongString.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_emptyFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        // an empty string field in the middle
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // an empty string field at the end
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field in the middle
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field at the end
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // (String)null makes varargs a null array.
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two (String)null for first and varargs fields
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, (String)null, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two empty fields tests
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, "", "");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmResults<DynamicRealmObject> distinctMulti = realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(1, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_doesNotExistField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesFields() {
+        populateTestRealm();
+
+        try {
+            realm.distinct(AllTypes.CLASS_NAME, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.distinct(AllJavaTypes.CLASS_NAME, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+        final DynamicRealmObject allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 4, 9)
+                .findFirstAsync();
+        assertFalse(allTypes.isLoaded());
+
+        allTypes.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("test data 4", allTypes.getString(AllTypes.FIELD_STRING));
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+        final RealmResults<DynamicRealmObject> allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 4, 9)
+                .findAllAsync();
+
+        assertFalse(allTypes.isLoaded());
+        assertEquals(0, allTypes.size());
+
+        allTypes.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(6, allTypes.size());
+                for (int i = 0; i < allTypes.size(); i++) {
+                    assertEquals("test data " + (4 + i), allTypes.get(i).getString(AllTypes.FIELD_STRING));
+                }
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+        final RealmResults<DynamicRealmObject> allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 0, 4)
+                .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertFalse(allTypes.isLoaded());
+        assertEquals(0, allTypes.size());
+
+        allTypes.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(5, allTypes.size());
+                for (int i = 0; i < 5; i++) {
+                    int iteration = (4 - i);
+                    assertEquals("test data " + iteration, allTypes.get(4 - iteration).getString(AllTypes.FIELD_STRING));
+                }
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Initialize a Dynamic Realm used by the *Async tests.
+    private DynamicRealm initializeDynamicRealm() {
+        RealmConfiguration defaultConfig = looperThread.realmConfiguration;
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+        populateTestRealm(dynamicRealm, 10);
+        return dynamicRealm;
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync_usingMultipleFields() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+
+        dynamicRealm.setAutoRefresh(false);
+        dynamicRealm.beginTransaction();
+        dynamicRealm.clear(AllTypes.CLASS_NAME);
+        for (int i = 0; i < 5; ) {
+            DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+            allTypes.set(AllTypes.FIELD_LONG, i);
+            allTypes.set(AllTypes.FIELD_STRING, "data " + i % 3);
+
+            allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+            allTypes.set(AllTypes.FIELD_LONG, i);
+            allTypes.set(AllTypes.FIELD_STRING, "data " + (++i % 3));
+        }
+        dynamicRealm.commitTransaction();
+        dynamicRealm.setAutoRefresh(true);
+
+        // Sort first set by using: String[ASC], Long[DESC]
+        final RealmResults<DynamicRealmObject> realmResults1 = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .findAllSortedAsync(
+                        new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
+                        new Sort[]{Sort.ASCENDING, Sort.DESCENDING}
+                );
+
+        // Sort second set by using: String[DESC], Long[ASC]
+        final RealmResults<DynamicRealmObject> realmResults2 = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 0, 5)
+                .findAllSortedAsync(
+                        new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
+                        new Sort[]{Sort.DESCENDING, Sort.ASCENDING}
+                );
+
+        final Runnable signalCallbackDone = new Runnable() {
+            final AtomicInteger callbacksDone = new AtomicInteger(2);
+            @Override
+            public void run() {
+                if (callbacksDone.decrementAndGet() == 0) {
+                    dynamicRealm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        realmResults1.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("data 0", realmResults1.get(0).get(AllTypes.FIELD_STRING));
+                assertEquals(3L, realmResults1.get(0).get(AllTypes.FIELD_LONG));
+                assertEquals("data 0", realmResults1.get(1).get(AllTypes.FIELD_STRING));
+                assertEquals(2L, realmResults1.get(1).get(AllTypes.FIELD_LONG));
+                assertEquals("data 0", realmResults1.get(2).get(AllTypes.FIELD_STRING));
+                assertEquals(0L, realmResults1.get(2).get(AllTypes.FIELD_LONG));
+
+                assertEquals("data 1", realmResults1.get(3).get(AllTypes.FIELD_STRING));
+                assertEquals(4L, realmResults1.get(3).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults1.get(4).get(AllTypes.FIELD_STRING));
+                assertEquals(3L, realmResults1.get(4).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults1.get(5).get(AllTypes.FIELD_STRING));
+                assertEquals(1L, realmResults1.get(5).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults1.get(6).get(AllTypes.FIELD_STRING));
+                assertEquals(0L, realmResults1.get(6).get(AllTypes.FIELD_LONG));
+
+                assertEquals("data 2", realmResults1.get(7).get(AllTypes.FIELD_STRING));
+                assertEquals(4L, realmResults1.get(7).get(AllTypes.FIELD_LONG));
+                assertEquals("data 2", realmResults1.get(8).get(AllTypes.FIELD_STRING));
+                assertEquals(2L, realmResults1.get(8).get(AllTypes.FIELD_LONG));
+                assertEquals("data 2", realmResults1.get(9).get(AllTypes.FIELD_STRING));
+                assertEquals(1L, realmResults1.get(9).get(AllTypes.FIELD_LONG));
+
+                signalCallbackDone.run();
+            }
+        });
+
+        realmResults2.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("data 2", realmResults2.get(0).get(AllTypes.FIELD_STRING));
+                assertEquals(1L, realmResults2.get(0).get(AllTypes.FIELD_LONG));
+                assertEquals("data 2", realmResults2.get(1).get(AllTypes.FIELD_STRING));
+                assertEquals(2L, realmResults2.get(1).get(AllTypes.FIELD_LONG));
+                assertEquals("data 2", realmResults2.get(2).get(AllTypes.FIELD_STRING));
+                assertEquals(4L, realmResults2.get(2).get(AllTypes.FIELD_LONG));
+
+                assertEquals("data 1", realmResults2.get(3).get(AllTypes.FIELD_STRING));
+                assertEquals(0L, realmResults2.get(3).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults2.get(4).get(AllTypes.FIELD_STRING));
+                assertEquals(1L, realmResults2.get(4).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults2.get(5).get(AllTypes.FIELD_STRING));
+                assertEquals(3L, realmResults2.get(5).get(AllTypes.FIELD_LONG));
+                assertEquals("data 1", realmResults2.get(6).get(AllTypes.FIELD_STRING));
+                assertEquals(4L, realmResults2.get(6).get(AllTypes.FIELD_LONG));
+
+                assertEquals("data 0", realmResults2.get(7).get(AllTypes.FIELD_STRING));
+                assertEquals(0L, realmResults2.get(7).get(AllTypes.FIELD_LONG));
+                assertEquals("data 0", realmResults2.get(8).get(AllTypes.FIELD_STRING));
+                assertEquals(2L, realmResults2.get(8).get(AllTypes.FIELD_LONG));
+                assertEquals("data 0", realmResults2.get(9).get(AllTypes.FIELD_STRING));
+                assertEquals(3L, realmResults2.get(9).get(AllTypes.FIELD_LONG));
+
+                signalCallbackDone.run();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(dynamicRealm, numberOfBlocks, numberOfObjects, false);
+
+        final RealmResults<DynamicRealmObject> distinctBool = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        final RealmResults<DynamicRealmObject> distinctLong = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_LONG);
+        final RealmResults<DynamicRealmObject> distinctDate = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_DATE);
+        final RealmResults<DynamicRealmObject> distinctString = dynamicRealm.distinctAsync(AnnotationIndexTypes.CLASS_NAME, AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        final Runnable callbackDoneTask = new Runnable() {
+            final CountDownLatch signalTestFinished = new CountDownLatch(4);
+            @Override
+            public void run() {
+                signalTestFinished.countDown();
+                if (signalTestFinished.getCount() == 0) {
+                    dynamicRealm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        distinctBool.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(2, distinctBool.size());
+                callbackDoneTask.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                callbackDoneTask.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                callbackDoneTask.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctString.size());
+                callbackDoneTask.run();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+        final DynamicRealmObject[] dynamicRealmObject = new DynamicRealmObject[1];
+
+        // Intercept completion of the async DynamicRealmObject query
+        Handler handler = new HandlerProxy(dynamicRealm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                        post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertFalse(dynamicRealmObject[0].isLoaded());
+                                assertFalse(dynamicRealmObject[0].isValid());
+                                try {
+                                    dynamicRealmObject[0].getObject(AllTypes.FIELD_BINARY);
+                                    fail("trying to access a DynamicRealmObject property should throw");
+                                } catch (IllegalStateException ignored) {
+
+                                } finally {
+                                    dynamicRealm.close();
+                                    looperThread.testComplete();
+                                }
+                            }
+                        });
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+
+        dynamicRealm.setHandler(handler);
+        dynamicRealmObject[0] = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 4, 9)
+                .findFirstAsync();
+    }
+
+    @Test
+    public void clear_all() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.CLASS_NAME);
+        DynamicRealmObject cat = realm.createObject(Cat.CLASS_NAME);
+        DynamicRealmObject owner =  realm.createObject(Owner.CLASS_NAME);
+        owner.setObject("cat", cat);
+        realm.getSchema().create("TestRemoveAll").addField("Field1", String.class);
+        realm.createObject("TestRemoveAll");
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(AllTypes.CLASS_NAME).count());
+        assertEquals(1, realm.where(Owner.CLASS_NAME).count());
+        assertEquals(1, realm.where(Cat.CLASS_NAME).count());
+        assertEquals(1, realm.where("TestRemoveAll").count());
+
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(AllTypes.CLASS_NAME).count());
+        assertEquals(0, realm.where(Owner.CLASS_NAME).count());
+        assertEquals(0, realm.where(Cat.CLASS_NAME).count());
+        assertEquals(0, realm.where("TestRemoveAll").count());
+        assertTrue(realm.isEmpty());
+    }
+
+    @Test
+    public void realmListRemoveAllFromRealm() {
+        populateTestRealm(realm, 1);
+        RealmList<DynamicRealmObject> list = realm.where(AllTypes.CLASS_NAME).findFirst().getList(AllTypes.FIELD_REALMLIST);
+        assertEquals(2, list.size());
+
+        realm.beginTransaction();
+        list.deleteAllFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(0, list.size());
+        assertEquals(0, realm.where(Dog.CLASS_NAME).count());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
new file mode 100644
index 0000000000..cc45110462
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.util.Date;
+
+import io.realm.entities.IOSAllTypes;
+import io.realm.entities.IOSChild;
+import io.realm.internal.Table;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * This class test interoperability with Realms created on iOS.
+ */
+@RunWith(AndroidJUnit4.class)
+public class IOSRealmTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private static final String[] IOS_VERSIONS = new String[] {"0.98.0"};
+    private static final String REALM_NAME = "alltypes.realm";
+    private Realm realm;
+    private Context context;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration defaultConfiguration = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .schema(IOSAllTypes.class, IOSChild.class)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+        Realm.setDefaultConfiguration(defaultConfiguration);
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+    }
+
+    @After
+    public void tearDown() {
+        Realm.removeDefaultConfiguration();
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void iOSDataTypes() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
+            realm = Realm.getDefaultInstance();
+            RealmResults<IOSAllTypes> result = realm.allObjectsSorted(IOSAllTypes.class, "id", Sort.ASCENDING);
+            // Verify metadata
+            Table table = realm.getTable(IOSAllTypes.class);
+            assertTrue(table.hasPrimaryKey());
+            assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
+            // iterative check
+            for (int i = 0; i < 10; i++) {
+                IOSAllTypes obj = result.get(i);
+                assertTrue(obj.isBoolCol());
+                assertEquals(i + 1, obj.getShortCol());
+                assertEquals(10 + i, obj.getIntCol());
+                assertEquals(100 + i, obj.getLongCol());
+                assertEquals(100000000L + (long)i, obj.getLongLongCol());
+                assertEquals(1.23F + (float)i, obj.getFloatCol(), 0F);
+                assertEquals(1.234D + (double)i, obj.getDoubleCol(), 0D);
+                assertArrayEquals(new byte[]{1, 2, 3}, obj.getByteCol());
+                assertEquals("String " + Integer.toString(i), obj.getStringCol());
+                assertEquals(new Date((1000 + i) * 1000), obj.getDateCol());
+                assertEquals("Foo", result.get(i).getChild().getName());
+                assertEquals(10, result.get(i).getChildren().size());
+                for (int j = 0; j < 10; j++) {
+                    assertEquals("Name: " + Integer.toString(i), result.get(i).getChildren().get(j).getName());
+                }
+            }
+        }
+    }
+
+    @Test
+    public void iOSDataTypesDefaultValues() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes-default.realm", REALM_NAME);
+            realm = Realm.getDefaultInstance();
+
+            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            assertFalse(obj.isBoolCol());
+            assertEquals(0, obj.getShortCol());
+            assertEquals(0, obj.getIntCol());
+            assertEquals(0, obj.getLongCol());
+            assertEquals(0L, obj.getLongLongCol());
+            assertEquals(0.0F, obj.getFloatCol(), 0F);
+            assertEquals(0.0D, obj.getDoubleCol(), 0D);
+            assertArrayEquals(new byte[0], obj.getByteCol());
+            assertEquals("", obj.getStringCol());
+            assertEquals(new Date(0), obj.getDateCol());
+            assertNull(obj.getChild());
+            assertEquals(0, obj.getChildren().size());
+        }
+    }
+
+    @Test
+    public void iOSDataTypesNullValues() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes-null-value.realm", REALM_NAME);
+            realm = Realm.getDefaultInstance();
+
+            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            assertEquals(null, obj.getByteCol());
+            assertEquals(null, obj.getStringCol());
+            assertEquals(null, obj.getDateCol());
+            assertEquals(null, obj.getChild());
+            assertEquals(new RealmList<IOSChild>(), obj.getChildren());
+        }
+    }
+
+    @Test
+    public void iOSDataTypesMinimumValues() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes-min.realm", REALM_NAME);
+            realm = Realm.getDefaultInstance();
+
+            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            assertFalse(obj.isBoolCol());
+            assertEquals(Short.MIN_VALUE, obj.getShortCol());
+            assertEquals(Integer.MIN_VALUE, obj.getIntCol());
+            assertEquals(Integer.MIN_VALUE, obj.getLongCol());
+            assertEquals(Long.MIN_VALUE, obj.getLongLongCol());
+            assertEquals(-Float.MAX_VALUE, obj.getFloatCol(), 0F);
+            assertEquals(-Double.MAX_VALUE, obj.getDoubleCol(), 0D);
+            assertArrayEquals(new byte[0], obj.getByteCol());
+            assertEquals("", obj.getStringCol());
+            assertEquals(0x8000000000000000L * 1000L, obj.getDateCol().getTime());
+        }
+    }
+
+    @Test
+    public void iOSDataTypesMaximumValues() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes-max.realm", REALM_NAME);
+            realm = Realm.getDefaultInstance();
+
+            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            assertEquals(Short.MAX_VALUE, obj.getShortCol());
+            assertEquals(Integer.MAX_VALUE, obj.getIntCol());
+            assertEquals(Integer.MAX_VALUE, obj.getLongCol());
+            assertEquals(Long.MAX_VALUE, obj.getLongLongCol());
+            assertEquals(Float.MAX_VALUE, obj.getFloatCol(), 0F);
+            assertEquals(Double.MAX_VALUE, obj.getDoubleCol(), 0D);
+            assertArrayEquals(new byte[0], obj.getByteCol());
+            assertEquals("", obj.getStringCol());
+            assertEquals(0x8000000000000000L * 1000L, obj.getDateCol().getTime());
+        }
+    }
+
+    @Test
+    public void iOSEncryptedRealm() throws IOException {
+        for (String iosVersion : IOS_VERSIONS) {
+            configFactory.copyRealmFromAssets(context,
+                    "ios/" + iosVersion + "-alltypes-default-encrypted.realm", REALM_NAME);
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .name(REALM_NAME)
+                    .encryptionKey(getIOSKey())
+                    .schema(IOSAllTypes.class, IOSChild.class)
+                    .build();
+            realm = Realm.getInstance(realmConfig);
+
+            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            assertFalse(obj.isBoolCol());
+            assertEquals(0, obj.getShortCol());
+            assertEquals(0, obj.getIntCol());
+            assertEquals(0L, obj.getLongCol());
+            assertEquals(0.0F, obj.getFloatCol(), 0F);
+            assertEquals(0.0D, obj.getDoubleCol(), 0D);
+            assertArrayEquals(new byte[0], obj.getByteCol());
+            assertEquals("", obj.getStringCol());
+            assertEquals(new Date(0), obj.getDateCol());
+            assertNull(obj.getChild());
+            assertEquals(0, obj.getChildren().size());
+        }
+    }
+
+    private byte[] getIOSKey() {
+        byte[] keyData = new byte[64];
+        for (int i = 0; i < keyData.length; i++) {
+            keyData[i] = 1;
+        }
+        return keyData;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java b/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java
new file mode 100644
index 0000000000..5bc28cad5b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/MediatorTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.test.AndroidTestCase;
+
+import java.util.Arrays;
+
+import io.realm.annotations.RealmModule;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnimalModule;
+import io.realm.entities.Cat;
+import io.realm.entities.CatOwner;
+import io.realm.entities.Dog;
+import io.realm.entities.HumanModule;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+
+public class MediatorTest extends AndroidTestCase {
+
+    @SuppressWarnings("AssertEqualsBetweenInconvertibleTypes")
+    public void testMediatorsEquality() {
+        final DefaultRealmModuleMediator defaultMediator = new DefaultRealmModuleMediator();
+        final CompositeMediator compositeMediator = new CompositeMediator(defaultMediator);
+        final FilterableMediator filterableMediator = new FilterableMediator(defaultMediator, defaultMediator.getModelClasses());
+
+        assertEquals(defaultMediator, defaultMediator);
+        assertEquals(defaultMediator.hashCode(), defaultMediator.hashCode());
+        assertEquals(defaultMediator, compositeMediator);
+        assertEquals(defaultMediator.hashCode(), compositeMediator.hashCode());
+        assertEquals(defaultMediator, filterableMediator);
+        assertEquals(defaultMediator.hashCode(), filterableMediator.hashCode());
+
+        assertEquals(compositeMediator, defaultMediator);
+        assertEquals(compositeMediator.hashCode(), defaultMediator.hashCode());
+        assertEquals(compositeMediator, compositeMediator);
+        assertEquals(compositeMediator.hashCode(), compositeMediator.hashCode());
+        assertEquals(compositeMediator, filterableMediator);
+        assertEquals(compositeMediator.hashCode(), filterableMediator.hashCode());
+
+        assertEquals(filterableMediator, defaultMediator);
+        assertEquals(filterableMediator.hashCode(), defaultMediator.hashCode());
+        assertEquals(filterableMediator, compositeMediator);
+        assertEquals(filterableMediator.hashCode(), compositeMediator.hashCode());
+        assertEquals(filterableMediator, filterableMediator);
+        assertEquals(filterableMediator.hashCode(), filterableMediator.hashCode());
+    }
+
+    public void testCompositeMediatorModelClassesCount() {
+        final CompositeMediator mediator = new CompositeMediator(
+                new HumanModuleMediator(),
+                new AnimalModuleMediator()
+        );
+
+        final int modelsInHumanModule = HumanModule.class.getAnnotation(RealmModule.class).classes().length;
+        final int modelsInAnimalModule = AnimalModule.class.getAnnotation(RealmModule.class).classes().length;
+
+        assertEquals(modelsInHumanModule + modelsInAnimalModule, mediator.getModelClasses().size());
+    }
+
+    public void testFilterableMediatorModelClassesCount() {
+        //noinspection unchecked
+        final FilterableMediator mediator = new FilterableMediator(new AnimalModuleMediator(), Arrays.asList(Cat.class, CatOwner.class));
+
+        assertTrue(mediator.getModelClasses().contains(Cat.class));
+        // CatOwner is not a member of AnimalModuleMediator
+        assertFalse(mediator.getModelClasses().contains(CatOwner.class));
+        assertFalse(mediator.getModelClasses().contains(Dog.class));
+        assertFalse(mediator.getModelClasses().contains(AllTypes.class));
+    }
+
+    public void testDefaultMediatorWasTransformed() {
+        final DefaultRealmModuleMediator defaultMediator = new DefaultRealmModuleMediator();
+        assertTrue(defaultMediator.transformerApplied());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
new file mode 100644
index 0000000000..422b8b85e4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -0,0 +1,1046 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Log;
+
+import junit.framework.AssertionFailedError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.ref.WeakReference;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.internal.log.Logger;
+import io.realm.internal.log.RealmLog;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class NotificationsTest {
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void failingSetAutoRefreshOnNonLooperThread() throws ExecutionException, InterruptedException {
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                Realm realm = Realm.getInstance(realmConfig);
+                boolean autoRefresh = realm.isAutoRefresh();
+                assertFalse(autoRefresh);
+                try {
+                    realm.setAutoRefresh(true);
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+
+        assertTrue(future.get());
+        RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
+    }
+
+    @Test
+    public void setAutoRefresh_onHandlerThread() throws ExecutionException, InterruptedException {
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(realmConfig);
+                assertTrue(realm.isAutoRefresh());
+                realm.setAutoRefresh(false);
+                assertFalse(realm.isAutoRefresh());
+                realm.setAutoRefresh(true);
+                assertTrue(realm.isAutoRefresh());
+                realm.close();
+                return true;
+            }
+        });
+
+        assertTrue(future.get());
+        RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
+    }
+
+    @Test
+    @UiThreadTest
+    public void removeChangeListener() throws InterruptedException, ExecutionException {
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+
+        realm = Realm.getInstance(realmConfig);
+        realm.addChangeListener(listener);
+        realm.removeChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertEquals(0, counter.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_duplicatedListener() {
+        final AtomicInteger counter = new AtomicInteger(0);
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(listener);
+        realm.addChangeListener(listener);
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(1, counter.get());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void notificationsNumber() throws InterruptedException, ExecutionException {
+        final AtomicInteger counter = new AtomicInteger(0);
+        final AtomicBoolean isReady = new AtomicBoolean(false);
+        final Looper[] looper = new Looper[1];
+        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                Realm realm = null;
+                try {
+                    Looper.prepare();
+                    looper[0] = Looper.myLooper();
+                    realm = Realm.getInstance(realmConfig);
+                    realm.addChangeListener(listener);
+                    isReady.set(true);
+                    Looper.loop();
+                } finally {
+                    if (realm != null) {
+                        realm.close();
+                        isRealmOpen.set(false);
+                    }
+                }
+                return true;
+            }
+        });
+
+        // Wait until the looper in the background thread is started
+        while (!isReady.get()) {
+            Thread.sleep(5);
+        }
+        Thread.sleep(100);
+
+        // Trigger OnRealmChanged on background thread
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName("Rex");
+        realm.commitTransaction();
+        realm.close();
+
+        try {
+            future.get(1, TimeUnit.SECONDS);
+        } catch (TimeoutException ignore) {
+        } finally {
+            looper[0].quit();
+        }
+
+        // Wait until the Looper thread is actually closed
+        while (isRealmOpen.get()) {
+            Thread.sleep(5);
+        }
+
+        assertEquals(1, counter.get());
+        RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
+    }
+
+    @Test
+    public void autoUpdateRealmResults() throws InterruptedException, ExecutionException {
+        final int TEST_SIZE = 10;
+        final AtomicInteger counter = new AtomicInteger(0);
+        final AtomicBoolean isReady = new AtomicBoolean(false);
+        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
+        final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
+        final Looper[] looper = new Looper[1];
+        final RealmChangeListener listener[] = new RealmChangeListener[1];
+
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+
+            @Override
+            public Boolean call() throws Exception {
+                Looper.prepare();
+                looper[0] = Looper.myLooper();
+                Realm realm = null;
+                try {
+                    realm = Realm.getInstance(realmConfig);
+                    final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                    assertEquals(0, dogs.size());
+                    listener[0] = new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            int c = counter.incrementAndGet();
+                            results.put(c, dogs.size());
+                        }
+                    };
+                    realm.addChangeListener(listener[0]);
+                    isReady.set(true);
+                    Looper.loop();
+                } finally {
+                    if (realm != null) {
+                        realm.close();
+                        isRealmOpen.set(false);
+                    }
+                }
+                return true;
+            }
+        });
+
+        // Wait until the looper is started
+        while (!isReady.get()) {
+            Thread.sleep(5);
+        }
+        Thread.sleep(100);
+
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setName("Rex " + i);
+        }
+        realm.commitTransaction();
+        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        realm.close();
+
+        try {
+            future.get(2, TimeUnit.SECONDS);
+        } catch (TimeoutException ignore) {
+        } finally {
+            looper[0].quit();
+        }
+
+        // Wait until the Looper thread is actually closed
+        while (isRealmOpen.get()) {
+            Thread.sleep(5);
+        }
+
+        assertEquals(1, results.size());
+
+        assertTrue(results.containsKey(1));
+        assertEquals(TEST_SIZE, results.get(1).intValue());
+
+        assertEquals(1, counter.get());
+        RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
+    }
+
+    @Test
+    public void closeClearingHandlerMessages() throws InterruptedException, TimeoutException, ExecutionException {
+        final int TEST_SIZE = 10;
+        final CountDownLatch backgroundLooperStarted = new CountDownLatch(1);
+        final CountDownLatch addHandlerMessages = new CountDownLatch(1);
+
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService
+                Realm realm = Realm.getInstance(realmConfig);
+                backgroundLooperStarted.countDown();
+
+                // Random operation in the client code
+                final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                if (dogs.size() != 0) {
+                    return false;
+                }
+                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages
+
+                // Find the current Handler for the thread now. All message and references will be
+                // cleared once we call close().
+                Handler threadHandler = realm.handler;
+                realm.close(); // Close native resources + associated handlers.
+
+                // Looper now reads the update message from the main thread if the Handler was not
+                // cleared. This will cause an IllegalStateException and should not happen.
+                // If it works correctly. The looper will just block on an empty message queue.
+                // This is normal behavior but is bad for testing, so we add a custom quit message
+                // at the end so we can evaluate results faster.
+                threadHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        TestHelper.quitLooperOrFail();
+                    }
+                });
+
+                try {
+                    Looper.loop();
+                } catch (IllegalStateException e) {
+                    return false;
+                }
+                return true;
+            }
+        });
+
+        // Wait until the looper is started on a background thread
+        backgroundLooperStarted.await(1, TimeUnit.SECONDS);
+
+        // Execute a transaction that will trigger a Realm update
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setName("Rex " + i);
+        }
+        realm.commitTransaction();
+        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        realm.close();
+        addHandlerMessages.countDown();
+
+        // Check that messages was properly cleared
+        // It looks like getting this future sometimes takes a while for some reason. Setting to
+        // 10s. now.
+        Boolean result = future.get(10, TimeUnit.SECONDS);
+        assertTrue(result);
+    }
+
+    @Test
+    @UiThreadTest
+    public void handlerNotRemovedToSoon() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("private-realm");
+        Realm.deleteRealm(realmConfig);
+        Realm instance1 = Realm.getInstance(realmConfig);
+        Realm instance2 = Realm.getInstance(realmConfig);
+        assertEquals(instance1.getPath(), instance2.getPath());
+        assertNotNull(instance1.handler);
+
+        // If multiple instances are open on the same thread, don't remove handler on that thread
+        // until last instance is closed.
+        instance2.close();
+        assertNotNull(instance1.handler);
+        instance1.close();
+        assertNull(instance1.handler);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void commitTransaction_delayChangeListenerOnSameThread() {
+        final AtomicInteger success = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(1, success.get());
+                looperThread.testComplete();
+            }
+        });
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        assertEquals(0, success.getAndIncrement());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void emptyCommitTriggerChangeListener() {
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                looperThread.testComplete();
+            }
+        };
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(listener);
+        realm.beginTransaction();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addRemoveListenerConcurrency() {
+        final Realm realm = looperThread.realm;
+        final AtomicInteger counter1 = new AtomicInteger(0);
+        final AtomicInteger counter2 = new AtomicInteger(0);
+        final AtomicInteger counter3 = new AtomicInteger(0);
+
+        // At least we need 2 listeners existing in the list to make sure
+        // the iterator.next get called
+
+        // This one will be added when listener2's onChange called
+        final RealmChangeListener listener1 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 7: Last listener called. Should only be called once
+                counter1.incrementAndGet();
+
+                // after listener2.onChange
+                // Since duplicated entries will be ignored, we still have:
+                // [listener2, listener1]
+                assertEquals(1, counter1.get());
+                assertEquals(2, counter2.get());
+                assertEquals(1, counter3.get());
+                looperThread.testComplete();
+            }
+        };
+
+        // This one will be existing in the list all the time
+        final RealmChangeListener listener2 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 3: Listener2 called
+                // Listener state [listener2, listener3, listener1]
+                // Listener 1 will not be called this time around
+                counter2.incrementAndGet();
+                realm.addChangeListener(listener1);
+            }
+        };
+
+        // This one will be removed after first transaction
+        RealmChangeListener listener3 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 4: Listener3 called
+                // Listener state [listener2, listener1]
+                counter3.incrementAndGet();
+                realm.removeChangeListener(this);
+
+                // Step 5: Assert proper state
+                // [listener2, listener1]
+                assertEquals(0, counter1.get());
+                assertEquals(1, counter2.get());
+                assertEquals(1, counter3.get());
+
+                // Step 6: Trigger next round of changes on [listener2, listener1]
+                realm.beginTransaction();
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+            }
+        };
+
+        // Step 1: Add initial listeners
+        // Listener state [listener2, listener3]
+        realm.addChangeListener(listener2);
+        realm.addChangeListener(listener3);
+
+        // Step 2: Trigger change listeners
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void weakReferenceListener() throws InterruptedException {
+        final AtomicInteger weakCounter = new AtomicInteger(0);
+        final AtomicInteger strongCounter = new AtomicInteger(0);
+
+        final Realm realm = looperThread.realm;
+
+        // Setup weak listener
+        RealmChangeListener weakListener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                weakCounter.incrementAndGet();
+            }
+        };
+        realm.handlerController.addChangeListenerAsWeakReference(weakListener);
+        assertEquals(1, realm.handlerController.weakChangeListeners.size());
+
+        // This is not a weak listener so will be called. When this is triggered the weak references have not been
+        // removed yet. So make another change to ensure that they really are removed before validating.
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                int count = strongCounter.incrementAndGet();
+                if (count == 1) {
+                    realm.beginTransaction();
+                    realm.createObject(AllTypes.class);
+                    realm.commitTransaction();
+                } else if (count == 2) {
+                    assertEquals(0, weakCounter.get());
+                    assertEquals(0, realm.handlerController.weakChangeListeners.size());
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        // Hack: There is no guaranteed way to release the WeakReference, just clear it.
+        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+            weakRef.clear();
+        }
+
+        // Trigger change listeners
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+
+    // Test that that a WeakReferenceListener can be removed.
+    // This test is not a proper GC test, but just ensures that listeners can be removed from the list of weak listeners
+    // without throwing an exception.
+    @Test
+    @RunTestInLooperThread
+    public void removingWeakReferenceListener() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        RealmChangeListener listenerA = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+        RealmChangeListener listenerB = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(0, counter.get());
+                assertEquals(1, realm.handlerController.weakChangeListeners.size());
+                looperThread.testComplete();
+            }
+        };
+        realm.handlerController.addChangeListenerAsWeakReference(listenerA);
+
+        // There is no guaranteed way to release the WeakReference,
+        // just clear it.
+        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+            weakRef.clear();
+        }
+
+        realm.handlerController.addChangeListenerAsWeakReference(listenerB);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmNotificationOrder() {
+        // Tests that global notifications are called in the order they are added
+        // Test both ways to check accidental ordering from unordered collections.
+        final AtomicInteger listenerACalled = new AtomicInteger(0);
+        final AtomicInteger listenerBCalled = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+
+        final RealmChangeListener listenerA = new RealmChangeListener() {
+
+            @Override
+            public void onChange() {
+                int called = listenerACalled.incrementAndGet();
+                if (called == 2) {
+                    assertEquals(2, listenerBCalled.get());
+                    looperThread.testComplete();
+                }
+            }
+        };
+        final RealmChangeListener listenerB = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenerBCalled.incrementAndGet();
+                if (listenerACalled.get() == 1) {
+                    // 2. Reverse order
+                    realm.removeAllChangeListeners();
+                    realm.addChangeListener(this);
+                    realm.addChangeListener(listenerA);
+                    realm.beginTransaction();
+                    realm.commitTransaction();
+
+                }
+            }
+        };
+
+        // 1. Add initial ordering
+        realm.addChangeListener(listenerA);
+        realm.addChangeListener(listenerB);
+
+        realm.beginTransaction();
+        realm.commitTransaction();
+    }
+
+    // Tests that if the same configuration is used on 2 different Looper threads that each gets its own Handler. This
+    // prevents commitTransaction from accidentally posting messages to Handlers which might reference a closed Realm.
+    @Test
+    public void doNotUseClosedHandler() throws InterruptedException {
+        final AssertionFailedError[] threadAssertionError = new AssertionFailedError[1]; // Keep track of errors in test threads.
+        final CountDownLatch handlerNotified = new CountDownLatch(1);
+        final CountDownLatch backgroundThreadClosed = new CountDownLatch(1);
+
+        // Create Handler on Thread1 by opening a Realm instance
+        new Thread("thread1") {
+
+            @Override
+            public void run() {
+                Looper.prepare();
+                final Realm realm = Realm.getInstance(realmConfig);
+                RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        realm.close();
+                        handlerNotified.countDown();
+                    }
+                };
+                realm.addChangeListener(listener);
+                Looper.loop();
+            }
+        }.start();
+
+        // Create Handler on Thread2 for the same Realm path and close the Realm instance again.
+        new Thread("thread2") {
+            @Override
+            public void run() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(realmConfig);
+                RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        try {
+                            fail("This handler should not be notified");
+                        } catch (AssertionFailedError e) {
+                            threadAssertionError[0] = e;
+                            handlerNotified.countDown(); // Make sure that that await() doesn't fail instead.
+                        }
+                    }
+                };
+                realm.addChangeListener(listener);
+                realm.close();
+                backgroundThreadClosed.countDown();
+                Looper.loop();
+            }
+
+        }.start();
+
+        // Any REALM_CHANGED message should now only reach the open Handler on Thread1
+        backgroundThreadClosed.await();
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        realm.commitTransaction();
+        try {
+            if (!handlerNotified.await(5, TimeUnit.SECONDS)) {
+                fail("Handler didn't receive message");
+            }
+        } finally {
+            realm.close();
+        }
+
+        if (threadAssertionError[0] != null) {
+            throw threadAssertionError[0];
+        }
+    }
+
+    // Test that we handle a Looper thread quiting it's looper before it is done executing the current loop ( = Realm.close()
+    // isn't called yet).
+    @Test
+    public void looperThreadQuitsLooperEarly() throws InterruptedException {
+        final CountDownLatch backgroundLooperStartedAndStopped = new CountDownLatch(1);
+        final CountDownLatch mainThreadCommitCompleted = new CountDownLatch(1);
+        final CountDownLatch backgroundThreadStopped = new CountDownLatch(1);
+
+        // Start background looper and let it hang
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService
+
+                Realm realm = Realm.getInstance(realmConfig);
+                realm.setAutoRefresh(false);
+                TestHelper.quitLooperOrFail();
+                backgroundLooperStartedAndStopped.countDown();
+                try {
+                    mainThreadCommitCompleted.await();
+                } catch (InterruptedException e) {
+                    fail("Thread interrupted"); // This will prevent backgroundThreadStopped from being called.
+                }
+                realm.close();
+                backgroundThreadStopped.countDown();
+            }
+        });
+
+        // Create a commit on another thread
+        TestHelper.awaitOrFail(backgroundLooperStartedAndStopped);
+        Realm realm = Realm.getInstance(realmConfig);
+        Logger logger = TestHelper.getFailureLogger(Log.WARN);
+        RealmLog.add(logger);
+
+        realm.beginTransaction();
+        realm.commitTransaction(); // If the Handler on the background is notified it will trigger a Log warning.
+        mainThreadCommitCompleted.countDown();
+        TestHelper.awaitOrFail(backgroundThreadStopped);
+
+        realm.close();
+        RealmLog.remove(logger);
+    }
+
+    @Test
+    public void handlerThreadShouldReceiveNotification() throws ExecutionException, InterruptedException {
+        final AssertionFailedError[] assertionFailedErrors = new AssertionFailedError[1];
+        final CountDownLatch backgroundThreadReady = new CountDownLatch(1);
+        final CountDownLatch numberOfInvocation = new CountDownLatch(1);
+
+        HandlerThread handlerThread = new HandlerThread("handlerThread");
+        handlerThread.start();
+        Handler handler = new Handler(handlerThread.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    assertEquals("handlerThread", Thread.currentThread().getName());
+                } catch (AssertionFailedError e) {
+                    assertionFailedErrors[0] = e;
+                }
+                final Realm backgroundRealm = Realm.getInstance(realmConfig);
+                backgroundRealm.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        backgroundRealm.close();
+                        numberOfInvocation.countDown();
+                    }
+                });
+                backgroundThreadReady.countDown();
+            }
+        });
+        TestHelper.awaitOrFail(backgroundThreadReady);
+        // At this point the background thread started & registered the listener
+
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        TestHelper.awaitOrFail(numberOfInvocation);
+        realm.close();
+        handlerThread.quit();
+        if (assertionFailedErrors[0] != null) {
+            throw assertionFailedErrors[0];
+        }
+    }
+
+    @Test
+    public void nonLooperThreadShouldNotifyLooperThreadAboutCommit() {
+        final CountDownLatch mainThreadReady = new CountDownLatch(1);
+        final CountDownLatch backgroundThreadClosed = new CountDownLatch(1);
+        final CountDownLatch numberOfInvocation = new CountDownLatch(1);
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                TestHelper.awaitOrFail(mainThreadReady);
+                Realm realm = Realm.getInstance(realmConfig);
+                realm.beginTransaction();
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+                realm.close();
+                backgroundThreadClosed.countDown();
+            }
+        };
+        thread.start();
+
+        HandlerThread mainThread = new HandlerThread("mainThread");
+        mainThread.start();
+        Handler handler = new Handler(mainThread.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                final Realm mainRealm = Realm.getInstance(realmConfig);
+                mainRealm.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        mainRealm.close();
+                        numberOfInvocation.countDown();
+                    }
+                });
+                mainThreadReady.countDown();
+            }
+        });
+
+        TestHelper.awaitOrFail(numberOfInvocation);
+        TestHelper.awaitOrFail(backgroundThreadClosed);
+        mainThread.quit();
+    }
+
+    // The presence of async RealmResults block any `REALM_CHANGE` notification causing historically the Realm
+    // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
+    // regardless of the presence of an async RealmResults that will delay the `REALM_CHANGE` sometimes
+    @Test
+    public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() throws Throwable {
+        final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
+        final AtomicInteger numberOfAsyncRealmResultsCallbackInvocation = new AtomicInteger(0);
+        final CountDownLatch signalTestFinished = new CountDownLatch(2);
+        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+        final Realm[] realm = new Realm[1];
+        final Throwable[] threadAssertionError = new Throwable[1];
+        final Looper[] backgroundLooper = new Looper[1];
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                backgroundLooper[0] = Looper.myLooper();
+
+                try {
+                    realm[0] = Realm.getInstance(realmConfig);
+                    realm[0].addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            RealmResults<Dog> dogs; // to keep it as a strong reference
+                            switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
+                                case 1: {
+                                    // first commit
+                                    dogs = realm[0].where(Dog.class).findAllAsync();
+                                    assertTrue(dogs.load());
+                                    dogs.addChangeListener(new RealmChangeListener() {
+                                        @Override
+                                        public void onChange() {
+                                            numberOfAsyncRealmResultsCallbackInvocation.incrementAndGet();
+                                        }
+                                    });
+
+                                    new Thread() {
+                                        @Override
+                                        public void run() {
+                                            Realm realm = Realm.getInstance(realmConfig);
+                                            realm.beginTransaction();
+                                            realm.createObject(Dog.class);
+                                            realm.commitTransaction();
+                                            realm.close();
+                                            signalTestFinished.countDown();
+                                        }
+                                    }.start();
+                                    break;
+                                }
+                                case 2: {
+                                    // finish test
+                                    signalTestFinished.countDown();
+                                    break;
+                                }
+                            }
+                        }
+                    });
+
+                    realm[0].handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            realm[0].beginTransaction();
+                            realm[0].createObject(Dog.class);
+                            realm[0].commitTransaction();
+                        }
+                    });
+
+                    Looper.loop();
+
+                } catch (Throwable e) {
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (realm.length > 0 && realm[0] != null) {
+                        realm[0].close();
+                    }
+                    signalClosedRealm.countDown();
+
+                    if (signalTestFinished.getCount() > 0) {
+                        signalTestFinished.countDown();
+                    }
+                }
+            }
+        });
+
+        TestHelper.exitOrThrow(executorService, signalTestFinished, signalClosedRealm, backgroundLooper, threadAssertionError);
+    }
+
+    // The presence of async RealmResults block any `REALM_CHANGE` notification causing historically the Realm
+    // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
+    // regardless of the presence of an async RealmObject that will delay the `REALM_CHANGE` sometimes
+    @Test
+    @RunTestInLooperThread
+    public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
+        final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
+        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+        looperThread.realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
+                    case 1: {
+                        // first commit
+                        Dog dog = looperThread.realm.where(Dog.class).findFirstAsync();
+                        assertTrue(dog.load());
+                        dog.addChangeListener(new RealmChangeListener() {
+                            @Override
+                            public void onChange() {
+                            }
+                        });
+                        looperThread.keepStrongReference.add(dog);
+
+                        new Thread() {
+                            @Override
+                            public void run() {
+                                Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+                                realm.beginTransaction();
+                                realm.createObject(Dog.class);
+                                realm.commitTransaction();
+                                realm.close();
+                                signalClosedRealm.countDown();
+                            }
+                        }.start();
+                        break;
+                    }
+                    case 2: {
+                        // finish test
+                        TestHelper.awaitOrFail(signalClosedRealm);
+                        looperThread.testComplete();
+                        break;
+                    }
+                }
+            }
+        });
+
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                looperThread.realm.beginTransaction();
+                looperThread.realm.createObject(Dog.class);
+                looperThread.realm.commitTransaction();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmListenerAddedAfterCommit() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        realm.commitTransaction();
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmResultsListenerAddedAfterCommit() {
+        Realm realm = looperThread.realm;
+        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        results.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmObjectListenerAddedAfterCommit() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        obj.setColumnLong(42);
+        realm.commitTransaction();
+
+        obj.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                looperThread.testComplete();
+            }
+        });
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
similarity index 69%
rename from realm/src/androidTest/java/io/realm/RealmAdapterTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
index 75020fa36e..140eb49e29 100644
--- a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAdapterTest.java
@@ -13,18 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.realm;
 
-import android.test.AndroidTestCase;
-import android.util.Log;
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
 import android.view.View;
 import android.widget.TextView;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
 import io.realm.entities.AllTypes;
 import io.realm.entities.RealmAdapter;
-import io.realm.exceptions.RealmException;
 
-public class RealmAdapterTest extends AndroidTestCase {
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmAdapterTest {
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    private Context context;
 
     private final static String FIELD_STRING = "columnString";
     private final static int TEST_DATA_SIZE = 47;
@@ -32,10 +49,15 @@
     private boolean automaticUpdate = true;
     private Realm testRealm;
 
-    protected void setUp() throws Exception {
-        super.setUp();
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+    @Before
+    public void setUp() throws Exception {
+        // Injecting the Instrumentation instance is required
+        // for your test to run with AndroidJUnitRunner.
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(context);
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
@@ -45,12 +67,12 @@ protected void setUp() throws Exception {
         testRealm.commitTransaction();
     }
 
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
+    @After
+    public void tearDown() throws Exception {
         testRealm.close();
     }
 
+    @Test
     public void testAdapterParameterExceptions() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
         try {
@@ -60,10 +82,11 @@ public void testAdapterParameterExceptions() {
         }
     }
 
+    @Test
     public void testUpdateRealmResultInAdapter() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
         resultList.sort(FIELD_STRING);
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, false);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, false);
         assertEquals(resultList.first().getColumnString(), realmAdapter.getRealmResults().first().getColumnString());
         assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
 
@@ -79,9 +102,11 @@ public void testUpdateRealmResultInAdapter() {
         assertEquals(emptyResultList.size(), realmAdapter.getRealmResults().size());
     }
 
+    @Test
+    @UiThreadTest
     public void testClearFromAdapter() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
 
         testRealm.beginTransaction();
         realmAdapter.getRealmResults().clear();
@@ -91,9 +116,11 @@ public void testClearFromAdapter() {
         assertEquals(0, resultList.size());
     }
 
+    @Test
+    @UiThreadTest
     public void testRemoveFromAdapter() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
 
         testRealm.beginTransaction();
         realmAdapter.getRealmResults().remove(0);
@@ -104,53 +131,65 @@ public void testRemoveFromAdapter() {
         assertEquals(0, resultList.size());
     }
 
+    @Test
+    @UiThreadTest
     public void testSortWithAdapter() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        resultList.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        resultList.sort(FIELD_STRING, Sort.DESCENDING);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         assertEquals(resultList.first().getColumnString(), realmAdapter.getRealmResults().first().getColumnString());
         assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
 
         resultList.sort(FIELD_STRING);
 
         assertEquals(resultList.last().getColumnString(), realmAdapter.getRealmResults().last().getColumnString());
-        assertEquals(resultList.get(TEST_DATA_SIZE/2).getColumnString(), realmAdapter.getRealmResults().get(TEST_DATA_SIZE/2).getColumnString());
+        assertEquals(resultList.get(TEST_DATA_SIZE / 2).getColumnString(), realmAdapter.getRealmResults().get(TEST_DATA_SIZE / 2).getColumnString());
         assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
     }
 
+    @Test
+    @UiThreadTest
     public void testEmptyRealmResult() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "Not there").findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         assertEquals(0, realmAdapter.getRealmResults().size());
         assertEquals(0, realmAdapter.getCount());
     }
 
+    @Test
+    @UiThreadTest
     public void testGetItem() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
 
         assertEquals(resultList.get(0).getColumnString(), realmAdapter.getItem(0).getColumnString());
         assertEquals(resultList.size(), realmAdapter.getRealmResults().size());
         assertEquals(resultList.last().getColumnString(), realmAdapter.getRealmResults().last().getColumnString());
     }
 
+    @Test
+    @UiThreadTest
     public void testGetItemId() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         for (int i = 0; i < resultList.size(); i++) {
             assertEquals(i, realmAdapter.getItemId(i));
         }
     }
 
+    @Test
+    @UiThreadTest
     public void testGetCount() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         assertEquals(TEST_DATA_SIZE, realmAdapter.getCount());
     }
 
+    @Test
+    @UiThreadTest
     public void testGetView() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         View view = realmAdapter.getView(0, null, null);
 
         TextView name = (TextView) view.findViewById(android.R.id.text1);
@@ -160,23 +199,28 @@ public void testGetView() {
         assertEquals(resultList.get(0).getColumnString(), name.getText());
     }
 
+    @Test
     public void testNullResults() {
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), null, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, null, automaticUpdate);
 
         assertEquals(0, realmAdapter.getCount());
     }
 
+    @Test
+    @UiThreadTest
     public void testNonNullToNullResults() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, resultList, automaticUpdate);
         realmAdapter.updateRealmResults(null);
 
         assertEquals(0, realmAdapter.getCount());
     }
 
+    @Test
+    @UiThreadTest
     public void testNullToNonNullResults() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmAdapter realmAdapter = new RealmAdapter(getContext(), null, automaticUpdate);
+        RealmAdapter realmAdapter = new RealmAdapter(context, null, automaticUpdate);
         realmAdapter.updateRealmResults(resultList);
 
         assertEquals(TEST_DATA_SIZE, realmAdapter.getCount());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
new file mode 100644
index 0000000000..a76ebf06b7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.AnnotationNameConventions;
+import io.realm.entities.AnnotationTypes;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.Table;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmAnnotationTests {
+    private Realm realm;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        AnnotationTypes object = realm.createObject(AnnotationTypes.class);
+        object.setNotIndexString("String 1");
+        object.setIndexString("String 2");
+        object.setIgnoreString("String 3");
+        realm.commitTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void ignore() {
+        Table table = realm.getTable(AnnotationTypes.class);
+        assertEquals(-1, table.getColumnIndex("ignoreString"));
+    }
+
+    // Test if "index" annotation works with supported types
+    @Test
+    public void index() {
+        Table table = realm.getTable(AnnotationIndexTypes.class);
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexString")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexInt")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexInt")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexByte")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexByte")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexShort")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexShort")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexLong")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexLong")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexBoolean")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexBoolean")));
+
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexDate")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexDate")));
+    }
+
+    // Test migrating primary key from string to long with existing data
+    @Test
+    public void primaryKey_migration_long() {
+        realm.beginTransaction();
+        for (int i = 1; i <= 2; i++) {
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            obj.setId(i);
+            obj.setName("String" + i);
+        }
+
+        Table table = realm.getTable(PrimaryKeyAsString.class);
+        table.setPrimaryKey("id");
+        assertEquals(1, table.getPrimaryKey());
+        realm.cancelTransaction();
+    }
+
+    // Test migrating primary key from string to long with existing data
+    @Test
+    public void primaryKey_migration_longDuplicateValues() {
+        realm.beginTransaction();
+        for (int i = 1; i <= 2; i++) {
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            obj.setId(1); // Create duplicate values
+            obj.setName("String" + i);
+        }
+
+        Table table = realm.getTable(PrimaryKeyAsString.class);
+        try {
+            table.setPrimaryKey("id");
+            fail("It should not be possible to set a primary key column which already contains duplicate values.");
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(0, table.getPrimaryKey());
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    // Test migrating primary key from long to str with existing data
+    @Test
+    public void primaryKey_migration_string() {
+        realm.beginTransaction();
+        for (int i = 1; i <= 2; i++) {
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
+            obj.setId(i);
+            obj.setName("String" + i);
+        }
+
+        Table table = realm.getTable(PrimaryKeyAsLong.class);
+        table.setPrimaryKey("name");
+        assertEquals(1, table.getPrimaryKey());
+        realm.cancelTransaction();
+    }
+
+    // Test migrating primary key from long to str with existing data
+    @Test
+    public void primaryKey_migration_stringDuplicateValues() {
+        realm.beginTransaction();
+        for (int i = 1; i <= 2; i++) {
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
+            obj.setId(i);
+            obj.setName("String"); // Create duplicate values
+        }
+
+        Table table = realm.getTable(PrimaryKeyAsLong.class);
+        try {
+            table.setPrimaryKey("name");
+            fail("It should not be possible to set a primary key column which already contains duplicate values.");
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(0, table.getPrimaryKey());
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void primaryKey_checkPrimaryKeyOnCreate() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(AnnotationTypes.class);
+            fail("Two empty objects cannot be created on the same table if a primary key is defined");
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    // It should be allowed to override the primary key value with the same value
+    @Test
+    public void primaryKey_defaultStringValue() {
+        realm.beginTransaction();
+        PrimaryKeyAsString str = realm.createObject(PrimaryKeyAsString.class);
+        str.setName("");
+        realm.commitTransaction();
+    }
+
+    // It should be allowed to override the primary key value with the same value
+    @Test
+    public void primaryKey_defaultLongValue() {
+        realm.beginTransaction();
+        PrimaryKeyAsLong str = realm.createObject(PrimaryKeyAsLong.class);
+        str.setId(0);
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void primaryKey_errorOnInsertingSameObject() {
+        try {
+            realm.beginTransaction();
+            AnnotationTypes obj1 = realm.createObject(AnnotationTypes.class);
+            obj1.setId(1);
+            AnnotationTypes obj2 = realm.createObject(AnnotationTypes.class);
+            obj2.setId(1);
+            fail("Inserting two objects with same primary key should fail");
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void primaryKey_isIndexed() {
+        Table table = realm.getTable(PrimaryKeyAsString.class);
+        assertTrue(table.hasPrimaryKey());
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("name")));
+
+        table = realm.getTable(PrimaryKeyAsLong.class);
+        assertTrue(table.hasPrimaryKey());
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
+    }
+
+    // Annotation processor honors common naming conventions
+    // We check if setters and getters are generated and working
+    @Test
+    public void namingConvention() {
+        realm.beginTransaction();
+        realm.clear(AnnotationNameConventions.class);
+        AnnotationNameConventions anc1 = realm.createObject(AnnotationNameConventions.class);
+        anc1.setHasObject(true);
+        anc1.setId_object(1);
+        anc1.setmObject(2);
+        anc1.setObject_id(3);
+        anc1.setObject(true);
+        realm.commitTransaction();
+
+        AnnotationNameConventions anc2 = realm.allObjects(AnnotationNameConventions.class).first();
+        assertTrue(anc2.isHasObject());
+        assertEquals(1, anc2.getId_object());
+        assertEquals(2, anc2.getmObject());
+        assertEquals(3, anc2.getObject_id());
+        assertTrue(anc2.isObject());
+        realm.close();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
new file mode 100644
index 0000000000..f6c1790534
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -0,0 +1,1856 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.ref.WeakReference;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.Owner;
+import io.realm.instrumentation.MockActivityManager;
+import io.realm.internal.log.RealmLog;
+import io.realm.proxy.HandlerProxy;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.RealmBackgroundTask;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmAsyncQueryTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    // ****************************
+    // ****  Async transaction  ***
+    // ****************************
+
+    // start asynchronously a transaction to insert one element
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync() throws Throwable {
+        final Realm realm = looperThread.realm;
+        assertEquals(0, realm.allObjects(Owner.class).size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
+                looperThread.testComplete();
+            }
+        }, new Realm.Transaction.OnError() {
+
+            @Override
+            public void onError(Throwable error) {
+                fail(error.getMessage());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_onSuccess() throws Throwable {
+        final Realm realm = looperThread.realm;
+        assertEquals(0, realm.allObjects(Owner.class).size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_onError() throws Throwable {
+        final Realm realm = looperThread.realm;
+        assertEquals(0, realm.allObjects(Owner.class).size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                throw new RuntimeException("Oh! What a Terrible Failure");
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                assertEquals(0, realm.allObjects(Owner.class).size());
+                assertNull(realm.where(Owner.class).findFirst());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_NoCallbacks() throws Throwable {
+        final Realm realm = looperThread.realm;
+        assertEquals(0, realm.allObjects(Owner.class).size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+            }
+        });
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Test that an async transaction that throws an exception propagate it properly to the user.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_exceptionHandling() throws Throwable {
+        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        RealmLog.add(testLogger);
+
+        final Realm realm = looperThread.realm;
+
+        assertEquals(0, realm.allObjects(Owner.class).size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+                realm.cancelTransaction(); // Cancel the transaction then throw
+                throw new RuntimeException("Boom");
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                fail("Should not reach success if runtime exception is thrown in callback.");
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                // Ensure we are giving developers quality messages in the logs.
+                assertEquals("Could not cancel transaction, not currently in a transaction.", testLogger.message);
+                RealmLog.remove(testLogger);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Test if the background Realm is closed when transaction success returned.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_realmClosedOnSuccess() {
+        final AtomicInteger counter = new AtomicInteger(100);
+        final Realm realm = looperThread.realm;
+        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                assertEquals(1, count);
+                if (counter.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+        final Realm.Transaction.OnSuccess transactionCallback = new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);
+                if (counter.get() == 0) {
+                    // Finish testing
+                    return;
+                }
+                realm.executeTransactionAsync(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                    }
+                }, this);
+            }
+        };
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+            }
+        }, transactionCallback);
+    }
+
+    // Test if the background Realm is closed when transaction error returned.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransaction_async_realmClosedOnError() {
+        final AtomicInteger counter = new AtomicInteger(100);
+        final Realm realm = looperThread.realm;
+        final RealmCache.Callback cacheCallback = new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                assertEquals(1, count);
+                if (counter.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+        final Realm.Transaction.OnError transactionCallback = new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                RealmCache.invokeWithGlobalRefCount(realm.getConfiguration(), cacheCallback);
+                if (counter.get() == 0) {
+                    // Finish testing
+                    return;
+                }
+                realm.executeTransactionAsync(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        throw new RuntimeException("Dummy exception");
+                    }
+                }, this);
+            }
+        };
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                throw new RuntimeException("Dummy exception");
+            }
+        }, transactionCallback);
+    }
+
+    // ************************************
+    // *** promises based async queries ***
+    // ************************************
+
+    // finding element [0-4] asynchronously then wait for the promise to be loaded.
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync() throws Throwable {
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllAsync();
+
+        assertFalse(results.isLoaded());
+        assertEquals(0, results.size());
+
+        results.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(results.isLoaded());
+                assertEquals(5, results.size());
+                assertTrue(results.get(0).isValid());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void accessingRealmListOnUnloadedRealmObjectShouldThrow() {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final AllTypes results = realm.where(AllTypes.class)
+                .equalTo("columnLong", 0)
+                .findFirstAsync();
+
+        assertFalse(results.isLoaded());
+        try {
+            results.getColumnRealmList();
+            fail("Accessing property on an empty row");
+        } catch (IllegalStateException ignored) {
+        }
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void standaloneObjectAsyncBehaviour() {
+        Dog dog = new Dog();
+        dog.setName("Akamaru");
+        dog.setAge(10);
+
+        assertTrue(dog.isLoaded());
+        assertFalse(dog.isValid());
+    }
+
+    @Test
+    public void findAllAsync_throwsOnNonLooperThread() throws Throwable {
+        Realm realm = Realm.getInstance(configFactory.createConfiguration());
+        try {
+            realm.where(AllTypes.class).findAllAsync();
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_reusingQuery() throws Throwable {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4);
+        RealmResults<AllTypes> queryAllSync = query.findAll();
+        RealmResults<AllTypes> allAsync = query.findAllAsync();
+
+        assertTrue(allAsync.load());
+        assertEquals(allAsync, queryAllSync);
+
+        // the RealmQuery already has an argumentHolder, can't reuse it
+        try {
+            query.findAllSorted("columnLong");
+            fail("Should throw an exception, can not reuse RealmQuery");
+        } catch (IllegalStateException ignored) {
+            looperThread.testComplete();
+        }
+    }
+
+    // finding elements [0-4] asynchronously then wait for the promise to be loaded
+    // using a callback to be notified when the data is loaded
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_withNotification() throws Throwable {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllAsync();
+
+        results.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(results.isLoaded());
+                assertEquals(5, results.size());
+                assertTrue(results.get(4).isValid());
+                looperThread.testComplete();
+            }
+        });
+
+        assertFalse(results.isLoaded());
+        assertEquals(0, results.size());
+    }
+
+    // transforming an async query into sync by calling load to force
+    // the blocking behaviour
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_forceLoad() throws Throwable {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllAsync();
+
+        // notification should be called as well
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(realmResults.isLoaded());
+                assertEquals(5, realmResults.size());
+                looperThread.testComplete();
+
+            }
+        });
+
+        assertFalse(realmResults.isLoaded());
+        assertEquals(0, realmResults.size());
+
+        boolean successful = realmResults.load();
+
+        assertTrue(successful);
+        assertTrue(realmResults.isLoaded());
+        assertEquals(5, realmResults.size());
+    }
+
+    // UC:
+    //   1- insert 10 objects
+    //   2- start an async query to find object [0-4]
+    //   3- assert current RealmResults is empty (Worker Thread didn't complete)
+    //   4- when the worker thread complete, advance the Realm
+    //   5- the caller thread is ahead of the result provided by the worker thread
+    //   6- retry automatically the async query
+    //   7- the returned RealmResults is now in the same version as the caller thread
+    //   8- the notification should be called once (when we retry automatically we shouldn't
+    //      notify the user).
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_retry() throws Throwable {
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        final AtomicInteger numberOfInvocation = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+
+        // 1. Populate initial data
+        realm.setAutoRefresh(false);
+        populateTestRealm(realm, 10);
+        realm.setAutoRefresh(true);
+
+        // 2. Configure handler interceptor
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                // Intercepts in order: [QueryComplete, RealmChanged, QueryUpdated]
+                int intercepts = numberOfIntercept.incrementAndGet();
+                switch (what) {
+                    // 5. Intercept all messages from other threads. On the first complete, we advance the tread
+                    // which will cause the async query to rerun instead of triggering the change listener.
+                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS:
+                        if (intercepts == 1) {
+                            // We advance the Realm so we can simulate a retry
+                            realm.beginTransaction();
+                            realm.clear(AllTypes.class);
+                            realm.commitTransaction();
+                        }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // 3. Create a async query
+        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllAsync();
+
+        // 4. Ensure that query isn't loaded yet
+        assertFalse(realmResults.isLoaded());
+        assertEquals(0, realmResults.size());
+
+        // 6. Callback triggered after retry has completed
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(3, numberOfIntercept.get());
+                assertEquals(1, numberOfInvocation.incrementAndGet());
+                assertTrue(realmResults.isLoaded());
+                assertEquals(0, realmResults.size());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // UC:
+    //   1- insert 10 objects
+    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
+    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
+    //   4- the queries will complete with the same version as the caller thread
+    //   5- using a background thread update the Realm
+    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
+    //   7- callbacks are notified with the latest results (called twice overall)
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_batchUpdate() throws Throwable {
+        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
+        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        // 1. Configure Handler interceptor
+        Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                int intercepts = numberOfIntercept.getAndIncrement();
+                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                    // 4. The first time the async queries complete we start an update from
+                    // another background thread. This will cause queries to rerun when the
+                    // background thread notifies this thread.
+                    new RealmBackgroundTask(looperThread.realmConfiguration) {
+                        @Override
+                        public void doInBackground(Realm realm) {
+                            realm.beginTransaction();
+                            realm.where(AllTypes.class)
+                                    .equalTo(AllTypes.FIELD_LONG, 4)
+                                    .findFirst()
+                                    .setColumnString("modified");
+                            realm.createObject(AllTypes.class);
+                            realm.createObject(AllTypes.class);
+                            realm.commitTransaction();
+                        }
+                    }.awaitOrFail();
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // 2. Create 2 async queries and check they are not loaded
+        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class).between("columnLong", 0, 4).findAllAsync();
+
+        assertFalse(realmResults1.isLoaded());
+        assertFalse(realmResults2.isLoaded());
+        assertEquals(0, realmResults1.size());
+        assertEquals(0, realmResults2.size());
+
+        // 3. Change listeners will be called twice. Once when the first query completely and then
+        // when the background thread has completed, notifying this thread to rerun and then receive
+        // the updated results.
+        final Runnable signalCallbackDone = new Runnable() {
+            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    assertEquals(4, numberOfIntercept.get());
+                    assertEquals(2, numberOfNotificationsQuery1.get());
+                    assertEquals(2, numberOfNotificationsQuery2.get());
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        realmResults1.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery1.incrementAndGet()) {
+                    case 1: // first callback invocation
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(10, realmResults1.size());
+                        assertEquals("test data 4", realmResults1.get(4).getColumnString());
+                        break;
+
+                    case 2: // second callback
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(12, realmResults1.size());
+                        assertEquals("modified", realmResults1.get(4).getColumnString());
+                        signalCallbackDone.run();
+                        break;
+                }
+            }
+        });
+
+
+        realmResults2.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery2.incrementAndGet()) {
+                    case 1: // first callback invocation
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(5, realmResults2.size());
+                        assertEquals("test data 4", realmResults2.get(4).getColumnString());
+                        break;
+
+                    case 2: // second callback
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(7, realmResults2.size());
+                        assertEquals("modified", realmResults2.get(4).getColumnString());
+                        signalCallbackDone.run();
+                        break;
+                }
+            }
+        });
+    }
+
+    // simulate a use case, when the caller thread advance read, while the background thread
+    // is operating on a previous version, this should retry the query on the worker thread
+    // to deliver the results once (using the latest version of the Realm)
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_callerIsAdvanced() throws Throwable {
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        // Configure handler interceptor
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated]
+                int intercepts = numberOfIntercept.incrementAndGet();
+                switch (what) {
+                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                        // we advance the Realm so we can simulate a retry
+                        if (intercepts == 1) {
+                            realm.beginTransaction();
+                            realm.createObject(AllTypes.class).setColumnLong(0);
+                            realm.commitTransaction();
+                        }
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // Create async query and verify it has not been loaded.
+        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllAsync();
+
+        assertFalse(realmResults.isLoaded());
+        assertEquals(0, realmResults.size());
+
+        // Add change listener that should only be called once
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(3, numberOfIntercept.get());
+                assertTrue(realmResults.isLoaded());
+                assertEquals(6, realmResults.size());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // UC:
+    //   1- insert 10 objects
+    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
+    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
+    //   4- start a third thread to insert 2 more elements
+    //   5- the third thread signal a REALM_CHANGE that should update all async queries
+    //   6- when the results from step [2] completes they should be ignored, since a pending
+    //      update (using the latest realm) for all async queries is in progress
+    //   7- onChange notification will be triggered once
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_callerThreadBehind() throws Throwable {
+        final AtomicInteger numberOfCompletedAsyncQuery = new AtomicInteger(0);
+        final AtomicInteger numberOfInterceptedChangeMessage = new AtomicInteger(0);
+        final AtomicInteger maxNumberOfNotificationsQuery1 = new AtomicInteger(1);
+        final AtomicInteger maxNumberOfNotificationsQuery2 = new AtomicInteger(1);
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        // Configure Handler Interceptor
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        // should only intercept the first REALM_CHANGED coming from the
+                        // background update thread
+
+                        // swallow this message, so the caller thread
+                        // remain behind the worker thread. This has as
+                        // a consequence to ignore the delivered result & wait for the
+                        // upcoming REALM_CHANGED to batch update all async queries
+                        return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
+                    }
+                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                        if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
+                            // both queries have completed now (& their results should be ignored)
+                            // now send the REALM_CHANGED event that should batch update all queries
+                            sendEmptyMessage(HandlerController.REALM_CHANGED);
+                        }
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+        Realm.asyncQueryExecutor.pause();
+
+        // Create async queries and check they haven't completed
+        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
+                .findAllAsync();
+        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4).findAllAsync();
+
+        assertFalse(realmResults1.isLoaded());
+        assertFalse(realmResults2.isLoaded());
+        assertEquals(0, realmResults1.size());
+        assertEquals(0, realmResults2.size());
+
+        // advance the Realm from a background thread
+        new RealmBackgroundTask(looperThread.realmConfiguration) {
+            @Override
+            public void doInBackground(Realm realm) {
+                realm.beginTransaction();
+                realm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
+                realm.createObject(AllTypes.class);
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+            }
+        }.awaitOrFail();
+        Realm.asyncQueryExecutor.resume();
+
+        // Setup change listeners
+        final Runnable signalCallbackDone = new Runnable() {
+            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    assertEquals(0, maxNumberOfNotificationsQuery1.get());
+                    assertEquals(0, maxNumberOfNotificationsQuery2.get());
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        realmResults1.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
+                assertTrue(realmResults1.isLoaded());
+                assertEquals(12, realmResults1.size());
+                assertEquals("modified", realmResults1.get(4).getColumnString());
+                signalCallbackDone.run();
+            }
+        });
+
+        realmResults2.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
+                assertTrue(realmResults2.isLoaded());
+                assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
+                assertEquals("modified", realmResults2.get(4).getColumnString());
+                signalCallbackDone.run();
+            }
+        });
+    }
+
+    // **********************************
+    // *** 'findFirst' async queries  ***
+    // **********************************
+
+    // similar UC as #testFindAllAsync using 'findFirst'
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync() {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
+        assertFalse(asyncObj.isValid());
+        assertFalse(asyncObj.isLoaded());
+
+        asyncObj.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(asyncObj.isLoaded());
+                assertTrue(asyncObj.isValid());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_initalEmptyRow() throws Throwable {
+        Realm realm = looperThread.realm;
+        final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
+        firstAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(firstAsync.load());
+                assertTrue(firstAsync.isLoaded());
+                assertTrue(firstAsync.isValid());
+                assertEquals(0, firstAsync.getColumnLong());
+                looperThread.testComplete();
+            }
+        });
+        assertTrue(firstAsync.load());
+        assertTrue(firstAsync.isLoaded());
+        assertFalse(firstAsync.isValid());
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class).setColumnLong(0);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_updatedIfsyncRealmObjectIsUpdated() throws Throwable {
+        populateTestRealm(looperThread.realm, 1);
+        AllTypes firstSync = looperThread.realm.where(AllTypes.class).findFirst();
+        assertEquals(0, firstSync.getColumnLong());
+        assertEquals("test data 0", firstSync.getColumnString());
+
+        final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
+        assertTrue(firstAsync.load());
+        assertTrue(firstAsync.isLoaded());
+        assertTrue(firstAsync.isValid());
+        assertEquals(0, firstAsync.getColumnLong());
+        assertEquals("test data 0", firstAsync.getColumnString());
+
+        firstAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Galacticon", firstAsync.getColumnString());
+                looperThread.testComplete();
+            }
+        });
+
+        looperThread.realm.beginTransaction();
+        firstSync.setColumnString("Galacticon");
+        looperThread.realm.commitTransaction();
+    }
+
+    // finding elements [0-4] asynchronously then wait for the promise to be loaded
+    // using a callback to be notified when the data is loaded
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_withNotification() throws Throwable {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+        final AllTypes realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 4, 9)
+                .findFirstAsync();
+
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(realmResults.isLoaded());
+                assertTrue(realmResults.isValid());
+                assertEquals("test data 4", realmResults.getColumnString());
+                looperThread.testComplete();
+            }
+        });
+
+        assertFalse(realmResults.isLoaded());
+        assertFalse(realmResults.isValid());
+        try {
+            realmResults.setColumnString("should fail");
+            fail("Accessing an unloaded object should throw");
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    // similar UC as #testForceLoadAsync using 'findFirst'
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_forceLoad() throws Throwable {
+        Realm Realm = looperThread.realm;
+        populateTestRealm(Realm, 10);
+        final AllTypes realmResults = Realm.where(AllTypes.class)
+                .between("columnLong", 4, 9)
+                .findFirstAsync();
+
+        assertFalse(realmResults.isLoaded());
+
+        assertTrue(realmResults.load());
+        assertTrue(realmResults.isLoaded());
+        assertEquals("test data 4", realmResults.getColumnString());
+
+        looperThread.testComplete();
+    }
+
+    // similar UC as #testFindAllAsyncRetry using 'findFirst'
+    // UC:
+    //   1- insert 10 objects
+    //   2- start an async query to find object [0-4]
+    //   3- assert current RealmResults is empty (Worker Thread didn't complete)
+    //   4- when the worker thread complete, advance the Realm
+    //   5- the caller thread is ahead of the result provided by the worker thread
+    //   6- retry automatically the async query
+    //   7- the returned RealmResults is now in the same version as the caller thread
+    //   8- the notification should be called once (when we retry automatically we shouldn't
+    //      notify the user).
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_retry() throws Throwable {
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        // Configure interceptor handler
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                int intercepts = numberOfIntercept.incrementAndGet();
+                switch (what) {
+                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                        if (intercepts == 1) {
+                            // we advance the Realm so we can simulate a retry
+                            realm.beginTransaction();
+                            realm.clear(AllTypes.class);
+                            AllTypes object = realm.createObject(AllTypes.class);
+                            object.setColumnString("The Endless River");
+                            object.setColumnLong(5);
+                            realm.commitTransaction();
+                        }
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // Create a async query and verify it is not still loaded.
+        final AllTypes realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 4, 6)
+                .findFirstAsync();
+
+        assertFalse(realmResults.isLoaded());
+
+        try {
+            realmResults.getColumnString();
+            fail("Accessing property on an empty row");
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Add change listener that should only be called once after the retry completed.
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(3, numberOfIntercept.get());
+                assertTrue(realmResults.isLoaded());
+                assertEquals(5, realmResults.getColumnLong());
+                assertEquals("The Endless River", realmResults.getColumnString());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // **************************************
+    // *** 'findAllSorted' async queries  ***
+    // **************************************
+
+    // similar UC as #testFindAllAsync using 'findAllSorted'
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync() throws Throwable {
+        final Realm realm = looperThread.realm;
+        populateTestRealm(realm, 10);
+
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllSortedAsync("columnString", Sort.DESCENDING);
+
+        assertFalse(results.isLoaded());
+        assertEquals(0, results.size());
+
+        results.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(results.isLoaded());
+                assertEquals(5, results.size());
+                for (int i = 0; i < 5; i++) {
+                    int iteration = (4 - i);
+                    assertEquals("test data " + iteration, results.get(4 - iteration).getColumnString());
+                }
+                looperThread.testComplete();
+            }
+        });
+    }
+
+
+    // finding elements [4-8] asynchronously then wait for the promise to be loaded
+    // using a callback to be notified when the data is loaded
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync_retry() throws Throwable {
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+
+        // 1. Populate the Realm without triggering a RealmChangeEvent.
+        realm.setAutoRefresh(false);
+        populateTestRealm(realm, 10);
+        realm.setAutoRefresh(true);
+
+        // 2. Configure proxy handler to intercept messages
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                // In order [QueryCompleted, RealmChanged, QueryUpdated]
+                int intercepts = numberOfIntercept.incrementAndGet();
+                switch (what) {
+                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                        if (intercepts == 1) {
+                            // We advance the Realm so we can simulate a retry before listeners are
+                            // called.
+                            realm.beginTransaction();
+                            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 8).findFirst().removeFromRealm();
+                            realm.commitTransaction();
+                        }
+                        break;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // 3. This will add a task to the paused asyncQueryExecutor
+        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
+                .between("columnLong", 4, 8)
+                .findAllSortedAsync("columnString", Sort.ASCENDING);
+
+        assertFalse(realmResults.isLoaded());
+        assertEquals(0, realmResults.size());
+
+        // 4. Intercepting the query completed event the first time will
+        // cause a commit that should cause the findAllSortedAsync to be re-run.
+        // This change listener should only be called with the final result.
+        realmResults.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(3, numberOfIntercept.get());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // similar UC as #testFindAllAsyncBatchUpdate using 'findAllSorted'
+    // UC:
+    //   1- insert 10 objects
+    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
+    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
+    //   4- the queries will complete with the same version as the caller thread
+    //   5- using a background thread update the Realm
+    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
+    //   7- callbacks are notified with the latest results (called twice overall)
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync_batchUpdate() {
+        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
+        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+
+        // 1. Add initial 10 objects
+        realm.setAutoRefresh(false);
+        populateTestRealm(realm, 10);
+        realm.setAutoRefresh(true);
+
+        // 2. Configure interceptor
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                        if (numberOfIntercept.incrementAndGet() == 1) {
+                            // 6. The first time the async queries complete we start an update from
+                            // another background thread. This will cause queries to rerun when the
+                            // background thread notifies this thread.
+                            final CountDownLatch bgThreadLatch = new CountDownLatch(1);
+                            new Thread() {
+                                @Override
+                                public void run() {
+                                    Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                                    bgRealm.beginTransaction();
+                                    bgRealm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
+                                    bgRealm.createObject(AllTypes.class);
+                                    bgRealm.createObject(AllTypes.class);
+                                    bgRealm.commitTransaction();
+                                    bgRealm.close();
+                                    bgThreadLatch.countDown();
+                                }
+                            }.start();
+                            TestHelper.awaitOrFail(bgThreadLatch);
+                        }
+                    }
+                    break;
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // 3. Create 2 async queries
+        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
+                .findAllSortedAsync("columnString", Sort.ASCENDING);
+        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllSortedAsync("columnString", Sort.DESCENDING);
+
+        // 4. Assert that queries have not finished
+        assertFalse(realmResults1.isLoaded());
+        assertFalse(realmResults2.isLoaded());
+        assertEquals(0, realmResults1.size());
+        assertEquals(0, realmResults2.size());
+
+        // 5. Change listeners will be called twice. Once when the first query completely and then
+        // when the background thread has completed, notifying this thread to rerun and then receive
+        // the updated results.
+        final Runnable signalCallbackDone = new Runnable() {
+            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    assertEquals(2, numberOfNotificationsQuery1.get());
+                    assertEquals(2, numberOfNotificationsQuery2.get());
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        realmResults1.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery1.incrementAndGet()) {
+                    case 1: { // first callback invocation
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(10, realmResults1.size());
+                        assertEquals("test data 4", realmResults1.get(4).getColumnString());
+                        break;
+                    }
+                    case 2: { // second callback
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(12, realmResults1.size());
+                        assertEquals("modified", realmResults1.get(2).getColumnString());
+                        signalCallbackDone.run();
+                        break;
+                    }
+                }
+            }
+        });
+
+        realmResults2.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery2.incrementAndGet()) {
+                    case 1: { // first callback invocation
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(5, realmResults2.size());
+                        assertEquals("test data 4", realmResults2.get(0).getColumnString());
+                        break;
+                    }
+                    case 2: { // second callback
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(7, realmResults2.size());
+                        assertEquals("modified", realmResults2.get(4).getColumnString());
+                        signalCallbackDone.run();
+                        break;
+                    }
+                }
+            }
+        });
+    }
+
+    // similar UC as #testFindAllAsyncBatchUpdate using 'findAllSortedMulti'
+    // UC:
+    //   1- insert 10 objects
+    //   2- start 2 async queries to find all objects [0-9] & objects[0-4]
+    //   3- assert both RealmResults are empty (Worker Thread didn't complete)
+    //   4- the queries will complete with the same version as the caller thread
+    //   5- using a background thread update the Realm
+    //   6- now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries
+    //   7- callbacks are notified with the latest results (called twice overall)
+    @Test
+    @RunTestInLooperThread
+    public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
+        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
+        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
+        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+
+        // 1. Add initial objects
+        realm.setAutoRefresh(false);
+        realm.beginTransaction();
+        for (int i = 0; i < 5; ) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+            allTypes.setColumnString("data " + i % 3);
+
+            allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+            allTypes.setColumnString("data " + (++i % 3));
+        }
+        realm.commitTransaction();
+        realm.setAutoRefresh(true);
+
+        // 2. Configure interceptor
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                int intercepts = numberOfIntercept.incrementAndGet();
+                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                    // 6. The first time the async queries complete we start an update from
+                    // another background thread. This will cause queries to rerun when the
+                    // background thread notifies this thread.
+                    new RealmBackgroundTask(looperThread.realmConfiguration) {
+                        @Override
+                        public void doInBackground(Realm realm) {
+                            realm.beginTransaction();
+                            realm.where(AllTypes.class)
+                                    .equalTo("columnString", "data 1")
+                                    .equalTo("columnLong", 0)
+                                    .findFirst().setColumnDouble(Math.PI);
+                            AllTypes allTypes = realm.createObject(AllTypes.class);
+                            allTypes.setColumnLong(2);
+                            allTypes.setColumnString("data " + 5);
+
+                            allTypes = realm.createObject(AllTypes.class);
+                            allTypes.setColumnLong(0);
+                            allTypes.setColumnString("data " + 5);
+                            realm.commitTransaction();
+                        }
+                    }.awaitOrFail();
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        // 3. Create 2 async queries
+        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
+                .findAllSortedAsync("columnString", Sort.ASCENDING, "columnLong", Sort.DESCENDING);
+        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
+                .between("columnLong", 0, 5)
+                .findAllSortedAsync("columnString", Sort.DESCENDING, "columnLong", Sort.ASCENDING);
+
+        // 4. Assert that queries have not finished
+        assertFalse(realmResults1.isLoaded());
+        assertFalse(realmResults2.isLoaded());
+        assertEquals(0, realmResults1.size());
+        assertEquals(0, realmResults2.size());
+        assertFalse(realmResults1.isLoaded());
+        assertFalse(realmResults2.isLoaded());
+        assertEquals(0, realmResults1.size());
+        assertEquals(0, realmResults2.size());
+
+        // 5. Change listeners will be called twice. Once when the first query completely and then
+        // when the background thread has completed, notifying this thread to rerun and then receive
+        // the updated results.
+        final Runnable signalCallbackDone = new Runnable() {
+            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    assertEquals(4, numberOfIntercept.get());
+                    assertEquals(2, numberOfNotificationsQuery1.get());
+                    assertEquals(2, numberOfNotificationsQuery2.get());
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        realmResults1.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery1.incrementAndGet()) {
+                    case 1: // first callback invocation
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(10, realmResults1.size());
+
+                        assertEquals("data 0", realmResults1.get(0).getColumnString());
+                        assertEquals(3, realmResults1.get(0).getColumnLong());
+                        assertEquals("data 0", realmResults1.get(1).getColumnString());
+                        assertEquals(2, realmResults1.get(1).getColumnLong());
+                        assertEquals("data 0", realmResults1.get(2).getColumnString());
+                        assertEquals(0, realmResults1.get(2).getColumnLong());
+
+                        assertEquals("data 1", realmResults1.get(3).getColumnString());
+                        assertEquals(4, realmResults1.get(3).getColumnLong());
+                        assertEquals("data 1", realmResults1.get(4).getColumnString());
+                        assertEquals(3, realmResults1.get(4).getColumnLong());
+                        assertEquals("data 1", realmResults1.get(5).getColumnString());
+                        assertEquals(1, realmResults1.get(5).getColumnLong());
+                        assertEquals("data 1", realmResults1.get(6).getColumnString());
+                        assertEquals(0, realmResults1.get(6).getColumnLong());
+
+                        assertEquals("data 2", realmResults1.get(7).getColumnString());
+                        assertEquals(4, realmResults1.get(7).getColumnLong());
+                        assertEquals("data 2", realmResults1.get(8).getColumnString());
+                        assertEquals(2, realmResults1.get(8).getColumnLong());
+                        assertEquals("data 2", realmResults1.get(9).getColumnString());
+                        assertEquals(1, realmResults1.get(9).getColumnLong());
+                        break;
+
+                    case 2: // second callback
+                        assertTrue(realmResults1.isLoaded());
+                        assertEquals(12, realmResults1.size());
+                        //first
+                        assertEquals("data 0", realmResults1.get(0).getColumnString());
+                        assertEquals(3, realmResults1.get(0).getColumnLong());
+
+                        //last
+                        assertEquals("data 5", realmResults1.get(11).getColumnString());
+                        assertEquals(0, realmResults1.get(11).getColumnLong());
+
+                        signalCallbackDone.run();
+                        break;
+                }
+            }
+        });
+
+        realmResults2.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfNotificationsQuery2.incrementAndGet()) {
+                    case 1: // first callback invocation
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(10, realmResults2.size());
+
+                        assertEquals("data 2", realmResults2.get(0).getColumnString());
+                        assertEquals(1, realmResults2.get(0).getColumnLong());
+                        assertEquals("data 2", realmResults2.get(1).getColumnString());
+                        assertEquals(2, realmResults2.get(1).getColumnLong());
+                        assertEquals("data 2", realmResults2.get(2).getColumnString());
+                        assertEquals(4, realmResults2.get(2).getColumnLong());
+
+                        assertEquals("data 1", realmResults2.get(3).getColumnString());
+                        assertEquals(0, realmResults2.get(3).getColumnLong());
+                        assertEquals("data 1", realmResults2.get(4).getColumnString());
+                        assertEquals(1, realmResults2.get(4).getColumnLong());
+                        assertEquals("data 1", realmResults2.get(5).getColumnString());
+                        assertEquals(3, realmResults2.get(5).getColumnLong());
+                        assertEquals("data 1", realmResults2.get(6).getColumnString());
+                        assertEquals(4, realmResults2.get(6).getColumnLong());
+
+                        assertEquals("data 0", realmResults2.get(7).getColumnString());
+                        assertEquals(0, realmResults2.get(7).getColumnLong());
+                        assertEquals("data 0", realmResults2.get(8).getColumnString());
+                        assertEquals(2, realmResults2.get(8).getColumnLong());
+                        assertEquals("data 0", realmResults2.get(9).getColumnString());
+                        assertEquals(3, realmResults2.get(9).getColumnLong());
+                        break;
+
+                    case 2: // second callback
+                        assertTrue(realmResults2.isLoaded());
+                        assertEquals(12, realmResults2.size());
+
+                        assertEquals("data 5", realmResults2.get(0).getColumnString());
+                        assertEquals(0, realmResults2.get(0).getColumnLong());
+
+                        assertEquals("data 0", realmResults2.get(11).getColumnString());
+                        assertEquals(3, realmResults2.get(11).getColumnLong());
+
+                        assertEquals("data 1", realmResults2.get(5).getColumnString());
+                        assertEquals(Math.PI, realmResults2.get(5).getColumnDouble(), 0.000000000001D);
+
+                        signalCallbackDone.run();
+                        break;
+                }
+            }
+        });
+    }
+
+    // make sure the notification listener does not leak the enclosing class
+    // if unregistered properly.
+    @Test
+    @RunTestInLooperThread
+    public void listenerShouldNotLeak() {
+        populateTestRealm(looperThread.realm, 10);
+
+        // simulate the ActivityManager by creating 1 instance responsible
+        // of attaching an onChange listener, then simulate a configuration
+        // change (ex: screen rotation), this change will create a new instance.
+        // we make sure that the GC enqueue the reference of the destroyed instance
+        // which indicate no memory leak
+        MockActivityManager mockActivityManager =
+                MockActivityManager.newInstance(looperThread.realm.getConfiguration());
+
+        mockActivityManager.sendConfigurationChange();
+
+        assertEquals(1, mockActivityManager.numberOfInstances());
+        // remove GC'd reference & assert that one instance should remain
+        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator =
+                looperThread.realm.handlerController.asyncRealmResults.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> entry = iterator.next();
+            RealmResults<?> weakReference = entry.getKey().get();
+            if (weakReference == null) {
+                iterator.remove();
+            }
+        }
+
+        assertEquals(1, looperThread.realm.handlerController.asyncRealmResults.size());
+        mockActivityManager.onStop();// to close the Realm
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void combiningAsyncAndSync() {
+        populateTestRealm(looperThread.realm, 10);
+
+        Realm.asyncQueryExecutor.pause();
+        final RealmResults<AllTypes> allTypesAsync = looperThread.realm.where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
+        final RealmResults<AllTypes> allTypesSync = allTypesAsync.where().greaterThan("columnLong", 3).findAll();
+
+        assertEquals(0, allTypesAsync.size());
+        assertEquals(6, allTypesSync.size());
+        allTypesAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(4, allTypesAsync.size());
+                assertEquals(6, allTypesSync.size());
+                looperThread.testComplete();
+            }
+        });
+        Realm.asyncQueryExecutor.resume();
+        looperThread.keepStrongReference.add(allTypesAsync);
+    }
+
+    // keep advancing the Realm by sending 1 commit for each frame (16ms)
+    // the async queries should keep up with the modification
+    @Test
+    @RunTestInLooperThread
+    public void stressTestBackgroundCommits() throws Throwable {
+        final int NUMBER_OF_COMMITS = 100;
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final long[] latestLongValue = new long[1];
+        final float[] latestFloatValue = new float[1];
+        // start a background thread that pushes a commit every 16ms
+        final Thread backgroundThread = new Thread() {
+            @Override
+            public void run() {
+                Random random = new Random(System.currentTimeMillis());
+                Realm backgroundThreadRealm = Realm.getInstance(looperThread.realm.getConfiguration());
+                for (int i = 0; i < NUMBER_OF_COMMITS; i++) {
+                    backgroundThreadRealm.beginTransaction();
+                    AllTypes object = backgroundThreadRealm.createObject(AllTypes.class);
+                    latestLongValue[0] = random.nextInt(100);
+                    latestFloatValue[0] = random.nextFloat();
+                    object.setColumnFloat(latestFloatValue[0]);
+                    object.setColumnLong(latestLongValue[0]);
+                    backgroundThreadRealm.commitTransaction();
+
+                    // Wait 16ms. before adding the next commit.
+                    SystemClock.sleep(16);
+                }
+                backgroundThreadRealm.close();
+                bgRealmClosed.countDown();
+            }
+        };
+
+        final RealmResults<AllTypes> allAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
+        allAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertTrue(allAsync.isLoaded());
+                if (allAsync.size() == NUMBER_OF_COMMITS) {
+                    AllTypes lastInserted = looperThread.realm.where(AllTypes.class)
+                            .equalTo("columnLong", latestLongValue[0])
+                            .equalTo("columnFloat", latestFloatValue[0])
+                            .findFirst();
+                    assertNotNull(lastInserted);
+                    TestHelper.awaitOrFail(bgRealmClosed);
+                    looperThread.testComplete();
+                }
+            }
+        });
+        looperThread.keepStrongReference.add(allAsync);
+
+        looperThread.realm.handler.postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                backgroundThread.start();
+            }
+        }, 16);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync() throws Throwable {
+        Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.distinctAsync(AnnotationIndexTypes.class, "indexBoolean");
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.distinctAsync(AnnotationIndexTypes.class, "indexLong");
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.distinctAsync(AnnotationIndexTypes.class, "indexDate");
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable changeListenerDone = new Runnable() {
+            final AtomicInteger signalCallbackFinished = new AtomicInteger(4);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        distinctBool.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(2, distinctBool.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctString.size());
+                changeListenerDone.run();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync_notIndexedFields() throws Throwable {
+        Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
+            try {
+                realm.distinctAsync(AnnotationIndexTypes.class, "notIndex" + fieldName);
+                fail("notIndex" + fieldName);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync_noneExistingField() throws Throwable {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "doesNotExist");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void batchUpdateDifferentTypeOfQueries() {
+        looperThread.realm.beginTransaction();
+        for (int i = 0; i < 5; ) {
+            AllTypes allTypes = looperThread.realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+            allTypes.setColumnString("data " + i % 3);
+
+            allTypes = looperThread.realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+            allTypes.setColumnString("data " + (++i % 3));
+        }
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        looperThread.realm.commitTransaction();
+        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AllTypes> findAllAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
+        RealmResults<AllTypes> findAllSorted = looperThread.realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
+        RealmResults<AllTypes> findAllSortedMulti = looperThread.realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
+                new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
+        RealmResults<AnnotationIndexTypes> findDistinct = looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+
+        looperThread.keepStrongReference.add(findAllAsync);
+        looperThread.keepStrongReference.add(findAllSorted);
+        looperThread.keepStrongReference.add(findAllSortedMulti);
+        looperThread.keepStrongReference.add(findDistinct);
+
+        final CountDownLatch queriesCompleted = new CountDownLatch(4);
+        final CountDownLatch bgRealmClosedLatch = new CountDownLatch(1);
+        final AtomicInteger batchUpdateCompleted = new AtomicInteger(0);
+        final AtomicInteger findAllAsyncInvocation = new AtomicInteger(0);
+        final AtomicInteger findAllSortedInvocation = new AtomicInteger(0);
+        final AtomicInteger findAllSortedMultiInvocation = new AtomicInteger(0);
+        final AtomicInteger findDistinctInvocation = new AtomicInteger(0);
+
+        findAllAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (findAllAsyncInvocation.incrementAndGet()) {
+                    case 1: {
+                        queriesCompleted.countDown();
+                        break;
+                    }
+                    case 2: {
+                        if (batchUpdateCompleted.incrementAndGet() == 4) {
+                            looperThread.testComplete(bgRealmClosedLatch);
+                        }
+                        break;
+                    }
+                }
+            }
+        });
+
+        findAllSorted.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (findAllSortedInvocation.incrementAndGet()) {
+                    case 1: {
+                        queriesCompleted.countDown();
+                        break;
+                    }
+                    case 2: {
+                        if (batchUpdateCompleted.incrementAndGet() == 4) {
+                            looperThread.testComplete(bgRealmClosedLatch);
+                        }
+                        break;
+                    }
+                }
+            }
+        });
+
+        findAllSortedMulti.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (findAllSortedMultiInvocation.incrementAndGet()) {
+                    case 1: {
+                        queriesCompleted.countDown();
+                        break;
+                    }
+                    case 2: {
+                        if (batchUpdateCompleted.incrementAndGet() == 4) {
+                            looperThread.testComplete(bgRealmClosedLatch);
+                        }
+                        break;
+                    }
+                }
+            }
+        });
+
+        findDistinct.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (findDistinctInvocation.incrementAndGet()) {
+                    case 1: {
+                        queriesCompleted.countDown();
+                        break;
+                    }
+                    case 2: {
+                        if (batchUpdateCompleted.incrementAndGet() == 4) {
+                            looperThread.testComplete(bgRealmClosedLatch);
+                        }
+                        break;
+                    }
+                }
+            }
+        });
+
+        // wait for the queries to completes then send a commit from
+        // another thread to trigger a batch update of the 4 queries
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    queriesCompleted.await();
+                    Realm bgRealm = Realm.getInstance(looperThread.realm.getConfiguration());
+
+                    bgRealm.beginTransaction();
+                    bgRealm.createObject(AllTypes.class);
+                    bgRealm.createObject(AnnotationIndexTypes.class);
+                    bgRealm.commitTransaction();
+
+                    bgRealm.close();
+                    bgRealmClosedLatch.countDown();
+                } catch (InterruptedException e) {
+                    fail(e.getMessage());
+                }
+            }
+        }.start();
+    }
+
+    // this test make sure that Async queries update when using link
+    @Test
+    @RunTestInLooperThread
+    public void queryingLinkHandover() throws Throwable {
+        final AtomicInteger numberOfInvocations = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+
+        final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo("owner.name", "kiba").findAllAsync();
+        allAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (numberOfInvocations.incrementAndGet()) {
+                    case 1:
+                        assertEquals(0, allAsync.size());
+                        assertTrue(allAsync.isLoaded());
+                        assertTrue(allAsync.isValid());
+                        assertTrue(allAsync.isEmpty());
+                        new RealmBackgroundTask(realm.getConfiguration()) {
+                            @Override
+                            public void doInBackground(Realm realm) {
+                                realm.beginTransaction();
+                                Dog dog = realm.createObject(Dog.class);
+                                dog.setAge(10);
+                                dog.setName("Akamaru");
+                                Owner kiba = realm.createObject(Owner.class);
+                                kiba.setName("kiba");
+                                dog.setOwner(kiba);
+                                realm.commitTransaction();
+                            }
+                        }.awaitOrFail();
+                        break;
+
+                    case 2:
+                        assertEquals(1, realm.allObjects(Dog.class).size());
+                        assertEquals(1, realm.allObjects(Owner.class).size());
+                        assertEquals(1, allAsync.size());
+                        assertTrue(allAsync.isLoaded());
+                        assertTrue(allAsync.isValid());
+                        assertFalse(allAsync.isEmpty());
+                        assertEquals(1, allAsync.size());
+                        assertEquals("Akamaru", allAsync.get(0).getName());
+                        assertEquals("kiba", allAsync.get(0).getOwner().getName());
+                        looperThread.testComplete();
+                        break;
+                }
+            }
+        });
+    }
+
+    // Make sure we don't get the run into the IllegalStateException
+    // (Caller thread behind the worker thread)
+    // Scenario:
+    // - Caller thread is in version 1, start an asyncFindFirst
+    // - Another thread advance the Realm, now the latest version = 2
+    // - The worker thread should query against version 1 not version 2
+    // otherwise the caller thread wouldn't be able to import the result
+    // - The notification mechanism will guarantee that the REALM_CHANGE triggered by
+    // the background thread, will update the caller thread (advancing it to version 2)
+    @Test
+    @RunTestInLooperThread
+    public void testFindFirstUsesCallerThreadVersion() throws Throwable {
+        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+
+        populateTestRealm(looperThread.realm, 10);
+        Realm.asyncQueryExecutor.pause();
+
+        final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
+        firstAsync.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertNotNull(firstAsync);
+                assertEquals("test data 0", firstAsync.getColumnString());
+                looperThread.testComplete(signalClosedRealm);
+            }
+        });
+
+        // advance the background Realm
+        new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                // Advancing the Realm without generating notifications
+                bgRealm.sharedGroupManager.promoteToWrite();
+                bgRealm.sharedGroupManager.commitAndContinueAsRead();
+                Realm.asyncQueryExecutor.resume();
+                bgRealm.close();
+                signalClosedRealm.countDown();
+            }
+        }.start();
+    }
+
+
+    // *** Helper methods ***
+
+    private void populateTestRealm(final Realm testRealm, int objects) {
+        testRealm.setAutoRefresh(false);
+        testRealm.beginTransaction();
+        testRealm.allObjects(AllTypes.class).clear();
+        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date());
+            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+            nonLatinFieldNames.set베타(1.234567f + i);
+            nonLatinFieldNames.setΒήτα(1.234567f + i);
+        }
+        testRealm.commitTransaction();
+        testRealm.setAutoRefresh(true);
+    }
+
+    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
+            for (int j = 0; j < numberOfBlocks; j++) {
+                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
+                obj.setIndexBoolean(j % 2 == 0);
+                obj.setIndexLong(j);
+                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexString(withNull ? null : "Test " + j);
+                obj.setNotIndexBoolean(j % 2 == 0);
+                obj.setNotIndexLong(j);
+                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexString(withNull ? null : "Test " + j);
+            }
+        }
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
new file mode 100644
index 0000000000..abbc3a37dc
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.StringOnly;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmCacheTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private RealmConfiguration defaultConfig;
+    private Context context;
+
+    @Before
+    public void setUp() {
+        defaultConfig = configFactory.createConfiguration();
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+    }
+
+    // Test that the closed Realm isn't kept in the Realm instance cache
+    @Test
+    public void typedRealmCacheIsCleared() {
+        Realm typedRealm = Realm.getInstance(defaultConfig);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+        typedRealm.close(); // Still a dynamic instance open, but the typed Realm cache must still be cleared.
+        dynamicRealm.close();
+
+        Realm typedRealm1 = Realm.getInstance(defaultConfig);
+        try {
+            assertFalse(typedRealm == typedRealm1); // Must be different instance
+            // If cache isn't cleared this would crash because of a closed shared group.
+            assertEquals(0, typedRealm1.where(AllTypes.class).count());
+        } finally {
+            typedRealm1.close();
+        }
+    }
+
+    // Test that the closed DynamicRealms isn't kept in the DynamicRealm instance cache
+    @Test
+    public void dynamicRealmCacheIsCleared() {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+        Realm typedRealm = Realm.getInstance(defaultConfig);
+
+        dynamicRealm.close(); // Still an instance open, but DynamicRealm cache must still be cleared.
+        typedRealm.close();
+
+        DynamicRealm dynamicRealm1 = DynamicRealm.getInstance(defaultConfig);
+        try {
+            // If cache isn't cleared this would crash because of a closed shared group.
+            assertFalse(dynamicRealm == dynamicRealm1);
+            assertEquals(0, dynamicRealm1.getVersion());
+        } finally {
+            dynamicRealm1.close();
+        }
+    }
+
+    @Test
+    public void getInstanceClearsCacheWhenFailed() {
+        String REALM_NAME = "invalid_cache.realm";
+        RealmConfiguration configA = configFactory.createConfiguration(REALM_NAME,
+                TestHelper.getRandomKey(42));
+        RealmConfiguration configB = configFactory.createConfiguration(REALM_NAME,
+                TestHelper.getRandomKey(43));
+
+        Realm realm = Realm.getInstance(configA); // Create starting Realm with key1
+        realm.close();
+        try {
+            Realm.getInstance(configB); // Try to open with key 2
+        } catch (IllegalArgumentException ignored) {
+            // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
+            // if initialization failed.
+            assertTrue(Realm.deleteRealm(configA));
+            realm = Realm.getInstance(configB);
+            realm.close();
+        }
+    }
+
+    @Test
+    public void realmCache() {
+        Realm realm = Realm.getInstance(defaultConfig);
+        Realm newRealm = Realm.getInstance(defaultConfig);
+        try {
+            assertEquals(realm, newRealm);
+        } finally {
+            realm.close();
+            newRealm.close();
+        }
+    }
+
+    // We should not cache wrong configurations
+    @Test
+    public void dontCacheWrongConfigurations() throws IOException {
+        Realm testRealm;
+        String REALM_NAME = "encrypted.realm";
+        configFactory.copyRealmFromAssets(context, REALM_NAME, REALM_NAME);
+        RealmMigration realmMigration = TestHelper.prepareMigrationToNullSupportStep();
+
+        RealmConfiguration wrongConfig = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .encryptionKey(TestHelper.SHA512("foo"))
+                .migration(realmMigration)
+                .schema(StringOnly.class)
+                .build();
+
+        RealmConfiguration rightConfig = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .encryptionKey(TestHelper.SHA512("realm"))
+                .migration(realmMigration)
+                .schema(StringOnly.class)
+                .build();
+
+        // Open Realm with wrong key
+        try {
+            Realm.getInstance(wrongConfig);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Try again with proper key
+        testRealm = Realm.getInstance(rightConfig);
+        assertNotNull(testRealm);
+        testRealm.close();
+    }
+
+    @Test
+    public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
+        String REALM_NAME = "encrypted.realm";
+        byte[] oldPassword = TestHelper.SHA512("realm");
+        byte[] newPassword = TestHelper.SHA512("realm-copy");
+
+        configFactory.copyRealmFromAssets(context, REALM_NAME, REALM_NAME);
+        RealmMigration realmMigration = TestHelper.prepareMigrationToNullSupportStep();
+
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .encryptionKey(oldPassword)
+                .migration(realmMigration)
+                .schema(StringOnly.class)
+                .build();
+
+        // 1. Write a copy of the encrypted Realm to a new file
+        Realm testRealm = Realm.getInstance(config);
+        File copiedRealm = new File(config.getRealmFolder(), "encrypted-copy.realm");
+        if (copiedRealm.exists()) {
+            assertTrue(copiedRealm.delete());
+        }
+        testRealm.writeEncryptedCopyTo(copiedRealm, newPassword);
+        testRealm.close();
+
+        // 2. Delete the old Realm.
+        Realm.deleteRealm(config);
+
+        // 3. Rename the new file to the old file name.
+        assertTrue(copiedRealm.renameTo(new File(config.getRealmFolder(), REALM_NAME)));
+
+        // 4. Try to open the file again with the new password
+        // If the configuration cache wasn't cleared this would fail as we would detect two
+        // configurations with 2 different passwords pointing to the same file.
+        RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .encryptionKey(newPassword)
+                .migration(realmMigration)
+                .schema(StringOnly.class)
+                .build();
+
+        testRealm = Realm.getInstance(newConfig);
+        assertNotNull(testRealm);
+        testRealm.close();
+    }
+
+    // Tests that if the same Realm file is opened on multiple threads, we only need to validate the
+    // schema on the first thread
+    // When there is a transaction holding by a typed Realm in one thread, getInstance from the
+    // other thread should not be blocked since we have cached the schemas already.
+    @Test
+    public void getInstance_shouldNotBeBlockedByTransactionInAnotherThread()
+            throws InterruptedException {
+        Realm realm = Realm.getInstance(defaultConfig);
+        final CountDownLatch latch = new CountDownLatch(1);
+        realm.beginTransaction();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(defaultConfig);
+                realm.close();
+                latch.countDown();
+            }
+        });
+        thread.start();
+        TestHelper.awaitOrFail(latch);
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Test
+    public void differentThreadsDifferentInstance() throws InterruptedException {
+        final CountDownLatch closeLatch = new CountDownLatch(1);
+
+        final Realm realmA = Realm.getInstance(defaultConfig);
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realmB = Realm.getInstance(defaultConfig);
+                assertFalse(realmA == realmB);
+                RealmCache.invokeWithGlobalRefCount(defaultConfig,
+                        new TestHelper.ExpectedCountCallback(2));
+                realmB.close();
+                closeLatch.countDown();
+            }
+        });
+        thread.start();
+
+        closeLatch.await();
+        RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(1));
+        realmA.close();
+        RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(0));
+    }
+
+    @Test
+    public void releaseCacheInOneThread() {
+        // Test release typed Realm instance
+        Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
+        Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
+        RealmCache.release(realmA);
+        assertNotNull(realmA.sharedGroupManager);
+        RealmCache.release(realmB);
+        assertNull(realmB.sharedGroupManager);
+        // No crash but warning in the log
+        RealmCache.release(realmB);
+
+        // Test release dynamic Realm instance
+        DynamicRealm dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig,
+                DynamicRealm.class);
+        DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
+                DynamicRealm.class);
+        RealmCache.release(dynamicRealmA);
+        assertNotNull(dynamicRealmA.sharedGroupManager);
+        RealmCache.release(dynamicRealmB);
+        assertNull(dynamicRealmB.sharedGroupManager);
+        // No crash but warning in the log
+        RealmCache.release(dynamicRealmB);
+
+        // Test both typed Realm and dynamic Realm in same thread
+        realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
+        dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
+        RealmCache.release(realmA);
+        assertNull(realmA.sharedGroupManager);
+        RealmCache.release(dynamicRealmA);
+        assertNull(realmA.sharedGroupManager);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
new file mode 100644
index 0000000000..4d93694fb6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -0,0 +1,647 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.Set;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnimalModule;
+import io.realm.entities.Cat;
+import io.realm.entities.CatOwner;
+import io.realm.entities.CyclicType;
+import io.realm.entities.Dog;
+import io.realm.entities.HumanModule;
+import io.realm.entities.Owner;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rx.RxObservableFactory;
+import rx.Observable;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmConfigurationTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    RealmConfiguration defaultConfig;
+    Realm realm;
+
+    @Before
+    public void setUp() {
+        defaultConfig = configFactory.createConfiguration();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void clearDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
+        final Field field = Realm.class.getDeclaredField("defaultConfiguration");
+        field.setAccessible(true);
+        field.set(null, null);
+    }
+
+    @Test
+    public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, IllegalAccessException {
+        clearDefaultConfiguration();
+        try {
+            Realm.setDefaultConfiguration(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void getDefaultInstance_nullThrows() throws NoSuchFieldException, IllegalAccessException {
+        clearDefaultConfiguration();
+        try {
+            Realm.getDefaultInstance();
+            fail();
+        } catch (NullPointerException ignored) {
+        }
+    }
+
+    @Test
+    public void getInstance_nullConfigThrows() {
+        try {
+            Realm.getInstance((RealmConfiguration) null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_nullDirThrows() {
+        try {
+            new RealmConfiguration.Builder((File) null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_createSubFoldersThrows() {
+        File folder = new File(configFactory.getRoot() + "/subfolder1/subfolder2/");
+        try {
+            new RealmConfiguration.Builder(folder).build();
+            fail("Assuming that sub folders are created automatically should fail.");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_nullNameThrows() {
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).name(null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_emptyNameThrows() {
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).name("").build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void getInstance_idForHashCollision() {
+        // Ea.hashCode() == FB.hashCode()
+        RealmConfiguration configA = configFactory.createConfiguration("Ea");
+        RealmConfiguration configB = configFactory.createConfiguration("FB");
+
+        Realm r1 = Realm.getInstance(configA);
+        Realm r2 = Realm.getInstance(configB);
+        assertNotSame(r1, r2);
+        r1.close();
+        r2.close();
+    }
+
+    @Test
+    public void constructBuilder_nullKeyThrows() {
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_wrongKeyLengthThrows() {
+        byte[][] wrongKeys = new byte[][] {
+                new byte[0],
+                new byte[RealmConfiguration.KEY_LENGTH - 1],
+                new byte[RealmConfiguration.KEY_LENGTH + 1]
+        };
+        for (byte[] key : wrongKeys) {
+            try {
+                new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+                fail("Key with length " + key.length + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void constructBuilder_negativeVersionThrows() {
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(-1).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void constructBuilder_versionLessThanDiscVersionThrows() {
+        realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(42).build());
+        realm.close();
+
+        int[] wrongVersions = new int[] { 0, 1, 41 };
+        for (int version : wrongVersions) {
+            try {
+                realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
+                        .schemaVersion(version).build());
+                fail("Version " + version + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
+        // Create initial Realm
+        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schemaVersion(42).schema(Dog.class).build();
+        Realm.getInstance(config).close();
+
+        // Create new instance with a configuration containing another schema
+        try {
+            config = new RealmConfiguration.Builder(configFactory.getRoot())
+                    .schemaVersion(42).schema(AllTypesPrimaryKey.class).build();
+            realm = Realm.getInstance(config);
+            fail("A migration should be required");
+        } catch (RealmMigrationNeededException ignored) {
+        }
+    }
+
+    @Test
+    public void customSchemaDontIncludeLinkedClasses() {
+        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).schema(Dog.class).build();
+        realm = Realm.getInstance(config);
+        try {
+            assertEquals(3, realm.getTable(Owner.class).getColumnCount());
+            fail("Owner should to be part of the schema");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void migration_nullThrows() {
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).migration(null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void setModules_nonRealmModulesThrows() {
+        // Test first argument
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).setModules(new Object());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Test second argument
+        try {
+            new RealmConfiguration.Builder(configFactory.getRoot()).setModules(Realm.getDefaultModule(), new Object());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void setModules() {
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(Realm.getDefaultModule(), (Object) null).build();
+        realm = Realm.getInstance(realmConfig);
+        assertNotNull(realm.getTable(AllTypes.class));
+    }
+
+    @Test
+    public void setDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
+        clearDefaultConfiguration();
+        Realm.setDefaultConfiguration(defaultConfig);
+        realm = Realm.getDefaultInstance();
+        assertEquals(realm.getPath(), defaultConfig.getPath());
+    }
+
+    @Test
+    public void getInstance() {
+        realm = Realm.getInstance(defaultConfig);
+        assertEquals(realm.getPath(), defaultConfig.getPath());
+    }
+
+    @Test
+    public void standardSetup() {
+        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .name("foo.realm")
+                .encryptionKey(TestHelper.getRandomKey())
+                .schemaVersion(42)
+                .migration(new RealmMigration() {
+                    @Override
+                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                        // no-op
+                    }
+                })
+                .deleteRealmIfMigrationNeeded()
+                .build();
+
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        assertTrue(realm.getPath().endsWith("foo.realm"));
+        assertEquals(42, realm.getVersion());
+    }
+
+    @Test
+    public void deleteRealmIfMigrationNeeded() {
+        // Populate v0 of a Realm with an object
+        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schema(Dog.class)
+                .schemaVersion(0)
+                .build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.copyToRealm(new Dog("Foo"));
+        realm.commitTransaction();
+        assertEquals(1, realm.where(Dog.class).count());
+        realm.close();
+
+        // Change schema and verify that Realm has been cleared
+        config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schema(Owner.class, Dog.class)
+                .schemaVersion(1)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+        realm = Realm.getInstance(config);
+        assertEquals(0, realm.where(Dog.class).count());
+    }
+
+    @Test
+    public void upgradeVersionWithNoMigration() {
+        realm = Realm.getInstance(defaultConfig);
+        assertEquals(0, realm.getVersion());
+        realm.close();
+
+        // Version upgrades should always require a migration.
+        try {
+            realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
+                    .schemaVersion(42).build());
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+    }
+
+    @Test
+    public void equals() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        assertTrue(config1.equals(config2));
+    }
+
+    @Test
+    public void hashCode_Test() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        assertEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    @Test
+    public void equals_withCustomModules() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new HumanModule(), new AnimalModule())
+                .build();
+
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new AnimalModule(), new HumanModule())
+                .build();
+
+        assertTrue(config1.equals(config2));
+    }
+
+    @Test
+    public void hashCode_withCustomModules() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new HumanModule(), new AnimalModule())
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new AnimalModule(), new HumanModule())
+                .build();
+
+        assertEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    @Test
+    public void equals_configurationsReturnCachedRealm() {
+        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
+        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
+        try {
+            assertEquals(realm1, realm2);
+        } finally {
+            realm1.close();
+            realm2.close();
+        }
+    }
+
+    @Test
+    public void schemaVersion_differentVersionsThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(1).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(2).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    @Test
+    public void encryptionKey_differentEncryptionKeysThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey()).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            realm = Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    @Test
+    public void schema_differentSchemasThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schema(AllTypes.class).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schema(CyclicType.class).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    // Creating Realm instances with same name but different durabilities is not allowed.
+    @Test
+    public void inMemory_differentDurabilityThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).inMemory().build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+
+        // Create In-memory Realm first.
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            // On-disk Realm then. Not allowed!
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm1.close();
+        }
+
+        // Create on-disk Realm first.
+        realm1 = Realm.getInstance(config2);
+        try {
+            // In-memory Realm then. Not allowed!
+            Realm.getInstance(config1);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    // It is allowed to create multiple Realm with same name but in different directory
+    @Test
+    public void constructBuilder_differentDirSameName() throws IOException {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.newFolder()).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        Realm realm2 = Realm.getInstance(config2);
+        realm1.close();
+        realm2.close();
+    }
+
+    @Test
+    public void encryptionKey_keyStorage() throws Exception {
+        // Generate a key and use it in a RealmConfiguration
+        byte[] oldKey = TestHelper.getRandomKey(12345);
+        byte[] key = oldKey;
+        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+
+        // Generate a different key and assign it to the same variable
+        byte[] newKey = TestHelper.getRandomKey(67890);
+        MoreAsserts.assertNotEqual(key, newKey);
+        key = newKey;
+        MoreAsserts.assertEquals(key, newKey);
+
+        // Ensure that the stored key did not change
+        MoreAsserts.assertEquals(oldKey, config.getEncryptionKey());
+    }
+
+    @Test
+    public void modelClassesForDefaultMediator() throws Exception {
+        assertTrue(defaultConfig.getSchemaMediator() instanceof DefaultRealmModuleMediator);
+
+        final Set<Class<? extends RealmObject>> realmClasses = defaultConfig.getRealmObjectClasses();
+
+        assertTrue(realmClasses.contains(AllTypes.class));
+
+        // tests returned Set is unmodifiable.
+        try {
+            realmClasses.add(AllTypes.class);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void modelClasses_forGeneratedMediator() throws Exception {
+        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new HumanModule()).build();
+        assertTrue(config.getSchemaMediator() instanceof HumanModuleMediator);
+
+        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+
+        assertFalse(realmClasses.contains(AllTypes.class));
+        assertTrue(realmClasses.contains(CatOwner.class));
+        assertFalse(realmClasses.contains(Cat.class));
+
+        // tests returned Set is unmodifiable.
+        try {
+            realmClasses.add(AllTypes.class);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void modelClasses_forCompositeMediator() throws Exception {
+        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .setModules(new HumanModule(), new AnimalModule()).build();
+        assertTrue(config.getSchemaMediator() instanceof CompositeMediator);
+
+        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+
+        assertFalse(realmClasses.contains(AllTypes.class));
+        assertTrue(realmClasses.contains(CatOwner.class));
+        assertTrue(realmClasses.contains(Cat.class));
+
+        // tests returned Set is unmodifiable.
+        try {
+            realmClasses.add(AllTypes.class);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void modelClasses_forFilterableMediator() throws Exception {
+        //noinspection unchecked
+        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+                .schema(AllTypes.class, CatOwner.class).build();
+        assertTrue(config.getSchemaMediator() instanceof FilterableMediator);
+
+        final Set<Class<? extends RealmObject>> realmClasses = config.getRealmObjectClasses();
+
+        assertTrue(realmClasses.contains(AllTypes.class));
+        assertTrue(realmClasses.contains(CatOwner.class));
+        assertFalse(realmClasses.contains(Cat.class));
+
+        // tests returned Set is unmodifiable.
+        try {
+            realmClasses.add(AllTypes.class);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+    @Test
+    public void rxFactory() {
+        final RxObservableFactory dummyFactory = new RxObservableFactory() {
+            @Override
+            public Observable<Realm> from(Realm realm) {
+                return null;
+            }
+
+            @Override
+            public Observable<DynamicRealm> from(DynamicRealm realm) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmObject> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+                return null;
+            }
+
+            @Override
+            public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+                return null;
+            }
+
+            @Override
+            public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmObject> Observable<E> from(Realm realm, E object) {
+                return null;
+            }
+
+            @Override
+            public Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+                return null;
+            }
+
+            @Override
+            public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+                return null;
+            }
+        };
+
+        RealmConfiguration configuration1 = configFactory.createConfigurationBuilder()
+                .rxFactory(dummyFactory)
+                .build();
+        assertTrue(configuration1.getRxFactory() == dummyFactory);
+
+        RealmConfiguration configuration2 = configFactory.createConfigurationBuilder()
+                .build();
+        assertNotNull(configuration2.getRxFactory());
+        assertFalse(configuration2.getRxFactory() == dummyFactory);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
new file mode 100644
index 0000000000..4f48119fac
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.StrictMode;
+import android.test.AndroidTestCase;
+
+import junit.framework.AssertionFailedError;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.Dog;
+
+public class RealmInMemoryTest extends AndroidTestCase {
+
+    private final static String IDENTIFIER = "InMemRealmTest";
+
+    private Realm testRealm;
+    private RealmConfiguration inMemConf;
+
+    @Override
+    protected void setUp() throws Exception {
+        RealmConfiguration onDiskConf = new RealmConfiguration.Builder(getContext())
+                .name(IDENTIFIER)
+                .build();
+        inMemConf = new RealmConfiguration.Builder(getContext())
+                .name(IDENTIFIER)
+                .inMemory()
+                .build();
+
+        // Delete the same name Realm file just in case
+        Realm.deleteRealm(onDiskConf);
+        testRealm = Realm.getInstance(inMemConf);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        if (testRealm != null) {
+            testRealm.close();
+        }
+    }
+
+    // Testing the in-memory Realm by Creating one instance, adding a record, then close the instance.
+    // By the next time in-memory Realm instance with the same name created, it should be empty.
+    // Use StrictMode to check no disk IO would happen in VM to this thread.
+    public void testInMemoryRealm() {
+        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                .detectDiskReads()
+                .detectDiskWrites()
+                .penaltyDeath()
+                .build());
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("DinoDog");
+        testRealm.commitTransaction();
+
+        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
+
+        testRealm.close();
+        // After all references to the in-mem-realm closed,
+        // in-mem-realm with same identifier should create a fresh new instance.
+        testRealm = Realm.getInstance(inMemConf);
+        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+
+        StrictMode.enableDefaults();
+    }
+
+    // Two in-memory Realms with different names should not affect each other.
+    public void testInMemoryRealmWithDifferentNames() {
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("DinoDog");
+        testRealm.commitTransaction();
+
+        // Create the 2nd in-memory Realm with a different name. To make sure they are not affecting each other.
+        RealmConfiguration inMemConf2 = new RealmConfiguration.Builder(getContext())
+                .name(IDENTIFIER + "2")
+                .inMemory()
+                .build();
+        Realm testRealm2 = Realm.getInstance(inMemConf2);
+        testRealm2.beginTransaction();
+        Dog dog2 = testRealm2.createObject(Dog.class);
+        dog2.setName("UFODog");
+        testRealm2.commitTransaction();
+
+        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
+        assertEquals(testRealm2.allObjects(Dog.class).size(), 1);
+        assertEquals(testRealm2.allObjects(Dog.class).first().getName(), "UFODog");
+
+        testRealm2.close();
+    }
+
+    // Test deleteRealm called on a in-memory Realm instance
+    public void testDelete() {
+        RealmConfiguration configuration = testRealm.getConfiguration();
+        try {
+            Realm.deleteRealm(configuration);
+            fail("Realm.deleteRealm should fail with illegal state");
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Nothing should happen when delete a closed in-mem-realm.
+        testRealm.close();
+        testRealm = null;
+        assertTrue(Realm.deleteRealm(configuration));
+    }
+
+    // Test if an in-memory Realm can be written to disk with/without encryption
+    public void testWriteCopyTo() throws IOException {
+        byte[] key = TestHelper.getRandomKey();
+        String fileName = IDENTIFIER + ".realm";
+        String encFileName = IDENTIFIER + ".enc.realm";
+        RealmConfiguration conf = new RealmConfiguration.Builder(getContext())
+                .name(fileName)
+                .build();
+        RealmConfiguration encConf = new RealmConfiguration.Builder(getContext())
+                .name(encFileName)
+                .encryptionKey(key)
+                .build();
+
+        Realm.deleteRealm(conf);
+        Realm.deleteRealm(encConf);
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("DinoDog");
+        testRealm.commitTransaction();
+
+        // Test a normal Realm file
+        testRealm.writeCopyTo(new File(getContext().getFilesDir(), fileName));
+        Realm onDiskRealm = Realm.getInstance(conf);
+        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        onDiskRealm.close();
+
+        // Test a encrypted Realm file
+        testRealm.writeEncryptedCopyTo(new File(getContext().getFilesDir(), encFileName), key);
+        onDiskRealm = Realm.getInstance(encConf);
+        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        onDiskRealm.close();
+        // Test with a wrong key to see if it fails as expected.
+        try {
+            RealmConfiguration wrongKeyConf = new RealmConfiguration.Builder(getContext())
+                    .name(encFileName)
+                    .encryptionKey(TestHelper.getRandomKey(42))
+                    .build();
+            Realm.getInstance(wrongKeyConf);
+            fail("Realm.getInstance should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Test below scenario:
+    // 1. Create a in-memory Realm instance in the main thread.
+    // 2. Create a in-memory Realm with same name in another thread.
+    // 3. Close the in-memory Realm instance in the main thread and the Realm data should not be released since
+    //    another instance is still held by the other thread.
+    // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
+    //    specific name exists.
+    public void testMultiThread() throws InterruptedException, ExecutionException {
+        final CountDownLatch workerReadyLatch = new CountDownLatch(1);
+        final CountDownLatch workerFinishedLatch = new CountDownLatch(1);
+        final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
+        final AssertionFailedError threadError[] = new AssertionFailedError[1];
+
+        // Step 2.
+        Thread workerThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(inMemConf);
+                realm.beginTransaction();
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName("DinoDog");
+                realm.commitTransaction();
+
+                try {
+                    assertEquals(realm.allObjects(Dog.class).size(), 1);
+                } catch (AssertionFailedError afe) {
+                    threadError[0] = afe;
+                    realm.close();
+                    return;
+                }
+                workerReadyLatch.countDown();
+
+                // Wait until Realm instance closed in main thread
+                try {
+                    realmInMainClosedLatch.await(3, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    threadError[0] = new AssertionFailedError("Worker thread was interrupted.");
+                    realm.close();
+                    return;
+                }
+
+                realm.close();
+                workerFinishedLatch.countDown();
+            }
+        });
+        workerThread.start();
+
+
+        // Wait until the worker thread started
+        workerReadyLatch.await(3, TimeUnit.SECONDS);
+        if (threadError[0] != null) { throw threadError[0]; }
+
+        // refresh will be ran in the next loop, manually refresh it here.
+        testRealm.refresh();
+        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+
+        // Step 3.
+        // Release the main thread Realm reference, and the worker thread hold the reference still
+        testRealm.close();
+
+        // Step 4.
+        // Create a new Realm reference in main thread and checking the data.
+        testRealm = Realm.getInstance(inMemConf);
+        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        testRealm.close();
+
+        // Let the worker thread continue.
+        realmInMainClosedLatch.countDown();
+
+        // Wait until the worker thread finished
+        workerFinishedLatch.await(3, TimeUnit.SECONDS);
+        if (threadError[0] != null) { throw threadError[0]; }
+
+        // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance
+        testRealm = Realm.getInstance(inMemConf);
+        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
new file mode 100644
index 0000000000..cb577ee748
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.annotation.SuppressLint;
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.test.AndroidTestCase;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllTypes;
+import io.realm.services.RemoteProcessService;
+
+// This is built for testing multi processes related cases.
+// To build a test case, create an InterprocessHandler in your test case. This handler will run in the newly
+// created thread's Looper. Remember to call Looper.loop() to start handling messages.
+// Pass the first thing you want to run to the constructor which will be posted to the beginning of the message queue.
+// And add steps you want to run in the remote process in RemoteProcessService.
+// Write the comments of the test case like this:
+// A-Z means steps running from remote service process.
+// 1-9xx means steps running from the main local process.
+// eg.: A. Open a Realm
+//      1. Open two Realms
+//      B. Open three Realms
+//      2. assertTrue("OK, remote process win. You can open more Realms than I do in the main local process", false);
+public class RealmInterprocessTest extends AndroidTestCase {
+    private Realm testRealm;
+    private Messenger remoteMessenger;
+    private Messenger localMessenger;
+    private CountDownLatch serviceStartLatch;
+    private final ServiceConnection serviceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
+            remoteMessenger = new Messenger(iBinder);
+            serviceStartLatch.countDown();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName componentName) {
+            if (serviceStartLatch != null && serviceStartLatch.getCount() > 1) {
+                serviceStartLatch.countDown();
+            }
+            serviceStartLatch = null;
+        }
+    };
+
+    // It is necessary to overload this method.
+    // AndroidTestRunner does call Looper.prepare() and we can have a looper in the case. The problem is all the test
+    // cases are running in a single thread!!! And after Looper.quit() called, it cannot start again. That means we
+    // can only have one case in this class LoL.
+    // By overloading this method, we create a new thread and looper to run the real case. And use latch to wait until
+    // it is finished. Then we can get rid of creating the thread in the test method, using array to store exception, many
+    // levels of nested code. Make the test case more nature.
+    @Override
+    public void runBare() throws Throwable {
+        final Throwable[] throwableArray = new Throwable[1];
+        final CountDownLatch latch = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                try {
+                    RealmInterprocessTest.super.runBare();
+                } catch (Throwable throwable) {
+                    throwableArray[0] = throwable;
+                } finally {
+                    latch.countDown();
+                }
+            }
+        });
+
+        thread.start();
+        latch.await();
+
+        if (throwableArray[0] != null) {
+            throw throwableArray[0];
+        }
+    }
+
+    // Helper handler to make it easy to interact with remote service process.
+    @SuppressLint("HandlerLeak") // SuppressLint bug, doesn't work
+    private class InterprocessHandler extends Handler {
+        // Timeout Watchdog. In case the service crashed or expected response is not returned.
+        // It is very important to feed the dog after the expected message arrived.
+        private final int timeout = 5000;
+        private volatile boolean isTimeout = true;
+        private Runnable timeoutRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (isTimeout) {
+                    assertTrue("Timeout happened", false);
+                } else {
+                    isTimeout = true;
+                    postDelayed(timeoutRunnable, timeout);
+                }
+            }
+        };
+
+        protected void clearTimeoutFlag() {
+            isTimeout = false;
+        }
+
+        protected void done() {
+            Looper.myLooper().quit();
+        }
+
+        public InterprocessHandler(Runnable startRunnable) {
+            super(Looper.myLooper());
+            localMessenger = new Messenger(this);
+            // To have the first step from main process run
+            post(startRunnable);
+            // Start watchdog
+            postDelayed(timeoutRunnable, timeout);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Bundle bundle = msg.getData();
+            String error = bundle.getString(RemoteProcessService.BUNDLE_KEY_ERROR);
+            if (error != null) {
+                // Assert and show error from service process
+                assertTrue(error, false);
+            }
+        }
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        Realm.deleteRealm(new RealmConfiguration.Builder(getContext()).build());
+
+        // Start the testing service
+        serviceStartLatch = new CountDownLatch(1);
+        Intent intent = new Intent(getContext(), RemoteProcessService.class);
+        getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
+        assertTrue(serviceStartLatch.await(10, TimeUnit.SECONDS));
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        int counter = 10;
+        if (testRealm != null) {
+            testRealm.close();
+        }
+
+        getContext().unbindService(serviceConnection);
+        remoteMessenger = null;
+
+        // Kill the remote process.
+        ActivityManager.RunningAppProcessInfo info = getRemoteProcessInfo();
+        if (info != null) {
+            android.os.Process.killProcess(info.pid);
+        }
+        while (getRemoteProcessInfo() != null) {
+            if (counter == 0) {
+                assertTrue("The remote service process is still alive.", false);
+            }
+            Thread.sleep(300);
+            counter--;
+        }
+        super.tearDown();
+    }
+
+    // Call this to trigger the next step of service process
+    private void triggerServiceStep(RemoteProcessService.Step step) {
+        Message msg = Message.obtain(null, step.message);
+        msg.replyTo = localMessenger;
+        try {
+            remoteMessenger.send(msg);
+        } catch (RemoteException e) {
+            assertTrue(false);
+        }
+    }
+
+    // Return the service info if it is alive.
+    // When this method return null, it doesn't mean the remote process is not existed. An 'empty' process could
+    // be retained by the system to be used next time.
+    // Use getRemoteProcessInfo if you want to check the existence of remote process.
+    private ActivityManager.RunningServiceInfo getServiceInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningServiceInfo> serviceInfoList = manager.getRunningServices(Integer.MAX_VALUE);
+        for (ActivityManager.RunningServiceInfo service : serviceInfoList) {
+            if (RemoteProcessService.class.getName().equals(service.service.getClassName())) {
+                return service;
+            }
+        }
+        return null;
+    }
+
+    // Get the remote process info if it is alive.
+    private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
+        for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
+            if (info.processName.equals(getContext().getPackageName() + ":remote")) {
+                return info;
+            }
+        }
+
+        return null;
+    }
+
+    // A. Open a realm, close it, then call Runtime.getRuntime().exit(0).
+    // 1. Wait 3 seconds to see if the service process existed.
+    public void testExitProcess() {
+        new InterprocessHandler(new Runnable() {
+            @Override
+            public void run() {
+                // Step A
+                triggerServiceStep(RemoteProcessService.stepExitProcess_A);
+            }
+        }) {
+
+            @SuppressWarnings("ConstantConditions")
+            final int servicePid = getServiceInfo().pid;
+
+            @Override
+            public void handleMessage(Message msg) {
+                super.handleMessage(msg);
+                if (msg.what == RemoteProcessService.stepExitProcess_A.message) {
+                    // Step 1
+                    clearTimeoutFlag();
+                    try {
+                        // Timeout is 5 seconds. 3 (6x500ms) seconds should be enough to quit the process.
+                        for (int i = 1; i <= 6; i++) {
+                            // We need to retrieve the service's pid again since the system might restart it automatically.
+                            ActivityManager.RunningAppProcessInfo processInfo = getRemoteProcessInfo();
+                            if (processInfo != null && processInfo.pid == servicePid && i >= 6) {
+                                // The process is still alive.
+                                assertTrue(false);
+                            } else if (processInfo == null || processInfo.pid != servicePid) {
+                                // The process is gone
+                                break;
+                            }
+                            Thread.sleep(500, 0);
+                        }
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                        assertTrue(false);
+                    }
+                    done();
+                }
+            }
+        };
+        Looper.loop();
+    }
+
+    // 1. Main process create Realm, write one object.
+    // A. Service process open Realm, check if there is one and only one object.
+    public void testCreateInitialRealm() throws InterruptedException {
+        new InterprocessHandler(new Runnable() {
+            @Override
+            public void run() {
+                // Step 1
+                testRealm = Realm.getInstance(getContext());
+                assertEquals(testRealm.allObjects(AllTypes.class).size(), 0);
+                testRealm.beginTransaction();
+                testRealm.createObject(AllTypes.class);
+                testRealm.commitTransaction();
+
+                // Step A
+                triggerServiceStep(RemoteProcessService.stepCreateInitialRealm_A);
+            }}) {
+
+            @Override
+            public void handleMessage(Message msg) {
+                super.handleMessage(msg);
+                if (msg.what == RemoteProcessService.stepCreateInitialRealm_A.message) {
+                    clearTimeoutFlag();
+                    done();
+                } else {
+                    assertTrue(false);
+                }
+            }
+        };
+        Looper.loop();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
new file mode 100644
index 0000000000..fb03e29c8f
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -0,0 +1,1181 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Base64;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnnotationTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.NoPrimaryKeyNullTypes;
+import io.realm.entities.NullTypes;
+import io.realm.entities.OwnerPrimaryKey;
+import io.realm.exceptions.RealmException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmJsonTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getTargetContext();
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private InputStream convertJsonObjectToStream(JSONObject obj) {
+        return new ByteArrayInputStream(obj.toString().getBytes());
+    }
+
+    // Assert that the list of AllTypesPrimaryKey objects where inserted and updated properly.
+    private void assertAllTypesPrimaryKeyUpdated() {
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals("Bar", obj.getColumnString());
+        assertEquals(2.23F, obj.getColumnFloat(), 0F);
+        assertEquals(2.234D, obj.getColumnDouble(), 0D);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
+        assertEquals(new Date(2000), obj.getColumnDate());
+        assertEquals("Dog4", obj.getColumnRealmObject().getName());
+        assertEquals(2, obj.getColumnRealmList().size());
+        assertEquals("Dog5", obj.getColumnRealmList().get(0).getName());
+    }
+
+    // Check the imported object from nulltyps.json[0].
+    private void checkNullableValuesAreNull(NullTypes nullTypes1) {
+        // 1 String
+        assertNull(nullTypes1.getFieldStringNull());
+        assertEquals("", nullTypes1.getFieldStringNotNull());
+        // 2 Bytes
+        assertNull(nullTypes1.getFieldBytesNull());
+        assertTrue(Arrays.equals(new byte[0], nullTypes1.getFieldBytesNotNull()));
+        // 3 Boolean
+        assertNull(nullTypes1.getFieldBooleanNull());
+        assertFalse(nullTypes1.getFieldBooleanNotNull());
+        // 4 Byte
+        assertNull(nullTypes1.getFieldByteNull());
+        assertEquals(0, nullTypes1.getFieldByteNotNull().byteValue());
+        // 5 Short
+        assertNull(nullTypes1.getFieldShortNull());
+        assertEquals(0, nullTypes1.getFieldShortNotNull().shortValue());
+        // 6 Integer
+        assertNull(nullTypes1.getFieldIntegerNull());
+        assertEquals(0, nullTypes1.getFieldIntegerNotNull().intValue());
+        // 7 Long
+        assertNull(nullTypes1.getFieldLongNull());
+        assertEquals(0, nullTypes1.getFieldLongNotNull().longValue());
+        // 8 Float
+        assertNull(nullTypes1.getFieldFloatNull());
+        assertEquals((Float)0F, nullTypes1.getFieldFloatNotNull());
+        // 9 Double
+        assertNull(nullTypes1.getFieldDoubleNull());
+        assertEquals((Double)0D, nullTypes1.getFieldDoubleNotNull());
+        // 10 Date
+        assertNull(nullTypes1.getFieldDateNull());
+        assertEquals(new Date(0), nullTypes1.getFieldDateNotNull());
+        // 11 RealmObject
+        assertNull(nullTypes1.getFieldObjectNull());
+    }
+
+    // Check the imported object from nulltyps.json[1].
+    private void checkNullableValuesAreNotNull(NullTypes nullTypes2) {
+        // 1 String
+        assertEquals("", nullTypes2.getFieldStringNull());
+        assertEquals("", nullTypes2.getFieldStringNotNull());
+        // 2 Bytes
+        assertTrue(Arrays.equals(new byte[0], nullTypes2.getFieldBytesNull()));
+        assertTrue(Arrays.equals(new byte[0], nullTypes2.getFieldBytesNotNull()));
+        // 3 Boolean
+        assertFalse(nullTypes2.getFieldBooleanNull());
+        assertFalse(nullTypes2.getFieldBooleanNotNull());
+        // 4 Byte
+        assertEquals(0, nullTypes2.getFieldByteNull().byteValue());
+        assertEquals(0, nullTypes2.getFieldByteNotNull().byteValue());
+        // 5 Short
+        assertEquals(0, nullTypes2.getFieldShortNull().shortValue());
+        assertEquals(0, nullTypes2.getFieldShortNotNull().shortValue());
+        // 6 Integer
+        assertEquals(0, nullTypes2.getFieldIntegerNull().intValue());
+        assertEquals(0, nullTypes2.getFieldIntegerNotNull().intValue());
+        // 7 Long
+        assertEquals(0, nullTypes2.getFieldLongNull().longValue());
+        assertEquals(0, nullTypes2.getFieldLongNotNull().longValue());
+        // 8 Float
+        assertEquals((Float)0F, nullTypes2.getFieldFloatNull());
+        assertEquals((Float)0F, nullTypes2.getFieldFloatNotNull());
+        // 9 Double
+        assertEquals((Double)0D, nullTypes2.getFieldDoubleNull());
+        assertEquals((Double)0D, nullTypes2.getFieldDoubleNotNull());
+        // 10 Date
+        assertEquals(new Date(0), nullTypes2.getFieldDateNull());
+        assertEquals(new Date(0), nullTypes2.getFieldDateNotNull());
+        // 11 RealmObject
+        assertTrue(nullTypes2.getFieldObjectNull() != null);
+    }
+
+    @Test
+    public void createObject_fromJsonNullObject() {
+        realm.createObjectFromJson(AllTypes.class, (JSONObject) null);
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_nullArray() {
+        realm.createAllFromJson(AllTypes.class, (JSONArray) null);
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+
+    }
+
+    @Test
+    public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnString", "String");
+        json.put("columnLong", 1L);
+        json.put("columnFloat", 1.23F);
+        json.put("columnDouble", 1.23D);
+        json.put("columnBoolean", true);
+        json.put("columnBinary", new String(Base64.encode(new byte[] {1,2,3}, Base64.DEFAULT)));
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, json);
+        realm.commitTransaction();
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+
+        // Check that all primitive types are imported correctly
+        assertEquals("String", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1.23F, obj.getColumnFloat(),0F);
+        assertEquals(1.23D, obj.getColumnDouble(),0D);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
+    }
+
+    @Test
+    public void createObjectFromJson_dateAsLong() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnDate", 1000L); // Realm operates at seconds level granularity
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, json);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_dateAsString() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnDate", "/Date(1000)/");
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, json);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_dateAsStringTimeZone() throws JSONException {
+        // Oct 03 2015 14:45.33
+        JSONObject json = new JSONObject();
+        json.put("columnDate", "/Date(1443854733376+0800)/");
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, json);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        Calendar cal = GregorianCalendar.getInstance();
+        cal.setTimeZone(TimeZone.getTimeZone("Australia/West"));
+        cal.set(2015, Calendar.OCTOBER, 03, 14, 45, 33);
+        cal.set(Calendar.MILLISECOND, 0);
+        Date convDate = obj.getColumnDate();
+
+        assertEquals(convDate.getTime(), cal.getTime().getTime());
+    }
+
+    @Test
+    public void createObjectFromJson_childObject() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONObject dogObject = new JSONObject();
+        dogObject.put("name", "Fido");
+        allTypesObject.put("columnRealmObject", dogObject);
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, allTypesObject);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("Fido", obj.getColumnRealmObject().getName());
+    }
+
+    @Test
+    public void createObjectFromJson_childObjectList() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
+        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
+        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
+        JSONArray dogList = new JSONArray();
+        dogList.put(dog1);
+        dogList.put(dog2);
+        dogList.put(dog3);
+        allTypesObject.put("columnRealmList", dogList);
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, allTypesObject);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(3, obj.getColumnRealmList().size());
+        assertEquals("Fido-3", obj.getColumnRealmList().get(2).getName());
+    }
+
+    @Test
+    public void createObjectFromJson_emptyChildObjectList() throws JSONException {
+        JSONObject allTypesObject = new JSONObject();
+        JSONArray dogList = new JSONArray();
+        allTypesObject.put("columnRealmList", dogList);
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, allTypesObject);
+        realm.commitTransaction();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    @Test
+    public void createObjectFromJson_stringSimpleObject() {
+        realm.beginTransaction();
+        Dog dog = realm.createObjectFromJson(Dog.class, "{ name: \"Foo\" }");
+        realm. commitTransaction();
+
+        assertEquals("Foo", dog.getName());
+        assertEquals("Foo", realm.allObjects(Dog.class).first().getName());
+    }
+
+    @Test
+    public void createObjectFromJson_stringFaultyJsonThrows() {
+        realm.beginTransaction();
+        try {
+            realm.createObjectFromJson(Dog.class, "{ name \"Foo\" }");
+            fail("Faulty JSON should result in a RealmException");
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+        }
+    }
+
+    @Test
+    public void createObjectFromJson_stringNull() {
+        realm.beginTransaction();
+        Dog dog = realm.createObjectFromJson(Dog.class, (String) null);
+        realm.commitTransaction();
+
+        //noinspection ConstantConditions
+        assertNull(dog);
+        assertEquals(0, realm.allObjects(Dog.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_jsonArrayEmpty() {
+        JSONArray array = new JSONArray();
+        realm.beginTransaction();
+        realm.createAllFromJson(AllTypes.class, array);
+        realm.commitTransaction();
+
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_jsonArray() throws JSONException {
+        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
+        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
+        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
+        JSONArray dogList = new JSONArray();
+        dogList.put(dog1);
+        dogList.put(dog2);
+        dogList.put(dog3);
+
+        realm.beginTransaction();
+        realm.createAllFromJson(Dog.class, dogList);
+        realm.commitTransaction();
+
+        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+    // Test if Json object doesn't have the field, then the field should have default value.
+    @Test
+    public void createObjectFromJson_noValues() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("noThingHere", JSONObject.NULL);
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, json);
+        realm.commitTransaction();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("", obj.getColumnString());
+        assertEquals(0L, obj.getColumnLong());
+        assertEquals(0F, obj.getColumnFloat(), 0F);
+        assertEquals(0D, obj.getColumnDouble(), 0D);
+        assertEquals(false, obj.isColumnBoolean());
+        assertEquals(new Date(0), obj.getColumnDate());
+        assertArrayEquals(new byte[0], obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    // Test that given an exception everything up to the exception is saved
+    @Test
+    public void createObjectFromJson_jsonException() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("columnString", "Foo");
+        json.put("columnDate", "Boom");
+
+        realm.beginTransaction();
+        try {
+            realm.createObjectFromJson(AllTypes.class, json);
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+        }
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("Foo", obj.getColumnString());
+        assertEquals(new Date(0), obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_respectIgnoredFields() throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("indexString", "Foo");
+        json.put("notIndexString", "Bar");
+        json.put("ignoreString", "Baz");
+
+        realm.beginTransaction();
+        realm.createObjectFromJson(AnnotationTypes.class, json);
+        realm.commitTransaction();
+
+        AnnotationTypes annotationsObject = realm.allObjects(AnnotationTypes.class).first();
+        assertEquals("Foo", annotationsObject.getIndexString());
+        assertEquals(null, annotationsObject.getIgnoreString());
+    }
+
+    @Test
+    public void createAllFromJson_stringArraySimpleArray() {
+        realm.beginTransaction();
+        realm.createAllFromJson(Dog.class, "[{ name: \"Foo\" }, { name: \"Bar\" }]");
+        realm.commitTransaction();
+
+        assertEquals(2, realm.allObjects(Dog.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_stringArrayFaultyJsonThrows() {
+        realm.beginTransaction();
+        try {
+            realm.createAllFromJson(Dog.class, "[{ name : \"Foo\" ]");
+            fail("Faulty JSON should result in a RealmException");
+        } catch (RealmException ignored) {
+        } finally {
+            realm.commitTransaction();
+        }
+    }
+
+    @Test
+    public void createAllFromJson_stringArrayNull() {
+        realm.beginTransaction();
+        realm.createAllFromJson(Dog.class, (String) null);
+        realm.commitTransaction();
+
+        assertEquals(0, realm.allObjects(Dog.class).size());
+    }
+
+    @Test
+    public void createAllFromJson_streamNull() throws IOException {
+        realm.createAllFromJson(AllTypes.class, (InputStream) null);
+        assertEquals(0, realm.allObjects(AllTypes.class).size());
+    }
+
+    @Test
+    public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "all_simple_types.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("String", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1.23F, obj.getColumnFloat(), 0F);
+        assertEquals(1.23D, obj.getColumnDouble(), 0D);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
+    }
+
+    @Test
+    public void createObjectFromJson_streamDateAsLong() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_long.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_streamDateAsString() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_string.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(new Date(1000), obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_streamDateAsISO8601String() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "date_as_iso8601_string.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);
+        cal.setTimeZone(TimeZone.getTimeZone("GMT"));
+        cal.set(Calendar.MILLISECOND, 789);
+        Date date = cal.getTime();
+        cal.set(Calendar.MILLISECOND, 0);
+        Date dateZeroMillis = cal.getTime();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(dateZeroMillis, obj.getColumnDate());
+    }
+
+    @Test
+    public void createObjectFromJson_streamChildObject() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "single_child_object.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("Fido", obj.getColumnRealmObject().getName());
+    }
+
+    @Test
+    public void createObjectFromJson_streamEmptyChildObjectList() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "realmlist_empty.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    @Test
+    public void createObjectFromJson_streamChildObjectList() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "realmlist.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+    @Test
+    public void createAllFromJson_streamArray() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "array.json");
+        realm.beginTransaction();
+        realm.createAllFromJson(Dog.class, in);
+        realm.commitTransaction();
+
+        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
+    }
+
+
+    // Test if Json object doesn't have the field, then the field should have default value. Stream version.
+    @Test
+    public void createObjectFromJson_streamNoValues() throws IOException {
+        InputStream in = TestHelper.loadJsonFromAssets(context, "other_json_object.json");
+        realm.beginTransaction();
+        realm.createObjectFromJson(AllTypes.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        assertEquals("", obj.getColumnString());
+        assertEquals(0L, obj.getColumnLong());
+        assertEquals(0F, obj.getColumnFloat(), 0F);
+        assertEquals(0D, obj.getColumnDouble(), 0D);
+        assertEquals(false, obj.isColumnBoolean());
+        assertEquals(new Date(0), obj.getColumnDate());
+        assertArrayEquals(new byte[0], obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    /**
+     * Test update a existing object with JSON stream. Only primary key in JSON.
+     * No value should be changed.
+     */
+    @Test
+    public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        Date date = new Date(0);
+        obj.setColumnLong(1); // ID
+        obj.setColumnBinary(new byte[]{1});
+        obj.setColumnBoolean(true);
+        obj.setColumnDate(date);
+        obj.setColumnDouble(1);
+        obj.setColumnFloat(1);
+        obj.setColumnString("1");
+
+        realm.beginTransaction();
+        realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+        InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_primary_key_field_only.json");
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+        realm.commitTransaction();
+        in.close();
+
+        // Check that all primitive types are imported correctly
+        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals("1", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1F, obj.getColumnFloat(), 0F);
+        assertEquals(1D, obj.getColumnDouble(), 0D);
+        assertEquals(true, obj.isColumnBoolean());
+        assertEquals(date, obj.getColumnDate());
+        assertArrayEquals(new byte[]{1}, obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    // Test update a existing object with JSON object with only primary key.
+    // No value should be changed.
+    @Test
+    public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        Date date = new Date(0);
+        obj.setColumnLong(1); // ID
+        obj.setColumnBinary(new byte[]{1});
+        obj.setColumnBoolean(true);
+        obj.setColumnDate(date);
+        obj.setColumnDouble(1);
+        obj.setColumnFloat(1);
+        obj.setColumnString("1");
+
+        realm.beginTransaction();
+        realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "all_types_primary_key_field_only.json"));
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
+        realm.commitTransaction();
+
+        // Check that all primitive types are imported correctly
+        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals("1", obj.getColumnString());
+        assertEquals(1L, obj.getColumnLong());
+        assertEquals(1F, obj.getColumnFloat(), 0F);
+        assertEquals(1D, obj.getColumnDouble(), 0D);
+        assertEquals(true, obj.isColumnBoolean());
+        assertEquals(date, obj.getColumnDate());
+        assertArrayEquals(new byte[]{1}, obj.getColumnBinary());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+    @Test
+    public void createOrUpdateObject_noPrimaryKeyThrows() {
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypes.class, new JSONObject());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_streamNoPrimaryKeyThrows() throws IOException {
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypes.class, new TestHelper.StubInputStream());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_streamInvalidJSonCurlyBracketThrows() throws IOException {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_stringNoPrimaryKeyThrows() throws IOException {
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_withJsonObject() throws JSONException {
+        realm.beginTransaction();
+
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+        realm.copyToRealm(obj);
+
+        JSONObject json = new JSONObject();
+        json.put("columnLong", 1);
+        json.put("columnString", "bar");
+        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
+
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals("bar", newObj.getColumnString());
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_objectIgnoreUnsetProperties() throws IOException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
+        realm.commitTransaction();
+
+        // No-op as no properties should be updated
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1 }");
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_streamIgnoreUnsetProperties() throws IOException {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        realm.commitTransaction();
+
+        // No-op as no properties should be updated
+        realm.beginTransaction();
+        realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_inputStream() throws IOException {
+        realm.beginTransaction();
+
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+        realm.copyToRealm(obj);
+
+        InputStream in = TestHelper.stringToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
+        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals("bar", newObj.getColumnString());
+    }
+
+    @Test
+    public void createOrUpdateObjectFromJson_inputString() throws IOException {
+        realm.beginTransaction();
+
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+        realm.copyToRealm(obj);
+
+        AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals("bar", newObj.getColumnString());
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_jsonArrayNoPrimaryKeyThrows() {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypes.class, new JSONArray());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_streamNoPrimaryKeyThrows() throws IOException {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypes.class, new TestHelper.StubInputStream());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_streamInvalidJSonBracketThrows() throws IOException {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("["));
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_stringNoPrimaryKeyThrows() throws IOException {
+        try {
+            realm.createOrUpdateAllFromJson(AllTypes.class, "{}");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_jsonArray() throws JSONException, IOException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        JSONArray array = new JSONArray(json);
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, array);
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_inputStream() throws IOException {
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    @Test
+    public void createOrUpdateAllFromJson_inputString() throws IOException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
+        realm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    // Testing create objects from Json, all nullable fields with null values or non-null values
+    @Test
+    public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
+        JSONArray array = new JSONArray(json);
+        realm.beginTransaction();
+        realm.createAllFromJson(NullTypes.class, array);
+        realm.commitTransaction();
+
+        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        assertEquals(3, nullTypesRealmResults.size());
+
+        NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
+        checkNullableValuesAreNull(nullTypes1);
+
+        NullTypes nullTypes2 = nullTypesRealmResults.where().equalTo("id", 2).findFirst();
+        checkNullableValuesAreNotNull(nullTypes2);
+    }
+
+    // Test creating objects form JSON stream, all nullable fields with null values or non-null values
+    @Test
+    public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException {
+        realm.beginTransaction();
+        realm.createAllFromJson(NullTypes.class, TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
+        realm.commitTransaction();
+
+        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        assertEquals(3, nullTypesRealmResults.size());
+
+        NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
+        checkNullableValuesAreNull(nullTypes1);
+
+        NullTypes nullTypes2 = nullTypesRealmResults.where().equalTo("id", 2).findFirst();
+        checkNullableValuesAreNotNull(nullTypes2);
+    }
+
+    /**
+     * Test a nullable field already has a non-null value, update it through JSON with null value
+     * of the corresponding field.
+     */
+    @Test
+    public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOException, JSONException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
+        // Nullable fields with values
+        JSONArray jsonArray = new JSONArray(json);
+        JSONObject jsonObject = jsonArray.getJSONObject(1);
+        jsonObject.put("id", 1);
+
+        // Now object with id 1 has values for all nullable fields.
+        realm.beginTransaction();
+        realm.createObjectFromJson(NullTypes.class, jsonObject);
+        realm.commitTransaction();
+
+        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        assertEquals(2, nullTypesRealmResults.size());
+        checkNullableValuesAreNotNull(nullTypesRealmResults.first());
+
+        // Update object with id 1, nullable fields should have null values
+        JSONArray array = new JSONArray(json);
+        realm.beginTransaction();
+        realm.createOrUpdateAllFromJson(NullTypes.class, array);
+        realm.commitTransaction();
+
+        nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        assertEquals(3, nullTypesRealmResults.size());
+
+        NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
+        checkNullableValuesAreNull(nullTypes1);
+    }
+
+    /**
+     * If JSON has a field with value null, and corresponding object's field is not nullable,
+     * an exception should be throw.
+     */
+    @Test
+    public void createObjectFromJson_nullTypesJSONToNotNullFields() throws IOException, JSONException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes_invalid.json"));
+        JSONArray array = new JSONArray(json);
+        realm.beginTransaction();
+
+        // 1 String
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(0));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 2 Bytes
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(1));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 3 Boolean
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(2));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 4 Byte
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(3));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 5 Short
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(4));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 6 Integer
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(5));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 7 Long
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(6));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 8 Float
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(7));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 9 Double
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(8));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+        // 10 Date
+        try {
+            realm.createObjectFromJson(NullTypes.class, array.getJSONObject(9));
+            fail();
+        } catch (RealmException expected) {
+            assertTrue(expected.getCause() instanceof IllegalArgumentException);
+        }
+
+        realm.cancelTransaction();
+    }
+
+    /**
+     * If JSON has a field with value null, and corresponding object's field is not nullable,
+     * an exception should be throw. Stream version.
+     */
+    @Test
+    public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOException, JSONException {
+        String json = TestHelper.streamToString(TestHelper.loadJsonFromAssets(context, "nulltypes_invalid.json"));
+        JSONArray array = new JSONArray(json);
+
+        // 1 String
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(0)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 2 Bytes
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(1)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 3 Boolean
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(2)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 4 Byte
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(3)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 5 Short
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(4)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 6 Integer
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(5)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 7 Long
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(6)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 8 Float
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(7)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 9 Double
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(8)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+        // 10 Date
+        try {
+            realm.beginTransaction();
+            realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, convertJsonObjectToStream(array.getJSONObject(9)));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    /**
+     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail)
+     */
+    @Test
+    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
+        JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, newObject);
+        realm.commitTransaction();
+
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
+    }
+
+    /**
+     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail)
+     */
+    @Test
+    public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
+        JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObjectFromJson(OwnerPrimaryKey.class, newObject);
+        realm.commitTransaction();
+
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
+    }
+
+    /**
+     * Check that using createOrUpdateObject will set the primary key directly instead of first setting
+     * it to the default value (which can fail)
+     */
+    @Test
+    public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
+        InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, stream);
+        realm.commitTransaction();
+
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
+    }
+
+    /**
+     * createObject using primary keys doesn't work if the Check that using createOrUpdateObject
+     * will set the primary key directly instead of first setting it to the default value (which can fail)
+     */
+    @Test
+    public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
+        InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObjectFromJson(OwnerPrimaryKey.class, stream);
+        realm.commitTransaction();
+
+        RealmResults<OwnerPrimaryKey> owners = realm.where(OwnerPrimaryKey.class).findAll();
+        assertEquals(2, owners.size());
+        assertEquals(1, owners.get(1).getId());
+        assertEquals("bar", owners.get(1).getName());
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
similarity index 87%
rename from realm/src/androidTest/java/io/realm/RealmLinkTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 81d8d04d85..f5d0e79933 100644
--- a/realm/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -20,6 +20,7 @@
 
 import java.util.Date;
 
+import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
@@ -29,8 +30,9 @@
     protected Realm testRealm;
 
     protected void setUp() {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
 
         testRealm.beginTransaction();
         testRealm.clear(Dog.class);
@@ -148,9 +150,11 @@ public void testQuerySingleRelationInteger() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.age", 1, 20).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.age", 1, 20).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     public void testQuerySingleRelationDate() {
@@ -184,9 +188,12 @@ public void testQuerySingleRelationDate() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.birthday", new Date(1), new Date(10000)).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            testRealm.where(Owner.class).between("cat.birthday", new Date(1), new Date(10000)).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            // Between does not support link queries.
+        }
     }
 
     public void testQuerySingleRelationFloat() {
@@ -214,9 +221,11 @@ public void testQuerySingleRelationFloat() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.height", 0.2f, 2.2f).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.height", 0.2f, 2.2f).findAll();
+        }
+        catch (IllegalArgumentException ignored) {
+        }
     }
 
     public void testQuerySingleRelationDouble() {
@@ -244,9 +253,12 @@ public void testQuerySingleRelationDouble() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.weight", 0.2, 2.2).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.weight", 0.2, 2.2).findAll();
+            fail();
+        }
+        catch (IllegalArgumentException ignored) {
+        }
     }
 
 
@@ -272,7 +284,7 @@ public void testQuerySingleRelationString() {
         RealmResults<Owner> owners5 = testRealm.where(Owner.class).contains("cat.name", "Blackie").findAll();
         assertEquals(1, owners5.size());
 
-        RealmResults<Owner> owners6 = testRealm.where(Owner.class).equalTo("cat.name", "blackIE", RealmQuery.CASE_INSENSITIVE).findAll();
+        RealmResults<Owner> owners6 = testRealm.where(Owner.class).equalTo("cat.name", "blackIE", Case.INSENSITIVE).findAll();
         assertEquals(1, owners6.size());
     }
 
@@ -309,8 +321,11 @@ public void testQueryMultipleRelationsInteger() {
         RealmResults<Owner> owners6 = testRealm.where(Owner.class).lessThanOrEqualTo("dogs.age", 9).findAll();
         assertEquals(1, owners6.size());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.age", 9, 11).findAll();
-        assertEquals(1, owners7.size());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.age", 9, 11).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     public void testQueryMultipleRelationsDate() {
@@ -338,8 +353,12 @@ public void testQueryMultipleRelationsDate() {
         RealmResults<Owner> owners6 = testRealm.where(Owner.class).lessThanOrEqualTo("dogs.birthday", new Date(10000)).findAll();
         assertEquals(1, owners6.size());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.birthday", new Date(1000), new Date(3000)).findAll();
-        assertEquals(1, owners7.size());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.birthday", new Date(1000), new Date(3000)).findAll();
+            fail();
+        } catch (IllegalArgumentException ignore) {
+            // Between does not support link queries.
+        }
     }
 
     public void testQueryMultipleRelationsFloat() {
@@ -367,9 +386,12 @@ public void testQueryMultipleRelationsFloat() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.height", 0.2f, 2.2f).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.height", 0.2f, 2.2f).findAll();
+            fail();
+        }
+        catch (IllegalArgumentException ignored) {
+        }
     }
 
     public void testQueryMultipleRelationsDouble() {
@@ -397,9 +419,12 @@ public void testQueryMultipleRelationsDouble() {
         assertEquals(1, owners6.size());
         assertEquals(12, owners6.first().getCat().getAge());
 
-        RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.weight", 0.2, 12.2).findAll();
-        assertEquals(1, owners7.size());
-        assertEquals(12, owners7.first().getCat().getAge());
+        try {
+            RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.weight", 0.2, 12.2).findAll();
+            fail();
+        }
+        catch (IllegalArgumentException ignored) {
+        }
     }
 
 
@@ -430,20 +455,22 @@ public void testQueryShouldFail() {
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat..hasTail", true).findAll();
             fail("Should throw Exception");
-        } catch (IllegalArgumentException e) {
-
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo(".cat.hasTail", true).findAll();
+            fail("Should throw Exception");
+        } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat.hasTail.", true).findAll();
             fail("Should throw Exception");
-        } catch (IllegalArgumentException e) {
-
+        } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("not.there", true).findAll();
             fail("Should throw Exception");
-        } catch (IllegalArgumentException e) {
-
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -476,18 +503,6 @@ public void testLinkIsNull() {
         assertEquals(1, owners2.size());
     }
 
-    public void testLinkListIsNull() {
-        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("dogs").findAll();
-        assertEquals(0, owners1.size());
-
-        testRealm.beginTransaction();
-        testRealm.clear(Dog.class);
-        testRealm.commitTransaction();
-
-        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("dogs").findAll();
-        assertEquals(1, owners2.size());
-    }
-
     public void testLinkIsNotNull() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("cat").findAll();
         assertEquals(1, owners1.size());
@@ -500,24 +515,12 @@ public void testLinkIsNotNull() {
         assertEquals(0, owners2.size());
     }
 
-    public void testLinkListIsNotNull() {
-        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
-        assertEquals(1, owners1.size());
-
-        testRealm.beginTransaction();
-        testRealm.clear(Dog.class);
-        testRealm.commitTransaction();
-
-        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
-        assertEquals(0, owners2.size());
-    }
-
     public void testIsNullWrongType() {
         try {
-            // Owner.name is a String
-            RealmResults<Owner> owners = testRealm.where(Owner.class).isNull("name").findAll();
+            // AllTypes.columnFloat is not nullable
+            testRealm.where(AllTypes.class).isNull("columnFloat").findAll();
             fail();
-        } catch (IllegalArgumentException expected) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
new file mode 100644
index 0000000000..5f9942429b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -0,0 +1,1187 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.Collections;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.CyclicType;
+import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.Dog;
+import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmListTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+    private static final int TEST_OBJECTS = 10;
+    private Realm testRealm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        testRealm = Realm.getInstance(realmConfig);
+
+        testRealm.beginTransaction();
+        Owner owner = testRealm.createObject(Owner.class);
+        owner.setName("Owner");
+        for (int i = 0; i < TEST_OBJECTS; i++) {
+            Dog dog = testRealm.createObject(Dog.class);
+            dog.setName("Dog " + i);
+            owner.getDogs().add(dog);
+        }
+        testRealm.commitTransaction();
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (testRealm != null) {
+            testRealm.close();
+        }
+    }
+
+    private RealmList<Dog> createNonManagedDogList() {
+        RealmList<Dog> list = new RealmList<Dog>();
+        for (int i = 0; i < TEST_OBJECTS; i++) {
+            list.add(new Dog("Dog " + i));
+        }
+        return list;
+    }
+
+    private RealmList<Dog> createDeletedRealmList() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        testRealm.beginTransaction();
+        owner.removeFromRealm();
+        testRealm.commitTransaction();
+        return dogs;
+    }
+
+    // Check that all methods work correctly on a empty RealmList
+    private void checkMethodsOnEmptyList(Realm realm, RealmList<Dog> list) {
+        realm.beginTransaction();
+        for (int i = 0; i < 4; i++) {
+            //noinspection TryWithIdenticalCatches
+            try {
+                switch (i) {
+                    case 0: list.get(0); break;
+                    case 1: list.remove(0); break;
+                    case 2: list.set(0, new Dog()); break;
+                    case 3: list.move(0, 0); break;
+                    default: break;
+                }
+                fail();
+            } catch (IndexOutOfBoundsException ignored) {
+            } catch (RealmException ignored) {
+            }
+        }
+        realm.cancelTransaction();
+
+        assertEquals(0, list.size());
+        assertNull(list.first());
+        assertNull(list.last());
+    }
+
+    /*********************************************************
+     * Non-Managed mode tests                                *
+     *********************************************************/
+
+    @Test
+    public void isValid_nonManagedMode() {
+        //noinspection MismatchedQueryAndUpdateOfCollection
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        assertFalse(list.isValid());
+    }
+
+    @Test (expected = RealmException.class)
+    public void where_nonManagedMode() {
+        new RealmList<AllTypes>().where();
+    }
+
+    @Test
+    public void add_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object = new AllTypes();
+        object.setColumnString("String");
+        list.add(object);
+        assertEquals(1, list.size());
+        assertEquals(object, list.get(0));
+    }
+
+    @Test (expected = IllegalArgumentException.class)
+    public void add_nullInNonManagedMode() {
+        new RealmList<AllTypes>().add(null);
+    }
+
+    @Test
+    public void add_managedObjectInNonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        testRealm.beginTransaction();
+        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
+        testRealm.commitTransaction();
+        list.add(managedAllTypes);
+
+        assertEquals(managedAllTypes, list.get(0));
+    }
+
+    @Test
+    public void add_standaloneObjectAtIndexInNonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object = new AllTypes();
+        object.setColumnString("String");
+        list.add(0, object);
+        assertEquals(1, list.size());
+        assertEquals(object, list.get(0));
+    }
+
+    @Test
+    public void add_ManagedObjectAtIndexInNonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        list.add(new AllTypes());
+        testRealm.beginTransaction();
+        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
+        testRealm.commitTransaction();
+        list.add(0, managedAllTypes);
+
+        assertEquals(managedAllTypes, list.get(0));
+    }
+
+    @Test (expected = IllegalArgumentException.class)
+    public void add_nullAtIndexInNonManagedMode() {
+        new RealmList<AllTypes>().add(0, null);
+    }
+
+    @Test
+    public void set_nonManagedMode() {
+        RealmList<Dog> list = new RealmList<Dog>();
+        Dog dog1 = new Dog("dog1");
+        Dog dog2 = new Dog("dog2");
+        list.add(dog1);
+        assertEquals(dog1, list.set(0, dog2));
+        assertEquals(1, list.size());
+    }
+
+    @Test
+    public void set_managedMode() {
+        testRealm.beginTransaction();
+        try {
+            RealmList<Dog> list = testRealm.createObject(Owner.class).getDogs();
+            Dog dog1 = testRealm.createObject(Dog.class);
+            dog1.setName("dog1");
+            Dog dog2 = testRealm.createObject(Dog.class);
+            dog2.setName("dog2");
+            list.add(dog1);
+            assertEquals(dog1, list.set(0, dog2));
+            assertEquals(1, list.size());
+        } finally {
+            testRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void set_nullInNonManagedMode() {
+        @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        list.add(new AllTypes());
+        thrown.expect(IllegalArgumentException.class);
+        list.set(0, null);
+    }
+
+    @Test
+    public void set_managedObjectInNonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        list.add(new AllTypes());
+        testRealm.beginTransaction();
+        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
+        testRealm.commitTransaction();
+        list.set(0, managedAllTypes);
+
+        assertEquals(managedAllTypes, list.get(0));
+    }
+
+    @Test
+    public void clear_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        list.add(new AllTypes());
+        assertEquals(1, list.size());
+        list.clear();
+        assertTrue(list.isEmpty());
+    }
+
+    @Test
+    public void remove_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object1 = new AllTypes();
+        list.add(object1);
+        AllTypes object2 = list.remove(0);
+        assertEquals(object1, object2);
+    }
+
+    @Test
+    public void get_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object1 = new AllTypes();
+        list.add(object1);
+        AllTypes object2 = list.get(0);
+        assertEquals(object1, object2);
+    }
+
+    @Test
+    public void size_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        list.add(new AllTypes());
+        assertEquals(1, list.size());
+    }
+
+    // Test move where oldPosition > newPosition
+    @Test
+    public void move_down() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        Dog dog1 = owner.getDogs().get(1);
+        testRealm.beginTransaction();
+        owner.getDogs().move(1, 0);
+        testRealm.commitTransaction();
+
+        assertEquals(0, owner.getDogs().indexOf(dog1));
+    }
+
+    // Test move where oldPosition < newPosition
+    @Test
+    public void move_up() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        int oldIndex = TEST_OBJECTS / 2;
+        int newIndex = oldIndex + 1;
+        Dog dog = owner.getDogs().get(oldIndex);
+        testRealm.beginTransaction();
+        owner.getDogs().move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
+        testRealm.commitTransaction();
+
+        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+        assertEquals(newIndex, owner.getDogs().indexOf(dog));
+    }
+
+    @Test
+    public void first_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object1 = new AllTypes();
+        AllTypes object2 = new AllTypes();
+        list.add(object1);
+        list.add(object2);
+
+        assertEquals(object1, list.first());
+    }
+
+    @Test
+    public void last_nonManagedMode() {
+        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        AllTypes object1 = new AllTypes();
+        AllTypes object2 = new AllTypes();
+        list.add(object1);
+        list.add(object2);
+
+        assertEquals(object2, list.last());
+    }
+
+    @Test
+    public void allMethods_emptyListInNonManagedMode() {
+        RealmList<Dog> list = new RealmList<Dog>();
+        checkMethodsOnEmptyList(testRealm, list);
+    }
+
+    // Test move where oldPosition > newPosition
+    @Test
+    public void move_downInNonManagedMode() {
+        RealmList<Dog> dogs = createNonManagedDogList();
+        Dog dog1 = dogs.get(1);
+        dogs.move(1, 0);
+
+        assertEquals(0, dogs.indexOf(dog1));
+    }
+
+    // Test move where oldPosition < newPosition
+    @Test
+    public void move_upInNonManagedMode() {
+        RealmList<Dog> dogs = createNonManagedDogList();
+        int oldIndex = TEST_OBJECTS / 2;
+        int newIndex = oldIndex + 1;
+        Dog dog = dogs.get(oldIndex);
+        dogs.move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
+
+        assertEquals(TEST_OBJECTS, dogs.size());
+        assertEquals(oldIndex, dogs.indexOf(dog));
+    }
+
+    /*********************************************************
+     * Managed mode tests                                    *
+     *********************************************************/
+
+    @Test
+    public void isValid() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        assertTrue(dogs.isValid());
+
+        testRealm.close();
+        assertFalse(dogs.isValid());
+    }
+
+    @Test
+    public void isValid_whenParentRemoved() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        testRealm.beginTransaction();
+        owner.removeFromRealm();
+        testRealm.commitTransaction();
+
+        // RealmList contained in removed object is invalid.
+        assertFalse(dogs.isValid());
+    }
+
+    @Test
+    public void move_outOfBoundsLowerThrows() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
+        try {
+            owner.getDogs().move(0, -1);
+            fail("Indexes < 0 should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+        } finally {
+            testRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void move_outOfBoundsHigherThrows() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
+        try {
+            int lastIndex = TEST_OBJECTS - 1;
+            int outOfBoundsIndex = TEST_OBJECTS;
+            owner.getDogs().move(lastIndex, outOfBoundsIndex);
+            fail("Indexes >= size() should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+            ignored.printStackTrace();
+        } finally {
+            testRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void add_managedObjectToManagedList() {
+        testRealm.beginTransaction();
+        testRealm.clear(Owner.class);
+        Owner owner = testRealm.createObject(Owner.class);
+        Dog dog = testRealm.createObject(Dog.class);
+        owner.getDogs().add(dog);
+        testRealm.commitTransaction();
+
+        assertEquals(1, testRealm.where(Owner.class).findFirst().getDogs().size());
+    }
+
+    // Test that add correctly uses Realm.copyToRealm() on standalone objects.
+    @Test
+    public void add_nonManagedObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicType parent = testRealm.createObject(CyclicType.class);
+        RealmList<CyclicType> children = parent.getObjects();
+        children.add(new CyclicType());
+        testRealm.commitTransaction();
+        assertEquals(1, testRealm.where(CyclicType.class).findFirst().getObjects().size());
+    }
+
+    // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
+    @Test
+    public void add_nonManagedPrimaryKeyObjectToManagedList() {
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
+        RealmList<CyclicTypePrimaryKey> children = testRealm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
+        children.add(new CyclicTypePrimaryKey(2, "new"));
+        testRealm.commitTransaction();
+
+        assertEquals(1, testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getObjects().size());
+        assertEquals("new", testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
+    }
+
+    // Test that set correctly uses Realm.copyToRealm() on standalone objects.
+    @Test
+    public void set_nonManagedObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicType parent = testRealm.copyToRealm(new CyclicType("Parent"));
+        RealmList<CyclicType> children = parent.getObjects();
+        children.add(new CyclicType());
+        children.add(new CyclicType("original"));
+        children.add(new CyclicType());
+        children.set(1, new CyclicType("updated"));
+        testRealm.commitTransaction();
+
+        RealmList<CyclicType> list = testRealm.where(CyclicType.class).findFirst().getObjects();
+        assertEquals(3, list.size());
+        assertEquals("updated", list.get(1).getName());
+        assertEquals(5, testRealm.where(CyclicType.class).count());
+    }
+
+    // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
+    @Test
+    public void  set_nonManagedPrimaryKeyObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicTypePrimaryKey parent = testRealm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
+        RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
+        children.add(new CyclicTypePrimaryKey(2));
+        children.add(new CyclicTypePrimaryKey(3, "original"));
+        children.add(new CyclicTypePrimaryKey(4));
+        children.set(1, new CyclicTypePrimaryKey(3, "updated"));
+        testRealm.commitTransaction();
+
+        RealmList<CyclicTypePrimaryKey> list = testRealm.where(CyclicTypePrimaryKey.class).findFirst().getObjects();
+        assertEquals(3, list.size());
+        assertEquals("updated", list.get(1).getName());
+    }
+
+    @Test
+    public void add_nullToManagedListThrows() {
+        testRealm.beginTransaction();
+        Owner owner = testRealm.createObject(Owner.class);
+        thrown.expect(IllegalArgumentException.class);
+        owner.getDogs().add(null);
+    }
+
+    @Test
+    public void size() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+    }
+
+    @Test
+    public void getObjects() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        assertNotNull(dogs);
+        assertEquals("Dog 1", dogs.get(1).getName());
+    }
+
+    @Test
+    public void first() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        assertEquals("Dog 0", dogs.first().getName());
+    }
+
+    @Test
+    public void last() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        assertEquals("Dog " + (TEST_OBJECTS - 1), dogs.last().getName());
+    }
+
+    @Test
+    public void remove_byIndex() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        Dog dog5 = dogs.get(5);
+
+        testRealm.beginTransaction();
+        Dog removedDog = dogs.remove(5);
+        testRealm.commitTransaction();
+
+        assertEquals(dog5, removedDog);
+        assertEquals(TEST_OBJECTS - 1, dogs.size());
+    }
+
+    @Test
+    public void remove_last() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        testRealm.beginTransaction();
+        dogs.remove(TEST_OBJECTS - 1);
+        testRealm.commitTransaction();
+
+        assertEquals(TEST_OBJECTS - 1, dogs.size());
+    }
+
+    @Test
+    public void remove_fromEmptyListThrows() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        testRealm.beginTransaction();
+        dogs.clear();
+        thrown.expect(IndexOutOfBoundsException.class);
+        dogs.remove(0);
+    }
+
+    @Test
+    public void remove_byObject() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        Dog dog = dogs.get(0);
+
+        testRealm.beginTransaction();
+        boolean result = dogs.remove(dog);
+        testRealm.commitTransaction();
+
+        assertTrue(result);
+        assertEquals(TEST_OBJECTS - 1, dogs.size());
+    }
+
+    @Test
+    public void add_atAfterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Dog");
+        thrown.expect(IllegalStateException.class);
+        dogs.add(0, dog);
+    }
+
+    @Test
+    public void add_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Dog");
+        thrown.expect(IllegalStateException.class);
+        dogs.add(dog);
+    }
+
+    @Test
+    public void set_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Dog");
+        thrown.expect(IllegalStateException.class);
+        dogs.set(0, dog);
+    }
+
+    @Test
+    public void move_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        thrown.expect(IllegalStateException.class);
+        dogs.move(0, 1);
+    }
+
+    @Test
+    public void clear_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        thrown.expect(IllegalStateException.class);
+        dogs.clear();
+    }
+
+    @Test
+    public void remove_atAfterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Dog");
+        thrown.expect(IllegalStateException.class);
+        dogs.remove(0);
+    }
+
+    @Test
+    public void remove_bbjectAfterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        Dog dog = testRealm.createObject(Dog.class);
+        dog.setName("Dog");
+        thrown.expect(IllegalStateException.class);
+        dogs.remove(dog);
+    }
+
+    @Test
+    public void remove_allAfterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        testRealm.beginTransaction();
+        thrown.expect(IllegalStateException.class);
+        dogs.removeAll(Collections.<Dog>emptyList());
+    }
+
+    @Test
+    public void get_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+        thrown.expect(IllegalStateException.class);
+        dogs.get(0);
+    }
+
+    @Test
+    public void first_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        thrown.expect(IllegalStateException.class);
+        dogs.first();
+    }
+
+    @Test
+    public void last_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        thrown.expect(IllegalStateException.class);
+        dogs.last();
+    }
+
+    @Test
+    public void size_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        thrown.expect(IllegalStateException.class);
+        dogs.size();
+    }
+
+    @Test
+    public void where_afterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        thrown.expect(IllegalStateException.class);
+        dogs.where();
+    }
+
+    @Test
+    public void toString_AfterContainerObjectRemoved() {
+        RealmList<Dog> dogs = createDeletedRealmList();
+
+        assertEquals("Dog@[invalid]", dogs.toString());
+    }
+
+    @Test
+    public void query() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        Dog firstDog = dogs.where().equalTo("name", "Dog 0").findFirst();
+
+        assertNotNull(firstDog);
+    }
+
+    @Test
+    public void allMethods_emptyListInManagedMode() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
+        owner.getDogs().clear();
+        testRealm.commitTransaction();
+
+        checkMethodsOnEmptyList(testRealm, owner.getDogs());
+    }
+
+    @Test
+    public void clear() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
+        assertEquals(TEST_OBJECTS, owner.getDogs().size());
+        owner.getDogs().clear();
+        assertEquals(0, owner.getDogs().size());
+        testRealm.commitTransaction();
+    }
+
+    @Test
+    public void clear_NotDeleting() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
+        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
+        owner.getDogs().clear();
+        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
+        testRealm.commitTransaction();
+    }
+
+    @Test
+    public void contains() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        Dog dog = owner.getDogs().get(0);
+        assertTrue("Should contain a particular dog.", owner.getDogs().contains(dog));
+    }
+
+    /**
+     * Test to see if a particular item that does exist in the same Realm does not
+     * exist in a query that excludes said item.
+     */
+    @Test
+    public void contains_sameRealmNotContained() {
+        RealmResults<Dog> dogs = testRealm.where(Dog.class)
+                .equalTo("name", "Dog 1").or().equalTo("name", "Dog 2").findAll();
+        Dog thirdDog = testRealm.where(Dog.class)
+                .equalTo("name", "Dog 3").findFirst();
+        assertFalse("Should not contain a particular dog.", dogs.contains(thirdDog));
+    }
+
+    @Test
+    public void contains_inNonManagedList() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> managedDogs = owner.getDogs();
+        // Create a non-managed RealmList
+        RealmList<Dog> nonManagedDogs
+                = new RealmList<Dog>(managedDogs.toArray(new Dog[managedDogs.size()]));
+        Dog dog = managedDogs.get(0);
+        assertTrue("Should contain a particular dog", nonManagedDogs.contains(dog));
+    }
+
+    @Test
+    public void contains_null() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        assertFalse("Should not contain a null item.", owner.getDogs().contains(null));
+    }
+
+    /**
+     * Test that the {@link Realm#contains(Class)} method of one Realm will not contain a
+     * {@link RealmObject} from another Realm.
+     */
+    @Test
+    public void contains_doesNotContainAnItem() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("contains_test.realm");
+        Realm testRealmTwo = Realm.getInstance(realmConfig);
+        try {
+            // Set up the test realm
+            testRealmTwo.beginTransaction();
+            Owner owner2 = testRealmTwo.createObject(Owner.class);
+            owner2.setName("Owner");
+            for (int i = 0; i < TEST_OBJECTS; i++) {
+                Dog dog = testRealmTwo.createObject(Dog.class);
+                dog.setName("Dog " + i);
+                owner2.getDogs().add(dog);
+            }
+            testRealmTwo.commitTransaction();
+
+            // Get a dog from the test realm.
+            Dog dog2 = testRealmTwo.where(Owner.class).findFirst().getDogs().get(0);
+
+            // Access the original Realm. Then see if the above dog object is contained. (It shouldn't).
+            Owner owner1 = testRealm.where(Owner.class).findFirst();
+
+            assertFalse("Should not be able to find one object in another Realm via contains",
+                    owner1.getDogs().contains(dog2));
+        } finally {
+            if (testRealmTwo != null && !testRealmTwo.isClosed()) {
+                testRealmTwo.close();
+            }
+        }
+    }
+
+    @Test
+    public void contains_shouldNotContainDeletedRealmObject() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        Dog dog1 = dogs.get(0);
+        testRealm.beginTransaction();
+        dog1.removeFromRealm();
+        testRealm.commitTransaction();
+        assertFalse("Should not contain a deleted RealmObject", dogs.contains(dog1));
+    }
+
+    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
+    @Test
+    public void mutableMethods_OutsideTransactions() {
+        testRealm.beginTransaction();
+        RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
+        Dog dog = testRealm.createObject(Dog.class);
+        list.add(dog);
+        testRealm.commitTransaction();
+
+        try { list.add(dog);    fail(); } catch (IllegalStateException ignored) {}
+        try { list.add(0, dog); fail(); } catch (IllegalStateException ignored) {}
+        try { list.clear();     fail(); } catch (IllegalStateException ignored) {}
+        try { list.move(0, 1);  fail(); } catch (IllegalStateException ignored) {}
+        try { list.remove(0);   fail(); } catch (IllegalStateException ignored) {}
+        try { list.set(0, dog); fail(); } catch (IllegalStateException ignored) {}
+    }
+
+    private enum Method {
+        METHOD_ADD,
+        METHOD_ADD_AT,
+        METHOD_CLEAR,
+        METHOD_MOVE,
+        METHOD_REMOVE,
+        METHOD_SET
+    }
+
+    // Calling methods from the wrong thread should fail
+    private boolean methodWrongThread(final Method method) throws InterruptedException, ExecutionException {
+        testRealm.beginTransaction();
+        testRealm.clear(AllTypes.class);
+        testRealm.clear(Dog.class);
+        final RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
+        Dog dog = testRealm.createObject(Dog.class);
+        list.add(dog);
+        testRealm.commitTransaction();
+
+        testRealm.beginTransaction(); // Make sure that a valid transaction has begun on the correct thread
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case METHOD_ADD:
+                            list.add(new Dog());
+                            break;
+                        case METHOD_ADD_AT:
+                            list.add(1, new Dog());
+                            break;
+                        case METHOD_CLEAR:
+                            list.clear();
+                            break;
+                        case METHOD_MOVE:
+                            list.add(new Dog());
+                            list.move(0, 1);
+                            break;
+                        case METHOD_REMOVE:
+                            list.remove(0);
+                            break;
+                        case METHOD_SET:
+                            list.set(0, new Dog());
+                            break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                }
+            }
+        });
+
+        boolean result = future.get();
+        testRealm.cancelTransaction();
+        return result;
+    }
+
+    @Test
+    public void methods_ThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        for (Method method : Method.values()) {
+            assertTrue(method.toString(), methodWrongThread(method));
+        }
+    }
+
+    @Test
+    public void setList_ClearsOldItems() {
+        testRealm.beginTransaction();
+        CyclicType one = testRealm.copyToRealm(new CyclicType());
+        CyclicType two = testRealm.copyToRealm(new CyclicType());
+        two.setObjects(new RealmList<CyclicType>(one));
+        two.setObjects(new RealmList<CyclicType>(one));
+        testRealm.commitTransaction();
+
+        assertEquals(1, two.getObjects().size());
+    }
+
+    @Test
+    public void removeAllFromRealm() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        assertEquals(TEST_OBJECTS, dogs.size());
+
+        testRealm.beginTransaction();
+        dogs.deleteAllFromRealm();
+        testRealm.commitTransaction();
+        assertEquals(0, dogs.size());
+        assertEquals(0, testRealm.where(Dog.class).count());
+    }
+
+    @Test
+    public void removeAllFromRealm_notManagedList() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        assertEquals(TEST_OBJECTS, dogs.size());
+
+        RealmList<Dog> notManagedDogs = new RealmList<Dog>();
+        for (Dog dog : dogs) {
+            notManagedDogs.add(dog);
+        }
+
+        testRealm.beginTransaction();
+        notManagedDogs.deleteAllFromRealm();
+        testRealm.commitTransaction();
+        assertEquals(0, dogs.size());
+        assertEquals(0, notManagedDogs.size());
+        assertEquals(0, testRealm.where(Dog.class).count());
+    }
+
+    @Test
+    public void removeAllFromRealm_outsideTransaction() {
+        Owner owner = testRealm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+        try {
+            dogs.deleteAllFromRealm();
+            fail("removeAllFromRealm should be called in a transaction.");
+        } catch (IllegalStateException e) {
+            assertEquals("Changing Realm data can only be done from inside a transaction.", e.getMessage());
+        }
+    }
+
+    @Test
+    public void removeAllFromRealm_listWithStandaloneObjectShouldThrow() {
+        final RealmList<Dog> list = new RealmList<Dog>();
+
+        testRealm.beginTransaction();
+        Dog dog1 = testRealm.where(Dog.class).findFirst();
+        testRealm.commitTransaction();
+        Dog dog2 = new Dog();
+
+        list.add(dog1);
+        list.add(dog2);
+
+        testRealm.beginTransaction();
+        try {
+            list.deleteAllFromRealm();
+            fail("Cannot remove a list with a standalone object in it!");
+        } catch (IllegalStateException e) {
+            assertEquals("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with" +
+                    " Realm.createObject()", e.getMessage());
+        } finally {
+            testRealm.cancelTransaction();
+        }
+
+        assertEquals(TEST_OBJECTS, testRealm.where(Dog.class).count());
+        assertEquals(2, list.size());
+    }
+
+    @Test
+    public void removeAllFromRealm_emptyList() {
+        RealmList<Dog> dogs = testRealm.where(Owner.class).findFirst().getDogs();
+        assertEquals(TEST_OBJECTS, dogs.size());
+
+        testRealm.beginTransaction();
+        dogs.deleteAllFromRealm();
+        testRealm.commitTransaction();
+        assertEquals(0, dogs.size());
+        assertEquals(0, testRealm.where(Dog.class).count());
+
+        // The dogs is empty now.
+        testRealm.beginTransaction();
+        dogs.deleteAllFromRealm();
+        testRealm.commitTransaction();
+        assertEquals(0, dogs.size());
+        assertEquals(0, testRealm.where(Dog.class).count());
+
+    }
+
+    @Test
+    public void removeAllFromRealm_invalidListShouldThrow() {
+        RealmList<Dog> dogs = testRealm.where(Owner.class).findFirst().getDogs();
+        assertEquals(TEST_OBJECTS, dogs.size());
+        testRealm.close();
+        testRealm = null;
+
+        try {
+            dogs.deleteAllFromRealm();
+            fail("dogs is invalid and it should throw an exception");
+        } catch (IllegalStateException e) {
+            assertEquals("This Realm instance has already been closed, making it unusable.", e.getMessage());
+        }
+    }
+
+    @Test
+    public void add_set_objectFromOtherThread() {
+        final CountDownLatch finishedLatch = new CountDownLatch(1);
+        final Dog dog = testRealm.where(Dog.class).findFirst();
+        final String expectedMsg = "Cannot copy an object from another Realm instance.";
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(testRealm.getConfiguration());
+                realm.beginTransaction();
+                RealmList<Dog> list = realm.createObject(Owner.class).getDogs();
+                list.add(realm.createObject(Dog.class));
+                try {
+                    list.add(dog);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                try {
+                    list.add(0, dog);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                try {
+                    list.set(0, dog);
+                    fail();
+                } catch (IllegalArgumentException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                realm.cancelTransaction();
+                realm.close();
+                finishedLatch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(finishedLatch);
+    }
+
+    @Test
+    public void add_set_dynamicObjectFromOtherThread() {
+        final CountDownLatch finishedLatch = new CountDownLatch(1);
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+        final DynamicRealmObject dynDog = dynamicRealm.where(Dog.CLASS_NAME).findFirst();
+        final String expectedMsg = "Cannot copy an object to a Realm instance created in another thread.";
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+                dynamicRealm.beginTransaction();
+                RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
+                        .getList(Owner.FIELD_DOGS);
+                list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
+
+                try {
+                    list.add(dynDog);
+                    fail();
+                } catch (IllegalStateException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                try {
+                    list.add(0,dynDog);
+                    fail();
+                } catch (IllegalStateException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                try {
+                    list.set(0,dynDog);
+                    fail();
+                } catch (IllegalStateException expected) {
+                    assertEquals(expectedMsg, expected.getMessage());
+                }
+
+                dynamicRealm.cancelTransaction();
+                dynamicRealm.close();
+                finishedLatch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(finishedLatch);
+        dynamicRealm.close();
+    }
+
+    @Test
+    public void add_set_withWrongDynamicObjectType() {
+        final String expectedMsg = "The object has a different type from list's. Type of the list is 'Dog'," +
+                        " type of object is 'Cat'.";
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+
+        dynamicRealm.beginTransaction();
+        RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
+                .getList(Owner.FIELD_DOGS);
+        DynamicRealmObject dynCat = dynamicRealm.createObject(Cat.CLASS_NAME);
+
+        try {
+            list.add(dynCat);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+
+        }
+
+        try {
+            list.add(0, dynCat);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+
+        }
+
+        try {
+            list.set(0, dynCat);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+
+        }
+
+        dynamicRealm.cancelTransaction();
+        dynamicRealm.close();
+    }
+
+    @Test
+    public void add_set_dynamicObjectCreatedFromTypedRealm() {
+        final String expectedMsg = "Cannot copy DynamicRealmObject between Realm instances.";
+        DynamicRealmObject dynDog = new DynamicRealmObject(testRealm.where(Dog.class).findFirst());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(testRealm.getConfiguration());
+
+        dynamicRealm.beginTransaction();
+        RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
+                .getList(Owner.FIELD_DOGS);
+
+        try {
+            list.add(dynDog);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+        }
+
+        try {
+            list.add(0, dynDog);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+        }
+
+        try {
+            list.set(0, dynDog);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(expectedMsg, expected.getMessage());
+        }
+
+        dynamicRealm.cancelTransaction();
+        dynamicRealm.close();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
new file mode 100644
index 0000000000..5294936414
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -0,0 +1,590 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Date;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationTypes;
+import io.realm.entities.FieldOrder;
+import io.realm.entities.NullTypes;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.Table;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmMigrationTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private Context context;
+
+    @Before
+    public void setup() {
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void getInstance_realmClosedAfterMigrationException() throws IOException {
+        String REALM_NAME = "default0.realm";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        configFactory.copyRealmFromAssets(context, REALM_NAME, REALM_NAME);
+        try {
+            Realm.getInstance(realmConfig);
+            fail("A migration should be triggered");
+        } catch (RealmMigrationNeededException expected) {
+            Realm.deleteRealm(realmConfig); // Delete old realm
+        }
+
+        // This should recreate the Realm with proper schema
+        Realm realm = Realm.getInstance(realmConfig);
+        int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
+        assertEquals(0, result);
+        realm.close();
+    }
+
+    // If a migration creates a different ordering of columns on Realm A, while another ordering is generated by
+    // creating a new Realm B. Global column indices will not work. They must be calculated for each Realm.
+    @Test
+    public void localColumnIndices() throws IOException {
+        String MIGRATED_REALM = "migrated.realm";
+        String NEW_REALM = "new.realm";
+
+        // Migrate old Realm to proper schema
+
+        // V1 config
+        RealmConfiguration v1Config = configFactory.createConfigurationBuilder()
+                .name(MIGRATED_REALM)
+                .schema(AllTypes.class)
+                .schemaVersion(1)
+                .build();
+        Realm oldRealm = Realm.getInstance(v1Config);
+        oldRealm.close();
+
+        // V2 config
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("FieldOrder")
+                        .addField("field2", int.class)
+                        .addField("field1", boolean.class);
+            }
+        };
+
+        RealmConfiguration v2Config = configFactory.createConfigurationBuilder()
+                .name(MIGRATED_REALM)
+                .schema(AllTypes.class, FieldOrder.class)
+                .schemaVersion(2)
+                .migration(migration)
+                .build();
+        oldRealm = Realm.getInstance(v2Config);
+
+        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
+        // instead of the migration
+        RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
+                .name(NEW_REALM)
+                .schemaVersion(2)
+                .schema(AllTypes.class, FieldOrder.class)
+                .build();
+        Realm newRealm = Realm.getInstance(newConfig);
+        newRealm.close();
+
+        // Try to query migrated realm. With local column indices this will work. With global it will fail.
+        assertEquals(0, oldRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
+        oldRealm.close();
+    }
+
+    @Test
+    public void notSettingIndexThrows() {
+
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        // Create v1 of the Realm
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class, FieldAttribute.PRIMARY_KEY)
+                        .addField("indexString", String.class) // Forget to set @Index
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void notSettingPrimaryKeyThrows() {
+
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class) // Forget to set @PrimaryKey
+                        .addField("indexString", String.class, FieldAttribute.INDEXED)
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RealmMigrationNeededException e) {
+            if (!e.getMessage().equals("Primary key not defined for field 'id' in existing Realm file. Add @PrimaryKey.")) {
+                fail(e.toString());
+            }
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // adding search index is idempotent
+    @Test
+    public void addingSearchIndexTwice() throws IOException {
+        Class[] classes = {PrimaryKeyAsLong.class, PrimaryKeyAsString.class};
+
+        for (final Class clazz : classes){
+            final boolean[] didMigrate = {false};
+
+            RealmMigration migration = new RealmMigration() {
+                @Override
+                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    Table table = realm.schema.getTable(clazz);
+                    long columnIndex = table.getColumnIndex("id");
+                    table.addSearchIndex(columnIndex);
+                    if (clazz == PrimaryKeyAsLong.class) {
+                        columnIndex = table.getColumnIndex("name");
+                        table.convertColumnToNullable(columnIndex);
+                    }
+                    didMigrate[0] = true;
+                }
+            };
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .schemaVersion(42)
+                    .schema(clazz)
+                    .migration(migration)
+                    .build();
+            Realm.deleteRealm(realmConfig);
+            configFactory.copyRealmFromAssets(context,
+                    "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+            Realm.migrateRealm(realmConfig);
+            realm = Realm.getInstance(realmConfig);
+            assertEquals(42, realm.getVersion());
+            assertTrue(didMigrate[0]);
+            Table table = realm.getTable(clazz);
+            assertEquals(true, table.hasSearchIndex(table.getColumnIndex("id")));
+            realm.close();
+        }
+    }
+
+    @Test
+    public void setAnnotations() {
+
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class, FieldAttribute.PRIMARY_KEY)
+                        .addField("indexString", String.class, FieldAttribute.INDEXED)
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+
+        realm = Realm.getInstance(realmConfig);
+        Table table = realm.getTable(AnnotationTypes.class);
+        assertEquals(3, table.getColumnCount());
+        assertTrue(table.hasPrimaryKey());
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
+    }
+
+    @Test
+    public void migrationException_getPath() throws IOException {
+        configFactory.copyRealmFromAssets(context, "default0.realm", Realm.DEFAULT_REALM_NAME);
+        File realm = new File(configFactory.getRoot(), Realm.DEFAULT_REALM_NAME);
+        try {
+            Realm.getInstance(configFactory.createConfiguration());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+            assertEquals(expected.getPath(), realm.getCanonicalPath());
+        }
+    }
+
+    // In default-before-migration.realm, CatOwner has a RealmList<Dog> field.
+    // This is changed to RealmList<Cat> and getInstance() must throw an exception.
+    @Test
+    public void migrationException_realmListChanged() throws IOException {
+        configFactory.copyRealmFromAssets(context,
+                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        try {
+            realm = Realm.getInstance(configFactory.createConfiguration());
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+    }
+
+    // Pre-null Realms will leave columns not-nullable after the underlying storage engine has
+    // migrated the file format. But @Required must be added, and forgetting so will give you
+    // a RealmMigrationNeeded exception.
+    @Test
+    public void openPreNullRealmRequiredMissing() throws IOException {
+        configFactory.copyRealmFromAssets(context,
+                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        RealmMigration realmMigration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // intentionally left empty
+            }
+        };
+
+        try {
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .schemaVersion(0)
+                    .schema(StringOnly.class)
+                    .migration(realmMigration)
+                    .build();
+            Realm realm = Realm.getInstance(realmConfig);
+            realm.close();
+            fail();
+        } catch (RealmMigrationNeededException e) {
+            assertEquals("Field 'chars' is required. Either set @Required to field 'chars' or migrate using io.realm.internal.Table.convertColumnToNullable().",
+                    e.getMessage());
+        }
+    }
+
+    // Pre-null Realms will leave columns not-nullable after the underlying storage engine has
+    // migrated the file format. An explicit migration step to convert to nullable, and the
+    // old class (without @Required) can be used,
+    @Test
+    public void migratePreNull() throws IOException {
+        configFactory.copyRealmFromAssets(context,
+                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                Table table = realm.schema.getTable(StringOnly.class);
+                table.convertColumnToNullable(table.getColumnIndex("chars"));
+            }
+        };
+
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(StringOnly.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        StringOnly stringOnly = realm.createObject(StringOnly.class);
+        stringOnly.setChars(null);
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    // Pre-null Realms will leave columns not-nullable after the underlying storage engine has
+    // migrated the file format. If the user adds the @Required annotation to a field and does not
+    // change the schema version, no migration is needed. But then, null cannot be used as a value.
+    @Test
+    public void openPreNullWithRequired() throws IOException {
+        configFactory.copyRealmFromAssets(context,
+                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(0)
+                .schema(AllTypes.class)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        realm.beginTransaction();
+        try {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnString(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        realm.cancelTransaction();
+
+        realm.close();
+    }
+
+    // If a required field was nullable before, a RealmMigrationNeededException should be thrown
+    @Test
+    public void notSettingRequiredForNotNullableThrows() {
+        String[] notNullableFields = {NullTypes.FIELD_STRING_NOT_NULL, NullTypes.FIELD_BYTES_NOT_NULL,
+                NullTypes.FIELD_BOOLEAN_NOT_NULL, NullTypes.FIELD_BYTE_NOT_NULL, NullTypes.FIELD_SHORT_NOT_NULL,
+                NullTypes.FIELD_INTEGER_NOT_NULL, NullTypes.FIELD_LONG_NOT_NULL, NullTypes.FIELD_FLOAT_NOT_NULL,
+                NullTypes.FIELD_DOUBLE_NOT_NULL, NullTypes.FIELD_DATE_NOT_NULL};
+        for (final String field : notNullableFields) {
+            final RealmMigration migration = new RealmMigration() {
+                @Override
+                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    if (oldVersion == 0) { // 0 after initNullTypesTableExcludes
+                        // No @Required for not nullable field
+                        RealmObjectSchema nullTypesSchema = realm.getSchema().getSchemaForClass(NullTypes.CLASS_NAME);
+                        if (field.equals(NullTypes.FIELD_STRING_NOT_NULL)) {
+                            // 1 String
+                            nullTypesSchema.addField(field, String.class);
+                        } else if (field.equals(NullTypes.FIELD_BYTES_NOT_NULL)) {
+                            // 2 Bytes
+                            nullTypesSchema.addField(field, byte[].class);
+                        } else if (field.equals(NullTypes.FIELD_BOOLEAN_NOT_NULL)) {
+                            // 3 Boolean
+                            nullTypesSchema.addField(field, Boolean.class);
+                            //table.addColumn(RealmFieldType.BOOLEAN, field, Table.NULLABLE);
+                        } else if (field.equals(NullTypes.FIELD_BYTE_NOT_NULL) ||
+                                field.equals(NullTypes.FIELD_SHORT_NOT_NULL) ||
+                                field.equals(NullTypes.FIELD_INTEGER_NOT_NULL) ||
+                                field.equals(NullTypes.FIELD_LONG_NOT_NULL)) {
+                            // 4 Byte 5 Short 6 Integer 7 Long
+                            nullTypesSchema.addField(field, Integer.class);
+                        } else if (field.equals(NullTypes.FIELD_FLOAT_NOT_NULL)) {
+                            // 8 Float
+                            nullTypesSchema.addField(field, Float.class);
+                        } else if (field.equals(NullTypes.FIELD_DOUBLE_NOT_NULL)) {
+                            // 9 Double
+                            nullTypesSchema.addField(field, Double.class);
+                        } else if (field.equals(NullTypes.FIELD_DATE_NOT_NULL)) {
+                            // 10 Date
+                            nullTypesSchema.addField(field, Date.class);
+                        }
+                        // 11 Object skipped
+                    }
+                }
+            };
+
+            @SuppressWarnings("unchecked")
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .schemaVersion(1)
+                    .schema(NullTypes.class)
+                    .migration(migration)
+                    .build();
+            Realm.deleteRealm(realmConfig);
+            // Prepare the version 0 db
+            DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+            TestHelper.initNullTypesTableExcludes(dynamicRealm, field);
+            dynamicRealm.close();
+
+            try {
+                realm = Realm.getInstance(realmConfig);
+                fail("Failed on " + field);
+            } catch (RealmMigrationNeededException e) {
+                assertEquals("Field '" + field + "' does support null values in the existing Realm file." +
+                        " Remove @Required or @PrimaryKey from field '" + field + "' " +
+                        "or migrate using io.realm.internal.Table.convertColumnToNotNullable().",
+                        e.getMessage());
+            }
+        }
+    }
+
+    // If a field is not required but was not nullable before, a RealmMigrationNeededException should be thrown
+    @Test
+    public void settingRequiredForNullableThrows() {
+        String[] notNullableFields = {NullTypes.FIELD_STRING_NULL, NullTypes.FIELD_BYTES_NULL,
+                NullTypes.FIELD_BOOLEAN_NULL, NullTypes.FIELD_BYTE_NULL, NullTypes.FIELD_SHORT_NULL,
+                NullTypes.FIELD_INTEGER_NULL, NullTypes.FIELD_LONG_NULL, NullTypes.FIELD_FLOAT_NULL,
+                NullTypes.FIELD_DOUBLE_NULL, NullTypes.FIELD_DATE_NULL};
+        for (final String field : notNullableFields) {
+            final RealmMigration migration = new RealmMigration() {
+                @Override
+                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    if (oldVersion == 0) { // 0 after initNullTypesTableExcludes
+                        // No @Required for not nullable field
+                        RealmObjectSchema nullTypesSchema = realm.getSchema().getSchemaForClass(NullTypes.CLASS_NAME);
+                        if (field.equals(NullTypes.FIELD_STRING_NULL)) {
+                            // 1 String
+                            nullTypesSchema.addField(field, String.class, FieldAttribute.REQUIRED);
+                        } else if (field.equals(NullTypes.FIELD_BYTES_NULL)) {
+                            // 2 Bytes
+                            nullTypesSchema.addField(field, byte[].class, FieldAttribute.REQUIRED);
+                        } else if (field.equals(NullTypes.FIELD_BOOLEAN_NULL)) {
+                            // 3 Boolean
+                            nullTypesSchema.addField(field, boolean.class);
+                        } else if (field.equals(NullTypes.FIELD_BYTE_NULL) ||
+                                field.equals(NullTypes.FIELD_SHORT_NULL) ||
+                                field.equals(NullTypes.FIELD_INTEGER_NULL) ||
+                                field.equals(NullTypes.FIELD_LONG_NULL)) {
+                            // 4 Byte 5 Short 6 Integer 7 Long
+                            nullTypesSchema.addField(field, int.class);
+                        } else if (field.equals(NullTypes.FIELD_FLOAT_NULL)) {
+                            // 8 Float
+                            nullTypesSchema.addField(field, float.class);
+                        } else if (field.equals(NullTypes.FIELD_DOUBLE_NULL)) {
+                            // 9 Double
+                            nullTypesSchema.addField(field, double.class);
+                        } else if (field.equals(NullTypes.FIELD_DATE_NULL)) {
+                            // 10 Date
+                            nullTypesSchema.addField(field, Date.class, FieldAttribute.REQUIRED);
+                        }
+                        // 11 Object skipped
+                    }
+                }
+            };
+
+            @SuppressWarnings("unchecked")
+            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                    .schemaVersion(1)
+                    .schema(NullTypes.class)
+                    .migration(migration)
+                    .build();
+            Realm.deleteRealm(realmConfig);
+            // Prepare the version 0 db
+            DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+            TestHelper.initNullTypesTableExcludes(dynamicRealm, field);
+            dynamicRealm.close();
+
+            try {
+                realm = Realm.getInstance(realmConfig);
+                fail("Failed on " + field);
+            } catch (RealmMigrationNeededException e) {
+                if (field.equals(NullTypes.FIELD_STRING_NULL) || field.equals(NullTypes.FIELD_BYTES_NULL) ||
+                        field.equals(NullTypes.FIELD_DATE_NULL)) {
+                    assertEquals("Field '" + field + "' is required. Either set @Required to field '" +
+                            field + "' " +
+                            "or migrate using io.realm.internal.Table.convertColumnToNullable().", e.getMessage());
+                } else {
+                    assertEquals("Field '" + field + "' does not support null values in the existing Realm file."
+                                    + " Either set @Required, use the primitive type for field '"
+                                    + field + "' or migrate using io.realm.internal.Table.convertColumnToNullable().",  e.getMessage());
+                }
+            }
+        }
+    }
+
+    @Test
+    public void realmOpenBeforeMigrationThrows() throws FileNotFoundException {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+
+        try {
+            // Trigger manual migration. This can potentially change the schema, so should only be allowed when
+            // no-one else is working on the Realm.
+            Realm.migrateRealm(config, new RealmMigration() {
+                @Override
+                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    // Do nothing
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void migrateRealm_config_nonExistingRealmFile() throws FileNotFoundException {
+        RealmConfiguration config = configFactory.createConfigurationBuilder().migration(new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+
+            }
+        }).build();
+        thrown.expect(FileNotFoundException.class);
+        Realm.migrateRealm(config);
+    }
+
+    @Test
+    public void migrateRealm_configMigration_nonExistingRealmFile() throws FileNotFoundException {
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+
+            }
+        };
+        RealmConfiguration config = configFactory.createConfiguration();
+        thrown.expect(FileNotFoundException.class);
+        Realm.migrateRealm(config, migration);
+    }
+
+    // TODO Add unit tests for default nullability
+    // TODO Add unit tests for default Indexing for Primary keys
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
new file mode 100644
index 0000000000..5ac41a5c25
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -0,0 +1,646 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.test.AndroidTestCase;
+
+import java.util.Date;
+import java.util.Set;
+
+import io.realm.entities.AllJavaTypes;
+
+public class RealmObjectSchemaTests extends AndroidTestCase {
+
+    private RealmObjectSchema DOG_SCHEMA;
+    private DynamicRealm realm;
+    private RealmObjectSchema schema;
+    private RealmSchema realmSchema;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).build();
+        Realm.deleteRealm(realmConfig);
+        Realm.getInstance(realmConfig).close(); // Create Schema
+        realm = DynamicRealm.getInstance(realmConfig);
+        realmSchema = realm.getSchema();
+        DOG_SCHEMA = realmSchema.get("Dog");
+        realm.beginTransaction();
+        schema = realmSchema.create("NewClass");
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    public enum SchemaFieldType {
+        SIMPLE, OBJECT, LIST
+    }
+
+    public enum FieldType {
+        STRING(String.class, true),
+        SHORT(Short.class, true), PRIMITIVE_SHORT(short.class, false),
+        INT(Integer.class, true), PRIMITIVE_INT(int.class, false),
+        LONG(Long.class, true), PRIMITIVE_LONG(long.class, false),
+        BYTE(Byte.class, true), PRIMITIVE_BYTE(byte.class, false),
+        BOOLEAN(Boolean.class, true), PRIMITIVE_BOOLEAN(boolean.class, false),
+        FLOAT(Float.class, true), PRIMITIVE_FLOAT(float.class, false),
+        DOUBLE(Double.class, true), PRIMITIVE_DOUBLE(double.class, false),
+        BLOB(byte[].class, true),
+        DATE(Date.class, true),
+        OBJECT(RealmObject.class, false),
+        LIST(RealmList.class, false);
+
+        final Class<?> clazz;
+        final boolean defaultNullable;
+
+        FieldType(Class<?> clazz, boolean defaultNullable) {
+            this.clazz = clazz;
+            this.defaultNullable = defaultNullable;
+        }
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        public boolean isNullable() {
+            return defaultNullable;
+        }
+    }
+
+    public enum IndexFieldType {
+        STRING(String.class),
+        SHORT(Short.class), PRIMITIVE_SHORT(short.class),
+        INT(Integer.class), PRIMITIVE_INT(int.class),
+        LONG(Long.class), PRIMITIVE_LONG(long.class),
+        BYTE(Byte.class), PRIMITIVE_BYTE(byte.class),
+        BOOLEAN(Boolean.class), PRIMITIVE_BOOLEAN(boolean.class),
+        DATE(Date.class);
+
+        Class<?> clazz;
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        IndexFieldType(Class<?> clazz) {
+            this.clazz = clazz;
+        }
+    }
+
+    public enum InvalidIndexFieldType {
+        FLOAT(Float.class), PRIMITIVE_FLOAT(float.class),
+        DOUBLE(Double.class), PRIMITIVE_DOUBLE(double.class),
+        BLOB(byte[].class),
+        OBJECT(RealmObject.class),
+        LIST(RealmList.class);
+
+        Class<?> clazz;
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        InvalidIndexFieldType(Class<?> clazz) {
+            this.clazz = clazz;
+        }
+    }
+
+    // TODO These should also be allowed? BOOLEAN, DATE
+    public enum PrimaryKeyFieldType {
+        STRING(String.class),
+        SHORT(Short.class), PRIMITIVE_SHORT(short.class),
+        INT(Integer.class), PRIMITIVE_INT(int.class),
+        LONG(Long.class), PRIMITIVE_LONG(long.class),
+        BYTE(Byte.class), PRIMITIVE_BYTE(byte.class);
+
+        Class<?> clazz;
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        PrimaryKeyFieldType(Class<?> clazz) {
+            this.clazz = clazz;
+        }
+    }
+
+    public enum InvalidPrimaryKeyFieldType {
+        BOOLEAN(Boolean.class), PRIMITIVE_BOOLEAN(boolean.class),
+        FLOAT(Float.class), PRIMITIVE_FLOAT(float.class),
+        DOUBLE(Double.class), PRIMITIVE_DOUBLE(double.class),
+        BLOB(byte[].class),
+        DATE(Date.class),
+        OBJECT(RealmObject.class),
+        LIST(RealmList.class);
+
+        Class<?> clazz;
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        InvalidPrimaryKeyFieldType(Class<?> clazz) {
+            this.clazz = clazz;
+        }
+    }
+
+    public void testAddRemoveField() {
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = "foo";
+            switch(fieldType) {
+                case OBJECT:
+                    schema.addRealmObjectField(fieldName, DOG_SCHEMA);
+                    checkAddedAndRemovable(fieldName);
+                    break;
+                case LIST:
+                    schema.addRealmListField(fieldName, DOG_SCHEMA);
+                    checkAddedAndRemovable(fieldName);
+                    break;
+                default:
+                    // All simple fields
+                    schema.addField(fieldName, fieldType.getType());
+                    checkAddedAndRemovable(fieldName);
+            }
+        }
+    }
+
+    // Check that field is actually added and that it can be removed again.
+    private void checkAddedAndRemovable(String fieldName) {
+        assertTrue(schema.hasField(fieldName));
+        schema.removeField(fieldName);
+        assertFalse(schema.hasField(fieldName));
+    }
+
+    public void testAddField_nameAlreadyExistsThrows() {
+        for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
+            switch (schemaFieldType) {
+                case SIMPLE:
+                    checkAddFieldTwice(AllJavaTypes.FIELD_STRING, new FieldRunnable() {
+                        @Override
+                        public void run(String fieldName) {
+                            schema.addField(fieldName, String.class);
+                        }
+                    });
+                    break;
+                case OBJECT:
+                    checkAddFieldTwice(AllJavaTypes.FIELD_OBJECT, new FieldRunnable() {
+                        @Override
+                        public void run(String fieldName) {
+                            schema.addRealmObjectField(fieldName, DOG_SCHEMA);
+                        }
+                    });
+                    break;
+                case LIST:
+                    checkAddFieldTwice(AllJavaTypes.FIELD_LIST, new FieldRunnable() {
+                        @Override
+                        public void run(String fieldName) {
+                            schema.addRealmListField(fieldName, DOG_SCHEMA);
+                        }
+                    });
+                    break;
+                default:
+                    fail("Unknown type: " + schemaFieldType);
+            }
+        }
+    }
+
+    private void checkAddFieldTwice(String fieldName, FieldRunnable runnable) {
+        runnable.run(fieldName);
+        try {
+            runnable.run(fieldName);
+            fail("Was able to add field twice: " + fieldName);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+
+    public void testAddField_illegalFieldNameThrows() {
+        String[] fieldNames = new String[] { null, "", "foo.bar", TestHelper.getRandomString(65) };
+        for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
+            for (String fieldName : fieldNames) {
+                try {
+                    switch(schemaFieldType) {
+                        case SIMPLE: schema.addField(fieldName, String.class); break;
+                        case OBJECT: schema.addRealmObjectField(fieldName, DOG_SCHEMA); break;
+                        case LIST: schema.addRealmListField(fieldName, DOG_SCHEMA); break;
+                        default:
+                            fail("Unknown type: " + schemaFieldType);
+                    }
+                    fail(schemaFieldType + " didn't throw");
+                } catch (IllegalArgumentException ignored) {
+                }
+            }
+        }
+    }
+
+    public void testRequiredFieldAttribute() {
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = "foo";
+            switch (fieldType) {
+                case OBJECT: continue; // Not possible
+                case LIST: continue; // Not possible
+                default:
+                    // All simple types
+                    schema.addField(fieldName, fieldType.getType(), FieldAttribute.REQUIRED);
+                    assertTrue(schema.isRequired(fieldName));
+                    schema.removeField(fieldName);
+            }
+        }
+    }
+
+    public void testIndexedFieldAttribute() {
+        for (IndexFieldType fieldType : IndexFieldType.values()) {
+            String fieldName = "foo";
+            switch (fieldType) {
+                default:
+                    schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
+                    assertTrue(fieldType + " failed", schema.hasIndex(fieldName));
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testInvalidIndexedFieldAttributeThrows() {
+        for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
+            String fieldName = "foo";
+            try {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
+                fail(fieldType + " should not be allowed to be indexed");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    public void testPrimaryKeyFieldAttribute() {
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
+            assertTrue(schema.hasPrimaryKey());
+            assertFalse(schema.isNullable(fieldName));
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testInvalidPrimaryKeyFieldAttributeThrows() {
+        for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
+            String fieldName = "foo";
+            try {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
+                fail(fieldType + " should not be allowed to be a primary key");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    public void testAddPrimaryKeyFieldModifier_alreadyExistsThrows() {
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType());
+            schema.addPrimaryKey(fieldName);
+            try {
+                schema.addPrimaryKey(fieldName);
+                fail();
+            } catch (IllegalStateException ignored) {
+                schema.removePrimaryKey();
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testAddPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
+        String fieldName = "foo";
+        for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
+            switch (fieldType) {
+                case OBJECT: schema.addRealmObjectField(fieldName, DOG_SCHEMA); break;
+                case LIST: schema.addRealmListField(fieldName, DOG_SCHEMA); break;
+                default: schema.addField(fieldName, fieldType.getType());
+            }
+            try {
+                schema.addPrimaryKey(fieldName);
+                fail(fieldType + " should not be a legal primary key");
+            } catch (IllegalArgumentException ignored) {
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testAddPrimaryKeyFieldModifier_duplicateValues() {
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            final String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType());
+
+            // create multiple objects with same values.
+            realm.createObject(schema.getClassName());
+            realm.createObject(schema.getClassName());
+
+            try {
+                schema.addPrimaryKey(fieldName);
+                fail();
+            } catch (IllegalArgumentException e) {
+                // check if message reports correct field name.
+                assertTrue(e.getMessage().contains("\"" + fieldName + "\""));
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testAddIndexFieldModifier_illegalFieldTypeThrows() {
+        String fieldName = "foo";
+        for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
+            switch (fieldType) {
+                case OBJECT: schema.addRealmObjectField(fieldName, DOG_SCHEMA); break;
+                case LIST: schema.addRealmListField(fieldName, DOG_SCHEMA); break;
+                default: schema.addField(fieldName, fieldType.getType());
+            }
+            try {
+                schema.addIndex(fieldName);
+                fail(fieldType + " should not be allowed to be indexed.");
+            } catch (IllegalArgumentException ignored) {
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testAddIndexFieldModifier_alreadyIndexedThrows() {
+        for (IndexFieldType fieldType : IndexFieldType.values()) {
+            String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType());
+            schema.addIndex(fieldName);
+            try {
+                schema.addIndex(fieldName);
+                fail();
+            } catch (IllegalStateException ignored) {
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testSetRemoveNullable() {
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = "foo";
+            switch (fieldType) {
+                case OBJECT:
+                    // Objects are always nullable and cannot be changed.
+                    schema.addRealmObjectField(fieldName, schema);
+                    assertTrue(schema.isNullable(fieldName));
+                    try {
+                        schema.setNullable(fieldName, false);
+                        fail();
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    break;
+                case LIST:
+                    // Lists are not nullable and cannot be configured to be so.
+                    schema.addRealmListField(fieldName, schema);
+                    assertFalse(schema.isNullable(fieldName));
+                    try {
+                        schema.setNullable(fieldName, true);
+                        fail();
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    break;
+                default:
+                    // All simple types
+                    schema.addField(fieldName, fieldType.getType());
+                    assertEquals(fieldType.isNullable(), schema.isNullable(fieldName));
+                    schema.setNullable(fieldName, !fieldType.isNullable());
+                    assertEquals(!fieldType.isNullable(), schema.isNullable(fieldName));
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testSetRemoveRequired() {
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = "foo";
+            switch (fieldType) {
+                case OBJECT:
+                    // Objects are always nullable and cannot be configured otherwise.
+                    schema.addRealmObjectField(fieldName, schema);
+                    assertFalse(schema.isRequired((fieldName)));
+                    try {
+                        schema.setRequired(fieldName, false);
+                        fail();
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    break;
+                case LIST:
+                    // Lists are always non-nullable and cannot be configured otherwise.
+                    schema.addRealmListField(fieldName, schema);
+                    assertTrue(schema.isRequired((fieldName)));
+                    try {
+                        schema.setRequired(fieldName, true);
+                        fail();
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    break;
+                default:
+                    // All simple types
+                    schema.addField(fieldName, fieldType.getType());
+                    assertEquals(!fieldType.isNullable(), schema.isRequired(fieldName));
+                    schema.setRequired(fieldName, fieldType.isNullable());
+                    assertEquals(fieldType.isNullable(), schema.isRequired(fieldName));
+            }
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testSetRemovePrimaryKey() {
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType());
+            schema.addPrimaryKey(fieldName);
+            assertTrue(schema.hasPrimaryKey());
+            schema.removePrimaryKey();
+            assertFalse(schema.hasPrimaryKey());
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testRemoveNonExistingPrimaryKeyThrows() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class);
+        try {
+            schema.removePrimaryKey();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    public void testSetRemoveIndex() {
+        for (IndexFieldType fieldType : IndexFieldType.values()) {
+            String fieldName = "foo";
+            schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
+            assertTrue(schema.hasIndex(fieldName));
+            schema.removeIndex(fieldName);
+            assertFalse(schema.hasIndex(fieldName));
+            schema.removeField(fieldName);
+        }
+    }
+
+    public void testRemoveNonExistingIndexThrows() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class);
+        try {
+            schema.removeIndex(fieldName);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    public void testRemoveField() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class);
+        assertTrue(schema.hasField(fieldName));
+        schema.removeField(fieldName);
+        assertFalse(schema.hasField(fieldName));
+    }
+
+    public void testRemoveFieldWithPrimaryKey() {
+        String fieldName = "foo";
+        schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
+        assertTrue(schema.hasField(fieldName));
+        assertTrue(schema.hasPrimaryKey());
+        schema.removeField(fieldName);
+        assertFalse(schema.hasPrimaryKey());
+    }
+
+    public void testRemoveNonExistingFieldThrows() {
+        String fieldName = "foo";
+        try {
+            schema.removeField(fieldName);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    public void testRenameField() {
+        String oldFieldName = "old";
+        String newFieldName = "new";
+        schema.addField(oldFieldName, String.class);
+        assertTrue(schema.hasField(oldFieldName));
+        assertFalse(schema.hasField(newFieldName));
+        schema.renameField(oldFieldName, newFieldName);
+        assertFalse(schema.hasField(oldFieldName));
+        assertTrue(schema.hasField(newFieldName));
+    }
+
+    public void testRenameNonExistingFieldThrows() {
+        String oldFieldName = "old";
+        String newFieldName = "new";
+        try {
+            schema.renameField(oldFieldName, newFieldName);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    public void testRenameFieldToIllegalNameThrows() {
+        String oldFieldName = "old";
+        String newFieldName = "";
+        schema.addField(oldFieldName, String.class);
+        try {
+            schema.renameField(oldFieldName, newFieldName);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    public void testSetGetClassName() {
+        assertEquals("Dog", DOG_SCHEMA.getClassName());
+        String newClassName = "Darby";
+        DOG_SCHEMA.setClassName(newClassName);
+        assertEquals(newClassName, DOG_SCHEMA.getClassName());
+        assertTrue(realmSchema.contains(newClassName));
+    }
+
+    public void testTransform() {
+        String className = DOG_SCHEMA.getClassName();
+        DynamicRealmObject dog1 = realm.createObject(className);
+        dog1.setInt("age", 1);
+        DynamicRealmObject dog2 = realm.createObject(className);
+        dog2.setInt("age", 2);
+
+        DOG_SCHEMA.transform(new RealmObjectSchema.Function() {
+            @Override
+            public void apply(DynamicRealmObject obj) {
+                obj.setInt("age", obj.getInt("age") + 1);
+            }
+        });
+        assertEquals(5, realm.where("Dog").sum("age").intValue());
+    }
+
+    public void testTransformObjectReferences() {
+        String className = DOG_SCHEMA.getClassName();
+        DynamicRealmObject dog1 = realm.createObject(className);
+        dog1.setInt("age", 1);
+
+        DOG_SCHEMA.transform(new RealmObjectSchema.Function() {
+            @Override
+            public void apply(DynamicRealmObject dog) {
+                DynamicRealmObject owner = realm.createObject("Owner");
+                owner.setString("name", "John");
+                dog.setObject("owner", owner);
+            }
+        });
+        assertEquals("John", realm.where("Dog").findFirst().getObject("owner").getString("name"));
+    }
+
+    public void testGetFieldNames() {
+        Set<String> fieldNames = DOG_SCHEMA.getFieldNames();
+        assertEquals(7, fieldNames.size());
+        assertTrue(fieldNames.contains("name"));
+        assertTrue(fieldNames.contains("age"));
+        assertTrue(fieldNames.contains("height"));
+        assertTrue(fieldNames.contains("weight"));
+        assertTrue(fieldNames.contains("hasTail"));
+        assertTrue(fieldNames.contains("birthday"));
+        assertTrue(fieldNames.contains("owner"));
+    }
+
+    public void testGetFieldType() {
+        schema = realmSchema.getSchemaForClass("AllJavaTypes");
+        assertEquals(RealmFieldType.STRING, schema.getFieldType(AllJavaTypes.FIELD_STRING));
+        assertEquals(RealmFieldType.BINARY, schema.getFieldType(AllJavaTypes.FIELD_BINARY));
+        assertEquals(RealmFieldType.BOOLEAN, schema.getFieldType(AllJavaTypes.FIELD_BOOLEAN));
+        assertEquals(RealmFieldType.DATE, schema.getFieldType(AllJavaTypes.FIELD_DATE));
+        assertEquals(RealmFieldType.DOUBLE, schema.getFieldType(AllJavaTypes.FIELD_DOUBLE));
+        assertEquals(RealmFieldType.FLOAT, schema.getFieldType(AllJavaTypes.FIELD_FLOAT));
+        assertEquals(RealmFieldType.OBJECT, schema.getFieldType(AllJavaTypes.FIELD_OBJECT));
+        assertEquals(RealmFieldType.LIST, schema.getFieldType(AllJavaTypes.FIELD_LIST));
+        assertEquals(RealmFieldType.INTEGER, schema.getFieldType(AllJavaTypes.FIELD_BYTE));
+        assertEquals(RealmFieldType.INTEGER, schema.getFieldType(AllJavaTypes.FIELD_SHORT));
+        assertEquals(RealmFieldType.INTEGER, schema.getFieldType(AllJavaTypes.FIELD_INT));
+        assertEquals(RealmFieldType.INTEGER, schema.getFieldType(AllJavaTypes.FIELD_LONG));
+    }
+
+    public void testGetFieldTypeThrows() {
+        try {
+            schema.getFieldType("I don't exists");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    private interface FieldRunnable {
+        void run(String fieldName);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
new file mode 100644
index 0000000000..b75f458c71
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -0,0 +1,1362 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.ConflictingFieldName;
+import io.realm.entities.CyclicType;
+import io.realm.entities.Dog;
+import io.realm.entities.NullTypes;
+import io.realm.entities.StringAndInt;
+import io.realm.entities.Thread;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmObjectTests {
+
+    private static final int TEST_SIZE = 5;
+    private static final boolean REMOVE_FIRST = true;
+    private static final boolean REMOVE_LAST = false;
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // FIXME remove?
+    @Test
+    public void row_isValid() {
+        realm.beginTransaction();
+        RealmObject realmObject = realm.createObject(AllTypes.class);
+        Row row = realmObject.row;
+        realm.commitTransaction();
+
+        assertNotNull("RealmObject.realmGetRow returns zero ", row);
+        assertEquals(9, row.getColumnCount());
+    }
+
+    @Test
+    public void stringEncoding() {
+        String[] strings = {"ABCD", "ÆØÅ", "Ö∫Ë", "ΠΑΟΚ", "Здравей"};
+
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+
+        for (String str : strings) {
+            AllTypes obj1 = realm.createObject(AllTypes.class);
+            obj1.setColumnString(str);
+        }
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> objects = realm.allObjects(AllTypes.class);
+        assertEquals(strings.length, objects.size());
+        int i = 0;
+        for (AllTypes obj : objects) {
+            String s = obj.getColumnString();
+            assertEquals(strings[i], s);
+            i++;
+        }
+    }
+
+    // invalid surrogate pairs:
+    // both high and low should lead to an IllegalArgumentException
+    @Test
+    public void invalidSurrogates() {
+        String high = "Invalid high surrogate \uD83C\uD83C\uDF51";
+        String low  = "Invalid low surrogate \uD83C\uDF51\uDF51";
+
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        try {
+            AllTypes highSurrogate = realm.createObject(AllTypes.class);
+            highSurrogate.setColumnString(high);
+            fail();
+        } catch (IllegalArgumentException ignored) {}
+        realm.cancelTransaction();
+
+        realm.beginTransaction();
+        try {
+            AllTypes lowSurrogate = realm.createObject(AllTypes.class);
+            lowSurrogate.setColumnString(low);
+            fail();
+        } catch (IllegalArgumentException ignored) {}
+        realm.cancelTransaction();
+    }
+
+    // removing original object and see if has been removed
+    @Test
+    public void removeFromRealm() {
+        realm.beginTransaction();
+        Dog rex = realm.createObject(Dog.class);
+        rex.setName("Rex");
+        Dog fido = realm.createObject(Dog.class);
+        fido.setName("Fido");
+        realm.commitTransaction();
+
+        RealmResults<Dog> allDogsBefore = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        assertEquals(1, allDogsBefore.size());
+
+        realm.beginTransaction();
+        rex.removeFromRealm();
+        realm.commitTransaction();
+
+        RealmResults<Dog> allDogsAfter = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        assertEquals(0, allDogsAfter.size());
+
+        fido.getName();
+        try {
+            rex.getName();
+            realm.close();
+            fail();
+        } catch (IllegalStateException ignored) {}
+
+        // deleting rex twice should fail
+        realm.beginTransaction();
+        try {
+            rex.removeFromRealm();
+            realm.close();
+            fail();
+        } catch (IllegalStateException ignored) {}
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    @Test
+    public void removeFromRealm_twiceThrows() {
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setAge(42);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        assertTrue(dog.isValid());
+        dog.removeFromRealm();
+        assertFalse(dog.isValid());
+
+        try {
+            dog.removeFromRealm();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    // query for an object, remove it and see it has been removed from realm
+    @Test
+    public void removeFromRealm_removedFromResults() {
+        realm.beginTransaction();
+        realm.clear(Dog.class);
+        Dog dogToAdd = realm.createObject(Dog.class);
+        dogToAdd.setName("Rex");
+        realm.commitTransaction();
+
+        assertEquals(1, realm.allObjects(Dog.class).size());
+
+        Dog dogToRemove = realm.where(Dog.class).findFirst();
+        assertNotNull(dogToRemove);
+        realm.beginTransaction();
+        dogToRemove.removeFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.allObjects(Dog.class).size());
+        try {
+            dogToAdd.getName();
+            realm.close();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+        try {
+            dogToRemove.getName();
+            realm.close();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+        realm.close();
+    }
+
+    private void removeOneByOne(boolean atFirst) {
+        Set<Long> ages = new HashSet<Long>();
+        realm.beginTransaction();
+        realm.clear(Dog.class);
+        for (int i = 0; i < TEST_SIZE; i++) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setAge(i);
+            ages.add((long) i);
+        }
+        realm.commitTransaction();
+
+        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+
+        RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+        for (int i = 0; i < TEST_SIZE; i++) {
+            realm.beginTransaction();
+            Dog dogToRemove;
+            if (atFirst) {
+                dogToRemove = dogs.first();
+            } else {
+                dogToRemove = dogs.last();
+            }
+            ages.remove(dogToRemove.getAge());
+            dogToRemove.removeFromRealm();
+
+            // object is no longer valid
+            try {
+                dogToRemove.getAge();
+                fail();
+            }
+            catch (IllegalStateException ignored) {}
+
+            realm.commitTransaction();
+
+            // and removed from realm and remaining objects are place correctly
+            RealmResults<Dog> remainingDogs = realm.allObjects(Dog.class);
+            assertEquals(TEST_SIZE - i - 1, remainingDogs.size());
+            for (Dog dog : remainingDogs) {
+                assertTrue(ages.contains(dog.getAge()));
+            }
+        }
+    }
+
+    @Test
+    public void removeFromRealm_atPosition() {
+        removeOneByOne(REMOVE_FIRST);
+        removeOneByOne(REMOVE_LAST);
+    }
+
+    private enum Method {
+        METHOD_GETTER,
+        METHOD_SETTER,
+        METHOD_REMOVE_FROM_REALM
+    }
+
+    private boolean runMethodOnWrongThread(final Method method) throws ExecutionException, InterruptedException {
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case METHOD_GETTER:
+                            allTypes.getColumnFloat();
+                           break;
+                        case METHOD_SETTER:
+                            allTypes.setColumnFloat(1.0f);
+                            break;
+                        case METHOD_REMOVE_FROM_REALM:
+                            allTypes.removeFromRealm();
+                            break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                }
+            }
+        });
+
+        Boolean result = future.get();
+        return result;
+    }
+
+    @Test
+    public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        for (Method method : Method.values()) {
+            assertTrue(runMethodOnWrongThread(method));
+        }
+    }
+
+    @Test
+    public void equals_sameObjectDifferentInstance() {
+        realm.beginTransaction();
+        CyclicType ct = realm.createObject(CyclicType.class);
+        ct.setName("Foo");
+        realm.commitTransaction();
+
+        CyclicType ct1 = realm.where(CyclicType.class).findFirst();
+        CyclicType ct2 = realm.where(CyclicType.class).findFirst();
+
+        assertTrue(ct1.equals(ct2));
+        assertTrue(ct2.equals(ct1));
+    }
+
+    @Test
+    public void equals_differentObjects() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("Foo");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("Bar");
+        realm.commitTransaction();
+
+        assertFalse(objA.equals(objB));
+        assertFalse(objB.equals(objA));
+    }
+
+    @Test
+    public void equals_afterModification() {
+        realm.beginTransaction();
+        CyclicType ct = realm.createObject(CyclicType.class);
+        ct.setName("Foo");
+        realm.commitTransaction();
+
+        CyclicType ct1 = realm.where(CyclicType.class).findFirst();
+        CyclicType ct2 = realm.where(CyclicType.class).findFirst();
+
+        realm.beginTransaction();
+        ct1.setName("Baz");
+        realm.commitTransaction();
+
+        assertTrue(ct1.equals(ct2));
+        assertTrue(ct2.equals(ct1));
+    }
+
+    @Test
+    public void equals_standAloneObject() {
+        realm.beginTransaction();
+        CyclicType ct1 = realm.createObject(CyclicType.class);
+        ct1.setName("Foo");
+        realm.commitTransaction();
+
+        CyclicType ct2 = new CyclicType();
+        ct2.setName("Bar");
+
+        assertFalse(ct1.equals(ct2));
+        assertFalse(ct2.equals(ct1));
+    }
+
+    @Test
+    public void equals_cyclicObject() {
+        realm.beginTransaction();
+        CyclicType foo = createCyclicData();
+        realm.commitTransaction();
+
+        assertEquals(foo, realm.where(CyclicType.class).equalTo("name", "Foo").findFirst());
+    }
+
+    @Test
+    public void toString_cyclicObject() {
+        realm.beginTransaction();
+        CyclicType foo = createCyclicData();
+        realm.commitTransaction();
+        String expected = "CyclicType = [{name:Foo},{object:CyclicType},{otherObject:null},{objects:RealmList<CyclicType>[0]}]";
+        assertEquals(expected, foo.toString());
+    }
+
+    @Test
+    public void hashCode_cyclicObject() {
+        realm.beginTransaction();
+        final CyclicType foo = createCyclicData();
+        realm.commitTransaction();
+
+        // Check that the hash code is always the same between multiple calls.
+        assertEquals(foo.hashCode(), foo.hashCode());
+        // Check that the hash code is the same among same object
+        assertEquals(foo.hashCode(), realm.where(CyclicType.class).equalTo("name", foo.getName()).findFirst().hashCode());
+        // hash code is different from other objects.
+        assertNotEquals(foo.getObject().hashCode(), foo.hashCode());
+
+        final int originalHashCode = foo.hashCode();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                foo.setName(foo.getName() + "1234");
+            }
+        });
+        // Check that Updating the value of its field does not affect the hash code.
+        assertEquals(originalHashCode, foo.hashCode());
+
+        // Check the hash code of the object from a Realm in different file name.
+        RealmConfiguration realmConfig_differentName = configFactory.createConfiguration(
+                "another_" + realmConfig.getRealmFileName());
+        Realm realm_differentName = Realm.getInstance(realmConfig_differentName);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm_differentName.beginTransaction();
+            CyclicType fooFromDifferentName = createCyclicData(realm_differentName);
+            realm_differentName.commitTransaction();
+
+            assertNotEquals(fooFromDifferentName.hashCode(), foo.hashCode());
+        } finally {
+            realm_differentName.close();
+        }
+
+        // Check the hash code of the object from a Realm in different folder.
+        RealmConfiguration realmConfig_differentPath = configFactory.createConfiguration(
+                "anotherDir", realmConfig.getRealmFileName());
+        Realm realm_differentPath = Realm.getInstance(realmConfig_differentPath);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm_differentPath.beginTransaction();
+            CyclicType fooFromDifferentPath = createCyclicData(realm_differentPath);
+            realm_differentPath.commitTransaction();
+
+            assertNotEquals(fooFromDifferentPath.hashCode(), foo.hashCode());
+        } finally {
+            realm_differentPath.close();
+        }
+    }
+
+    private CyclicType createCyclicData(Realm realm) {
+        CyclicType foo = realm.createObject(CyclicType.class);
+        foo.setName("Foo");
+        CyclicType bar = realm.createObject(CyclicType.class);
+        bar.setName("Bar");
+
+        // Setup cycle on normal object references
+        foo.setObject(bar);
+        bar.setObject(foo);
+        return foo;
+    }
+
+    private CyclicType createCyclicData() {
+        return createCyclicData(realm);
+    }
+
+    @Test
+    public void dateType() {
+        long testDatesValid[] = {-1000, 0, 1000};
+        long testDatesLoosePrecision[] = {Long.MIN_VALUE, 1, 1001, Long.MAX_VALUE};
+
+        // test valid dates
+        realm.beginTransaction();
+        for (long value : testDatesValid) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnDate(new Date(value));
+        }
+        realm.commitTransaction();
+
+        int i = 0;
+        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
+            assertEquals("Item " + i, new Date(testDatesValid[i]), allTypes.getColumnDate());
+            i++;
+        }
+
+        // test valid dates but with precision lost
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        for (long value : testDatesLoosePrecision) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnDate(new Date(value));
+        }
+        realm.commitTransaction();
+
+        i = 0;
+        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
+            assertFalse("Item " + i, new Date(testDatesLoosePrecision[i]) == allTypes.getColumnDate());
+            assertEquals("Item " + i, new Date(1000*(testDatesLoosePrecision[i]/1000)), allTypes.getColumnDate());
+            i++;
+        }
+    }
+
+    private Date newDate(int year, int month, int dayOfMonth) {
+        Calendar cal = Calendar.getInstance();
+        cal.set(Calendar.YEAR, year);
+        cal.set(Calendar.MONTH, month);
+        cal.set(Calendar.DAY_OF_MONTH, dayOfMonth);
+        cal.set(Calendar.HOUR, 0);
+        cal.set(Calendar.MINUTE, 0);
+        cal.set(Calendar.MILLISECOND, 0);
+        return cal.getTime();
+    }
+
+    @Test
+    public void setter_outsideTransactionThrows() {
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        thrown.expect(IllegalStateException.class);
+        dog.setName("Rex");
+    }
+
+    @Test
+    public void setter_link_null() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("Foo");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("Bar");
+
+        objA.setObject(objB);
+
+        assertNotNull(objA.getObject());
+
+        try {
+            objA.setObject(null);
+        } catch (NullPointerException nullPointer) {
+            fail();
+        }
+        realm.commitTransaction();
+        assertNull(objA.getObject());
+    }
+
+    @Test
+    public void setter_link_standaloneObject() {
+        CyclicType standalone = new CyclicType();
+
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            try {
+                target.setObject(standalone);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_link_deletedObject() {
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            CyclicType removed = realm.createObject(CyclicType.class);
+            removed.removeFromRealm();
+
+            try {
+                target.setObject(removed);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_link_closedObject() {
+        realm.beginTransaction();
+        CyclicType closed = realm.createObject(CyclicType.class);
+        realm.commitTransaction();
+        realm.close();
+        assertTrue(realm.isClosed());
+
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            try {
+                target.setObject(closed);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_link_objectFromOtherRealm() {
+        RealmConfiguration config = configFactory.createConfiguration("another.realm");
+        Realm anotherRealm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            anotherRealm.beginTransaction();
+            CyclicType objFromAnotherRealm = anotherRealm.createObject(CyclicType.class);
+            anotherRealm.commitTransaction();
+
+            realm.beginTransaction();
+            try {
+                CyclicType target = realm.createObject(CyclicType.class);
+
+                try {
+                    target.setObject(objFromAnotherRealm);
+                    fail();
+                } catch (IllegalArgumentException ignored) {
+                }
+            } finally {
+                realm.cancelTransaction();
+            }
+        } finally {
+            anotherRealm.close();
+        }
+    }
+
+    @Test
+    public void setter_link_objectFromAnotherThread() throws InterruptedException {
+        final CountDownLatch createLatch = new CountDownLatch(1);
+        final CountDownLatch testEndLatch = new CountDownLatch(1);
+
+        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<>();
+
+        java.lang.Thread thread = new java.lang.Thread() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+
+                // 1. create an object
+                realm.beginTransaction();
+                objFromAnotherThread.set(realm.createObject(CyclicType.class));
+                realm.commitTransaction();
+
+                createLatch.countDown();
+                try {
+                    testEndLatch.await();
+                } catch (InterruptedException ignored) {
+                }
+
+                // 3. close Realm in this thread and finish.
+                realm.close();
+            }
+        };
+        thread.start();
+
+        createLatch.await();
+        // 2. set created object to target
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+            try {
+                target.setObject(objFromAnotherThread.get());
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            testEndLatch.countDown();
+            realm.cancelTransaction();
+        }
+
+        // wait for finishing the thread
+        thread.join();
+    }
+
+    @Test
+    public void setter_list_withStandaloneObject() {
+        CyclicType standalone = new CyclicType();
+
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            RealmList<CyclicType> list = new RealmList<>();
+            list.add(realm.createObject(CyclicType.class));
+            list.add(standalone); // List contains a standalone object
+            list.add(realm.createObject(CyclicType.class));
+
+            try {
+                target.setObjects(list);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_list_withDeletedObject() {
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            CyclicType removed = realm.createObject(CyclicType.class);
+            removed.removeFromRealm();
+
+            RealmList<CyclicType> list = new RealmList<>();
+            list.add(realm.createObject(CyclicType.class));
+            list.add(removed); // List contains a deleted object
+            list.add(realm.createObject(CyclicType.class));
+
+            try {
+                target.setObjects(list);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_list_withClosedObject() {
+        realm.beginTransaction();
+        CyclicType closed = realm.createObject(CyclicType.class);
+        realm.commitTransaction();
+        realm.close();
+        assertTrue(realm.isClosed());
+
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            RealmList<CyclicType> list = new RealmList<>();
+            list.add(realm.createObject(CyclicType.class));
+            list.add(closed); // List contains a closed object
+            list.add(realm.createObject(CyclicType.class));
+
+            try {
+                target.setObjects(list);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void setter_list_withObjectFromAnotherRealm() {
+        RealmConfiguration config = configFactory.createConfiguration("another.realm");
+        Realm anotherRealm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            anotherRealm.beginTransaction();
+            CyclicType objFromAnotherRealm = anotherRealm.createObject(CyclicType.class);
+            anotherRealm.commitTransaction();
+
+            realm.beginTransaction();
+            try {
+                CyclicType target = realm.createObject(CyclicType.class);
+
+                RealmList<CyclicType> list = new RealmList<>();
+                list.add(realm.createObject(CyclicType.class));
+                list.add(objFromAnotherRealm); // List contains an object from another Realm
+                list.add(realm.createObject(CyclicType.class));
+
+                try {
+                    target.setObjects(list);
+                    fail();
+                } catch (IllegalArgumentException ignored) {
+                }
+            } finally {
+                realm.cancelTransaction();
+            }
+        } finally {
+            anotherRealm.close();
+        }
+    }
+
+    @Test
+    public void setter_list_withObjectFromAnotherThread() throws InterruptedException {
+        final CountDownLatch createLatch = new CountDownLatch(1);
+        final CountDownLatch testEndLatch = new CountDownLatch(1);
+
+        final AtomicReference<CyclicType> objFromAnotherThread = new AtomicReference<>();
+
+        java.lang.Thread thread = new java.lang.Thread() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+
+                // 1. create an object
+                realm.beginTransaction();
+                objFromAnotherThread.set(realm.createObject(CyclicType.class));
+                realm.commitTransaction();
+
+                createLatch.countDown();
+                try {
+                    testEndLatch.await();
+                } catch (InterruptedException ignored) {
+                }
+
+                // 3. close Realm in this thread and finish.
+                realm.close();
+            }
+        };
+        thread.start();
+
+        createLatch.await();
+        // 2. set created object to target
+        realm.beginTransaction();
+        try {
+            CyclicType target = realm.createObject(CyclicType.class);
+
+            RealmList<CyclicType> list = new RealmList<>();
+            list.add(realm.createObject(CyclicType.class));
+            list.add(objFromAnotherThread.get()); // List contains an object from another thread.
+            list.add(realm.createObject(CyclicType.class));
+
+            try {
+                target.setObjects(list);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        } finally {
+            testEndLatch.countDown();
+            realm.cancelTransaction();
+        }
+
+        // wait for finishing the thread
+        thread.join();
+    }
+
+    @Test
+    public void classNameConflictsWithFrameworkClass() {
+        // The model class' name (Thread) clashed with a common Java class.
+        // The annotation process must be able to handle that.
+        realm.beginTransaction();
+        @SuppressWarnings("unused")
+        Thread thread = realm.createObject(Thread.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void isValid_standaloneObject() {
+        AllTypes allTypes = new AllTypes();
+        assertFalse(allTypes.isValid());
+    }
+
+    @Test
+    public void isValid_closedRealm() {
+        RealmConfiguration otherConfig = configFactory.createConfiguration("other-realm");
+        Realm testRealm = Realm.getInstance(otherConfig);
+        testRealm.beginTransaction();
+        AllTypes allTypes = testRealm.createObject(AllTypes.class);
+        assertTrue(allTypes.isValid());
+        testRealm.commitTransaction();
+        testRealm.close();
+        assertFalse(allTypes.isValid());
+    }
+
+    @Test
+    public void IsValid_deletedObject() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        assertTrue(allTypes.isValid());
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+        assertFalse(allTypes.isValid());
+    }
+
+    @Test
+    public void isValid_managedObject() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        assertTrue(allTypes.isValid());
+        realm.commitTransaction();
+        assertTrue(allTypes.isValid());
+    }
+
+    // store and retrieve null values for nullable fields
+    @Test
+    public void set_get_nullOnNullableFields() {
+        realm.beginTransaction();
+        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        // 1 String
+        nullTypes.setFieldStringNull(null);
+        // 2 Bytes
+        nullTypes.setFieldBytesNull(null);
+        // 3 Boolean
+        nullTypes.setFieldBooleanNull(null);
+        // 4 Byte
+        nullTypes.setFieldByteNull(null);
+        // 5 Short
+        nullTypes.setFieldShortNull(null);
+        // 6 Integer
+        nullTypes.setFieldIntegerNull(null);
+        // 7 Long
+        nullTypes.setFieldLongNull(null);
+        // 8 Float
+        nullTypes.setFieldFloatNull(null);
+        // 9 Double
+        nullTypes.setFieldDoubleNull(null);
+        // 10 Date
+        nullTypes.setFieldDateNull(null);
+        realm.commitTransaction();
+
+        nullTypes = realm.where(NullTypes.class).findFirst();
+        // 1 String
+        assertNull(nullTypes.getFieldStringNull());
+        // 2 Bytes
+        assertNull(nullTypes.getFieldBytesNull());
+        // 3 Boolean
+        assertNull(nullTypes.getFieldBooleanNull());
+        // 4 Byte
+        assertNull(nullTypes.getFieldByteNull());
+        // 5 Short
+        assertNull(nullTypes.getFieldShortNull());
+        // 6 Integer
+        assertNull(nullTypes.getFieldIntegerNull());
+        // 7 Long
+        assertNull(nullTypes.getFieldLongNull());
+        // 8 Float
+        assertNull(nullTypes.getFieldFloatNull());
+        // 9 Double
+        assertNull(nullTypes.getFieldDoubleNull());
+        // 10 Date
+        assertNull(nullTypes.getFieldDateNull());
+    }
+
+    // store and retrieve non-null values when field can contain null strings
+    @Test
+    public void get_set_nonNullValueOnNullableFields() {
+        final String testString = "FooBar";
+        final byte[] testBytes = new byte[] {42};
+        final Date testDate = newDate(2000, 1, 1);
+        realm.beginTransaction();
+        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        // 1 String
+        nullTypes.setFieldStringNull(testString);
+        // 2 Bytes
+        nullTypes.setFieldBytesNull(testBytes);
+        // 3 Boolean
+        nullTypes.setFieldBooleanNull(true);
+        // 4 Byte
+        nullTypes.setFieldByteNull((byte)42);
+        // 5 Short
+        nullTypes.setFieldShortNull((short)42);
+        // 6 Integer
+        nullTypes.setFieldIntegerNull(42);
+        // 7 Long
+        nullTypes.setFieldLongNull(42L);
+        // 8 Float
+        nullTypes.setFieldFloatNull(42.42F);
+        // 9 Double
+        nullTypes.setFieldDoubleNull(42.42D);
+        // 10 Date
+        nullTypes.setFieldDateNull(testDate);
+        realm.commitTransaction();
+
+        nullTypes = realm.where(NullTypes.class).findFirst();
+        // 1 String
+        assertEquals(testString, nullTypes.getFieldStringNull());
+        // 2 Bytes
+        assertArrayEquals(testBytes, nullTypes.getFieldBytesNull());
+        // 3 Boolean
+        assertTrue(nullTypes.getFieldBooleanNull());
+        // 4 Byte
+        assertEquals((byte)42, (byte)nullTypes.getFieldByteNull().intValue());
+        // 5 Short
+        assertEquals((short)42, (short)nullTypes.getFieldShortNull().intValue());
+        // 6 Integer
+        assertEquals(42, nullTypes.getFieldIntegerNull().intValue());
+        // 7 Long
+        assertEquals(42L, nullTypes.getFieldLongNull().longValue());
+        // 8 Float
+        assertEquals(42.42F, nullTypes.getFieldFloatNull(), 0.0F);
+        // 9 Double
+        assertEquals(42.42D, nullTypes.getFieldDoubleNull(), 0.0D);
+        // 10 Date
+        assertEquals(testDate.getTime(), nullTypes.getFieldDateNull().getTime());
+    }
+
+    // try to store null values in non-nullable fields
+    @Test
+    public void set_nullValuesToNonNullableFields() {
+        try {
+            realm.beginTransaction();
+            NullTypes nullTypes = realm.createObject(NullTypes.class);
+            // 1 String
+            try {
+                nullTypes.setFieldStringNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 2 Bytes
+            try {
+                nullTypes.setFieldBytesNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 3 Boolean
+            try {
+                nullTypes.setFieldBooleanNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 4 Byte
+            try {
+                nullTypes.setFieldByteNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 5 Short
+            try {
+                nullTypes.setFieldShortNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 6 Integer
+            try {
+                nullTypes.setFieldIntegerNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 7 Long
+            try {
+                nullTypes.setFieldLongNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 8 Float
+            try {
+                nullTypes.setFieldFloatNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 9 Double
+            try {
+                nullTypes.setFieldDoubleNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            // 10 Date
+            try {
+                nullTypes.setFieldDateNotNull(null);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+        finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void defaultValuesForNewObject() {
+        realm.beginTransaction();
+        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        realm.commitTransaction();
+
+        assertNotNull(nullTypes);
+        assertEquals(0, nullTypes.getId());
+        // 1 String
+        assertEquals("", nullTypes.getFieldStringNotNull());
+        assertNull(nullTypes.getFieldStringNull());
+        // 2 Bytes
+        assertArrayEquals(new byte[0], nullTypes.getFieldBytesNotNull());
+        assertNull(nullTypes.getFieldByteNull());
+        // 3 Boolean
+        assertFalse(nullTypes.getFieldBooleanNotNull());
+        assertNull(nullTypes.getFieldBooleanNull());
+        // 4 Byte
+        assertEquals(0, nullTypes.getFieldByteNotNull().byteValue());
+        assertNull(nullTypes.getFieldByteNull());
+        // 5 Short
+        assertEquals(0, nullTypes.getFieldShortNotNull().shortValue());
+        assertNull(nullTypes.getFieldShortNull());
+        // 6 Integer
+        assertEquals(0, nullTypes.getFieldIntegerNotNull().intValue());
+        assertNull(nullTypes.getFieldIntegerNull());
+        // 7 Long
+        assertEquals(0, nullTypes.getFieldLongNotNull().longValue());
+        assertNull(nullTypes.getFieldLongNull());
+        // 8 Float
+        assertEquals(0F, nullTypes.getFieldFloatNotNull(), 0.0F);
+        assertNull(nullTypes.getFieldFloatNull());
+        // 9 Double
+        assertEquals(0D, nullTypes.getFieldDoubleNotNull(), 0.0D);
+        assertNull(nullTypes.getFieldDoubleNull());
+        // 10 Date
+        assertEquals(new Date(0), nullTypes.getFieldDateNotNull());
+        assertNull(nullTypes.getFieldDateNull());
+    }
+
+    @Test
+    public void getter_afterDeleteFromOtherThreadThrows() {
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final CountDownLatch objectDeletedInBackground = new CountDownLatch(1);
+        new java.lang.Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                realm.beginTransaction();
+                realm.clear(AllTypes.class);
+                realm.commitTransaction();
+                realm.close();
+                objectDeletedInBackground.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(objectDeletedInBackground);
+        realm.refresh(); // Move to version where underlying object is deleted.
+
+        // Object should no longer be available
+        assertFalse(obj.isValid());
+        thrown.expect(IllegalStateException.class);
+        obj.getColumnLong();
+    }
+
+    @Test
+    public void isValid() {
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName("Fido");
+        realm.commitTransaction();
+
+        assertTrue(dog.isValid());
+
+        realm.beginTransaction();
+        dog.removeFromRealm();
+        realm.commitTransaction();
+
+        assertFalse(dog.isValid());
+    }
+
+    // Test NaN value on float and double columns
+    @Test
+    public void float_double_NaN() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.NaN);
+        allTypes.setColumnDouble(Double.NaN);
+        realm.commitTransaction();
+        assertEquals(Float.NaN, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.NaN, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        // NaN != NaN !!!
+        assertEquals(0, realm.where(AllTypes.class).equalTo("columnFloat", Float.NaN).count());
+        assertEquals(0, realm.where(AllTypes.class).equalTo("columnDouble", Double.NaN).count());
+    }
+
+    // Test max value on float and double columns
+    @Test
+    public void float_double_maxValue() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MAX_VALUE);
+        allTypes.setColumnDouble(Double.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(Float.MAX_VALUE, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.MAX_VALUE, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnFloat", Float.MAX_VALUE).count());
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MAX_VALUE).count());
+    }
+
+    // Test min normal value on float and double columns
+    @Test
+    public void float_double_minNormal() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MIN_NORMAL);
+        allTypes.setColumnDouble(Double.MIN_NORMAL);
+        realm.commitTransaction();
+        assertEquals(Float.MIN_NORMAL, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.MIN_NORMAL, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnFloat", Float.MIN_NORMAL).count());
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_NORMAL).count());
+    }
+
+    // Test min value on float and double columns
+    @Test
+    public void float_double_minValue() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.MIN_VALUE);
+        allTypes.setColumnDouble(Double.MIN_VALUE);
+        realm.commitTransaction();
+        assertEquals(Float.MIN_VALUE, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.MIN_VALUE, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnFloat", Float.MIN_VALUE).count());
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.MIN_VALUE).count());
+    }
+
+    // Test negative infinity value on float and double columns
+    @Test
+    public void float_double_negativeInfinity() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.NEGATIVE_INFINITY);
+        allTypes.setColumnDouble(Double.NEGATIVE_INFINITY);
+        realm.commitTransaction();
+        assertEquals(Float.NEGATIVE_INFINITY, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.NEGATIVE_INFINITY, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnFloat", Float.NEGATIVE_INFINITY).count());
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.NEGATIVE_INFINITY).count());
+    }
+
+    // Test positive infinity value on float and double columns
+    @Test
+    public void float_double_positiveInfinity() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(Float.POSITIVE_INFINITY);
+        allTypes.setColumnDouble(Double.POSITIVE_INFINITY);
+        realm.commitTransaction();
+        assertEquals(Float.POSITIVE_INFINITY, realm.where(AllTypes.class).findFirst().getColumnFloat(), 0.0F);
+        assertEquals(Double.POSITIVE_INFINITY, realm.where(AllTypes.class).findFirst().getColumnDouble(), 0.0D);
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnFloat", Float.POSITIVE_INFINITY).count());
+        assertEquals(1, realm.where(AllTypes.class).equalTo("columnDouble", Double.POSITIVE_INFINITY).count());
+    }
+
+    private RealmConfiguration prepareColumnSwappedRealm() throws FileNotFoundException {
+
+        final RealmConfiguration columnSwappedRealmConfigForV0 = configFactory.createConfigurationBuilder()
+                .name("columnSwapped.realm")
+                .migration(new RealmMigration() {
+                    @Override
+                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                        final Table table = realm.schema.getTable(StringAndInt.class);
+                        final long strIndex = table.getColumnIndex("str");
+                        final long numberIndex = table.getColumnIndex("number");
+
+                        while (0 < table.getColumnCount()) {
+                            table.removeColumn(0);
+                        }
+
+                        final long newStrIndex;
+                        // swap column indices
+                        if (strIndex < numberIndex) {
+                            table.addColumn(RealmFieldType.INTEGER, "number");
+                            newStrIndex = table.addColumn(RealmFieldType.STRING, "str");
+                        } else {
+                            newStrIndex = table.addColumn(RealmFieldType.STRING, "str");
+                            table.addColumn(RealmFieldType.INTEGER, "number");
+                        }
+                        table.convertColumnToNullable(newStrIndex);
+                    }
+                })
+                .build();
+
+        final RealmConfiguration columnSwappedRealmConfigForV1 = configFactory.createConfigurationBuilder()
+                .name("columnSwapped.realm")
+                .migration(new RealmMigration() {
+                    @Override
+                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                        // Do nothing
+                    }
+                })
+                .schemaVersion(1L)
+                .build();
+
+        Realm.deleteRealm(columnSwappedRealmConfigForV0);
+        Realm.getInstance(columnSwappedRealmConfigForV0).close();
+        Realm.migrateRealm(columnSwappedRealmConfigForV0);
+        return columnSwappedRealmConfigForV1;
+    }
+
+    @Test
+    public void realmProxy_columnIndex() throws FileNotFoundException {
+        final RealmConfiguration configForSwapped = prepareColumnSwappedRealm();
+
+        // open swapped Realm in order to load column index
+        Realm.getInstance(configForSwapped).close();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final StringAndInt obj = RealmObjectTests.this.realm.createObject(StringAndInt.class);
+                /*
+                 * If https://github.com/realm/realm-java/issues/1611 issue exists,
+                 * setter/getter of RealmObjectProxy uses last loaded column index for every Realm.
+                 */
+                obj.setStr("foo");
+                obj.getStr();
+            }
+        });
+    }
+
+    @Test
+    public void conflictingFieldName_readAndUpdate() {
+        final ConflictingFieldName standalone = new ConflictingFieldName();
+        standalone.setRealm("realm");
+        standalone.setRow("row");
+        standalone.setIsCompleted("isCompleted");
+        standalone.setListeners("listeners");
+        standalone.setPendingQuery("pendingQuery");
+        standalone.setCurrentTableVersion("currentTableVersion");
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.copyToRealm(standalone);
+            }
+        });
+
+        // tests those values are persisted
+        final ConflictingFieldName managed = realm.where(ConflictingFieldName.class).findFirst();
+        assertEquals("realm", managed.getRealm());
+        assertEquals("row", managed.getRow());
+        assertEquals("isCompleted", managed.getIsCompleted());
+        assertEquals("listeners", managed.getListeners());
+        assertEquals("pendingQuery", managed.getPendingQuery());
+        assertEquals("currentTableVersion", managed.getCurrentTableVersion());
+
+        // tests those values can be updated
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                managed.setRealm("realm_updated");
+                managed.setRow("row_updated");
+                managed.setIsCompleted("isCompleted_updated");
+                managed.setListeners("listeners_updated");
+                managed.setPendingQuery("pendingQuery_updated");
+                managed.setCurrentTableVersion("currentTableVersion_updated");
+            }
+        });
+
+        assertEquals("realm_updated", managed.getRealm());
+        assertEquals("row_updated", managed.getRow());
+        assertEquals("isCompleted_updated", managed.getIsCompleted());
+        assertEquals("listeners_updated", managed.getListeners());
+        assertEquals("pendingQuery_updated", managed.getPendingQuery());
+        assertEquals("currentTableVersion_updated", managed.getCurrentTableVersion());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
new file mode 100644
index 0000000000..34d2905794
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -0,0 +1,2447 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Looper;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.CatOwner;
+import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
+import io.realm.entities.StringOnly;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmQueryTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    protected final static int TEST_DATA_SIZE = 10;
+
+    private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void populateTestRealm(Realm testRealm, int objects) {
+        testRealm.beginTransaction();
+        testRealm.allObjects(AllTypes.class).clear();
+        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
+            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+            nonLatinFieldNames.set베타(1.234567f + i);
+            nonLatinFieldNames.setΒήτα(1.234567f + i);
+        }
+        testRealm.commitTransaction();
+    }
+
+    private void populateTestRealm() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+    }
+
+    @Test
+    public void between() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .between(AllTypes.FIELD_LONG, 0, 9).findAll();
+        assertEquals(10, resultList.size());
+
+        resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data ").findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+
+        resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data 1")
+                .between(AllTypes.FIELD_LONG, 2, 20).findAll();
+        assertEquals(10, resultList.size());
+
+        resultList = realm.where(AllTypes.class).between(AllTypes.FIELD_LONG, 2, 20)
+                .beginsWith(AllTypes.FIELD_STRING, "test data 1").findAll();
+        assertEquals(10, resultList.size());
+
+        assertEquals(51, realm.where(AllTypes.class).between(AllTypes.FIELD_DATE,
+                new Date(0),
+                new Date(DECADE_MILLIS * 50)).count());
+    }
+
+    @Test
+    public void greaterThan() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .greaterThan(AllTypes.FIELD_FLOAT, 10.234567f).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 10, resultList.size());
+
+        resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data 1")
+                .greaterThan(AllTypes.FIELD_FLOAT, 50.234567f).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.234567f);
+        resultList = query.between(AllTypes.FIELD_LONG, 1, 20).findAll();
+        assertEquals(10, resultList.size());
+    }
+
+    @Test
+    public void greaterThan_date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(179, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT / 2 - 1, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(19, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+
+    @Test
+    public void greaterThanOrEqualTo() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 10.234567f).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 9, resultList.size());
+
+        resultList = realm.where(AllTypes.class).beginsWith(AllTypes.FIELD_STRING, "test data 1")
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 50.234567f).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class)
+                .greaterThanOrEqualTo(AllTypes.FIELD_FLOAT, 11.234567f);
+        query = query.between(AllTypes.FIELD_LONG, 1, 20);
+
+        resultList = query.beginsWith(AllTypes.FIELD_STRING, "test data 15").findAll();
+        assertEquals(1, resultList.size());
+    }
+
+    @Test
+    public void greaterThanOrEqualTo_date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(180, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT / 2, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(20, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void or() {
+        populateTestRealm(realm, 200);
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.234567f);
+        RealmResults<AllTypes> resultList = query.or().between(AllTypes.FIELD_LONG, 1, 20).findAll();
+        assertEquals(21, resultList.size());
+
+        resultList = query.or().equalTo(AllTypes.FIELD_STRING, "test data 15").findAll();
+        assertEquals(21, resultList.size());
+
+        resultList = query.or().equalTo(AllTypes.FIELD_STRING, "test data 117").findAll();
+        assertEquals(22, resultList.size());
+    }
+
+    @Test
+    public void not() {
+        populateTestRealm(); // create TEST_DATA_SIZE objects
+
+        // only one object with value 5 -> TEST_DATA_SIZE-1 object with value "not 5"
+        RealmResults<AllTypes> list1 = realm.where(AllTypes.class).not().equalTo(AllTypes.FIELD_LONG, 5).findAll();
+        assertEquals(TEST_DATA_SIZE - 1, list1.size());
+
+        // not().greater() and lessThenOrEqual() must be the same
+        RealmResults<AllTypes> list2 = realm.where(AllTypes.class).not().greaterThan(AllTypes.FIELD_LONG, 5).findAll();
+        RealmResults<AllTypes> list3 = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_LONG, 5).findAll();
+        assertEquals(list2.size(), list3.size());
+        for (int i = 0; i < list2.size(); i++) {
+            assertEquals(list2.get(i).getColumnLong(), list3.get(i).getColumnLong());
+        }
+
+        // excepted result: 0, 1, 2, 5
+        long expected[] = {0, 1, 2, 5};
+        RealmResults<AllTypes> list4 = realm.where(AllTypes.class)
+                .equalTo(AllTypes.FIELD_LONG, 5)
+                .or()
+                .not().beginGroup()
+                .greaterThan(AllTypes.FIELD_LONG, 2)
+                .endGroup()
+                .findAll();
+        assertEquals(4, list4.size());
+        for (int i = 0; i < list4.size(); i++) {
+            assertEquals(expected[i], list4.get(i).getColumnLong());
+        }
+    }
+
+    @Test (expected = UnsupportedOperationException.class)
+    public void not_aloneThrows() {
+        // a not() alone must fail
+        realm.where(AllTypes.class).not().findAll();
+    }
+
+    @Test
+    public void and_implicit() {
+        populateTestRealm(realm, 200);
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 31.234567f);
+        RealmResults<AllTypes> resultList = query.between(AllTypes.FIELD_LONG, 1, 10).findAll();
+        assertEquals(0, resultList.size());
+
+        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 81.234567f);
+        resultList = query.between(AllTypes.FIELD_LONG, 1, 100).findAll();
+        assertEquals(1, resultList.size());
+    }
+
+    @Test
+    public void lessThan() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).
+                lessThan(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+        assertEquals(30, resultList.size());
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_FLOAT, 31.234567f);
+        resultList = query.between(AllTypes.FIELD_LONG, 1, 10).findAll();
+        assertEquals(10, resultList.size());
+    }
+
+    @Test
+    public void lessThan_Date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(20, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT / 2, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(180, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+    }
+
+    @Test
+    public void lessThanOrEqualTo() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+        assertEquals(31, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_FLOAT, 31.234567f)
+                .between(AllTypes.FIELD_LONG, 11, 20).findAll();
+        assertEquals(10, resultList.size());
+    }
+
+    @Test
+    public void lessThanOrEqualTo_date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(21, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT / 2 + 1, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(181, resultList.size());
+        resultList = realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+    }
+
+    @Test
+    public void equalTo() {
+        populateTestRealm(realm, 200);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.0f)
+                .equalTo(AllTypes.FIELD_LONG, 10).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 11.0f)
+                .equalTo(AllTypes.FIELD_LONG, 1).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void equalTo_date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void equalTo_nonLatinCharacters() {
+        populateTestRealm(realm, 200);
+
+        RealmResults<NonLatinFieldNames> resultList = realm.where(NonLatinFieldNames.class)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR, 13).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NonLatinFieldNames.class)
+                .greaterThan(NonLatinFieldNames.FIELD_FLOAT_KOREAN_CHAR, 11.0f)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR, 10).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NonLatinFieldNames.class)
+                .greaterThan(NonLatinFieldNames.FIELD_FLOAT_KOREAN_CHAR, 11.0f)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR, 1).findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(NonLatinFieldNames.class)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR, 13).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NonLatinFieldNames.class)
+                .greaterThan(NonLatinFieldNames.FIELD_FLOAT_GREEK_CHAR, 11.0f)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR, 10).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NonLatinFieldNames.class)
+                .greaterThan(NonLatinFieldNames.FIELD_FLOAT_GREEK_CHAR, 11.0f)
+                .equalTo(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR, 1).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void notEqualTo() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .notEqualTo(AllTypes.FIELD_LONG, 31).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.234567f)
+                .equalTo(AllTypes.FIELD_LONG, 10).findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_FLOAT, 11.234567f)
+                .equalTo(AllTypes.FIELD_LONG, 1).findAll();
+        assertEquals(1, resultList.size());
+    }
+
+    @Test
+    public void notEqualTo_date() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList;
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_DATE, new Date(Long.MIN_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * -80)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_DATE, new Date(0)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_DATE, new Date(DECADE_MILLIS * 80)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
+        resultList = realm.where(AllTypes.class).notEqualTo(AllTypes.FIELD_DATE, new Date(Long.MAX_VALUE)).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+    }
+
+    @Test
+    public void contains_caseSensitive() {
+        final int TEST_OBJECTS_COUNT = 200;
+        populateTestRealm(realm, TEST_OBJECTS_COUNT);
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .contains("columnString", "DaTa 0", Case.INSENSITIVE)
+                .or().contains("columnString", "20")
+                .findAll();
+        assertEquals(3, resultList.size());
+
+        resultList = realm.where(AllTypes.class).contains("columnString", "DATA").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class)
+                .contains("columnString", "TEST", Case.INSENSITIVE).findAll();
+        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
+    }
+
+    @Test
+    public void contains_caseSensitiveWithNonLatinCharacters() {
+        populateTestRealm();
+
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("Αλφα");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("βήτα");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("δέλτα");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class)
+                .contains("columnString", "Α", Case.INSENSITIVE)
+                .or().contains("columnString", "δ")
+                .findAll();
+        // Without case sensitive there is 3, Α = α
+        // assertEquals(3,resultList.size());
+        assertEquals(2, resultList.size());
+
+        resultList = realm.where(AllTypes.class).contains("columnString", "α").findAll();
+        assertEquals(3, resultList.size());
+
+        resultList = realm.where(AllTypes.class).contains("columnString", "Δ").findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).contains("columnString", "Δ",
+                Case.INSENSITIVE).findAll();
+        // Without case sensitive there is 1, Δ = δ
+        // assertEquals(1,resultList.size());
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void equalTo_withNonExistingField() {
+        try {
+            realm.where(AllTypes.class).equalTo("NotAField", 13).findAll();
+            fail("Should throw exception");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void queryLink() {
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        Dog dog1 = realm.createObject(Dog.class);
+        dog1.setName("Dog 1");
+        dog1.setWeight(1);
+        Dog dog2 = realm.createObject(Dog.class);
+        dog2.setName("Dog 2");
+        dog2.setWeight(2);
+        owner.getDogs().add(dog1);
+        owner.getDogs().add(dog2);
+        realm.commitTransaction();
+
+        // Dog.weight has index 4 which is more than the total number of columns in Owner
+        // This tests exposes a subtle error where the Owner table spec is used instead of Dog table spec.
+        RealmResults<Dog> dogs = realm.where(Owner.class).findFirst().getDogs().where()
+                .findAllSorted("name", Sort.ASCENDING);
+        Dog dog = dogs.where().equalTo("weight", 1d).findFirst();
+        assertEquals(dog1, dog);
+    }
+
+
+    @Test
+    public void findAllSorted_multiFailures() {
+        // zero fields specified
+        try {
+            realm.where(AllTypes.class).findAllSorted(new String[]{}, new Sort[]{});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // number of fields and sorting orders don't match
+        try {
+            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING},
+                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // null is not allowed
+        try {
+            realm.where(AllTypes.class).findAllSorted((String[]) null, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING}, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // non-existing field name
+        try {
+            realm.where(AllTypes.class)
+                    .findAllSorted(new String[]{AllTypes.FIELD_STRING, "do-not-exist"},
+                            new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void findAllSorted_singleField() {
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_DATA_SIZE; i++) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+        }
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> sortedList = realm.where(AllTypes.class)
+                .findAllSorted(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
+        assertEquals(0, sortedList.last().getColumnLong());
+    }
+
+    @Test
+    public void subQueryScope() {
+        populateTestRealm();
+        RealmResults<AllTypes> result = realm.where(AllTypes.class).lessThan("columnLong", 5).findAll();
+        RealmResults<AllTypes> subQueryResult = result.where().greaterThan("columnLong", 3).findAll();
+        assertEquals(1, subQueryResult.size());
+    }
+
+    @Test
+    public void findFirst() {
+        realm.beginTransaction();
+        Owner owner1 = realm.createObject(Owner.class);
+        owner1.setName("Owner 1");
+        Dog dog1 = realm.createObject(Dog.class);
+        dog1.setName("Dog 1");
+        dog1.setWeight(1);
+        Dog dog2 = realm.createObject(Dog.class);
+        dog2.setName("Dog 2");
+        dog2.setWeight(2);
+        owner1.getDogs().add(dog1);
+        owner1.getDogs().add(dog2);
+
+        Owner owner2 = realm.createObject(Owner.class);
+        owner2.setName("Owner 2");
+        Dog dog3 = realm.createObject(Dog.class);
+        dog3.setName("Dog 3");
+        dog3.setWeight(1);
+        Dog dog4 = realm.createObject(Dog.class);
+        dog4.setName("Dog 4");
+        dog4.setWeight(2);
+        owner2.getDogs().add(dog3);
+        owner2.getDogs().add(dog4);
+        realm.commitTransaction();
+
+        RealmList<Dog> dogs = realm.where(Owner.class).equalTo("name", "Owner 2").findFirst().getDogs();
+        Dog dog = dogs.where().equalTo("name", "Dog 4").findFirst();
+        assertEquals(dog4, dog);
+    }
+
+    @Test
+    public void georgian() {
+        String words[] = {"მონაცემთა ბაზა", "მიწისქვეშა გადასასვლელი", "რუსთაველის გამზირი",
+                "მთავარი ქუჩა", "სადგურის მოედანი", "ველოცირაპტორების ჯოგი"};
+        String sorted[] = {"ველოცირაპტორების ჯოგი", "მთავარი ქუჩა", "მიწისქვეშა გადასასვლელი",
+                "მონაცემთა ბაზა", "რუსთაველის გამზირი", "სადგურის მოედანი"};
+
+        realm.beginTransaction();
+        realm.clear(StringOnly.class);
+        for (String word : words) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars(word);
+        }
+        realm.commitTransaction();
+
+        RealmResults<StringOnly> stringOnlies1 = realm.where(StringOnly.class).contains("chars", "მთავარი").findAll();
+        assertEquals(1, stringOnlies1.size());
+
+        RealmResults<StringOnly> stringOnlies2 = realm.allObjects(StringOnly.class);
+        stringOnlies2.sort("chars");
+        for (int i = 0; i < stringOnlies2.size(); i++) {
+            assertEquals(sorted[i], stringOnlies2.get(i).getChars());
+        }
+    }
+
+    // Querying a non-nullable field with null is an error
+    @Test
+    public void equalTo_notNullableFields() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NOT_NULL,
+                    (String) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 2 Bytes skipped, doesn't support equalTo query
+        // 3 Boolean
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NOT_NULL, (Boolean) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 4 Byte
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NOT_NULL, (Byte) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 5 Short
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NOT_NULL, (Short) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 6 Integer
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NOT_NULL, (Integer) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 7 Long
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NOT_NULL, (Long) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 8 Float
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NOT_NULL, (Float) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 9 Double
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NOT_NULL, (Double) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 10 Date
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NOT_NULL, (Date) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Querying a non-nullable field with null is an error
+    @Test
+    public void isNull_notNullableFields() {
+        // 1 String
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_STRING_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 2 Bytes
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTES_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 3 Boolean
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_BOOLEAN_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 4 Byte
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTE_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 5 Short
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_SHORT_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 6 Integer
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_INTEGER_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 7 Long
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_LONG_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 8 Float
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_FLOAT_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 9 Double
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_DOUBLE_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 10 Date
+        try {
+            realm.where(NullTypes.class).isNull(NullTypes.FIELD_DATE_NOT_NULL).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Querying nullable fields, querying with equalTo null
+    @Test
+    public void equalTo_nullableFields() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Horse").findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, (String) null).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Fish").findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Goat").findAll().size());
+        // 2 Bytes skipped, doesn't support equalTo query
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, true).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, false).findAll().size());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 42).findAll().size());
+        // 5 Short for other long based columns, only test null
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (Short) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 42).findAll().size());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 42).findAll().size());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 1).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (Long) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 42).findAll().size());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 1F).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 42F).findAll().size());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 1D).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 42D).findAll().size());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(0)).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, (Date) null).findAll().size());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(424242)).findAll().size());
+        // 11 Object skipped, doesn't support equalTo query
+    }
+
+    // Querying nullable field for null
+    @Test
+    public void isNull_nullableFields() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_STRING_NULL).findAll().size());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTES_NULL).findAll().size());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BOOLEAN_NULL).findAll().size());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTE_NULL).findAll().size());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_SHORT_NULL).findAll().size());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_INTEGER_NULL).findAll().size());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_LONG_NULL).findAll().size());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_FLOAT_NULL).findAll().size());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DOUBLE_NULL).findAll().size());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DATE_NULL).findAll().size());
+        // 11 Object
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL).findAll().size());
+    }
+
+    // Querying nullable field for not null
+    @Test
+    public void notEqualTo_nullableFields() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        // 1 String
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, "Horse").findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, (String) null).findAll().size());
+        // 2 Bytes skipped, doesn't support notEqualTo query
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, false).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).findAll().size());
+        // 4 Byte
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).findAll().size());
+        // 5 Short
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (short) 1).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (Byte) null).findAll().size());
+        // 6 Integer
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, 1).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).findAll().size());
+        // 7 Long
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, 1).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, (Integer) null).findAll().size());
+        // 8 Float
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, 1F).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).findAll().size());
+        // 9 Double
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, 1D).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).findAll().size());
+        // 10 Date
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, new Date(0)).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, (Date) null).findAll().size());
+        // 11 Object skipped, doesn't support notEqualTo query
+    }
+
+    // Querying nullable field for not null
+    @Test
+    public void isNotNull_nullableFields() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_STRING_NULL).findAll().size());
+        // 2 Bytes
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTES_NULL).findAll().size());
+        // 3 Boolean
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BOOLEAN_NULL).findAll().size());
+        // 4 Byte
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTE_NULL).findAll().size());
+        // 5 Short
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_SHORT_NULL).findAll().size());
+        // 6 Integer
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_INTEGER_NULL).findAll().size());
+        // 7 Long
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LONG_NULL).findAll().size());
+        // 8 Float
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_FLOAT_NULL).findAll().size());
+        // 9 Double
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DOUBLE_NULL).findAll().size());
+        // 10 Date
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DATE_NULL).findAll().size());
+        // 11 Object
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL).findAll().size());
+    }
+
+    // Querying nullable field with beginsWith - all strings begin with null
+    @Test
+    public void beginWith_nullForNullableStrings() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        assertEquals("Fish", realm.where(NullTypes.class).beginsWith(NullTypes.FIELD_STRING_NULL,
+                null).findFirst().getFieldStringNotNull());
+    }
+
+    // Querying nullable field with endsWith - all strings contain with null
+    @Test
+    public void contains_nullForNullableStrings() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        assertEquals("Fish", realm.where(NullTypes.class).contains(NullTypes.FIELD_STRING_NULL,
+                null).findFirst().getFieldStringNotNull());
+    }
+
+    // Querying nullable field with endsWith - all strings end with null
+    @Test
+    public void endsWith_nullForNullableStrings() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        assertEquals("Fish", realm.where(NullTypes.class).endsWith(NullTypes.FIELD_STRING_NULL,
+                null).findFirst().getFieldStringNotNull());
+    }
+
+    // Querying with between and table has null values in row.
+    @Test
+    public void between_nullValuesInRow() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).between(NullTypes.FIELD_INTEGER_NULL, 2, 4).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).between(NullTypes.FIELD_LONG_NULL, 2L, 4L).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).between(NullTypes.FIELD_FLOAT_NULL, 2F, 4F).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).between(NullTypes.FIELD_DOUBLE_NULL, 2D, 4D).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).between(NullTypes.FIELD_DATE_NULL, new Date(10000),
+                new Date(20000)).count());
+    }
+
+    // Querying with greaterThan and table has null values in row.
+    @Test
+    public void greaterThan_nullValuesInRow() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).greaterThan(NullTypes.FIELD_INTEGER_NULL, 2).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).greaterThan(NullTypes.FIELD_LONG_NULL, 2L).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).greaterThan(NullTypes.FIELD_FLOAT_NULL, 2F).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).greaterThan(NullTypes.FIELD_DOUBLE_NULL, 2D).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).greaterThan(NullTypes.FIELD_DATE_NULL,
+                new Date(5000)).count());
+    }
+
+    // Querying with greaterThanOrEqualTo and table has null values in row.
+    @Test
+    public void greaterThanOrEqualTo_nullValuesInRow() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_INTEGER_NULL, 3).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_LONG_NULL, 3L).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_FLOAT_NULL, 3F).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_DOUBLE_NULL, 3D).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).greaterThanOrEqualTo(NullTypes.FIELD_DATE_NULL,
+                new Date(10000)).count());
+    }
+
+    // Querying with lessThan and table has null values in row.
+    @Test
+    public void lessThan_nullValuesInRow() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).lessThan(NullTypes.FIELD_INTEGER_NULL, 2).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).lessThan(NullTypes.FIELD_LONG_NULL, 2L).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).lessThan(NullTypes.FIELD_FLOAT_NULL, 2F).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).lessThan(NullTypes.FIELD_DOUBLE_NULL, 2D).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).lessThan(NullTypes.FIELD_DATE_NULL,
+                new Date(5000)).count());
+
+    }
+
+    // Querying with lessThanOrEqualTo and table has null values in row.
+    @Test
+    public void lessThanOrEqual_nullValuesInRow() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_INTEGER_NULL, 1).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_LONG_NULL, 1L).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_FLOAT_NULL, 1F).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_DOUBLE_NULL, 1D).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).lessThanOrEqualTo(NullTypes.FIELD_DATE_NULL,
+                new Date(9999)).count());
+    }
+
+    // If the RealmQuery is built on a TableView, it should not crash when used after GC.
+    // See issue #1161 for more details.
+    @Test
+    public void buildQueryFromResultsGC() {
+        // According to the testing, setting this to 10 can almost certainly trigger the GC.
+        // Use 30 here can ensure GC happen. (Tested with 4.3 1G Ram and 5.0 3G Ram)
+        final int count = 30;
+        RealmResults<CatOwner> results = realm.where(CatOwner.class).findAll();
+
+        for (int i = 1; i <= count; i++) {
+            @SuppressWarnings({"unused"})
+            byte garbage[] = TestHelper.allocGarbage(0);
+            results = results.where().findAll();
+            System.gc(); // if a native resource has a reference count = 0, doing GC here might lead to a crash
+        }
+    }
+
+    // Test min on empty columns
+    @Test
+    public void min_emptyColumns() {
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertNull(query.min(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(query.min(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(query.min(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(query.minimumDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test min on columns with all null rows
+    @Test
+    public void min_allNullColumns() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertNull(query.min(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(query.min(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(query.min(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(query.minimumDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test min on columns with all non-null rows
+    @Test
+    public void min_allNonNullRows() {
+        TestHelper.populateAllNonNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(-1, query.min(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(-2f, query.min(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(-3d, query.min(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+        assertEquals(-2000, query.minimumDate(NullTypes.FIELD_DATE_NULL).getTime());
+    }
+
+    // Test min on columns with partial null rows
+    @Test
+    public void min_partialNullRows() {
+        TestHelper.populatePartialNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(3, query.min(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(4f, query.min(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(5d, query.min(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test max on empty columns
+    @Test
+    public void max_emptyColumns() {
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertNull(query.max(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(query.max(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(query.max(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(query.maximumDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test max on columns with all null rows
+    @Test
+    public void max_allNullColumns() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertNull(query.max(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(query.max(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(query.max(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(query.maximumDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test max on columns with all non-null rows
+    @Test
+    public void max_allNonNullRows() {
+        TestHelper.populateAllNonNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+    }
+
+    // Test max on columns with partial null rows
+    @Test
+    public void max_partialNullRows() {
+        TestHelper.populatePartialNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+    }
+
+    // Test average on empty columns
+    @Test
+    public void average_emptyColumns() {
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertEquals(0d, query.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(0d, query.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(0d, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    // Test average on columns with all null rows
+    @Test
+    public void average_allNullColumns() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertEquals(0d, query.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(0d, query.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(0d, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    // Test average on columns with all non-null rows
+    @Test
+    public void average_allNonNullRows() {
+        TestHelper.populateAllNonNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(2.0, query.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(7.0 / 3, query.average(NullTypes.FIELD_FLOAT_NULL), 0.001d);
+        assertEquals(8.0 / 3, query.average(NullTypes.FIELD_DOUBLE_NULL), 0.001d);
+    }
+
+    // Test average on columns with partial null rows
+    @Test
+    public void average_partialNullRows() {
+        TestHelper.populatePartialNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(3.5, query.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(4.5, query.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(5.5, query.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    // Test sum on empty columns
+    @Test
+    public void sum_emptyColumns() {
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertEquals(0, query.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, query.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test sum on columns with all null rows
+    @Test
+    public void sum_allNullColumns() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+        assertEquals(0, query.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, query.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test sum on columns with all non-null rows
+    @Test
+    public void sum_allNonNullRows() {
+        TestHelper.populateAllNonNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(6, query.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(7f, query.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(8d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test sum on columns with partial null rows
+    @Test
+    public void sum_partialNullRows() {
+        TestHelper.populatePartialNullRowsForNumericTesting(realm);
+        RealmQuery<NullTypes> query = realm.where(NullTypes.class);
+
+        assertEquals(7, query.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(9f, query.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(11d, query.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test isNull on link's nullable field.
+    @Test
+    public void isNull_linkField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // For the link with null value, query isNull on its fields should return true.
+        // 1 String
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(2, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DATE_NULL).count());
+        // 11 Object
+        // FIXME: Currently, Realm Core does not support isNull() query for nested link field.
+        //assertEquals(1, realm.where(NullTypes.class).isNull(
+        //        NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_OBJECT_NULL).count());
+        try {
+            realm.where(NullTypes.class).isNull(
+                    NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_OBJECT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Test isNull on link's not-nullable field. should throw
+    @Test
+    public void isNull_linkFieldNotNullable() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_STRING_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 2 Bytes
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTES_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 3 Boolean
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BOOLEAN_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 4 Byte
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 5 Short
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_SHORT_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 6 Integer
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_INTEGER_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 7 Long
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LONG_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 8 Float
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_FLOAT_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 9 Double
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DOUBLE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 10 Date
+        try {
+            realm.where(NullTypes.class)
+                    .isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DATE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 11 Object skipped, doesn't support equalTo query
+    }
+
+    // Test isNotNull on link's nullable field.
+    @Test
+    public void isNotNull_linkField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DATE_NULL).count());
+        // 11 Object
+        //assertEquals(1, realm.where(NullTypes.class).isNotNull(
+        //        NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_OBJECT_NULL).count());
+        // FIXME: Currently, Realm Core does not support isNotNull() query for nested link field.
+        try {
+            realm.where(NullTypes.class).isNotNull(
+                    NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_OBJECT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Test isNotNull on link's not-nullable field. should throw
+    @Test
+    public void isNotNull_linkFieldNotNullable() {
+        TestHelper.populateTestRealmForNullTests(realm);
+
+        // 1 String
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_STRING_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 2 Bytes
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTES_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 3 Boolean
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BOOLEAN_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 4 Byte
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_BYTE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 5 Short
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_SHORT_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 6 Integer
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_INTEGER_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 7 Long
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LONG_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 8 Float
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_FLOAT_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 9 Double
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DOUBLE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 10 Date
+        try {
+            realm.where(NullTypes.class)
+                    .isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_DATE_NOT_NULL);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        // 11 Object skipped, RealmObject is always nullable.
+    }
+
+    // Calling isNull on fields with the RealmList type will trigger an exception
+    @Test
+    public void isNull_listFieldThrows() {
+        try {
+            realm.where(Owner.class).isNull("dogs");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+        }
+
+        try {
+            realm.where(Cat.class).isNull("owner.dogs");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+        }
+    }
+
+    // Calling isNotNull on fields with the RealmList type will trigger an exception
+    @Test
+    public void isNotNull_listFieldThrows() {
+        try {
+            realm.where(Owner.class).isNotNull("dogs");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+        }
+
+        try {
+            realm.where(Cat.class).isNotNull("owner.dogs");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: RealmList is not nullable.", expected.getMessage());
+        }
+    }
+
+    // @Test Disabled because of time consuming.
+    public void largeRealmMultipleThreads() throws InterruptedException {
+        final int nObjects = 500000;
+        final int nThreads = 3;
+        final CountDownLatch latch = new CountDownLatch(nThreads);
+
+        realm.beginTransaction();
+        realm.clear(StringOnly.class);
+        for (int i = 0; i < nObjects; i++) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars(String.format("string %d", i));
+        }
+        realm.commitTransaction();
+
+
+        for (int i = 0; i < nThreads; i++) {
+            Thread thread = new Thread(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            RealmConfiguration realmConfig = configFactory.createConfiguration();
+                            Realm realm = Realm.getInstance(realmConfig);
+                            RealmResults<StringOnly> realmResults = realm.allObjects(StringOnly.class);
+                            int n = 0;
+                            for (StringOnly ignored : realmResults) {
+                                n = n + 1;
+                            }
+                            assertEquals(nObjects, n);
+                            realm.close();
+                            latch.countDown();
+                        }
+                    }
+            );
+            thread.start();
+        }
+
+        latch.await();
+    }
+
+    @Test
+    public void isValid_tableQuery() {
+        final RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+
+        assertTrue(query.isValid());
+        populateTestRealm(realm, 1);
+        // still valid if result changed
+        assertTrue(query.isValid());
+
+        realm.close();
+        assertFalse(query.isValid());
+    }
+
+    @Test
+    public void isValid_tableViewQuery() {
+        populateTestRealm();
+        final RealmQuery<AllTypes> query = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_FLOAT, 5f)
+                .findAll().where();
+        assertTrue(query.isValid());
+
+        populateTestRealm(realm, 1);
+        // still valid if table view changed
+        assertTrue(query.isValid());
+
+        realm.close();
+        assertFalse(query.isValid());
+    }
+
+    // test for https://github.com/realm/realm-java/issues/1905
+    @Test
+    public void resultOfTableViewQuery() {
+        populateTestRealm();
+
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 3L).findAll();
+        final RealmQuery<AllTypes> tableViewQuery = results.where();
+        assertEquals("test data 3", tableViewQuery.findAll().first().getColumnString());
+        assertEquals("test data 3", tableViewQuery.findFirst().getColumnString());
+    }
+
+    @Test
+    public void isValid_linkViewQuery() {
+        populateTestRealm(realm, 1);
+        final RealmList<Dog> list = realm.where(AllTypes.class).findFirst().getColumnRealmList();
+        final RealmQuery<Dog> query = list.where();
+        final long listLength = query.count();
+        assertTrue(query.isValid());
+
+        realm.beginTransaction();
+        final Dog dog = realm.createObject(Dog.class);
+        dog.setName("Dog");
+        list.add(dog);
+        realm.commitTransaction();
+
+        // still valid if base view changed
+        assertEquals(listLength + 1, query.count());
+        assertTrue(query.isValid());
+
+        realm.close();
+        assertFalse(query.isValid());
+    }
+
+    @Test
+    public void isValid_removedParent() {
+        populateTestRealm(realm, 1);
+        final AllTypes obj = realm.where(AllTypes.class).findFirst();
+        final RealmQuery<Dog> query = obj.getColumnRealmList().where();
+        assertTrue(query.isValid());
+
+        realm.beginTransaction();
+        obj.removeFromRealm();
+        realm.commitTransaction();
+
+        // invalid if parent has been removed
+        assertFalse(query.isValid());
+    }
+
+
+    private static final List<RealmFieldType> SUPPORTED_IS_EMPTY_TYPES = Arrays.asList(
+            RealmFieldType.STRING,
+            RealmFieldType.BINARY,
+            RealmFieldType.LIST);
+
+    private static final List<RealmFieldType> NOT_SUPPORTED_IS_EMPTY_TYPES;
+    static {
+        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
+        list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
+        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
+        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        NOT_SUPPORTED_IS_EMPTY_TYPES = list;
+    }
+
+    private void createIsEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldLong(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        realm.copyToRealm(emptyValues);
+
+        AllJavaTypes nonEmpty = new AllJavaTypes();
+        nonEmpty.setFieldLong(2);
+        nonEmpty.setFieldString("Foo");
+        nonEmpty.setFieldBinary(new byte[]{1, 2, 3});
+        nonEmpty.setFieldObject(nonEmpty);
+        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
+        realm.copyToRealmOrUpdate(nonEmpty);
+
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void isEmpty() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_illegalFieldTypeThrows() {
+        for (RealmFieldType type : NOT_SUPPORTED_IS_EMPTY_TYPES) {
+            try {
+                switch (type) {
+                    case INTEGER:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LONG).findAll();
+                        break;
+                    case FLOAT:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_FLOAT).findAll();
+                        break;
+                    case DOUBLE:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_DOUBLE).findAll();
+                        break;
+                    case BOOLEAN:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BOOLEAN).findAll();
+                        break;
+                    case OBJECT:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT).findAll();
+                        break;
+                    case DATE:
+                        realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_DATE).findAll();
+                        break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+                fail(type + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_invalidFieldNameThrows() {
+        String[] fieldNames = new String[] {null, "", "foo", AllJavaTypes.FIELD_OBJECT + ".foo"};
+
+        for (String fieldName : fieldNames) {
+            try {
+                realm.where(AllJavaTypes.class).isEmpty(fieldName).findAll();
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // not-empty test harnesses
+    private static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES = Arrays.asList(
+            RealmFieldType.STRING,
+            RealmFieldType.BINARY,
+            RealmFieldType.LIST);
+
+    private static final List<RealmFieldType> NOT_SUPPORTED_IS_NOT_EMPTY_TYPES;
+    static {
+        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
+        list.removeAll(SUPPORTED_IS_NOT_EMPTY_TYPES);
+        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
+        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = list;
+    }
+
+    private void createIsNotEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldLong(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        realm.copyToRealm(emptyValues);
+
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldLong(2);
+        notEmpty.setFieldString("Foo");
+        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
+        realm.copyToRealmOrUpdate(notEmpty);
+
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void isNotEmpty() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLink() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_illegalFieldTypeThrows() {
+        for (RealmFieldType type : NOT_SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            try {
+                switch (type) {
+                    case INTEGER:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LONG).findAll();
+                        break;
+                    case FLOAT:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_FLOAT).findAll();
+                        break;
+                    case DOUBLE:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_DOUBLE).findAll();
+                        break;
+                    case BOOLEAN:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_BOOLEAN).findAll();
+                        break;
+                    case OBJECT:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT).findAll();
+                        break;
+                    case DATE:
+                        realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_DATE).findAll();
+                        break;
+                    default:
+                        fail("Unknown type: " + type);
+                }
+                fail(type + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_invalidFieldNameThrows() {
+        String[] fieldNames = new String[] {null, "", "foo", AllJavaTypes.FIELD_OBJECT + ".foo"};
+
+        for (String fieldName : fieldNames) {
+            try {
+                realm.where(AllJavaTypes.class).isNotEmpty(fieldName).findAll();
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // Test that deep queries work on a lot of data
+    @Test
+    public void deepLinkListQuery() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+
+                // Crash with i == 1000, 500, 100, 89, 85, 84
+                // Doesn't crash for i == 10, 50, 75, 82, 83
+                for (int i = 0; i < 84; i++) {
+                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+                    obj.setFieldLong(i + 1);
+                    obj.setFieldBoolean(i % 2 == 0);
+                    obj.setFieldObject(obj);
+
+                    RealmResults<AllJavaTypes> items = realm.where(AllJavaTypes.class).findAll();
+                    RealmList<AllJavaTypes> fieldList = obj.getFieldList();
+                    for (int j = 0; j < items.size(); j++) {
+                        fieldList.add(items.get(j));
+                    }
+                }
+            }
+        });
+
+        for (int i = 0; i < 4; i++) {
+            realm.where(AllJavaTypes.class).equalTo(
+                    AllJavaTypes.FIELD_LIST + "." + AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN, true)
+                    .findAll();
+        }
+    }
+
+    @Test
+    public void findAllSorted_onSubObjectFieldThrows() {
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Sorting using child object fields is not supported: ");
+        realm.where(AllTypes.class).findAllSorted(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN);
+    }
+
+    @Test
+    public void findAllSortedAsync_onSubObjectFieldThrows() {
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Sorting using child object fields is not supported: ");
+        realm.where(AllTypes.class).findAllSortedAsync(
+                AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN);
+    }
+
+    @Test
+    public void findAllSorted_listOnSubObjectFieldThrows() {
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Sorting using child object fields is not supported: ");
+        String[] fieldNames = new String[1];
+        fieldNames[0] = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN;
+        Sort[] sorts = new Sort[1];
+        sorts[0] = Sort.ASCENDING;
+        realm.where(AllTypes.class).findAllSorted(fieldNames, sorts);
+    }
+
+    @Test
+    public void findAllSortedAsync_listOnSubObjectFieldThrows() {
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Sorting using child object fields is not supported: ");
+        String[] fieldNames = new String[1];
+        fieldNames[0] = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN;
+        Sort[] sorts = new Sort[1];
+        sorts[0] = Sort.ASCENDING;
+        realm.where(AllTypes.class).findAllSortedAsync(fieldNames, sorts);
+    }
+
+    // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string
+    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
+            for (int j = 0; j < numberOfBlocks; j++) {
+                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
+                obj.setIndexBoolean(j % 2 == 0);
+                obj.setIndexLong(j);
+                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexString(withNull ? null : "Test " + j);
+                obj.setNotIndexBoolean(j % 2 == 0);
+                obj.setNotIndexLong(j);
+                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexString(withNull ? null : "Test " + j);
+                obj.setFieldObject(obj);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateForDistinctInvalidTypesLinked(Realm realm) {
+        realm.beginTransaction();
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
+        realm.copyToRealm(notEmpty);
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void distinct() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            assertEquals(field, 1, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).distinct(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_doesNotExist() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinct_invalidTypes() {
+        populateTestRealm();
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.where(AllTypes.class).distinct(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported Index" + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported notIndex" + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.where(AllJavaTypes.class).distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // distinctAsync
+    private Realm openRealmInstance(String name) {
+        RealmConfiguration config = configFactory.createConfiguration(name);
+        Realm.deleteRealm(config);
+        return Realm.getInstance(config);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync() throws Throwable {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+        final Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        distinctBool.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(2, distinctBool.size());
+                endTest.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                endTest.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                endTest.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctString.size());
+                endTest.run();
+            }
+        });
+    }
+
+    @Test
+    public void distinctAsync_withNullValues () throws Throwable {
+        final CountDownLatch signalCallbackFinished = new CountDownLatch(2);
+        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+        final Throwable[] threadAssertionError = new Throwable[1];
+        final Looper[] backgroundLooper = new Looper[1];
+        final ExecutorService executorService = Executors.newSingleThreadExecutor();
+        executorService.submit(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                backgroundLooper[0] = Looper.myLooper();
+
+                Realm asyncRealm = null;
+                try {
+                    Realm.asyncQueryExecutor.pause();
+                    asyncRealm = openRealmInstance("testDistinctAsyncQueryWithNull");
+                    final long numberOfBlocks = 25;
+                    final long numberOfObjects = 10; // must be greater than 1
+                    populateForDistinct(asyncRealm, numberOfBlocks, numberOfObjects, true);
+
+                    final RealmResults<AnnotationIndexTypes> distinctDate = asyncRealm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+                    final RealmResults<AnnotationIndexTypes> distinctString = asyncRealm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+                    assertFalse(distinctDate.isLoaded());
+                    assertTrue(distinctDate.isValid());
+                    assertTrue(distinctDate.isEmpty());
+
+                    assertFalse(distinctString.isLoaded());
+                    assertTrue(distinctString.isValid());
+                    assertTrue(distinctString.isEmpty());
+
+                    Realm.asyncQueryExecutor.resume();
+
+                    distinctDate.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            assertEquals(1, distinctDate.size());
+                            signalCallbackFinished.countDown();
+                        }
+                    });
+
+                    distinctString.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            assertEquals(1, distinctString.size());
+                            signalCallbackFinished.countDown();
+                        }
+                    });
+
+                    Looper.loop();
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    threadAssertionError[0] = e;
+
+                } finally {
+                    if (signalCallbackFinished.getCount() > 0) {
+                        signalCallbackFinished.countDown();
+                    }
+                    if (asyncRealm != null) {
+                        asyncRealm.close();
+                    }
+                    signalClosedRealm.countDown();
+                }
+            }
+        });
+
+        TestHelper.exitOrThrow(executorService, signalCallbackFinished, signalClosedRealm, backgroundLooper, threadAssertionError);
+    }
+
+    @Test
+    public void distinctAsync_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).distinctAsync(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_doesNotExist() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctAsync_invalidTypes() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.where(AllTypes.class).distinctAsync(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported " + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_notIndexedLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.where(AllJavaTypes.class).distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        assertEquals(numberOfBlocks, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_switchedFieldsOrder() {
+        final long numberOfBlocks = 25;
+        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
+
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        RealmResults<AnnotationIndexTypes> distinctStringLong = query.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
+        RealmResults<AnnotationIndexTypes> distinctLongString = query.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(4, distinctStringLong.size());
+        assertEquals(4, distinctLongString.size());
+        assertEquals(distinctStringLong.size(), distinctLongString.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_emptyField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        // an empty string field in the middle
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // an empty string field at the end
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field in the middle
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field at the end
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // (String)null makes varargs a null array.
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two (String)null for first and varargs fields
+        try {
+            query.distinct((String)null, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            query.distinct("", (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            query.distinct((String)null, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two empty fields tests
+        try {
+            query.distinct("", "");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(1, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_doesNotExistField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        try {
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesFields() {
+        populateTestRealm();
+
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        try {
+            query.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        try {
+            query.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
+        try {
+            query.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
+        try {
+            query.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
similarity index 95%
rename from realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
index adc3da79ac..1643aa73c8 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsIteratorTests.java
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package io.realm;
 
 import android.test.AndroidTestCase;
@@ -37,8 +38,9 @@
 
     @Override
     protected void setUp() throws InterruptedException {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
         testRealm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
@@ -250,7 +252,8 @@ public void DISABLEDtestIteratorFailOnDoubleRemove() {
     public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws InterruptedException, ExecutionException {
 
         // Prefill
-        Realm realm = Realm.getInstance(getContext(), "test");
+        final RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext(), "test");
+        Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         realm.clear(AllTypes.class);
         AllTypes o1 = realm.createObject(AllTypes.class);
@@ -269,14 +272,14 @@ public void DISABLEDtestRemovingObjectsFromOtherThreadWhileIterating() throws In
         Callable<Boolean> backgroundWorker = new Callable<Boolean>() {
             @Override
             public Boolean call() throws Exception {
-                Realm backgroundRealm = Realm.getInstance(getContext(), "test");
+                Realm backgroundRealm = Realm.getInstance(realmConfig);
                 backgroundRealm.beginTransaction();
                 RealmResults<AllTypes> backgroundResult = backgroundRealm.allObjects(AllTypes.class);
                 if (backgroundResult.size() != 2) {
                     backgroundRealm.close();
                     return false;
                 }
-                backgroundResult.sort("columnLong", RealmResults.SORT_ORDER_ASCENDING);
+                backgroundResult.sort("columnLong", Sort.ASCENDING);
                 backgroundResult.remove(0);
                 AllTypes o3 = backgroundRealm.createObject(AllTypes.class);
                 o3.setColumnLong(3);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
new file mode 100644
index 0000000000..8cc93758be
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -0,0 +1,1921 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
+import io.realm.internal.Table;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmResultsTests {
+
+    private final static int TEST_DATA_SIZE = 2516;
+    private final static int TEST_DATA_FIRST_HALF = 2 * (TEST_DATA_SIZE / 4) - 1;
+    private final static int TEST_DATA_LAST_HALF = 2 * (TEST_DATA_SIZE / 4) + 1;
+    private final static long YEAR_MILLIS = TimeUnit.DAYS.toMillis(365);
+    private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+        populateTestRealm();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void populateTestRealm(int objects) {
+        realm.beginTransaction();
+        realm.allObjects(AllTypes.class).clear();
+        realm.allObjects(NonLatinFieldNames.class).clear();
+
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 2) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - objects / 2)));
+            allTypes.setColumnDouble(3.1415 + i);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            Dog d = realm.createObject(Dog.class);
+            d.setName("Foo " + i);
+            allTypes.setColumnRealmObject(d);
+            allTypes.getColumnRealmList().add(d);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateTestRealm() {
+        populateTestRealm(TEST_DATA_SIZE);
+    }
+
+    private void populatePartialNullRowsForNumericTesting() {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(1);
+        nullTypes1.setFieldFloatNull(2F);
+        nullTypes1.setFieldDoubleNull(3D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+        nullTypes3.setFieldIntegerNull(0);
+        nullTypes3.setFieldFloatNull(0F);
+        nullTypes3.setFieldDoubleNull(0D);
+        nullTypes3.setFieldBooleanNull(false);
+        nullTypes3.setFieldStringNull("0");
+        nullTypes3.setFieldDateNull(new Date(0));
+
+        realm.beginTransaction();
+        realm.copyToRealm(nullTypes1);
+        realm.copyToRealm(nullTypes2);
+        realm.copyToRealm(nullTypes3);
+        realm.commitTransaction();
+    }
+
+    private enum Method {
+        METHOD_MIN,
+        METHOD_MAX,
+        METHOD_SUM,
+        METHOD_AVG,
+        METHOD_SORT,
+        METHOD_WHERE,
+        METHOD_REMOVE,
+        METHOD_REMOVE_LAST,
+        METHOD_CLEAR
+    }
+
+    @Test
+    public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        for (Method method : Method.values()) {
+            assertTrue(runMethodOnWrongThread(method));
+        }
+    }
+
+    private boolean runMethodOnWrongThread(final Method method) throws ExecutionException, InterruptedException {
+        final RealmResults<AllTypes> allTypeses = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case METHOD_MIN:
+                            allTypeses.min(AllTypes.FIELD_FLOAT);
+                            break;
+                        case METHOD_MAX:
+                            allTypeses.max(AllTypes.FIELD_FLOAT);
+                            break;
+                        case METHOD_SUM:
+                            allTypeses.sum(AllTypes.FIELD_FLOAT);
+                            break;
+                        case METHOD_AVG:
+                            allTypeses.average(AllTypes.FIELD_FLOAT);
+                            break;
+                        case METHOD_SORT:
+                            allTypeses.sort(AllTypes.FIELD_FLOAT);
+                            break;
+                        case METHOD_WHERE:
+                            allTypeses.where();
+                            break;
+                        case METHOD_REMOVE:
+                            allTypeses.remove(0);
+                            break;
+                        case METHOD_REMOVE_LAST:
+                            allTypeses.removeLast();
+                            break;
+                        case METHOD_CLEAR:
+                            allTypeses.clear();
+                            break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                }
+            }
+        });
+        Boolean result = future.get();
+        realm.cancelTransaction();
+        return result;
+    }
+
+    @Test
+    public void clear() {
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE, results.size());
+
+        realm.beginTransaction();
+        results.clear();
+        realm.commitTransaction();
+
+        assertEquals(0, results.size());
+    }
+
+    @Test
+    public void removeLast_emptyList() {
+        RealmResults<AllTypes> resultsList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "Not there").findAll();
+        assertEquals(0, resultsList.size());
+        realm.beginTransaction();
+        resultsList.removeLast();
+        assertEquals(0, resultsList.size());
+    }
+
+    @Test
+    public void get() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        AllTypes allTypes = resultList.get(0);
+        assertTrue(allTypes.getColumnString().startsWith("test data"));
+    }
+
+    @Test
+    public void first() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        AllTypes allTypes = resultList.first();
+        assertTrue(allTypes.getColumnString().startsWith("test data 0"));
+    }
+
+    // first() and last() will throw an exception when no element exist
+    @Test
+    public void firstAndLast_throwsIfEmpty() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> allTypes = realm.allObjects(AllTypes.class);
+        assertEquals(0, allTypes.size());
+        try {
+            allTypes.first();
+            fail();
+        } catch (ArrayIndexOutOfBoundsException ignored) {
+        }
+
+        try {
+            allTypes.last();
+            fail();
+        } catch (ArrayIndexOutOfBoundsException ignored) {
+        }
+    }
+
+    @Test
+    public void last() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        AllTypes allTypes = resultList.last();
+        assertEquals((TEST_DATA_SIZE - 1), allTypes.getColumnLong());
+    }
+
+    @Test
+    public void min() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        Number minimum = resultList.min(AllTypes.FIELD_LONG);
+        assertEquals(0, minimum.intValue());
+    }
+
+    // Test min on empty columns
+    @Test
+    public void min_emptyNonNullFields() {
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertNull(results.min(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(results.min(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(results.min(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(results.minDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test min on nullable rows with all null values
+    @Test
+    public void min_emptyNullFields() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test min on nullable rows with partial null values
+    @Test
+    public void min_partialNullRows() {
+        populatePartialNullRowsForNumericTesting();
+
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertEquals(0, results.min(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, results.min(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, results.min(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void max() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        Number maximum = resultList.max(AllTypes.FIELD_LONG);
+        assertEquals(TEST_DATA_SIZE - 1, maximum.intValue());
+    }
+
+    // Test max on empty columns
+    @Test
+    public void max_emptyNonNullFields() {
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NOT_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NOT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NOT_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NOT_NULL));
+    }
+
+    // Test max on nullable rows with all null values
+    @Test
+    public void max_emptyNullFields() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertNull(results.max(NullTypes.FIELD_INTEGER_NULL));
+        assertNull(results.max(NullTypes.FIELD_FLOAT_NULL));
+        assertNull(results.max(NullTypes.FIELD_DOUBLE_NULL));
+        assertNull(results.maxDate(NullTypes.FIELD_DATE_NULL));
+    }
+
+    // Test max on nullable rows with partial null values
+    @Test
+    public void max_partialNullRows() {
+        populatePartialNullRowsForNumericTesting();
+
+        RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
+        assertEquals(1, results.max(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(2f, results.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(3d, results.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void sum() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+
+        Number sum = resultList.sum(AllTypes.FIELD_LONG);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
+    }
+
+    // Test sum on nullable rows with all null values
+    @Test
+    public void sum_nullRows() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+        assertEquals(0, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(0f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(0d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    // Test sum on nullable rows with partial null values
+    @Test
+    public void sum_partialNullRows() {
+        populatePartialNullRowsForNumericTesting();
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+
+        assertEquals(1, resultList.sum(NullTypes.FIELD_INTEGER_NULL).intValue());
+        assertEquals(2f, resultList.sum(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
+        assertEquals(3d, resultList.sum(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
+    }
+
+    @Test
+    public void sum_nonLatinColumnNames() {
+        RealmResults<NonLatinFieldNames> resultList = realm.where(NonLatinFieldNames.class).findAll();
+
+        Number sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_KOREAN_CHAR);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
+
+        sum = resultList.sum(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR);
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
+    }
+
+    @Test
+    public void avg() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        double N = (double) TEST_DATA_SIZE;
+
+        // Sum of numbers 1 to M: M*(M+1)/2
+        // See setUp() for values of fields
+        // N = TEST_DATA_SIZE
+
+        // Type: double; a = 3.1415
+        // a, a+1, ..., a+i, ..., a+N-1
+        // sum = 3.1415*N + N*(N-1)/2
+        // average = sum/N = 3.1415+(N-1)/2
+        double average = 3.1415 + (N - 1.0) * 0.5;
+        assertEquals(average, resultList.average(AllTypes.FIELD_DOUBLE), 0.0001);
+
+        // Type: long
+        // 0, 1, ..., N-1
+        // sum = N*(N-1)/2
+        // average = sum/N = (N-1)/2
+        assertEquals(0.5 * (N - 1), resultList.average(AllTypes.FIELD_LONG), 0.0001);
+
+        // Type: float; b = 1.234567
+        // b, b+1, ..., b+i, ..., b+N-1
+        // sum = b*N + N*(N-1)/2
+        // average = sum/N = b + (N-1)/2
+        assertEquals(1.234567 + 0.5 * (N - 1.0), resultList.average(AllTypes.FIELD_FLOAT), 0.0001);
+    }
+
+    // Test average on empty columns
+    @Test
+    public void avg_emptyNonNullFields() {
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+
+        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NOT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NOT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NOT_NULL), 0d);
+    }
+
+    // Test average on nullable rows with all null values
+    @Test
+    public void avg_emptyNullFields() {
+        TestHelper.populateAllNullRowsForNumericTesting(realm);
+
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+        assertEquals(0d, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(0d, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    // Test average on nullable rows with partial null values
+    @Test
+    public void avg_partialNullRows() {
+        populatePartialNullRowsForNumericTesting();
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+
+        assertEquals(0.5, resultList.average(NullTypes.FIELD_INTEGER_NULL), 0d);
+        assertEquals(1.0, resultList.average(NullTypes.FIELD_FLOAT_NULL), 0d);
+        assertEquals(1.5, resultList.average(NullTypes.FIELD_DOUBLE_NULL), 0d);
+    }
+
+    @Test
+    public void remove() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        resultList.remove(0);
+        realm.commitTransaction();
+
+        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
+
+        AllTypes allTypes = resultList.get(0);
+        assertEquals(1, allTypes.getColumnLong());
+    }
+
+    @Test
+    public void removeLast() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        realm.beginTransaction();
+        resultList.removeLast();
+        realm.commitTransaction();
+
+        assertEquals("ResultList.removeLast did not remove record", TEST_DATA_SIZE - 1, resultList.size());
+
+        AllTypes allTypes = resultList.get(resultList.size() - 1);
+        assertEquals("ResultList.removeLast unexpected last record", TEST_DATA_SIZE - 2, allTypes.getColumnLong());
+
+        RealmResults<AllTypes> resultListCheck = realm.where(AllTypes.class).findAll();
+        assertEquals("ResultList.removeLast not committed", TEST_DATA_SIZE - 1, resultListCheck.size());
+    }
+
+    @Test
+    public void sort_long() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = realm.allObjects(AllTypes.class);
+        sortedList.sort(AllTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getColumnLong(), sortedList.last().getColumnLong());
+
+        sortedList.sort(AllTypes.FIELD_LONG, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnLong(), sortedList.first().getColumnLong());
+        assertEquals("Last excepted to be last", resultList.last().getColumnLong(), sortedList.last().getColumnLong());
+
+        sortedList.sort(AllTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+    }
+
+    @Test
+    public void sort_date() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.where().findAll();
+        sortedList.sort(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(resultList.first().getColumnDate(), sortedList.last().getColumnDate());
+
+        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(resultList.first().getColumnDate(), reverseList.first().getColumnDate());
+        assertEquals(resultList.last().getColumnDate(), reverseList.last().getColumnDate());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
+        reserveSortedList.sort(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+    }
+
+    @Test
+    public void sort_boolean() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.where().findAll();
+        sortedList.sort(AllTypes.FIELD_BOOLEAN, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(false, sortedList.last().isColumnBoolean());
+        assertEquals(true, sortedList.first().isColumnBoolean());
+        assertEquals(true, sortedList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
+        assertEquals(false, sortedList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
+
+        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_BOOLEAN, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(true, reverseList.last().isColumnBoolean());
+        assertEquals(false, reverseList.first().isColumnBoolean());
+        assertEquals(false, reverseList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
+        assertEquals(true, reverseList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
+        reserveSortedList.sort(AllTypes.FIELD_BOOLEAN, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+        assertEquals(reserveSortedList.first(), sortedList.first());
+    }
+
+    @Test
+    public void sort_string() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.where().findAll();
+        sortedList.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(resultList.first().getColumnString(), sortedList.last().getColumnString());
+
+        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_STRING, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(resultList.first().getColumnString(), reverseList.first().getColumnString());
+
+        int numberOfDigits = 1 + ((int) Math.log10(TEST_DATA_SIZE));
+        int largestNumber = 1;
+        for (int i = 1; i < numberOfDigits; i++)
+            largestNumber *= 10;  // 10*10* ... *10
+        largestNumber = largestNumber - 1;
+        assertEquals(resultList.get(largestNumber).getColumnString(), reverseList.last().getColumnString());
+        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
+    }
+
+    @Test
+    public void sort_double() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.where().findAll();
+        sortedList.sort(AllTypes.FIELD_DOUBLE, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(resultList.first().getColumnDouble(), sortedList.last().getColumnDouble(), 0D);
+
+        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_DOUBLE, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(resultList.first().getColumnDouble(), reverseList.first().getColumnDouble(), 0D);
+        assertEquals(resultList.last().getColumnDouble(), reverseList.last().getColumnDouble(), 0D);
+
+        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
+        reverseSortedList.sort(AllTypes.FIELD_DOUBLE, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
+    }
+
+    @Test
+    public void sort_float() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.where().findAll();
+        sortedList.sort(AllTypes.FIELD_FLOAT, Sort.DESCENDING);
+        assertEquals(resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(resultList.first().getColumnFloat(), sortedList.last().getColumnFloat(), 0D);
+
+        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
+        reverseList.sort(AllTypes.FIELD_FLOAT, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(resultList.first().getColumnFloat(), reverseList.first().getColumnFloat(), 0D);
+        assertEquals(resultList.last().getColumnFloat(), reverseList.last().getColumnFloat(), 0D);
+
+        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
+        reverseSortedList.sort(AllTypes.FIELD_FLOAT, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
+    }
+
+    private void doTestSortOnColumnWithPartialNullValues(String fieldName) {
+        RealmResults<NullTypes> resultList = realm.where(NullTypes.class).findAll();
+        // Ascending
+        RealmResults<NullTypes> sortedList = realm.allObjects(NullTypes.class);
+        sortedList.sort(fieldName, Sort.ASCENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        // Null should always be the first one in the ascending sorted list
+        assertEquals(2, sortedList.first().getId());
+        assertEquals(1, sortedList.last().getId());
+
+        // Descending
+        sortedList = realm.allObjects(NullTypes.class);
+        sortedList.sort(fieldName, Sort.DESCENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(1, sortedList.first().getId());
+        // Null should always be the last one in the descending sorted list
+        assertEquals(2, sortedList.last().getId());
+    }
+
+    // Test sort on nullable fields with null values partially
+    @Test
+    public void sort_rowsWithPartialNullValues() {
+        populatePartialNullRowsForNumericTesting();
+
+        // 1 String
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_STRING_NULL);
+
+        // 3 Boolean
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_BOOLEAN_NULL);
+
+        // 6 Integer
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_INTEGER_NULL);
+
+        // 7 Float
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_FLOAT_NULL);
+
+        // 8 Double
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DOUBLE_NULL);
+
+        // 10 Date
+        doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_DATE_NULL);
+    }
+
+    @Test
+    public void sort_nonExistingColumn() {
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        thrown.expect(IllegalArgumentException.class);
+        resultList.sort("Non-existing");
+    }
+
+    @Test
+    public void sort_danishCharacters() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("Æble");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("Øl");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("Århus");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> sortedResult = result.where().findAll();
+        sortedResult.sort(AllTypes.FIELD_STRING);
+
+        assertEquals(3, sortedResult.size());
+        assertEquals("Æble", sortedResult.first().getColumnString());
+        assertEquals("Æble", sortedResult.get(0).getColumnString());
+        assertEquals("Øl", sortedResult.get(1).getColumnString());
+        assertEquals("Århus", sortedResult.get(2).getColumnString());
+
+        RealmResults<AllTypes> reverseResult = result.where().findAll();
+        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, reverseResult.size());
+        assertEquals("Æble", reverseResult.last().getColumnString());
+        assertEquals("Århus", reverseResult.get(0).getColumnString());
+        assertEquals("Øl", reverseResult.get(1).getColumnString());
+        assertEquals("Æble", reverseResult.get(2).getColumnString());
+    }
+
+    @Test
+    public void sort_russianCharacters() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("Санкт-Петербург");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("Москва");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("Новороссийск");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> sortedResult = result.where().findAll();
+        sortedResult.sort(AllTypes.FIELD_STRING);
+
+        assertEquals(3, sortedResult.size());
+        assertEquals("Москва", sortedResult.first().getColumnString());
+        assertEquals("Москва", sortedResult.get(0).getColumnString());
+        assertEquals("Новороссийск", sortedResult.get(1).getColumnString());
+        assertEquals("Санкт-Петербург", sortedResult.get(2).getColumnString());
+
+        RealmResults<AllTypes> reverseResult = result.where().findAll();
+        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, reverseResult.size());
+        assertEquals("Москва", reverseResult.last().getColumnString());
+        assertEquals("Санкт-Петербург", reverseResult.get(0).getColumnString());
+        assertEquals("Новороссийск", reverseResult.get(1).getColumnString());
+        assertEquals("Москва", reverseResult.get(2).getColumnString());
+    }
+
+    @Test
+    public void sort_greekCharacters() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("αύριο");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("ημέρες");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("δοκιμές");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> sortedResult = result.where().findAll();
+        sortedResult.sort(AllTypes.FIELD_STRING);
+
+        assertEquals(3, sortedResult.size());
+        assertEquals("αύριο", sortedResult.first().getColumnString());
+        assertEquals("αύριο", sortedResult.get(0).getColumnString());
+        assertEquals("δοκιμές", sortedResult.get(1).getColumnString());
+        assertEquals("ημέρες", sortedResult.get(2).getColumnString());
+
+        RealmResults<AllTypes> reverseResult = result.where().findAll();
+        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(3, reverseResult.size());
+        assertEquals("αύριο", reverseResult.last().getColumnString());
+        assertEquals("ημέρες", reverseResult.get(0).getColumnString());
+        assertEquals("δοκιμές", reverseResult.get(1).getColumnString());
+        assertEquals("αύριο", reverseResult.get(2).getColumnString());
+    }
+
+    //No sorting order defined. There are Korean, Arabic and Chinese characters.
+    @Test
+    public void sort_manyDifferentCharacters() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes at1 = realm.createObject(AllTypes.class);
+        at1.setColumnString("단위");
+        AllTypes at2 = realm.createObject(AllTypes.class);
+        at2.setColumnString("테스트");
+        AllTypes at3 = realm.createObject(AllTypes.class);
+        at3.setColumnString("وحدة");
+        AllTypes at4 = realm.createObject(AllTypes.class);
+        at4.setColumnString("اختبار");
+        AllTypes at5 = realm.createObject(AllTypes.class);
+        at5.setColumnString("单位");
+        AllTypes at6 = realm.createObject(AllTypes.class);
+        at6.setColumnString("试验");
+        AllTypes at7 = realm.createObject(AllTypes.class);
+        at7.setColumnString("單位");
+        AllTypes at8 = realm.createObject(AllTypes.class);
+        at8.setColumnString("測試");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> sortedResult = result.where().findAll();
+        sortedResult.sort(AllTypes.FIELD_STRING);
+
+        assertEquals(8, sortedResult.size());
+
+        @SuppressWarnings("UnnecessaryLocalVariable")
+        RealmResults<AllTypes> reverseResult = result;
+        reverseResult.sort(AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(8, reverseResult.size());
+    }
+
+    @Test
+    public void sort_twoLanguages() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        AllTypes allTypes1 = realm.createObject(AllTypes.class);
+        allTypes1.setColumnString("test");
+        AllTypes allTypes2 = realm.createObject(AllTypes.class);
+        allTypes2.setColumnString("αύριο");
+        AllTypes allTypes3 = realm.createObject(AllTypes.class);
+        allTypes3.setColumnString("work");
+        realm.commitTransaction();
+
+        try {
+            RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+            result.sort(AllTypes.FIELD_STRING);
+        } catch (IllegalArgumentException e) {
+            fail("Failed to sort with two kinds of alphabets");
+        }
+    }
+
+    @Test
+    public void sort_usingChildObject() {
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        owner.setName("owner");
+        Cat cat = realm.createObject(Cat.class);
+        cat.setName("cat");
+        owner.setCat(cat);
+        realm.commitTransaction();
+
+        RealmQuery<Owner> query = realm.where(Owner.class);
+        RealmResults<Owner> owners = query.findAll();
+
+        try {
+            owners.sort("cat.name");
+            fail("Sorting by child object properties should result in a IllegalArgumentException");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void sort_nullArguments() {
+        RealmResults<AllTypes> result = realm.allObjects(AllTypes.class);
+        try {
+            result.sort(null);
+            fail("Sorting with a null field name should throw an IllegalArgumentException");
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            result.sort((String) null, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void sort_emptyResults() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(0, results.size());
+        results.sort(AllTypes.FIELD_STRING);
+        assertEquals(0, results.size());
+    }
+
+    @Test
+    public void sort_singleField() {
+        RealmResults<AllTypes> sortedList = realm.allObjects(AllTypes.class);
+        sortedList.sort(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
+        assertEquals(0, sortedList.last().getColumnLong());
+    }
+
+    @Test
+    public void count() {
+        assertEquals(TEST_DATA_SIZE, realm.where(AllTypes.class).count());
+    }
+
+    @Test
+    public void findFirst() {
+        AllTypes result = realm.where(AllTypes.class).findFirst();
+        assertEquals(0, result.getColumnLong());
+        assertEquals("test data 0", result.getColumnString());
+
+        AllTypes none = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "smurf").findFirst();
+        assertNull(none);
+    }
+
+    @Test
+    public void where_equalTo_manyConditions() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        query.equalTo(AllTypes.FIELD_LONG, 0);
+        for (int i = 1; i < TEST_DATA_SIZE; i++) {
+            query.or().equalTo(AllTypes.FIELD_LONG, i);
+        }
+        RealmResults<AllTypes> allTypesRealmResults = query.findAll();
+        assertEquals(TEST_DATA_SIZE, allTypesRealmResults.size());
+    }
+
+    @Test
+    public void where() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
+        assertNotNull(query);
+    }
+
+    @Test
+    public void where_contains() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
+        AllTypes item = query.findFirst();
+        assertTrue("Item should exist in results.", query.findAll().contains(item));
+    }
+
+    @Test
+    public void where_contains_null() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
+        assertFalse("Should not contain a null item.", query.findAll().contains(null));
+    }
+
+    @Test
+    public void where_shouldNotContainRemovedItem() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).findAll().where();
+        AllTypes item = realm.where(AllTypes.class).findFirst();
+        realm.beginTransaction();
+        item.removeFromRealm();
+        realm.commitTransaction();
+        assertFalse("Should not contain a removed item.", query.findAll().contains(item));
+    }
+
+    /**
+     * Test to see if a particular item that does exist in the same Realm does not
+     * exist in the result set of another query.
+     */
+    @Test
+    public void where_lessThanGreaterThan() {
+        RealmResults<AllTypes> items = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 1000).findAll();
+        AllTypes anotherType = realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_LONG, 1000).findFirst();
+        assertFalse("Should not be able to find item in another result list.", items.contains(anotherType));
+    }
+
+    // Tests that `contains()` correctly doesn't find RealmObjects that belongs to another Realm file.
+    @Test
+    public void contains_realmObjectFromOtherRealm() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("contains_test.realm");
+        Realm realmTwo = Realm.getInstance(realmConfig);
+        try {
+
+            realmTwo.beginTransaction();
+            realmTwo.allObjects(AllTypes.class).clear();
+            realmTwo.allObjects(NonLatinFieldNames.class).clear();
+
+            for (int i = 0; i < TEST_DATA_SIZE; ++i) {
+                AllTypes allTypes = realmTwo.createObject(AllTypes.class);
+                allTypes.setColumnBoolean((i % 2) == 0);
+                allTypes.setColumnBinary(new byte[]{1, 2, 3});
+                allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - TEST_DATA_SIZE / 2)));
+                allTypes.setColumnDouble(3.1415 + i);
+                allTypes.setColumnFloat(1.234567f + i);
+                allTypes.setColumnString("test data " + i);
+                allTypes.setColumnLong(i);
+                Dog d = realmTwo.createObject(Dog.class);
+                d.setName("Foo " + i);
+                allTypes.setColumnRealmObject(d);
+                allTypes.getColumnRealmList().add(d);
+                NonLatinFieldNames nonLatinFieldNames = realmTwo.createObject(NonLatinFieldNames.class);
+                nonLatinFieldNames.set델타(i);
+                nonLatinFieldNames.setΔέλτα(i);
+            }
+            realmTwo.commitTransaction();
+
+            final AllTypes item = realmTwo.where(AllTypes.class).findFirst();
+
+            assertFalse("Should not be able to find one object in another Realm via RealmResults#contains",
+                    realm.where(AllTypes.class).findAll().contains(item));
+
+        } finally {
+            if (realmTwo != null && !realmTwo.isClosed()) {
+                realmTwo.close();
+            }
+        }
+    }
+
+    @Test
+    public void where_findAll_size() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE, allTypes.size());
+
+        // querying a RealmResults should find objects that fulfill the condition
+        RealmResults<AllTypes> onedigits = allTypes.where().lessThan(AllTypes.FIELD_LONG, 10).findAll();
+        assertEquals(Math.min(10, TEST_DATA_SIZE), onedigits.size());
+
+        // if no objects fulfill conditions, the result has zero objects
+        RealmResults<AllTypes> none = allTypes.where().greaterThan(AllTypes.FIELD_LONG, TEST_DATA_SIZE).findAll();
+        assertEquals(0, none.size());
+
+        // querying a result with zero objects must give zero objects
+        RealmResults<AllTypes> stillNone = none.where().greaterThan(AllTypes.FIELD_LONG, TEST_DATA_SIZE).findAll();
+        assertEquals(0, stillNone.size());
+    }
+
+    @Test
+    public void size_returns_Integer_MAX_VALUE_for_huge_results() {
+        final Table table = Mockito.mock(Table.class);
+        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, table, AllTypes.class);
+
+        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
+        assertEquals(Integer.MAX_VALUE - 1, targetResult.size());
+        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE));
+        assertEquals(Integer.MAX_VALUE, targetResult.size());
+        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
+        assertEquals(Integer.MAX_VALUE, targetResult.size());
+    }
+
+    @Test
+    public void where_findAllSorted() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, allTypes.size());
+        assertEquals(0, allTypes.first().getColumnLong());
+        assertEquals(TEST_DATA_SIZE - 1, allTypes.last().getColumnLong());
+
+        RealmResults<AllTypes> reverseList = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals(0, reverseList.last().getColumnLong());
+        assertEquals(TEST_DATA_SIZE - 1, reverseList.first().getColumnLong());
+
+        try {
+            realm.where(AllTypes.class).findAllSorted("invalid",
+                    Sort.DESCENDING);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void where_queryDateField() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * 5));
+        RealmResults<AllTypes> all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+
+        // before 1901
+        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * -100));
+        all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+
+        // after 2038
+        query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_DATE, new Date(YEAR_MILLIS * 100));
+        all = query.findAll();
+        assertEquals(1, query.count());
+        assertEquals(1, all.size());
+    }
+
+    @Test
+    public void indexOf() {
+        try {
+            RealmResults<AllTypes> all = realm.allObjects(AllTypes.class);
+            all.indexOf(all.first());
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    @Test
+    public void subList() {
+        RealmResults<AllTypes> list = realm.allObjects(AllTypes.class);
+        list.sort("columnLong");
+        List<AllTypes> sublist = list.subList(Math.max(list.size() - 20, 0), list.size());
+        assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
+    }
+
+    // Setting a not-nullable field to null is an error
+    // TODO Move this to RealmObjectTests?
+    @Test
+    public void setter_nullValueInRequiredField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+
+        // 1 String
+        try {
+            realm.beginTransaction();
+            list.first().setFieldStringNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 2 Bytes
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBytesNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 3 Boolean
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBooleanNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 4 Byte
+        try {
+            realm.beginTransaction();
+            list.first().setFieldBytesNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 5 Short 6 Integer 7 Long are skipped for this case, same with Bytes
+
+        // 8 Float
+        try {
+            realm.beginTransaction();
+            list.first().setFieldFloatNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 9 Double
+        try {
+            realm.beginTransaction();
+            list.first().setFieldDoubleNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // 10 Date
+        try {
+            realm.beginTransaction();
+            list.first().setFieldDateNotNull(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    // Setting a nullable field to null is not an error
+    // TODO Move this to RealmObjectsTest?
+    @Test
+    public void setter_nullValueInNullableField() {
+        TestHelper.populateTestRealmForNullTests(realm);
+        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+
+        // 1 String
+        realm.beginTransaction();
+        list.first().setFieldStringNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldStringNull());
+
+        // 2 Bytes
+        realm.beginTransaction();
+        list.first().setFieldBytesNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldBytesNull());
+
+        // 3 Boolean
+        realm.beginTransaction();
+        list.first().setFieldBooleanNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldBooleanNull());
+
+        // 4 Byte
+        // 5 Short 6 Integer 7 Long are skipped
+        realm.beginTransaction();
+        list.first().setFieldByteNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldByteNull());
+
+        // 8 Float
+        realm.beginTransaction();
+        list.first().setFieldFloatNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldFloatNull());
+
+        // 9 Double
+        realm.beginTransaction();
+        list.first().setFieldDoubleNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldDoubleNull());
+
+        // 10 Date
+        realm.beginTransaction();
+        list.first().setFieldDateNull(null);
+        realm.commitTransaction();
+        assertNull(realm.allObjects(NullTypes.class).first().getFieldDateNull());
+    }
+
+    @Test
+    public void unsupportedMethods() {
+        RealmResults<AllTypes> result = realm.where(AllTypes.class).findAll();
+
+        try { //noinspection deprecation
+            result.add(null);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+        try {
+            result.set(0, null);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        }
+    }
+
+
+    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
+    @Test
+    public void mutableMethodsOutsideTransactions() {
+        RealmResults<AllTypes> result = realm.where(AllTypes.class).findAll();
+
+        try {
+            result.clear();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+        try {
+            result.remove(0);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+        try {
+            result.removeLast();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    // TODO: More extended tests of querying all types must be done.
+
+    @Test
+    public void isValid() {
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        assertTrue(results.isValid());
+        populateTestRealm(1);
+        // still valid if result changed
+        assertTrue(results.isValid());
+
+        realm.close();
+        assertFalse(results.isValid());
+    }
+
+    // Triggered an ARM bug
+    @Test
+    public void verifyArmComparisons() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        long id = -1;
+        for (int i = 0; i < 10; i++) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(id--);
+        }
+        realm.commitTransaction();
+
+        assertEquals(10, realm.where(AllTypes.class).between(AllTypes.FIELD_LONG, -10, -1).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).greaterThan(AllTypes.FIELD_LONG, -11).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).greaterThanOrEqualTo(AllTypes.FIELD_LONG, -10).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 128).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 127).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).lessThanOrEqualTo(AllTypes.FIELD_LONG, -1).findAll().size());
+        assertEquals(10, realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 0).findAll().size());
+    }
+
+    // RealmResults.distinct(): requires indexing, and type = boolean, integer, date, string
+    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
+            for (int j = 0; j < numberOfBlocks; j++) {
+                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
+                obj.setIndexBoolean(j % 2 == 0);
+                obj.setIndexLong(j);
+                obj.setIndexDate(withNull ? null : new Date(1000 * (long) j));
+                obj.setIndexString(withNull ? null : "Test " + j);
+                obj.setNotIndexBoolean(j % 2 == 0);
+                obj.setNotIndexLong(j);
+                obj.setNotIndexDate(withNull ? null : new Date(1000 * (long) j));
+                obj.setNotIndexString(withNull ? null : "Test " + j);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateForDistinctInvalidTypesLinked(Realm realm) {
+        realm.beginTransaction();
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
+        realm.copyToRealm(notEmpty);
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void distinct() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_restrictedByPreviousDistinct() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        // all objects
+        RealmResults<AnnotationIndexTypes> allResults = realm.where(AnnotationIndexTypes.class).findAll();
+        assertEquals("All Objects Count", numberOfBlocks * numberOfBlocks * numberOfObjects, allResults.size());
+        // distinctive dates
+        RealmResults<AnnotationIndexTypes> distinctDates = allResults.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE);
+        assertEquals("Distinctive Dates", numberOfBlocks, distinctDates.size());
+        // distinctive Booleans
+        RealmResults<AnnotationIndexTypes> distinctBooleans = distinctDates.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        assertEquals("Distinctive Booleans", 2, distinctBooleans.size());
+        // all three results are the same object
+        assertTrue(allResults == distinctDates);
+        assertTrue(allResults == distinctBooleans);
+        assertTrue(distinctDates == distinctBooleans);
+    }
+
+    @Test
+    public void distinct_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
+            assertEquals(field, 1, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_noneExistingField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.where(AnnotationIndexTypes.class).findAll().distinct("doesNotExist");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinct_invalidTypes() {
+        populateTestRealm();
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.where(AllTypes.class).findAll().distinct(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported Index" + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported notIndex" + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.where(AllJavaTypes.class).findAll().distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+            fail("Unsupported columnBinary linked field");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // distinctAsync
+    private Realm openRealmInstance(String name) {
+        RealmConfiguration config = configFactory.createConfiguration(name);
+        Realm.deleteRealm(config);
+        return Realm.getInstance(config);
+    }
+
+    private void populateTestRealm(Realm testRealm, int objects) {
+        testRealm.beginTransaction();
+        testRealm.allObjects(AllTypes.class).clear();
+        testRealm.allObjects(NonLatinFieldNames.class).clear();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
+            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+            nonLatinFieldNames.set베타(1.234567f + i);
+            nonLatinFieldNames.setΒήτα(1.234567f + i);
+        }
+        testRealm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync() throws Throwable {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+        final Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        distinctBool.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(2, distinctBool.size());
+                endTest.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                endTest.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                endTest.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(numberOfBlocks, distinctString.size());
+                endTest.run();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void distinctAsync_withNullValues() throws Throwable {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(2);
+        final Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        distinctDate.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("distinctDate", 1, distinctDate.size());
+                endTest.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("distinctString", 1, distinctString.size());
+                endTest.run();
+            }
+        });
+    }
+
+    @Test
+    public void distinctAsync_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_doesNotExist() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.where(AnnotationIndexTypes.class).findAll().distinctAsync("doesNotExist");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctAsync_invalidTypes() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.where(AllTypes.class).findAll().distinctAsync(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
+            try {
+                realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                fail("Unsupported " + field + " linked field");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctAsync_notIndexedLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.where(AllJavaTypes.class).findAll().distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        RealmResults<AnnotationIndexTypes> distinctMulti = results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        assertEquals(numberOfBlocks, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_switchedFieldsOrder() {
+        final long numberOfBlocks = 25;
+        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
+
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        RealmResults<AnnotationIndexTypes> distinctStringLong = results.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
+        RealmResults<AnnotationIndexTypes> distinctLongString = results.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(4, distinctStringLong.size());
+        assertEquals(4, distinctLongString.size());
+        assertEquals(distinctStringLong.size(), distinctLongString.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_emptyField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        // an empty string field in the middle
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // an empty string field at the end
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field in the middle
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field at the end
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // (String)null makes varargs a null array.
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two (String)null for first and varargs fields
+        try {
+            results.distinct((String)null, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            results.distinct("", (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            results.distinct((String)null, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two empty fields tests
+        try {
+            results.distinct("", "");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        RealmResults<AnnotationIndexTypes> distinctMulti = results.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(1, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_doesNotExistField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesFields() {
+        populateTestRealm();
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
+        try {
+            results.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    private RealmResults<Dog> populateRealmResultsOnDeletedLinkView() {
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        for (int i = 0; i < 10; i++) {
+            Dog dog = new Dog();
+            dog.setName("name_" + i);
+            dog.setOwner(owner);
+            owner.getDogs().add(dog);
+        }
+        realm.commitTransaction();
+
+
+        RealmResults<Dog> dogs = owner.getDogs().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
+        //dogs = dogs.where().findFirst().getOwner().getDogs().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
+
+        realm.beginTransaction();
+        owner.removeFromRealm();
+        realm.commitTransaction();
+        return dogs;
+    }
+
+    // It will still be treated as valid table view in core, just alays be empty.
+    @Test
+    public void isValid_resultsBuiltOnDeletedLinkView() {
+        assertEquals(true, populateRealmResultsOnDeletedLinkView().isValid());
+    }
+
+    @Test
+    public void size_resultsBuiltOnDeletedLinkView() {
+        assertEquals(0, populateRealmResultsOnDeletedLinkView().size());
+    }
+
+    @Test
+    public void first_resultsBuiltOnDeletedLinkView() {
+        try {
+            populateRealmResultsOnDeletedLinkView().first();
+        } catch (ArrayIndexOutOfBoundsException ignored) {
+        }
+    }
+
+    @Test
+    public void last_resultsBuiltOnDeletedLinkView() {
+        try {
+            populateRealmResultsOnDeletedLinkView().last();
+        } catch (ArrayIndexOutOfBoundsException ignored) {
+        }
+    }
+
+    @Test
+    public void sum_resultsBuiltOnDeletedLinkView() {
+        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+        assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());
+        assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);
+        assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);
+    }
+
+    @Test
+    public void average_resultsBuiltOnDeletedLinkView() {
+        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+        assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);
+        assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);
+        assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);
+    }
+
+    @Test
+    public void clear_resultsBuiltOnDeletedLinkView() {
+        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+        realm.beginTransaction();
+        dogs.clear();
+        assertEquals(0, dogs.size());
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void max_resultsBuiltOnDeletedLinkView() {
+        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+        assertNull(dogs.max(Dog.FIELD_AGE));
+        assertNull(dogs.max(Dog.FIELD_HEIGHT));
+        assertNull(dogs.max(Dog.FIELD_WEIGHT));
+    }
+
+    @Test
+    public void max_dateResultsBuiltOnDeletedLinkView() {
+        assertEquals(null, populateRealmResultsOnDeletedLinkView().maxDate(Dog.FIELD_BIRTHDAY));
+    }
+
+    @Test
+    public void min_resultsBuiltOnDeletedLinkView() {
+        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
+        assertNull(dogs.min(Dog.FIELD_AGE));
+        assertNull(dogs.min(Dog.FIELD_HEIGHT));
+        assertNull(dogs.min(Dog.FIELD_WEIGHT));
+    }
+
+    @Test
+    public void minDateResultsBuiltOnDeletedLinkView() {
+        assertEquals(null, populateRealmResultsOnDeletedLinkView().minDate(Dog.FIELD_BIRTHDAY));
+    }
+
+    @Test
+    public void whereResultsBuiltOnDeletedLinkView() {
+        assertEquals(0, populateRealmResultsOnDeletedLinkView().where().findAll().size());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
new file mode 100644
index 0000000000..b2172a7367
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Owner;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmSchemaTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private DynamicRealm realm;
+    private RealmSchema realmSchema;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schema(AllJavaTypes.class, Owner.class)
+                .build();
+        Realm.getInstance(realmConfig).close(); // create Schema
+        realm = DynamicRealm.getInstance(realmConfig);
+        realmSchema = this.realm.getSchema();
+        realm.beginTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Test
+    public void getAll() {
+        Set<RealmObjectSchema> objectSchemas = realmSchema.getAll();
+        assertEquals(5, objectSchemas.size());
+
+        List<String> expectedTables = Arrays.asList(AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey");
+        for (RealmObjectSchema objectSchema : objectSchemas) {
+            if (!expectedTables.contains(objectSchema.getClassName())) {
+                fail(objectSchema.getClassName() + " was not found");
+            }
+        }
+    }
+
+    @Test
+    public void create() {
+        realmSchema.create("Foo");
+        assertTrue(realmSchema.contains("Foo"));
+    }
+
+    @Test
+    public void create_invalidNameThrows() {
+        String[] names = { null, "", TestHelper.getRandomString(57) };
+
+        for (String name : names) {
+            try {
+                realmSchema.create(name);
+            } catch (IllegalArgumentException ignored) {
+            }
+            assertFalse(String.format("'%s' failed", name), realmSchema.contains(name));
+        }
+    }
+
+    @Test
+    public void get() {
+        RealmObjectSchema objectSchema = realmSchema.get(AllJavaTypes.CLASS_NAME);
+        assertNotNull(objectSchema);
+        assertEquals(AllJavaTypes.CLASS_NAME, objectSchema.getClassName());
+    }
+
+    @Test
+    public void get_unknownClass() {
+        assertNull(realmSchema.get("Foo"));
+    }
+
+    @Test
+    public void rename() {
+        realmSchema.rename("Owner", "Owner2");
+        assertFalse(realmSchema.contains("Owner"));
+        assertTrue(realmSchema.contains("Owner2"));
+    }
+
+    @Test
+    public void rename_invalidArgumentThrows() {
+        String[] illegalNames = new String[] { null, "" };
+
+        // Test as first parameter
+        for (String illegalName : illegalNames) {
+            try {
+                realmSchema.rename(illegalName, AllJavaTypes.CLASS_NAME);
+                fail(illegalName + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+
+        // Test as last parameters
+        for (String illegalName : illegalNames) {
+            try {
+                realmSchema.rename(AllJavaTypes.CLASS_NAME, illegalName);
+                fail(illegalName + " should throw an exception");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void remove() {
+        realmSchema.remove(AllJavaTypes.CLASS_NAME);
+        assertFalse(realmSchema.contains(AllJavaTypes.CLASS_NAME));
+    }
+
+    @Test
+    public void remove_invalidArgumentThrows() {
+        try {
+            realmSchema.remove("Foo");
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            realmSchema.remove(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // Test that it if { A -> B  && B -> A } you should remove the individual fields first before removing the entire
+    // class. This also include transitive dependencies.
+    // FIXME: Disabled until https://github.com/realm/realm-core/pull/1475#issuecomment-185192434 is fixed.
+    // @Test
+    public void remove_classWithReferencesThrows() {
+        try {
+            realmSchema.remove("Cat");
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        RealmObjectSchema ownerSchema = realmSchema.get("Owner");
+        RealmObjectSchema catSchema = realmSchema.get("Cat");
+        ownerSchema.removeField("cat");
+        catSchema.removeField("owner");
+        realmSchema.remove("Cat");
+        assertFalse(realmSchema.contains("Cat"));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
new file mode 100644
index 0000000000..2f42aaeb33
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -0,0 +1,2979 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
+
+import junit.framework.AssertionFailedError;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Random;
+import java.util.Scanner;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.CyclicType;
+import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.Dog;
+import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.NoPrimaryKeyNullTypes;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.entities.NullTypes;
+import io.realm.entities.Owner;
+import io.realm.entities.OwnerPrimaryKey;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.PrimaryKeyMix;
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
+import io.realm.internal.log.RealmLog;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmTests {
+    private final static int TEST_DATA_SIZE = 10;
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Context context;
+    private Realm realm;
+    private List<String> columnData = new ArrayList<String>();
+    private RealmConfiguration realmConfig;
+
+    private void setColumnData() {
+        columnData.add(0, AllTypes.FIELD_BOOLEAN);
+        columnData.add(1, AllTypes.FIELD_DATE);
+        columnData.add(2, AllTypes.FIELD_DOUBLE);
+        columnData.add(3, AllTypes.FIELD_FLOAT);
+        columnData.add(4, AllTypes.FIELD_STRING);
+        columnData.add(5, AllTypes.FIELD_LONG);
+    }
+
+    @Before
+    public void setUp() {
+        // Injecting the Instrumentation instance is required
+        // for your test to run with AndroidJUnitRunner.
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+        realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    private void populateTestRealm(Realm realm, int objects) {
+        realm.beginTransaction();
+        realm.allObjects(AllTypes.class).clear();
+        realm.allObjects(NonLatinFieldNames.class).clear();
+        for (int i = 0; i < objects; ++i) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnBoolean((i % 3) == 0);
+            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnDate(new Date());
+            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnString("test data " + i);
+            allTypes.setColumnLong(i);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
+            nonLatinFieldNames.set델타(i);
+            nonLatinFieldNames.setΔέλτα(i);
+            nonLatinFieldNames.set베타(1.234567f + i);
+            nonLatinFieldNames.setΒήτα(1.234567f + i);
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateTestRealm() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void getInstance_nullDir() {
+        Realm.getInstance(new RealmConfiguration.Builder((File) null).build());
+    }
+
+    @Test
+    public void getInstance_writeProtectedDir() {
+        File folder = new File("/");
+        thrown.expect(IllegalArgumentException.class);
+        Realm.getInstance(new RealmConfiguration.Builder(folder).build());
+    }
+
+    @Test
+    public void getInstance_writeProtectedFile() throws IOException {
+        String REALM_FILE = "readonly.realm";
+        File folder = configFactory.getRoot();
+        File realmFile = new File(folder, REALM_FILE);
+        assertFalse(realmFile.exists());
+        assertTrue(realmFile.createNewFile());
+        assertTrue(realmFile.setWritable(false));
+
+        thrown.expect(RealmIOException.class);
+        Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
+    }
+
+    @Test
+    public void checkIfValid() {
+        // checkIfValid() must not throw any Exception against valid Realm instance.
+        realm.checkIfValid();
+
+        realm.close();
+        try {
+            realm.checkIfValid();
+            fail("closed Realm instance must throw IllegalStateException.");
+        } catch (IllegalStateException ignored) {
+        }
+        realm = null;
+    }
+
+    @Test
+    @UiThreadTest
+    public void internalRealmChangedHandlersRemoved() {
+        realm.close(); // Clear handler created by testRealm in setUp()
+        assertEquals(0, Realm.getHandlers().size());
+        final String REALM_NAME = "test-internalhandlers";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        Realm.deleteRealm(realmConfig);
+
+        // Open and close first instance of a Realm
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(realmConfig);
+            assertFalse(this.realm == realm);
+            assertEquals(1, Realm.getHandlers().size());
+            realm.close();
+
+            // All Realms closed. No handlers should be alive.
+            assertEquals(0, Realm.getHandlers().size());
+
+            // Open instance the 2nd time. Old handler should now be gone
+            realm = Realm.getInstance(realmConfig);
+            assertEquals(1, Realm.getHandlers().size());
+            realm.close();
+
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void getInstance() {
+        assertNotNull("Realm.getInstance unexpectedly returns null", realm);
+        assertTrue("Realm.getInstance does not contain expected table", realm.contains(AllTypes.class));
+    }
+
+    @Test
+    public void getInstance_context() {
+        RealmConfiguration config = new RealmConfiguration.Builder(context).build();
+        Realm.deleteRealm(config);
+
+        Realm testRealm = Realm.getInstance(context);
+        assertNotNull("Realm.getInstance unexpectedly returns null", testRealm);
+        assertTrue("Realm.getInstance does not contain expected table", testRealm.contains(AllTypes.class));
+        config = testRealm.getConfiguration();
+        config.getRealmFolder().equals(context.getFilesDir());
+        testRealm.close();
+        Realm.deleteRealm(config);
+    }
+
+    @Test
+    public void getInstance_nullContext() {
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance((Context) null); // throws when context.getFilesDir() is called;
+            // has nothing to do with Realm
+            fail("Should throw an exception");
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // Private API
+    @Test
+    public void remove() {
+        populateTestRealm();
+        realm.beginTransaction();
+        realm.remove(AllTypes.class, 0);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
+    }
+
+    // Private API
+    @Test
+    public void get() {
+        populateTestRealm();
+        AllTypes allTypes = realm.get(AllTypes.class, 0);
+        assertNotNull(allTypes);
+        assertEquals("test data 0", allTypes.getColumnString());
+    }
+
+    // Private API
+    @Test
+    public void contains() {
+        assertTrue("contains returns false for table that should exists", realm.contains(Dog.class));
+        assertFalse("contains returns true for non-existing table", realm.contains(null));
+    }
+
+    @Test
+    public void where() {
+        populateTestRealm();
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE, resultList.size());
+    }
+
+    // Note that this test is relying on the values set while initializing the test dataset
+    // TODO Move to RealmQueryTests?
+    @Test
+    public void where_queryResults() throws IOException {
+        populateTestRealm(realm, 159);
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 33).findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 3333).findAll();
+        assertEquals(0, resultList.size());
+
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "test data 0").findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "test data 0", Case.INSENSITIVE).findAll();
+        assertEquals(1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "Test data 0", Case.SENSITIVE).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    // TODO Move to RealmQueryTests?
+    @Test
+    public void where_equalTo_wrongFieldTypeAsInput() throws IOException {
+        populateTestRealm();
+        setColumnData();
+
+        for (int i = 0; i < columnData.size(); i++) {
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), true).findAll();
+                if (i != 0) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), new Date()).findAll();
+                if (i != 1) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.37d).findAll();
+                if (i != 2) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711f).findAll();
+                if (i != 3) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), "test").findAll();
+                if (i != 4) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            try {
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 1337).findAll();
+                if (i != 5) {
+                    fail("Realm.where should fail with illegal argument");
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    // TODO Move to RealmQueryTests?
+    @Test
+    public void where_equalTo_invalidFieldName() throws IOException {
+        try {
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", 33).findAll();
+            fail("Invalid field name");
+        } catch (Exception ignored) {
+        }
+
+        try {
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", "test").findAll();
+            fail("Invalid field name");
+        } catch (Exception ignored) {
+        }
+
+        try {
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", true).findAll();
+            fail("Invalid field name");
+        } catch (Exception ignored) {
+        }
+
+        try {
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415d).findAll();
+            fail("Invalid field name");
+        } catch (Exception ignored) {
+        }
+
+        try {
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415f).findAll();
+            fail("Invalid field name");
+        } catch (Exception ignored) {
+        }
+    }
+
+    // TODO Move to RealmQueryTests?
+    @Test
+    public void where_equalTo_requiredFieldWithNullArgument() {
+        // String
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NOT_NULL, (String) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Boolean
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NOT_NULL, (String) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Byte
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NOT_NULL, (Byte) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Short
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NOT_NULL, (Short) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Integer
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NOT_NULL, (Integer) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Long
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NOT_NULL, (Long) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Float
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NOT_NULL, (Float) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Double
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NOT_NULL, (Double) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Date
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NOT_NULL, (Date) null).findAll();
+            fail("Realm.where should fail with illegal argument");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void allObjects() {
+        populateTestRealm();
+        RealmResults<AllTypes> resultList = realm.allObjects(AllTypes.class);
+        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
+    }
+
+    @Test
+    public void allObjectsSorted() {
+        populateTestRealm();
+        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.ASCENDING);
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("test data 0", sortedList.first().getColumnString());
+
+        RealmResults<AllTypes> reverseList = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_STRING, Sort.DESCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("test data 0", reverseList.last().getColumnString());
+
+        try {
+            realm.allObjectsSorted(AllTypes.class, "invalid", Sort.ASCENDING);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void allObjectsSorted_singleField() {
+        populateTestRealm();
+        RealmResults<AllTypes> sortedList = realm.allObjectsSorted(AllTypes.class,
+                new String[]{AllTypes.FIELD_LONG},
+                new Sort[]{Sort.DESCENDING});
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
+        assertEquals(0, sortedList.last().getColumnLong());
+    }
+
+    @Test
+    public void allObjectsSorted_twoFields() {
+        TestHelper.populateForMultiSort(realm);
+
+        RealmResults<AllTypes> results1 = realm.allObjectsSorted(AllTypes.class,
+                new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
+                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+
+        assertEquals(3, results1.size());
+
+        assertEquals("Adam", results1.get(0).getColumnString());
+        assertEquals(4, results1.get(0).getColumnLong());
+
+        assertEquals("Adam", results1.get(1).getColumnString());
+        assertEquals(5, results1.get(1).getColumnLong());
+
+        assertEquals("Brian", results1.get(2).getColumnString());
+        assertEquals(4, results1.get(2).getColumnLong());
+
+        RealmResults<AllTypes> results2 = realm.allObjectsSorted(AllTypes.class,
+                new String[]{AllTypes.FIELD_LONG, AllTypes.FIELD_STRING},
+                new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+
+        assertEquals(3, results2.size());
+
+        assertEquals("Adam", results2.get(0).getColumnString());
+        assertEquals(4, results2.get(0).getColumnLong());
+
+        assertEquals("Brian", results2.get(1).getColumnString());
+        assertEquals(4, results2.get(1).getColumnLong());
+
+        assertEquals("Adam", results2.get(2).getColumnString());
+        assertEquals(5, results2.get(2).getColumnLong());
+    }
+
+    @Test
+    public void allObjectsSorted_failures() {
+        // zero fields specified
+        try {
+            realm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // number of fields and sorting orders don't match
+        try {
+            realm.allObjectsSorted(AllTypes.class,
+                    new String[]{AllTypes.FIELD_STRING},
+                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // null is not allowed
+        try {
+            realm.allObjectsSorted(AllTypes.class, null, (Sort[]) null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.allObjectsSorted(AllTypes.class, new String[]{AllTypes.FIELD_STRING}, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // non-existing field name
+        try {
+            realm.allObjectsSorted(AllTypes.class,
+                    new String[]{AllTypes.FIELD_STRING, "dont-exist"},
+                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void beginTransaction() throws IOException {
+        populateTestRealm();
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnFloat(3.1415f);
+        allTypes.setColumnString("a unique string");
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE + 1, resultList.size());
+
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "a unique string").findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 3.1415f).findAll();
+        assertEquals(1, resultList.size());
+    }
+
+    @Test
+    public void nestedTransaction() {
+        realm.beginTransaction();
+        try {
+            realm.beginTransaction();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().", e.getMessage());
+        }
+        realm.commitTransaction();
+    }
+
+    private enum Method {
+        METHOD_BEGIN,
+        METHOD_COMMIT,
+        METHOD_CANCEL,
+        METHOD_CLEAR,
+        METHOD_CLEAR_ALL,
+        METHOD_DISTINCT,
+        METHOD_CREATE_OBJECT,
+        METHOD_COPY_TO_REALM,
+        METHOD_COPY_TO_REALM_OR_UPDATE,
+        METHOD_CREATE_ALL_FROM_JSON,
+        METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON,
+        METHOD_CREATE_FROM_JSON,
+        METHOD_CREATE_OR_UPDATE_FROM_JSON
+    }
+
+    // Calling methods on a wrong thread will fail.
+    private boolean runMethodOnWrongThread(final Method method) throws InterruptedException, ExecutionException {
+        if (method != Method.METHOD_BEGIN) {
+            realm.beginTransaction();
+            realm.createObject(Dog.class);
+        }
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                try {
+                    switch (method) {
+                        case METHOD_BEGIN:
+                            realm.beginTransaction();
+                            break;
+                        case METHOD_COMMIT:
+                            realm.commitTransaction();
+                            break;
+                        case METHOD_CANCEL:
+                            realm.cancelTransaction();
+                            break;
+                        case METHOD_CLEAR:
+                            realm.clear(AllTypes.class);
+                            break;
+                        case METHOD_CLEAR_ALL:
+                            realm.deleteAll();
+                            break;
+                        case METHOD_DISTINCT:
+                            realm.distinct(AllTypesPrimaryKey.class, "columnLong");
+                            break;
+                        case METHOD_CREATE_OBJECT:
+                            realm.createObject(AllTypes.class);
+                            break;
+                        case METHOD_COPY_TO_REALM:
+                            realm.copyToRealm(new AllTypes());
+                            break;
+                        case METHOD_COPY_TO_REALM_OR_UPDATE:
+                            realm.copyToRealm(new AllTypesPrimaryKey());
+                            break;
+                        case METHOD_CREATE_ALL_FROM_JSON:
+                            realm.createAllFromJson(AllTypes.class, "[{}]");
+                            break;
+                        case METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON:
+                            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "[{\"columnLong\":1}]");
+                            break;
+                        case METHOD_CREATE_FROM_JSON:
+                            realm.createObjectFromJson(AllTypes.class, "{}");
+                            break;
+                        case METHOD_CREATE_OR_UPDATE_FROM_JSON:
+                            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1}");
+                            break;
+                    }
+                    return false;
+                } catch (IllegalStateException ignored) {
+                    return true;
+                } catch (RealmException jsonFailure) {
+                    // TODO: Eew. Reconsider how our JSON methods reports failure. See https://github.com/realm/realm-java/issues/1594
+                    return (jsonFailure.getMessage().equals("Could not map Json"));
+                }
+            }
+        });
+
+        boolean result = future.get();
+        if (method != Method.METHOD_BEGIN) {
+            realm.cancelTransaction();
+        }
+        return result;
+    }
+
+    @Test
+    public void methodCalledOnWrongThread() throws ExecutionException, InterruptedException {
+        for (Method method : Method.values()) {
+            assertTrue(method.toString(), runMethodOnWrongThread(method));
+        }
+    }
+
+    @Test
+    public void commitTransaction() {
+        populateTestRealm();
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnBoolean(true);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE + 1, resultList.size());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void commitTransaction_afterCancelTransaction() {
+        realm.beginTransaction();
+        realm.cancelTransaction();
+        realm.commitTransaction();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void commitTransaction_twice() {
+        realm.beginTransaction();
+        realm.commitTransaction();
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void cancelTransaction() {
+        populateTestRealm();
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.cancelTransaction();
+        assertEquals(TEST_DATA_SIZE, realm.allObjects(AllTypes.class).size());
+
+        try {
+            realm.cancelTransaction();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void executeTransaction_null() {
+        try {
+            realm.executeTransaction(null);
+            fail("null transaction should throw");
+        } catch (IllegalArgumentException ignored) {
+
+        }
+        assertFalse(realm.hasChanged());
+    }
+
+    @Test
+    public void executeTransaction_success() {
+        assertEquals(0, realm.allObjects(Owner.class).size());
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+            }
+        });
+        assertEquals(1, realm.allObjects(Owner.class).size());
+    }
+
+    @Test
+    public void executeTransaction_canceled() {
+        final AtomicReference<RuntimeException> thrownException = new AtomicReference<>(null);
+
+        assertEquals(0, realm.allObjects(Owner.class).size());
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    Owner owner = realm.createObject(Owner.class);
+                    owner.setName("Owner");
+                    thrownException.set(new RuntimeException("Boom"));
+                    throw thrownException.get();
+                }
+            });
+        } catch (RuntimeException e) {
+            //noinspection ThrowableResultOfMethodCallIgnored
+            assertTrue(e == thrownException.get());
+        }
+        assertEquals(0, realm.allObjects(Owner.class).size());
+    }
+
+    @Test
+    public void executeTransaction_cancelInsideClosureThrowsException() {
+        assertEquals(0, realm.allObjects(Owner.class).size());
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        try {
+            RealmLog.add(testLogger);
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    Owner owner = realm.createObject(Owner.class);
+                    owner.setName("Owner");
+                    realm.cancelTransaction();
+                    throw new RuntimeException("Boom");
+                }
+            });
+        } catch (RuntimeException ignored) {
+            // Ensure that we pass a valuable error message to the logger for developers.
+            assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
+        } finally {
+            RealmLog.remove(testLogger);
+        }
+        assertEquals(0, realm.allObjects(Owner.class).size());
+    }
+
+    @Test
+    public void clear_type() {
+        // ** clear non existing table should succeed
+
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+
+        // ** clear existing class, but leave other classes classes
+
+        // Add two classes
+        populateTestRealm();
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName("Castro");
+        realm.commitTransaction();
+        // Clear
+        realm.beginTransaction();
+        realm.clear(Dog.class);
+        realm.commitTransaction();
+        // Check one class is cleared but other class is still there
+        RealmResults<AllTypes> resultListTypes = realm.where(AllTypes.class).findAll();
+        assertEquals(TEST_DATA_SIZE, resultListTypes.size());
+        RealmResults<Dog> resultListDogs = realm.where(Dog.class).findAll();
+        assertEquals(0, resultListDogs.size());
+
+        // ** clear() must throw outside a transaction
+        try {
+            realm.clear(AllTypes.class);
+            fail("Expected exception");
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    private void createAndTestFilename(String language, String fileName) {
+        RealmConfiguration realmConfig = configFactory.createConfiguration(fileName);
+        Realm realm1 = Realm.getInstance(realmConfig);
+        realm1.beginTransaction();
+        Dog dog1 = realm1.createObject(Dog.class);
+        dog1.setName("Rex");
+        realm1.commitTransaction();
+        realm1.close();
+
+        File file = new File(realmConfig.getPath());
+        assertTrue(language, file.exists());
+
+        Realm realm2 = Realm.getInstance(realmConfig);
+        Dog dog2 = realm2.allObjects(Dog.class).first();
+        assertEquals(language, "Rex", dog2.getName());
+        realm2.close();
+    }
+
+    // TODO Move to RealmConfigurationTests?
+    @Test
+    public void realmConfiguration_fileName() {
+        createAndTestFilename("American", "Washington");
+        createAndTestFilename("Danish", "København");
+        createAndTestFilename("Russian", "Москва");
+        createAndTestFilename("Greek", "Αθήνα");
+        createAndTestFilename("Chinese", "北京市");
+        createAndTestFilename("Korean", "서울시");
+        createAndTestFilename("Arabic", "الرياض");
+        createAndTestFilename("India", "नई दिल्ली");
+        createAndTestFilename("Japanese", "東京都");
+    }
+
+    @Test
+    public void utf8Tests() {
+        realm.beginTransaction();
+        realm.clear(AllTypes.class);
+        realm.commitTransaction();
+
+        String file = "assets/unicode_codepoints.csv";
+        Scanner scanner = new Scanner(getClass().getClassLoader().getResourceAsStream(file), "UTF-8");
+        int i = 0;
+        String currentUnicode = null;
+        try {
+            realm.beginTransaction();
+            while (scanner.hasNextLine()) {
+                currentUnicode = scanner.nextLine();
+                char[] chars = Character.toChars(Integer.parseInt(currentUnicode, 16));
+                String codePoint = new String(chars);
+                AllTypes o = realm.createObject(AllTypes.class);
+                o.setColumnLong(i);
+                o.setColumnString(codePoint);
+
+                AllTypes realmType = realm.where(AllTypes.class).equalTo("columnLong", i).findFirst();
+                if (i > 1) {
+                    assertEquals("Codepoint: " + i + " / " + currentUnicode, codePoint,
+                            realmType.getColumnString()); // codepoint 0 is NULL, ignore for now.
+                }
+                i++;
+            }
+            realm.commitTransaction();
+        } catch (Exception e) {
+            fail("Failure, Codepoint: " + i + " / " + currentUnicode + " " + e.getMessage());
+        }
+    }
+
+    private List<String> getCharacterArray() {
+        List<String> chars_array = new ArrayList<String>();
+        String file = "assets/unicode_codepoints.csv";
+        Scanner scanner = new Scanner(getClass().getClassLoader().getResourceAsStream(file), "UTF-8");
+        int i = 0;
+        String currentUnicode = null;
+        try {
+            while (scanner.hasNextLine()) {
+                currentUnicode = scanner.nextLine();
+                char[] chars = Character.toChars(Integer.parseInt(currentUnicode, 16));
+                String codePoint = new String(chars);
+                chars_array.add(codePoint);
+                i++;
+            }
+        } catch (Exception e) {
+            fail("Failure, Codepoint: " + i + " / " + currentUnicode + " " + e.getMessage());
+        }
+        return chars_array;
+    }
+
+    // This test is slow. Move it to another testsuite that runs once a day on Jenkins.
+    // The test writes and reads random Strings.
+    // @Test TODO AndroidJUnit4 runner doesn't seem to respect the @Ignore annotation?
+    @Ignore
+    public void unicodeStrings() {
+        List<String> chars_array = getCharacterArray();
+        // Change seed value for new random values.
+        long seed = 20;
+        Random random = new Random(seed);
+
+        int random_value = 0;
+
+        String test_char = "";
+        String test_char_old = "";
+        String get_data = "";
+
+        for (int i = 0; i < 1000; i++) {
+            random_value = random.nextInt(25);
+
+            for (int j = 0; j < random_value; j++) {
+                test_char = test_char_old + chars_array.get(random.nextInt(27261));
+                test_char_old = test_char;
+            }
+            realm.beginTransaction();
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars(test_char);
+            realm.commitTransaction();
+
+            realm.allObjects(StringOnly.class).get(0).getChars();
+
+            realm.beginTransaction();
+            realm.clear(StringOnly.class);
+            realm.commitTransaction();
+        }
+    }
+
+    @Test
+    public void getInstance_referenceCounting() {
+        // At this point reference count should be one because of the setUp method
+        try {
+            realm.where(AllTypes.class).count();
+        } catch (IllegalStateException e) {
+            fail();
+        }
+
+        // Make sure the reference counter is per realm file
+        RealmConfiguration anotherConfig = configFactory.createConfiguration("anotherRealm.realm");
+        Realm.deleteRealm(anotherConfig);
+        Realm otherRealm = Realm.getInstance(anotherConfig);
+
+        // Raise the reference
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(configFactory.createConfiguration());
+        } finally {
+            if (realm != null) realm.close();
+        }
+
+        try {
+            // This should not fail because the reference is now 1
+            if (realm != null) {
+                realm.where(AllTypes.class).count();
+            }
+        } catch (IllegalStateException e) {
+            fail();
+        }
+
+        this.realm.close();
+        try {
+            this.realm.where(AllTypes.class).count();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            otherRealm.where(AllTypes.class).count();
+        } catch (IllegalStateException e) {
+            fail();
+        } finally {
+            otherRealm.close();
+        }
+
+        try {
+            otherRealm.where(AllTypes.class).count();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void getInstance_referenceCounting_doubleClose() {
+        realm.close();
+        realm.close(); // Count down once too many. Counter is now potentially negative
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        RealmResults<AllTypes> queryResult = realm.allObjects(AllTypes.class);
+        assertEquals(allTypes, queryResult.get(0));
+        realm.commitTransaction();
+        realm.close(); // This might not close the Realm if the reference count is wrong
+
+        // This should now fail due to the Realm being fully closed.
+        thrown.expect(IllegalStateException.class);
+        allTypes.getColumnString();
+    }
+
+    @Test
+    public void writeCopyTo() throws IOException {
+        RealmConfiguration configA = configFactory.createConfiguration("file1.realm");
+        RealmConfiguration configB = configFactory.createConfiguration("file2.realm");
+        Realm.deleteRealm(configA);
+        Realm.deleteRealm(configB);
+
+        Realm realm1 = null;
+        try {
+            realm1 = Realm.getInstance(configA);
+            realm1.beginTransaction();
+            AllTypes allTypes = realm1.createObject(AllTypes.class);
+            allTypes.setColumnString("Hello World");
+            realm1.commitTransaction();
+
+            realm1.writeCopyTo(new File(configB.getPath()));
+        } finally {
+            if (realm1 != null) {
+                realm1.close();
+            }
+        }
+
+        // Copy is compacted i.e. smaller than original
+        File file1 = new File(configA.getPath());
+        File file2 = new File(configB.getPath());
+        assertTrue(file1.length() >= file2.length());
+
+        Realm realm2 = null;
+        try {
+            // Contents is copied too
+            realm2 = Realm.getInstance(configB);
+            RealmResults<AllTypes> results = realm2.allObjects(AllTypes.class);
+            assertEquals(1, results.size());
+            assertEquals("Hello World", results.first().getColumnString());
+        } finally {
+            if (realm2 != null) {
+                realm2.close();
+            }
+        }
+    }
+
+    @Test
+    public void compactRealm() {
+        final RealmConfiguration configuration = realm.getConfiguration();
+        realm.close();
+        realm = null;
+        assertTrue(Realm.compactRealm(configuration));
+        realm = Realm.getInstance(configuration);
+    }
+
+    @Test
+    public void compactRealm_failsIfOpen() {
+        assertFalse(Realm.compactRealm(realm.getConfiguration()));
+    }
+
+    @Test
+    public void compactRealm_encryptedEmptyRealm() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealm(realmConfig));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void compactRealm_encryptedPopulatedRealm() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("enc.realm", TestHelper.getRandomKey());
+        Realm realm = Realm.getInstance(realmConfig);
+
+        populateTestRealm(realm, 100);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealm(realmConfig));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    public void compactRealm_emptyRealm() throws IOException {
+        final String REALM_NAME = "test.realm";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
+        long before = new File(realmConfig.getPath()).length();
+        assertTrue(Realm.compactRealm(realmConfig));
+        long after = new File(realmConfig.getPath()).length();
+        assertTrue(before >= after);
+    }
+
+    @Test
+    public void compactRealm_populatedRealm() throws IOException {
+        final String REALM_NAME = "test.realm";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        Realm realm = Realm.getInstance(realmConfig);
+        populateTestRealm(realm, 100);
+        realm.close();
+        long before = new File(realmConfig.getPath()).length();
+        assertTrue(Realm.compactRealm(realmConfig));
+        long after = new File(realmConfig.getPath()).length();
+        assertTrue(before >= after);
+    }
+
+    @Test
+    public void copyToRealm_null() {
+        realm.beginTransaction();
+        try {
+            realm.copyToRealm((AllTypes) null);
+            fail("Copying null objects into Realm should not be allowed");
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void copyToRealm_managedObject() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnString("Test");
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        AllTypes copiedAllTypes = realm.copyToRealm(allTypes);
+        realm.commitTransaction();
+
+        assertTrue(allTypes == copiedAllTypes);
+    }
+
+    @Test
+    public void copyToRealm_fromOtherRealm() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnString("Test");
+        realm.commitTransaction();
+
+        RealmConfiguration realmConfig = configFactory.createConfiguration("other-realm");
+        Realm otherRealm = Realm.getInstance(realmConfig);
+        otherRealm.beginTransaction();
+        AllTypes copiedAllTypes = otherRealm.copyToRealm(allTypes);
+        otherRealm.commitTransaction();
+
+        assertNotSame(allTypes, copiedAllTypes); // Same object in different Realms is not the same
+        assertEquals(allTypes.getColumnString(), copiedAllTypes.getColumnString()); // But data is still the same
+        otherRealm.close();
+    }
+
+    @Test
+    public void copyToRealm() {
+        Date date = new Date();
+        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
+        Dog dog = new Dog();
+        dog.setName("Fido");
+        RealmList<Dog> list = new RealmList<Dog>();
+        list.add(dog);
+
+        AllTypes allTypes = new AllTypes();
+        allTypes.setColumnString("String");
+        allTypes.setColumnLong(1l);
+        allTypes.setColumnFloat(1f);
+        allTypes.setColumnDouble(1d);
+        allTypes.setColumnBoolean(true);
+        allTypes.setColumnDate(date);
+        allTypes.setColumnBinary(new byte[]{1, 2, 3});
+        allTypes.setColumnRealmObject(dog);
+        allTypes.setColumnRealmList(list);
+
+        realm.beginTransaction();
+        AllTypes realmTypes = realm.copyToRealm(allTypes);
+        realm.commitTransaction();
+
+        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal
+        assertEquals(allTypes.getColumnString(), realmTypes.getColumnString()); // But they contain the same data
+        assertEquals(allTypes.getColumnLong(), realmTypes.getColumnLong());
+        assertEquals(allTypes.getColumnFloat(), realmTypes.getColumnFloat(), 0);
+        assertEquals(allTypes.getColumnDouble(), realmTypes.getColumnDouble(), 0);
+        assertEquals(allTypes.isColumnBoolean(), realmTypes.isColumnBoolean());
+        assertEquals(allTypes.getColumnDate(), realmTypes.getColumnDate());
+        assertArrayEquals(allTypes.getColumnBinary(), realmTypes.getColumnBinary());
+        assertEquals(allTypes.getColumnRealmObject().getName(), dog.getName());
+        assertEquals(list.size(), realmTypes.getColumnRealmList().size());
+        assertEquals(list.get(0).getName(), realmTypes.getColumnRealmList().get(0).getName());
+    }
+
+    @Test
+    public void copyToRealm_cyclicObjectReferences() {
+        CyclicType oneCyclicType = new CyclicType();
+        oneCyclicType.setName("One");
+        CyclicType anotherCyclicType = new CyclicType();
+        anotherCyclicType.setName("Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        CyclicType realmObject = realm.copyToRealm(oneCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObject.getName());
+        assertEquals("Two", realmObject.getObject().getName());
+        assertEquals(2, realm.allObjects(CyclicType.class).size());
+    }
+
+    @Test
+    public void copyToRealm_cyclicListReferences() {
+        CyclicType oneCyclicType = new CyclicType();
+        oneCyclicType.setName("One");
+        CyclicType anotherCyclicType = new CyclicType();
+        anotherCyclicType.setName("Two");
+        oneCyclicType.setObjects(new RealmList(anotherCyclicType));
+        anotherCyclicType.setObjects(new RealmList(oneCyclicType));
+
+        realm.beginTransaction();
+        CyclicType realmObject = realm.copyToRealm(oneCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObject.getName());
+        assertEquals(2, realm.allObjects(CyclicType.class).size());
+    }
+
+    // Check that if a field has a null value it gets converted to the default value for that type
+    @Test
+    public void copyToRealm_convertsNullToDefaultValue() {
+        realm.beginTransaction();
+        AllTypes realmTypes = realm.copyToRealm(new AllTypes());
+        realm.commitTransaction();
+
+        assertEquals("", realmTypes.getColumnString());
+        assertEquals(new Date(0), realmTypes.getColumnDate());
+        assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
+    }
+
+    // Check that using copyToRealm will set the primary key directly instead of first setting
+    // it to the default value (which can fail).
+    @Test
+    public void copyToRealm_primaryKeyIsSetDirectly() {
+        realm.beginTransaction();
+        realm.createObject(OwnerPrimaryKey.class);
+        realm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
+        realm.commitTransaction();
+        assertEquals(2, realm.where(OwnerPrimaryKey.class).count());
+    }
+
+    @Test
+    public void copyToRealm_primaryKeyIsNull() {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyToRealm(new PrimaryKeyAsString());
+    }
+
+    @Test
+    public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
+        realm.beginTransaction();
+
+        // Child object is managed by Realm
+        CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class);
+        childObj.setName("Child");
+        childObj.setId(1);
+
+        // Parent object is a standalone object
+        CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
+        parentObj.setObject(childObj);
+
+        realm.copyToRealm(parentObj);
+        realm.commitTransaction();
+
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
+    }
+
+    @Test
+    public void copyToRealm_list() {
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+        RealmList<Dog> list = new RealmList<Dog>();
+        list.addAll(Arrays.asList(dog1, dog2));
+
+        realm.beginTransaction();
+        List<Dog> copiedList = new ArrayList<Dog>(realm.copyToRealm(list));
+        realm.commitTransaction();
+
+        assertEquals(2, copiedList.size());
+        assertEquals(dog1.getName(), copiedList.get(0).getName());
+        assertEquals(dog2.getName(), copiedList.get(1).getName());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_null() {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyToRealmOrUpdate((AllTypes) null);
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_primaryKeyFieldIsNull() {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyToRealmOrUpdate(new PrimaryKeyAsString());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_noPrimaryKeyField() {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyToRealmOrUpdate(new AllTypes());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_addNewObjects() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+                obj.setId(1);
+                obj.setName("Foo");
+                realm.copyToRealm(obj);
+
+                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
+                obj2.setId(2);
+                obj2.setName("Bar");
+                realm.copyToRealmOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(2, realm.allObjects(PrimaryKeyAsLong.class).size());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_updateExistingObject() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+                obj.setColumnString("Foo");
+                obj.setColumnLong(1);
+                obj.setColumnFloat(1.23F);
+                obj.setColumnDouble(1.234D);
+                obj.setColumnBoolean(false);
+                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnDate(new Date(1000));
+                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
+                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
+                obj.setColumnBoxedBoolean(true);
+                realm.copyToRealm(obj);
+
+                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
+                obj2.setColumnString("Bar");
+                obj2.setColumnLong(1);
+                obj2.setColumnFloat(2.23F);
+                obj2.setColumnDouble(2.234D);
+                obj2.setColumnBoolean(true);
+                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnDate(new Date(2000));
+                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
+                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
+                obj2.setColumnBoxedBoolean(false);
+                realm.copyToRealmOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+
+        // Check that the the only element has all its properties updated
+        assertEquals("Bar", obj.getColumnString());
+        assertEquals(1, obj.getColumnLong());
+        assertEquals(2.23F, obj.getColumnFloat(), 0);
+        assertEquals(2.234D, obj.getColumnDouble(), 0);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertEquals(new Date(2000), obj.getColumnDate());
+        assertEquals("Dog3", obj.getColumnRealmObject().getName());
+        assertEquals(1, obj.getColumnRealmList().size());
+        assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
+        assertFalse(obj.getColumnBoxedBoolean());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_cyclicObject() {
+        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1);
+        oneCyclicType.setName("One");
+        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2);
+        anotherCyclicType.setName("Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        realm.copyToRealm(oneCyclicType);
+        realm.commitTransaction();
+
+        oneCyclicType.setName("Three");
+        anotherCyclicType.setName("Four");
+        realm.beginTransaction();
+        realm.copyToRealmOrUpdate(oneCyclicType);
+        realm.commitTransaction();
+
+        assertEquals(2, realm.allObjects(CyclicTypePrimaryKey.class).size());
+        assertEquals("Three", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getName());
+    }
+
+
+    // Checks that a standalone object with only default values can override data
+    @Test
+    public void copyToRealmOrUpdate_defaultValuesOverrideExistingData() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+                obj.setColumnString("Foo");
+                obj.setColumnLong(1);
+                obj.setColumnFloat(1.23F);
+                obj.setColumnDouble(1.234D);
+                obj.setColumnBoolean(false);
+                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnDate(new Date(1000));
+                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
+                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
+                realm.copyToRealm(obj);
+
+                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
+                obj2.setColumnLong(1);
+                realm.copyToRealmOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+
+        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertNull(obj.getColumnString());
+        assertEquals(1, obj.getColumnLong());
+        assertEquals(0.0F, obj.getColumnFloat(), 0);
+        assertEquals(0.0D, obj.getColumnDouble(), 0);
+        assertEquals(false, obj.isColumnBoolean());
+        assertNull(obj.getColumnBinary());
+        assertNull(obj.getColumnDate());
+        assertNull(obj.getColumnRealmObject());
+        assertEquals(0, obj.getColumnRealmList().size());
+    }
+
+
+    // Tests that if references to objects are removed, the objects are still in the Realm
+    @Test
+    public void copyToRealmOrUpdate_referencesNotDeleted() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+                obj.setColumnLong(1);
+                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
+                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
+                realm.copyToRealm(obj);
+
+                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
+                obj2.setColumnLong(1);
+                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
+                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
+                realm.copyToRealmOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(4, realm.allObjects(DogPrimaryKey.class).size());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_primaryKeyMixInObjectGraph() {
+        // Crate Object graph where tier 2 consists of 1 object with primary key and one doesn't.
+        // Tier 3 both have objects with primary keys.
+        //
+        //        PK
+        //     /      \
+        //    PK      nonPK
+        //    |        |
+        //    PK       PK
+        DogPrimaryKey dog = new DogPrimaryKey(1, "Dog");
+        OwnerPrimaryKey owner = new OwnerPrimaryKey(1, "Owner");
+        owner.setDog(dog);
+
+        Cat cat = new Cat();
+        cat.setScaredOfDog(dog);
+
+        PrimaryKeyMix mixObject = new PrimaryKeyMix(1);
+        mixObject.setDogOwner(owner);
+        mixObject.setCat(cat);
+
+        realm.beginTransaction();
+        PrimaryKeyMix realmObject = realm.copyToRealmOrUpdate(mixObject);
+        realm.commitTransaction();
+
+        assertEquals("Dog", realmObject.getCat().getScaredOfDog().getName());
+        assertEquals("Dog", realmObject.getDogOwner().getDog().getName());
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_iterable() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+                obj.setId(1);
+                obj.setName("Foo");
+                realm.copyToRealm(obj);
+
+                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
+                obj2.setId(1);
+                obj2.setName("Bar");
+
+                PrimaryKeyAsLong obj3 = new PrimaryKeyAsLong();
+                obj3.setId(1);
+                obj3.setName("Baz");
+
+                realm.copyToRealmOrUpdate(Arrays.asList(obj2, obj3));
+            }
+        });
+
+        assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
+        assertEquals("Baz", realm.allObjects(PrimaryKeyAsLong.class).first().getName());
+    }
+
+    // Tests that a collection of objects with references all gets copied.
+    @Test
+    public void copyToRealmOrUpdate_iterableChildObjects() {
+        DogPrimaryKey dog = new DogPrimaryKey(1, "Snoop");
+
+        AllTypesPrimaryKey allTypes1 = new AllTypesPrimaryKey();
+        allTypes1.setColumnLong(1);
+        allTypes1.setColumnRealmObject(dog);
+
+        AllTypesPrimaryKey allTypes2 = new AllTypesPrimaryKey();
+        allTypes1.setColumnLong(2);
+        allTypes2.setColumnRealmObject(dog);
+
+        realm.beginTransaction();
+        realm.copyToRealmOrUpdate(Arrays.asList(allTypes1, allTypes2));
+        realm.commitTransaction();
+
+        assertEquals(2, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.allObjects(DogPrimaryKey.class).size());
+    }
+
+    @Test
+    public void getInstance_differentEncryptionKeys() {
+        byte[] key1 = TestHelper.getRandomKey(42);
+        byte[] key2 = TestHelper.getRandomKey(42);
+
+        // Make sure the key is the same, but in two different instances
+        assertArrayEquals(key1, key2);
+        assertTrue(key1 != key2);
+
+        final String ENCRYPTED_REALM = "differentKeys.realm";
+        Realm realm1 = null;
+        Realm realm2 = null;
+        try {
+            realm1 = Realm.getInstance(configFactory.createConfiguration(ENCRYPTED_REALM, key1));
+            try {
+                realm2 = Realm.getInstance(configFactory.createConfiguration(ENCRYPTED_REALM, key2));
+            } catch (Exception e) {
+                fail();
+            } finally {
+                if (realm2 != null) {
+                    realm2.close();
+                }
+            }
+        } finally {
+            if (realm1 != null) {
+                realm1.close();
+            }
+        }
+    }
+
+    @Test
+    public void writeEncryptedCopyTo() throws Exception {
+        populateTestRealm();
+        long before = realm.where(AllTypes.class).count();
+        assertEquals(TEST_DATA_SIZE, before);
+
+        // Configure test realms
+        final String ENCRYPTED_REALM_FILE_NAME = "encryptedTestRealm.realm";
+        final String RE_ENCRYPTED_REALM_FILE_NAME = "reEncryptedTestRealm.realm";
+        final String DECRYPTED_REALM_FILE_NAME = "decryptedTestRealm.realm";
+
+        RealmConfiguration encryptedRealmConfig = configFactory.createConfiguration(ENCRYPTED_REALM_FILE_NAME,
+                TestHelper.getRandomKey());
+
+        RealmConfiguration reEncryptedRealmConfig = configFactory.createConfiguration(RE_ENCRYPTED_REALM_FILE_NAME,
+                TestHelper.getRandomKey());
+
+        RealmConfiguration decryptedRealmConfig = configFactory.createConfiguration(DECRYPTED_REALM_FILE_NAME);
+
+        // Write encrypted copy from a unencrypted Realm
+        File destination = new File(encryptedRealmConfig.getPath());
+        try {
+            realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
+        } catch (Exception e) {
+            fail(e.getMessage());
+        }
+
+        Realm encryptedRealm = null;
+        try {
+
+            // Verify encrypted Realm and write new encrypted copy with a new key
+            encryptedRealm = Realm.getInstance(encryptedRealmConfig);
+            assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
+
+            destination = new File(reEncryptedRealmConfig.getPath());
+            try {
+                encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
+            } catch (Exception e) {
+                fail(e.getMessage());
+            }
+
+            // Verify re-encrypted copy
+            Realm reEncryptedRealm = null;
+            try {
+                reEncryptedRealm = Realm.getInstance(reEncryptedRealmConfig);
+                assertEquals(TEST_DATA_SIZE, reEncryptedRealm.where(AllTypes.class).count());
+            } finally {
+                if (reEncryptedRealm != null) {
+                    reEncryptedRealm.close();
+                    if (!Realm.deleteRealm(reEncryptedRealmConfig)) {
+                        fail();
+                    }
+                }
+            }
+
+            // Write non-encrypted copy from the encrypted version
+            destination = new File(decryptedRealmConfig.getPath());
+            try {
+                encryptedRealm.writeEncryptedCopyTo(destination, null);
+            } catch (Exception e) {
+                fail(e.getMessage());
+            }
+
+            // Verify decrypted Realm and cleanup
+            Realm decryptedRealm = null;
+            try {
+                decryptedRealm = Realm.getInstance(decryptedRealmConfig);
+                assertEquals(TEST_DATA_SIZE, decryptedRealm.where(AllTypes.class).count());
+            } finally {
+                if (decryptedRealm != null) {
+                    decryptedRealm.close();
+                    if (!Realm.deleteRealm(decryptedRealmConfig)) {
+                        fail();
+                    }
+                }
+            }
+        } finally {
+            if (encryptedRealm != null) {
+                encryptedRealm.close();
+                if (!Realm.deleteRealm(encryptedRealmConfig)) {
+                    fail();
+                }
+            }
+        }
+    }
+
+    @Test
+    public void deleteRealm_failures() {
+        final String OTHER_REALM_NAME = "yetAnotherRealm.realm";
+
+        RealmConfiguration configA = configFactory.createConfiguration();
+        RealmConfiguration configB = configFactory.createConfiguration(OTHER_REALM_NAME);
+
+        // This instance is already cached because of the setUp() method so this deletion should throw
+        try {
+            Realm.deleteRealm(configA);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Create a new Realm file
+        Realm yetAnotherRealm = Realm.getInstance(configB);
+
+        // Deleting it should fail
+        try {
+            Realm.deleteRealm(configB);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // But now that we close it deletion should work
+        yetAnotherRealm.close();
+        try {
+            Realm.deleteRealm(configB);
+        } catch (Exception e) {
+            fail();
+        }
+    }
+
+    // TODO Does this test something meaningfull not tested elsewhere?
+    @Test
+    public void setter_updateField() throws Exception {
+        realm.beginTransaction();
+
+        // Create an owner with two dogs
+        OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class);
+        owner.setId(1);
+        owner.setName("Jack");
+        Dog rex = realm.createObject(Dog.class);
+        rex.setName("Rex");
+        Dog fido = realm.createObject(Dog.class);
+        fido.setName("Fido");
+        owner.getDogs().add(rex);
+        owner.getDogs().add(fido);
+        assertEquals(2, owner.getDogs().size());
+
+        // Changing the name of the owner should not affect the number of dogs
+        owner.setName("Peter");
+        assertEquals(2, owner.getDogs().size());
+
+        // Updating the user should not affect it either. This is actually a no-op since owner is a Realm backed object
+        OwnerPrimaryKey owner2 = realm.copyToRealmOrUpdate(owner);
+        assertEquals(2, owner.getDogs().size());
+        assertEquals(2, owner2.getDogs().size());
+
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void deleteRealm() throws InterruptedException {
+        File tempDir = new File(context.getFilesDir(), "delete_test_dir");
+        if (!tempDir.exists()) {
+            assertTrue(tempDir.mkdir());
+        }
+
+        assertTrue(tempDir.isDirectory());
+
+        // Delete all files in the directory
+        File[] files = tempDir.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                assertTrue(file.delete());
+            }
+        }
+
+        final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
+
+        final CountDownLatch readyToCloseLatch = new CountDownLatch(1);
+        final CountDownLatch closedLatch = new CountDownLatch(1);
+
+        Realm realm = Realm.getInstance(configuration);
+        // Create another Realm to ensure the log files are generated
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(configuration);
+                try {
+                    readyToCloseLatch.await();
+                } catch (InterruptedException ignored) {
+                }
+                realm.close();
+                closedLatch.countDown();
+            }
+        }).start();
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        readyToCloseLatch.countDown();
+        realm.close();
+        closedLatch.await();
+
+        // ATTENTION: log, log_a, log_b will be deleted when the other thread close the Realm peacefully. And we force
+        // user to close all Realm instances before deleting. It would be difficult to simulate a case that log files
+        // exist before deletion. Let's keep the case like this for now, we might allow user to delete Realm even there
+        // are instances opened in the future.
+        assertTrue(Realm.deleteRealm(configuration));
+
+        // Directory should be empty now
+        assertEquals(0, tempDir.listFiles().length);
+    }
+
+    // Test that all methods that require a transaction (ie. any function that mutates Realm data)
+    @Test
+    public void callMutableMethodOutsideTransaction() throws JSONException, IOException {
+
+        // Prepare standalone object data
+        AllTypesPrimaryKey t = new AllTypesPrimaryKey();
+        List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
+
+        // Prepare JSON data
+        String jsonObjStr = "{ \"columnLong\" : 1 }";
+        JSONObject jsonObj = new JSONObject(jsonObjStr);
+        InputStream jsonObjStream = TestHelper.stringToStream(jsonObjStr);
+        InputStream jsonObjStream2 = TestHelper.stringToStream(jsonObjStr);
+
+        String jsonArrStr = " [{ \"columnLong\" : 1 }] ";
+        JSONArray jsonArr = new JSONArray(jsonArrStr);
+        InputStream jsonArrStream = TestHelper.stringToStream(jsonArrStr);
+        InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
+
+        // Test all methods that should require a transaction
+        try { realm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
+        try { realm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
+        try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
+        try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
+        try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
+        try { realm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
+        try { realm.clear(AllTypes.class);          fail(); } catch (IllegalStateException expected) {}
+        try { realm.deleteAll();                        fail(); } catch (IllegalStateException expected) {}
+
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
+        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
+        try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);       fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (RealmException expected) {}
+        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (RealmException expected) {}
+        try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);          fail(); } catch (IllegalStateException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (RealmException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (RealmException expected) {}
+        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
+    }
+
+    // TODO: re-introduce this test mocking the ReferenceQueue instead of relying on the GC
+/*    // Check that FinalizerRunnable can free native resources (phantom refs)
+    public void testReferenceCleaning() throws NoSuchFieldException, IllegalAccessException {
+        testRealm.close();
+
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext()).name("myown").build();
+        Realm.deleteRealm(config);
+        testRealm = Realm.getInstance(config);
+
+        // Manipulate field accessibility to facilitate testing
+        Field realmFileReference = BaseRealm.class.getDeclaredField("sharedGroupManager");
+        realmFileReference.setAccessible(true);
+        Field contextField = SharedGroup.class.getDeclaredField("context");
+        contextField.setAccessible(true);
+        Field rowReferencesField = io.realm.internal.Context.class.getDeclaredField("rowReferences");
+        rowReferencesField.setAccessible(true);
+
+        SharedGroupManager realmFile = (SharedGroupManager) realmFileReference.get(testRealm);
+        assertNotNull(realmFile);
+
+        io.realm.internal.Context context = (io.realm.internal.Context) contextField.get(realmFile.getSharedGroup());
+        assertNotNull(context);
+
+        Map<Reference<?>, Integer> rowReferences = (Map<Reference<?>, Integer>) rowReferencesField.get(context);
+        assertNotNull(rowReferences);
+
+        // insert some rows, then give the thread some time to cleanup
+        // we have 8 reference so far let's add more
+        final int numberOfPopulateTest = 1000;
+        final int numberOfObjects = 20;
+        final int totalNumberOfReferences = 8 + numberOfObjects * 2 * numberOfPopulateTest;
+
+        long tic = System.currentTimeMillis();
+        for (int i = 0; i < numberOfPopulateTest; i++) {
+            populateTestRealm(testRealm, numberOfObjects);
+        }
+        long toc = System.currentTimeMillis();
+        Log.d(RealmTest.class.getName(), "Insertion time: " + (toc - tic));
+
+        final int MAX_GC_RETRIES = 5;
+        int numberOfRetries = 0;
+        Log.i("GCing", "Hoping for the best");
+        while (rowReferences.size() > 0 && numberOfRetries < MAX_GC_RETRIES) {
+            SystemClock.sleep(TimeUnit.SECONDS.toMillis(1)); //1s
+            TestHelper.allocGarbage(0);
+            numberOfRetries++;
+            System.gc();
+        }
+        context.cleanNativeReferences();
+
+        // we can't guarantee that all references have been GC'ed but we should detect a decrease
+        boolean isDecreasing = rowReferences.size() < totalNumberOfReferences;
+        if (!isDecreasing) {
+            fail("Native resources are not being closed");
+
+        } else {
+            android.util.Log.d(RealmTest.class.getName(), "References freed : "
+                    + (totalNumberOfReferences - rowReferences.size()) + " out of " + totalNumberOfReferences);
+        }
+    }*/
+
+    @Test
+    public void createObject_cannotCreateDynamicRealmObject() {
+        realm.beginTransaction();
+        try {
+            realm.createObject(DynamicRealmObject.class);
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    // Test close Realm in another thread different from where it is created.
+    @Test
+    public void close_differentThread() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AssertionFailedError threadAssertionError[] = new AssertionFailedError[1];
+
+        final Thread thatThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    realm.close();
+                    threadAssertionError[0] = new AssertionFailedError(
+                            "Close realm in a different thread should throw IllegalStateException.");
+                } catch (IllegalStateException ignored) {
+                }
+                latch.countDown();
+            }
+        });
+        thatThread.start();
+
+        // Timeout should never happen
+        latch.await();
+        if (threadAssertionError[0] != null) {
+            throw threadAssertionError[0];
+        }
+        // After exception thrown in another thread, nothing should be changed to the realm in this thread.
+        realm.checkIfValid();
+        realm.close();
+        realm = null;
+    }
+
+    @Test
+    public void isClosed() {
+        assertFalse(realm.isClosed());
+        realm.close();
+        assertTrue(realm.isClosed());
+    }
+
+    // Test Realm#isClosed() in another thread different from where it is created.
+    @Test
+    public void isClosed_differentThread() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AssertionFailedError threadAssertionError[] = new AssertionFailedError[1];
+
+        final Thread thatThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    realm.isClosed();
+                    threadAssertionError[0] = new AssertionFailedError(
+                            "Call isClosed() of Realm instance in a different thread should throw IllegalStateException.");
+                } catch (IllegalStateException ignored) {
+                }
+                latch.countDown();
+            }
+        });
+        thatThread.start();
+
+        // Timeout should never happen
+        latch.await();
+        if (threadAssertionError[0] != null) {
+            throw threadAssertionError[0];
+        }
+        // After exception thrown in another thread, nothing should be changed to the realm in this thread.
+        realm.checkIfValid();
+        assertFalse(realm.isClosed());
+        realm.close();
+    }
+
+    // Realm validation & initialization is done once, still ColumnIndices
+    // should be populated for the subsequent Realm sharing the same configuration
+    // even if we skip initialization & validation
+    @Test
+    public void columnIndicesIsPopulatedWhenSkippingInitialization() throws Throwable {
+        final RealmConfiguration realmConfiguration = configFactory.createConfiguration("columnIndices");
+        final Exception threadError[] = new Exception[1];
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch mainThreadRealmDone = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfiguration); // This will populate columnIndices
+                try {
+                    bgRealmOpened.countDown();
+                    TestHelper.awaitOrFail(mainThreadRealmDone);
+                    realm.close();
+                    bgRealmClosed.countDown();
+                } catch (Exception e) {
+                    threadError[0] = e;
+                } finally {
+                    if (!realm.isClosed()) {
+                        realm.close();
+                    }
+                }
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        Realm realm = Realm.getInstance(realmConfiguration);
+        realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll(); // This would crash if columnIndices == null
+        realm.close();
+        mainThreadRealmDone.countDown();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        if (threadError[0] != null) {
+            throw threadError[0];
+        }
+    }
+
+    // FIXME HandlerThread
+    @Test
+    public void processLocalListenersAfterRefresh() throws InterruptedException {
+        // Used to validate the result
+        final AtomicBoolean listenerWasCalled = new AtomicBoolean(false);
+        final AtomicBoolean typeListenerWasCalled = new AtomicBoolean(false);
+
+        // Used by the background thread to wait for the main thread to do the write operation
+        final CountDownLatch bgThreadLatch = new CountDownLatch(1);
+        final CountDownLatch bgClosedLatch = new CountDownLatch(1);
+        final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
+
+        Thread backgroundThread = new Thread() {
+            @Override
+            public void run() {
+                // this will allow to register a listener.
+                // we don't start looping to prevent the callback to be invoked via
+                // the handler mechanism, the purpose of this test is to make sure refresh calls
+                // the listeners.
+                Looper.prepare();
+
+                Realm bgRealm = Realm.getInstance(realmConfig);
+                RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
+                try {
+                    bgRealm.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            listenerWasCalled.set(true);
+                        }
+                    });
+                    dogs.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            typeListenerWasCalled.set(true);
+                        }
+                    });
+
+                    bgThreadReadyLatch.countDown();
+                    bgThreadLatch.await(); // Wait for the main thread to do a write operation
+                    bgRealm.refresh(); // This should call the listener
+                    assertTrue(listenerWasCalled.get());
+                    assertTrue(typeListenerWasCalled.get());
+                    bgRealm.close();
+                    bgRealm = null;
+                    // DON'T count down in the final block! The test will fail silently!!!
+                    bgClosedLatch.countDown();
+                } catch (InterruptedException e) {
+                    fail(e.getMessage());
+                } finally {
+                    if (bgRealm != null) {
+                        bgRealm.close();
+                    }
+                }
+            }
+        };
+        backgroundThread.start();
+
+        // Wait until bgThread finishes adding listener to the RealmResults. Otherwise same TableView version won't
+        // trigger the listener.
+        bgThreadReadyLatch.await();
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+        bgThreadLatch.countDown();
+        bgClosedLatch.await();
+    }
+
+    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
+            for (int j = 0; j < numberOfBlocks; j++) {
+                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
+                obj.setIndexBoolean(j % 2 == 0);
+                obj.setIndexLong(j);
+                obj.setIndexDate(withNull ? null : new Date(1000 * (long) j));
+                obj.setIndexString(withNull ? null : "Test " + j);
+                obj.setNotIndexBoolean(j % 2 == 0);
+                obj.setNotIndexLong(j);
+                obj.setNotIndexDate(withNull ? null : new Date(1000 * (long) j));
+                obj.setNotIndexString(withNull ? null : "Test " + j);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    private void populateForDistinctInvalidTypesLinked(Realm realm) {
+        realm.beginTransaction();
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
+        realm.copyToRealm(notEmpty);
+        realm.commitTransaction();
+    }
+
+    // Realm.distinct(): requires indexing, and type = boolean, integer, date, string
+    @Test
+    public void distinct() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
+            assertEquals(field, numberOfBlocks, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.distinct(AnnotationIndexTypes.class, field);
+            assertEquals(field, 1, distinct.size());
+        }
+    }
+
+    @Test
+    public void distinct_notIndexedFieldsThrows() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
+            try {
+                realm.distinct(AnnotationIndexTypes.class, field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinct_unknownFieldThrows() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+        thrown.expect(IllegalArgumentException.class);
+
+        realm.distinct(AnnotationIndexTypes.class, "doesNotExist");
+    }
+
+    @Test
+    public void distinct_invalidTypeThrows() {
+        populateTestRealm();
+
+        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
+            try {
+                realm.distinct(AllTypes.class, field);
+                fail(field);
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        assertEquals(numberOfBlocks, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_switchedFieldsOrder() {
+        final long numberOfBlocks = 25;
+        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
+
+        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples
+        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
+        RealmResults<AnnotationIndexTypes> distinctLongString = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(4, distinctStringLong.size());
+        assertEquals(4, distinctLongString.size());
+        assertEquals(distinctStringLong.size(), distinctLongString.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_emptyFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        // an empty string field in the middle
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // an empty string field at the end
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field in the middle
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // a null string field at the end
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // (String)null makes varargs a null array.
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two (String)null for first and varargs fields
+        try {
+            realm.distinct(AnnotationIndexTypes.class, (String)null, (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            realm.distinct(AnnotationIndexTypes.class, "", (String)null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        // "" & (String)null combination
+        try {
+            realm.distinct(AnnotationIndexTypes.class, (String)null, "");
+        } catch (IllegalArgumentException ignored) {
+        }
+        // Two empty fields tests
+        try {
+            realm.distinct(AnnotationIndexTypes.class, "", "");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_withNullValues() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        RealmResults<AnnotationIndexTypes> distinctMulti = realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        assertEquals(1, distinctMulti.size());
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_doesNotExistField() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesFields() {
+        populateTestRealm();
+
+        try {
+            realm.distinct(AllTypes.class, AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_indexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_notIndexedLinkedFields() {
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10;
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
+
+        try {
+            realm.distinct(AnnotationIndexTypes.class, AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void distinctMultiArgs_invalidTypesLinkedFields() {
+        populateForDistinctInvalidTypesLinked(realm);
+
+        try {
+            realm.distinct(AllJavaTypes.class, AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void isInTransaction() {
+        assertFalse(realm.isInTransaction());
+        realm.beginTransaction();
+        assertTrue(realm.isInTransaction());
+        realm.commitTransaction();
+        assertFalse(realm.isInTransaction());
+        realm.beginTransaction();
+        assertTrue(realm.isInTransaction());
+        realm.cancelTransaction();
+        assertFalse(realm.isInTransaction());
+    }
+
+    // test for https://github.com/realm/realm-java/issues/1646
+    @Test
+    public void closingRealmWhileOtherThreadIsOpeningRealm() throws Exception {
+        final CountDownLatch startLatch = new CountDownLatch(1);
+        final CountDownLatch endLatch = new CountDownLatch(1);
+
+        final List<Exception> exception = new ArrayList<Exception>();
+
+        new Thread() {
+            @Override
+            public void run() {
+                try {
+                    startLatch.await();
+                } catch (InterruptedException e) {
+                    exception.add(e);
+                    return;
+                }
+
+                final Realm realm = Realm.getInstance(realmConfig);
+                try {
+                    realm.where(AllTypes.class).equalTo("columnLong", 0L).findFirst();
+                } catch (Exception e) {
+                    exception.add(e);
+                } finally {
+                    endLatch.countDown();
+                    realm.close();
+                }
+            }
+        }.start();
+
+        // prevent for another thread to enter Realm.createAndValidate().
+        synchronized (BaseRealm.class) {
+            startLatch.countDown();
+
+            // wait for another thread's entering Realm.createAndValidate().
+            SystemClock.sleep(100L);
+
+            realm.close();
+            realm = null;
+        }
+
+        endLatch.await();
+
+        if (!exception.isEmpty()) {
+            throw exception.get(0);
+        }
+    }
+
+    // Bug reported https://github.com/realm/realm-java/issues/1728.
+    // Root cause is validatedRealmFiles will be cleaned when any thread's Realm ref counter reach 0.
+    @Test
+    public void openRealmWhileTransactionInAnotherThread() throws Exception {
+        final CountDownLatch realmOpenedInBgLatch = new CountDownLatch(1);
+        final CountDownLatch realmClosedInFgLatch = new CountDownLatch(1);
+        final CountDownLatch transBeganInBgLatch = new CountDownLatch(1);
+        final CountDownLatch fgFinishedLatch = new CountDownLatch(1);
+        final CountDownLatch bgFinishedLatch = new CountDownLatch(1);
+        final List<Exception> exception = new ArrayList<Exception>();
+
+        // Step 1: testRealm is opened already.
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                // Step 2: Open realm in background thread.
+                Realm realm = Realm.getInstance(realmConfig);
+                realmOpenedInBgLatch.countDown();
+                try {
+                    realmClosedInFgLatch.await();
+                } catch (InterruptedException e) {
+                    exception.add(e);
+                    realm.close();
+                    return;
+                }
+
+                // Step 4: Start transaction in background
+                realm.beginTransaction();
+                transBeganInBgLatch.countDown();
+                try {
+                    fgFinishedLatch.await();
+                } catch (InterruptedException e) {
+                    exception.add(e);
+                }
+                // Step 6: Cancel Transaction and close realm in background
+                realm.cancelTransaction();
+                realm.close();
+                bgFinishedLatch.countDown();
+            }
+        });
+        thread.start();
+
+        realmOpenedInBgLatch.await();
+        // Step 3: Close all realm instances in foreground thread.
+        realm.close();
+        realmClosedInFgLatch.countDown();
+        transBeganInBgLatch.await();
+
+        // Step 5: Get a new Realm instance in foreground
+        realm = Realm.getInstance(realmConfig);
+        fgFinishedLatch.countDown();
+        bgFinishedLatch.await();
+
+        if (!exception.isEmpty()) {
+            throw exception.get(0);
+        }
+    }
+
+    @Test
+    public void refresh_insideTransactionThrows() {
+        realm.beginTransaction();
+        thrown.expect(IllegalStateException.class);
+        realm.refresh();
+    }
+
+    @Test
+    public void isEmpty() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration("empty_test.realm");
+        Realm emptyRealm = Realm.getInstance(realmConfig);
+
+        assertTrue(emptyRealm.isEmpty());
+
+        emptyRealm.beginTransaction();
+        PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+        obj.setId(1);
+        obj.setName("Foo");
+        emptyRealm.copyToRealm(obj);
+        assertFalse(emptyRealm.isEmpty());
+        emptyRealm.cancelTransaction();
+
+        assertTrue(emptyRealm.isEmpty());
+
+        emptyRealm.beginTransaction();
+        obj = new PrimaryKeyAsLong();
+        obj.setId(1);
+        obj.setName("Foo");
+        emptyRealm.copyToRealm(obj);
+        emptyRealm.commitTransaction();
+
+        assertFalse(emptyRealm.isEmpty());
+
+        emptyRealm.close();
+    }
+
+    @Test
+    public void copyFromRealm_invalidObjectThrows() {
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        obj.removeFromRealm();
+        realm.commitTransaction();
+
+        try {
+            realm.copyFromRealm(obj);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            realm.copyFromRealm(new AllTypes());
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void copyFromRealm_invalidDepthThrows() {
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyFromRealm(obj, -1);
+    }
+
+    @Test
+    public void copyFromRealm() {
+        populateTestRealm();
+        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes standaloneObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.getColumnBinary(), standaloneObject.getColumnBinary());
+        assertEquals(realmObject.getColumnString(), standaloneObject.getColumnString());
+        assertEquals(realmObject.getColumnLong(), standaloneObject.getColumnLong());
+        assertEquals(realmObject.getColumnFloat(), standaloneObject.getColumnFloat(), 0.00000000001);
+        assertEquals(realmObject.getColumnDouble(), standaloneObject.getColumnDouble(), 0.00000000001);
+        assertEquals(realmObject.isColumnBoolean(), standaloneObject.isColumnBoolean());
+        assertEquals(realmObject.getColumnDate(), standaloneObject.getColumnDate());
+    }
+
+    @Test
+    public void copyFromRealm_newCopyEachTime() {
+        populateTestRealm();
+        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes standaloneObject1 = realm.copyFromRealm(realmObject);
+        AllTypes standaloneObject2 = realm.copyFromRealm(realmObject);
+        assertFalse(standaloneObject1 == standaloneObject2);
+        assertNotSame(standaloneObject1, standaloneObject2);
+    }
+
+    // Test that the object graph is copied as it is and no extra copies are made
+    // 1) (A -> B/[B,C])
+    // 2) (C -> B/[B,A])
+    // A copy should result in only 3 distinct objects
+    @Test
+    public void copyFromRealm_cyclicObjectGraph() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("A");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("B");
+        CyclicType objC = realm.createObject(CyclicType.class);
+        objC.setName("C");
+        objA.setObject(objB);
+        objC.setObject(objB);
+        objA.getObjects().add(objB);
+        objA.getObjects().add(objC);
+        objC.getObjects().add(objB);
+        objC.getObjects().add(objA);
+        realm.commitTransaction();
+
+        CyclicType copyA = realm.copyFromRealm(objA);
+        CyclicType copyB = copyA.getObject();
+        CyclicType copyC = copyA.getObjects().get(1);
+
+        assertEquals("A", copyA.getName());
+        assertEquals("B", copyB.getName());
+        assertEquals("C", copyC.getName());
+
+        // Assert object equality on the object graph
+        assertTrue(copyA.getObject() == copyC.getObject());
+        assertTrue(copyA.getObjects().get(0) == copyC.getObjects().get(0));
+        assertTrue(copyA == copyC.getObjects().get(1));
+        assertTrue(copyC == copyA.getObjects().get(1));
+    }
+
+    // Test that for (A -> B -> C) for maxDepth = 1, result is (A -> B -> null)
+    @Test
+    public void copyFromRealm_checkMaxDepth() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("A");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("B");
+        CyclicType objC = realm.createObject(CyclicType.class);
+        objC.setName("C");
+        objA.setObject(objB);
+        objC.setObject(objC);
+        objA.getObjects().add(objB);
+        objA.getObjects().add(objC);
+        realm.commitTransaction();
+
+        CyclicType copyA = realm.copyFromRealm(objA, 1);
+
+        assertNull(copyA.getObject().getObject());
+    }
+
+    // Test that depth restriction is calculated from the top-most encountered object, i.e. it is possible for some
+    // objects to exceed the depth limit.
+    // A -> B -> C -> D -> E
+    // A -> D -> E
+    // D is both at depth 1 and 3. For maxDepth = 3, E should still be copied.
+    @Test
+    public void copyFromRealm_sameObjectDifferentDepths() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("A");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("B");
+        CyclicType objC = realm.createObject(CyclicType.class);
+        objC.setName("C");
+        CyclicType objD = realm.createObject(CyclicType.class);
+        objD.setName("D");
+        CyclicType objE = realm.createObject(CyclicType.class);
+        objE.setName("E");
+        objA.setObject(objB);
+        objB.setObject(objC);
+        objC.setObject(objD);
+        objD.setObject(objE);
+        objA.setOtherObject(objD);
+        realm.commitTransaction();
+
+        // object is filled before otherObject (because of field order - WARNING: Not guaranteed)
+        // this means that the object will be encountered first time at max depth, so E will not be copied.
+        // If the object cache does not handle this, otherObject will be wrong.
+        CyclicType copyA = realm.copyFromRealm(objA, 3);
+        assertEquals("E", copyA.getOtherObject().getObject().getName());
+    }
+
+    @Test
+    public void copyFromRealm_list_invalidListThrows() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        List<AllTypes> list = new RealmList<AllTypes>(object);
+        object.removeFromRealm();
+        realm.commitTransaction();
+
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyFromRealm(list);
+    }
+
+    @Test
+    public void copyFromRealm_list_invalidDepthThrows() {
+        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        thrown.expect(IllegalArgumentException.class);
+        realm.copyFromRealm(results, -1);
+    }
+
+    // Test that the same Realm objects in a list result in the same Java in-memory copy.
+    // List: A -> [(B -> C), (B -> C)] should result in only 2 copied objects A and B and not A1, B1, A2, B2
+    @Test
+    public void copyFromRealm_list_sameElements() {
+        realm.beginTransaction();
+        CyclicType objA = realm.createObject(CyclicType.class);
+        objA.setName("A");
+        CyclicType objB = realm.createObject(CyclicType.class);
+        objB.setName("B");
+        CyclicType objC = realm.createObject(CyclicType.class);
+        objC.setName("C");
+        objB.setObject(objC);
+        objA.getObjects().add(objB);
+        objA.getObjects().add(objB);
+        realm.commitTransaction();
+
+        List<CyclicType> results = realm.copyFromRealm(objA.getObjects());
+        assertEquals(2, results.size());
+        assertEquals("B", results.get(0).getName());
+        assertTrue(results.get(0) == results.get(1));
+    }
+
+    @Test
+    public void copyFromRealm_dynamicRealmObjectThrows() {
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        DynamicRealmObject dObj = new DynamicRealmObject(obj);
+
+        try {
+            realm.copyFromRealm(dObj);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void copyFromRealm_dynamicRealmListThrows() {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dynamicRealm.beginTransaction();
+        RealmList<DynamicRealmObject> dynamicList = dynamicRealm.createObject(AllTypes.CLASS_NAME).getList(AllTypes.FIELD_REALMLIST);
+        DynamicRealmObject dObj = dynamicRealm.createObject(Dog.CLASS_NAME);
+        dynamicList.add(dObj);
+        dynamicRealm.commitTransaction();
+        try {
+            realm.copyFromRealm(dynamicList);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    // Test if close can be called from Realm change listener when there is no other listeners
+    @Test
+    public void closeRealmInChangeListener() {
+        realm.close();
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        HandlerThread handlerThread = new HandlerThread("background");
+        handlerThread.start();
+        final Handler handler = new Handler(handlerThread.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                final Realm realm = Realm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (realm.where(AllTypes.class).count() == 1) {
+                            realm.removeChangeListener(this);
+                            realm.close();
+                            signalTestFinished.countDown();
+                        }
+                    }
+                };
+
+                realm.addChangeListener(listener);
+
+                realm.executeTransactionAsync(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        realm.createObject(AllTypes.class);
+                    }
+                });
+            }
+        });
+        TestHelper.awaitOrFail(signalTestFinished);
+    }
+
+    // Test if close can be called from Realm change listener when there is a listener on empty Realm Object
+    @Test
+    @RunTestInLooperThread
+    public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final RealmChangeListener dummyListener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+            }
+        };
+
+        // Change listener on Realm
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(AllTypes.class).count() == 1) {
+                    realm.removeChangeListener(this);
+                    realm.close();
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        };
+        realm.addChangeListener(listener);
+
+        // Change listener on Empty Object
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        allTypes.addChangeListener(dummyListener);
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        });
+    }
+
+    // Test if close can be called from Realm change listener when there is an listener on non-empty Realm Object
+    @Test
+    @RunTestInLooperThread
+    public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final RealmChangeListener dummyListener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+            }
+        };
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(AllTypes.class).count() == 2) {
+                    realm.removeChangeListener(this);
+                    realm.close();
+
+                    // End test after next looper event to ensure that all listeners were called.
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        };
+
+        realm.addChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // Step 1: Change listener on Realm Object
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        allTypes.addChangeListener(dummyListener);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        });
+    }
+
+    // Test if close can be called from Realm change listener when there is an listener on RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final RealmChangeListener dummyListener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+            }
+        };
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(AllTypes.class).count() == 1) {
+                    realm.removeChangeListener(this);
+                    realm.close();
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        };
+
+        realm.addChangeListener(listener);
+
+        // Step 1: Change listener on Realm results
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        results.addChangeListener(dummyListener);
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        });
+    }
+
+    @Test
+    public void removeChangeListenerThrowExceptionOnNonLooperThread() {
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                try {
+                    realm.removeChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                        }
+                    });
+                    fail("Should not be able to invoke removeChangeListener");
+                } catch (IllegalStateException ignored) {
+                } finally {
+                    realm.close();
+                    signalTestFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+
+        try {
+            TestHelper.awaitOrFail(signalTestFinished);
+        } finally {
+            thread.interrupt();
+        }
+    }
+
+    @Test
+    public void removeAllChangeListenersThrowExceptionOnNonLooperThread() {
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                try {
+                    realm.removeAllChangeListeners();
+                    fail("Should not be able to invoke removeChangeListener");
+                } catch (IllegalStateException ignored) {
+                } finally {
+                    realm.close();
+                    signalTestFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+
+        try {
+            TestHelper.awaitOrFail(signalTestFinished);
+        } finally {
+            thread.interrupt();
+        }
+    }
+
+    @Test
+    public void clear_all() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.createObject(Owner.class).setCat(realm.createObject(Cat.class));
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(AllTypes.class).count());
+        assertEquals(1, realm.where(Owner.class).count());
+        assertEquals(1, realm.where(Cat.class).count());
+
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(AllTypes.class).count());
+        assertEquals(0, realm.where(Owner.class).count());
+        assertEquals(0, realm.where(Cat.class).count());
+        assertTrue(realm.isEmpty());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
new file mode 100644
index 0000000000..9a352fc60d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -0,0 +1,543 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.CyclicType;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+import rx.Observable;
+import rx.Subscription;
+import rx.functions.Action0;
+import rx.functions.Action1;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RxJavaTests {
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread() {
+        @Override
+        public void looperTearDown() {
+            if (subscription != null && !subscription.isUnsubscribed()) {
+                subscription.unsubscribe();
+            }
+        }
+    };
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+    private Subscription subscription;
+
+    @Before
+    public void setUp() throws Exception {
+        // For non-LooperThread tests
+        realm = Realm.getInstance(configFactory.createConfiguration());
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        // For non-LooperThread tests
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmObject_emittedOnSubscribe() {
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(AllTypes rxObject) {
+                assertTrue(rxObject == obj);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmObject_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(AllTypes rxObject) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        obj.setColumnLong(1);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void findFirst_emittedOnSubscribe() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class).setColumnLong(42);
+        realm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 42).findFirst().<AllTypes>asObservable()
+                .subscribe(new Action1<AllTypes>() {
+                    @Override
+                    public void call(AllTypes rxObject) {
+                        subscribedNotified.set(true);
+                    }
+                });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @UiThreadTest
+    public void findFirstAsync_emittedOnSubscribe() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
+        subscription = asyncObj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(AllTypes rxObject) {
+                assertTrue(rxObject == asyncObj);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(AllTypes rxObject) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        obj.setColumnLong(1);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmResults_emittedOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+            @Override
+            public void call(RealmResults<AllTypes> rxResults) {
+                assertTrue(rxResults == results);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmResults_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        realm.commitTransaction();
+
+        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+            @Override
+            public void call(RealmResults<AllTypes> allTypes) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void findAllAsync_emittedOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+            @Override
+            public void call(RealmResults<AllTypes> rxResults) {
+                assertTrue(rxResults == results);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void findAllAsync_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        subscription = realm.where(AllTypes.class).findAllAsync().asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+            @Override
+            public void call(RealmResults<AllTypes> rxResults) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realm_emittedOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+            @Override
+            public void call(Realm rxRealm) {
+                assertTrue(rxRealm == realm);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realm_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+            @Override
+            public void call(Realm rxRealm) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealm_emittedOnSubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+            @Override
+            public void call(DynamicRealm rxRealm) {
+                assertTrue(rxRealm == dynamicRealm);
+                subscribedNotified.set(true);
+            }
+        }, new Action1<Throwable>() {
+            @Override
+            public void call(Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        });
+
+        assertTrue(subscribedNotified.get());
+        dynamicRealm.close();
+        subscription.unsubscribe();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealm_emittedOnUpdate() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+            @Override
+            public void call(DynamicRealm rxRealm) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    dynamicRealm.close();
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        dynamicRealm.createObject("AllTypes");
+        dynamicRealm.commitTransaction();
+    }
+
+    @Test
+    @UiThreadTest
+    public void unsubscribe_sameThread() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+            @Override
+            public void call(Realm rxRealm) {
+                assertTrue(rxRealm == realm);
+                subscribedNotified.set(true);
+            }
+        });
+        assertEquals(1, realm.handlerController.changeListeners.size());
+        subscription.unsubscribe();
+        assertEquals(0, realm.handlerController.changeListeners.size());
+    }
+
+    @Test
+    @UiThreadTest
+    public void unsubscribe_fromOtherThread() {
+        final CountDownLatch unsubscribeCompleted = new CountDownLatch(1);
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final Subscription subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+            @Override
+            public void call(Realm rxRealm) {
+                assertTrue(rxRealm == realm);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        assertEquals(1, realm.handlerController.changeListeners.size());
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    subscription.unsubscribe();
+                    fail();
+                } catch (IllegalStateException ignored) {
+                } finally {
+                    unsubscribeCompleted.countDown();
+                }
+            }
+        }).start();
+        TestHelper.awaitOrFail(unsubscribeCompleted);
+        assertEquals(1, realm.handlerController.changeListeners.size());
+        // We cannot call subscription.unsubscribe() again, so manually close the extra Realm instance opened by
+        // the Observable.
+        realm.close();
+    }
+
+    @Test
+    @UiThreadTest
+    public void wrongGenericClassThrows() {
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        Observable<CyclicType> obs = obj.asObservable();
+        obs.subscribe(new Action1<CyclicType>() {
+            @Override
+            public void call(CyclicType cyclicType) {
+                fail();
+            }
+        }, new Action1<Throwable>() {
+            @Override
+            public void call(Throwable ignored) {
+            }
+        });
+    }
+
+    @Test
+    @UiThreadTest
+    public void realm_closeInDoOnUnsubscribe() {
+        Observable<Realm> observable = realm.asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        realm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<Realm>() {
+            @Override
+            public void call(Realm rxRealm) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(realm.isClosed());
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealm_closeInDoOnUnsubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+
+        Observable<DynamicRealm> observable = dynamicRealm.asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        dynamicRealm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<DynamicRealm>() {
+            @Override
+            public void call(DynamicRealm rxRealm) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(dynamicRealm.isClosed());
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmResults_closeInDoOnUnsubscribe() {
+        Observable<RealmResults<AllTypes>> observable = realm.allObjects(AllTypes.class).asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        realm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<RealmResults<AllTypes>>() {
+            @Override
+            public void call(RealmResults<AllTypes> allTypes) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(realm.isClosed());
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmResults_closeInDoOnUnsubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+
+        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        dynamicRealm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void call(RealmResults<DynamicRealmObject> allTypes) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(dynamicRealm.isClosed());
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmObject_closeInDoOnUnsubscribe() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        Observable<AllTypes> observable = realm.allObjects(AllTypes.class).first().<AllTypes>asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        realm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(AllTypes allTypes) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(realm.isClosed());
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmObject_closeInDoOnUnsubscribe() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+
+        Observable<DynamicRealmObject> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).first().<DynamicRealmObject>asObservable()
+                .doOnUnsubscribe(new Action0() {
+                    @Override
+                    public void call() {
+                        dynamicRealm.close();
+                    }
+                });
+
+        subscription = observable.subscribe(new Action1<DynamicRealmObject>() {
+            @Override
+            public void call(DynamicRealmObject obj) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(dynamicRealm.isClosed());
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
similarity index 95%
rename from realm/src/androidTest/java/io/realm/SortTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 63bcaa50b0..7f116eb2d7 100644
--- a/realm/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -30,8 +30,8 @@
     private final static String[] ORDER_STRING_INT = {FIELD_STRING, FIELD_LONG};
     private final static String[] ORDER_INT_STRING = {FIELD_LONG, FIELD_STRING};
 
-    private final static boolean[] ORDER_ASC_ASC = {RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING};
-    private final static boolean[] ORDER_ASC_DES = {RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_DESCENDING};
+    private final static Sort[] ORDER_ASC_ASC = {Sort.ASCENDING, Sort.ASCENDING};
+    private final static Sort[] ORDER_ASC_DES = {Sort.ASCENDING, Sort.DESCENDING};
 
     @Override
     public void setUp() {
@@ -40,8 +40,9 @@ public void setUp() {
         // 1: (4, "Brian")
         // 2: (4, "Adam")
         // 3: (5, "Adam")
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration config = TestHelper.createConfiguration(getContext());
+        Realm.deleteRealm(config);
+        testRealm = Realm.getInstance(config);
 
         testRealm.beginTransaction();
         testRealm.clear(AllTypes.class);
@@ -73,7 +74,7 @@ public void testSortMultiFailures() {
 
         // zero fields specified
         try {
-            allTypes.sort(new String[]{}, new boolean[]{});
+            allTypes.sort(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -87,7 +88,7 @@ public void testSortMultiFailures() {
 
         // null is not allowed
         try {
-            allTypes.sort(null, null);
+            allTypes.sort(null, (Sort[])null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -133,7 +134,7 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
         // Sorted Long (ascending), String (descending)
-        // Expected outout:
+        // Expected output:
         // (4, "Adam"), row index = 2
         // (4, "Brian"), row index = 1
         // (5, "Adam"), row index = 0 - stable sort!
@@ -269,7 +270,7 @@ public void testRealmSortMultiFailures() {
 
         // zero fields specified
         try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{}, new boolean[]{});
+            testRealm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -284,7 +285,7 @@ public void testRealmSortMultiFailures() {
 
         // null is not allowed
         try {
-            testRealm.allObjectsSorted(AllTypes.class, null, null);
+            testRealm.allObjectsSorted(AllTypes.class, null, (Sort[])null);
             fail();
         } catch (IllegalArgumentException ignored) {}
         try {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
new file mode 100644
index 0000000000..c07a560e32
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -0,0 +1,760 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.os.Looper;
+import android.util.Log;
+
+import org.junit.Assert;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.NullTypes;
+import io.realm.entities.StringOnly;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.log.Logger;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+
+public class TestHelper {
+
+    public static class ExpectedCountCallback implements RealmCache.Callback {
+
+        private int expectedCount;
+
+        ExpectedCountCallback(int expectedCount) {
+            this.expectedCount = expectedCount;
+        }
+
+        @Override
+        public void onResult(int count) {
+            assertEquals(expectedCount, count);
+        }
+    }
+
+    public static RealmFieldType getColumnType(Object o){
+        if (o instanceof Boolean)
+            return RealmFieldType.BOOLEAN;
+        if (o instanceof String)
+            return RealmFieldType.STRING;
+        if (o instanceof Long)
+            return RealmFieldType.INTEGER;
+        if (o instanceof Float)
+            return RealmFieldType.FLOAT;
+        if (o instanceof Double)
+            return RealmFieldType.DOUBLE;
+        if (o instanceof Date)
+            return RealmFieldType.DATE;
+        if (o instanceof byte[])
+            return RealmFieldType.BINARY;
+        return RealmFieldType.UNSUPPORTED_MIXED;
+    }
+
+    /**
+     * Creates an empty table with 1 column of all our supported column types, currently 9 columns
+     * @return
+     */
+    public static Table getTableWithAllColumnTypes(){
+        Table t = new Table();
+
+        t.addColumn(RealmFieldType.BINARY, "binary");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolean");
+        t.addColumn(RealmFieldType.DATE, "date");
+        t.addColumn(RealmFieldType.DOUBLE, "double");
+        t.addColumn(RealmFieldType.FLOAT, "float");
+        t.addColumn(RealmFieldType.INTEGER, "long");
+        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
+        t.addColumn(RealmFieldType.STRING, "string");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
+
+        return t;
+    }
+
+    public static String streamToString(InputStream in) throws IOException {
+        BufferedReader br = null;
+        StringBuilder sb = new StringBuilder();
+        String line;
+        try {
+            br = new BufferedReader(new InputStreamReader(in));
+            while ((line = br.readLine()) != null) {
+                sb.append(line);
+            }
+        } finally {
+            if (br != null) {
+                br.close();
+            }
+        }
+
+        return sb.toString();
+    }
+
+    public static InputStream stringToStream(String str) {
+        return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
+    }
+
+    // Creates a simple migration step in order to support null
+    // FIXME: generate a new encrypted.realm will null support
+    public static RealmMigration prepareMigrationToNullSupportStep() {
+        RealmMigration realmMigration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                Table stringOnly = realm.schema.getTable(StringOnly.class);
+                stringOnly.convertColumnToNullable(stringOnly.getColumnIndex("chars"));
+            }
+        };
+        return realmMigration;
+    }
+
+    // Returns a random key used by encrypted Realms.
+    public static byte[] getRandomKey() {
+        byte[] key = new byte[64];
+        new Random().nextBytes(key);
+        return key;
+    }
+
+    // Returns a random key from the given seed. Used by encrypted Realms.
+    public static byte[] getRandomKey(long seed) {
+        byte[] key = new byte[64];
+        new Random(seed).nextBytes(key);
+        return key;
+    }
+
+    /**
+     * Returns a Logger that will fail if it is asked to log a message above a certain level.
+     *
+     * @param failureLevel {@link Log} level from which the unit test will fail.
+     * @return Logger implementation
+     */
+    public static Logger getFailureLogger(final int failureLevel) {
+        return new Logger() {
+
+            private void failIfEqualOrAbove(int logLevel, int failureLevel) {
+                if (logLevel >= failureLevel) {
+                    fail("Message logged that was above valid level: " + logLevel + " >= " + failureLevel);
+                }
+            }
+
+            @Override
+            public void v(String message) {
+                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
+            }
+
+            @Override
+            public void v(String message, Throwable t) {
+                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
+            }
+
+            @Override
+            public void d(String message) {
+                failIfEqualOrAbove(Log.DEBUG, failureLevel);
+            }
+
+            @Override
+            public void d(String message, Throwable t) {
+                failIfEqualOrAbove(Log.DEBUG, failureLevel);
+            }
+
+            @Override
+            public void i(String message) {
+                failIfEqualOrAbove(Log.INFO, failureLevel);
+            }
+
+            @Override
+            public void i(String message, Throwable t) {
+                failIfEqualOrAbove(Log.INFO, failureLevel);
+            }
+
+            @Override
+            public void w(String message) {
+                failIfEqualOrAbove(Log.WARN, failureLevel);
+            }
+
+            @Override
+            public void w(String message, Throwable t) {
+                failIfEqualOrAbove(Log.WARN, failureLevel);
+            }
+
+            @Override
+            public void e(String message) {
+                failIfEqualOrAbove(Log.ERROR, failureLevel);
+            }
+
+            @Override
+            public void e(String message, Throwable t) {
+                failIfEqualOrAbove(Log.ERROR, failureLevel);
+            }
+        };
+    }
+
+    public static String getRandomString(int length) {
+        Random r = new Random();
+        StringBuilder sb = new StringBuilder(length);
+        for (int i = 0; i < length; i++) {
+            sb.append((char) r.nextInt(128)); // Restrict to standard ASCII chars.
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Returns a naive logger that can be used to test the values that are sent to the logger.
+     */
+    public static class TestLogger implements Logger {
+
+        public String message;
+        public Throwable throwable;
+
+        @Override
+        public void v(String message) {
+            this.message = message;
+        }
+
+        @Override
+        public void v(String message, Throwable t) {
+            this.message = message;
+            this.throwable = t;
+        }
+
+        @Override
+        public void d(String message) {
+            this.message = message;
+        }
+
+        @Override
+        public void d(String message, Throwable t) {
+            this.message = message;
+            this.throwable = t;
+        }
+
+        @Override
+        public void i(String message) {
+            this.message = message;
+        }
+
+        @Override
+        public void i(String message, Throwable t) {
+            this.message = message;
+            this.throwable = t;
+        }
+
+        @Override
+        public void w(String message) {
+            this.message = message;
+        }
+
+        @Override
+        public void w(String message, Throwable t) {
+            this.message = message;
+            this.throwable = t;
+        }
+
+        @Override
+        public void e(String message) {
+            this.message = message;
+        }
+
+        @Override
+        public void e(String message, Throwable t) {
+            this.message = message;
+            this.throwable = t;
+        }
+    }
+
+    public static class StubInputStream extends InputStream {
+        @Override
+        public int read() throws IOException {
+            return 0; // Stub implementation
+        }
+    }
+
+    // Alloc as much garbage as we can. Pass maxSize = 0 to use it.
+    public static byte[] allocGarbage(int garbageSize) {
+        if (garbageSize == 0) {
+            long maxMemory = Runtime.getRuntime().maxMemory();
+            long totalMemory = Runtime.getRuntime().totalMemory();
+            garbageSize = (int)(maxMemory - totalMemory)/10*9;
+        }
+        byte garbage[] = new byte[0];
+        try {
+            if (garbageSize > 0) {
+                garbage = new byte[garbageSize];
+                garbage[0] = 1;
+                garbage[garbage.length - 1] = 1;
+            }
+        } catch (OutOfMemoryError oom) {
+            return allocGarbage(garbageSize/10*9);
+        }
+
+        return garbage;
+    }
+
+    // Creates SHA512 hash of a String. Can be used as password for encrypted Realms.
+    public static byte[] SHA512(String str) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-512");
+            md.update(str.getBytes("UTF-8"), 0, str.length());
+            return md.digest();
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        } catch (UnsupportedEncodingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * @deprecated Use {@link TestRealmConfigurationFactory#createConfiguration()} instead.
+     */
+    @Deprecated
+    public static RealmConfiguration createConfiguration(Context context) {
+        return createConfiguration(context, Realm.DEFAULT_REALM_NAME);
+    }
+
+    /**
+     * @deprecated Use {@link TestRealmConfigurationFactory#createConfiguration(String)} instead.
+     */
+    @Deprecated
+    public static RealmConfiguration createConfiguration(Context context, String name) {
+        return createConfiguration(context.getFilesDir(), name);
+    }
+
+    /**
+     * @deprecated Use {@link TestRealmConfigurationFactory#createConfiguration(String)} instead.
+     */
+    @Deprecated
+    public static RealmConfiguration createConfiguration(File folder, String name) {
+        return createConfiguration(folder, name, null);
+    }
+
+    /**
+     * @deprecated Use {@link TestRealmConfigurationFactory#createConfiguration(String, byte[])} instead.
+     */
+    @Deprecated
+    public static RealmConfiguration createConfiguration(Context context, String name, byte[] key) {
+        return createConfiguration(context.getFilesDir(), name, key);
+    }
+
+    /**
+     * @deprecated Use {@link TestRealmConfigurationFactory#createConfiguration(String, byte[])} instead.
+     */
+    @Deprecated
+    public static RealmConfiguration createConfiguration(File dir, String name, byte[] key) {
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder(dir).name(name);
+        if (key != null) {
+            config.encryptionKey(key);
+        }
+
+        return config.build();
+    }
+
+    public static void populateTestRealmForNullTests(Realm testRealm) {
+
+        // Create 3 NullTypes objects. The objects are self-referenced (link) in
+        // order to test link queries.
+        //
+        // +-+--------+------+---------+--------+--------------------+
+        // | | string | link | numeric | binary | numeric (not null) |
+        // +-+--------+------+---------+--------+--------------------+
+        // |0| Fish   |    0 |       1 |    {0} |                  1 |
+        // |1| null   | null |    null |   null |                  0 |
+        // |2| Horse  |    1 |       3 |  {1,2} |                  3 |
+        // +-+--------+------+---------+--------+--------------------+
+
+        // 1 String
+        String[] words = {"Fish", null, "Horse"};
+        // 2 Bytes
+        byte[][] binaries = {new byte[]{0}, null, new byte[]{1, 2}};
+        // 3 Boolean
+        Boolean[] booleans = {false, null, true};
+        // Numeric fields will be 1, 0/null, 3
+        // 10 Date
+        Date[] dates = {new Date(0), null, new Date(10000)};
+        NullTypes[] nullTypesArray = new NullTypes[3];
+
+        testRealm.beginTransaction();
+        for (int i = 0; i < words.length; i++) {
+            NullTypes nullTypes = new NullTypes();
+            nullTypes.setId(i + 1);
+            // 1 String
+            nullTypes.setFieldStringNull(words[i]);
+            if (words[i] != null) {
+                nullTypes.setFieldStringNotNull(words[i]);
+            }
+            // 2 Bytes
+            nullTypes.setFieldBytesNull(binaries[i]);
+            if (binaries[i] != null) {
+                nullTypes.setFieldBytesNotNull(binaries[i]);
+            }
+            // 3 Boolean
+            nullTypes.setFieldBooleanNull(booleans[i]);
+            if (booleans[i] != null) {
+                nullTypes.setFieldBooleanNotNull(booleans[i]);
+            }
+            if (i != 1) {
+                int n = i + 1;
+                // 4 Byte
+                nullTypes.setFieldByteNull((byte) n);
+                nullTypes.setFieldByteNotNull((byte) n);
+                // 5 Short
+                nullTypes.setFieldShortNull((short) n);
+                nullTypes.setFieldShortNotNull((short) n);
+                // 6 Integer
+                nullTypes.setFieldIntegerNull(n);
+                nullTypes.setFieldIntegerNotNull(n);
+                // 7 Long
+                nullTypes.setFieldLongNull((long) n);
+                nullTypes.setFieldLongNotNull((long) n);
+                // 8 Float
+                nullTypes.setFieldFloatNull((float) n);
+                nullTypes.setFieldFloatNotNull((float) n);
+                // 9 Double
+                nullTypes.setFieldDoubleNull((double) n);
+                nullTypes.setFieldDoubleNotNull((double) n);
+            }
+            // 10 Date
+            nullTypes.setFieldDateNull(dates[i]);
+            if (dates[i] != null) {
+                nullTypes.setFieldDateNotNull(dates[i]);
+            }
+
+            nullTypesArray[i] = testRealm.copyToRealm(nullTypes);
+        }
+        nullTypesArray[0].setFieldObjectNull(nullTypesArray[0]);
+        nullTypesArray[1].setFieldObjectNull(null);
+        nullTypesArray[2].setFieldObjectNull(nullTypesArray[1]);
+        testRealm.commitTransaction();
+    }
+
+    public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(3);
+        nullTypes1.setFieldFloatNull(4F);
+        nullTypes1.setFieldDoubleNull(5D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+        nullTypes2.setFieldIntegerNull(-1);
+        nullTypes2.setFieldFloatNull(-2F);
+        nullTypes2.setFieldDoubleNull(-3D);
+        nullTypes2.setFieldBooleanNull(false);
+        nullTypes2.setFieldStringNull("str");
+        nullTypes2.setFieldDateNull(new Date(-2000));
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+        nullTypes3.setFieldIntegerNull(4);
+        nullTypes3.setFieldFloatNull(5F);
+        nullTypes3.setFieldDoubleNull(6D);
+        nullTypes3.setFieldBooleanNull(false);
+        nullTypes3.setFieldStringNull("0");
+        nullTypes3.setFieldDateNull(new Date(0));
+
+        realm.beginTransaction();
+        realm.copyToRealm(nullTypes1);
+        realm.copyToRealm(nullTypes2);
+        realm.copyToRealm(nullTypes3);
+        realm.commitTransaction();
+    }
+
+    public static void populatePartialNullRowsForNumericTesting (Realm realm) {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(3);
+        nullTypes1.setFieldFloatNull(4F);
+        nullTypes1.setFieldDoubleNull(5D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+        nullTypes3.setFieldIntegerNull(4);
+        nullTypes3.setFieldFloatNull(5F);
+        nullTypes3.setFieldDoubleNull(6D);
+        nullTypes3.setFieldBooleanNull(false);
+        nullTypes3.setFieldStringNull("0");
+        nullTypes3.setFieldDateNull(new Date(0));
+
+        realm.beginTransaction();
+        realm.copyToRealm(nullTypes1);
+        realm.copyToRealm(nullTypes2);
+        realm.copyToRealm(nullTypes3);
+        realm.commitTransaction();
+    }
+
+    public static void populateAllNullRowsForNumericTesting(Realm realm) {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        realm.beginTransaction();
+        realm.copyToRealm(nullTypes1);
+        realm.copyToRealm(nullTypes2);
+        realm.commitTransaction();
+    }
+
+    // Helper function to create all columns except the given excluding field for NullTypes.
+    // The schema version will be set to 0.
+    public static void initNullTypesTableExcludes(DynamicRealm realm, String excludingField) {
+        realm.beginTransaction();
+
+        RealmObjectSchema nullTypesSchema = realm.getSchema().create(NullTypes.CLASS_NAME);
+        if (!excludingField.equals(NullTypes.FIELD_ID)) {
+            nullTypesSchema.addField(NullTypes.FIELD_ID, int.class, FieldAttribute.PRIMARY_KEY);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_STRING_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_STRING_NOT_NULL, String.class, FieldAttribute.REQUIRED);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_STRING_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_STRING_NULL, String.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BYTES_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BYTES_NOT_NULL, byte[].class, FieldAttribute.REQUIRED);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BYTES_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BYTES_NULL, byte[].class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BOOLEAN_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BOOLEAN_NOT_NULL, boolean.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BOOLEAN_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BOOLEAN_NULL, Boolean.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BYTE_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BYTE_NOT_NULL, byte.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_BYTE_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_BYTE_NULL, Byte.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_SHORT_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_SHORT_NOT_NULL, short.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_SHORT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_SHORT_NULL, Short.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_INTEGER_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_INTEGER_NOT_NULL, int.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_INTEGER_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_INTEGER_NULL, Integer.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_LONG_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_LONG_NOT_NULL, long.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_LONG_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_LONG_NULL, Long.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_FLOAT_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_FLOAT_NOT_NULL, float.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_FLOAT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_FLOAT_NULL, Float.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_DOUBLE_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_DOUBLE_NOT_NULL, double.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_DOUBLE_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_DOUBLE_NULL, Double.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_DATE_NOT_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_DATE_NOT_NULL, Date.class, FieldAttribute.REQUIRED);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_DATE_NULL)) {
+            nullTypesSchema.addField(NullTypes.FIELD_DATE_NULL, Date.class);
+        }
+        if (!excludingField.equals(NullTypes.FIELD_OBJECT_NULL)) {
+            nullTypesSchema.addRealmObjectField(NullTypes.FIELD_OBJECT_NULL, nullTypesSchema);
+        }
+
+        nullTypesSchema.addRealmListField(NullTypes.FIELD_LIST_NULL, nullTypesSchema);
+
+        realm.setVersion(0);
+        realm.commitTransaction();
+    }
+
+    public static void populateForMultiSort(Realm typedRealm) {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(typedRealm.getConfiguration());
+        populateForMultiSort(dynamicRealm);
+        dynamicRealm.close();
+        typedRealm.refresh();
+    }
+
+    public static void populateForMultiSort(DynamicRealm realm) {
+        realm.beginTransaction();
+        realm.clear(AllTypes.CLASS_NAME);
+        DynamicRealmObject object1 = realm.createObject(AllTypes.CLASS_NAME);
+        object1.setLong(AllTypes.FIELD_LONG, 5);
+        object1.setString(AllTypes.FIELD_STRING, "Adam");
+
+        DynamicRealmObject object2 = realm.createObject(AllTypes.CLASS_NAME);
+        object2.setLong(AllTypes.FIELD_LONG, 4);
+        object2.setString(AllTypes.FIELD_STRING, "Brian");
+
+        DynamicRealmObject object3 = realm.createObject(AllTypes.CLASS_NAME);
+        object3.setLong(AllTypes.FIELD_LONG, 4);
+        object3.setString(AllTypes.FIELD_STRING, "Adam");
+        realm.commitTransaction();
+    }
+
+
+    /*
+     * Fields order test for Chained or Multi-Arguments Distinct()
+     *
+     * The idea is to interweave different values in 2's multiplier and 3's multiplier in a way that
+     * the outcome is different if the order of distinct* operations alternates. More numbers of
+     * fields can be constructed with the combination of multipliers in prime numbers such as 2, 3,
+     * and 5.
+     *
+     * An example is illustrated below.
+     *
+     * Object      : O1| O2| O3| O4| O5| O6
+     * indexString : A | A | B | B | A | A
+     * indexLong   : 1 | 1 | 1 | 2 | 2 | 2
+     *
+     * @param realm a {@link Realm} instance.
+     * @param numberOfBlocks number of times set of unique objects should be created.
+     */
+    public static void populateForDistinctFieldsOrder(Realm realm, long numberOfBlocks) {
+        realm.beginTransaction();
+        for (int i = 0; i < numberOfBlocks; i++) {
+            for (int j = 0; j < 6; j++) {
+                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
+                obj.setIndexString((((j / 2) % 2) == 0) ? "A" : "B");
+                obj.setIndexLong((j < 3) ? 1 : 2);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    public static void awaitOrFail(CountDownLatch latch) {
+        awaitOrFail(latch, 7);
+    }
+
+    public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
+        try {
+            if (!latch.await(numberOfSeconds, TimeUnit.SECONDS)) {
+                fail("Test took longer than " + numberOfSeconds + " seconds");
+            }
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    // clean resource, shutdown the executor service & throw any background exception
+    public static void exitOrThrow(final ExecutorService executorService,
+                                   final CountDownLatch signalTestFinished,
+                                   final CountDownLatch signalClosedRealm,
+                                   final Looper[] looper,
+                                   final Throwable[] throwable) throws Throwable {
+
+        // wait for the signal indicating the test's use case is done
+        try {
+            // Even if this fails we want to try as hard as possible to cleanup. If we fail to close all resources
+            // properly, the `after()` method will most likely throw as well because it tries do delete any Realms
+            // used. Any exception in the `after()` code will mask the original error.
+            TestHelper.awaitOrFail(signalTestFinished);
+        } finally {
+            // close the executor
+            executorService.shutdownNow();
+            if (looper[0] != null) {
+                // failing to quit the looper will not execute the finally block responsible
+                // of closing the Realm
+                looper[0].quit();
+            }
+
+            // wait for the finally block to execute & close the Realm
+            TestHelper.awaitOrFail(signalClosedRealm);
+
+            if (throwable[0] != null) {
+                // throw any assertion errors happened in the background thread
+                throw throwable[0];
+            }
+        }
+    }
+
+    public static InputStream loadJsonFromAssets(Context context, String file) throws IOException {
+        AssetManager assetManager = context.getAssets();
+        return assetManager.open(file);
+    }
+
+    public static void quitLooperOrFail() {
+        Looper looper = Looper.myLooper();
+        if (looper != null) {
+            looper.quit();
+        } else {
+            Assert.fail();
+        }
+    }
+
+    /**
+     * Creates a {@link RealmResults} instance.
+     * This helper method is useful to create a mocked {@link RealmResults}.
+     *
+     * @param realm a {@link Realm} or a {@link DynamicRealm} instance.
+     * @param table a {@link Table} or a {@link io.realm.internal.TableView} instance.
+     * @param tableClass a Class of Table.
+     * @return a created {@link RealmResults} instance.
+     */
+    public static <T extends RealmObject> RealmResults<T> newRealmResults(
+            BaseRealm realm, TableOrView table, Class<T> tableClass) {
+        //noinspection TryWithIdenticalCatches
+        try {
+            final Constructor<RealmResults> c = RealmResults.class.getDeclaredConstructor(
+                    BaseRealm.class, TableOrView.class, Class.class);
+            c.setAccessible(true);
+            //noinspection unchecked
+            return c.newInstance(realm, table, tableClass);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException(e);
+        } catch (InstantiationException e) {
+            throw new RuntimeException(e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
new file mode 100644
index 0000000000..5b6b5a8c32
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -0,0 +1,1807 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Base64;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.Date;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.proxy.HandlerProxy;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.RealmBackgroundTask;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class TypeBasedNotificationsTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private AtomicInteger globalCommitInvocations;
+    private AtomicInteger typebasedCommitInvocations;
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getTargetContext();
+        globalCommitInvocations = new AtomicInteger(0);
+        typebasedCommitInvocations = new AtomicInteger(0);
+    }
+
+    // ****************************************************************************************** //
+    // UC 0.
+    // Callback should be notified if we create a RealmObject without the async mechanism
+    // ex: using (createObject, copyOrUpdate, createObjectFromJson etc.)
+    // ***************************************************************************************** //
+
+    //UC 0 using Realm.createObject
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createObject() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        final Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dog.getName());
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        realm.beginTransaction();
+        dog.setName("Akamaru");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createObject_dynamic_realm() {
+        final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            realm.close();
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        final DynamicRealmObject dog = realm.createObject("Dog");
+        realm.commitTransaction();
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dog.getString("name"));
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        realm.beginTransaction();
+        dog.setString("name", "Akamaru");
+        realm.commitTransaction();
+    }
+
+    //UC 0 using Realm.copyToRealm
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_copyToRealm() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        Dog akamaru = new Dog();
+        akamaru.setName("Akamaru");
+        final Dog dog = realm.copyToRealm(akamaru);
+        realm.commitTransaction();
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(8, dog.getAge());
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        realm.beginTransaction();
+        dog.setAge(8);
+        realm.commitTransaction();
+    }
+
+    //UC 0 using Realm.copyToRealmOrUpdate
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_copyToRealmOrUpdate() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+        obj.setId(1);
+        obj.setName("Foo");
+
+        realm.beginTransaction();
+        final PrimaryKeyAsLong primaryKeyAsLong = realm.copyToRealmOrUpdate(obj);
+        realm.commitTransaction();
+
+        primaryKeyAsLong.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(1, primaryKeyAsLong.getId());
+                assertEquals("Bar", primaryKeyAsLong.getName());
+                assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
+        obj2.setId(1);
+        obj2.setName("Bar");
+        realm.beginTransaction();
+        PrimaryKeyAsLong primaryKeyAsLong2 = realm.copyToRealmOrUpdate(obj2);
+        realm.commitTransaction();
+
+        assertEquals(primaryKeyAsLong, primaryKeyAsLong2);
+    }
+
+    //UC 0 using Realm.copyToRealmOrUpdate
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createObjectFromJson() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        try {
+            InputStream in = TestHelper.loadJsonFromAssets(InstrumentationRegistry.getTargetContext(), "all_simple_types.json");
+            realm.beginTransaction();
+            final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, in);
+            realm.commitTransaction();
+            in.close();
+
+            objectFromJson.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    assertEquals("ObjectFromJson", objectFromJson.getColumnString());
+                    assertEquals(1L, objectFromJson.getColumnLong());
+                    assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
+                    assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
+                    assertEquals(true, objectFromJson.isColumnBoolean());
+                    assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+
+            realm.beginTransaction();
+            objectFromJson.setColumnString("ObjectFromJson");
+            realm.commitTransaction();
+
+        } catch (IOException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    //UC 0 using Realm.copyToRealmOrUpdate
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        try {
+            JSONObject json = new JSONObject();
+            json.put("columnString", "String");
+            json.put("columnLong", 1L);
+            json.put("columnFloat", 1.23f);
+            json.put("columnDouble", 1.23d);
+            json.put("columnBoolean", true);
+            json.put("columnBinary", new String(Base64.encode(new byte[]{1, 2, 3}, Base64.DEFAULT)));
+
+            realm.beginTransaction();
+            final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
+            realm.commitTransaction();
+
+            objectFromJson.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    assertEquals("ObjectFromJson", objectFromJson.getColumnString());
+                    assertEquals(1L, objectFromJson.getColumnLong());
+                    assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
+                    assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
+                    assertEquals(true, objectFromJson.isColumnBoolean());
+                    assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+
+            realm.beginTransaction();
+            objectFromJson.setColumnString("ObjectFromJson");
+            realm.commitTransaction();
+
+        } catch (JSONException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    //UC 0 using Realm.createOrUpdateObjectFromJson
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (globalCommitInvocations.incrementAndGet() == 1) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        try {
+            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+            Date date = new Date(0);
+            // ID
+            obj.setColumnLong(1);
+            obj.setColumnBinary(new byte[]{1});
+            obj.setColumnBoolean(true);
+            obj.setColumnDate(date);
+            obj.setColumnDouble(1);
+            obj.setColumnFloat(1);
+            obj.setColumnString("1");
+            realm.beginTransaction();
+            realm.copyToRealm(obj);
+            realm.commitTransaction();
+
+            InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_primary_key_field_only.json");
+            realm.beginTransaction();
+            final AllTypesPrimaryKey objectFromJson = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
+            realm.commitTransaction();
+            in.close();
+
+            objectFromJson.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    assertEquals("ObjectFromJson", objectFromJson.getColumnString());
+                    assertEquals(1L, objectFromJson.getColumnLong());
+                    assertEquals(1F, objectFromJson.getColumnFloat(), 0F);
+                    assertEquals(1D, objectFromJson.getColumnDouble(), 0D);
+                    assertEquals(true, objectFromJson.isColumnBoolean());
+                    assertArrayEquals(new byte[]{1}, objectFromJson.getColumnBinary());
+                    assertNull(objectFromJson.getColumnRealmObject());
+                    assertEquals(0, objectFromJson.getColumnRealmList().size());
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+
+            realm.beginTransaction();
+            objectFromJson.setColumnString("ObjectFromJson");
+            realm.commitTransaction();
+
+        } catch (IOException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    //UC 0 using Realm.copyToRealmOrUpdate
+    @Test
+    @RunTestInLooperThread
+    public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONObject() throws JSONException {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                realm.handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(1, typebasedCommitInvocations.get());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        });
+
+        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+        obj.setColumnLong(1);
+        obj.setColumnString("Foo");
+
+        realm.beginTransaction();
+        realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+
+        JSONObject json = new JSONObject();
+        json.put("columnLong", 1);
+        json.put("columnString", "bar");
+
+        realm.beginTransaction();
+        final AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
+        realm.commitTransaction();
+
+        newObj.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+                assertEquals("bar", newObj.getColumnString());
+                assertTrue(newObj.getColumnBoxedBoolean());
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        realm.beginTransaction();
+        newObj.setColumnBoxedBoolean(Boolean.TRUE);
+        realm.commitTransaction();
+    }
+
+    // ********************************************************************************* //
+    // UC 1.
+    // Callback should be invoked after a relevant commit (one that should impact the
+    // query from which we obtained our RealmObject or RealmResults)
+    // ********************************************************************************* //
+    // UC 1 for Sync RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_realmobject_sync() {
+        final Realm realm = looperThread.realm;
+
+        // Step 1: Trigger global Realm change listener
+        realm.beginTransaction();
+        final Dog akamaru = realm.createObject(Dog.class);
+        akamaru.setName("Akamaru");
+        realm.commitTransaction();
+
+        final Dog dog = realm.where(Dog.class).findFirst();
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 4: Respond to relevant change
+                typebasedCommitInvocations.incrementAndGet();
+                assertEquals("Akamaru", dog.getName());
+                assertEquals(17, dog.getAge());
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                int commits = globalCommitInvocations.incrementAndGet();
+                switch (commits) {
+                    case 1:
+                        // Step 2: Trigger non-related commit
+                        realm.beginTransaction();
+                        realm.commitTransaction();
+                        break;
+
+                    case 2:
+                        // Step 3: Trigger related commit
+                        realm.beginTransaction();
+                        akamaru.setAge(17);
+                        realm.commitTransaction();
+                        break;
+
+                    case 3:
+                        // Step 5: Complete test
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(1, typebasedCommitInvocations.get());
+                                looperThread.testComplete();
+                            }
+                        });
+
+                }
+            }
+        });
+    }
+
+    // UC 1 Async RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_realmobject_async() {
+        final Realm realm = looperThread.realm;
+
+        // Step 1: Trigger global Realm change listener
+        realm.beginTransaction();
+        final Dog akamaru = realm.createObject(Dog.class);
+        akamaru.setName("Akamaru");
+        realm.commitTransaction();
+
+        final Dog dog = realm.where(Dog.class).findFirstAsync();
+        assertTrue(dog.load());
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (typebasedCommitInvocations.incrementAndGet()) {
+                    case 1:
+                        assertEquals("Akamaru", dog.getName());
+                        assertEquals(0, dog.getAge());
+                        break;
+
+                    case 2:
+                        // Step 4: Respond to relevant change
+                        assertEquals(17, dog.getAge());
+                        break;
+                }
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                int commits = globalCommitInvocations.incrementAndGet();
+                switch (commits) {
+                    case 1:
+                        // Step 2: Trigger non-related commit
+                        realm.beginTransaction();
+                        realm.commitTransaction();
+                        break;
+
+                    case 2:
+                        // Step 3: Trigger related commit
+                        realm.beginTransaction();
+                        akamaru.setAge(17);
+                        realm.commitTransaction();
+                        break;
+
+                    case 3:
+                        // Step 5: Complete test
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(3, globalCommitInvocations.get());
+                                assertEquals(2, typebasedCommitInvocations.get());
+                                looperThread.testComplete();
+                            }
+                        });
+
+                }
+            }
+        });
+    }
+
+    // UC 1 Async RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_from_different_looper_realmobject_async() {
+        final CountDownLatch looperThread1Done = new CountDownLatch(1);
+        final CountDownLatch looperThread2Done = new CountDownLatch(1);
+        final CountDownLatch looperThread3Done = new CountDownLatch(1);
+        final HandlerThread looperThread1 = new HandlerThread("looperThread1");
+        final HandlerThread looperThread2 = new HandlerThread("looperThread2");
+        final HandlerThread looperThread3 = new HandlerThread("looperThread3");
+        looperThread1.start();
+        looperThread2.start();
+        looperThread3.start();
+        final Handler looperHandler1 = new Handler(looperThread1.getLooper());
+        final Handler looperHandler2 = new Handler(looperThread2.getLooper());
+        final Handler looperHandler3 = new Handler(looperThread3.getLooper());
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                globalCommitInvocations.incrementAndGet();
+            }
+        });
+
+        final Dog dog = realm.where(Dog.class).findFirstAsync();
+        assertTrue(dog.load());
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (typebasedCommitInvocations.incrementAndGet()) {
+                    case 1: // triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load()
+                        assertTrue(dog.isLoaded());
+                        assertFalse(dog.isValid());
+
+                        looperHandler1.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                Realm realmLooperThread1 = Realm.getInstance(realm.getConfiguration());
+                                realmLooperThread1.beginTransaction();
+                                realmLooperThread1.commitTransaction();
+                                realmLooperThread1.close();
+                                looperThread1Done.countDown();
+                            }
+                        });
+                        break;
+                    case 2: // triggered by the irrelevant commit (not affecting Dog table) from LooperThread1
+                        assertTrue(dog.isLoaded());
+                        assertFalse(dog.isValid());
+
+                        looperHandler2.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                Realm realmLooperThread2 = Realm.getInstance(realm.getConfiguration());
+                                // trigger first callback invocation
+                                realmLooperThread2.beginTransaction();
+                                Dog dog = realmLooperThread2.createObject(Dog.class);
+                                dog.setName("Akamaru");
+                                realmLooperThread2.commitTransaction();
+                                realmLooperThread2.close();
+                                looperThread2Done.countDown();
+                            }
+                        });
+                        break;
+
+                    case 3: // triggered by relevant commit from LooperThread2
+                        assertEquals("Akamaru", dog.getName());
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                // trigger second callback invocation
+                                looperHandler3.post(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        Realm realmLooperThread3 = Realm.getInstance(realm.getConfiguration());
+                                        realmLooperThread3.beginTransaction();
+                                        realmLooperThread3.where(Dog.class).findFirst().setAge(17);
+                                        realmLooperThread3.commitTransaction();
+                                        realmLooperThread3.close();
+                                        looperThread3Done.countDown();
+                                    }
+                                });
+                            }
+                        });
+                        break;
+                    case 4:
+                        assertEquals("Akamaru", dog.getName());
+                        assertEquals(17, dog.getAge());
+                        // posting as an event will give the handler a chance
+                        // to deliver the notification for globalCommitInvocations
+                        // otherwise, test will exit before the callback get a chance to be invoked
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(3, globalCommitInvocations.get());
+                                assertEquals(4, typebasedCommitInvocations.get());
+                                looperThread1.quit();
+                                looperThread2.quit();
+                                looperThread3.quit();
+                                TestHelper.awaitOrFail(looperThread1Done);
+                                TestHelper.awaitOrFail(looperThread2Done);
+                                TestHelper.awaitOrFail(looperThread3Done);
+                                looperThread.testComplete();
+                            }
+                        });
+                        break;
+                }
+            }
+        });
+
+    }
+
+    // UC 1 Async RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_from_different_non_looper_realmobject_async() throws Throwable {
+        final CountDownLatch nonLooperThread3CloseLatch = new CountDownLatch(1);
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                globalCommitInvocations.incrementAndGet();
+            }
+        });
+
+        final Dog dog = realm.where(Dog.class).findFirstAsync();
+        assertTrue(dog.load());
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                switch (typebasedCommitInvocations.incrementAndGet()) {
+                    case 1:  // triggered by COMPLETED_ASYNC_REALM_OBJECT
+                        new RealmBackgroundTask(realm.configuration) {
+                            @Override
+                            protected void doInBackground(Realm realm) {
+                                realm.beginTransaction();
+                                realm.commitTransaction();
+                            }
+                        }.awaitOrFail();
+                        break;
+
+                    case 2: {// triggered by the irrelevant commit (not affecting Dog table)
+                        assertTrue(dog.isLoaded());
+                        assertFalse(dog.isValid());
+                        new RealmBackgroundTask(realm.configuration) {
+                            @Override
+                            protected void doInBackground(Realm realm) {
+                                realm.beginTransaction();
+                                realm.createObject(Dog.class).setName("Akamaru");
+                                realm.commitTransaction();
+
+                            }
+                        }.awaitOrFail();
+                        break;
+                    }
+                    case 3: {
+                        assertEquals("Akamaru", dog.getName());
+                        realm.handler.postDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                // trigger second callback invocation
+                                new Thread() {
+                                    @Override
+                                    public void run() {
+                                        Realm realmNonLooperThread3 = Realm.getInstance(realm.getConfiguration());
+                                        realmNonLooperThread3.beginTransaction();
+                                        realmNonLooperThread3.where(Dog.class).findFirst().setAge(17);
+                                        realmNonLooperThread3.commitTransaction();
+                                        realmNonLooperThread3.close();
+                                        nonLooperThread3CloseLatch.countDown();
+                                    }
+                                }.start();
+                            }
+                        }, TimeUnit.SECONDS.toMillis(0));
+                        break;
+                    }
+                    case 4: {
+                        assertEquals("Akamaru", dog.getName());
+                        assertEquals(17, dog.getAge());
+                        // posting as an event will give the handler a chance
+                        // to deliver the notification for globalCommitInvocations
+                        // otherwise, test will exit before the callback get a chance to be invoked
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(3, globalCommitInvocations.get());
+                                assertEquals(4, typebasedCommitInvocations.get());
+                                TestHelper.awaitOrFail(nonLooperThread3CloseLatch);
+                                looperThread.testComplete();
+                            }
+                        });
+                        break;
+                    }
+                }
+            }
+        });
+    }
+
+    // UC 1 Sync RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_realmresults_sync() {
+        final Realm realm = looperThread.realm;
+
+        // Step 1: Trigger global Realm change listener
+        realm.beginTransaction();
+        final Dog akamaru = realm.createObject(Dog.class);
+        akamaru.setName("Akamaru");
+        realm.commitTransaction();
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 4: Respond to relevant change
+                typebasedCommitInvocations.incrementAndGet();
+                assertEquals(1, dogs.size());
+                assertEquals("Akamaru", dogs.get(0).getName());
+                assertEquals(17, dogs.get(0).getAge());
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                int commits = globalCommitInvocations.incrementAndGet();
+                switch (commits) {
+                    case 1:
+                        // Step 2: Trigger non-related commit
+                        realm.beginTransaction();
+                        realm.commitTransaction();
+                        break;
+
+                    case 2:
+                        // Step 3: Trigger related commit
+                        realm.beginTransaction();
+                        akamaru.setAge(17);
+                        realm.commitTransaction();
+                        break;
+
+                    case 3:
+                        // Step 5: Complete test
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(1, typebasedCommitInvocations.get());
+                                looperThread.testComplete();
+                            }
+                        });
+
+                }
+            }
+        });
+    }
+
+    // UC 1 Async RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void callback_with_relevant_commit_realmresults_async() {
+        final Realm realm = looperThread.realm;
+
+        // Step 1: Trigger global Realm change listener
+        realm.beginTransaction();
+        final Dog akamaru = realm.createObject(Dog.class);
+        akamaru.setName("Akamaru");
+        realm.commitTransaction();
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        assertTrue(dogs.load());
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Step 4: Respond to relevant change
+                int commits = typebasedCommitInvocations.incrementAndGet();
+                switch (commits) {
+                    case 2:
+                        assertEquals(17, dogs.get(0).getAge());
+                    case 1:
+                        assertEquals(1, dogs.size());
+                        assertEquals("Akamaru", dogs.get(0).getName());
+
+                }
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                int commits = globalCommitInvocations.incrementAndGet();
+                switch (commits) {
+                    case 1:
+                        // Step 2: Trigger non-related commit
+                        realm.beginTransaction();
+                        realm.commitTransaction();
+                        break;
+
+                    case 2:
+                        // Step 3: Trigger related commit
+                        realm.beginTransaction();
+                        akamaru.setAge(17);
+                        realm.commitTransaction();
+                        break;
+
+                    case 3:
+                        // Step 5: Complete test
+                        realm.handler.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertEquals(2, typebasedCommitInvocations.get());
+                                looperThread.testComplete();
+                            }
+                        });
+
+                }
+            }
+        });
+    }
+
+    // ********************************************************************************* //
+    // UC 2.
+    // Multiple callbacks should be invoked after a relevant commit
+    // ********************************************************************************* //
+    // UC 2 for Sync RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void multiple_callbacks_should_be_invoked_realmobject_sync() {
+        final int NUMBER_OF_LISTENERS = 7;
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                realm.handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        });
+
+        realm.beginTransaction();
+        Dog akamaru = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        Dog dog = realm.where(Dog.class).findFirst();
+        for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
+            dog.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+        }
+
+        realm.beginTransaction();
+        akamaru.setAge(17);
+        realm.commitTransaction();
+    }
+
+    // UC 2 Async RealmObject
+    @Test
+    @RunTestInLooperThread
+    public void multiple_callbacks_should_be_invoked_realmobject_async() {
+        final int NUMBER_OF_LISTENERS = 7;
+        final Realm realm = looperThread.realm;
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                realm.handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        };
+
+        realm.addChangeListener(listener);
+
+        realm.beginTransaction();
+        Dog akamaru = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        Dog dog = realm.where(Dog.class).findFirstAsync();
+        assertTrue(dog.load());
+        for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
+            dog.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+        }
+
+        realm.beginTransaction();
+        akamaru.setAge(17);
+        realm.commitTransaction();
+    }
+
+    // UC 2 Sync RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void multiple_callbacks_should_be_invoked_realmresults_sync() {
+        final int NUMBER_OF_LISTENERS = 7;
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                realm.handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        });
+
+        realm.beginTransaction();
+        Dog akamaru = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
+            dogs.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+        }
+
+        realm.beginTransaction();
+        akamaru.setAge(17);
+        realm.commitTransaction();
+    }
+
+    // UC 2 Async RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void multiple_callbacks_should_be_invoked_realmresults_async() {
+        final int NUMBER_OF_LISTENERS = 7;
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                realm.handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+        });
+
+        realm.beginTransaction();
+        Dog akamaru = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        assertTrue(dogs.load());
+
+        for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
+            dogs.addChangeListener(new RealmChangeListener() {
+                @Override
+                public void onChange() {
+                    typebasedCommitInvocations.incrementAndGet();
+                }
+            });
+        }
+
+        realm.beginTransaction();
+        akamaru.setAge(17);
+        realm.commitTransaction();
+    }
+
+    // ********************************************************************************* //
+    // UC 3.
+    // Callback should be invoked when a non Looper thread commits
+    // ********************************************************************************* //
+
+    // UC 3 for Sync RealmObject
+    // 1. Add listener to RealmObject which is queried synchronized.
+    // 2. Commit transaction in another non-looper thread
+    // 3. Listener on the RealmObject gets triggered.
+    @Test
+    @RunTestInLooperThread
+    public void non_looper_thread_commit_realmobject_sync() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(Dog.class).count() == 2) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(1, typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        Dog dog = realm.where(Dog.class).findFirst();
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                typebasedCommitInvocations.incrementAndGet();
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(Dog.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    // UC 3 Async RealmObject
+    // 1. Create RealmObject async query
+    // 2. Wait COMPLETED_ASYNC_REALM_OBJECT then commit transaction in another non-looper thread
+    // 3. Listener on the RealmObject gets triggered again.
+    @Test
+    @RunTestInLooperThread
+    public void non_looper_thread_commit_realmobject_async() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Check if the 2nd transaction is committed.
+                if (realm.where(Dog.class).count() == 2) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(2,typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        final Thread thread = new Thread() {
+            @Override
+            public void run() {
+                if (typebasedCommitInvocations.get() != 1) {
+                    try {
+                        Thread.sleep(200);
+                    } catch (InterruptedException e) {
+                        fail(e.getMessage());
+                    }
+                }
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(Dog.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+
+        Dog dog = realm.where(Dog.class).findFirstAsync();
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                typebasedCommitInvocations.incrementAndGet();
+
+                if (typebasedCommitInvocations.get() == 1) {
+                    try {
+                        thread.join();
+                    } catch (InterruptedException e) {
+                        fail(e.getMessage());
+                    }
+                }
+            }
+        });
+
+        thread.start();
+    }
+
+    // UC 3 Sync RealmResults
+    // 1. Add listener to RealmResults which is queried synchronized.
+    // 2. Commit transaction in another non-looper thread
+    // 3. Listener on the RealmResults gets triggered.
+    @Test
+    @RunTestInLooperThread
+    public void non_looper_thread_commit_realmresults_sync() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(Dog.class).count() == 2) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(typebasedCommitInvocations.get(),1);
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                typebasedCommitInvocations.incrementAndGet();
+                assertEquals(2, dogs.size());
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(Dog.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    // UC 3 Async RealmResults
+    // 1. Create RealmResults async query
+    // 2. Wait COMPLETED_ASYNC_REALM_RESULTS then commit transaction in another non-looper thread
+    // 3. Listener on the RealmResults gets triggered again.
+    @Test
+    @RunTestInLooperThread
+    public void non_looper_thread_commit_realmresults_async() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (realm.where(Dog.class).count() == 2) {
+                    realm.handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            assertEquals(2,typebasedCommitInvocations.get());
+                            looperThread.testComplete();
+                        }
+                    });
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        final Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(Dog.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                typebasedCommitInvocations.incrementAndGet();
+                if (typebasedCommitInvocations.get() == 1) {
+                    // COMPLETED_ASYNC_REALM_RESULTS arrived
+                    thread.start();
+                    try {
+                        thread.join();
+                    } catch (InterruptedException e) {
+                        fail(e.getMessage());
+                    }
+                }
+            }
+        });
+    }
+
+    // ****************************************************************************************** //
+    // UC 4.
+    // Callback should throw if registered on a non Looper thread.
+    // no tests for async RealmObject & RealmResults, since those already require a Looper thread
+    // ***************************************************************************************** //
+
+    // UC 4 for Realm
+    @Test
+    public void should_throw_on_non_looper_thread_realm() {
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(configFactory.createConfiguration());
+                try {
+                    bgRealm.beginTransaction();
+                    bgRealm.createObject(Dog.class);
+                    bgRealm.commitTransaction();
+
+                    bgRealm.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            fail("Callback should not be registered and invoked on a non-Looper thread");
+                        }
+                    });
+                    fail("Callback should not be registered and invoked on a non-Looper thread");
+                } catch (IllegalStateException ignored) {
+
+                } finally {
+                    bgRealm.close();
+                    signalTestFinished.countDown();
+                }
+            }
+        }.start();
+        TestHelper.awaitOrFail(signalTestFinished);
+    }
+
+    // UC 4 for RealmObject
+    @Test
+    public void should_throw_on_non_looper_thread_realmobject() {
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(configFactory.createConfiguration());
+                try {
+                    bgRealm.beginTransaction();
+                    bgRealm.createObject(Dog.class);
+                    bgRealm.commitTransaction();
+
+                    Dog dog = bgRealm.where(Dog.class).findFirst();
+                    dog.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            fail("Callback should not be registered and invoked on a non-Looper thread");
+                        }
+                    });
+                    fail("Callback should not be registered and invoked on a non-Looper thread");
+                } catch (IllegalStateException ignored) {
+
+                } finally {
+                    bgRealm.close();
+                    signalTestFinished.countDown();
+                }
+            }
+        }.start();
+        TestHelper.awaitOrFail(signalTestFinished);
+    }
+
+    // UC 4 RealmObject
+    @Test
+    public void should_throw_on_non_looper_thread_realmresults() {
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(configFactory.createConfiguration());
+                try {
+                    bgRealm.beginTransaction();
+                    bgRealm.createObject(Dog.class);
+                    bgRealm.commitTransaction();
+
+                    RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
+                    dogs.addChangeListener(new RealmChangeListener() {
+                        @Override
+                        public void onChange() {
+                            fail("Callback should not be registered and invoked on a non-Looper thread");
+                        }
+                    });
+                    fail("Callback should not be registered and invoked on a non-Looper thread");
+                } catch (IllegalStateException ignored) {
+
+                } finally {
+                    bgRealm.close();
+                    signalTestFinished.countDown();
+                }
+            }
+        }.start();
+        TestHelper.awaitOrFail(signalTestFinished);
+    }
+
+    // ****************************************************************************************** //
+    // UC 5.
+    // Callback should be notified if we call refresh (even without getting the REALM_CHANGE yet)
+    // ***************************************************************************************** //
+    @Test
+    @RunTestInLooperThread
+    public void refresh_should_notify_callbacks_realmobject_sync() {
+        final Realm realm = looperThread.realm;
+        // Swallow all REALM_CHANGED events to test the behaviour of refresh
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        realm.beginTransaction();
+        realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        final Dog dog = realm.where(Dog.class).findFirst();
+        assertNull(dog.getName());
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dog.getName());
+                looperThread.testComplete();
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                bgRealm.beginTransaction();
+                bgRealm.where(Dog.class).findFirst().setName("Akamaru");
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+
+        realm.refresh();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void refresh_should_notify_callbacks_realmobject_async() {
+        final Realm realm = looperThread.realm;
+        // Swallow all REALM_CHANGED events to test the behaviour of refresh
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        final Dog dog = realm.where(Dog.class).findFirstAsync();
+        assertTrue(dog.load());
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dog.getName());
+                looperThread.testComplete();
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                bgRealm.beginTransaction();
+                Dog akamaru = bgRealm.createObject(Dog.class);
+                akamaru.setName("Akamaru");
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+
+        realm.refresh();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void refresh_should_notify_callbacks_realmresults_sync() {
+        final Realm realm = looperThread.realm;
+        // Swallow all REALM_CHANGED events to test the behaviour of refresh
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dogs.get(0).getName());
+                looperThread.testComplete();
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                bgRealm.beginTransaction();
+                Dog akamaru = bgRealm.createObject(Dog.class);
+                akamaru.setName("Akamaru");
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+
+        realm.refresh();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void refresh_should_notify_callbacks_realmresults_async() {
+        final Realm realm = looperThread.realm;
+        // Swallow all REALM_CHANGED events to test the behaviour of refresh
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        assertTrue(dogs.load());
+
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                assertEquals("Akamaru", dogs.get(0).getName());
+                looperThread.testComplete();
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                bgRealm.beginTransaction();
+                Dog akamaru = bgRealm.createObject(Dog.class);
+                akamaru.setName("Akamaru");
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+
+        realm.refresh();
+    }
+
+    // mixed async RealmObject & RealmResults
+    @Test
+    @RunTestInLooperThread
+    public void refresh_should_notify_callbacks_mixed() {
+        final CountDownLatch listenerWasCalledOnRealmObject = new CountDownLatch(1);
+        final CountDownLatch listenerWasCalledOnRealmResults = new CountDownLatch(1);
+
+        final Realm realm = looperThread.realm;
+        // Swallow all REALM_CHANGED events to test the behaviour of an explicit refresh
+        final Handler handler = new HandlerProxy(realm.handlerController) {
+            @Override
+            public boolean onInterceptInMessage(int what) {
+                switch (what) {
+                    case HandlerController.REALM_CHANGED: {
+                        return true;
+                    }
+                }
+                return false;
+            }
+        };
+        realm.setHandler(handler);
+
+        Dog dog = realm.where(Dog.class).findFirstAsync();
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+
+        assertTrue(dog.load());
+        assertTrue(dogs.load());
+
+        dog.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenerWasCalledOnRealmObject.countDown();
+                if (listenerWasCalledOnRealmObject.getCount() == 0 && listenerWasCalledOnRealmResults.getCount() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                listenerWasCalledOnRealmResults.countDown();
+                if (listenerWasCalledOnRealmObject.getCount() == 0 && listenerWasCalledOnRealmResults.getCount() == 0) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
+                bgRealm.beginTransaction();
+                Dog akamaru = bgRealm.createObject(Dog.class);
+                akamaru.setName("Akamaru");
+                bgRealm.commitTransaction();
+                bgRealm.close();
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail(e.getMessage());
+        }
+
+        realm.refresh();
+    }
+
+    // Test modifying realmObjects in RealmObject's change listener
+    @Test
+    @RunTestInLooperThread
+    public void change_realm_objects_map_in_listener() throws InterruptedException {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        // At least two objects are needed to make sure list modification happen during iterating.
+        final Cat cat = realm.createObject(Cat.class);
+        final Owner owner = realm.createObject(Owner.class);
+        owner.setCat(cat);
+        realm.commitTransaction();
+
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                Cat cat = owner.getCat();
+                boolean foundKey = false;
+                // Check if cat has been added to the realmObjects in case of the behaviour of getCat changes
+                for (WeakReference<RealmObject> weakReference : realm.handlerController.realmObjects.keySet()) {
+                    if (weakReference.get() == cat) {
+                        foundKey = true;
+                        break;
+                    }
+                }
+                assertTrue(foundKey);
+                looperThread.testComplete();
+            }
+        };
+
+        cat.addChangeListener(listener);
+        owner.addChangeListener(listener);
+
+        realm.beginTransaction();
+        // To make sure the shared group version changed
+        realm.createObject(Owner.class);
+        realm.commitTransaction();
+    }
+
+    // Test modifying syncRealmResults in RealmResults's change listener
+    @Test
+    @RunTestInLooperThread
+    public void change_realm_results_map_in_listener() throws InterruptedException {
+        final CountDownLatch finishedLatch = new CountDownLatch(2);
+
+        final Realm realm = looperThread.realm;
+        // Two results needed to make sure list modification happen while iterating
+        RealmResults<Owner> results1 = realm.allObjects(Owner.class);
+        RealmResults<Cat> results2 = realm.allObjects(Cat.class);
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                RealmResults<Owner> results = realm.allObjects(Owner.class);
+                boolean foundKey = false;
+                // Check if the results has been added to the syncRealmResults in case of the behaviour of
+                // allObjects changes
+                for (WeakReference<RealmResults<? extends RealmObject>> weakReference :
+                        realm.handlerController.syncRealmResults.keySet()) {
+                    if (weakReference.get() == results) {
+                        foundKey = true;
+                        break;
+                    }
+                }
+                assertTrue(foundKey);
+                looperThread.testComplete();
+                finishedLatch.countDown();
+            }
+        };
+        results1.addChangeListener(listener);
+        results2.addChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(Owner.class);
+        realm.commitTransaction();
+    }
+
+    // Build a RealmResults from a RealmList, and delete the RealmList. Test the behavior of ChangeListener on the
+// "invalid" RealmResults.
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_onResultsBuiltOnDeletedLinkView() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        for (int i = 0; i < 10; i++) {
+            Dog dog = new Dog();
+            dog.setName("name_" + i);
+            allTypes.getColumnRealmList().add(dog);
+        }
+        realm.commitTransaction();
+
+        final RealmResults<Dog> dogs =
+                allTypes.getColumnRealmList().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
+        dogs.addChangeListener(new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                if (typebasedCommitInvocations.getAndIncrement() == 0) {
+                    assertTrue(dogs.isValid());
+                    assertEquals(0, dogs.size());
+                } else {
+                    fail("This listener should only be called once.");
+                }
+            }
+        });
+
+        // Trigger the listener at the first time.
+        realm.beginTransaction();
+        allTypes.removeFromRealm();
+        realm.commitTransaction();
+
+        // Try to trigger the listener second time.
+        realm.beginTransaction();
+        realm.commitTransaction();
+
+        // Close the realm and finish the test. This needs to follow the REALM_CHANGED in the queue.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                realm.close();
+                assertEquals(1,typebasedCommitInvocations.get());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
new file mode 100644
index 0000000000..79ef9063ff
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+
+public class AllJavaTypes extends RealmObject{
+
+    public static final String CLASS_NAME = "AllJavaTypes";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+    public static final String   INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
+    public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_OBJECT + "." + FIELD_BINARY, FIELD_OBJECT + "." + FIELD_OBJECT, FIELD_OBJECT + "." + FIELD_LIST};
+
+    @Ignore private String fieldIgnored;
+    @Index private String fieldString;
+    private short fieldShort;
+    private int fieldInt;
+    @PrimaryKey private long fieldLong;
+    private byte fieldByte;
+    private float fieldFloat;
+    private double fieldDouble;
+    private boolean fieldBoolean;
+    private Date fieldDate;
+    private byte[] fieldBinary;
+    private AllJavaTypes fieldObject;
+    private RealmList<AllJavaTypes> fieldList;
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public AllJavaTypes getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(AllJavaTypes columnRealmObject) {
+        this.fieldObject = columnRealmObject;
+    }
+
+    public RealmList<AllJavaTypes> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<AllJavaTypes> columnRealmList) {
+        this.fieldList = columnRealmList;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
similarity index 72%
rename from realm/src/androidTest/java/io/realm/entities/AllTypes.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
index 8eaf25c60f..7d4fbba7b5 100644
--- a/realm/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -20,15 +20,33 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.annotations.Required;
 
 public class AllTypes extends RealmObject {
-    private String columnString;
+
+    public static final String CLASS_NAME = "AllTypes";
+    public static final String FIELD_STRING = "columnString";
+    public static final String FIELD_LONG = "columnLong";
+    public static final String FIELD_FLOAT = "columnFloat";
+    public static final String FIELD_DOUBLE = "columnDouble";
+    public static final String FIELD_BOOLEAN = "columnBoolean";
+    public static final String FIELD_DATE = "columnDate";
+    public static final String FIELD_BINARY = "columnBinary";
+    public static final String FIELD_REALMOBJECT = "columnRealmObject";
+    public static final String FIELD_REALMLIST = "columnRealmList";
+
+    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
+
+    @Required
+    private String columnString = "";
     private long columnLong;
     private float columnFloat;
     private double columnDouble;
     private boolean columnBoolean;
-    private Date columnDate;
-    private byte[] columnBinary;
+    @Required
+    private Date columnDate = new Date(0);
+    @Required
+    private byte[] columnBinary = new byte[0];
     private Dog columnRealmObject;
     private RealmList<Dog> columnRealmList;
 
diff --git a/realm/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
similarity index 91%
rename from realm/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
index 20c3ee8ac7..5965b6d031 100644
--- a/realm/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
@@ -33,6 +33,7 @@
     private byte[] columnBinary;
     private DogPrimaryKey columnRealmObject;
     private RealmList<DogPrimaryKey> columnRealmList;
+    private Boolean columnBoxedBoolean;
 
     public String getColumnString() {
         return columnString;
@@ -105,4 +106,12 @@ public void setColumnRealmObject(DogPrimaryKey columnRealmObject) {
     public void setColumnRealmList(RealmList<DogPrimaryKey> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
+
+    public Boolean getColumnBoxedBoolean() {
+        return columnBoxedBoolean;
+    }
+
+    public void setColumnBoxedBoolean(Boolean columnBoxedBoolean) {
+        this.columnBoxedBoolean = columnBoxedBoolean;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java
new file mode 100644
index 0000000000..c26f7fd282
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {Dog.class, Cat.class})
+public class AnimalModule {
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationIndexTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationIndexTypes.java
new file mode 100644
index 0000000000..ca13e96528
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationIndexTypes.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+
+// Class for testing annotation index only
+public class AnnotationIndexTypes extends RealmObject {
+
+    public static final String CLASS_NAME = "AnnotationIndexTypes";
+
+    public static final String FIELD_INDEX_STRING = "indexString";
+    public static final String FIELD_INDEX_INT = "indexInt";
+    public static final String FIELD_INDEX_BYTE = "indexByte";
+    public static final String FIELD_INDEX_SHORT = "indexShort";
+    public static final String FIELD_INDEX_LONG = "indexLong";
+    public static final String FIELD_INDEX_BOOL = "indexBoolean";
+    public static final String FIELD_INDEX_DATE = "indexDate";
+
+    public static final String FIELD_NOT_INDEX_STRING = "notIndexString";
+    public static final String FIELD_NOT_INDEX_INT = "notIndexInt";
+    public static final String FIELD_NOT_INDEX_BYTE = "notIndexByte";
+    public static final String FIELD_NOT_INDEX_SHORT = "notIndexShort";
+    public static final String FIELD_NOT_INDEX_LONG = "notIndexLong";
+    public static final String FIELD_NOT_INDEX_BOOL = "notIndexBoolean";
+    public static final String FIELD_NOT_INDEX_DATE = "notIndexDate";
+
+    public static final String FIELD_OBJECT = "fieldObject";
+
+    public static final String[] INDEX_FIELDS = new String[]{FIELD_INDEX_STRING, FIELD_INDEX_INT, FIELD_INDEX_BYTE, FIELD_INDEX_SHORT, FIELD_INDEX_LONG, FIELD_INDEX_BOOL, FIELD_INDEX_DATE};
+    public static final String[] NOT_INDEX_FIELDS = new String[]{FIELD_NOT_INDEX_STRING, FIELD_NOT_INDEX_INT, FIELD_NOT_INDEX_BYTE, FIELD_NOT_INDEX_SHORT, FIELD_NOT_INDEX_LONG, FIELD_NOT_INDEX_BOOL, FIELD_NOT_INDEX_DATE};
+    public static final String   INDEX_LINKED_FIELD_STRING = AnnotationIndexTypes.FIELD_OBJECT + "." + AnnotationIndexTypes.FIELD_INDEX_STRING;
+    public static final String[] INDEX_LINKED_FIELDS = new String[]{FIELD_OBJECT + "." + FIELD_INDEX_STRING, FIELD_OBJECT + "." + FIELD_INDEX_INT};
+    public static final String   NOT_INDEX_LINKED_FILED_STRING = FIELD_OBJECT + "." + FIELD_NOT_INDEX_STRING;
+    public static final String[] NOT_INDEX_LINKED_FIELDS = new String[]{FIELD_OBJECT + "." + FIELD_NOT_INDEX_STRING, FIELD_OBJECT + "." + FIELD_NOT_INDEX_INT};
+    public static final String[] NONEXISTANT_MIX_FIELDS = new String[]{FIELD_INDEX_INT, "doesNotExists", FIELD_INDEX_STRING};
+
+    @Index
+    private String indexString;
+    private String notIndexString;
+
+    @Index
+    private int indexInt;
+    private int notIndexInt;
+
+    @Index
+    private byte indexByte;
+    private byte notIndexByte;
+
+    @Index
+    private short indexShort;
+    private short notIndexShort;
+
+    @Index
+    private long indexLong;
+    private long notIndexLong;
+
+    @Index
+    private boolean indexBoolean;
+    private boolean notIndexBoolean;
+
+    @Index
+    private Date indexDate;
+    private Date notIndexDate;
+
+    private AnnotationIndexTypes fieldObject;
+
+    public String getIndexString() {
+        return indexString;
+    }
+
+    public void setIndexString(String indexString) {
+        this.indexString = indexString;
+    }
+
+    public String getNotIndexString() {
+        return notIndexString;
+    }
+
+    public void setNotIndexString(String notIndexString) {
+        this.notIndexString = notIndexString;
+    }
+
+    public int getIndexInt() {
+        return indexInt;
+    }
+
+    public void setIndexInt(int indexInt) {
+        this.indexInt = indexInt;
+    }
+
+    public int getNotIndexInt() {
+        return notIndexInt;
+    }
+
+    public void setNotIndexInt(int notIndexInt) {
+        this.notIndexInt = notIndexInt;
+    }
+
+    public short getIndexShort() {
+        return indexShort;
+    }
+
+    public void setIndexShort(short indexShort) {
+        this.indexShort = indexShort;
+    }
+
+    public byte getIndexByte() {
+        return indexByte;
+    }
+
+    public void setIndexByte(byte indexByte) {
+        this.indexByte = indexByte;
+    }
+
+    public byte getNotIndexByte() {
+        return notIndexByte;
+    }
+
+    public void setNotIndexByte(byte notIndexByte) {
+        this.notIndexByte = notIndexByte;
+    }
+
+    public short getNotIndexShort() {
+        return notIndexShort;
+    }
+
+    public void setNotIndexShort(short notIndexShort) {
+        this.notIndexShort = notIndexShort;
+    }
+
+    public long getIndexLong() {
+        return indexLong;
+    }
+
+    public void setIndexLong(long indexLong) {
+        this.indexLong = indexLong;
+    }
+
+    public long getNotIndexLong() {
+        return notIndexLong;
+    }
+
+    public void setNotIndexLong(long notIndexLong) {
+        this.notIndexLong = notIndexLong;
+    }
+
+    public boolean isIndexBoolean() {
+        return indexBoolean;
+    }
+
+    public void setIndexBoolean(boolean indexBoolean) {
+        this.indexBoolean = indexBoolean;
+    }
+
+    public boolean isNotIndexBoolean() {
+        return notIndexBoolean;
+    }
+
+    public void setNotIndexBoolean(boolean notIndexBoolean) {
+        this.notIndexBoolean = notIndexBoolean;
+    }
+
+    public Date getIndexDate() {
+        return indexDate;
+    }
+
+    public void setIndexDate(Date indexDate) {
+        this.indexDate = indexDate;
+    }
+
+    public Date getNotIndexDate() {
+        return notIndexDate;
+    }
+
+    public void setNotIndexDate(Date notIndexDate) {
+        this.notIndexDate = notIndexDate;
+    }
+
+    public void setFieldObject(AnnotationIndexTypes object) {
+        this.fieldObject = object;
+    }
+
+    public AnnotationIndexTypes getFieldObject() { return this.fieldObject; }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/AnnotationNameConventions.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationNameConventions.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/AnnotationNameConventions.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationNameConventions.java
diff --git a/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
diff --git a/realm/src/androidTest/java/io/realm/entities/Cat.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
similarity index 97%
rename from realm/src/androidTest/java/io/realm/entities/Cat.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
index bb7a911601..03e961f055 100644
--- a/realm/src/androidTest/java/io/realm/entities/Cat.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
@@ -21,6 +21,9 @@
 import io.realm.RealmObject;
 
 public class Cat extends RealmObject {
+
+    public static final String CLASS_NAME = "Cat";
+
     private String name;
     private long age;
     private float height;
diff --git a/realm/src/androidTest/java/io/realm/entities/CatOwner.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
similarity index 95%
rename from realm/src/androidTest/java/io/realm/entities/CatOwner.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
index 9596e0ee22..477ee232fd 100644
--- a/realm/src/androidTest/java/io/realm/entities/CatOwner.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
@@ -18,8 +18,10 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.annotations.Required;
 
 public class CatOwner extends RealmObject {
+    @Required
     private String name;
     private RealmList<Cat> cats;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
new file mode 100644
index 0000000000..478c47cf00
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+
+import io.realm.RealmObject;
+
+public class ConflictingFieldName extends RealmObject {
+    private String realm;
+    private String row;
+    private String listeners;
+    private String pendingQuery;
+    private String isCompleted;
+    private String currentTableVersion;
+
+    public String getRealm() {
+        return realm;
+    }
+
+    public void setRealm(String realm) {
+        this.realm = realm;
+    }
+
+    public String getRow() {
+        return row;
+    }
+
+    public void setRow(String row) {
+        this.row = row;
+    }
+
+    public String getListeners() {
+        return listeners;
+    }
+
+    public void setListeners(String listeners) {
+        this.listeners = listeners;
+    }
+
+    public String getPendingQuery() {
+        return pendingQuery;
+    }
+
+    public void setPendingQuery(String pendingQuery) {
+        this.pendingQuery = pendingQuery;
+    }
+
+    public String getIsCompleted() {
+        return isCompleted;
+    }
+
+    public void setIsCompleted(String isCompleted) {
+        this.isCompleted = isCompleted;
+    }
+
+    public String getCurrentTableVersion() {
+        return currentTableVersion;
+    }
+
+    public void setCurrentTableVersion(String currentTableVersion) {
+        this.currentTableVersion = currentTableVersion;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java
new file mode 100644
index 0000000000..e29160615a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicType.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class CyclicType extends RealmObject {
+
+    private String name;
+    private CyclicType object;
+    private CyclicType otherObject;
+    private RealmList<CyclicType> objects;
+
+    public CyclicType() {
+    }
+
+    public CyclicType(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public CyclicType getObject() {
+        return object;
+    }
+
+    public void setObject(CyclicType object) {
+        this.object = object;
+    }
+
+    public RealmList<CyclicType> getObjects() {
+        return objects;
+    }
+
+    public void setObjects(RealmList<CyclicType> objects) {
+        this.objects = objects;
+    }
+
+    public CyclicType getOtherObject() {
+        return otherObject;
+    }
+
+    public void setOtherObject(CyclicType otherObject) {
+        this.otherObject = otherObject;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
similarity index 60%
rename from realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
index 25941ca5d7..085dc2fee8 100644
--- a/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.entities;
 
 import io.realm.RealmList;
@@ -19,6 +35,11 @@ public CyclicTypePrimaryKey(long id) {
         this.id = id;
     }
 
+    public CyclicTypePrimaryKey(long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     public long getId() {
         return id;
     }
diff --git a/realm/src/androidTest/java/io/realm/entities/Dog.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
similarity index 85%
rename from realm/src/androidTest/java/io/realm/entities/Dog.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
index 91d754b658..d6b2046a9f 100644
--- a/realm/src/androidTest/java/io/realm/entities/Dog.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Dog.java
@@ -24,6 +24,13 @@
 
 public class Dog extends RealmObject {
 
+    public static final String CLASS_NAME = "Dog";
+    public static final String FIELD_NAME = "name";
+    public static final String FIELD_AGE = "age";
+    public static final String FIELD_HEIGHT = "height";
+    public static final String FIELD_WEIGHT = "weight";
+    public static final String FIELD_BIRTHDAY = "birthday";
+
     @Index
     private String name;
     private long age;
diff --git a/realm/src/androidTest/java/io/realm/entities/DogPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
similarity index 97%
rename from realm/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
index 0800553ed8..21004f036d 100644
--- a/realm/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DogPrimaryKey.java
@@ -20,11 +20,12 @@
 import java.util.Date;
 
 import io.realm.RealmObject;
-import io.realm.annotations.Index;
 import io.realm.annotations.PrimaryKey;
 
 public class DogPrimaryKey extends RealmObject {
 
+    public static final String CLASS_NAME = "DogPrimaryKey";
+
     @PrimaryKey
     private long id;
     private String name;
diff --git a/realm/src/androidTest/java/io/realm/entities/FieldOrder.java b/realm/realm-library/src/androidTest/java/io/realm/entities/FieldOrder.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/FieldOrder.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/FieldOrder.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java
new file mode 100644
index 0000000000..6810f4288a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {CatOwner.class})
+public class HumanModule {
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/IOSAllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
similarity index 62%
rename from realm/src/androidTest/java/io/realm/entities/IOSAllTypes.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
index 14fb439026..db36d1a8e9 100644
--- a/realm/src/androidTest/java/io/realm/entities/IOSAllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
@@ -1,24 +1,53 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.entities;
 
 import java.util.Date;
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
 
 public class IOSAllTypes extends RealmObject {
 
+    @PrimaryKey
+    private long id;
+
     private boolean boolCol;
     private short shortCol;
     private int intCol;
-    private long longCol;
+    private int longCol;
+    private long longLongCol;
     private float floatCol;
     private double doubleCol;
-    private byte[] byteCol;
-    private String stringCol;
-    private Date dateCol;
+    private byte[] byteCol = new byte[0];
+    private String stringCol = "";
+    private Date dateCol = new Date(0);
     private IOSChild child;
     private RealmList<IOSChild> children;
 
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
     public boolean isBoolCol() {
         return boolCol;
     }
@@ -43,14 +72,22 @@ public void setIntCol(int intCol) {
         this.intCol = intCol;
     }
 
-    public long getLongCol() {
+    public int getLongCol() {
         return longCol;
     }
 
-    public void setLongCol(long longCol) {
+    public void setLongCol(int longCol) {
         this.longCol = longCol;
     }
 
+    public long getLongLongCol() {
+        return longLongCol;
+    }
+
+    public void setLongLongCol(long longLongCol) {
+        this.longLongCol = longCol;
+    }
+
     public float getFloatCol() {
         return floatCol;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/IOSChild.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSChild.java
new file mode 100644
index 0000000000..599d971270
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSChild.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class IOSChild extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
new file mode 100644
index 0000000000..dbac8543f2
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Required;
+
+// Always follow below order and put comments like below to make NullTypes Related cases
+// 1 String
+// 2 Bytes
+// 3 Boolean
+// 4 Byte
+// 5 Short
+// 6 Integer
+// 7 Long
+// 8 Float
+// 9 Double
+// 10 Date
+// 11 Object
+public class NoPrimaryKeyNullTypes extends RealmObject {
+
+    @Required
+    private String fieldStringNotNull = "";
+    private String fieldStringNull;
+
+    @Required
+    private byte[] fieldBytesNotNull = new byte[0];
+    private byte[] fieldBytesNull;
+
+    @Required
+    private Boolean fieldBooleanNotNull = false;
+    private Boolean fieldBooleanNull;
+
+    @Required
+    private Byte fieldByteNotNull = 0;
+    private Byte fieldByteNull;
+
+    @Required
+    private Short fieldShortNotNull = 0;
+    private Short fieldShortNull;
+
+    @Required
+    private Integer fieldIntegerNotNull = 0;
+    private Integer fieldIntegerNull;
+
+    @Required
+    private Long fieldLongNotNull = 0L;
+    private Long fieldLongNull;
+
+    @Required
+    private Float fieldFloatNotNull = 0F;
+    private Float fieldFloatNull;
+
+    @Required
+    private Double fieldDoubleNotNull = 0D;
+    private Double fieldDoubleNull;
+
+    @Required
+    private Date fieldDateNotNull = new Date(0);
+    private Date fieldDateNull;
+
+    private NoPrimaryKeyNullTypes fieldObjectNull;
+
+    public String getFieldStringNotNull() {
+        return fieldStringNotNull;
+    }
+
+    public void setFieldStringNotNull(String fieldStringNotNull) {
+        this.fieldStringNotNull = fieldStringNotNull;
+    }
+
+    public String getFieldStringNull() {
+        return fieldStringNull;
+    }
+
+    public void setFieldStringNull(String fieldStringNull) {
+        this.fieldStringNull = fieldStringNull;
+    }
+
+    public byte[] getFieldBytesNull() {
+        return fieldBytesNull;
+    }
+
+    public void setFieldBytesNull(byte[] fieldBytesNull) {
+        this.fieldBytesNull = fieldBytesNull;
+    }
+
+    public byte[] getFieldBytesNotNull() {
+        return fieldBytesNotNull;
+    }
+
+    public void setFieldBytesNotNull(byte[] fieldBytesNotNull) {
+        this.fieldBytesNotNull = fieldBytesNotNull;
+    }
+
+    public Boolean getFieldBooleanNotNull() {
+        return fieldBooleanNotNull;
+    }
+
+    public void setFieldBooleanNotNull(Boolean fieldBooleanNotNull) {
+        this.fieldBooleanNotNull = fieldBooleanNotNull;
+    }
+
+    public Boolean getFieldBooleanNull() {
+        return fieldBooleanNull;
+    }
+
+    public void setFieldBooleanNull(Boolean fieldBooleanNull) {
+        this.fieldBooleanNull = fieldBooleanNull;
+    }
+
+    public Byte getFieldByteNotNull() {
+        return fieldByteNotNull;
+    }
+
+    public void setFieldByteNotNull(Byte fieldByteNotNull) {
+        this.fieldByteNotNull = fieldByteNotNull;
+    }
+
+    public Byte getFieldByteNull() {
+        return fieldByteNull;
+    }
+
+    public void setFieldByteNull(Byte fieldByteNull) {
+        this.fieldByteNull = fieldByteNull;
+    }
+
+    public Short getFieldShortNotNull() {
+        return fieldShortNotNull;
+    }
+
+    public void setFieldShortNotNull(Short fieldShortNotNull) {
+        this.fieldShortNotNull = fieldShortNotNull;
+    }
+
+    public Short getFieldShortNull() {
+        return fieldShortNull;
+    }
+
+    public void setFieldShortNull(Short fieldShortNull) {
+        this.fieldShortNull = fieldShortNull;
+    }
+
+    public Integer getFieldIntegerNotNull() {
+        return fieldIntegerNotNull;
+    }
+
+    public void setFieldIntegerNotNull(Integer fieldIntegerNotNull) {
+        this.fieldIntegerNotNull = fieldIntegerNotNull;
+    }
+
+    public Integer getFieldIntegerNull() {
+        return fieldIntegerNull;
+    }
+
+    public void setFieldIntegerNull(Integer fieldIntegerNull) {
+        this.fieldIntegerNull = fieldIntegerNull;
+    }
+
+    public Long getFieldLongNotNull() {
+        return fieldLongNotNull;
+    }
+
+    public void setFieldLongNotNull(Long fieldLongNotNull) {
+        this.fieldLongNotNull = fieldLongNotNull;
+    }
+
+    public Long getFieldLongNull() {
+        return fieldLongNull;
+    }
+
+    public void setFieldLongNull(Long fieldLongNull) {
+        this.fieldLongNull = fieldLongNull;
+    }
+
+    public Float getFieldFloatNotNull() {
+        return fieldFloatNotNull;
+    }
+
+    public void setFieldFloatNotNull(Float fieldFloatNotNull) {
+        this.fieldFloatNotNull = fieldFloatNotNull;
+    }
+
+    public Float getFieldFloatNull() {
+        return fieldFloatNull;
+    }
+
+    public void setFieldFloatNull(Float fieldFloatNull) {
+        this.fieldFloatNull = fieldFloatNull;
+    }
+
+    public Double getFieldDoubleNotNull() {
+        return fieldDoubleNotNull;
+    }
+
+    public void setFieldDoubleNotNull(Double fieldDoubleNotNull) {
+        this.fieldDoubleNotNull = fieldDoubleNotNull;
+    }
+
+    public Double getFieldDoubleNull() {
+        return fieldDoubleNull;
+    }
+
+    public void setFieldDoubleNull(Double fieldDoubleNull) {
+        this.fieldDoubleNull = fieldDoubleNull;
+    }
+
+    public Date getFieldDateNotNull() {
+        return fieldDateNotNull;
+    }
+
+    public void setFieldDateNotNull(Date fieldDateNotNull) {
+        this.fieldDateNotNull = fieldDateNotNull;
+    }
+
+    public Date getFieldDateNull() {
+        return fieldDateNull;
+    }
+
+    public void setFieldDateNull(Date fieldDateNull) {
+        this.fieldDateNull = fieldDateNull;
+    }
+
+    public NoPrimaryKeyNullTypes getFieldObjectNull() {
+        return fieldObjectNull;
+    }
+
+    public void setFieldObjectNull(NoPrimaryKeyNullTypes fieldObjectNull) {
+        this.fieldObjectNull = fieldObjectNull;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
similarity index 82%
rename from realm/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
index 8bbe8e7c0a..ee51ea91f7 100644
--- a/realm/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
@@ -19,6 +19,12 @@
 import io.realm.RealmObject;
 
 public class NonLatinFieldNames extends RealmObject{
+
+    public final static String FIELD_LONG_KOREAN_CHAR = "델타";
+    public final static String FIELD_LONG_GREEK_CHAR = "Δέλτα";
+    public final static String FIELD_FLOAT_KOREAN_CHAR = "베타";
+    public final static String FIELD_FLOAT_GREEK_CHAR = "βήτα";
+
     private long 델타;
     private long Δέλτα;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
new file mode 100644
index 0000000000..5696701480
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
+
+// Always follow below order and put comments like below to make NullTypes Related cases
+// 1 String
+// 2 Bytes
+// 3 Boolean
+// 4 Byte
+// 5 Short
+// 6 Integer
+// 7 Long
+// 8 Float
+// 9 Double
+// 10 Date
+// 11 Object
+public class NullTypes extends RealmObject {
+
+    public static String CLASS_NAME = "NullTypes";
+    public static String FIELD_ID = "id";
+    public static String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
+    public static String FIELD_STRING_NULL = "fieldStringNull";
+    public static String FIELD_BYTES_NOT_NULL = "fieldBytesNotNull";
+    public static String FIELD_BYTES_NULL = "fieldBytesNull";
+    public static String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
+    public static String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
+    public static String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
+    public static String FIELD_BYTE_NULL = "fieldByteNull";
+    public static String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
+    public static String FIELD_SHORT_NULL = "fieldShortNull";
+    public static String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
+    public static String FIELD_INTEGER_NULL = "fieldIntegerNull";
+    public static String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
+    public static String FIELD_LONG_NULL = "fieldLongNull";
+    public static String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
+    public static String FIELD_FLOAT_NULL = "fieldFloatNull";
+    public static String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
+    public static String FIELD_DOUBLE_NULL = "fieldDoubleNull";
+    public static String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
+    public static String FIELD_DATE_NULL = "fieldDateNull";
+    public static String FIELD_OBJECT_NULL = "fieldObjectNull";
+    public static String FIELD_LIST_NULL = "fieldListNull";
+
+    @PrimaryKey
+    private int id;
+
+    @Required
+    private String fieldStringNotNull = "";
+    private String fieldStringNull;
+
+    @Required
+    private byte[] fieldBytesNotNull = new byte[0];
+    private byte[] fieldBytesNull;
+
+    @Required
+    private Boolean fieldBooleanNotNull = false;
+    private Boolean fieldBooleanNull;
+
+    @Required
+    private Byte fieldByteNotNull = 0;
+    private Byte fieldByteNull;
+
+    @Required
+    private Short fieldShortNotNull = 0;
+    private Short fieldShortNull;
+
+    @Required
+    private Integer fieldIntegerNotNull = 0;
+    private Integer fieldIntegerNull;
+
+    @Required
+    private Long fieldLongNotNull = 0L;
+    private Long fieldLongNull;
+
+    @Required
+    private Float fieldFloatNotNull = 0F;
+    private Float fieldFloatNull;
+
+    @Required
+    private Double fieldDoubleNotNull = 0D;
+    private Double fieldDoubleNull;
+
+    @Required
+    private Date fieldDateNotNull = new Date(0);
+    private Date fieldDateNull;
+
+    private NullTypes fieldObjectNull;
+
+    private RealmList<NullTypes> fieldListNull;
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public String getFieldStringNotNull() {
+        return fieldStringNotNull;
+    }
+
+    public void setFieldStringNotNull(String fieldStringNotNull) {
+        this.fieldStringNotNull = fieldStringNotNull;
+    }
+
+    public String getFieldStringNull() {
+        return fieldStringNull;
+    }
+
+    public void setFieldStringNull(String fieldStringNull) {
+        this.fieldStringNull = fieldStringNull;
+    }
+
+    public byte[] getFieldBytesNull() {
+        return fieldBytesNull;
+    }
+
+    public void setFieldBytesNull(byte[] fieldBytesNull) {
+        this.fieldBytesNull = fieldBytesNull;
+    }
+
+    public byte[] getFieldBytesNotNull() {
+        return fieldBytesNotNull;
+    }
+
+    public void setFieldBytesNotNull(byte[] fieldBytesNotNull) {
+        this.fieldBytesNotNull = fieldBytesNotNull;
+    }
+
+    public Boolean getFieldBooleanNotNull() {
+        return fieldBooleanNotNull;
+    }
+
+    public void setFieldBooleanNotNull(Boolean fieldBooleanNotNull) {
+        this.fieldBooleanNotNull = fieldBooleanNotNull;
+    }
+
+    public Boolean getFieldBooleanNull() {
+        return fieldBooleanNull;
+    }
+
+    public void setFieldBooleanNull(Boolean fieldBooleanNull) {
+        this.fieldBooleanNull = fieldBooleanNull;
+    }
+
+    public Byte getFieldByteNotNull() {
+        return fieldByteNotNull;
+    }
+
+    public void setFieldByteNotNull(Byte fieldByteNotNull) {
+        this.fieldByteNotNull = fieldByteNotNull;
+    }
+
+    public Byte getFieldByteNull() {
+        return fieldByteNull;
+    }
+
+    public void setFieldByteNull(Byte fieldByteNull) {
+        this.fieldByteNull = fieldByteNull;
+    }
+
+    public Short getFieldShortNotNull() {
+        return fieldShortNotNull;
+    }
+
+    public void setFieldShortNotNull(Short fieldShortNotNull) {
+        this.fieldShortNotNull = fieldShortNotNull;
+    }
+
+    public Short getFieldShortNull() {
+        return fieldShortNull;
+    }
+
+    public void setFieldShortNull(Short fieldShortNull) {
+        this.fieldShortNull = fieldShortNull;
+    }
+
+    public Integer getFieldIntegerNotNull() {
+        return fieldIntegerNotNull;
+    }
+
+    public void setFieldIntegerNotNull(Integer fieldIntegerNotNull) {
+        this.fieldIntegerNotNull = fieldIntegerNotNull;
+    }
+
+    public Integer getFieldIntegerNull() {
+        return fieldIntegerNull;
+    }
+
+    public void setFieldIntegerNull(Integer fieldIntegerNull) {
+        this.fieldIntegerNull = fieldIntegerNull;
+    }
+
+    public Long getFieldLongNotNull() {
+        return fieldLongNotNull;
+    }
+
+    public void setFieldLongNotNull(Long fieldLongNotNull) {
+        this.fieldLongNotNull = fieldLongNotNull;
+    }
+
+    public Long getFieldLongNull() {
+        return fieldLongNull;
+    }
+
+    public void setFieldLongNull(Long fieldLongNull) {
+        this.fieldLongNull = fieldLongNull;
+    }
+
+    public Float getFieldFloatNotNull() {
+        return fieldFloatNotNull;
+    }
+
+    public void setFieldFloatNotNull(Float fieldFloatNotNull) {
+        this.fieldFloatNotNull = fieldFloatNotNull;
+    }
+
+    public Float getFieldFloatNull() {
+        return fieldFloatNull;
+    }
+
+    public void setFieldFloatNull(Float fieldFloatNull) {
+        this.fieldFloatNull = fieldFloatNull;
+    }
+
+    public Double getFieldDoubleNotNull() {
+        return fieldDoubleNotNull;
+    }
+
+    public void setFieldDoubleNotNull(Double fieldDoubleNotNull) {
+        this.fieldDoubleNotNull = fieldDoubleNotNull;
+    }
+
+    public Double getFieldDoubleNull() {
+        return fieldDoubleNull;
+    }
+
+    public void setFieldDoubleNull(Double fieldDoubleNull) {
+        this.fieldDoubleNull = fieldDoubleNull;
+    }
+
+    public Date getFieldDateNotNull() {
+        return fieldDateNotNull;
+    }
+
+    public void setFieldDateNotNull(Date fieldDateNotNull) {
+        this.fieldDateNotNull = fieldDateNotNull;
+    }
+
+    public Date getFieldDateNull() {
+        return fieldDateNull;
+    }
+
+    public void setFieldDateNull(Date fieldDateNull) {
+        this.fieldDateNull = fieldDateNull;
+    }
+
+    public NullTypes getFieldObjectNull() {
+        return fieldObjectNull;
+    }
+
+    public void setFieldObjectNull(NullTypes fieldObjectNull) {
+        this.fieldObjectNull = fieldObjectNull;
+    }
+
+    public RealmList<NullTypes> getFieldListNull() {
+        return fieldListNull;
+    }
+
+    public void setFieldListNull(RealmList<NullTypes> fieldListNull) {
+        this.fieldListNull = fieldListNull;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/Owner.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Owner.java
similarity index 86%
rename from realm/src/androidTest/java/io/realm/entities/Owner.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/Owner.java
index 307a4a44f3..605d5ae79a 100644
--- a/realm/src/androidTest/java/io/realm/entities/Owner.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Owner.java
@@ -20,6 +20,12 @@
 import io.realm.RealmObject;
 
 public class Owner extends RealmObject {
+
+    public static String CLASS_NAME = "Owner";
+    public static String FIELD_NAME = "name";
+    public static String FIELD_DOGS = "dogs";
+    public static String FIELD_CAT = "cat";
+
     private String name;
     private RealmList<Dog> dogs;
     private Cat cat;
diff --git a/realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
diff --git a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
diff --git a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
diff --git a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyMix.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyMix.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/PrimaryKeyMix.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyMix.java
diff --git a/realm/src/androidTest/java/io/realm/entities/RealmAdapter.java b/realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/RealmAdapter.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/RealmAdapter.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringAndInt.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringAndInt.java
new file mode 100644
index 0000000000..2f007626f7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringAndInt.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class StringAndInt extends RealmObject {
+    private String str;
+    private int number;
+
+    public String getStr() {
+        return str;
+    }
+
+    public void setStr(String str) {
+        this.str = str;
+    }
+
+    public int getNumber() {
+        return number;
+    }
+
+    public void setNumber(int number) {
+        this.number = number;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/StringOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
similarity index 99%
rename from realm/src/androidTest/java/io/realm/entities/StringOnly.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
index d210058866..b4183425c9 100644
--- a/realm/src/androidTest/java/io/realm/entities/StringOnly.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
@@ -19,7 +19,6 @@
 import io.realm.RealmObject;
 
 public class StringOnly extends RealmObject {
-
     private String chars;
 
     public String getChars() {
diff --git a/realm/src/androidTest/java/io/realm/entities/Thread.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/entities/Thread.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
new file mode 100644
index 0000000000..bad11e5007
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.instrumentation;
+
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.entities.AllTypes;
+
+public class ActivityLifecycle implements Lifecycle, RealmChangeListener {
+    private final RealmConfiguration realmConfiguration;
+    private Realm realm;
+    private RealmResults<AllTypes> mAllTypes;
+
+    public ActivityLifecycle (RealmConfiguration realmConfiguration) {
+        this.realmConfiguration = realmConfiguration;
+    }
+
+    @Override
+    public void onStart() {
+        realm = Realm.getInstance(realmConfiguration);
+        mAllTypes = realm.where(AllTypes.class).findAllAsync();
+        mAllTypes.addChangeListener(this);
+    }
+
+    @Override
+    public void onStop() {
+        mAllTypes.removeChangeListener(this);
+        realm.close();
+    }
+
+    @Override
+    public void onChange() {
+
+    }
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/Lifecycle.java
similarity index 80%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java
rename to realm/realm-library/src/androidTest/java/io/realm/instrumentation/Lifecycle.java
index c8e90b18a3..6185c3d869 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/Lifecycle.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,9 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service;
-
-public interface KillableThread {
-
-    public void terminate();
+package io.realm.instrumentation;
 
+public interface Lifecycle {
+    void onStart ();
+    void onStop ();
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/LifecycleComponentFactory.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/LifecycleComponentFactory.java
new file mode 100644
index 0000000000..948077b365
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/LifecycleComponentFactory.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.instrumentation;
+
+import io.realm.RealmConfiguration;
+
+public class LifecycleComponentFactory {
+    public static Lifecycle newInstance(RealmConfiguration realmConfiguration) {
+        return new ActivityLifecycle(realmConfiguration);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java
new file mode 100644
index 0000000000..93372b8aad
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/MockActivityManager.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.instrumentation;
+
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import io.realm.RealmConfiguration;
+
+public class MockActivityManager {
+    private Lifecycle instance;
+    private final RealmConfiguration realmConfiguration;
+    private final ReferenceQueue<Lifecycle> queue;
+    private static final Set<WeakReference<Lifecycle>> references = new CopyOnWriteArraySet<WeakReference<Lifecycle>>();
+
+    private MockActivityManager(RealmConfiguration realmConfiguration) {
+        this.realmConfiguration = realmConfiguration;
+
+        instance = LifecycleComponentFactory.newInstance(realmConfiguration);
+
+        this.queue = new ReferenceQueue<Lifecycle>();
+        references.add(new WeakReference<Lifecycle>(instance, queue));
+
+        instance.onStart();
+    }
+
+    public static MockActivityManager newInstance (RealmConfiguration realmConfiguration) {
+        return new MockActivityManager(realmConfiguration);
+    }
+
+    // simulate a configuration change, that should trigger
+    // to recreate the Lifecycle component
+    public void sendConfigurationChange () {
+        instance.onStop();
+        // create a new instance
+        instance = LifecycleComponentFactory.newInstance(realmConfiguration);
+        references.add(new WeakReference<Lifecycle>(instance, queue));
+
+        instance.onStart();
+    }
+
+    public int numberOfInstances () {
+        triggerGC();
+        // WeakReferences are enqueued as soon as the object to which they point to becomes
+        // weakly reachable.
+        deleteWeaklyReachableReferences();
+        return references.size();
+    }
+
+    // call onStop on the Activity, this help closing any open open realm
+    public void onStop() {
+        instance.onStop();
+    }
+
+    private void triggerGC () {
+        // From the AOSP FinalizationTest:
+        // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+        // java/lang/ref/FinalizationTester.java
+        // System.gc() does not garbage collect every time. Runtime.gc() is
+        // more likely to perform a gc.
+        Runtime.getRuntime().gc();
+        enqueueReferences();
+        System.runFinalization();
+    }
+
+    private void enqueueReferences() {
+        // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
+        // references to the appropriate queues.
+        try {
+            Thread.sleep(100);
+        } catch (InterruptedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    private void deleteWeaklyReachableReferences() {
+        Reference<? extends Lifecycle> weakReference;
+        while ((weakReference = queue.poll()) != null ) { // Does not wait for a reference to become available.
+            references.remove(weakReference);
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
new file mode 100644
index 0000000000..e6ac3b88a6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import junit.framework.TestCase;
+
+import io.realm.RealmFieldType;
+
+public class JNIBinaryTypeTest extends TestCase {
+
+    protected Table table;
+    protected byte [] testArray = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
+
+    @Override
+    public void setUp() {
+        RealmCore.loadLibrary();
+        //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
+
+        table = new Table();
+        table.addColumn(RealmFieldType.BINARY, "bin");
+    }
+
+    @Override
+    public void tearDown() {
+        //table.close();
+        table = null;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNICloseTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
similarity index 71%
rename from realm/src/androidTest/java/io/realm/internal/JNICloseTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
index 9e5759bfe5..a798ecb28c 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNICloseTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import android.test.AndroidTestCase;
@@ -7,7 +23,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import io.realm.internal.test.TestHelper;
+import io.realm.RealmFieldType;
+import io.realm.TestHelper;
 
 // Tables get detached
 
@@ -36,7 +53,7 @@ public void testCloseable() {
         try {
             Table t = wt.getTable("test");
             resources.add(t);
-            t.addColumn(ColumnType.STRING, "StringColumn");
+            t.addColumn(RealmFieldType.STRING, "StringColumn");
 
             t.add("abc");
             t.add("cba");
@@ -46,7 +63,7 @@ public void testCloseable() {
         } catch(Throwable t) {
             wt.rollback();
         } finally {
-            for(Closeable c : resources) {
+            for (Closeable c : resources) {
                 try {
                     c.close();
                 } catch(java.io.IOException e) {
@@ -62,7 +79,7 @@ public void testShouldCloseTable() throws Throwable {
 
         try { table.size();                            fail("Table is closed"); } catch (IllegalStateException e) { }
         try { table.getColumnCount();                  fail("Table is closed"); } catch (IllegalStateException e) { }
-        try { table.addColumn(ColumnType.STRING, "");  fail("Table is closed"); } catch (IllegalStateException e) { }
+        try { table.addColumn(RealmFieldType.STRING, "");  fail("Table is closed"); } catch (IllegalStateException e) { }
 
         // TODO: Test all methods...
     }
@@ -142,22 +159,22 @@ public void testAccessingViewMethodsAfterTableClose() {
 
         WriteTransaction trans = db.beginWrite();
         Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(ColumnType.STRING, "name");
-        tbl.addColumn(ColumnType.INTEGER, "number");
+        tbl.addColumn(RealmFieldType.STRING, "name");
+        tbl.addColumn(RealmFieldType.INTEGER, "number");
         TableView view = tbl.where().findAll();
 
         trans.commit();
 
         //methods below should throw exception, as table is invalid after commit
-        try{ view.size();                       fail(); } catch (IllegalStateException e){}
-        try{ view.getBinaryByteArray(0, 0);     fail(); } catch (IllegalStateException e){}
-        try{ view.getBoolean(1, 0);             fail(); } catch (IllegalStateException e){}
-        try{ view.getDate(2, 0);                fail(); } catch (IllegalStateException e){}
-        try{ view.getDouble(3, 0);              fail(); } catch (IllegalStateException e){}
-        try{ view.getFloat(4, 0);               fail(); } catch (IllegalStateException e){}
-        try{ view.getLong(5, 0);                fail(); } catch (IllegalStateException e){}
-        try{ view.getMixed(6, 0);               fail(); } catch (IllegalStateException e){}
-        try{ view.getString(7, 0);              fail(); } catch (IllegalStateException e){}
+        try { view.size();                       fail(); } catch (IllegalStateException e){}
+        try { view.getBinaryByteArray(0, 0);     fail(); } catch (IllegalStateException e){}
+        try { view.getBoolean(1, 0);             fail(); } catch (IllegalStateException e){}
+        try { view.getDate(2, 0);                fail(); } catch (IllegalStateException e){}
+        try { view.getDouble(3, 0);              fail(); } catch (IllegalStateException e){}
+        try { view.getFloat(4, 0);               fail(); } catch (IllegalStateException e){}
+        try { view.getLong(5, 0);                fail(); } catch (IllegalStateException e){}
+        try { view.getMixed(6, 0);               fail(); } catch (IllegalStateException e){}
+        try { view.getString(7, 0);              fail(); } catch (IllegalStateException e){}
         // TODO: Add more methods
 
         db.close();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
new file mode 100644
index 0000000000..30c64ac29c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import junit.framework.TestCase;
+
+import io.realm.RealmFieldType;
+
+public class JNIColumnInfoTest extends TestCase {
+
+    Table table;
+
+    @Override
+    public void setUp() {
+        table = new Table();
+        table.addColumn(RealmFieldType.STRING, "firstName");
+        table.addColumn(RealmFieldType.STRING, "lastName");
+    }
+
+    public void testShouldGetColumnInformation() {
+
+        assertEquals(2, table.getColumnCount());
+
+        assertEquals("lastName", table.getColumnName(1));
+
+        assertEquals(1, table.getColumnIndex("lastName"));
+
+        assertEquals(RealmFieldType.STRING, table.getColumnType(1));
+
+    }
+
+    public void testValidateColumnInfo() {
+
+        TableView view = table.where().findAll();
+
+        assertEquals(2, view.getColumnCount());
+
+        assertEquals("lastName", view.getColumnName(1));
+
+        assertEquals(1, view.getColumnIndex("lastName"));
+
+        assertEquals(RealmFieldType.STRING, view.getColumnType(1));
+
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
similarity index 70%
rename from realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
index 4e85a4e073..1759b9d8c4 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
@@ -1,17 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 // TODO: Check that Index can be set on multiple columns.
 
 import junit.framework.TestCase;
 
+import io.realm.RealmFieldType;
+
 @SuppressWarnings("unused")
 public class JNIDistinctTest extends TestCase {
     Table table;
 
     void init() {
         table = new Table();
-        table.addColumn(ColumnType.INTEGER, "number");
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.INTEGER, "number");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         long i = 0;
         table.add(0, "A");
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
similarity index 63%
rename from realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
index 5906b1e233..3ca74bc1e4 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
@@ -5,6 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+
 // Tables get detached
 
 public class JNIGarbageCollectorQueryTest extends TestCase {
@@ -45,7 +63,7 @@ public void t3(long count){
     public void testGetSubtable(){
 
         t = new Table();
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         long count = 100;
         long loop = 100;
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
similarity index 62%
rename from realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
index 9b22aa416c..4f44a3c174 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
@@ -5,6 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+
 
 // Tables get detached
 
@@ -16,7 +34,7 @@
     public void t1(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         List<TableSchema> tables = new ArrayList<TableSchema>();
@@ -32,7 +50,7 @@ public void t1(long count){
     public void t2(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         for (long i=0;i<count;i++){
@@ -48,7 +66,7 @@ public void t2(long count){
     public void t3(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         for (long i=0;i<count;i++){
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
similarity index 61%
rename from realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
index a2e1f4c03e..309b0611fd 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
@@ -5,6 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+
 
 // Tables get detached
 
@@ -16,7 +34,7 @@
     public void t1(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         List<Table> tables = new ArrayList<Table>();
@@ -32,7 +50,7 @@ public void t1(long count){
     public void t2(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         for (long i=0;i<count;i++){
@@ -48,7 +66,7 @@ public void t2(long count){
     public void t3(long count){
         t = new Table();
 
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         t.addEmptyRow();
 
         for (long i=0;i<count;i++){
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
similarity index 64%
rename from realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
index 1b691fac2b..a6d9024d57 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
@@ -5,6 +21,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+
 // Tables get detached
 
 public class JNIGarbageCollectorTableViewTest extends TestCase {
@@ -45,7 +63,7 @@ public void t3(long count){
     public void testGetSubtableView(){
         
         t = new Table();
-        t.addColumn(ColumnType.TABLE, "table");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         long count = 10; // 1000;
         long loop = 100;
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
similarity index 68%
rename from realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
index 6202f2a2f4..bbfcbbf011 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import android.test.AndroidTestCase;
@@ -5,6 +21,8 @@
 import java.io.File;
 import java.util.Arrays;
 
+import io.realm.RealmFieldType;
+
 public class JNIImplicitTransactionsTest extends AndroidTestCase {
 
     String testFile;
@@ -28,13 +46,13 @@ private void deleteFile() {
 
     public void testImplicitTransactions() {
         deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, null); // TODO: try with encryption
+        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null); // TODO: try with encryption
 
         // Create a table
         WriteTransaction wt = sg.beginWrite();
         if (!wt.hasTable("test")) {
             Table table = wt.getTable("test");
-            table.addColumn(ColumnType.INTEGER, "integer");
+            table.addColumn(RealmFieldType.INTEGER, "integer");
             table.addEmptyRow();
         }
         wt.commit();
@@ -58,11 +76,11 @@ public void testImplicitTransactions() {
 
     public void testCannotUseClosedImplicitTransaction() {
         deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, null);
+        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null);
         WriteTransaction wt = sg.beginWrite();
         if (!wt.hasTable("test")) {
             Table table = wt.getTable("test");
-            table.addColumn(ColumnType.INTEGER, "integer");
+            table.addColumn(RealmFieldType.INTEGER, "integer");
             table.addEmptyRow();
         }
         wt.commit();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
new file mode 100644
index 0000000000..ba674f6664
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import junit.framework.TestCase;
+
+import io.realm.RealmFieldType;
+
+public class JNILinkTest extends TestCase {
+
+    public void testLinkColumns() {
+
+        Group group = new Group();
+
+        Table table1 = group.getTable("table1");
+
+        Table table2 = group.getTable("table2");
+        table2.addColumn(RealmFieldType.INTEGER, "int");
+        table2.addColumn(RealmFieldType.STRING, "string");
+
+        table2.add(1, "c");
+        table2.add(2, "b");
+        table2.add(3, "a");
+
+        table1.addColumnLink(RealmFieldType.OBJECT, "Link", table2);
+
+        table1.addEmptyRow();
+        table1.setLink(0, 0, 1);
+
+        Table target = table1.getLinkTarget(0);
+
+        System.gc();
+
+        assertEquals(target.getColumnCount(), 2);
+
+        String test = target.getString(1, table1.getLink(0, 0));
+
+        assertEquals(test, "b");
+
+    }
+
+    public void testLinkList() {
+
+        Group group = new Group();
+
+        Table table1 = group.getTable("table1");
+        table1.addColumn(RealmFieldType.INTEGER, "int");
+        table1.addColumn(RealmFieldType.STRING, "string");
+        table1.add(1, "c");
+        table1.add(2, "b");
+        table1.add(3, "a");
+
+        Table table2 = group.getTable("table2");
+
+        table2.addColumnLink(RealmFieldType.LIST, "LinkList", table1);
+
+        table2.addEmptyRow();
+
+        LinkView links = table2.getUncheckedRow(0).getLinkList(0);
+
+        assertEquals(links.isEmpty(), true);
+        assertEquals(links.size(), 0);
+
+        links.add(2);
+        links.add(1);
+
+        assertEquals(links.isEmpty(), false);
+        assertEquals(links.size(), 2);
+
+        assertEquals(links.getUncheckedRow(0).getColumnName(1), "string");
+
+        assertEquals(links.getUncheckedRow(0).getString(1), "a");
+
+        links.move(1, 0);
+
+        assertEquals(links.getUncheckedRow(0).getString(1), "b");
+
+        links.remove(0);
+
+        assertEquals(links.getUncheckedRow(0).getString(1), "a");
+        assertEquals(links.size(), 1);
+
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
similarity index 78%
rename from realm/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
index 056cd31d77..fcce79d622 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
@@ -1,16 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
 import java.util.Date;
 
+import io.realm.RealmFieldType;
+
 public class JNIMixedSubtableTest extends TestCase {
 
     public void testGetSubtableFromMixedColumnTest() {
+        Util.setDebugLevel(2);
         Table table = new Table();
 
-        table.addColumn(ColumnType.INTEGER, "num");
-        table.addColumn(ColumnType.MIXED, "mix");
+        table.addColumn(RealmFieldType.INTEGER, "num");
+        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
 
         // No rows added yet
         try { Table subtable = table.getSubtable(1, 0); fail("No rows added, index out of bounds"); } catch (ArrayIndexOutOfBoundsException e) { }
@@ -57,7 +76,7 @@ public void testGetSubtableFromMixedColumnTest() {
 
         /* FIXME: Subtable in Mixed is currently not supported
         // Now we specifically set the Mixed value to a subtable
-        table.setMixed(1, 0, new Mixed(ColumnType.TABLE));
+        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
         // Getting a subtable on the mixed column is now allowed
         Table subtable = table.getSubtable(1, 0);
         */
@@ -68,13 +87,13 @@ public void testShouldCreateSubtableInMixedTypeColumn() {
         Table table = new Table();
 
         TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.INTEGER, "num");
-        tableSpec.addColumn(ColumnType.MIXED, "mix");
+        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
+        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
         TableSpec subspec = tableSpec.addSubtableColumn("subtable");
-        subspec.addColumn(ColumnType.INTEGER, "num");
+        subspec.addColumn(RealmFieldType.INTEGER, "num");
         table.updateFromSpec(tableSpec);
 
-        // Shouln't work: no Mixed stored yet
+        // Shouldn't work: no Mixed stored yet
         //Mixed m1 = table.getMixed(1, 0);
         //ColumnType mt = table.getMixedType(1,0);
 
@@ -91,14 +110,14 @@ public void testShouldCreateSubtableInMixedTypeColumn() {
         long ROW = 0;
         // Add empty row - the simple way
         table.addEmptyRow();
-        table.setMixed(1, ROW, new Mixed(ColumnType.TABLE));
+        table.setMixed(1, ROW, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
         assertEquals(1, table.size());
         assertEquals(0, table.getSubtableSize(1, 0));
 
         // Create schema for the one Mixed cell with a subtable
         Table subtable = table.getSubtable(1, ROW);
         TableSpec subspecMixed = subtable.getTableSpec();
-        subspecMixed.addColumn(ColumnType.INTEGER, "num");
+        subspecMixed.addColumn(RealmFieldType.INTEGER, "num");
         subtable.updateFromSpec(subspecMixed);
 
         // Insert value in the Mixed subtable
@@ -116,12 +135,12 @@ public void testShouldCreateSubtableInMixedTypeColumn2() {
         Table table = new Table();
 
         TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.INTEGER, "num");
-        tableSpec.addColumn(ColumnType.MIXED, "mix");
+        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
+        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
         table.updateFromSpec(tableSpec);
 
         table.addEmptyRow();
-        table.setMixed(1, 0, new Mixed(ColumnType.TABLE));
+        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
 
         Table subtable = table.getSubtable(1, 0);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
new file mode 100644
index 0000000000..5c630f7ff6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.test.MixedData;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class JNIMixedTypeTest {
+
+    List<MixedData> mixedDataList = new ArrayList<MixedData>();
+
+    @Parameterized.Parameters
+    public static List<Object[]> parameters() {
+        //Adding MixedData to the list
+        List<MixedData> mixedDataList = new ArrayList<MixedData>();
+        mixedDataList.add(0, new MixedData(RealmFieldType.INTEGER, 123L));
+        mixedDataList.add(1, new MixedData(RealmFieldType.FLOAT, 987.123f));
+        mixedDataList.add(2, new MixedData(RealmFieldType.DOUBLE, 1234567.898d));
+        mixedDataList.add(3, new MixedData(RealmFieldType.BOOLEAN, true));
+        mixedDataList.add(4, new MixedData(RealmFieldType.STRING, "abc"));
+        mixedDataList.add(5, new MixedData(RealmFieldType.BINARY, new byte[]{1, 2, 3, 4, 5}));
+        mixedDataList.add(6, new MixedData(RealmFieldType.DATE, new Date(645342)));
+
+        return Arrays.asList(
+                new Object[]{mixedDataList},
+                new Object[]{mixedDataList},
+                new Object[]{mixedDataList},
+                new Object[]{mixedDataList}
+        );
+    }
+
+    public JNIMixedTypeTest(List<MixedData> mixedDataList) {
+        this.mixedDataList = mixedDataList;
+    }
+
+    @Test
+    public void testShouldMatchMixedValues() {
+        for (int i = 0; i < mixedDataList.size(); i++) {
+            for (int j = 0; j < mixedDataList.size(); j++) {
+                if (mixedDataList.get(i).value == mixedDataList.get(j).value) {
+                    assertEquals(mixedDataList.get(i).value, mixedDataList.get(j).value);
+
+                } else {
+                    assertNotSame(mixedDataList.get(i).value, mixedDataList.get(j).value);
+
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testShouldFailOnWrongTypeRetrieval() {
+        for (int i = 0; i < mixedDataList.size(); i++) {
+            Object value = mixedDataList.get(i).type != RealmFieldType.STRING ? "abc" : 123;
+            Mixed mixed = Mixed.mixedValue(value);
+
+            switch (mixedDataList.get(i).type) {
+                case BINARY:
+                    try {
+                        mixed.getBinaryByteArray();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case DATE:
+                    try {
+                        mixed.getDateValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case BOOLEAN:
+                    try {
+                        mixed.getBooleanValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case INTEGER:
+                    try {
+                        mixed.getLongValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case FLOAT:
+                    try {
+                        mixed.getFloatValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case DOUBLE:
+                    try {
+                        mixed.getDoubleValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                case STRING:
+                    try {
+                        mixed.getStringValue();
+                        fail("Wrong mixed type");
+                    } catch (IllegalMixedTypeException ignored) {
+                    }
+                    break;
+                default:
+                    fail("wrong type");
+                    break;
+            }
+        }
+    }
+}
+
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
similarity index 73%
rename from realm/src/androidTest/java/io/realm/internal/JNIQueryTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 3264d85403..4942a9497e 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -1,10 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
 import java.util.Date;
+import java.util.concurrent.TimeUnit;
 
-import io.realm.internal.test.TestHelper;
+import io.realm.Case;
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+import io.realm.TestHelper;
 
 public class JNIQueryTest extends TestCase {
 
@@ -12,8 +32,8 @@
 
     void init() {
         table = new Table();
-        table.addColumn(ColumnType.INTEGER, "number");
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.INTEGER, "number");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         table.add(10, "A");
         table.add(11, "B");
@@ -28,7 +48,7 @@ public void shouldQueryOnSortedView() {
 
         init();
 
-        TableView sortedView = table.getSortedView(0, TableView.Order.descending);
+        TableView sortedView = table.getSortedView(0, Sort.DESCENDING);
 
         TableView result = sortedView.where().findAll();
 
@@ -63,24 +83,34 @@ public void testNonCompleteQuery() {
         init();
 
         // All the following queries are not valid, e.g contain a group but not a closing group, an or() but not a second filter etc
-        try { table.where().equalTo(new long[]{0}, 1).or().findAll();       fail("missing a second filter"); }      catch (UnsupportedOperationException e) { }
-        try { table.where().or().findAll();                                 fail("just an or()"); }                 catch (UnsupportedOperationException e) { }
-        try { table.where().group().equalTo(new long[]{0}, 1).findAll();    fail("messing a clsong group"); }       catch (UnsupportedOperationException e) { }
-        try { table.where().endGroup().equalTo(new long[]{0}, 1).findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
+        try { table.where().equalTo(new long[]{0}, 1).or().findAll();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().or().findAll();                                 fail("just an or()"); }                 catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().equalTo(new long[]{0}, 1).findAll();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
+
+        try { table.where().group().count();                                fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().findAll();                              fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().find();                                 fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().minimumInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().maximumInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().sumInt(0);                              fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().averageInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
+
+        try { table.where().endGroup().equalTo(new long[]{0}, 1).findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(0, -1, -1); fail("ends group, no start"); } catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(0, -1, -1); fail("ends group, no start"); }         catch (UnsupportedOperationException e) { }
 
 
         // step by step buildup
         TableQuery q = table.where().equalTo(new long[]{0}, 1); // valid
         q.findAll();
         q.or();                                                 // not valid
-        try { q.findAll();     fail("no start group"); }         catch (UnsupportedOperationException e) { }
+        try { q.findAll();     fail("no start group"); }         catch (UnsupportedOperationException ignore) { }
         q.equalTo(new long[]{0}, 100);                          // valid again
         q.findAll();
         q.equalTo(new long[]{0}, 200);                          // still valid
@@ -123,14 +153,14 @@ public void testInvalidColumnIndexEqualTo() {
         try { query.equalTo(new long[]{10}, "a").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.equalTo(new long[]{-1}, "a", true).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", true).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", true).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, "a", Case.SENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, "a", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, "a", Case.SENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.equalTo(new long[]{-1}, "a", false).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", false).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", false).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, "a", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, "a", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, "a", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testInvalidColumnIndexNotEqualTo() {
@@ -165,14 +195,14 @@ public void testInvalidColumnIndexNotEqualTo() {
         try { query.notEqualTo(new long[]{10}, "a").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.notEqualTo(new long[]{-1}, "a", true).findAll(); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", true).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", true).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, "a", Case.SENSITIVE).findAll(); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, "a", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, "a", Case.SENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.notEqualTo(new long[]{-1}, "a", false).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", false).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", false).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, "a", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, "a", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, "a", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -320,21 +350,21 @@ public void testInvalidColumnIndexContains() {
         try { query.contains(new long[]{10}, "hey").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.contains(new long[]{-1}, "hey", true).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", true).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", true).findAll(); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, "hey", Case.SENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, "hey", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, "hey", Case.SENSITIVE).findAll(); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.contains(new long[]{-1}, "hey", false).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", false).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", false).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, "hey", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, "hey", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, "hey", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testNullInputQuery() {
         Table t = new Table();
-        t.addColumn(ColumnType.DATE, "dateCol");
-        t.addColumn(ColumnType.STRING, "stringCol");
-        
+        t.addColumn(RealmFieldType.DATE, "dateCol");
+        t.addColumn(RealmFieldType.STRING, "stringCol");
+
         Date nullDate = null;
         try { t.where().equalTo(new long[]{0}, nullDate);               fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().notEqualTo(new long[]{0}, nullDate);            fail("Date is null"); } catch (IllegalArgumentException e) { }
@@ -345,29 +375,29 @@ public void testNullInputQuery() {
         try { t.where().between(new long[]{0}, nullDate, new Date());   fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().between(new long[]{0}, new Date(), nullDate);   fail("Date is null"); } catch (IllegalArgumentException e) { }
         try { t.where().between(new long[]{0}, nullDate, nullDate);     fail("Dates are null"); } catch (IllegalArgumentException e) { }
-        
+
         String nullString = null;
-        try { t.where().equalTo(new long[]{1}, nullString);             fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().equalTo(new long[]{1}, nullString, false);      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString);          fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString, false);   fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString);            fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString, false);     fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString);          fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString, false);   fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString);            fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString, false);     fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{1}, nullString);                         fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{1}, nullString, Case.INSENSITIVE);       fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().notEqualTo(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().notEqualTo(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().contains(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().contains(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().beginsWith(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().beginsWith(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().endsWith(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().endsWith(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
     }
 
 
-    
+
     public void testShouldFind() {
         // Create a table
         Table table = new Table();
 
-        table.addColumn(ColumnType.STRING, "username");
-        table.addColumn(ColumnType.INTEGER, "score");
-        table.addColumn(ColumnType.BOOLEAN, "completed");
+        table.addColumn(RealmFieldType.STRING, "username");
+        table.addColumn(RealmFieldType.INTEGER, "score");
+        table.addColumn(RealmFieldType.BOOLEAN, "completed");
 
         // Insert some values
         table.add("Arnold", 420, false);    // 0
@@ -404,7 +434,7 @@ public void testShouldFind() {
     }
 
 
-    
+
     public void testQueryTestForNoMatches() {
         Table t = new Table();
         t = TestHelper.getTableWithAllColumnTypes();
@@ -418,7 +448,7 @@ public void testQueryTestForNoMatches() {
     }
 
 
-    
+
     public void testQueryWithWrongDataType() {
 
         Table table = TestHelper.getTableWithAllColumnTypes();
@@ -498,7 +528,7 @@ public void testQueryWithWrongDataType() {
         */
     }
 
-    
+
     public void testColumnIndexOutOfBounds() {
         Table table = TestHelper.getTableWithAllColumnTypes();
 
@@ -622,14 +652,14 @@ public void testColumnIndexOutOfBounds() {
         try { query.equalTo(new long[]{9}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
     }
 
-    
+
     public void testQueryOnView() {
         Table table = new Table();
 
         // Specify the column types and names
-        table.addColumn(ColumnType.STRING, "firstName");
-        table.addColumn(ColumnType.STRING, "lastName");
-        table.addColumn(ColumnType.INTEGER, "salary");
+        table.addColumn(RealmFieldType.STRING, "firstName");
+        table.addColumn(RealmFieldType.STRING, "lastName");
+        table.addColumn(RealmFieldType.INTEGER, "salary");
 
         // Add data to the table
         table.add("John", "Lee", 10000);
@@ -649,14 +679,14 @@ public void testQueryOnView() {
         assertEquals(1, view3.size());
     }
 
-    
-    public void testQueryOnViewWithalreadyQueriedTable() {
+
+    public void testQueryOnViewWithAlreadyQueriedTable() {
         Table table = new Table();
 
         // Specify the column types and names
-        table.addColumn(ColumnType.STRING, "firstName");
-        table.addColumn(ColumnType.STRING, "lastName");
-        table.addColumn(ColumnType.INTEGER, "salary");
+        table.addColumn(RealmFieldType.STRING, "firstName");
+        table.addColumn(RealmFieldType.STRING, "lastName");
+        table.addColumn(RealmFieldType.INTEGER, "salary");
 
         // Add data to the table
         table.add("John", "Lee", 10000);
@@ -673,17 +703,17 @@ public void testQueryOnViewWithalreadyQueriedTable() {
     }
 
 
-    
+
     public void testQueryWithSubtable() {
         Table table = new Table();
-        table.addColumn(ColumnType.STRING, "username");
-        table.addColumn(ColumnType.TABLE, "tasks");
-        table.addColumn(ColumnType.STRING, "username2");
+        table.addColumn(RealmFieldType.STRING, "username");
+        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "tasks");
+        table.addColumn(RealmFieldType.STRING, "username2");
 
         TableSchema tasks = table.getSubtableSchema(1);
-        tasks.addColumn(ColumnType.STRING, "name");
-        tasks.addColumn(ColumnType.INTEGER, "score");
-        tasks.addColumn(ColumnType.BOOLEAN, "completed");
+        tasks.addColumn(RealmFieldType.STRING, "name");
+        tasks.addColumn(RealmFieldType.INTEGER, "score");
+        tasks.addColumn(RealmFieldType.BOOLEAN, "completed");
 
         // Insert some values
         table.add("Arnold", new Object[][] {{"task1", 120, false},
@@ -699,46 +729,141 @@ public void testQueryWithSubtable() {
         assertEquals(2, view.size());
     }
 
-    
+
     public void testQueryWithUnbalancedSubtable() {
         Table table = new Table();
-        table.addColumn(ColumnType.TABLE, "sub");
-        
+        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
+
         TableSchema tasks = table.getSubtableSchema(0);
-        tasks.addColumn(ColumnType.STRING, "name");
-        
+        tasks.addColumn(RealmFieldType.STRING, "name");
+
         try { table.where().subtable(0).count();               assert(false); } catch (UnsupportedOperationException e) {}
         try { table.where().endSubtable().count();             assert(false); } catch (UnsupportedOperationException e) {}
         try { table.where().endSubtable().subtable(0).count(); assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().subtable(0).endSubtable().count(); assert(false); } catch (UnsupportedOperationException e) {} 
+        try { table.where().subtable(0).endSubtable().count(); assert(false); } catch (UnsupportedOperationException e) {}
     }
 
-    
+
     public void testMaximumDate() {
 
         Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
+        table.addColumn(RealmFieldType.DATE, "date");
 
         table.add(new Date(0));
         table.add(new Date(10000));
         table.add(new Date(1000));
 
         assertEquals(new Date(10000), table.where().maximumDate(0));
-
     }
 
-    
+
     public void testMinimumDate() {
 
         Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
+        table.addColumn(RealmFieldType.DATE, "date");
 
         table.add(new Date(10000));
         table.add(new Date(0));
         table.add(new Date(1000));
 
         assertEquals(new Date(0), table.where().minimumDate(0));
-
     }
 
+    public void testDateQuery() throws Exception {
+
+        Table table = new Table();
+        table.addColumn(RealmFieldType.DATE, "date");
+
+        final Date past = new Date(TimeUnit.SECONDS.toMillis(Integer.MIN_VALUE - 100L));
+        final Date future = new Date(TimeUnit.SECONDS.toMillis(Integer.MAX_VALUE + 1L));
+        final Date distantPast = new Date(Long.MIN_VALUE);
+        final Date distantFuture = new Date(Long.MAX_VALUE);
+
+        table.add(new Date(10000));
+        table.add(new Date(0));
+        table.add(new Date(1000));
+        table.add(future);
+        table.add(distantFuture);
+        table.add(past);
+        table.add(distantPast);
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, distantPast).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantPast).count());
+        assertEquals(0L, table.where().lessThan(new long[]{0}, distantPast).count());
+        assertEquals(1L, table.where().lessThanOrEqual(new long[]{0}, distantPast).count());
+        assertEquals(6L, table.where().greaterThan(new long[]{0}, distantPast).count());
+        assertEquals(7L, table.where().greaterThanOrEqual(new long[]{0}, distantPast).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, past).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, past).count());
+        assertEquals(1L, table.where().lessThan(new long[]{0}, past).count());
+        assertEquals(2L, table.where().lessThanOrEqual(new long[]{0}, past).count());
+        assertEquals(5L, table.where().greaterThan(new long[]{0}, past).count());
+        assertEquals(6L, table.where().greaterThanOrEqual(new long[]{0}, past).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, new Date(0)).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, new Date(0)).count());
+        assertEquals(2L, table.where().lessThan(new long[]{0}, new Date(0)).count());
+        assertEquals(3L, table.where().lessThanOrEqual(new long[]{0}, new Date(0)).count());
+        assertEquals(4L, table.where().greaterThan(new long[]{0}, new Date(0)).count());
+        assertEquals(5L, table.where().greaterThanOrEqual(new long[]{0}, new Date(0)).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, future).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, future).count());
+        assertEquals(5L, table.where().lessThan(new long[]{0}, future).count());
+        assertEquals(6L, table.where().lessThanOrEqual(new long[]{0}, future).count());
+        assertEquals(1L, table.where().greaterThan(new long[]{0}, future).count());
+        assertEquals(2L, table.where().greaterThanOrEqual(new long[]{0}, future).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, distantFuture).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantFuture).count());
+        assertEquals(6L, table.where().lessThan(new long[]{0}, distantFuture).count());
+        assertEquals(7L, table.where().lessThanOrEqual(new long[]{0}, distantFuture).count());
+        assertEquals(0L, table.where().greaterThan(new long[]{0}, distantFuture).count());
+        assertEquals(1L, table.where().greaterThanOrEqual(new long[]{0}, distantFuture).count());
+
+        // between
+
+        assertEquals(1L, table.where().between(new long[]{0}, distantPast, distantPast).count());
+        assertEquals(2L, table.where().between(new long[]{0}, distantPast, past).count());
+        assertEquals(3L, table.where().between(new long[]{0}, distantPast, new Date(0)).count());
+        assertEquals(5L, table.where().between(new long[]{0}, distantPast, new Date(10000)).count());
+        assertEquals(6L, table.where().between(new long[]{0}, distantPast, future).count());
+        assertEquals(7L, table.where().between(new long[]{0}, distantPast, distantFuture).count());
+
+        assertEquals(0L, table.where().between(new long[]{0}, past, distantPast).count());
+        assertEquals(1L, table.where().between(new long[]{0}, past, past).count());
+        assertEquals(2L, table.where().between(new long[]{0}, past, new Date(0)).count());
+        assertEquals(4L, table.where().between(new long[]{0}, past, new Date(10000)).count());
+        assertEquals(5L, table.where().between(new long[]{0}, past, future).count());
+        assertEquals(6L, table.where().between(new long[]{0}, past, distantFuture).count());
+
+        assertEquals(0L, table.where().between(new long[]{0}, new Date(0), distantPast).count());
+        assertEquals(0L, table.where().between(new long[]{0}, new Date(0), past).count());
+        assertEquals(1L, table.where().between(new long[]{0}, new Date(0), new Date(0)).count());
+        assertEquals(3L, table.where().between(new long[]{0}, new Date(0), new Date(10000)).count());
+        assertEquals(4L, table.where().between(new long[]{0}, new Date(0), future).count());
+        assertEquals(5L, table.where().between(new long[]{0}, new Date(0), distantFuture).count());
+
+        assertEquals(0L, table.where().between(new long[]{0}, new Date(10000), distantPast).count());
+        assertEquals(0L, table.where().between(new long[]{0}, new Date(10000), past).count());
+        assertEquals(0L, table.where().between(new long[]{0}, new Date(10000), new Date(0)).count());
+        assertEquals(1L, table.where().between(new long[]{0}, new Date(10000), new Date(10000)).count());
+        assertEquals(2L, table.where().between(new long[]{0}, new Date(10000), future).count());
+        assertEquals(3L, table.where().between(new long[]{0}, new Date(10000), distantFuture).count());
+
+        assertEquals(0L, table.where().between(new long[]{0}, future, distantPast).count());
+        assertEquals(0L, table.where().between(new long[]{0}, future, past).count());
+        assertEquals(0L, table.where().between(new long[]{0}, future, new Date(0)).count());
+        assertEquals(0L, table.where().between(new long[]{0}, future, new Date(10000)).count());
+        assertEquals(1L, table.where().between(new long[]{0}, future, future).count());
+        assertEquals(2L, table.where().between(new long[]{0}, future, distantFuture).count());
+
+        assertEquals(0L, table.where().between(new long[]{0}, distantFuture, distantPast).count());
+        assertEquals(0L, table.where().between(new long[]{0}, distantFuture, past).count());
+        assertEquals(0L, table.where().between(new long[]{0}, distantFuture, new Date(0)).count());
+        assertEquals(0L, table.where().between(new long[]{0}, distantFuture, new Date(10000)).count());
+        assertEquals(0L, table.where().between(new long[]{0}, distantFuture, future).count());
+        assertEquals(1L, table.where().between(new long[]{0}, distantFuture, distantFuture).count());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
new file mode 100644
index 0000000000..96f6c359d6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.test.MoreAsserts;
+
+import junit.framework.TestCase;
+
+import java.util.Date;
+
+import io.realm.RealmFieldType;
+
+public class JNIRowTest extends TestCase {
+
+    public void testRow() {
+
+        Table table = new Table();
+
+        table.addColumn(RealmFieldType.STRING, "string");
+        table.addColumn(RealmFieldType.INTEGER, "integer");
+        table.addColumn(RealmFieldType.FLOAT, "float");
+        table.addColumn(RealmFieldType.DOUBLE, "double");
+        table.addColumn(RealmFieldType.BOOLEAN, "boolean");
+        table.addColumn(RealmFieldType.DATE, "date");
+        table.addColumn(RealmFieldType.BINARY, "binary");
+
+
+        byte[] data = new byte[2];
+
+        table.add("abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
+
+
+        UncheckedRow row = table.getUncheckedRow(0);
+
+        assertEquals("abc", row.getString(0));
+        assertEquals(3, row.getLong(1));
+        assertEquals((float) 1.2, row.getFloat(2), 0.0001);
+        assertEquals(1.3, row.getDouble(3));
+        assertEquals(true, row.getBoolean(4));
+        assertEquals(new Date(0), row.getDate(5));
+        MoreAsserts.assertEquals(data, row.getBinaryByteArray(6));
+
+
+        row.setString(0, "a");
+        row.setLong(1, 1);
+        row.setFloat(2, (float) 8.8);
+        row.setDouble(3, 9.9);
+        row.setBoolean(4, false);
+        row.setDate(5, new Date(10000));
+
+        byte[] newData = new byte[3];
+        row.setBinaryByteArray(6, newData);
+
+        assertEquals("a", row.getString(0));
+        assertEquals(1, row.getLong(1));
+        assertEquals((float) 8.8, row.getFloat(2), 0.0001);
+        assertEquals(9.9, row.getDouble(3));
+        assertEquals(false, row.getBoolean(4));
+        assertEquals(new Date(10000), row.getDate(5));
+        MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
+    }
+
+    public void testMixed() {
+        Table table = new Table();
+
+        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
+
+        table.addEmptyRows(2);
+
+        UncheckedRow row = table.getUncheckedRow(0);
+        row.setMixed(0, new Mixed(1.5));
+
+        assertEquals(1.5, row.getMixed(0).getDoubleValue());
+
+        UncheckedRow row2 = table.getUncheckedRow(1);
+        row2.setMixed(0, new Mixed("test"));
+
+        assertEquals("test", row2.getMixed(0).getStringValue());
+
+
+    }
+
+    public void testNull() {
+
+        Table table = new Table();
+
+        long colStringIndex = table.addColumn(RealmFieldType.STRING, "string", true);
+        long colIntIndex = table.addColumn(RealmFieldType.INTEGER, "integer", true);
+        table.addColumn(RealmFieldType.FLOAT, "float");
+        table.addColumn(RealmFieldType.DOUBLE, "double");
+        long colBoolIndex = table.addColumn(RealmFieldType.BOOLEAN, "boolean", true);
+        table.addColumn(RealmFieldType.DATE, "date");
+        table.addColumn(RealmFieldType.BINARY, "binary");
+
+        long rowIndex = table.addEmptyRow();
+        UncheckedRow row = table.getUncheckedRow(rowIndex);
+
+        row.setString(colStringIndex, "test");
+        assertEquals(row.getString(colStringIndex), "test");
+        row.setNull(colStringIndex);
+        assertNull(row.getString(colStringIndex));
+
+        row.setLong(colIntIndex, 1);
+        assertFalse(row.isNull(colIntIndex));
+        row.setNull(colIntIndex);
+        assertTrue(row.isNull(colIntIndex));
+
+        row.setBoolean(colBoolIndex, true);
+        assertFalse(row.isNull(colBoolIndex));
+        row.setNull(colBoolIndex);
+        assertTrue(row.isNull(colBoolIndex));
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
similarity index 62%
rename from realm/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
index 43b3303b4b..4272b7599e 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
@@ -1,15 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
+import io.realm.RealmFieldType;
+
 public class JNISortedLongTest extends TestCase {
     Table table;
     TableView view;
 
     void init() {
         table = new Table();
-        table.addColumn(ColumnType.INTEGER, "number");
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.INTEGER, "number");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         table.add(1, "A");
         table.add(10, "B");
@@ -39,7 +57,7 @@ public void testShouldTestSortedIntTable() {
         assertEquals(4, table.lowerBoundLong(0, 40));
         assertEquals(5, table.upperBoundLong(0, 40));
 
-        // find mindle (nonexisting)
+        // find middle (nonexisting)
         assertEquals(5, table.lowerBoundLong(0, 41));
         assertEquals(5, table.upperBoundLong(0, 41));
 
diff --git a/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
similarity index 63%
rename from realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
index a56d0718f0..50a3650938 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
@@ -1,7 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
+import io.realm.RealmFieldType;
+
 public class JNISubtableTest extends TestCase {
 
     public void testShouldSynchronizeNestedTables() throws Throwable {
@@ -9,10 +27,10 @@ public void testShouldSynchronizeNestedTables() throws Throwable {
         Table table = group.getTable("emp");
 
         TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.STRING, "name");
+        tableSpec.addColumn(RealmFieldType.STRING, "name");
 
         TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(ColumnType.INTEGER, "num");
+        subspec.addColumn(RealmFieldType.INTEGER, "num");
 
         table.updateFromSpec(tableSpec);
 
@@ -37,12 +55,12 @@ public void testShouldInsertNestedTablesNested() {
 
         // Define table
         TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.STRING, "name");
+        tableSpec.addColumn(RealmFieldType.STRING, "name");
 
         TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(ColumnType.INTEGER, "num");
+        subspec.addColumn(RealmFieldType.INTEGER, "num");
 
-        tableSpec.addColumn(ColumnType.INTEGER, "Int");
+        tableSpec.addColumn(RealmFieldType.INTEGER, "Int");
         table.updateFromSpec(tableSpec);
 
         // Insert values
@@ -58,8 +76,8 @@ public void testShouldReturnSubtableIfNullIsInsertedAsSubtable() {
         Group group = new Group();
         Table table = group.getTable("emp");
 
-        table.addColumn(ColumnType.STRING, "string");
-        long subtableColIndex = table.addColumn(ColumnType.TABLE, "table");
+        table.addColumn(RealmFieldType.STRING, "string");
+        long subtableColIndex = table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         table.add("val", null);
         assertEquals(0,  table.getSubtable(subtableColIndex, 0).getColumnCount());
@@ -69,7 +87,7 @@ public void testGetSubtableOutOfRange() {
         Group group = new Group();
         Table table = group.getTable("emp");
 
-        table.addColumn(ColumnType.TABLE, "table");
+        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         // No rows added
         try { 
@@ -100,10 +118,10 @@ public void testSubtableSort() {
         Group group = new Group();
         Table table = group.getTable("emp");
 
-        table.addColumn(ColumnType.TABLE, "table");
+        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
         TableSchema subSchema = table.getSubtableSchema(0);
-        long subtableIntColIndex = subSchema.addColumn(ColumnType.INTEGER, "int col");
-        long subtableStringColIndex = subSchema.addColumn(ColumnType.STRING, "string col");
+        long subtableIntColIndex = subSchema.addColumn(RealmFieldType.INTEGER, "int col");
+        long subtableStringColIndex = subSchema.addColumn(RealmFieldType.STRING, "string col");
 
         table.addEmptyRow();
 
@@ -124,18 +142,18 @@ public void testAddColumnsToSubtables() {
 
         // Table definition
         Table persons = new Table();
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         // Add a subtable
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(ColumnType.INTEGER, "number");
+        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
 
         // Inserting data
         persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
@@ -156,34 +174,34 @@ public void testSubtableAddColumnsCheckNames() {
         // Table definition
         Table persons = new Table();
 
-        persons.addColumn(ColumnType.TABLE, "sub");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
 
         TableSchema addresses = persons.getSubtableSchema(0);
         try {
-            addresses.addColumn(ColumnType.STRING, "I am 64 chracters...............................................");
-            fail("Only 63 chracters supported"); }
+            addresses.addColumn(RealmFieldType.STRING, "I am 64 characters..............................................");
+            fail("Only 63 characters supported"); }
         catch (IllegalArgumentException e) {
             assertNotNull(e);
         }
 
-        addresses.addColumn(ColumnType.STRING, "I am 63 chracters..............................................");
+        addresses.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
     }
 
     public void testRemoveColumnFromSubtable() {
 
         // Table definition
         Table persons = new Table();
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(ColumnType.INTEGER, "number");
+        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
 
         // Inserting data
         persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
@@ -198,18 +216,18 @@ public void testRenameColumnInSubtable() {
 
         // Table definition
         Table persons = new Table();
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         // Define subtable
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(ColumnType.INTEGER, "number");
+        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
 
         // Inserting data
         persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
@@ -223,24 +241,24 @@ public void testRenameColumnInSubtable() {
     public void testShouldThrowOnGetSubtableDefinitionFromSubtable() {
         // Table definition
         Table persons = new Table();
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(ColumnType.INTEGER, "number");
+        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
 
         // Inserting data
         persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
 
         try {
             // Should throw
-            persons.getSubtable(2,0).addColumn(ColumnType.INTEGER, "i");
+            persons.getSubtable(2,0).addColumn(RealmFieldType.INTEGER, "i");
             fail("expected exception.");
         } catch (UnsupportedOperationException e) {
             assertNotNull(e);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
new file mode 100644
index 0000000000..675a46ac1f
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.test.MoreAsserts;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+@RunWith(Parameterized.class)
+public class JNITableInsertTest {
+
+    List<Object> value = new ArrayList<Object>();
+
+    @Parameterized.Parameters
+    public static Collection<Object[]> parameters() {
+        List<Object> value = new ArrayList<Object>();
+        value.add(0, true);
+        value.add(1, "abc");
+        value.add(2, 123L);
+        value.add(3, 987.123f);
+        value.add(4, 1234567.898d);
+        value.add(5, new Date(645342));
+        value.add(6, new byte[]{1, 2, 3, 4, 5});
+        return Arrays.asList(
+                new Object[]{value},
+                new Object[]{value}
+        );
+    }
+
+    public JNITableInsertTest(List<Object> value) {
+        this.value = value;
+    }
+
+    public void verifyRow(Table tbl, long rowIndex, Object[] values) {
+        assertTrue((Boolean) (values[0]) == tbl.getBoolean(0, rowIndex));
+        assertEquals(((Number) values[1]).longValue(), tbl.getLong(1, rowIndex));
+        assertEquals((String) values[2], tbl.getString(2, rowIndex));
+        if (values[3] instanceof byte[])
+            MoreAsserts.assertEquals((byte[]) values[3], tbl.getBinaryByteArray(3, rowIndex));
+        assertEquals(((Date) values[4]).getTime() / 1000, tbl.getDate(4, rowIndex).getTime() / 1000);
+
+        //      Mixed mix1 = Mixed.mixedValue(values[5]);
+        //      Mixed mix2 =  tbl.getMixed(5, rowIndex);
+        // TODO:        assertTrue(mix1.equals(mix2));
+
+        Table subtable = tbl.getSubtable(6, rowIndex);
+        Object[] subValues = (Object[]) values[6];
+        for (long i = 0; i < subtable.size(); i++) {
+            Object[] val = (Object[]) subValues[(int) i];
+            assertTrue(((Number) val[0]).longValue() == subtable.getLong(0, i));
+            assertEquals(((String) val[1]), subtable.getString(1, i));
+        }
+        assertTrue(tbl.isValid());
+    }
+
+    @Test
+    public void testShouldThrowExceptionWhenColumnNameIsTooLong() {
+
+        Table table = new Table();
+        try {
+            table.addColumn(RealmFieldType.STRING, "THIS STRING HAS 64 CHARACTERS, "
+                    + "LONGER THAN THE MAX 63 CHARACTERS");
+            fail("Too long name");
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void testWhenColumnNameIsExactly63CharLong() {
+
+        Table table = new Table();
+        table.addColumn(RealmFieldType.STRING, "THIS STRING HAS 63 CHARACTERS PERFECT FOR THE MAX 63 CHARACTERS");
+    }
+
+    @Test
+    public void testGenericAddOnTable() {
+        for (int i = 0; i < value.size(); i++) {
+            for (int j = 0; j < value.size(); j++) {
+
+                Table t = new Table();
+
+                //If the objects matches no exception will be thrown
+                if (value.get(i).getClass().equals(value.get(j).getClass())) {
+                    assertTrue(true);
+
+                } else {
+                    //Add column
+                    t.addColumn(TestHelper.getColumnType(value.get(j)), value.get(j).getClass().getSimpleName());
+                    //Add value
+                    try {
+                        t.add(value.get(i));
+                        fail("No matching type");
+                    } catch (IllegalArgumentException e) {
+                    }
+                }
+            }
+        }
+    }
+
+}
+
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITableSpecTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
similarity index 77%
rename from realm/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
index ccf0d44c74..8eeb871773 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
@@ -13,34 +13,41 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.realm.internal;
 
-import junit.framework.Test;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
 
+import io.realm.RealmFieldType;
 import io.realm.internal.test.ColumnTypeData;
 
-public class JNITableSpecTest extends TestCase {
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class JNITableSpecTest {
 
     TableSpec spec, spec2 = new TableSpec();
     Table table = new Table();
     ColumnTypeData columnTypeData = new ColumnTypeData(null);
 
+    @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
-
         return Arrays.asList(
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.INTEGER)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.FLOAT)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.DOUBLE)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.BOOLEAN)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.STRING)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.BINARY)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.MIXED)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(ColumnType.TABLE)}
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.INTEGER)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.FLOAT)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.DOUBLE)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BOOLEAN)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.STRING)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BINARY)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_MIXED)},
+                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_TABLE)}
         );
     }
 
@@ -52,6 +59,7 @@ public JNITableSpecTest(TableSpec spec, TableSpec spec2,
         this.columnTypeData = columnTypeData;
     }
 
+    @Test
     public void testShouldDefineOneColumnTable() {
         spec.addColumn(columnTypeData.type, "foo");
         assertEquals(0, spec.getColumnIndex("foo"));
@@ -69,6 +77,7 @@ public void checkSpecIdentity(TableSpec spec, TableSpec spec2) {
         assertEquals(spec.hashCode(), spec2.hashCode());
     }
 
+    @Test
     public void testShouldDefineTwoColumnsTable() {
         TableSpec subSpec = spec.addSubtableColumn("bar");
         subSpec.addColumn(columnTypeData.type, "subbar");
@@ -85,30 +94,31 @@ public void testShouldDefineTwoColumnsTable() {
         table.updateFromSpec(spec);
     }
 
+    @Test
     public void testShouldHandleColumnsDynamically() {
-        table.addColumn(ColumnType.INTEGER, "0");
+        table.addColumn(RealmFieldType.INTEGER, "0");
         assertEquals(1, table.getColumnCount());
         assertEquals(0, table.getColumnIndex("0"));
         assertEquals("0", table.getColumnName(0));
-        assertEquals(ColumnType.INTEGER, table.getColumnType(0));
+        assertEquals(RealmFieldType.INTEGER, table.getColumnType(0));
         table.add(23);
 
-        table.addColumn(ColumnType.FLOAT, "1");
+        table.addColumn(RealmFieldType.FLOAT, "1");
         table.add(11, 11.1f);
-        table.addColumn(ColumnType.DOUBLE, "2");
+        table.addColumn(RealmFieldType.DOUBLE, "2");
         table.add(22, 22.2f, -22.2);
-        table.addColumn(ColumnType.BOOLEAN, "3");
+        table.addColumn(RealmFieldType.BOOLEAN, "3");
         table.add(33, 33.3f, -33.3, true);
-        table.addColumn(ColumnType.STRING, "4");
+        table.addColumn(RealmFieldType.STRING, "4");
         table.add(44, 44.4f, -44.4, true, "44");
-        table.addColumn(ColumnType.DATE, "5");
+        table.addColumn(RealmFieldType.DATE, "5");
         Date date = new Date();
         table.add(55, 55.5f, -55.5, false, "55", date);
-        table.addColumn(ColumnType.BINARY, "6");
+        table.addColumn(RealmFieldType.BINARY, "6");
         table.add(66, 66.6f, -66.6, false, "66", date, new byte[]{6});
-        table.addColumn(ColumnType.MIXED, "7");
+        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "7");
         table.add(77, 77.7f, -77.7, true, "77", date, new byte[]{7, 7}, "mix");
-        table.addColumn(ColumnType.TABLE, "8");
+        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "8");
         table.add(88, 88.8f, -88.8, false, "88", date, new byte[]{8, 8, 8}, "mixed", null);
 
         table.addEmptyRows(10);
@@ -167,25 +177,25 @@ public void removeColumnsTest(Table table) {
         assertEquals("44", table.getString(0, 4));
     }
 
+    @Test
     public void testShouldThrowOnUpdateFromTableSpecOnSubtable() {
-
         // Table definition
         Table persons = new Table();
 
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         persons.add(new Object[]{"Mr X", "xx@xxxx.com", new Object[][]{{"X Street", 1234, null}}});
 
         Table address = persons.getSubtable(2, 0);
 
-        spec.addColumn(ColumnType.INTEGER, "foo");
+        spec.addColumn(RealmFieldType.INTEGER, "foo");
 
         try {
             address.updateFromSpec(spec);
@@ -193,9 +203,5 @@ public void testShouldThrowOnUpdateFromTableSpecOnSubtable() {
         } catch (UnsupportedOperationException e) {
         }
     }
-
-    public static Test suite() {
-        return new JNITestSuite(JNITableSpecTest.class, parameters());
-    }
 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
new file mode 100644
index 0000000000..5bc96014e0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -0,0 +1,627 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.test.AndroidTestCase;
+
+import java.io.File;
+import java.util.Date;
+
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+import io.realm.TestHelper;
+
+public class JNITableTest extends AndroidTestCase {
+
+    Table t;
+
+    Table createTestTable() {
+        Table t = new Table();
+        return t;
+    }
+
+    @Override
+    public void setUp() {
+        t = createTestTable();
+    }
+
+    public void testTableToString() {
+        Table t = new Table();
+
+        t.addColumn(RealmFieldType.STRING, "stringCol");
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
+
+        t.add("s1", 1, true);
+        t.add("s2", 2, false);
+
+        String expected =
+"    stringCol  intCol  boolCol\n" +
+"0:  s1              1     true\n" +
+"1:  s2              2    false\n" ;
+
+        assertEquals(expected, t.toString());
+    }
+
+    public void testRowOperationsOnZeroRow(){
+
+        Table t = new Table();
+        // Remove rows without columns
+        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+
+        // Column added, remove rows again
+        t.addColumn(RealmFieldType.STRING, "");
+        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+
+    }
+
+    public void testZeroColOperations() {
+        Table tableZeroCols = new Table();
+
+        // Add rows
+        try { tableZeroCols.add("val");         fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
+        try { tableZeroCols.addEmptyRow();      fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
+        try { tableZeroCols.addEmptyRows(10);   fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
+
+
+        // Col operations
+        try { tableZeroCols.removeColumn(0);                fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { tableZeroCols.renameColumn(0, "newName");     fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { tableZeroCols.removeColumn(10);               fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+    }
+
+    public void testFindFirstNonExisting() {
+        Table t = TestHelper.getTableWithAllColumnTypes();
+        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+
+        assertEquals(-1, t.findFirstBoolean(1, false));
+        assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
+        assertEquals(-1, t.findFirstDouble(3, 1.0d));
+        assertEquals(-1, t.findFirstFloat(4, 1.0f));
+        assertEquals(-1, t.findFirstLong(5, 50));
+        assertEquals(-1, t.findFirstString(7, "other string"));
+    }
+
+    public void testFindFirst() {
+        final int TEST_SIZE = 10;
+        Table t = TestHelper.getTableWithAllColumnTypes();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            t.add(new byte[]{1,2,3}, true, new Date(1000*i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
+        }
+        t.add(new byte[]{1, 2, 3}, true, new Date(1000 * TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
+
+        assertEquals(0, t.findFirstBoolean(1, true));
+        for (int i = 0; i < TEST_SIZE; i++) {
+            assertEquals(i, t.findFirstDate(2, new Date(1000*i)));
+            assertEquals(i, t.findFirstDouble(3, (double) i));
+            assertEquals(i, t.findFirstFloat(4, (float) i));
+            assertEquals(i, t.findFirstLong(5, i));
+            assertEquals(i, t.findFirstString(7, "string " + i));
+        }
+
+        assertEquals(TEST_SIZE, t.findFirstString(7, ""));
+
+        try {
+            t.findFirstString(7, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {}
+
+        try {
+            t.findFirstDate(2, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {}
+    }
+
+
+    public void testGetValuesFromNonExistingColumn() {
+        Table t = TestHelper.getTableWithAllColumnTypes();
+        t.addEmptyRows(10);
+
+        try { t.getBinaryByteArray(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getBinaryByteArray(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getBinaryByteArray(9, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getBoolean(-1, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getBoolean(-10, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getBoolean(9, 0);                   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getDate(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getDate(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getDate(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getDouble(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getDouble(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getDouble(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getFloat(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getFloat(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getFloat(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getLong(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getMixed(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getMixed(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getMixed(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+        try { t.getSubtable(-1, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getSubtable(-10, 0);                fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getSubtable(9, 0);                  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+    }
+
+    public void testGetNonExistingColumn() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.INTEGER, "int");
+
+        assertEquals(-1, t.getColumnIndex("non-existing column"));
+        try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException ignored) { }
+    }
+
+
+    public void testGetSortedView() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.INTEGER, "");
+        t.addColumn(RealmFieldType.STRING, "");
+        t.addColumn(RealmFieldType.DOUBLE, "");
+
+        t.add(1, "s", 1000d);
+        t.add(3,"sss", 10d);
+        t.add(2, "ss", 100d);
+
+
+        // Check the order is as it is added
+        assertEquals(1, t.getLong(0, 0));
+        assertEquals(3, t.getLong(0, 1));
+        assertEquals(2, t.getLong(0, 2));
+        assertEquals("s", t.getString(1, 0));
+        assertEquals("sss", t.getString(1, 1));
+        assertEquals("ss", t.getString(1, 2));
+        assertEquals(1000d, t.getDouble(2, 0));
+        assertEquals(10d, t.getDouble(2, 1));
+        assertEquals(100d, t.getDouble(2, 2));
+
+        // Get the sorted view on first column
+        TableView v = t.getSortedView(0);
+
+        // Check the new order
+        assertEquals(1, v.getLong(0, 0));
+        assertEquals(2, v.getLong(0, 1));
+        assertEquals(3, v.getLong(0, 2));
+        assertEquals("s", v.getString(1, 0));
+        assertEquals("ss", v.getString(1, 1));
+        assertEquals("sss", v.getString(1, 2));
+        assertEquals(1000d, v.getDouble(2, 0));
+        assertEquals(100d, v.getDouble(2, 1));
+        assertEquals(10d, v.getDouble(2, 2));
+
+        // Get the sorted view on first column descending
+        v = t.getSortedView(0, Sort.DESCENDING);
+
+        // Check the new order
+        assertEquals(3, v.getLong(0, 0));
+        assertEquals(2, v.getLong(0, 1));
+        assertEquals(1, v.getLong(0, 2));
+        assertEquals("sss", v.getString(1, 0));
+        assertEquals("ss", v.getString(1, 1));
+        assertEquals("s", v.getString(1, 2));
+        assertEquals(10d, v.getDouble(2, 0));
+        assertEquals(100d, v.getDouble(2, 1));
+        assertEquals(1000d, v.getDouble(2, 2));
+
+        // Some out of bounds test cases
+        try { t.getSortedView(-1, Sort.DESCENDING);    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getSortedView(-100, Sort.DESCENDING);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try { t.getSortedView(100, Sort.DESCENDING);   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+
+    }
+
+    public void testSetNulls() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.STRING, "");
+        t.addColumn(RealmFieldType.DATE, "");
+        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "");
+        t.addColumn(RealmFieldType.BINARY, "");
+        t.add("String val", new Date(), new Mixed(""), new byte[]{1, 2, 3});
+
+        try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
+        try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
+    }
+
+    public void testAddNegativeEmptyRows() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.STRING, "colName");
+
+        try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
+    }
+
+    public void testAddNullInMixedColumn() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
+        t.add(new Mixed(true));
+
+        try { t.setMixed(0, 0, null); fail("Argument is null"); } catch (IllegalArgumentException ignored) { }
+    }
+
+    public void testImmutableInsertNotAllowed() {
+
+        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
+        String TABLENAME = "tableName";
+
+        new File(FILENAME).delete();
+        new File(FILENAME+".lock").delete();
+        SharedGroup group = new SharedGroup(FILENAME);
+
+        // Write transaction must be run so we are sure a db exists with the correct table
+        WriteTransaction wt = group.beginWrite();
+        try {
+            Table table = wt.getTable(TABLENAME);
+            table.addColumn(RealmFieldType.STRING, "col0");
+            table.add("value0");
+            table.add("value1");
+            table.add("value2");
+
+            wt.commit();
+        } catch (Throwable t) {
+            wt.rollback();
+        }
+
+        ReadTransaction rt = group.beginRead();
+        try {
+            Table table = rt.getTable(TABLENAME);
+
+            try {
+                table.addEmptyRow();
+                fail("Exception expected when inserting in read transaction");
+            } catch (IllegalStateException ignored) {
+            }
+
+        } finally {
+            rt.endRead();
+        }
+    }
+
+    public void testGetName() {
+        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
+        String TABLENAME = "tableName";
+
+        new File(FILENAME).delete();
+        new File(FILENAME+".lock").delete();
+        SharedGroup group = new SharedGroup(FILENAME);
+
+        // Write transaction must be run so we are sure a db exists with the correct table
+        WriteTransaction wt = group.beginWrite();
+        try {
+            wt.getTable(TABLENAME);
+            wt.commit();
+        } catch (Throwable t) {
+            wt.rollback();
+        }
+
+        ReadTransaction rt = group.beginRead();
+        Table table = rt.getTable(TABLENAME);
+        assertEquals(TABLENAME, table.getName());
+    }
+
+    public void testShouldThrowWhenSetIndexOnWrongRealmFieldType() {
+        for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
+
+            // All types supported addSearchIndex and removeSearchIndex
+            boolean exceptionExpected = (
+                            t.getColumnType(colIndex) != RealmFieldType.STRING &&
+                            t.getColumnType(colIndex) != RealmFieldType.INTEGER &&
+                            t.getColumnType(colIndex) != RealmFieldType.BOOLEAN &&
+                            t.getColumnType(colIndex) != RealmFieldType.DATE);
+
+            // Try to addSearchIndex()
+            try {
+                t.addSearchIndex(colIndex);
+                if (exceptionExpected) {
+                    fail("Expected exception for colIndex " + colIndex);
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+            // Try to removeSearchIndex()
+            try {
+                // Currently core will do nothing if the column doesn't have a search index
+                t.removeSearchIndex(colIndex);
+                if (exceptionExpected) {
+                    fail("Expected exception for colIndex " + colIndex);
+                }
+            } catch (IllegalArgumentException ignored) {
+            }
+
+
+            // Try to hasSearchIndex() for all columnTypes
+            t.hasSearchIndex(colIndex);
+        }
+    }
+
+    public void testColumnName() {
+        Table t = new Table();
+        try { t.addColumn(RealmFieldType.STRING, "I am 64 characters.............................................."); fail("Only 63 characters supported"); } catch (IllegalArgumentException ignored) { }
+        t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
+    }
+
+    public void testTableNumbers() {
+        Table t = new Table();
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.DOUBLE, "doubleCol");
+        t.addColumn(RealmFieldType.FLOAT, "floatCol");
+        t.addColumn(RealmFieldType.STRING, "StringCol");
+
+        // Add 3 rows of data with same values in each column
+        t.add(1, 2.0d, 3.0f, "s1");
+        t.add(1, 2.0d, 3.0f, "s1");
+        t.add(1, 2.0d, 3.0f, "s1");
+
+        // Add other values
+        t.add(10, 20.0d, 30.0f, "s10");
+        t.add(100, 200.0d, 300.0f, "s100");
+        t.add(1000, 2000.0d, 3000.0f, "s1000");
+
+        // Count instances of values added in the first 3 rows
+        assertEquals(3, t.count(0, 1));
+        assertEquals(3, t.count(1, 2.0d));
+        assertEquals(3, t.count(2, 3.0f));
+        assertEquals(3, t.count(3, "s1"));
+
+        assertEquals(3, t.findAllDouble(1, 2.0d).size());
+        assertEquals(3, t.findAllFloat(2, 3.0f).size());
+
+        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1
+        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2
+
+        // Set double and float
+        t.setDouble(1, 2, -2.0d);
+        t.setFloat(2, 2, -3.0f);
+
+        // Get double tests
+        assertEquals(-2.0d, t.getDouble(1, 2));
+        assertEquals(20.0d, t.getDouble(1, 3));
+        assertEquals(200.0d, t.getDouble(1, 4));
+        assertEquals(2000.0d, t.getDouble(1, 5));
+
+        // Get float test
+        assertEquals(-3.0f, t.getFloat(2, 2));
+        assertEquals(30.0f, t.getFloat(2, 3));
+        assertEquals(300.0f, t.getFloat(2, 4));
+        assertEquals(3000.0f, t.getFloat(2, 5));
+    }
+
+    public void testMaximumDate() {
+
+        Table table = new Table();
+        table.addColumn(RealmFieldType.DATE, "date");
+
+        table.add(new Date(0));
+        table.add(new Date(10000));
+        table.add(new Date(1000));
+
+        assertEquals(new Date(10000), table.maximumDate(0));
+
+    }
+
+    public void testMinimumDate() {
+
+        Table table = new Table();
+        table.addColumn(RealmFieldType.DATE, "date");
+
+        table.add(new Date(10000));
+        table.add(new Date(0));
+        table.add(new Date(1000));
+
+        assertEquals(new Date(0), table.minimumDate(0));
+
+    }
+
+    // testing the migration of a string column to be nullable.
+    public void testConvertToNullable() {
+        RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
+                RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
+        for (RealmFieldType columnType : columnTypes) {
+            // testing various combinations of column names and nullability
+            String[] columnNames = {"foobar", "__TMP__0"};
+            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
+                for (String columnName : columnNames) {
+                    Table table = new Table();
+                    long colIndex = table.addColumn(columnType, columnName, nullable);
+                    table.addColumn(RealmFieldType.BOOLEAN, "bool");
+                    table.addEmptyRow();
+                    if (columnType == RealmFieldType.BOOLEAN) {
+                        table.setBoolean(colIndex, 0, true);
+                    } else if (columnType == RealmFieldType.DATE) {
+                        table.setDate(colIndex, 0, new Date(0));
+                    } else if (columnType == RealmFieldType.DOUBLE) {
+                        table.setDouble(colIndex, 0, 1.0);
+                    } else if (columnType == RealmFieldType.FLOAT) {
+                        table.setFloat(colIndex, 0, 1.0f);
+                    } else if (columnType == RealmFieldType.INTEGER) {
+                        table.setLong(colIndex, 0, 1);
+                    } else if (columnType == RealmFieldType.BINARY) {
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                    } else if (columnType == RealmFieldType.STRING) {
+                        table.setString(colIndex, 0, "Foo");
+                    }
+                    try {
+                        table.addEmptyRow();
+                        if (columnType == RealmFieldType.BINARY) {
+                            table.setBinaryByteArray(colIndex, 1, null);
+                        } else if (columnType == RealmFieldType.STRING) {
+                            table.setString(colIndex, 1, null);
+                        } else {
+                            table.getCheckedRow(1).setNull(colIndex);
+                        }
+
+                        if (!nullable) {
+                            fail();
+                        }
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    table.removeLast();
+                    assertEquals(1, table.size());
+
+                    table.convertColumnToNullable(colIndex);
+                    assertTrue(table.isColumnNullable(colIndex));
+                    assertEquals(1, table.size());
+                    assertEquals(2, table.getColumnCount());
+                    assertTrue(table.getColumnIndex(columnName) >= 0);
+                    assertEquals(colIndex, table.getColumnIndex(columnName));
+
+                    table.addEmptyRow();
+                    if (columnType == RealmFieldType.BINARY) {
+                        table.setBinaryByteArray(colIndex, 0, null);
+                    } else if (columnType == RealmFieldType.STRING) {
+                        table.setString(colIndex, 0, null);
+                    } else {
+                        table.getCheckedRow(0).setNull(colIndex);
+                    }
+
+                    assertEquals(2, table.size());
+
+                    if (columnType == RealmFieldType.BINARY) {
+                        assertNull(table.getBinaryByteArray(colIndex, 1));
+                    } else if (columnType == RealmFieldType.STRING) {
+                        assertNull(table.getString(colIndex, 1));
+                    } else {
+                        assertTrue(table.getUncheckedRow(1).isNull(colIndex));
+                    }
+                }
+            }
+        }
+    }
+
+    public void testConvertToNotNullable() {
+        RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
+                RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
+        for (RealmFieldType columnType : columnTypes) {
+            // testing various combinations of column names and nullability
+            String[] columnNames = {"foobar", "__TMP__0"};
+            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
+                for (String columnName : columnNames) {
+                    Table table = new Table();
+                    long colIndex = table.addColumn(columnType, columnName, nullable);
+                    table.addColumn(RealmFieldType.BOOLEAN, "bool");
+                    table.addEmptyRow();
+                    if (columnType == RealmFieldType.BOOLEAN)
+                        table.setBoolean(colIndex, 0, true);
+                    else if (columnType == RealmFieldType.DATE)
+                        table.setDate(colIndex, 0, new Date(1));
+                    else if (columnType == RealmFieldType.DOUBLE)
+                        table.setDouble(colIndex, 0, 1.0);
+                    else if (columnType == RealmFieldType.FLOAT)
+                        table.setFloat(colIndex, 0, 1.0f);
+                    else if (columnType == RealmFieldType.INTEGER)
+                        table.setLong(colIndex, 0, 1);
+                    else if (columnType == RealmFieldType.BINARY)
+                        table.setBinaryByteArray(colIndex, 0, new byte[]{0});
+                    else if (columnType == RealmFieldType.STRING)
+                        table.setString(colIndex, 0, "Foo");
+                    try {
+                        table.addEmptyRow();
+                        if (columnType == RealmFieldType.BINARY) {
+                            table.setBinaryByteArray(colIndex, 1, null);
+                        } else if (columnType == RealmFieldType.STRING) {
+                            table.setString(colIndex, 1, null);
+                        } else {
+                            table.getCheckedRow(1).setNull(colIndex);
+                        }
+
+                        if (!nullable) {
+                            fail();
+                        }
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    assertEquals(2, table.size());
+
+                    table.convertColumnToNotNullable(colIndex);
+                    assertFalse(table.isColumnNullable(colIndex));
+                    assertEquals(2, table.size());
+                    assertEquals(2, table.getColumnCount());
+                    assertTrue(table.getColumnIndex(columnName) >= 0);
+                    assertEquals(colIndex, table.getColumnIndex(columnName));
+
+                    table.addEmptyRow();
+                    try {
+                        if (columnType == RealmFieldType.BINARY) {
+                            table.setBinaryByteArray(colIndex, 0, null);
+                        } else if (columnType == RealmFieldType.STRING) {
+                            table.setString(colIndex, 0, null);
+                        } else {
+                            table.getCheckedRow(0).setNull(colIndex);
+                        }
+                        if (!nullable) {
+                            fail();
+                        }
+                    } catch (IllegalArgumentException ignored) {
+                    }
+                    table.removeLast();
+                    assertEquals(2, table.size());
+
+                    if (columnType == RealmFieldType.BINARY) {
+                        assertNotNull(table.getBinaryByteArray(colIndex, 1));
+                    } else if (columnType == RealmFieldType.STRING) {
+                        assertNotNull(table.getString(colIndex, 1));
+                        assertEquals("", table.getString(colIndex, 1));
+                    } else {
+                        assertFalse(table.getUncheckedRow(1).isNull(colIndex));
+                        if (columnType == RealmFieldType.BOOLEAN)
+                            assertEquals(false, table.getBoolean(colIndex, 1));
+                        else if (columnType == RealmFieldType.DATE)
+                            assertEquals(0, table.getDate(colIndex, 1).getTime());
+                        else if (columnType == RealmFieldType.DOUBLE)
+                            assertEquals(0.0, table.getDouble(colIndex, 1));
+                        else if (columnType == RealmFieldType.FLOAT)
+                            assertEquals(0.0f, table.getFloat(colIndex, 1));
+                        else if (columnType == RealmFieldType.INTEGER)
+                            assertEquals(0, table.getLong(colIndex, 1));
+                    }
+                }
+            }
+        }
+    }
+
+    // migrating an mixed column to be nullable is not supported
+    public void testConvertMixedToNullable() {
+        Table table = new Table();
+        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed", Table.NOT_NULLABLE);
+        try {
+            table.convertColumnToNullable(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    // add column and read back if it is nullable or not
+    public void testIsNullable() {
+        Table table = new Table();
+        table.addColumn(RealmFieldType.STRING, "string1", Table.NOT_NULLABLE);
+        table.addColumn(RealmFieldType.STRING, "string2", Table.NULLABLE);
+
+        assertFalse(table.isColumnNullable(0));
+        assertTrue(table.isColumnNullable(1));
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
similarity index 64%
rename from realm/src/androidTest/java/io/realm/internal/JNITransactions.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
index 8d6cfb1fe3..91a9f5660b 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -1,48 +1,69 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import android.test.AndroidTestCase;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.List;
 
 import io.realm.Realm;
-import io.realm.TestHelper;
+import io.realm.RealmFieldType;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNITransactions extends AndroidTestCase {
-    
-    String testFile;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
-    @Override
-    protected void setUp() throws Exception {
-        createDBFileName();
-    }
+@RunWith(AndroidJUnit4.class)
+public class JNITransactions {
 
-    @Override
-    public void tearDown() throws IOException {
-        deleteFile(testFile);
-    }
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    protected void deleteFile(String filename) throws IOException {
-        for (String filePath : Arrays.asList(filename, filename + ".lock")) {
-            File f = new File(filePath);
-            if (f.exists()) {
-                boolean result = f.delete();
-                if (!result) {
-                    throw new java.io.IOException("Could not delete " + filePath);
-                }
-            }
-        }
+    private String testFile;
+    private android.content.Context context;
+
+    @Before
+    public void setUp() throws Exception {
+        testFile = new File(
+                configFactory.getRoot(),
+                System.currentTimeMillis() + "_transact.realm").getAbsolutePath();
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+        RealmCore.loadLibrary(context);
     }
 
     private Table getTableWithStringPrimaryKey() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         WriteTransaction trans = db.beginWrite();
         Table t = trans.getTable("TestTable");
-        t.addColumn(ColumnType.STRING, "colName");
+        t.addColumn(RealmFieldType.STRING, "colName");
         t.setPrimaryKey("colName");
         return t;
     }
@@ -51,22 +72,16 @@ private Table getTableWithIntegerPrimaryKey() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         WriteTransaction trans = db.beginWrite();
         Table t = trans.getTable("TestTable");
-        t.addColumn(ColumnType.INTEGER, "colName");
+        t.addColumn(RealmFieldType.INTEGER, "colName");
         t.setPrimaryKey("colName");
         return t;
     }
 
-    private void createDBFileName(){
-        testFile = new File(
-                this.getContext().getFilesDir(),
-                System.currentTimeMillis() + "_transact.realm").toString();
-    }
-
     protected void writeOneTransaction(SharedGroup db, long rows) {
         WriteTransaction trans = db.beginWrite();
         Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(ColumnType.STRING, "name");
-        tbl.addColumn(ColumnType.INTEGER, "number");
+        tbl.addColumn(RealmFieldType.STRING, "name");
+        tbl.addColumn(RealmFieldType.INTEGER, "number");
 
 
         for (long row=0; row < rows; row++)
@@ -95,20 +110,22 @@ protected void checkRead(SharedGroup db, int rows) {
 
     // TODO: tests should be done both for all Durability options
 
-    public void testMustWriteAndReadEmpty() {
+    @Test
+    public void mustWriteAndReadEmpty() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         writeOneTransaction(db, 0);
         checkRead(db, 0);
     }
 
-    public void testMustWriteCommit() {
+    @Test
+    public void mustWriteCommit() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         writeOneTransaction(db, 10);
         checkRead(db, 10);
     }
 
-
-    public void testShouldThrowExceptionAfterClosedReadTransaction() {
+    @Test
+    public void shouldThrowExceptionAfterClosedReadTransaction() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         writeOneTransaction(db, 10);
         ReadTransaction rt = db.beginRead();
@@ -119,17 +136,15 @@ public void testShouldThrowExceptionAfterClosedReadTransaction() {
             try {
                 tbl.getColumnCount(); //Should throw exception, the table is invalid when transaction has been closed
                 fail();
-            } catch (IllegalStateException e) {
-                assert(false);
-                //assertNotNull(e);
+            } catch (IllegalStateException ignored) {
             }
         } finally {
             rt.endRead();
         }
     }
 
-
-    public void testShouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
+    @Test
+    public void shouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         writeOneTransaction(db, 10);
         ReadTransaction rt = db.beginRead();
@@ -138,7 +153,7 @@ public void testShouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
             Table tbl = rt.getTable("EmployeeTable");
             rt.endRead();
             try {
-                tbl.addColumn(ColumnType.STRING, "newString"); //Should throw exception, as adding a column is not allowed in read transaction
+                tbl.addColumn(RealmFieldType.STRING, "newString"); //Should throw exception, as adding a column is not allowed in read transaction
                 fail();
             } catch (IllegalStateException e) {
                 //assertNotNull(e);
@@ -148,8 +163,8 @@ public void testShouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
         }
     }
 
-
-    public void testShouldThrowExceptionWhenWritingInReadTrans() {
+    @Test
+    public void shouldThrowExceptionWhenWritingInReadTrans() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         ReadTransaction rt = db.beginRead();
 
@@ -165,14 +180,14 @@ public void testShouldThrowExceptionWhenWritingInReadTrans() {
         }
     }
 
-
-    public void testOnlyOneCommit() {
+    @Test
+    public void onlyOneCommit() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         WriteTransaction trans = db.beginWrite();
 
         try {
             Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(ColumnType.STRING, "name");
+            tbl.addColumn(RealmFieldType.STRING, "name");
             trans.commit();
             try {
                 trans.commit(); // should throw
@@ -186,7 +201,8 @@ public void testOnlyOneCommit() {
         }
     }
 
-    public void testMustRollback() {
+    @Test
+    public void mustRollback() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         writeOneTransaction(db, 1);
         WriteTransaction trans = db.beginWrite();
@@ -199,13 +215,14 @@ public void testMustRollback() {
         checkRead(db, 1); // Only 1 row now.
     }
 
-    public void testMustAllowDoubleCommitAndRollback() {
+    @Test
+    public void mustAllowDoubleCommitAndRollback() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
         {
             WriteTransaction trans = db.beginWrite();
             Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(ColumnType.STRING, "name");
-            tbl.addColumn(ColumnType.INTEGER, "number");
+            tbl.addColumn(RealmFieldType.STRING, "name");
+            tbl.addColumn(RealmFieldType.INTEGER, "number");
 
             // allow commit before any changes
             assertEquals(0, tbl.size());
@@ -236,7 +253,8 @@ public void testMustAllowDoubleCommitAndRollback() {
     // Test: above in custom Typed Tables
     // TableQuery.... in ReadTransactions
 
-    public void testMustFailOnWriteInReadTransactions() {
+    @Test
+    public void mustFailOnWriteInReadTransactions() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
 
         writeOneTransaction(db, 1);
@@ -244,11 +262,8 @@ public void testMustFailOnWriteInReadTransactions() {
         ReadTransaction t = db.beginRead();
         Table table = t.getTable("EmployeeTable");
 
-        try { table.addAt(0, 0, false);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.add(0, false);                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.addEmptyRow();                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.addEmptyRows(1);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.adjust(0,0);                    fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.clear();                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.clearSubtable(0,0);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.optimize();                     fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -268,7 +283,6 @@ public void testMustFailOnWriteInReadTransactions() {
         try { q.remove(0,0);                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
 
         TableView v = q.findAll();
-        try { v.adjust(0, 0);                       fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.clear();                            fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.clearSubtable(0, 0);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.remove(0);                          fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -284,19 +298,20 @@ public void testMustFailOnWriteInReadTransactions() {
     }
 
     // Test that primary key constraints are actually removed
-    public void testRemovingPrimaryKeyRemovesConstraint() {
+    @Test
+    public void removingPrimaryKeyRemovesConstraint() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
 
         WriteTransaction trans = db.beginWrite();
         Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(ColumnType.STRING, "name");
-        tbl.addColumn(ColumnType.INTEGER, "number");
+        tbl.addColumn(RealmFieldType.STRING, "name");
+        tbl.addColumn(RealmFieldType.INTEGER, "number");
         tbl.setPrimaryKey("name");
 
         tbl.add("Foo", 42);
         try {
             tbl.add("Foo", 41);
-        } catch (RealmException e1) {
+        } catch (RealmPrimaryKeyConstraintException e1) {
             // Primary key check worked, now remove it and try again.
             tbl.setPrimaryKey("");
             try {
@@ -311,12 +326,13 @@ public void testRemovingPrimaryKeyRemovesConstraint() {
     }
 
     // Test that primary key constraints are actually removed
-    public void testRemovingPrimaryKeyRemovesConstraint_typeSetters() {
+    @Test
+    public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
 
         WriteTransaction trans = db.beginWrite();
         Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(ColumnType.STRING, "name");
+        tbl.addColumn(RealmFieldType.STRING, "name");
         tbl.setPrimaryKey("name");
 
         // Create first entry with name "foo"
@@ -325,7 +341,7 @@ public void testRemovingPrimaryKeyRemovesConstraint_typeSetters() {
         long rowIndex = tbl.addEmptyRow();
         try {
             tbl.setString(0, rowIndex, "Foo"); // Try to create 2nd entry with name Foo
-        } catch (RealmException e1) {
+        } catch (RealmPrimaryKeyConstraintException e1) {
             tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
             try {
                 tbl.setString(0, rowIndex, "Foo");
@@ -338,54 +354,104 @@ public void testRemovingPrimaryKeyRemovesConstraint_typeSetters() {
         fail("Primary key not enforced.");
     }
 
-    public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
         Table t = getTableWithStringPrimaryKey();
         try {
             t.addEmptyRowWithPrimaryKey(42);
             fail();
-        } catch (IllegalArgumentException expected) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-    public void testAddEmptyRowWithPrimaryKeyNullStringThrows() {
+    @Test
+    public void addEmptyRowWithPrimaryKeyNullStringThrows() {
         Table t = getTableWithStringPrimaryKey();
         try {
             t.addEmptyRowWithPrimaryKey(null);
             fail();
-        } catch (IllegalArgumentException expected) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-    public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
+    @Test
+    public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
         Table t = getTableWithIntegerPrimaryKey();
         try {
             t.addEmptyRowWithPrimaryKey("Foo");
             fail();
-        } catch (IllegalArgumentException expected) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-    public void testAddEmptyRowWithPrimaryKeyString() {
+    @Test
+    public void addEmptyRowWithPrimaryKeyString() {
         Table t = getTableWithStringPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
         assertEquals(1, t.size());
-        assertEquals("Foo", t.getRow(rowIndex).getString(0));
+        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
     }
 
-    public void testAddEmptyRowWithPrimaryKeyLong() {
+    @Test
+    public void addEmptyRowWithPrimaryKeyLong() {
         Table t = getTableWithIntegerPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey(42);
         assertEquals(1, t.size());
-        assertEquals(42, t.getRow(rowIndex).getLong(0));
+        assertEquals(42, t.getUncheckedRow(rowIndex).getLong(0));
+    }
+
+    @Test
+    public void firstPrimaryKeyTableMigration() throws IOException {
+        configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
+        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
+                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
+        ImplicitTransaction tr = db.beginImplicitTransaction();
+        Table t = tr.getTable("class_AnnotationTypes");
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertTrue(t.hasPrimaryKey());
+        assertEquals(RealmFieldType.STRING, tr.getTable("pk").getColumnType(0));
+        db.close();
     }
 
-    public void testPrimaryKeyTableMigration() throws IOException {
-        TestHelper.copyRealmFromAssets(getContext(), "080_annotationtypes.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
+    @Test
+    public void secondPrimaryKeyTableMigration() throws IOException {
+        configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
+        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
+                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
         ImplicitTransaction tr = db.beginImplicitTransaction();
         Table t = tr.getTable("class_AnnotationTypes");
         assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
         assertTrue(t.hasPrimaryKey());
+        assertEquals("AnnotationTypes", tr.getTable("pk").getString(0, 0));
+        db.close();
+    }
+
+    // See https://github.com/realm/realm-java/issues/1775 .
+    // Before 0.84.2, pk table added prefix "class_" to every class's name.
+    // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
+    // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
+    // "NClass", "Meclass" and etc..
+    // The 0841_pk_migration.realm is made to produce the issue.
+    @Test
+    public void primaryKeyTableMigratedWithRightName() throws IOException {
+        List<String> tableNames = Arrays.asList(
+                "ChatList", "Drafts", "Member", "Message", "Notifs", "NotifyLink", "PopularPost",
+                "Post", "Tags", "Threads", "User");
+
+        configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
+        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
+                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
+
+        ImplicitTransaction tr = db.beginImplicitTransaction();
+        // To trigger migratePrimaryKeyTableIfNeeded.
+        tr.getTable("class_ChatList").getPrimaryKey();
+
+        Table table =  tr.getTable("pk");
+        for (int i = 0; i < table.size(); i++) {
+            UncheckedRow row = table.getUncheckedRow(i);
+            // io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
+            assertTrue(tableNames.contains(row.getString(0)));
+        }
         db.close();
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
similarity index 87%
rename from realm/src/androidTest/java/io/realm/internal/JNIViewTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 0a185c9714..27d1aa48da 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import android.test.MoreAsserts;
@@ -6,7 +22,9 @@
 
 import java.util.Date;
 
-import io.realm.internal.test.TestHelper;
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+import io.realm.TestHelper;
 
 @SuppressWarnings("deprecation")
 public class JNIViewTest extends TestCase {
@@ -20,14 +38,14 @@
     public void setUp() {
         //Specify table
         t = new Table();
-        t.addColumn(ColumnType.STRING, "Name");
-        t.addColumn(ColumnType.BOOLEAN,   "Study");
-        t.addColumn(ColumnType.INTEGER,    "Age");
-        t.addColumn(ColumnType.DATE,   "Birthday");
+        t.addColumn(RealmFieldType.STRING, "Name");
+        t.addColumn(RealmFieldType.BOOLEAN,   "Study");
+        t.addColumn(RealmFieldType.INTEGER,    "Age");
+        t.addColumn(RealmFieldType.DATE,   "Birthday");
 
         // Add unsupported column types
-        t.addColumn(ColumnType.MIXED,  "Unsupported3");
-        t.addColumn(ColumnType.TABLE,  "Unsupported4");
+        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED,  "Unsupported3");
+        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE,  "Unsupported4");
 
         //Add data
         t.add("cc", true,  24, date1, 0, null);
@@ -79,7 +97,7 @@ public void testShouldSortViewIntegers() {
         assertEquals("dd", view.getString(0, 3));
 
         //Sort descending - creating a new view
-        view.sort(2, TableView.Order.descending);
+        view.sort(2, Sort.DESCENDING);
         assertEquals(35, view.getLong(2, 0));
         assertEquals(24, view.getLong(2, 1));
         assertEquals(22, view.getLong(2, 2));
@@ -88,7 +106,7 @@ public void testShouldSortViewIntegers() {
 
         //Sort ascending.
         TableView view2 = t.where().findAll();
-        view2.sort(2, TableView.Order.ascending);
+        view2.sort(2, Sort.ASCENDING);
         assertEquals(22, view2.getLong(2, 0));
         assertEquals(22, view2.getLong(2, 1));
         assertEquals(24, view2.getLong(2, 2));
@@ -107,7 +125,7 @@ public void testShouldSortViewIntegers() {
     public void testSetBinary() {
 
         Table table = new Table();
-        table.addColumn(ColumnType.BINARY, "binary");
+        table.addColumn(RealmFieldType.BINARY, "binary");
 
         byte[] arr1 = new byte[] {1,2,3};
         table.add(new Object[]{arr1});
@@ -125,17 +143,17 @@ public void testSetBinary() {
 
     public void testSubtable() {
         Table persons = new Table();
-        persons.addColumn(ColumnType.STRING, "name");
-        persons.addColumn(ColumnType.STRING, "email");
-        persons.addColumn(ColumnType.TABLE, "addresses");
+        persons.addColumn(RealmFieldType.STRING, "name");
+        persons.addColumn(RealmFieldType.STRING, "email");
+        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
 
         TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(ColumnType.STRING, "street");
-        addresses.addColumn(ColumnType.INTEGER, "zipcode");
-        addresses.addColumn(ColumnType.TABLE, "phone_numbers");
+        addresses.addColumn(RealmFieldType.STRING, "street");
+        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
+        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
 
         TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(ColumnType.INTEGER, "number");
+        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
 
         // Inserting data
         persons.add("Mr X", "xx@xxxx.com",
@@ -222,9 +240,9 @@ public void testGetValuesFromNonExistingColumn() {
 
     public void testGetSourceRow() {
         Table t = new Table();
-        t.addColumn(ColumnType.STRING, "");
-        t.addColumn(ColumnType.INTEGER, "");
-        t.addColumn(ColumnType.BOOLEAN, "");
+        t.addColumn(RealmFieldType.STRING, "");
+        t.addColumn(RealmFieldType.INTEGER, "");
+        t.addColumn(RealmFieldType.BOOLEAN, "");
 
         t.add("1", 1, true);
         t.add("2", 2, true);
@@ -246,9 +264,9 @@ public void testGetSourceRow() {
 
     public void testGetSourceRowNoRows() {
         Table t = new Table();
-        t.addColumn(ColumnType.STRING, "");
-        t.addColumn(ColumnType.INTEGER, "");
-        t.addColumn(ColumnType.BOOLEAN, "");
+        t.addColumn(RealmFieldType.STRING, "");
+        t.addColumn(RealmFieldType.INTEGER, "");
+        t.addColumn(RealmFieldType.BOOLEAN, "");
         // No data is added
         TableView v = t.where().findAll();
 
@@ -298,7 +316,7 @@ public void testShouldThrowExceptionForUnsupportedColumns() {
 
     public void testShouldSearchByColumnValue() {
         Table table = new Table();
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         table.add("Foo");
         table.add("Bar");
@@ -312,7 +330,7 @@ public void testShouldSearchByColumnValue() {
 
     public void testShouldQueryInView() {
         Table table = new Table();
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         table.add("A1");
         table.add("B");
@@ -333,14 +351,14 @@ public void testShouldQueryInView() {
 
     public void testGetNonExistingColumn() {
         Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "int");
+        t.addColumn(RealmFieldType.INTEGER, "int");
         TableView view = t.where().findAll();
         assertEquals(-1, view.getColumnIndex("non-existing column"));
     }
 
     public void testGetNullColumn() {
         Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "");
+        t.addColumn(RealmFieldType.INTEGER, "");
         TableView view = t.where().findAll();
         try { view.getColumnIndex(null); fail("Getting null column"); } catch(IllegalArgumentException e) { }
     }
@@ -348,9 +366,9 @@ public void testGetNullColumn() {
 
     public void testViewToString() {
         Table t = new Table();
-        t.addColumn(ColumnType.STRING, "stringCol");
-        t.addColumn(ColumnType.INTEGER, "intCol");
-        t.addColumn(ColumnType.BOOLEAN, "boolCol");
+        t.addColumn(RealmFieldType.STRING, "stringCol");
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
 
         t.add("s1", 1, true);
         t.add("s2", 2, false);
@@ -407,7 +425,7 @@ void accessingViewMustThrow(TableView view)
 
     public void testViewShouldInvalidate() {
         Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
         t.add(1);
         t.add(2);
         t.add(3);
@@ -436,7 +454,7 @@ public void testViewShouldInvalidate() {
     public void testMaximumDate() {
 
         Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
+        table.addColumn(RealmFieldType.DATE, "date");
 
         table.add(new Date(0));
         table.add(new Date(10000));
@@ -451,7 +469,7 @@ public void testMaximumDate() {
     public void testMinimumDate() {
 
         Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
+        table.addColumn(RealmFieldType.DATE, "date");
 
         table.add(new Date(10000));
         table.add(new Date(0));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
new file mode 100644
index 0000000000..e05e3ab8ef
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import junit.framework.TestCase;
+
+public class JNI_nativeTests extends TestCase {
+
+    public void testNativeExceptions() {
+        String expect = "";
+        for (Util.Testcase test : Util.Testcase.values()) {
+            expect = test.expectedResult(0);
+            try {
+                test.execute(0);
+            } catch (Exception e) {
+                assertEquals(expect, e.toString());
+            } catch (Error e) {
+                assertEquals(expect, e.toString());
+            }
+
+        }
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
similarity index 72%
rename from realm/src/androidTest/java/io/realm/internal/PivotTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
index 8485c1b1f0..6b5aa39009 100644
--- a/realm/src/androidTest/java/io/realm/internal/PivotTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
@@ -1,66 +1,84 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
+import io.realm.RealmFieldType;
 import io.realm.internal.TableOrView.PivotType;
 
 public class PivotTest extends TestCase {
 
-    Table t = new Table();
+    Table t;
     long colIndexSex;
     long colIndexAge;
     long colIndexHired;
-    
+
     @Override
-    public void setUp(){
-        colIndexSex = t.addColumn(ColumnType.STRING, "sex");
-        colIndexAge = t.addColumn(ColumnType.INTEGER, "age");
-        colIndexHired = t.addColumn(ColumnType.BOOLEAN, "hired");
-        
+    public void setUp() {
+        t = new Table();
+        colIndexSex = t.addColumn(RealmFieldType.STRING, "sex");
+        colIndexAge = t.addColumn(RealmFieldType.INTEGER, "age");
+        colIndexHired = t.addColumn(RealmFieldType.BOOLEAN, "hired");
+
         for (long i=0;i<50000;i++){
             String sex = i % 2 == 0 ? "Male" : "Female";
             t.add(sex, 20 + (i%20), true);
         }
     }
-    
+
     public void testPivotTable(){
-        
+
         Table resultCount = t.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
         assertEquals(2, resultCount.size());
         assertEquals(25000, resultCount.getLong(1, 0));
         assertEquals(25000, resultCount.getLong(1, 1));
-        
+
         Table resultMin = t.pivot(colIndexSex, colIndexAge, PivotType.MIN);
         assertEquals(20, resultMin.getLong(1, 0));
         assertEquals(21, resultMin.getLong(1, 1));
-        
+
         Table resultMax = t.pivot(colIndexSex, colIndexAge, PivotType.MAX);
         assertEquals(38, resultMax.getLong(1, 0));
         assertEquals(39, resultMax.getLong(1, 1));
-        
+
         try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
         try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
     }
-    
-    
+
+
     public void testPivotTableView(){
-        
+
         TableView view = t.getSortedView(colIndexAge);
-        
+
         Table resultCount = view.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
         assertEquals(2, resultCount.size());
         assertEquals(25000, resultCount.getLong(1, 0));
         assertEquals(25000, resultCount.getLong(1, 1));
-        
+
         Table resultMin = view.pivot(colIndexSex, colIndexAge, PivotType.MIN);
         assertEquals(20, resultMin.getLong(1, 0));
         assertEquals(21, resultMin.getLong(1, 1));
-        
+
         Table resultMax = view.pivot(colIndexSex, colIndexAge, PivotType.MAX);
         assertEquals(38, resultMax.getLong(1, 0));
         assertEquals(39, resultMax.getLong(1, 1));
-        
-        
+
+
         try { view.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
         try { view.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
     }
diff --git a/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
similarity index 80%
rename from realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index 5401792e45..d8587d2bc3 100644
--- a/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -1,14 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal;
 
 import junit.framework.TestCase;
 
+import io.realm.RealmFieldType;
+
 public class TableIndexAndDistinctTest extends TestCase {
     Table table;
 
     void init() {
         table = new Table();
-        table.addColumn(ColumnType.INTEGER, "number");
-        table.addColumn(ColumnType.STRING, "name");
+        table.addColumn(RealmFieldType.INTEGER, "number");
+        table.addColumn(RealmFieldType.STRING, "name");
 
         long i = 0;
         table.add(0, "A");
@@ -70,11 +88,11 @@ public void testShouldTestSettingIndexOnMultipleColumns() {
 
         //Create a table only with String type columns
         Table t = new Table();
-        t.addColumn(ColumnType.STRING, "col1");
-        t.addColumn(ColumnType.STRING, "col2");
-        t.addColumn(ColumnType.STRING, "col3");
-        t.addColumn(ColumnType.STRING, "col4");
-        t.addColumn(ColumnType.STRING, "col5");
+        t.addColumn(RealmFieldType.STRING, "col1");
+        t.addColumn(RealmFieldType.STRING, "col2");
+        t.addColumn(RealmFieldType.STRING, "col3");
+        t.addColumn(RealmFieldType.STRING, "col4");
+        t.addColumn(RealmFieldType.STRING, "col5");
         t.add("row1", "row2", "row3", "row4", "row5");
         t.add("row1", "row2", "row3", "row4", "row5");
         t.add("row1", "row2", "row3", "row4", "row5");
@@ -101,7 +119,7 @@ public void shouldTestIndexOnWrongColumnType(Long index) {
         Table t = TestHelper.getTableWithAllColumnTypes();
 
         //If column type is String, then throw the excepted exception
-        if (t.getColumnType(index).equals(ColumnType.STRING)){
+        if (t.getColumnType(index).equals(RealmFieldType.STRING)){
             throw new IllegalArgumentException();
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
new file mode 100644
index 0000000000..89539fc9fc
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import junit.framework.TestCase;
+
+import io.realm.RealmFieldType;
+
+public class TableSpecEqualityTest extends TestCase {
+
+    public void testShouldMatchIdenticalSimpleSpecs() {
+        TableSpec spec1 = new TableSpec();
+        spec1.addColumn(RealmFieldType.STRING, "foo");
+        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
+
+        TableSpec spec2 = new TableSpec();
+        spec2.addColumn(RealmFieldType.STRING, "foo");
+        spec2.addColumn(RealmFieldType.BOOLEAN, "bar");
+
+        assertTrue(spec1.equals(spec2));
+    }
+
+    public void testShouldntMatchSpecsWithDifferentColumnNames() {
+        TableSpec spec1 = new TableSpec();
+        spec1.addColumn(RealmFieldType.STRING, "foo");
+        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
+
+        TableSpec spec2 = new TableSpec();
+        spec2.addColumn(RealmFieldType.STRING, "foo");
+        spec2.addColumn(RealmFieldType.BOOLEAN, "bar2");
+
+        assertFalse(spec1.equals(spec2));
+    }
+
+    public void testShouldntMatchSpecsWithDifferentColumnTypes() {
+        TableSpec spec1 = new TableSpec();
+        spec1.addColumn(RealmFieldType.STRING, "foo");
+        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
+
+        TableSpec spec2 = new TableSpec();
+        spec2.addColumn(RealmFieldType.STRING, "foo");
+        spec2.addColumn(RealmFieldType.BINARY, "bar");
+
+        assertFalse(spec1.equals(spec2));
+    }
+
+    public void testShouldMatchDeepRecursiveIdenticalSpecs() {
+        TableSpec spec1 = new TableSpec();
+        spec1.addColumn(RealmFieldType.STRING, "foo");
+        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
+        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
+        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
+        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
+
+        TableSpec spec2 = new TableSpec();
+        spec2.addColumn(RealmFieldType.STRING, "foo");
+        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
+        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
+        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
+        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
+
+        assertTrue(spec1.equals(spec2));
+    }
+
+    public void testShouldNotMatchDeepRecursiveDifferentSpecs() {
+        TableSpec spec1 = new TableSpec();
+        spec1.addColumn(RealmFieldType.STRING, "foo");
+        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
+        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
+        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
+        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
+
+        TableSpec spec2 = new TableSpec();
+        spec2.addColumn(RealmFieldType.STRING, "foo");
+        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
+        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
+        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub2");
+        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
+
+        assertFalse(spec1.equals(spec2));
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java
new file mode 100644
index 0000000000..0fffbd9f57
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2015 FasterXML
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.android;
+
+import android.test.AndroidTestCase;
+
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * @see ISO8601Utils
+ * @see <a href="https://github.com/FasterXML/jackson-databind/blob/master/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java">Original Source</a>
+ */
+public class ISO8601UtilsTest extends AndroidTestCase {
+    private Date date;
+    private Date dateWithoutTime;
+    private Date dateZeroMillis;
+    private Date dateZeroSecondAndMillis;
+
+    @Override
+    public void setUp() {
+        Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);
+        cal.setTimeZone(TimeZone.getTimeZone("GMT"));
+        cal.set(Calendar.MILLISECOND, 789);
+        date = cal.getTime();
+        cal.set(Calendar.MILLISECOND, 0);
+        dateZeroMillis = cal.getTime();
+        cal.set(Calendar.SECOND, 0);
+        dateZeroSecondAndMillis = cal.getTime();
+
+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);
+        cal.set(Calendar.MILLISECOND, 0);
+        cal.setTimeZone(TimeZone.getTimeZone("GMT"));
+        dateWithoutTime = cal.getTime();
+
+    }
+
+    public void testParse() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("2007-08-13T19:51:23.789Z", new ParsePosition(0));
+        assertEquals(date, d);
+
+        d = ISO8601Utils.parse("2007-08-13T19:51:23Z", new ParsePosition(0));
+        assertEquals(dateZeroMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T21:51:23.789+02:00", new ParsePosition(0));
+        assertEquals(date, d);
+    }
+
+    public void testParseShortDate() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("20070813T19:51:23.789Z", new ParsePosition(0));
+        assertEquals(date, d);
+
+        d = ISO8601Utils.parse("20070813T19:51:23Z", new ParsePosition(0));
+        assertEquals(dateZeroMillis, d);
+
+        d = ISO8601Utils.parse("20070813T21:51:23.789+02:00", new ParsePosition(0));
+        assertEquals(date, d);
+    }
+
+    public void testParseShortTime() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("2007-08-13T195123.789Z", new ParsePosition(0));
+        assertEquals(date, d);
+
+        d = ISO8601Utils.parse("2007-08-13T195123Z", new ParsePosition(0));
+        assertEquals(dateZeroMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T215123.789+02:00", new ParsePosition(0));
+        assertEquals(date, d);
+    }
+
+    public void testParseShortDateTime() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("20070813T195123.789Z", new ParsePosition(0));
+        assertEquals(date, d);
+
+        d = ISO8601Utils.parse("20070813T195123Z", new ParsePosition(0));
+        assertEquals(dateZeroMillis, d);
+
+        d = ISO8601Utils.parse("20070813T215123.789+02:00", new ParsePosition(0));
+        assertEquals(date, d);
+    }
+
+    public void testParseWithoutTime() throws ParseException {
+        Date d = ISO8601Utils.parse("2007-08-13Z", new ParsePosition(0));
+        assertEquals(dateWithoutTime, d);
+
+        d = ISO8601Utils.parse("20070813Z", new ParsePosition(0));
+        assertEquals(dateWithoutTime, d);
+
+        d = ISO8601Utils.parse("2007-08-13+00:00", new ParsePosition(0));
+        assertEquals(dateWithoutTime, d);
+
+        d = ISO8601Utils.parse("20070813+00:00", new ParsePosition(0));
+        assertEquals(dateWithoutTime, d);
+    }
+
+    public void testParseOptional() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("2007-08-13T19:51Z", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T1951Z", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T21:51+02:00", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+    }
+
+    public void testParseRfc3339Examples() throws java.text.ParseException {
+        // Two digit milliseconds.
+        Date d = ISO8601Utils.parse("1985-04-12T23:20:50.52Z", new ParsePosition(0));
+        assertEquals(newDate(1985, 4, 12, 23, 20, 50, 520, 0), d);
+
+        d = ISO8601Utils.parse("1996-12-19T16:39:57-08:00", new ParsePosition(0));
+        assertEquals(newDate(1996, 12, 19, 16, 39, 57, 0, -8 * 60), d);
+
+        // Truncated leap second.
+        d = ISO8601Utils.parse("1990-12-31T23:59:60Z", new ParsePosition(0));
+        assertEquals(newDate(1990, 12, 31, 23, 59, 59, 0, 0), d);
+
+        // Truncated leap second.
+        d = ISO8601Utils.parse("1990-12-31T15:59:60-08:00", new ParsePosition(0));
+        assertEquals(newDate(1990, 12, 31, 15, 59, 59, 0, -8 * 60), d);
+
+        // Two digit milliseconds.
+        d = ISO8601Utils.parse("1937-01-01T12:00:27.87+00:20", new ParsePosition(0));
+        assertEquals(newDate(1937, 1, 1, 12, 0, 27, 870, 20), d);
+    }
+
+    public void testFractionalSeconds() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("1970-01-01T00:00:00.9Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 900, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.09Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 90, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.009Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 9, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.0009Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 0, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483647Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483648Z", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 0), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.9+02:00", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 900, 2 * 60), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.09+02:00", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 90, 2 * 60), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.009+02:00", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 9, 2 * 60), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.0009+02:00", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 0, 2 * 60), d);
+
+        d = ISO8601Utils.parse("1970-01-01T00:00:00.2147483648+02:00", new ParsePosition(0));
+        assertEquals(newDate(1970, 1, 1, 0, 0, 0, 214, 2 * 60), d);
+    }
+
+    public void testDecimalWithoutDecimalPointButNoFractionalSeconds() throws java.text.ParseException {
+        try {
+            ISO8601Utils.parse("1970-01-01T00:00:00.Z", new ParsePosition(0));
+            fail();
+        } catch (ParseException expected) {
+        }
+    }
+
+    private Date newDate(int year, int month, int day, int hour,
+                         int minute, int second, int millis, int timezoneOffsetMinutes) {
+        Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+        calendar.set(year, month - 1, day, hour, minute, second);
+        calendar.set(Calendar.MILLISECOND, millis);
+        return new Date(calendar.getTimeInMillis() - TimeUnit.MINUTES.toMillis(timezoneOffsetMinutes));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
new file mode 100644
index 0000000000..ce52c272cb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2015 FasterXML
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.android;
+
+import android.test.AndroidTestCase;
+
+import java.text.ParseException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+import io.realm.exceptions.RealmException;
+
+public class JsonUtilsTest extends AndroidTestCase {
+
+    public void testParseNullAndEmptyDateIsNull() {
+        Date output = JsonUtils.stringToDate(null);
+        assertNull("Null input should output a null date object", output);
+
+        output = JsonUtils.stringToDate("");
+        assertNull("Empty string input should output a null date object", output);
+    }
+
+    public void testParseMillisToDate() {
+        Date originalDate = Calendar.getInstance().getTime();
+        long dateTimeInMillis = originalDate.getTime();
+        Date output = JsonUtils.stringToDate(String.valueOf(dateTimeInMillis));
+
+        assertTrue("Dates should match", output.equals(originalDate));
+    }
+
+    public void testParseJsonDateToDate() {
+        String jsonDate = "/Date(1198908717056)/"; // 2007-12-27T23:11:57.056
+        Date output = JsonUtils.stringToDate(jsonDate);
+
+        assertEquals(output.getTime(), 1198908717056L);
+    }
+
+    public void testNegativeLongDate() {
+        long timeInMillis = -631152000L; // Jan 1, 1950
+        Date output = JsonUtils.stringToDate(String.valueOf(timeInMillis));
+
+        assertEquals("Should be Jan 1, 1950 in millis", timeInMillis, output.getTime());
+    }
+
+    public void testParseInvalidDateShouldThrowRealmException() {
+        String invalidLongDate = "123abc";
+        try {
+            Date d = JsonUtils.stringToDate(invalidLongDate);
+            fail("Should fail with a RealmException.");
+        } catch (RealmException e) {
+            assertNotNull(e);
+            assertTrue(e.getCause() instanceof ParseException);
+        }
+    }
+
+    public void testParseInvalidNumericDateShouldThrowRealmException() {
+        String invalidLongDate = "2342347289374398342759873495743"; // not a date.
+        try {
+            Date d = JsonUtils.stringToDate(invalidLongDate);
+            fail("Should fail with a RealmException.");
+        } catch (RealmException e) {
+            assertNotNull(e);
+            assertTrue(e.getCause() instanceof NumberFormatException);
+        }
+    }
+
+    public void testParseISO8601Dates() throws ParseException {
+        Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);
+        cal.setTimeZone(TimeZone.getTimeZone("GMT"));
+        cal.set(Calendar.MILLISECOND, 789);
+        Date date = cal.getTime();
+        cal.set(Calendar.MILLISECOND, 0);
+        Date dateZeroMillis = cal.getTime();
+        cal.set(Calendar.SECOND, 0);
+
+        // Parse date with short time and decimal second
+        Date d = JsonUtils.stringToDate("2007-08-13T195123.789Z");
+        assertEquals(date, d);
+
+        // Short time without decimal second
+        d = JsonUtils.stringToDate("2007-08-13T195123Z");
+        assertEquals(dateZeroMillis, d);
+
+        // GMT+2 with decimal second
+        d = JsonUtils.stringToDate("2007-08-13T215123.789+02:00");
+        assertEquals(date, d);
+
+        // Tests without time
+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);
+        cal.set(Calendar.MILLISECOND, 0);
+        cal.setTimeZone(TimeZone.getTimeZone("GMT"));
+        Date dateWithoutTime = cal.getTime();
+
+        // Date only with hyphens
+        d = JsonUtils.stringToDate("2007-08-13Z");
+        assertEquals(dateWithoutTime, d);
+
+        // Date, no hyphens
+        d = JsonUtils.stringToDate("20070813Z");
+        assertEquals(dateWithoutTime, d);
+
+        // Hyphenated Date with empty time
+        d = JsonUtils.stringToDate("2007-08-13+00:00");
+        assertEquals(dateWithoutTime, d);
+
+        // Non-hyphenated date with empty time
+        d = JsonUtils.stringToDate("20070813+00:00");
+        assertEquals(dateWithoutTime, d);
+
+        // Please see the ISO8601UtilsTest.java file for a full suite of ISO8601 tests
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
new file mode 100644
index 0000000000..7bc898b5c8
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.test;
+
+import io.realm.internal.DefineTable;
+
+/**
+ * A helper class containing model(s) for simple code generation tests.
+ */
+class CodeGenTest {
+
+    @DefineTable // this is enabled only for occasional local tests
+    class someModel {
+        String name;
+        int age;
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
similarity index 85%
rename from realm/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
index de54062ce6..e841f2daee 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.realm.internal.test;
 
-import io.realm.internal.ColumnType;
+import io.realm.RealmFieldType;
 
 public class ColumnTypeData {
 
-    public ColumnType type;
+    public RealmFieldType type;
 
-    public ColumnTypeData(ColumnType type) {
+    public ColumnTypeData(RealmFieldType type) {
         this.type = type;
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
new file mode 100644
index 0000000000..db78aa4ff6
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.test;
+
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+
+public class DataProviderUtil {
+
+    public static Iterator<Object[]> allCombinations(List<?>... lists) {
+        Iterator<Object[]> iterator = new VariationsIterator<Object>(Arrays.asList(lists));
+        return iterator;
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/EmployeeData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
similarity index 69%
rename from realm/src/androidTest/java/io/realm/internal/test/EmployeeData.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
index 9bcd215f38..e8436e35a6 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/EmployeeData.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.test;
 
 import java.nio.ByteBuffer;
diff --git a/realm/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
similarity index 62%
rename from realm/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
index e03f893365..d1f4c85453 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.test;
 
 import java.util.Date;
diff --git a/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
similarity index 86%
rename from realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
index 77660e48ec..3a422eaf09 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/ExtraTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/ExtraTests.java
@@ -1,7 +1,25 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.test;
 
 import java.lang.reflect.Array;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.fail;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
new file mode 100644
index 0000000000..3f748bef60
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.test;
+
+import io.realm.RealmFieldType;
+
+public class MixedData {
+
+    public RealmFieldType type;
+
+    public Object value;
+
+    public MixedData(RealmFieldType type, Object value) {
+        this.type = type;
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return "MixedData [type=" + type + ", value=" + value + "]";
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
new file mode 100644
index 0000000000..cbeb2c0c1b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.test;
+
+public class PhoneData {
+
+    public String type;
+    public String number;
+
+    public PhoneData(String type, String number) {
+        this.type = type;
+        this.number = number;
+    }
+
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/TestTableModel.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
similarity index 68%
rename from realm/src/androidTest/java/io/realm/internal/test/TestTableModel.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
index dbc1ebe2eb..51182615b5 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/TestTableModel.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.test;
 
 import java.util.Date;
diff --git a/realm/src/androidTest/java/io/realm/internal/test/TestValue.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
similarity index 99%
rename from realm/src/androidTest/java/io/realm/internal/test/TestValue.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
index 705b57dde4..d85661cc79 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/TestValue.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.realm.internal.test;
 
 public class TestValue {
diff --git a/realm/src/androidTest/java/io/realm/internal/test/VariationsIterator.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
similarity index 70%
rename from realm/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
index 5bf51f4422..03a7d85ab5 100644
--- a/realm/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.test;
 
 import java.util.Iterator;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
new file mode 100644
index 0000000000..95d5797a34
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/proxy/HandlerProxy.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.proxy;
+
+import android.os.Handler;
+import android.os.Message;
+
+import io.realm.HandlerController;
+
+/**
+ * Handler decorator, to help intercept some messages before they are sent and received.
+ */
+public abstract class HandlerProxy extends Handler {
+
+    private final HandlerController controller;
+
+    public HandlerProxy(HandlerController controller) {
+        if (null == controller) {
+            throw new IllegalArgumentException("non-null HandlerController required.");
+        }
+        this.controller = controller;
+    }
+
+    /**
+     * @see {@link Handler#postAtFrontOfQueue(Runnable)}
+     */
+    public void postAtFront(Runnable runnable) {
+        if (onInterceptOutMessage(0)) {
+            postAtFrontOfQueue(runnable);
+        }
+    }
+
+    @Override
+    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
+        boolean eventConsumed = onInterceptOutMessage(msg.what);
+        return !eventConsumed && super.sendMessageAtTime(msg, uptimeMillis);
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        boolean eventConsumed = onInterceptInMessage(msg.what);
+        if (!eventConsumed) {
+            controller.handleMessage(msg);
+        }
+    }
+
+    /**
+     * Intercepts a message as it is being posted. Return {@code false} to continue sending it. {@code true} to
+     * swallow it.
+     *
+     * This method will be executed on the thread sending the message.
+     *
+     * @return {@code true} if message should be swallowed. {@code false} to continue processing it.
+     */
+    protected boolean onInterceptOutMessage(int what) {
+        return false;
+    }
+
+    /**
+     * Intercepts a message as it is being received. Return {@code false} to let subclasses continue the handling.
+     * {@code true} to swallow it.
+     *
+     * This method will be executed on the thread of the Looper backing the Handler
+     *
+     * @return {@code true} if message should be swallowed. {@code false} to continue processing it.
+     */
+    protected boolean onInterceptInMessage(int what) {
+        return false;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
new file mode 100644
index 0000000000..29060837c0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.LinkedList;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.TestHelper;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Rule that runs the test inside a worker looper thread. This rule is responsible
+ * of creating a temp directory containing a Realm instance then delete it, once the test finishes.
+ *
+ * All Realms used in a method method annotated with {@code @RunTestInLooperThread } should use
+ * {@link RunInLooperThread#createConfiguration()} and friends to create their configurations. Failing to do so can
+ * result in the test failing because the Realm could not be deleted (Reason is that {@link TestRealmConfigurationFactory}
+ * and this class does not agree in which order to delete all open Realms.
+ */
+public class RunInLooperThread extends TestRealmConfigurationFactory {
+    public Realm realm;
+    public RealmConfiguration realmConfiguration;
+    private CountDownLatch signalTestCompleted;
+    private Handler backgroundHandler;
+
+    // the variables created inside the test are local and eligible for GC.
+    // but sometimes we need the variables to survive across different Looper
+    // events (Callbacks happening in the future), so we add a strong reference
+    // to them for the duration of the test.
+    public LinkedList<Object> keepStrongReference;
+
+    @Override
+    protected void before() throws Throwable {
+        super.before();
+        realmConfiguration = createConfiguration(UUID.randomUUID().toString());
+        signalTestCompleted = new CountDownLatch(1);
+        keepStrongReference = new LinkedList<Object>();
+    }
+
+    @Override
+    protected void after() {
+        super.after();
+        realmConfiguration = null;
+        realm = null;
+        keepStrongReference = null;
+    }
+
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        if (description.getAnnotation(RunTestInLooperThread.class) == null) {
+            return base;
+        }
+        return new Statement() {
+            private Throwable testException;
+
+            @Override
+            public void evaluate() throws Throwable {
+                before();
+                try {
+                    final CountDownLatch signalClosedRealm = new CountDownLatch(1);
+                    final Throwable[] threadAssertionError = new Throwable[1];
+                    final Looper[] backgroundLooper = new Looper[1];
+                    final ExecutorService executorService = Executors.newSingleThreadExecutor();
+                    executorService.submit(new Runnable() {
+                        @Override
+                        public void run() {
+                            Looper.prepare();
+                            backgroundLooper[0] = Looper.myLooper();
+                            backgroundHandler = new Handler(backgroundLooper[0]);
+                            try {
+                                realm = Realm.getInstance(realmConfiguration);
+                                base.evaluate();
+                                Looper.loop();
+                            } catch (Throwable e) {
+                                threadAssertionError[0] = e;
+                                unitTestFailed = true;
+                            } finally {
+                                try {
+                                    looperTearDown();
+                                } catch (Throwable t) {
+                                    if (threadAssertionError[0] == null) {
+                                        threadAssertionError[0] = t;
+                                    }
+                                    unitTestFailed = true;
+                                }
+                                if (signalTestCompleted.getCount() > 0) {
+                                    signalTestCompleted.countDown();
+                                }
+                                if (realm != null) {
+                                    realm.close();
+                                }
+                                signalClosedRealm.countDown();
+                            }
+                        }
+                    });
+                    TestHelper.exitOrThrow(executorService, signalTestCompleted, signalClosedRealm, backgroundLooper, threadAssertionError);
+                } catch (Throwable error) {
+                    // These exceptions should only come from TestHelper.awaitOrFail()
+                    testException = error;
+                } finally {
+                    // Try as hard as possible to close down gracefully, while still keeping all exceptions intact.
+                    try {
+                        after();
+                    } catch (Throwable e) {
+                        if (testException != null) {
+                            // Both TestHelper.awaitOrFail() and after() threw an exception. Make sure we are aware of
+                            // that fact by printing both exceptions.
+                            StringWriter testStackTrace = new StringWriter();
+                            testException.printStackTrace(new PrintWriter(testStackTrace));
+
+                            StringWriter afterStackTrace = new StringWriter();
+                            e.printStackTrace(new PrintWriter(afterStackTrace));
+
+                            StringBuilder errorMessage = new StringBuilder()
+                                    .append("after() threw an error that shadows a test case error")
+                                    .append('\n')
+                                    .append("== Test case exception ==\n")
+                                    .append(testStackTrace.toString())
+                                    .append('\n')
+                                    .append("== after() exception ==\n")
+                                    .append(afterStackTrace.toString());
+                            fail(errorMessage.toString());
+                        } else {
+                            // Only after() threw an exception
+                            throw e;
+                        }
+                    }
+
+                    // Only TestHelper.awaitOrFail() threw an exception
+                    if (testException != null) {
+                        //noinspection ThrowFromFinallyBlock
+                        throw testException;
+                    }
+                }
+            }
+        };
+    }
+
+    /**
+     * Signal that the test has completed.
+     */
+    public void testComplete() {
+        signalTestCompleted.countDown();
+    }
+
+    /**
+     * Signal that the test has completed.
+     *
+     * @param latches additional latches to wait before set the test completed flag.
+     */
+    public void testComplete(CountDownLatch... latches) {
+        for (CountDownLatch latch : latches) {
+            TestHelper.awaitOrFail(latch);
+        }
+        signalTestCompleted.countDown();
+    }
+
+    /**
+     * Posts a runnable to this worker threads looper.
+     */
+    public void postRunnable(Runnable runnable) {
+        backgroundHandler.post(runnable);
+    }
+
+    /**
+     * Tear down logic which is guaranteed to run after the looper test has either completed or failed.
+     * This will run on the same thread as the looper test.
+     */
+    public void looperTearDown() {
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
new file mode 100644
index 0000000000..149412fbcb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+/**
+ * This annotation should be used along with {@link RunInLooperThread}
+ * When the annotation is present, the test method is executed on a worker thread with a looper.
+ * This will also uses {@link org.junit.rules.TemporaryFolder} to create and open a Realm.
+ */
+@Target(METHOD) @Retention(RUNTIME)
+public @interface RunTestInLooperThread {
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
new file mode 100644
index 0000000000..2681563436
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import android.content.Context;
+import android.content.res.AssetManager;
+
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Rule that creates the {@link RealmConfiguration } in a temporary directory and deletes the Realm created with that
+ * configuration once the test finishes. Be sure to close all Realm instances before finishing the test. Otherwise
+ * {@link Realm#deleteRealm(RealmConfiguration)} will throw an exception in the {@link #after()} method.
+ * The temp directory will be deleted regardless if the {@link Realm#deleteRealm(RealmConfiguration)} fails or not.
+ */
+public class TestRealmConfigurationFactory extends TemporaryFolder {
+    private Map<RealmConfiguration, Boolean> map = new ConcurrentHashMap<RealmConfiguration, Boolean>();
+    private Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
+    protected boolean unitTestFailed = false;
+
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                before();
+                try {
+                    base.evaluate();
+                } catch (Throwable throwable) {
+                    unitTestFailed = true;
+                    throw throwable;
+                } finally {
+                    after();
+                }
+            }
+        };
+    }
+
+    @Override
+    protected void before() throws Throwable {
+        super.before();
+    }
+
+    @Override
+    protected void after() {
+        try {
+            for (RealmConfiguration configuration : configurations) {
+                Realm.deleteRealm(configuration);
+            }
+        } catch (IllegalStateException e) {
+            // Only throw the exception caused by deleting the opened Realm if the test case itself doesn't throw.
+            if (!unitTestFailed) {
+                throw e;
+            }
+        } finally {
+            // This will delete the temp folder.
+            super.after();
+        }
+    }
+
+    public RealmConfiguration createConfiguration() {
+        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+                .build();
+
+        configurations.add(configuration);
+        return configuration;
+    }
+
+    public RealmConfiguration createConfiguration(String subDir, String name) {
+        final File folder = new File(getRoot(), subDir);
+        assertTrue(folder.mkdirs());
+        RealmConfiguration configuration = new RealmConfiguration.Builder(folder)
+                .name(name)
+                .build();
+
+        configurations.add(configuration);
+        return configuration;
+    }
+
+    public RealmConfiguration createConfiguration(String name) {
+        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+                .name(name)
+                .build();
+
+        configurations.add(configuration);
+        return configuration;
+    }
+
+    public RealmConfiguration createConfiguration(String name, byte[] key) {
+        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+                .name(name)
+                .encryptionKey(key)
+                .build();
+
+        configurations.add(configuration);
+        return configuration;
+    }
+
+    public RealmConfiguration.Builder createConfigurationBuilder() {
+        return new RealmConfiguration.Builder(getRoot());
+    }
+
+    // Copies a Realm file from assets to temp dir
+    public void copyRealmFromAssets(Context context, String realmPath, String newName)
+            throws IOException {
+        // Delete the existing file before copy
+        RealmConfiguration configToDelete = new RealmConfiguration.Builder(getRoot())
+                .name(newName)
+                .build();
+        Realm.deleteRealm(configToDelete);
+
+        AssetManager assetManager = context.getAssets();
+        InputStream is = assetManager.open(realmPath);
+        File file = new File(getRoot(), newName);
+        FileOutputStream outputStream = new FileOutputStream(file);
+        byte[] buf = new byte[1024];
+        int bytesRead;
+        while ((bytesRead = is.read(buf)) > -1) {
+            outputStream.write(buf, 0, bytesRead);
+        }
+        outputStream.close();
+        is.close();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
new file mode 100644
index 0000000000..d560e819f2
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.services;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.entities.AllTypes;
+
+/**
+ * Helper service for multi-processes support testing.
+ */
+public class RemoteProcessService extends Service {
+
+    public abstract static class Step {
+        public final int message;
+        private Step(int message) {
+            this.message = message;
+            stepMap.put(message, this);
+        }
+
+        abstract void run();
+
+        // Pass a null to tell main process that everything is OK.
+        // Otherwise, pass a error String which will be used by assertion in main process.
+        protected void response(String error) {
+            try {
+                Message msg = Message.obtain(null, message);
+                if (error != null) {
+                    Bundle bundle = new Bundle();
+                    bundle.putString(BUNDLE_KEY_ERROR, error);
+                    msg.setData(bundle);
+                }
+                thiz.client.send(msg);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public static final String BUNDLE_KEY_ERROR = "error";
+    private static Map<Integer, Step> stepMap = new HashMap<Integer, Step>();
+
+    private static RemoteProcessService thiz;
+    private Realm testRealm;
+
+    private final Messenger messenger = new Messenger(new IncomingHandler());
+    private Messenger client;
+
+    public RemoteProcessService() {
+        if (thiz != null) {
+            throw new RuntimeException("Only one instance is allowed!");
+        }
+        thiz = this;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return messenger.getBinder();
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        stopSelf();
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        return START_NOT_STICKY;
+    }
+
+    private static class IncomingHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            thiz.client = msg.replyTo;
+            if (thiz.client == null) {
+                throw new RuntimeException("Message with an empty client.");
+            }
+            Step step = stepMap.get(msg.what);
+            if (step != null) {
+                step.run();
+            } else {
+                throw new RuntimeException("Cannot find corresponding step to message " + msg.what + ".");
+            }
+        }
+    }
+
+    // Call this function to return the String of current class and line number.
+    private static String currentLine() {
+        StackTraceElement element = new Throwable().getStackTrace()[1];
+        return element.getClassName() + " line " + element.getLineNumber() + ": ";
+    }
+
+    public final static Step stepCreateInitialRealm_A = new Step(10) {
+
+        @Override
+        void run() {
+            thiz.testRealm = Realm.getInstance(thiz);
+            int expected = 1;
+            int got = thiz.testRealm.allObjects(AllTypes.class).size();
+            if (expected == got) {
+                response(null);
+            } else {
+                response(currentLine() + "expected: " + expected + ", but got " + got);
+            }
+            thiz.testRealm.close();
+        }
+    };
+
+    public final static Step stepExitProcess_A = new Step(20) {
+
+        @Override
+        void run() {
+            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm.close();
+            response(null);
+            Runtime.getRuntime().exit(0);
+        }
+    };
+}
diff --git a/realm/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
rename to realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
diff --git a/realm/src/androidTest/java/io/realm/tests/api/entities/Dog.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
similarity index 100%
rename from realm/src/androidTest/java/io/realm/tests/api/entities/Dog.java
rename to realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java b/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java
new file mode 100644
index 0000000000..f630cb8a4a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/ExceptionHolder.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import junit.framework.AssertionFailedError;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+import static junit.framework.Assert.fail;
+
+/**
+ * Utility class for wrapping exceptions from background threads in unit tests.
+ * It makes patterns like this possible:
+ *
+ * {@code
+ *   final CountDownLatch taskDone = new CountDownLatch(1);
+ *   final ExceptionHolder bgError = new ExceptionHolder();
+ *   new Thread(new Runnable() {
+ *      @Override
+ *      public void run() {
+ *          try {
+ *              // Error prone code ...
+ *          } catch (Exception e) {
+ *              bgError.setException(e);
+ *          } finall {
+ *              taskDone.countDown();
+ *          }
+ *      }
+ *   }).start()
+ *   taskDone.await();
+ *   bgError.checkFailure();
+ * }
+ */
+public class ExceptionHolder {
+
+    private Throwable exception;
+
+    /**
+     * Sets the exception held by this container. This is a one-shot operation.
+     *
+     * @param throwable error to save.
+     * @throws IllegalStateException if an exception have already been put into this holder.
+     */
+    public void setException(Throwable throwable) {
+        if (exception != null) {
+            throw new IllegalStateException("An exception has already been set.");
+        }
+        this.exception = throwable;
+    }
+
+    /**
+     * Sets a custom error message that can be used instead of setting an exception.
+     * This will still trigger {@link #checkFailure()}.
+     *
+     * @param message error message
+     */
+    public void setError(String message) {
+        setException(new AssertionFailedError(message));
+    }
+
+    /**
+     * Returns any saved exception.
+     *
+     * @return {@link Throwable} held by this container
+     */
+    public Throwable getException() {
+        return exception;
+    }
+
+    /**
+     * Checks if an exception has been set and fails the unit test if that is the case.
+     */
+    public void checkFailure() {
+        if (exception != null) {
+            StringWriter stacktrace = new StringWriter();
+            exception.printStackTrace(new PrintWriter(stacktrace));
+            fail(stacktrace.toString());
+        }
+    }
+}
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/LooperSpy.java b/realm/realm-library/src/androidTest/java/io/realm/util/LooperSpy.java
new file mode 100644
index 0000000000..6909b0851a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/LooperSpy.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import android.os.Looper;
+import android.os.Message;
+import android.os.MessageQueue;
+import android.util.Log;
+
+import java.lang.reflect.Field;
+
+/**
+ * Debug util for dumping the content of a Looper message queue.
+ * Inspired by: https://corner.squareup.com/2013/12/android-main-thread-2.html
+ */
+public class LooperSpy {
+
+    private final Field messagesField;
+    private final Field nextField;
+    private final MessageQueue mainMessageQueue;
+
+    /**
+     * Creates a LooperSpy for the Looper on the main thread.
+     */
+    public static LooperSpy mainLooper() {
+        return new LooperSpy(Looper.getMainLooper());
+    }
+
+    /**
+     * Creates a LooperSpy for a specified Looper.
+     */
+    public static LooperSpy create(Looper looper) {
+        return new LooperSpy(looper);
+    }
+
+    private LooperSpy(Looper looper) {
+        try {
+            Field queueField = Looper.class.getDeclaredField("mQueue");
+            queueField.setAccessible(true);
+            messagesField = MessageQueue.class.getDeclaredField("mMessages");
+            messagesField.setAccessible(true);
+            nextField = Message.class.getDeclaredField("next");
+            nextField.setAccessible(true);
+            mainMessageQueue = (MessageQueue) queueField.get(looper);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Outputs the Looper's entire MessageQueue to LogCat.
+     */
+    public void dumpQueue() {
+        try {
+            Message nextMessage = (Message) messagesField.get(mainMessageQueue);
+            Log.d("MainLooperSpy", "Begin dumping queue");
+            dumpMessages(nextMessage);
+            Log.d("MainLooperSpy", "End dumping queue");
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void dumpMessages(Message message) throws IllegalAccessException {
+        if (message != null) {
+            Log.d("MainLooperSpy", message.toString());
+            Message next = (Message) nextField.get(message);
+            dumpMessages(next);
+        }
+    }
+}
+
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
new file mode 100644
index 0000000000..cc570efb8d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/RealmBackgroundTask.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+/**
+ * Utility class for running a task on a non-looper background thread.
+ *
+ * This class ensures that the background Realm is automatically closed no matter the outcome of
+ * the test.
+ *
+ * Failures can be asserted using {@code task.checkFailure()}
+ */
+public abstract class RealmBackgroundTask {
+
+    private final RealmConfiguration configuration;
+    private final ExceptionHolder exceptionHolder = new ExceptionHolder();
+
+    public RealmBackgroundTask(RealmConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    /**
+     * Runs the task on a background thread. It will either return when it completes successfully or throw an
+     * {@link junit.framework.AssertionFailedError} if it failed or timed out. The background task is limited to
+     * 10 seconds after which it will time out.
+     */
+    public void awaitOrFail() {
+        final CountDownLatch jobDone = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(configuration);
+                try {
+                    doInBackground(realm);
+                } catch (Throwable throwable) {
+                    exceptionHolder.setException(throwable);
+                } finally {
+                    realm.close();
+                    jobDone.countDown();
+                }
+            }
+        }, "RealmBackgroundTask").start();
+
+        try {
+            if (!jobDone.await(10, TimeUnit.SECONDS)) {
+                exceptionHolder.setError("Job timed out!");
+            }
+        } catch (InterruptedException e) {
+            exceptionHolder.setException(e);
+        }
+
+        exceptionHolder.checkFailure();
+    }
+
+    /**
+     * Executes the task. This method is called on a background thread.
+     *
+     * @param realm Realm instance created by the provided configuration.
+     */
+    protected abstract void doInBackground(Realm realm);
+}
diff --git a/realm/src/main/AndroidManifest.xml b/realm/realm-library/src/main/AndroidManifest.xml
similarity index 70%
rename from realm/src/main/AndroidManifest.xml
rename to realm/realm-library/src/main/AndroidManifest.xml
index 8deea15631..6c57d744f5 100644
--- a/realm/src/main/AndroidManifest.xml
+++ b/realm/realm-library/src/main/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="io.realm" >
-    <application android:allowBackup="true"/>
+
 </manifest>
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
new file mode 100644
index 0000000000..6faf09ed5e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -0,0 +1,682 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.SharedGroupManager;
+import io.realm.internal.Table;
+import io.realm.internal.TableView;
+import io.realm.internal.UncheckedRow;
+import io.realm.internal.android.DebugAndroidLogger;
+import io.realm.internal.android.ReleaseAndroidLogger;
+import io.realm.internal.async.RealmThreadPoolExecutor;
+import io.realm.internal.log.RealmLog;
+import rx.Observable;
+
+/**
+ * Base class for all Realm instances.
+ *
+ * @see io.realm.Realm
+ * @see io.realm.DynamicRealm
+ */
+abstract class BaseRealm implements Closeable {
+    protected static final long UNVERSIONED = -1;
+    private static final String INCORRECT_THREAD_CLOSE_MESSAGE = "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
+    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
+    private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
+    private static final String CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE = "Cannot refresh inside of a transaction.";
+
+    // Map between a Handler and the canonical path to a Realm file
+    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
+
+    // Thread pool for all async operations (Query & transaction)
+    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.getInstance();
+
+    protected long threadId;
+    protected RealmConfiguration configuration;
+    protected SharedGroupManager sharedGroupManager;
+    protected boolean autoRefresh;
+    RealmSchema schema;
+    Handler handler;
+    HandlerController handlerController;
+
+    static {
+        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
+    }
+
+    protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
+        this.threadId = Thread.currentThread().getId();
+        this.configuration = configuration;
+        this.sharedGroupManager = new SharedGroupManager(configuration);
+        this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
+        setAutoRefresh(autoRefresh);
+    }
+
+    /**
+     * Sets the auto-refresh status of the Realm instance.
+     * <p>
+     * Auto-refresh is a feature that enables automatic update of the current Realm instance and all its derived objects
+     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in
+     * another thread. This feature is only available if the Realm instance lives is a {@link android.os.Looper} enabled
+     * thread.
+     *
+     * @param autoRefresh {@code true} will turn auto-refresh on, {@code false} will turn it off.
+     * @throws IllegalStateException if called from a non-Looper thread.
+     */
+    public void setAutoRefresh(boolean autoRefresh) {
+        checkIfValid();
+        if (autoRefresh && Looper.myLooper() == null) {
+            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
+        }
+
+        if (autoRefresh && !this.autoRefresh) { // Switch it on
+            handlerController = new HandlerController(this);
+            handler = new Handler(handlerController);
+            handlers.put(handler, configuration.getPath());
+        } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
+            removeHandler();
+        }
+        this.autoRefresh = autoRefresh;
+    }
+
+    /**
+     * Retrieves the auto-refresh status of the Realm instance.
+     *
+     * @return the auto-refresh status.
+     */
+    public boolean isAutoRefresh() {
+        return autoRefresh;
+    }
+
+    /**
+     * Checks if the Realm is currently in a transaction.
+     *
+     * @return {@code true} if inside a transaction, {@code false} otherwise.
+     */
+    public boolean isInTransaction() {
+        checkIfValid();
+        return !sharedGroupManager.isImmutable();
+    }
+
+    /**
+     * Adds a change listener to the Realm.
+     * <p>
+     * The listeners will be executed:
+     * <ul>
+     * <li>Immediately if a change was committed by the local thread</li>
+     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
+     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
+     * </ul>
+     *
+     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
+     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
+     *
+     * @param listener the change listener.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     * @see #removeChangeListener(RealmChangeListener)
+     * @see #removeAllChangeListeners()
+     */
+    public void addChangeListener(RealmChangeListener listener) {
+        checkIfValid();
+        if (handlerController == null) {
+            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+        }
+        handlerController.addChangeListener(listener);
+    }
+
+    /**
+     * Removes the specified change listener.
+     *
+     * @param listener the change listener to be removed.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     * @see #addChangeListener(RealmChangeListener)
+     */
+    public void removeChangeListener(RealmChangeListener listener) {
+        checkIfValid();
+        if (handlerController == null) {
+            throw new IllegalStateException("You can't remove a listener from a non-Looper thread ");
+        }
+        handlerController.removeChangeListener(listener);
+    }
+
+    /**
+     * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
+     * when subscribed to. Items will continually be emitted as the Realm is updated -
+     * {@code onComplete} will never be called.
+     *
+     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * only emit only the first item by using the {@code first()} operator:
+     *
+     * <pre>
+     * {@code
+     * realm.asObservable().first().subscribe( ... ) // You only get the results once
+     * }
+     * </pre>
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public abstract Observable asObservable();
+
+    /**
+     * Removes all user-defined change listeners.
+     *
+     * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     * @see #addChangeListener(RealmChangeListener)
+     */
+    public void removeAllChangeListeners() {
+        checkIfValid();
+        if (handlerController == null) {
+            throw new IllegalStateException("You can't remove listeners from a non-Looper thread ");
+        }
+        handlerController.removeAllChangeListeners();
+    }
+
+    // WARNING: If this method is used after calling any async method, the old handler will still be used.
+    //          package private, for test purpose only
+    void setHandler(Handler handler) {
+        // remove the old one
+        handlers.remove(this.handler);
+        handlers.put(handler, configuration.getPath());
+        this.handler = handler;
+    }
+
+    /**
+     * Removes and stops the current thread handler as gracefully as possible.
+     */
+    protected void removeHandler() {
+        handlers.remove(handler);
+        // Warning: This only clears the Looper queue. Handler.Callback is not removed.
+        handler.removeCallbacksAndMessages(null);
+        this.handler = null;
+    }
+
+    /**
+     * Writes a compacted copy of the Realm to the given destination File.
+     * <p>
+     * The destination file cannot already exist.
+     * <p>
+     * Note that if this is called from within a transaction it writes the current data, and not the data as it was when
+     * the last transaction was committed.
+     *
+     * @param destination file to save the Realm to.
+     * @throws java.io.IOException if any write operation fails.
+     */
+    public void writeCopyTo(File destination) throws java.io.IOException {
+        writeEncryptedCopyTo(destination, null);
+    }
+
+    /**
+     * Writes a compacted and encrypted copy of the Realm to the given destination File.
+     * <p>
+     * The destination file cannot already exist.
+     * <p>
+     * Note that if this is called from within a transaction it writes the current data, and not the data as it was when
+     * the last transaction was committed.
+     * <p>
+     *
+     * @param destination file to save the Realm to.
+     * @param key a 64-byte encryption key.
+     * @throws java.io.IOException if any write operation fails.
+     * @throws IllegalArgumentException if destination argument is null.
+     */
+    public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IOException {
+        if (destination == null) {
+            throw new IllegalArgumentException("The destination argument cannot be null");
+        }
+        checkIfValid();
+        sharedGroupManager.copyToFile(destination, key);
+    }
+
+    /**
+     * Refreshes the Realm instance and all the RealmResults and RealmObjects instances coming from it.
+     * It also calls the listeners associated to the Realm instance.
+     *
+     * @throws IllegalStateException if attempting to refresh from within a transaction.
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public void refresh() {
+        checkIfValid();
+        if (isInTransaction()) {
+            throw new IllegalStateException(BaseRealm.CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE);
+        }
+        sharedGroupManager.advanceRead();
+        if (handlerController != null) {
+            handlerController.notifyAllListeners();
+            // if we have empty async RealmObject then rerun
+            if (handlerController.threadContainsAsyncEmptyRealmObject()) {
+                handlerController.updateAsyncEmptyRealmObject();
+            }
+        }
+    }
+
+    /**
+     * Starts a transaction, this must be closed with {@link io.realm.Realm#commitTransaction()} or aborted by
+     * {@link io.realm.Realm#cancelTransaction()}. Transactions are used to atomically create, update and delete objects
+     * within a Realm.
+     * <br>
+     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the realm in the case of
+     * pending updates from other threads.
+     * <br>
+     * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
+     * thrown.
+     */
+    public void beginTransaction() {
+        checkIfValid();
+        sharedGroupManager.promoteToWrite();
+    }
+
+    /**
+     * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the Realm reverts back to
+     * being read-only. An event is sent to notify all other Realm instances that a change has occurred. When the event
+     * is received, the other Realms will get their objects and {@link io.realm.RealmResults} updated to reflect the
+     * changes from this commit.
+     */
+    public void commitTransaction() {
+        commitTransaction(true, null);
+    }
+
+    /**
+     * Commits transaction, runs the given runnable and then sends notifications. The runnable is useful to meet some
+     * timing conditions like the async transaction. In async transaction, the background Realm has to be closed before
+     * other threads see the changes to majoyly avoid the flaky tests.
+     *
+     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change listeners.
+     * @param runAfterCommit runnable will run after transaction committed but before notification sent.
+     */
+    void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
+        checkIfValid();
+        sharedGroupManager.commitAndContinueAsRead();
+
+        if (runAfterCommit != null)  {
+            runAfterCommit.run();
+        }
+
+        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
+            Handler handler = handlerIntegerEntry.getKey();
+            String realmPath = handlerIntegerEntry.getValue();
+
+            // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
+            // file will make a commit in order to create the schema. Users should not be notified about that.
+            if (!notifyLocalThread && handler.equals(this.handler)) {
+                continue;
+            }
+
+            // For all other threads, use the Handler
+            // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
+            // as the target thread consumes messages at the same time. In this case it is not a problem as worst
+            // case we end up with two REALM_CHANGED messages in the queue.
+            if (
+                    realmPath.equals(configuration.getPath())            // It's the right realm
+                            && !handler.hasMessages(HandlerController.REALM_CHANGED)       // The right message
+                            && handler.getLooper().getThread().isAlive() // The receiving thread is alive
+                            && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
+                RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
+                        "to prevent this.");
+            }
+        }
+    }
+
+    /**
+     * Reverts all writes (created, updated, or deleted objects) made in the current write transaction and end the
+     * transaction.
+     * <br>
+     * The Realm reverts back to read-only.
+     * <br>
+     * Calling this when not in a transaction will throw an exception.
+     */
+    public void cancelTransaction() {
+        checkIfValid();
+        sharedGroupManager.rollbackAndContinueAsRead();
+    }
+
+    /**
+     * Checks if a Realm's underlying resources are still available or not getting accessed from the wrong thread.
+     */
+    protected void checkIfValid() {
+        // Check if the Realm instance has been closed
+        if (sharedGroupManager == null || !sharedGroupManager.isOpen()) {
+            throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+        }
+
+        // Check if we are in the right thread
+        if (threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException(BaseRealm.INCORRECT_THREAD_MESSAGE);
+        }
+    }
+
+    /**
+     * Returns the canonical path to where this Realm is persisted on disk.
+     *
+     * @return the canonical path to the Realm file.
+     * @see File#getCanonicalPath()
+     */
+    public String getPath() {
+        return configuration.getPath();
+    }
+
+    /**
+     * Returns the {@link RealmConfiguration} for this Realm.
+     *
+     * @return the {@link RealmConfiguration} for this Realm.
+     */
+    public RealmConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Returns the schema version for this Realm.
+     *
+     * @return the schema version for the Realm file backing this Realm.
+     */
+    public long getVersion() {
+        if (!sharedGroupManager.hasTable(Table.METADATA_TABLE_NAME)) {
+            return UNVERSIONED;
+        }
+        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
+        return metadataTable.getLong(0, 0);
+    }
+
+    /**
+     * Closes the Realm instance and all its resources.
+     * <p>
+     * It's important to always remember to close Realm instances when you're done with it in order not to leak memory,
+     * file descriptors or grow the size of Realm file out of measure.
+     *
+     * @throws IllegalStateException if attempting to close from another thread.
+     */
+    @Override
+    public void close() {
+        if (this.threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE);
+        }
+
+        RealmCache.release(this);
+    }
+
+    /**
+     * Closes the Realm instances and all its resources without checking the {@link RealmCache}.
+     */
+    void doClose() {
+        if (sharedGroupManager != null) {
+            sharedGroupManager.close();
+            sharedGroupManager = null;
+        }
+        if (handler != null) {
+            removeHandler();
+        }
+    }
+
+    /**
+     * Checks if the {@link io.realm.Realm} instance has already been closed.
+     *
+     * @return {@code true} if closed, {@code false} otherwise.
+     * @throws IllegalStateException if attempting to close from another thread.
+     */
+    public boolean isClosed() {
+        if (this.threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
+        }
+
+        return sharedGroupManager == null || !sharedGroupManager.isOpen();
+    }
+
+    /**
+     * Checks if this {@link io.realm.Realm} contains any objects.
+     *
+     * @return {@code true} if empty, @{code false} otherwise.
+     */
+    public boolean isEmpty() {
+        checkIfValid();
+        return sharedGroupManager.getTransaction().isObjectTablesEmpty();
+    }
+
+    boolean hasChanged() {
+        return sharedGroupManager.hasChanged();
+    }
+
+    // package protected so unit tests can access it
+    void setVersion(long version) {
+        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
+        if (metadataTable.getColumnCount() == 0) {
+            metadataTable.addColumn(RealmFieldType.INTEGER, "version");
+            metadataTable.addEmptyRow();
+        }
+        metadataTable.setLong(0, 0, version);
+    }
+
+    /**
+     * Sort a table using the given field names and sorting directions. If a field name does not
+     * exist in the table an {@link IllegalArgumentException} will be thrown.
+     */
+    protected TableView doMultiFieldSort(String[] fieldNames, Sort sortOrders[], Table table) {
+        long columnIndices[] = new long[fieldNames.length];
+        for (int i = 0; i < fieldNames.length; i++) {
+            String fieldName = fieldNames[i];
+            long columnIndex = table.getColumnIndex(fieldName);
+            if (columnIndex == -1) {
+                throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+            }
+            columnIndices[i] = columnIndex;
+        }
+
+        return table.getSortedView(columnIndices, sortOrders);
+    }
+
+    protected void checkAllObjectsSortedParameters(String[] fieldNames, Sort[] sortOrders) {
+        if (fieldNames == null) {
+            throw new IllegalArgumentException("fieldNames must be provided.");
+        } else if (sortOrders == null) {
+            throw new IllegalArgumentException("sortOrders must be provided.");
+        }
+    }
+
+    // Return all handlers registered for this Realm
+    static Map<Handler, String> getHandlers() {
+        return handlers;
+    }
+
+    /**
+     * Returns the schema for this Realm.
+     *
+     * @return The {@link RealmSchema} for this Realm.
+     */
+    public RealmSchema getSchema() {
+        return schema;
+    }
+
+    <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
+        Table table = schema.getTable(clazz);
+        UncheckedRow row = table.getUncheckedRow(rowIndex);
+        E result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+        result.row = row;
+        result.realm = this;
+        result.setTableVersion();
+        if (handlerController != null) {
+            handlerController.addToRealmObjects(result);
+        }
+        return result;
+    }
+
+    // Used by RealmList/RealmResults
+    // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
+    <E extends RealmObject> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
+        Table table;
+        E result;
+        if (dynamicClassName != null) {
+            table = schema.getTable(dynamicClassName);
+            @SuppressWarnings("unchecked")
+            E dynamicObj = (E) new DynamicRealmObject();
+            result = dynamicObj;
+        } else {
+            table = schema.getTable(clazz);
+            result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+        }
+        result.row = table.getUncheckedRow(rowIndex);
+        result.realm = this;
+        result.setTableVersion();
+
+        if (handlerController != null) {
+            handlerController.addToRealmObjects(result);
+        }
+        return result;
+    }
+
+    /**
+     * Removes all objects from this Realm.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or on an incorrect thread.
+     */
+    public void deleteAll() {
+        checkIfValid();
+        for (RealmObjectSchema objectSchema : schema.getAll()) {
+            schema.getTable(objectSchema.getClassName()).clear();
+        }
+    }
+
+    /**
+     * Deletes the Realm file defined by the given configuration.
+     */
+    static boolean deleteRealm(final RealmConfiguration configuration) {
+        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
+
+        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                if (count != 0) {
+                    throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
+                            "Remember to close() all the instances of the Realm before deleting its file: " + configuration.getPath());
+                }
+
+                String canonicalPath = configuration.getPath();
+                File realmFolder = configuration.getRealmFolder();
+                String realmFileName = configuration.getRealmFileName();
+                List<File> filesToDelete = Arrays.asList(new File(canonicalPath),
+                        new File(realmFolder, realmFileName + ".lock"),
+                        new File(realmFolder, realmFileName + ".log_a"),
+                        new File(realmFolder, realmFileName + ".log_b"),
+                        new File(realmFolder, realmFileName + ".log"));
+                for (File fileToDelete : filesToDelete) {
+                    if (fileToDelete.exists()) {
+                        boolean deleteResult = fileToDelete.delete();
+                        if (!deleteResult) {
+                            realmDeleted.set(false);
+                            RealmLog.w("Could not delete the file " + fileToDelete);
+                        }
+                    }
+                }
+            }
+        });
+
+        return realmDeleted.get();
+    }
+
+    /**
+     * Compacts the Realm file defined by the given configuration.
+     */
+    static boolean compactRealm(final RealmConfiguration configuration) {
+        if (configuration.getEncryptionKey() != null) {
+            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
+        }
+
+        return SharedGroupManager.compact(configuration);
+    }
+
+    /**
+     * Migrates the Realm file defined by the given configuration using the provided migration block.
+     *
+     * @param configuration configuration for the Realm that should be migrated
+     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}
+     * @param callback callback for specific Realm type behaviors.
+     * @throws FileNotFoundException if the Realm file doesn't exist.
+     */
+    protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
+                                       final MigrationCallback callback) throws FileNotFoundException {
+        if (configuration == null) {
+            throw new IllegalArgumentException("RealmConfiguration must be provided");
+        }
+        if (migration == null && configuration.getMigration() == null) {
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided");
+        }
+
+        final AtomicBoolean fileNotFound = new AtomicBoolean(false);
+
+        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                if (count != 0) {
+                    throw new IllegalStateException("Cannot migrate a Realm file that is already open: "
+                            + configuration.getPath());
+                }
+
+                File realmFile = new File(configuration.getPath());
+                if (!realmFile.exists()) {
+                    fileNotFound.set(true);
+                    return;
+                }
+
+                RealmMigration realmMigration = (migration == null) ? configuration.getMigration() : migration;
+                DynamicRealm realm = null;
+                try {
+                    realm = DynamicRealm.getInstance(configuration);
+                    realm.beginTransaction();
+                    long currentVersion = realm.getVersion();
+                    realmMigration.migrate(realm, currentVersion, configuration.getSchemaVersion());
+                    realm.setVersion(configuration.getSchemaVersion());
+                    realm.commitTransaction();
+                } catch (RuntimeException e) {
+                    if (realm != null) {
+                        realm.cancelTransaction();
+                    }
+                    throw e;
+                } finally {
+                    if (realm != null) {
+                        realm.close();
+                        callback.migrationComplete();
+                    }
+                }
+            }
+        });
+
+        if (fileNotFound.get()) {
+            throw new FileNotFoundException("Cannot migrate a Realm file which doesn't exist: "
+                    + configuration.getPath());
+        }
+    }
+
+    // Internal delegate for migrations
+    protected interface MigrationCallback {
+        void migrationComplete();
+    }
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Case.java b/realm/realm-library/src/main/java/io/realm/Case.java
new file mode 100644
index 0000000000..2bb8f18960
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/Case.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * This class describes the Case settings used in Realm queries.
+ *
+ * @see io.realm.RealmQuery#equalTo(String, String, Case)
+ * @see io.realm.RealmQuery#contains(String, String, Case)
+ * @see io.realm.RealmQuery#beginsWith(String, String, Case)
+ * @see io.realm.RealmQuery#endsWith(String, String, Case)
+ */
+public enum Case {
+    SENSITIVE(true),
+    INSENSITIVE(false);
+
+    private final boolean value;
+
+    Case(boolean value) {
+        this.value = value;
+    }
+
+    /**
+     * Returns the value for this setting that is used by the underlying query engine.
+     * @return The value used by the underlying query engine to indicate this value.
+     */
+    public boolean getValue() {
+        return value;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
new file mode 100644
index 0000000000..3b2acdea34
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Looper;
+
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
+import io.realm.internal.Table;
+import io.realm.internal.TableView;
+import rx.Observable;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
+ * done using string based class names instead of class type references.
+ *
+ * This is useful during migrations or when working with string-based data like CSV or XML files.
+ *
+ * The same {@link io.realm.RealmConfiguration} can be used to open a Realm file in both dynamic and typed mode, but
+ * modifying the schema while having both a typed and dynamic version open is highly discouraged and will most likely
+ * crash the typed Realm. During migrations only a DynamicRealm will be open.
+ *
+ * Dynamic Realms do not enforce schemas or schema versions and {@link RealmMigration} code is not used even if it has
+ * been defined in the {@link RealmConfiguration}.
+ *
+ * This means that the schema is not created or validated until a Realm has been opened in typed mode, so if a Realm
+ * file is opened in dynamic mode first it will not contain any information about classes and fields, and any queries
+ * for classes defined by the schema will fail.
+ *
+ * @see Realm
+ * @see RealmSchema
+ */
+public final class DynamicRealm extends BaseRealm {
+
+    private DynamicRealm(RealmConfiguration configuration, boolean autoRefresh) {
+        super(configuration, autoRefresh);
+    }
+
+    /**
+     * Realm static constructor that returns a dynamic variant of the Realm instance defined by provided
+     * {@link io.realm.RealmConfiguration}. Dynamic Realms do not care about schemaVersion and schemas, so opening a
+     * DynamicRealm will never trigger a migration.
+     *
+     * @return the DynamicRealm defined by the configuration.
+     * @see RealmConfiguration for details on how to configure a Realm.
+     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws IllegalArgumentException if {@code configuration} argument is {@code null}.
+     */
+    public static DynamicRealm getInstance(RealmConfiguration configuration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+        }
+        return RealmCache.createRealmOrGetFromCache(configuration, DynamicRealm.class);
+    }
+
+    /**
+     * Instantiates and adds a new object to the Realm.
+     *
+     * @param className the class name of the object to create.
+     * @return the new object.
+     * @throws RealmException if the object could not be created.
+     */
+    public DynamicRealmObject createObject(String className) {
+        checkIfValid();
+        Table table = schema.getTable(className);
+        long rowIndex = table.addEmptyRow();
+        return get(DynamicRealmObject.class, className, rowIndex);
+    }
+
+    /**
+     * Creates an object with a given primary key. Classes without a primary key defined must use
+     * {@link #createObject(String)}} instead.
+     *
+     * @return the new object. All fields will have default values for their type, except for the
+     * primary key field which will have the provided value.
+     * @throws IllegalArgumentException if the primary key value is of the wrong type.
+     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     */
+    public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
+        Table table = schema.getTable(className);
+        long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
+        DynamicRealmObject dynamicRealmObject = new DynamicRealmObject(this, table.getCheckedRow(index));
+        if (handlerController != null) {
+            handlerController.addToRealmObjects(dynamicRealmObject);
+        }
+        return dynamicRealmObject;
+    }
+
+    /**
+     * Returns a RealmQuery, which can be used to query for the provided class.
+     *
+     * @param className The class of the object which is to be queried for.
+     * @return a RealmQuery, which can be used to query for specific objects of provided type.
+     * @see io.realm.RealmQuery
+     * @throws IllegalArgumentException if the class doesn't exist.
+     */
+    public RealmQuery<DynamicRealmObject> where(String className) {
+        checkIfValid();
+        if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
+            throw new IllegalArgumentException("Class does not exist in the Realm so it cannot be queried: " + className);
+        }
+        return RealmQuery.createDynamicQuery(this, className);
+    }
+
+    /**
+     * Removes all objects of the specified class.
+     *
+     * @param className the class for which all objects should be removed.
+     */
+    public void clear(String className) {
+        checkIfValid();
+        schema.getTable(className).clear();
+    }
+
+    /**
+     * Executes a given transaction on the DynamicRealm. {@link #beginTransaction()} and
+     * {@link #commitTransaction()} will be called automatically. If any exception is thrown
+     * during the transaction {@link #cancelTransaction()} will be called instead of {@link #commitTransaction()}.
+     *
+     * @param transaction {@link io.realm.DynamicRealm.Transaction} to execute.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}.
+     */
+    public void executeTransaction(Transaction transaction) {
+        if (transaction == null) {
+            throw new IllegalArgumentException("Transaction should not be null");
+        }
+
+        beginTransaction();
+        try {
+            transaction.execute(this);
+            commitTransaction();
+        } catch (RuntimeException e) {
+            if (isInTransaction()) {
+                cancelTransaction();
+            } else {
+                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Get all objects of a specific class name.
+     *
+     * @param className the Class to get objects of.
+     * @return a {@link RealmResults} list containing the objects. If no results where found, an empty list
+     * will be returned.
+     * @see io.realm.RealmResults
+     */
+    public RealmResults<DynamicRealmObject> allObjects(String className) {
+        return where(className).findAll();
+    }
+
+    /**
+     * Get all objects of a specific class name sorted by a field. If no objects exist, the returned
+     * {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of objects instead.
+     *
+     * @param className the class to get all objects from.
+     * @param fieldName the field name to sort by.
+     * @param sortOrder how to sort the results.
+     * @return a sorted {@link RealmResults} containing the objects.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName, Sort sortOrder) {
+        checkIfValid();
+        Table table = schema.getTable(className);
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+        }
+
+        TableView tableView = table.getSortedView(columnIndex, sortOrder);
+        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
+    }
+
+
+    /**
+     * Get all objects of a specific class name sorted by two specific field names.  If no objects exist,
+     * the returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
+     * objects instead.
+     *
+     * @param className the class to get all objects from.
+     * @param fieldName1 the first field name to sort by.
+     * @param sortOrder1 how to sort the first field.
+     * @param fieldName2 the second field name to sort by.
+     * @param sortOrder2 how to sort the second field.
+     * @return a sorted {@link RealmResults} containing the objects. If no results where found an empty list
+     * is returned.
+     * @throws java.lang.IllegalArgumentException if a field name used for sorting does not exist.
+     */
+    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName1,
+                                                                    Sort sortOrder1, String fieldName2,
+                                                                    Sort sortOrder2) {
+        return allObjectsSorted(className, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
+                sortOrder2});
+    }
+
+    /**
+     * Get all objects of a specific class name sorted by multiple fields.  If no objects exist, the
+     * returned {@link RealmResults} will not be {@code null}. Use {@link RealmResults#size()} to check the number of
+     * objects instead.
+     *
+     * @param className the class to get all objects from.
+     * @param sortOrders sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
+     * @param fieldNames an array of field names to sort objects by.
+     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
+     * @return A sorted {@link RealmResults} containing the objects.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    @SuppressWarnings("unchecked")
+    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldNames[], Sort sortOrders[]) {
+        checkAllObjectsSortedParameters(fieldNames, sortOrders);
+        Table table = schema.getTable(className);
+
+        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
+        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
+    }
+
+    /**
+     * Creates a {@link DynamicRealm} instance without checking the existence in the {@link RealmCache}.
+     *
+     * @return a {@link DynamicRealm} instance.
+     */
+    static DynamicRealm createInstance(RealmConfiguration configuration) {
+        boolean autoRefresh = Looper.myLooper() != null;
+        return new DynamicRealm(configuration, autoRefresh);
+    }
+
+    /**
+     * Return a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * returned in case of multiple occurrences.
+     *
+     * @param className the Class to get objects of.
+     * @param fieldName the field name.
+     * @return A non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<DynamicRealmObject> distinct(String className, String fieldName) {
+        checkIfValid();
+        Table table = schema.getTable(className);
+        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
+        TableView tableView = table.getDistinctView(columnIndex);
+        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
+    }
+
+    /**
+     * Return a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * returned in case of multiple occurrences.
+     * This method is only available from a Looper thread.
+     *
+     * @param className the Class to get objects of.
+     * @param fieldName the field name.
+     * @return immediately a {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
+     * query completes.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<DynamicRealmObject> distinctAsync(String className, String fieldName) {
+        checkIfValid();
+        return where(className).distinctAsync(fieldName);
+    }
+
+    /**
+     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param className the Class to get objects of.
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     */
+    public RealmResults<DynamicRealmObject> distinct(String className, String firstFieldName, String... remainingFieldNames) {
+        checkIfValid();
+        return where(className).distinct(firstFieldName, remainingFieldNames);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Observable<DynamicRealm> asObservable() {
+        return configuration.getRxFactory().from(this);
+    }
+
+    /**
+     * Encapsulates a Realm transaction.
+     * <p>
+     * Using this class will automatically handle {@link #beginTransaction()} and {@link #commitTransaction()}
+     * If any exception is thrown during the transaction {@link #cancelTransaction()} will be called
+     * instead of {@link #commitTransaction()}.
+     */
+    public interface Transaction {
+        void execute(DynamicRealm realm);
+    }
+}
+
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
new file mode 100644
index 0000000000..a506deb5fc
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -0,0 +1,730 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Locale;
+
+import io.realm.internal.CheckedRow;
+import io.realm.internal.LinkView;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
+import io.realm.internal.android.JsonUtils;
+
+/**
+ * Class that wraps a normal RealmObject in order to allow dynamic access instead of a typed interface.
+ * Using a DynamicRealmObject is slower than using the regular RealmObject class.
+ */
+public final class DynamicRealmObject extends RealmObject {
+    private String className;
+
+    /**
+     * Creates a dynamic Realm object based on an existing object.
+     *
+     * @param obj the Realm object to convert to a dynamic object. Only objects managed by {@link Realm} can be used.
+     * @throws IllegalArgumentException if object isn't managed by Realm or is a {@link DynamicRealmObject} already.
+     */
+    public DynamicRealmObject(RealmObject obj) {
+        if (obj == null) {
+            throw new IllegalArgumentException("A non-null object must be provided.");
+        }
+        if (obj instanceof DynamicRealmObject) {
+            throw new IllegalArgumentException("The object is already a DynamicRealmObject: " + obj);
+        }
+
+        Row row = obj.row;
+        if (!obj.isValid()) {
+            throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
+                    "is a standalone object or it was deleted.");
+        }
+        this.realm = obj.realm;
+        this.row = ((UncheckedRow) row).convertToChecked();
+    }
+
+    // Create a dynamic object. Only used internally
+    DynamicRealmObject() {
+
+    }
+
+    DynamicRealmObject(BaseRealm realm, Row row) {
+        this.realm = realm;
+        this.row = (row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked();
+    }
+
+    DynamicRealmObject(String className) {
+        this.className = className;
+    }
+
+    /**
+     * Returns the value for the given field.
+     *
+     * @param fieldName name of the field.
+     * @return the field value.
+     * @throws ClassCastException if the field doesn't contain a field of the defined return type.
+     */
+    @SuppressWarnings("unchecked")
+    public <E> E get(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        RealmFieldType type = row.getColumnType(columnIndex);
+        switch (type) {
+            case BOOLEAN: return (E) Boolean.valueOf(row.getBoolean(columnIndex));
+            case INTEGER: return (E) Long.valueOf(row.getLong(columnIndex));
+            case FLOAT: return (E) Float.valueOf(row.getFloat(columnIndex));
+            case DOUBLE: return (E) Double.valueOf(row.getDouble(columnIndex));
+            case STRING: return (E) row.getString(columnIndex);
+            case BINARY: return (E) row.getBinaryByteArray(columnIndex);
+            case DATE: return (E) row.getDate(columnIndex);
+            case OBJECT: return (E) getObject(fieldName);
+            case LIST: return (E) getList(fieldName);
+            case UNSUPPORTED_TABLE:
+            case UNSUPPORTED_MIXED:
+            default:
+                throw new IllegalStateException("Field type not supported: " + type);
+        }
+    }
+
+    /**
+     * Returns the {@code boolean} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the boolean value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain booleans.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public boolean getBoolean(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getBoolean(columnIndex);
+    }
+
+    /**
+     * Returns the {@code int} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the int value. Integer values exceeding {@code Integer.MAX_VALUE} will wrap.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public int getInt(String fieldName) {
+        return (int) getLong(fieldName);
+    }
+
+    /**
+     * Returns the {@code short} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the short value. Integer values exceeding {@code Short.MAX_VALUE} will wrap.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public short getShort(String fieldName) {
+        return (short) getLong(fieldName);
+    }
+
+    /**
+     * Returns the {@code long} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the long value. Integer values exceeding {@code Long.MAX_VALUE} will wrap.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public long getLong(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getLong(columnIndex);
+    }
+
+    /**
+     * Returns the {@code byte} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the byte value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public byte getByte(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return (byte) row.getLong(columnIndex);
+    }
+
+    /**
+     * Returns the {@code float} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the float value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain floats.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public float getFloat(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getFloat(columnIndex);
+    }
+
+    /**
+     * Returns the {@code double} value for a given field.
+     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * this method.
+     *
+     * @param fieldName the name of the field.
+     * @return the double value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain doubles.
+     * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
+     */
+    public double getDouble(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getDouble(columnIndex);
+    }
+
+    /**
+     * Returns the {@code byte[]} value for a given field.
+     *
+     * @param fieldName the name of the field.
+     * @return the byte[] value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain binary data.
+     */
+    public byte[] getBlob(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getBinaryByteArray(columnIndex);
+    }
+
+    /**
+     * Returns the {@code String} value for a given field.
+     *
+     * @param fieldName the name of the field.
+     * @return the String value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Strings.
+     */
+    public String getString(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getString(columnIndex);
+    }
+
+    /**
+     * Returns the {@code Date} value for a given field.
+     *
+     * @param fieldName the name of the field.
+     * @return the Date value.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Dates.
+     */
+    public Date getDate(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        if (row.isNull(columnIndex)) {
+            return null;
+        } else {
+            return row.getDate(columnIndex);
+        }
+    }
+
+    /**
+     * Returns the object being linked to from this field.
+     *
+     * @param fieldName the name of the field.
+     * @return the {@link DynamicRealmObject} representation of the linked object or {@code null} if no object is linked.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain links to other objects.
+     */
+    public DynamicRealmObject getObject(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        if (row.isNullLink(columnIndex)) {
+            return null;
+        } else {
+            long linkRowIndex = row.getLink(columnIndex);
+            CheckedRow linkRow = row.getTable().getLinkTarget(columnIndex).getCheckedRow(linkRowIndex);
+            return new DynamicRealmObject(realm, linkRow);
+        }
+    }
+
+    /**
+     * Returns the {@link RealmList} of objects being linked to from this field.
+     *
+     * @param fieldName the name of the field.
+     * @return the {@link RealmList} data for this field.
+     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain a list of links.
+     */
+    public RealmList<DynamicRealmObject> getList(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        LinkView linkView = row.getLinkList(columnIndex);
+        String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
+        return new RealmList<DynamicRealmObject>(className, linkView, realm);
+    }
+
+    /**
+     * Checks if the value of a given field is {@code null}.
+     *
+     * @param fieldName the name of the field.
+     * @return {@code true} if field value is null, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exists.
+     */
+    public boolean isNull(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        RealmFieldType type = row.getColumnType(columnIndex);
+        switch (type) {
+            case OBJECT:
+                return row.isNullLink(columnIndex);
+            case BOOLEAN:
+            case INTEGER:
+            case FLOAT:
+            case DOUBLE:
+            case STRING:
+            case BINARY:
+            case DATE:
+                return row.isNull(columnIndex);
+            case LIST:
+            case UNSUPPORTED_TABLE:
+            case UNSUPPORTED_MIXED:
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Checks whether an object has the given field or not.
+     *
+     * @param fieldName field name to check.
+     * @return {@code true} if the object has a field with the given name, {@code false} otherwise.
+     */
+    public boolean hasField(String fieldName) {
+        //noinspection SimplifiableIfStatement
+        if (fieldName == null || fieldName.isEmpty()) {
+            return false;
+        }
+        return row.hasColumn(fieldName);
+    }
+
+    /**
+     * Returns the list of field names on this object.
+     *
+     * @return list of field names on this objects or the empty list if the object doesn't have any fields.
+     */
+    public String[] getFieldNames() {
+        String[] keys = new String[(int) row.getColumnCount()];
+        for (int i = 0; i < keys.length; i++) {
+            keys[i] = row.getColumnName(i);
+        }
+        return keys;
+    }
+
+    /**
+     * Set the value for the given field. This method will automatically try to convert numbers and
+     * booleans that are given as {@code String} to their appropriate type. E.g. {@code "10"} will be
+     * converted to {@code 10} if the field type is {@code int}.
+     *
+     * Using the typed setters will be faster than using this method.
+     *
+     * @throws IllegalArgumentException if field name doesn't exists or if the input value cannot be converted
+     * to the appropriate input type.
+     * @throws NumberFormatException if a String based number cannot be converted properly.
+     */
+    @SuppressWarnings("unchecked")
+    public void set(String fieldName, Object value) {
+        boolean isString = (value instanceof String);
+        String strValue = isString ? (String) value : null;
+
+        // Do implicit conversion if needed
+        long columnIndex = row.getColumnIndex(fieldName);
+        RealmFieldType type = row.getColumnType(columnIndex);
+        if (isString && type != RealmFieldType.STRING) {
+            switch(type) {
+                case BOOLEAN: value = Boolean.parseBoolean(strValue); break;
+                case INTEGER: value = Long.parseLong(strValue); break;
+                case FLOAT: value = Float.parseFloat(strValue); break;
+                case DOUBLE: value = Double.parseDouble(strValue); break;
+                case DATE: value = JsonUtils.stringToDate(strValue); break;
+                default:
+                    throw new IllegalArgumentException(String.format("Field %s is not a String field, " +
+                            "and the provide value could not be automatically converted: %s. Use a typed" +
+                            "setter instead", fieldName, value));
+            }
+        }
+
+        if (value == null) {
+            setNull(fieldName);
+        } else {
+            setValue(fieldName, value);
+        }
+    }
+
+    // Automatically finds the appropriate setter based on the objects type
+    private void setValue(String fieldName, Object value) {
+        Class<?> valueClass = value.getClass();
+        if (valueClass == Boolean.class) {
+            setBoolean(fieldName, (Boolean) value);
+        } else if (valueClass == Short.class) {
+            setShort(fieldName, (Short) value);
+        } else if (valueClass == Integer.class) {
+            setInt(fieldName, (Integer) value);
+        } else if (valueClass == Long.class) {
+            setLong(fieldName, (Long) value);
+        } else if (valueClass == Byte.class) {
+            setByte(fieldName, (Byte) value);
+        } else if (valueClass == Float.class) {
+            setFloat(fieldName, (Float) value);
+        } else if (valueClass == Double.class) {
+            setDouble(fieldName, (Double) value);
+        } else if (valueClass == String.class) {
+            setString(fieldName, (String) value);
+        } else if (value instanceof Date) {
+            setDate(fieldName, (Date) value);
+        } else if (value instanceof byte[]) {
+            setBlob(fieldName, (byte[]) value);
+        } else if (valueClass == DynamicRealmObject.class) {
+            setObject(fieldName, (DynamicRealmObject) value);
+        } else if (valueClass == RealmList.class) {
+            @SuppressWarnings("unchecked")
+            RealmList<RealmObject> list = (RealmList<RealmObject>) value;
+            setList(fieldName, list);
+        } else {
+            throw new IllegalArgumentException("Value is of an type not supported: " + value.getClass());
+        }
+    }
+
+    /**
+     * Sets the {@code boolean} value of the given field.
+     *
+     * @param fieldName field name to update.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't a boolean field.
+     */
+    public void setBoolean(String fieldName, boolean value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setBoolean(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code short} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     */
+    public void setShort(String fieldName, short value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setLong(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code int} value of the given field.
+     *
+     * @param fieldName field name to update.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     */
+    public void setInt(String fieldName, int value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setLong(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code long} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     */
+    public void setLong(String fieldName, long value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setLong(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code byte} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     */
+    public void setByte(String fieldName, byte value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setLong(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code float} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     */
+    public void setFloat(String fieldName, float value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setFloat(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code double} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't a double field.
+     */
+    public void setDouble(String fieldName, double value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setDouble(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code String} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't a String field.
+     */
+    public void setString(String fieldName, String value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setString(columnIndex, value);
+    }
+
+    /**
+     * Sets the binary value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't a binary field.
+     */
+    public void setBlob(String fieldName, byte[] value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        row.setBinaryByteArray(columnIndex, value);
+    }
+
+    /**
+     * Sets the {@code Date} value of the given field.
+     *
+     * @param fieldName field name.
+     * @param value value to insert.
+     * @throws IllegalArgumentException if field name doesn't exists or isn't a Date field.
+     */
+    public void setDate(String fieldName, Date value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        if (value == null) {
+            row.setNull(columnIndex);
+        } else {
+            row.setDate(columnIndex, value);
+        }
+    }
+
+    /**
+     * Sets a reference to another object on the given field.
+     *
+     * @param fieldName field name.
+     * @param value object to link to.
+     * @throws IllegalArgumentException if field name doesn't exists, it doesn't link to other Realm objects, the type
+     * of DynamicRealmObject doesn't match or it belongs to a different Realm.
+     */
+    public void setObject(String fieldName, DynamicRealmObject value) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        if (value == null) {
+            row.nullifyLink(columnIndex);
+        } else {
+            if (value.realm == null || value.row == null) {
+                throw new IllegalArgumentException("Cannot link to objects that are not part of the Realm.");
+            }
+            if (realm != value.realm) {
+                throw new IllegalArgumentException("Cannot add an object from another Realm instance.");
+            }
+            Table table = row.getTable().getLinkTarget(columnIndex);
+            Table inputTable = value.row.getTable();
+            if (!table.hasSameSchema(inputTable)) {
+                throw new IllegalArgumentException(String.format("Type of object is wrong. Was %s, expected %s",
+                        inputTable.getName(), table.getName()));
+            }
+            row.setLink(columnIndex, value.row.getIndex());
+        }
+    }
+
+    /**
+     * Sets the reference to a {@link RealmList} on the given field.
+     *
+     * @param fieldName field name.
+     * @param list list of references.
+     * @throws IllegalArgumentException if field name doesn't exist, it is not a list field, the type
+     * of the object represented by the DynamicRealmObject doesn't match or any element in the list belongs to a
+     * different Realm.
+     */
+    public void setList(String fieldName, RealmList<? extends RealmObject> list) {
+        if (list == null) {
+            throw new IllegalArgumentException("Null values not allowed for lists");
+        }
+
+        String tableName = row.getTable().getName();
+        boolean typeValidated;
+        if (list.className == null && list.clazz == null) {
+            // Standalone lists don't know anything about the types they contain. They might even hold objects of
+            // multiple types :(, so we have to check each item in the list.
+            typeValidated = false;
+        } else {
+            String listType = list.className != null ? list.className : realm.schema.getTable(list.clazz).getName();
+            if (!tableName.equals(listType)) {
+                throw new IllegalArgumentException(String.format("The elements in the list is not the proper type. " +
+                        "Was %s expected %s.", listType, tableName));
+            }
+            typeValidated = true;
+        }
+
+        long columnIndex = row.getColumnIndex(fieldName);
+        LinkView links = row.getLinkList(columnIndex);
+        links.clear();
+        Table linkTargetTable = links.getTargetTable();
+        for (int i = 0; i < list.size(); i++) {
+            RealmObject obj = list.get(i);
+            if (obj.realm != realm) {
+                throw new IllegalArgumentException("Each element in 'list' must belong to the same Realm instance.");
+            }
+            if (!typeValidated && !linkTargetTable.hasSameSchema(obj.row.getTable())) {
+                throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                        "Element at index %d is not the proper type. " +
+                                "Was '%s' expected '%s'.", i, obj.row.getTable().getName(), linkTargetTable.getName()));
+            }
+            links.add(obj.row.getIndex());
+        }
+    }
+
+    /**
+     * Sets the value to {@code null} for the given field.
+     *
+     * @param fieldName field name.
+     * @throws IllegalArgumentException if field name doesn't exists, or the field isn't nullable.
+     */
+    public void setNull(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        RealmFieldType type = row.getColumnType(columnIndex);
+        if (type == RealmFieldType.OBJECT) {
+            row.nullifyLink(columnIndex);
+        } else {
+            row.setNull(columnIndex);
+        }
+    }
+
+    /**
+     * Return the type of object. This will normally correspond to the name of a class that is extending
+     * {@link RealmObject}.
+     *
+     * @return this objects type.
+     */
+    public String getType() {
+        return RealmSchema.getSchemaForTable(row.getTable());
+    }
+
+    /**
+     * Returns the type used by the underlying storage engine to represent this field.
+     *
+     * @return the underlying type used by Realm to represent this field.
+     */
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = row.getColumnIndex(fieldName);
+        return row.getColumnType(columnIndex);
+    }
+
+    @Override
+    public int hashCode() {
+        String realmName = realm.getPath();
+        String tableName = row.getTable().getName();
+        long rowIndex = row.getIndex();
+
+        int result = 17;
+        result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0);
+        result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0);
+        result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        DynamicRealmObject other = (DynamicRealmObject) o;
+
+        String path = realm.getPath();
+        String otherPath = other.realm.getPath();
+        if (path != null ? !path.equals(otherPath) : otherPath != null) {
+            return false;
+        }
+
+        String tableName = row.getTable().getName();
+        String otherTableName = other.row.getTable().getName();
+        //noinspection SimplifiableIfStatement
+        if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) {
+            return false;
+        }
+
+        return row.getIndex() == other.row.getIndex();
+    }
+
+    @Override
+    public String toString() {
+        if (row == null || !row.isAttached()) {
+            return "Invalid object";
+        }
+        StringBuilder sb = new StringBuilder(row.getTable().getName() + " = [");
+        String[] fields = getFieldNames();
+        for (String field : fields) {
+            long columnIndex = row.getColumnIndex(field);
+            RealmFieldType type = row.getColumnType(columnIndex);
+            sb.append("{");
+            switch (type) {
+                case BOOLEAN: sb.append(field).append(": ").append(row.getBoolean(columnIndex)); break;
+                case INTEGER: sb.append(field).append(": ").append(row.getLong(columnIndex)); break;
+                case FLOAT: sb.append(field).append(": ").append(row.getFloat(columnIndex)); break;
+                case DOUBLE: sb.append(field).append(": ").append(row.getDouble(columnIndex)); break;
+                case STRING: sb.append(field).append(": ").append(row.getString(columnIndex)); break;
+                case BINARY: sb.append(field).append(": ").append(Arrays.toString(row.getBinaryByteArray(columnIndex))); break;
+                case DATE: sb.append(field).append(": ").append(row.getDate(columnIndex)); break;
+                case OBJECT:
+                    if (row.isNullLink(columnIndex)) {
+                        sb.append("null");
+                    } else {
+                        sb.append(field).append(": ").append(row.getTable().getLinkTarget(columnIndex).getName());
+                    }
+                    break;
+                case LIST:
+                    String targetType = row.getTable().getLinkTarget(columnIndex).getName();
+                    sb.append(String.format("%s: RealmList<%s>[%s]", field, targetType, row.getLinkList(columnIndex).size()));
+                    break;
+                case UNSUPPORTED_TABLE:
+                case UNSUPPORTED_MIXED:
+                default:
+                    sb.append(field).append(": ?");
+            }
+            sb.append("}, ");
+        }
+        sb.replace(sb.length() - 2, sb.length(), "");
+        sb.append("]");
+        return sb.toString();
+    }
+
+    @Override
+    protected Table getTable() {
+        if (className != null) {
+            return realm.schema.getTable(className);
+        }
+        return super.getTable();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/FieldAttribute.java b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
new file mode 100644
index 0000000000..d8c9c46870
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * This class contains all Realm attributes for a Realm field.
+ * These will usually match the annotations found in the {@code io.realm.annotation} package. See the relevant
+ * annotation for further information on each modifier.
+ */
+public enum FieldAttribute {
+    /**
+     * Mark a field as indexed.
+     *
+     * @see io.realm.annotations.Index
+     */
+    INDEXED,
+
+    /**
+     * Mark a field as a primary key. This also implicitly mark it as {@link #INDEXED} and {@link #REQUIRED}.
+     *
+     * @see io.realm.annotations.PrimaryKey
+     */
+    PRIMARY_KEY,
+
+    /**
+     * Mark a field as explicitly not allowing null values. The default behavior for allowing {@code
+     * null} depends on the type of the field.
+     *
+     * @see io.realm.annotations.Required
+     * @see RealmObjectSchema#setRequired(String, boolean)
+     */
+    REQUIRED
+}
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
new file mode 100644
index 0000000000..0f1d4875d0
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -0,0 +1,618 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Message;
+
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
+
+import io.realm.internal.IdentitySet;
+import io.realm.internal.Row;
+import io.realm.internal.SharedGroup;
+import io.realm.internal.async.QueryUpdateTask;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
+ */
+public class HandlerController implements Handler.Callback {
+    // Keep a strong reference to the registered RealmChangeListener
+    // user should unregister those listeners
+    protected final CopyOnWriteArrayList<RealmChangeListener> changeListeners =
+            new CopyOnWriteArrayList<RealmChangeListener>();
+
+    // Keep a weak reference to the registered RealmChangeListener those are Weak since
+    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener
+    protected final List<WeakReference<RealmChangeListener>> weakChangeListeners =
+            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
+
+    static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
+    static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
+    static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
+    static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
+    static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+    final BaseRealm realm;
+    // pending update of async queries
+    private Future updateAsyncQueriesTask;
+
+    final ReferenceQueue<RealmResults<? extends RealmObject>> referenceQueueAsyncRealmResults = new ReferenceQueue<RealmResults<? extends RealmObject>>();
+    final ReferenceQueue<RealmResults<? extends RealmObject>> referenceQueueSyncRealmResults = new ReferenceQueue<RealmResults<? extends RealmObject>>();
+    final ReferenceQueue<RealmObject> referenceQueueRealmObject = new ReferenceQueue<RealmObject>();
+    // keep a WeakReference list to RealmResults obtained asynchronously in order to update them
+    // RealmQuery is not WeakReferenced to prevent it from being GC'd. RealmQuery should be
+    // cleaned if RealmResults is cleaned. we need to keep RealmQuery because it contains the query
+    // pointer (to handover for each update) + all the arguments necessary to rerun the query:
+    // sorting orders, soring columns, type (findAll, findFirst, findAllSorted etc.)
+    final Map<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<? extends RealmObject>> asyncRealmResults =
+            new IdentityHashMap<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<? extends RealmObject>>();
+    // Keep a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
+    // the query in the background for each commit, until we got a valid Row (pointer)
+    final Map<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>> emptyAsyncRealmObject =
+            new IdentityHashMap<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>>();
+
+    // keep a reference to the list of sync RealmResults, we'll use it
+    // to deliver type based notification once the shared_group advance
+    final IdentitySet<WeakReference<RealmResults<? extends RealmObject>>> syncRealmResults =
+            new IdentitySet<WeakReference<RealmResults<? extends RealmObject>>>();
+
+    final Map<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>> realmObjects =
+            new IdentityHashMap<WeakReference<RealmObject>, RealmQuery<? extends RealmObject>>();
+
+    public HandlerController(BaseRealm realm) {
+        this.realm = realm;
+    }
+
+    @Override
+    public boolean handleMessage(Message message) {
+        // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
+        // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
+        // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
+        // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
+        // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
+        if (realm.sharedGroupManager != null) {
+            switch (message.what) {
+                case REALM_CHANGED: {
+                    realmChanged();
+                    break;
+                }
+                case COMPLETED_ASYNC_REALM_RESULTS: {
+                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+                    completedAsyncRealmResults(result);
+                    break;
+                }
+                case COMPLETED_ASYNC_REALM_OBJECT: {
+                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+                    completedAsyncRealmObject(result);
+                    break;
+                }
+                case COMPLETED_UPDATE_ASYNC_QUERIES: {
+                    // this is called once the background thread completed the update of the async queries
+                    QueryUpdateTask.Result result = (QueryUpdateTask.Result) message.obj;
+                    completedAsyncQueriesUpdate(result);
+                    break;
+                }
+                case REALM_ASYNC_BACKGROUND_EXCEPTION: {
+                    // Don't fail silently in the background in case of Core exception
+                    throw (Error) message.obj;
+                }
+            }
+        }
+        return true;
+    }
+
+    void addChangeListener(RealmChangeListener listener) {
+        changeListeners.addIfAbsent(listener);
+    }
+
+    /**
+     * For internal use only.
+     * Sometimes we don't know when to unregister listeners (ex: {@link RealmBaseAdapter}). Using
+     * a WeakReference the listener doesn't need to be explicitly unregistered.
+     *
+     * @param listener the change listener.
+     */
+    void addChangeListenerAsWeakReference(RealmChangeListener listener) {
+        Iterator<WeakReference<RealmChangeListener>> iterator = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+        boolean addListener = true;
+        while (iterator.hasNext()) {
+            WeakReference<RealmChangeListener> weakRef = iterator.next();
+            RealmChangeListener weakListener = weakRef.get();
+
+            // Collect all listeners that are GC'ed
+            if (weakListener == null) {
+                if (toRemoveList == null) {
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                }
+                toRemoveList.add(weakRef);
+            }
+
+            // Check if Listener already exists
+            if (weakListener == listener) {
+                addListener = false;
+            }
+        }
+        if (toRemoveList != null) {
+            weakChangeListeners.removeAll(toRemoveList);
+        }
+        if (addListener) {
+            weakChangeListeners.add(new WeakReference<RealmChangeListener>(listener));
+        }
+    }
+
+    void removeChangeListener(RealmChangeListener listener) {
+        changeListeners.remove(listener);
+    }
+
+    void removeAllChangeListeners() {
+        changeListeners.clear();
+    }
+
+    void notifyGlobalListeners() {
+        // notify strong reference listener
+        Iterator<RealmChangeListener> iteratorStrongListeners = changeListeners.iterator();
+        while (iteratorStrongListeners.hasNext() && !realm.isClosed()) { // every callback could close the realm
+            RealmChangeListener listener = iteratorStrongListeners.next();
+            listener.onChange();
+        }
+        // notify weak reference listener (internals)
+        Iterator<WeakReference<RealmChangeListener>> iteratorWeakListeners = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+        while (iteratorWeakListeners.hasNext() && !realm.isClosed()) {
+            WeakReference<RealmChangeListener> weakRef = iteratorWeakListeners.next();
+            RealmChangeListener listener = weakRef.get();
+            if (listener == null) {
+                if (toRemoveList == null) {
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                }
+                toRemoveList.add(weakRef);
+            } else {
+                listener.onChange();
+            }
+        }
+        if (toRemoveList != null) {
+            weakChangeListeners.removeAll(toRemoveList);
+        }
+    }
+
+    void updateAsyncEmptyRealmObject() {
+        Iterator<Map.Entry<WeakReference<RealmObject>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<WeakReference<RealmObject>, RealmQuery<?>> next = iterator.next();
+            if (next.getKey().get() != null) {
+                Realm.asyncQueryExecutor
+                        .submit(QueryUpdateTask.newBuilder()
+                                .realmConfiguration(realm.getConfiguration())
+                                .addObject(next.getKey(),
+                                        next.getValue().handoverQueryPointer(),
+                                        next.getValue().getArgument())
+                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .build());
+
+            } else {
+                iterator.remove();
+            }
+        }
+    }
+
+    void notifyAllListeners() {
+        notifyGlobalListeners();
+        notifyTypeBasedListeners();
+    }
+
+    private void notifyTypeBasedListeners() {
+        notifyAsyncRealmResultsCallbacks();
+        notifySyncRealmResultsCallbacks();
+        notifyRealmObjectCallbacks();
+    }
+
+    private void notifyAsyncRealmResultsCallbacks() {
+        notifyRealmResultsCallbacks(asyncRealmResults.keySet().iterator());
+    }
+
+    private void notifySyncRealmResultsCallbacks() {
+        notifyRealmResultsCallbacks(syncRealmResults.keySet().iterator());
+    }
+
+    private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmObject>>> iterator) {
+        List<RealmResults<? extends RealmObject>> resultsToBeNotified =
+                new ArrayList<RealmResults<? extends RealmObject>>();
+        while (iterator.hasNext()) {
+            WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = iterator.next();
+            RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+            if (realmResults == null) {
+                iterator.remove();
+            } else {
+                // It should be legal to modify asyncRealmResults and syncRealmResults in the listener
+                resultsToBeNotified.add(realmResults);
+            }
+        }
+
+        for (Iterator<RealmResults<? extends RealmObject>> it = resultsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+            RealmResults<? extends RealmObject> realmResults = it.next();
+            realmResults.notifyChangeListeners();
+        }
+    }
+
+    private void notifyRealmObjectCallbacks() {
+        List<RealmObject> objectsToBeNotified = new ArrayList<RealmObject>();
+        Iterator<WeakReference<RealmObject>> iterator = realmObjects.keySet().iterator();
+        while (iterator.hasNext()) {
+            WeakReference<? extends RealmObject> weakRealmObject = iterator.next();
+            RealmObject realmObject = weakRealmObject.get();
+            if (realmObject == null) {
+                iterator.remove();
+
+            } else {
+                if (realmObject.row.isAttached()) {
+                    // It should be legal to modify realmObjects in the listener
+                    objectsToBeNotified.add(realmObject);
+                } else if (realmObject.row != Row.EMPTY_ROW) {
+                    iterator.remove();
+                }
+            }
+        }
+
+        for (Iterator<RealmObject> it = objectsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+            RealmObject realmObject = it.next();
+            realmObject.notifyChangeListeners();
+        }
+    }
+
+    private void updateAsyncQueries() {
+        if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
+            // try to cancel any pending update since we're submitting a new one anyway
+            updateAsyncQueriesTask.cancel(true);
+            Realm.asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
+            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates");
+        }
+        RealmLog.d("REALM_CHANGED realm:"+ HandlerController.this + " updating async queries, total: " + asyncRealmResults.size());
+        // prepare a QueryUpdateTask to current async queries in this thread
+        QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
+                .realmConfiguration(realm.getConfiguration());
+        QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;
+
+        // we iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch)
+        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>> entry = iterator.next();
+            WeakReference<RealmResults<? extends RealmObject>> weakReference = entry.getKey();
+            RealmResults<? extends RealmObject> realmResults = weakReference.get();
+            if (realmResults == null) {
+                // GC'd instance remove from the list
+                iterator.remove();
+
+            } else {
+                realmResultsQueryStep = updateQueryStep.add(weakReference,
+                        entry.getValue().handoverQueryPointer(),
+                        entry.getValue().getArgument());
+            }
+
+            // Note: we're passing an WeakRef of a RealmResults to another thread
+            //       this is safe as long as we don't invoke any of the RealmResults methods.
+            //       we're just using it as a Key in an IdentityHashMap (i.e doesn't call
+            //       AbstractList's hashCode, that require accessing objects from another thread)
+            //
+            //       watch out when you debug, as you're IDE try to evaluate RealmResults
+            //       which break the Thread confinement constraints.
+        }
+        if (realmResultsQueryStep != null) {
+            QueryUpdateTask queryUpdateTask = realmResultsQueryStep
+                    .sendToHandler(realm.handler, COMPLETED_UPDATE_ASYNC_QUERIES)
+                    .build();
+            updateAsyncQueriesTask = Realm.asyncQueryExecutor.submit(queryUpdateTask);
+        }
+    }
+
+    private void realmChanged() {
+        deleteWeakReferences();
+        if (threadContainsAsyncQueries()) {
+            updateAsyncQueries();
+
+        } else {
+            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " no async queries, advance_read");
+            realm.sharedGroupManager.advanceRead();
+            notifyAllListeners();
+            // empty async RealmObject shouldn't block the realm to advance
+            // they're empty so no risk on running into a corrupt state
+            // where the pointer (Row) is using one version of a Realm, whereas the
+            // current Realm is advancing to a newer version (they're empty anyway)
+            if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
+                updateAsyncEmptyRealmObject();
+            }
+        }
+    }
+
+    private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
+        Set<WeakReference<RealmResults<? extends RealmObject>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
+        if (updatedTableViewsKeys.size() > 0) {
+            WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = updatedTableViewsKeys.iterator().next();
+
+            RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+            if (realmResults == null) {
+                asyncRealmResults.remove(weakRealmResults);
+                RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] realm:"+ HandlerController.this + " RealmResults GC'd ignore results");
+
+            } else {
+                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                int compare = callerVersionID.compareTo(result.versionID);
+                if (compare == 0) {
+                    // if the RealmResults is empty (has not completed yet) then use the value
+                    // otherwise a task (grouped update) has already updated this RealmResults
+                    if (!realmResults.isLoaded()) {
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " same versions, using results (RealmResults is not loaded)");
+                        // swap pointer
+                        realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
+                        // notify callbacks
+                        realmResults.notifyChangeListeners();
+                    } else {
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " ignoring result the RealmResults (is already loaded)");
+                    }
+
+                } else if (compare > 0) {
+                    // we have two use cases:
+                    // 1- this RealmResults is not empty, this means that after we started the async
+                    //    query, we received a REALM_CHANGE that triggered an update of all async queries
+                    //    including the last async submitted, so no need to use the provided TableView pointer
+                    //    (or the user forced the sync behaviour .load())
+                    // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread
+                    //    this could happen if the current thread advanced the shared_group (via a write or refresh)
+                    //    this means that we need to rerun the query against a newer worker thread.
+
+                    if (!realmResults.isLoaded()) { // UC2
+                        // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS " + weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");
+
+                        RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
+                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
+                                .realmConfiguration(realm.getConfiguration())
+                                .add(weakRealmResults,
+                                        query.handoverQueryPointer(),
+                                        query.getArgument())
+                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_RESULTS)
+                                .build();
+
+                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+
+                    } else {
+                        // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
+                    }
+
+                } else {
+                    // the caller thread is behind the worker thread,
+                    // no need to rerun the query, since we're going to receive the update signal
+                    // & batch update all async queries including this one
+                    // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
+                    RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
+                }
+            }
+        }
+    }
+
+    private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
+        SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+        int compare = callerVersionID.compareTo(result.versionID);
+        if (compare > 0) {
+            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, rerun updates");
+            // The caller is more advance than the updated queries ==>
+            // need to refresh them again (if there is still async queries)
+            realm.handler.sendEmptyMessage(REALM_CHANGED);
+
+        } else {
+            // We're behind or on the same version as the worker thread
+
+            // only advance if we're behind
+            if (compare != 0) {
+                // no need to remove old pointers from TableView, since they're
+                // imperative TV, they will not rerun if the SharedGroup advance
+
+                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
+                RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " caller is behind  advance_read");
+                // refresh the Realm to the version provided by the worker thread
+                // (advanceRead to the latest version may cause a version mismatch error) preventing us
+                // from importing correctly the handover table view
+                realm.sharedGroupManager.advanceRead(result.versionID);
+            }
+
+            ArrayList<RealmResults<? extends RealmObject>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmObject>>(result.updatedTableViews.size());
+            // use updated TableViews pointers for the existing async RealmResults
+            for (Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, Long> query : result.updatedTableViews.entrySet()) {
+                WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = query.getKey();
+                RealmResults<? extends RealmObject> realmResults = weakRealmResults.get();
+                if (realmResults == null) {
+                    // don't update GC'd instance
+                    asyncRealmResults.remove(weakRealmResults);
+
+                } else {
+                    // it's dangerous to notify the callback about new results before updating
+                    // the pointers, because the callback may use another RealmResults not updated yet
+                    // this is why we defer the notification until we're done updating all pointers
+                    callbacksToNotify.add(realmResults);
+
+                    RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
+
+                    // update the instance with the new pointer
+                    realmResults.swapTableViewPointer(query.getValue());
+                }
+            }
+
+            for (RealmResults<? extends RealmObject> query : callbacksToNotify) {
+                query.notifyChangeListeners();
+            }
+
+            // We need to notify the rest of listeners, since the original REALM_CHANGE
+            // was delayed/swallowed in order to be able to update async queries
+            notifyGlobalListeners();
+            notifySyncRealmResultsCallbacks();
+            notifyRealmObjectCallbacks();
+
+            updateAsyncQueriesTask = null;
+        }
+    }
+
+    private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
+        Set<WeakReference<RealmObject>> updatedRowKey = result.updatedRow.keySet();
+        if (updatedRowKey.size() > 0) {
+            WeakReference<RealmObject> realmObjectWeakReference = updatedRowKey.iterator().next();
+            RealmObject realmObject = realmObjectWeakReference.get();
+
+            if (realmObject != null) {
+                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                int compare = callerVersionID.compareTo(result.versionID);
+                // we always query on the same version
+                // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
+                if (compare == 0) { //same version import the handover
+                    long rowPointer = result.updatedRow.get(realmObjectWeakReference);
+                    if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
+                        // cleanup a previously empty async RealmObject
+                        emptyAsyncRealmObject.remove(realmObjectWeakReference);
+                        realmObjects.put(realmObjectWeakReference, null);
+                    }
+                    realmObject.onCompleted(rowPointer);
+                    realmObject.notifyChangeListeners();
+
+                } else if (compare > 0) {
+                    // the caller has advanced we need to
+                    // retry against the current version of the caller if it's still empty
+                    if (realmObject.isValid()) { // already completed & has a valid pointer no need to re-run
+                        realmObject.notifyChangeListeners();
+                    } else {
+                        RealmQuery<?> realmQuery = realmObjects.get(realmObjectWeakReference);
+                        if (realmQuery == null) { // this is a retry of an empty RealmObject
+                            realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
+                        }
+
+                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
+                                .realmConfiguration(realm.getConfiguration())
+                                .addObject(realmObjectWeakReference,
+                                        realmQuery.handoverQueryPointer(),
+                                        realmQuery.getArgument())
+                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .build();
+
+                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+                    }
+                } else {
+                    // should not happen, since the the background thread position itself against the provided version
+                    // and the caller thread can only go forward (advance_read)
+                    throw new IllegalStateException("Caller thread behind the worker thread");
+                }
+            } // else: element GC'd in the meanwhile
+        }
+    }
+
+    /**
+     * Indicate the presence of {@code RealmResults} obtained asynchronously, this will prevent advancing the Realm
+     * before updating the {@code RealmResults}, otherwise we will potentially re-run the queries in this thread.
+     *
+     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmResults} {@code false}
+     * otherwise.
+     */
+    private boolean threadContainsAsyncQueries() {
+        boolean isEmpty = true;
+        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<WeakReference<RealmResults<? extends RealmObject>>, RealmQuery<?>> next = iterator.next();
+            if (next.getKey().get() == null) {
+                iterator.remove();
+            } else {
+                isEmpty = false;
+            }
+        }
+
+        return !isEmpty;
+    }
+
+    /**
+     * Indicate the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}
+     * empty means no pointer to a valid Row. This will help to caller to decice when to rerun the query.
+     *
+     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject} {@code false} otherwise.
+     */
+    boolean threadContainsAsyncEmptyRealmObject() {
+        boolean isEmpty = true;
+        Iterator<Map.Entry<WeakReference<RealmObject>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<WeakReference<RealmObject>, RealmQuery<?>> next = iterator.next();
+            if (next.getKey().get() == null) {
+                iterator.remove();
+            } else {
+                isEmpty = false;
+            }
+        }
+
+        return !isEmpty;
+    }
+
+    private void deleteWeakReferences() {
+        Reference<? extends RealmResults<? extends RealmObject>> weakReferenceResults;
+        Reference<? extends RealmObject> weakReferenceObject;
+        while ((weakReferenceResults = referenceQueueAsyncRealmResults.poll()) != null ) { // Does not wait for a reference to become available.
+            asyncRealmResults.remove(weakReferenceResults);
+        }
+        while ((weakReferenceResults = referenceQueueSyncRealmResults.poll()) != null ) {
+            syncRealmResults.remove(weakReferenceResults);
+        }
+        while ((weakReferenceObject = referenceQueueRealmObject.poll()) != null ) {
+            realmObjects.remove(weakReferenceObject);
+        }
+    }
+
+    WeakReference<RealmResults<? extends RealmObject>> addToAsyncRealmResults(RealmResults<? extends RealmObject> realmResults, RealmQuery<? extends RealmObject> realmQuery) {
+        WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = new WeakReference<RealmResults<? extends RealmObject>>(realmResults,
+                referenceQueueAsyncRealmResults);
+        asyncRealmResults.put(weakRealmResults, realmQuery);
+        return weakRealmResults;
+    }
+
+    void addToRealmResults(RealmResults<? extends RealmObject> realmResults) {
+        WeakReference<RealmResults<? extends RealmObject>> realmResultsWeakReference
+                = new WeakReference<RealmResults<? extends RealmObject>>(realmResults, referenceQueueSyncRealmResults);
+        syncRealmResults.add(realmResultsWeakReference);
+    }
+
+    // add to the list of RealmObject to be notified after a commit
+    <E extends RealmObject> void addToRealmObjects(E realmobject) {
+        realmObjects.put(new WeakReference<RealmObject>(realmobject), null);
+    }
+
+    <E extends RealmObject> WeakReference<RealmObject> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmObject> realmQuery) {
+        final WeakReference<RealmObject> realmObjectWeakReference = new WeakReference<RealmObject>(realmObject, referenceQueueRealmObject);
+        realmObjects.put(realmObjectWeakReference, realmQuery);
+        return realmObjectWeakReference;
+    }
+
+    void removeFromAsyncRealmObject(WeakReference<RealmObject> realmObjectWeakReference) {
+        realmObjects.remove(realmObjectWeakReference);
+    }
+
+    void addToEmptyAsyncRealmObject(WeakReference<RealmObject> realmObjectWeakReference, RealmQuery<? extends RealmObject> realmQuery) {
+        emptyAsyncRealmObject.put(realmObjectWeakReference, realmQuery);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
new file mode 100644
index 0000000000..1cf7940efc
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -0,0 +1,1572 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Build;
+import android.os.Looper;
+import android.util.JsonReader;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Scanner;
+import java.util.Set;
+import java.util.concurrent.Future;
+
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+import io.realm.internal.TableView;
+import io.realm.internal.Util;
+import io.realm.internal.log.RealmLog;
+import rx.Observable;
+
+/**
+ * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
+ * instances of your RealmObjects. Objects within a Realm can be queried and read at any time. Creating, modifying, and
+ * deleting objects must be done while inside a transaction. See {@link #beginTransaction()}
+ * <p>
+ * The transactions ensure that multiple instances (on multiple threads) can access the same objects in a consistent
+ * state with full ACID guarantees.
+ * <p>
+ * It is important to remember to call the {@link #close()} method when done with a Realm instance. Failing to do so can
+ * lead to {@link java.lang.OutOfMemoryError} as the native resources cannot be freed.
+ * <p>
+ * Realm instances cannot be used across different threads. This means that you have to open an instance on each thread
+ * you want to use Realm. Realm instances are cached automatically per thread using reference counting, so as long as
+ * the reference count doesn't reach zero, calling {@link #getInstance(RealmConfiguration)} will just return the cached
+ * Realm and should be considered a lightweight operation.
+ * <p>
+ * For the UI thread this means that opening and closing Realms should occur in either onCreate/onDestroy or
+ *  onStart/onStop.
+ * <p>
+ * Realm instances coordinate their state across threads using the {@link android.os.Handler} mechanism. This also means
+ * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #refresh()}
+ * is manually called.
+ * <p>
+ * A standard pattern for working with Realm in Android activities can be seen below:
+ * <p>
+ * <pre>
+ * public class RealmApplication extends Application {
+ *
+ *     \@Override
+ *     public void onCreate() {
+ *         super.onCreate();
+ *
+ *         // The Realm file will be located in package's "files" directory.
+ *         RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
+ *         Realm.setDefaultConfiguration(realmConfig);
+ *     }
+ * }
+ *
+ * public class RealmActivity extends Activity {
+ *
+ *   private Realm realm;
+ *
+ *   \@Override
+ *   protected void onCreate(Bundle savedInstanceState) {
+ *     super.onCreate(savedInstanceState);
+ *     setContentView(R.layout.layout_main);
+ *     realm = Realm.getDefaultInstance();
+ *   }
+ *
+ *   \@Override
+ *   protected void onDestroy() {
+ *     super.onDestroy();
+ *     realm.close();
+ *   }
+ * }
+ * </pre>
+ * <p>
+ * Realm supports String and byte fields containing up to 16 MB.
+ * <p>
+ *
+ * @see <a href="http://en.wikipedia.org/wiki/ACID">ACID</a>
+ * @see <a href="https://github.com/realm/realm-java/tree/master/examples">Examples using Realm</a>
+ */
+public final class Realm extends BaseRealm {
+
+    public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
+
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmObject>, Table> classToTable =
+            new HashMap<Class<? extends RealmObject>, Table>();
+
+    private static RealmConfiguration defaultConfiguration;
+
+    /**
+     * The constructor is private to enforce the use of the static one.
+     *
+     * @param configuration the {@link RealmConfiguration} used to open the Realm.
+     * @param autoRefresh {@code true} if Realm should auto-refresh. {@code false} otherwise.
+     * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
+     */
+    Realm(RealmConfiguration configuration, boolean autoRefresh) {
+        super(configuration, autoRefresh);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Observable<Realm> asObservable() {
+        return configuration.getRxFactory().from(this);
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        if (sharedGroupManager != null && sharedGroupManager.isOpen()) {
+            RealmLog.w("Remember to call close() on all Realm instances. " +
+                            "Realm " + configuration.getPath() + " is being finalized without being closed, " +
+                            "this can lead to running out of native memory."
+            );
+        }
+        super.finalize();
+    }
+
+    /**
+     * Realm static constructor for the default Realm file {@value io.realm.RealmConfiguration#DEFAULT_REALM_NAME}.
+     * This is equivalent to calling {@code Realm.getInstance(new RealmConfiguration(getContext()).build())}.
+     *
+     * This constructor is only provided for convenience. It is recommended to use
+     * {@link #getInstance(RealmConfiguration)} or {@link #getDefaultInstance()}.
+     *
+     * @param context a non-null Android {@link android.content.Context}
+     * @return an instance of the Realm class.
+     * @throws java.lang.IllegalArgumentException if no {@link Context} is provided.
+     * @throws RealmMigrationNeededException if the RealmObject classes no longer match the underlying Realm and it must be
+     * migrated.
+     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @deprecated use {@link #getDefaultInstance()} or {@link #getInstance(RealmConfiguration)} instead.
+     */
+    public static Realm getInstance(Context context) {
+        return Realm.getInstance(new RealmConfiguration.Builder(context)
+                .name(DEFAULT_REALM_NAME)
+                .build());
+    }
+
+    /**
+     * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
+     * by {@link #setDefaultConfiguration(RealmConfiguration)}
+     *
+     * @return an instance of the Realm class.
+     * @throws java.lang.NullPointerException if no default configuration has been defined.
+     * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
+     * RealmObject classes or version has has changed so a migration is required.
+     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     */
+    public static Realm getDefaultInstance() {
+        if (defaultConfiguration == null) {
+            throw new NullPointerException("No default RealmConfiguration was found. Call setDefaultConfiguration() first");
+        }
+        return RealmCache.createRealmOrGetFromCache(defaultConfiguration, Realm.class);
+    }
+
+    /**
+     * Realm static constructor that returns the Realm instance defined by provided {@link io.realm.RealmConfiguration}
+     *
+     * @param configuration {@link RealmConfiguration} used to open the Realm
+     * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException if no migration has been provided by the configuration and the RealmObject
+     * classes or version has has changed so a migration is required.
+     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
+     * @see RealmConfiguration for details on how to configure a Realm.
+     */
+    public static Realm getInstance(RealmConfiguration configuration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+        }
+        return RealmCache.createRealmOrGetFromCache(configuration, Realm.class);
+    }
+
+    /**
+     * Sets the {@link io.realm.RealmConfiguration} used when calling {@link #getDefaultInstance()}.
+     *
+     * @param configuration the {@link io.realm.RealmConfiguration} to use as the default configuration.
+     * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
+     * @see RealmConfiguration for details on how to configure a Realm.
+     */
+    public static void setDefaultConfiguration(RealmConfiguration configuration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+        }
+        defaultConfiguration = configuration;
+    }
+
+    /**
+     * Removes the current default configuration (if any). Any further calls to {@link #getDefaultInstance()} will
+     * fail until a new default configuration has been set using {@link #setDefaultConfiguration(RealmConfiguration)}.
+     */
+    public static void removeDefaultConfiguration() {
+        defaultConfiguration = null;
+    }
+
+    /**
+     * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
+     *
+     * @param configuration {@link RealmConfiguration} used to create the Realm.
+     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be initialized
+     *                      to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from the Realm file.
+     * @return a {@link Realm} instance.
+     */
+    static Realm createInstance(RealmConfiguration configuration, ColumnIndices columnIndices) {
+        try {
+            return createAndValidate(configuration, columnIndices);
+
+        } catch (RealmMigrationNeededException e) {
+            if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
+                deleteRealm(configuration);
+            } else {
+                try {
+                    migrateRealm(configuration);
+                } catch (FileNotFoundException fileNotFoundException) {
+                    // Should never happen
+                    throw new RealmIOException(fileNotFoundException);
+                }
+            }
+
+            return createAndValidate(configuration, columnIndices);
+        }
+    }
+
+    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices columnIndices) {
+        boolean autoRefresh = Looper.myLooper() != null;
+        Realm realm = new Realm(configuration, autoRefresh);
+        long currentVersion = realm.getVersion();
+        long requiredVersion = configuration.getSchemaVersion();
+        if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && columnIndices == null) {
+            realm.doClose();
+            throw new RealmMigrationNeededException(configuration.getPath(), String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
+        }
+        if (currentVersion != UNVERSIONED && requiredVersion < currentVersion && columnIndices == null) {
+            realm.doClose();
+            throw new IllegalArgumentException(String.format("Realm on disk is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
+        }
+
+        // Initialize Realm schema if needed
+        if (columnIndices == null) {
+            try {
+                initializeRealm(realm);
+            } catch (RuntimeException e) {
+                realm.doClose();
+                throw e;
+            }
+        } else {
+            realm.schema.columnIndices = columnIndices;
+        }
+
+        return realm;
+    }
+
+    @SuppressWarnings("unchecked")
+    private static void initializeRealm(Realm realm) {
+        long version = realm.getVersion();
+        boolean commitNeeded = false;
+        try {
+            realm.beginTransaction();
+            if (version == UNVERSIONED) {
+                commitNeeded = true;
+                realm.setVersion(realm.configuration.getSchemaVersion());
+            }
+
+            RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            final Set<Class<? extends RealmObject>> modelClasses = mediator.getModelClasses();
+            final Map<Class<? extends RealmObject>, ColumnInfo> columnInfoMap;
+            columnInfoMap = new HashMap<Class<? extends RealmObject>, ColumnInfo>(modelClasses.size());
+            for (Class<? extends RealmObject> modelClass : modelClasses) {
+                // Create and validate table
+                if (version == UNVERSIONED) {
+                    mediator.createTable(modelClass, realm.sharedGroupManager.getTransaction());
+                }
+                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedGroupManager.getTransaction()));
+            }
+            realm.schema.columnIndices = new ColumnIndices(columnInfoMap);
+        } finally {
+            if (commitNeeded) {
+                realm.commitTransaction(false, null);
+            } else {
+                realm.cancelTransaction();
+            }
+        }
+    }
+
+    /**
+     * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
+     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the RealmObject
+     * field will be set to the default value for that type.
+     *
+     * @param clazz type of Realm objects to create.
+     * @param json an array where each JSONObject must map to the specified class.
+     * @throws RealmException if mapping from JSON fails.
+     */
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) {
+        if (clazz == null || json == null) {
+            return;
+        }
+
+        for (int i = 0; i < json.length(); i++) {
+            try {
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
+            } catch (Exception e) {
+                throw new RealmException("Could not map Json", e);
+            }
+        }
+    }
+
+    /**
+     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
+     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
+     * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a
+     * new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the default
+     * value for the field type.
+     *
+     * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param json array with object data.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if unable to map JSON.
+     * @see #createAllFromJson(Class, org.json.JSONArray)
+     */
+    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, JSONArray json) {
+        if (clazz == null || json == null) {
+            return;
+        }
+        checkHasPrimaryKey(clazz);
+        for (int i = 0; i < json.length(); i++) {
+            try {
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
+            } catch (Exception e) {
+                throw new RealmException("Could not map Json", e);
+            }
+        }
+    }
+
+    /**
+     * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
+     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will be set to the default value for that type.
+     *
+     * @param clazz type of Realm objects to create.
+     * @param json the JSON array as a String where each object can map to the specified class.
+     * @throws RealmException if mapping from JSON fails.
+     */
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) {
+            return;
+        }
+
+        JSONArray arr;
+        try {
+            arr = new JSONArray(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not create JSON array from string", e);
+        }
+
+        createAllFromJson(clazz, arr);
+    }
+
+    /**
+     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
+     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
+     * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated.
+     * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
+     * the default value for the field type.
+     *
+     * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param json string with an array of JSON objects.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if unable to create a JSON array from the json string.
+     * @see #createAllFromJson(Class, String)
+     */
+    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) {
+            return;
+        }
+        checkHasPrimaryKey(clazz);
+
+        JSONArray arr;
+        try {
+            arr = new JSONArray(json);
+        } catch (JSONException e) {
+            throw new RealmException("Could not create JSON array from string", e);
+        }
+
+        createOrUpdateAllFromJson(clazz, arr);
+    }
+
+    /**
+     * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
+     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
+     * will be set to the default value for that type.
+     *
+     * @param clazz type of Realm objects created.
+     * @param inputStream the JSON array as a InputStream. All objects in the array must be of the specified class.
+     * @throws RealmException if mapping from JSON fails.
+     * @throws IOException if something was wrong with the input stream.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        if (clazz == null || inputStream == null) {
+            return;
+        }
+
+        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
+        try {
+            reader.beginArray();
+            while (reader.hasNext()) {
+                configuration.getSchemaMediator().createUsingJsonStream(clazz, this, reader);
+            }
+            reader.endArray();
+        } finally {
+            reader.close();
+        }
+    }
+
+    /**
+     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
+     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
+     * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated.
+     * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
+     * the default value for the field type.
+     *
+     * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param in the InputStream with a list of object data in JSON format.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if unable to read JSON.
+     * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
+        if (clazz == null || in == null) {
+            return;
+        }
+        checkHasPrimaryKey(clazz);
+
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
+        try {
+            scanner = getFullStringScanner(in);
+            JSONArray json = new JSONArray(scanner.next());
+            for (int i = 0; i < json.length(); i++) {
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
+            }
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
+        }
+    }
+
+    /**
+     * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
+     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
+     * be set to the default value for that type.
+     *
+     * @param clazz type of Realm object to create.
+     * @param json the JSONObject with object data.
+     * @return created object or null if no json data was provided.
+     * @throws RealmException if the mapping from JSON fails.
+     * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
+     */
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, JSONObject json) {
+        if (clazz == null || json == null) {
+            return null;
+        }
+
+        try {
+            return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
+        } catch (Exception e) {
+            throw new RealmException("Could not map Json", e);
+        }
+    }
+
+    /**
+     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
+     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a {@link RealmObject}
+     * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
+     * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
+     *
+     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param json {@link org.json.JSONObject} with object data.
+     * @return created or updated {@link io.realm.RealmObject}.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if JSON data cannot be mapped.
+     * @see #createObjectFromJson(Class, org.json.JSONObject)
+     */
+    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
+        if (clazz == null || json == null) {
+            return null;
+        }
+        checkHasPrimaryKey(clazz);
+        try {
+            E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
+            if (handlerController != null) {
+                handlerController.addToRealmObjects(realmObject);
+            }
+            return realmObject;
+        } catch (JSONException e) {
+            throw new RealmException("Could not map Json", e);
+        }
+    }
+
+    /**
+     * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
+     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
+     * be set to the default value for that type.
+     *
+     * @param clazz type of Realm object to create.
+     * @param json the JSON string with object data.
+     * @return created object or null if json string was empty or null.
+     * @throws RealmException if mapping to json failed.
+     */
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) {
+            return null;
+        }
+
+        JSONObject obj;
+        try {
+            obj = new JSONObject(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not create Json object from string", e);
+        }
+
+        return createObjectFromJson(clazz, obj);
+    }
+
+    /**
+     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
+     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a {@link RealmObject}
+     * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
+     * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
+     *
+     * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param json string with object data in JSON format.
+     * @return created or updated {@link io.realm.RealmObject}.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if JSON object cannot be mapped from the string parameter.
+     * @see #createObjectFromJson(Class, String)
+     */
+    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
+        if (clazz == null || json == null || json.length() == 0) {
+            return null;
+        }
+        checkHasPrimaryKey(clazz);
+
+        JSONObject obj;
+        try {
+            obj = new JSONObject(json);
+        } catch (Exception e) {
+            throw new RealmException("Could not create Json object from string", e);
+        }
+
+        return createOrUpdateObjectFromJson(clazz, obj);
+    }
+
+    /**
+     * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
+     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
+     * be set to the default value for that type.
+     *
+     * @param clazz type of Realm object to create.
+     * @param inputStream the JSON object data as a InputStream.
+     * @return created object or null if json string was empty or null.
+     * @throws RealmException if the mapping from JSON failed.
+     * @throws IOException if something was wrong with the input stream.
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        if (clazz == null || inputStream == null) {
+            return null;
+        }
+        E realmObject;
+        Table table = getTable(clazz);
+        if (table.hasPrimaryKey()) {
+            // As we need the primary key value we have to first parse the entire input stream as in the general
+            // case that value might be the last property :(
+            Scanner scanner = null;
+            try {
+                scanner = getFullStringScanner(inputStream);
+                JSONObject json = new JSONObject(scanner.next());
+                realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
+
+            } catch (JSONException e) {
+                throw new RealmException("Failed to read JSON", e);
+            } finally {
+                if (scanner != null) {
+                    scanner.close();
+                }
+            }
+        } else {
+            JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
+            try {
+                realmObject = configuration.getSchemaMediator().createUsingJsonStream(clazz, this, reader);
+            } finally {
+                reader.close();
+            }
+        }
+        return realmObject;
+    }
+
+    /**
+     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
+     * found a new object will be saved in the Realm. This must happen within a transaction. If updating a {@link RealmObject}
+     * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
+     * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
+     *
+     * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
+     * @param in the {@link InputStream} with object data in JSON format.
+     * @return created or updated {@link io.realm.RealmObject}.
+     * @throws java.lang.IllegalArgumentException if trying to update a class without a
+     * {@link io.realm.annotations.PrimaryKey}.
+     * @throws RealmException if failure to read JSON.
+     * @see #createObjectFromJson(Class, java.io.InputStream)
+     */
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
+        if (clazz == null || in == null) {
+            return null;
+        }
+        checkHasPrimaryKey(clazz);
+
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
+        try {
+            scanner = getFullStringScanner(in);
+            JSONObject json = new JSONObject(scanner.next());
+            return createOrUpdateObjectFromJson(clazz, json);
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
+        }
+    }
+
+    private Scanner getFullStringScanner(InputStream in) {
+        return new Scanner(in, "UTF-8").useDelimiter("\\A");
+    }
+
+    /**
+     * Instantiates and adds a new object to the Realm.
+     *
+     * @param clazz the Class of the object to create
+     * @return the new object
+     * @throws RealmException if an object could not be created
+     */
+    public <E extends RealmObject> E createObject(Class<E> clazz) {
+        checkIfValid();
+        Table table = getTable(clazz);
+        long rowIndex = table.addEmptyRow();
+        return get(clazz, rowIndex);
+    }
+
+    /**
+     * Creates a new object inside the Realm with the Primary key value initially set.
+     * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
+     * thrown.
+     *
+     * @param clazz the Class of the object to create.
+     * @param primaryKeyValue value for the primary key field.
+     * @return the new object.
+     * @throws RealmException if object could not be created.
+     */
+    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
+        Table table = getTable(clazz);
+        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
+        return get(clazz, rowIndex);
+    }
+
+    void remove(Class<? extends RealmObject> clazz, long objectIndex) {
+        getTable(clazz).moveLastOver(objectIndex);
+    }
+
+    /**
+     * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
+     * will not be reflected in the Realm copy. This is a deep copy, so all referenced objects will be copied. Objects
+     * already in this Realm will be ignored.
+     *
+     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param object the {@link io.realm.RealmObject} to copy to the Realm.
+     * @return a managed RealmObject with its properties backed by the Realm.
+     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null}.
+     */
+    public <E extends RealmObject> E copyToRealm(E object) {
+        checkNotNullObject(object);
+        return copyOrUpdate(object, false);
+    }
+
+    /**
+     * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or creates
+     * a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * either copied or updated.
+     *
+     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param object {@link io.realm.RealmObject} to copy or update.
+     * @return the new or updated RealmObject with all its properties backed by the Realm.
+     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
+     * @see #copyToRealm(RealmObject)
+     */
+    public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
+        checkNotNullObject(object);
+        checkHasPrimaryKey(object.getClass());
+        return copyOrUpdate(object, true);
+    }
+
+    /**
+     * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes to the
+     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy, so all referenced objects
+     * will be copied. Objects already in this Realm will be ignored.
+     *
+     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param objects the RealmObjects to copy to the Realm.
+     * @return a list of the the converted RealmObjects that all has their properties managed by the Realm.
+     * @throws io.realm.exceptions.RealmException if any of the objects has already been added to Realm.
+     * @throws java.lang.IllegalArgumentException if any of the elements in the input collection is {@code null}.
+     */
+    public <E extends RealmObject> List<E> copyToRealm(Iterable<E> objects) {
+        if (objects == null) {
+            return new ArrayList<E>();
+        }
+
+        ArrayList<E> realmObjects = new ArrayList<E>();
+        for (E object : objects) {
+            realmObjects.add(copyToRealm(object));
+        }
+
+        return realmObjects;
+    }
+
+    /**
+     * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
+     * creates a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects
+     * will be either copied or updated.
+     *
+     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * set to their default value if not provided.
+     *
+     * @param objects a list of objects to update or copy into Realm.
+     * @return a list of all the new or updated RealmObjects.
+     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
+     * @see #copyToRealm(Iterable)
+     */
+    public <E extends RealmObject> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
+        if (objects == null) {
+            return new ArrayList<E>(0);
+        }
+
+        ArrayList<E> realmObjects = new ArrayList<E>();
+        for (E object : objects) {
+            realmObjects.add(copyToRealmOrUpdate(object));
+        }
+
+        return realmObjects;
+    }
+
+    /**
+     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * referenced objects.
+     *
+     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
+     *
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
+     * but all fields will be overridden, not just those that were changed. This includes references to other objects,
+     * and can potentially override changes made by other threads.
+     *
+     * @param realmObjects RealmObjects to copy
+     * @param <E> type of object.
+     * @return an in-memory detached copy of managed RealmObjects.
+     * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
+     * @see #copyToRealmOrUpdate(Iterable)
+     */
+    public <E extends RealmObject> List<E> copyFromRealm(Iterable<E> realmObjects) {
+        return copyFromRealm(realmObjects, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * referenced objects up to the defined depth.
+     *
+     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
+     *
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(Iterable)},
+     * but all fields will be overridden, not just those that were changed. This includes references to other objects
+     * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
+     * changes made by other threads.
+     *
+     * @param realmObjects RealmObjects to copy.
+     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is {@code 0}.
+     * @param <E> type of object.
+     * @return an in-memory detached copy of the RealmObjects.
+     * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
+     *         {@link DynamicRealmObject}.
+     * @see #copyToRealmOrUpdate(Iterable)
+     */
+    public <E extends RealmObject> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
+        checkMaxDepth(maxDepth);
+        if (realmObjects == null) {
+            return new ArrayList<E>(0);
+        }
+
+        ArrayList<E> standaloneObjects = new ArrayList<E>();
+        Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> listCache = new HashMap<RealmObject, RealmObjectProxy.CacheData<RealmObject>>();
+        for (E object : realmObjects) {
+            checkValidObjectForDetach(object);
+            standaloneObjects.add(createDetachedCopy(object, maxDepth, listCache));
+        }
+
+        return standaloneObjects;
+    }
+
+    /**
+     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * all referenced objects.
+     *
+     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
+     *
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
+     * but all fields will be overridden, not just those that were changed. This includes references to other objects,
+     * and can potentially override changes made by other threads.
+     *
+     * @param realmObject {@link RealmObject} to copy
+     * @param <E> type of object.
+     * @return an in-memory detached copy of the managed {@link RealmObject}.
+     * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
+     * @see #copyToRealmOrUpdate(RealmObject)
+     */
+    public <E extends RealmObject> E copyFromRealm(E realmObject) {
+        return copyFromRealm(realmObject, Integer.MAX_VALUE);
+    }
+
+    /**
+     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * all referenced objects up to the defined depth.
+     *
+     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
+     *
+     * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmObject)},
+     * but all fields will be overridden, not just those that were changed. This includes references to other objects
+     * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
+     * changes made by other threads.
+     *
+     * @param realmObject {@link RealmObject} to copy
+     * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is {@code 0}.
+     * @param <E> type of object.
+     * @return an in-memory detached copy of the managed {@link RealmObject}.
+     * @throws IllegalArgumentException if {@code maxDepth < 0}, the RealmObject is no longer accessible or it is a
+     *         {@link DynamicRealmObject}.
+     * @see #copyToRealmOrUpdate(RealmObject)
+     */
+    public <E extends RealmObject> E copyFromRealm(E realmObject, int maxDepth) {
+        checkMaxDepth(maxDepth);
+        checkValidObjectForDetach(realmObject);
+        return createDetachedCopy(realmObject, maxDepth, new HashMap<RealmObject, RealmObjectProxy.CacheData<RealmObject>>());
+    }
+
+    boolean contains(Class<? extends RealmObject> clazz) {
+        return configuration.getSchemaMediator().getModelClasses().contains(clazz);
+    }
+
+    /**
+     * Returns a typed RealmQuery, which can be used to query for specific objects of this type
+     *
+     * @param clazz the class of the object which is to be queried for.
+     * @return a typed RealmQuery, which can be used to query for specific objects of this type.
+     * @see io.realm.RealmQuery
+     */
+    public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz) {
+        checkIfValid();
+        return RealmQuery.createQuery(this, clazz);
+    }
+
+    /**
+     * Gets all objects of a specific Class. If no objects exist, the returned RealmResults will not be {@code null}.
+     * The RealmResults.size() to check the number of objects instead.
+     *
+     * @param clazz the Class to get objects of.
+     * @return a RealmResult list containing the objects.
+     * @see io.realm.RealmResults
+     */
+    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz) {
+        return where(clazz).findAll();
+    }
+
+    /**
+     * Get all objects of a specific Class sorted by a field. If no objects exist, the returned {@link RealmResults}
+     * will not be {@code null}. The RealmResults.size() to check the number of objects instead.
+     *
+     * @param clazz the Class to get objects of.
+     * @param fieldName the field name to sort by.
+     * @param sortOrder how to sort the results.
+     * @return a sorted RealmResults containing the objects.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
+                                                                    Sort sortOrder) {
+        checkIfValid();
+        Table table = getTable(clazz);
+        long columnIndex = schema.columnIndices.getColumnIndex(clazz, fieldName);
+        if (columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+        }
+
+        TableView tableView = table.getSortedView(columnIndex, sortOrder);
+        return RealmResults.createFromTableOrView(this, tableView, clazz);
+    }
+
+
+    /**
+     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
+     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
+     *
+     * @param clazz the class ti get objects of.
+     * @param fieldName1 first field name to sort by.
+     * @param sortOrder1 sort order for first field.
+     * @param fieldName2 second field name to sort by.
+     * @param sortOrder2 sort order for second field.
+     * @return a sorted RealmResults containing the objects.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
+                                                                    Sort sortOrder1, String fieldName2,
+                                                                    Sort sortOrder2) {
+        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
+                sortOrder2});
+    }
+
+    /**
+     * Gets all objects of a specific class sorted by two specific field names.  If no objects exist, the returned
+     * {@link RealmResults} will not be {@code null}. The RealmResults.size() to check the number of objects instead.
+     *
+     * @param clazz the class ti get objects of.
+     * @param fieldName1 first field name to sort by.
+     * @param sortOrder1 sort order for first field.
+     * @param fieldName2 second field name to sort by.
+     * @param sortOrder2 sort order for second field.
+     * @param fieldName3 third field name to sort by.
+     * @param sortOrder3 sort order for third field.
+     * @return a sorted RealmResults containing the objects.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
+                                                                    Sort sortOrder1,
+                                                                    String fieldName2, Sort sortOrder2,
+                                                                    String fieldName3, Sort sortOrder3) {
+        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2, fieldName3},
+                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
+    }
+
+    /**
+     * Gets all objects of a specific Class sorted by multiple fields. If no objects exist, the returned
+     * {@link RealmResults} will not be null. The RealmResults.size() to check the number of objects instead.
+     *
+     * @param clazz the Class to get objects of.
+     * @param sortOrders sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
+     * @param fieldNames an array of field names to sort objects by. The objects are first sorted by fieldNames[0], then
+     *                   by fieldNames[1] and so forth.
+     * @return a sorted RealmResults containing the objects.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    @SuppressWarnings("unchecked")
+    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
+                                                                    Sort sortOrders[]) {
+        checkAllObjectsSortedParameters(fieldNames, sortOrders);
+        Table table = this.getTable(clazz);
+
+        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
+        return RealmResults.createFromTableOrView(this, tableView, clazz);
+    }
+
+    /**
+     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * returned in case of multiple occurrences.
+     *
+     * @param clazz the Class to get objects of.
+     * @param fieldName the field name.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
+        checkIfValid();
+        Table table = schema.getTable(clazz);
+        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
+        TableView tableView = table.getDistinctView(columnIndex);
+        return RealmResults.createFromTableOrView(this, tableView, clazz);
+    }
+
+    /**
+     * Returns a distinct set of objects of a specific class. As a Realm is unordered, it is undefined which objects are
+     * returned in case of multiple occurrences.
+     * This method is only available from a Looper thread.
+     *
+     * @param clazz the Class to get objects of.
+     * @param fieldName the field name.
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
+     * query completes.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public <E extends RealmObject> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
+        checkIfValid();
+        return where(clazz).distinctAsync(fieldName);
+    }
+
+    /**
+     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param clazz the Class to get objects of.
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     */
+    public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
+        checkIfValid();
+        return where(clazz).distinct(firstFieldName, remainingFieldNames);
+    }
+
+    /**
+     * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be
+     * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be
+     * called instead of {@link #commitTransaction()}.
+     *
+     * @param transaction the {@link io.realm.Realm.Transaction} to execute.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}.
+     */
+    public void executeTransaction(Transaction transaction) {
+        if (transaction == null) {
+            throw new IllegalArgumentException("Transaction should not be null");
+        }
+
+        beginTransaction();
+        try {
+            transaction.execute(this);
+            commitTransaction();
+        } catch (Throwable e) {
+            if (isInTransaction()) {
+                cancelTransaction();
+            } else {
+                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
+     *
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @param callback optional, to receive the result of this query.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     * @deprecated replaced by {@link #executeTransactionAsync(Transaction)}, {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess)}, {@link #executeTransactionAsync(Transaction, io.realm.Realm.Transaction.OnError)} and {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess, Transaction.OnError)}.
+     */
+    @Deprecated
+    public RealmAsyncTask executeTransaction(final Transaction transaction, final Transaction.Callback callback) {
+        checkIfValid();
+        if (transaction == null) {
+            throw new IllegalArgumentException("Transaction should not be null");
+        }
+
+        // If the user provided a Callback then we make sure, the current Realm has a Handler
+        // we can use to deliver the result
+        if (callback != null && handler == null) {
+            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
+                    " and you provided a callback, we need a Handler to invoke your callback");
+        }
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the transaction
+        final RealmConfiguration realmConfiguration = getConfiguration();
+
+        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                if (Thread.currentThread().isInterrupted()) {
+                    return;
+                }
+
+                boolean transactionCommitted = false;
+                final Exception[] exception = new Exception[1];
+                final Realm bgRealm = Realm.getInstance(realmConfiguration);
+                bgRealm.beginTransaction();
+                try {
+                    transaction.execute(bgRealm);
+
+                    if (!Thread.currentThread().isInterrupted()) {
+                        bgRealm.commitTransaction(false, new Runnable() {
+                            @Override
+                            public void run() {
+                                // The bgRealm needs to be closed before post event to caller's handler to avoid
+                                // concurrency problem. eg.: User wants to delete Realm in the callbacks.
+                                // This will close Realm before sending REALM_CHANGED.
+                                bgRealm.close();
+                            }
+                        });
+                        transactionCommitted = true;
+                    }
+                } catch (final Exception e) {
+                    exception[0] = e;
+                } finally {
+                    if (!bgRealm.isClosed()) {
+                        if (bgRealm.isInTransaction()) {
+                            bgRealm.cancelTransaction();
+                        } else if (exception[0] != null) {
+                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                        }
+                        bgRealm.close();
+                    }
+
+                    // Send response as the final step to ensure the bg thread quit before others get the response!
+                    if (callback != null
+                            && handler != null
+                            && !Thread.currentThread().isInterrupted()
+                            && handler.getLooper().getThread().isAlive()) {
+                        if (transactionCommitted) {
+                            handler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    callback.onSuccess();
+                                }
+                            });
+                        } else if (exception[0] != null) {
+                            // transaction has not been canceled by there is a exception during transaction.
+                            handler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    callback.onError(exception[0]);
+                                }
+                            });
+                        }
+                    }
+                }
+            }
+        });
+
+        return new RealmAsyncTask(pendingQuery);
+    }
+
+    /**
+     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
+     *
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     */
+    public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
+        return executeTransactionAsync(transaction, null, null);
+    }
+
+    /**
+     * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnSuccess callback.
+     *
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @param onSuccess callback invoked when the transaction succeeds.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     */
+    public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess) {
+        if (onSuccess == null) {
+            throw new IllegalArgumentException("onSuccess callback can't be null");
+        }
+
+        return executeTransactionAsync(transaction, onSuccess, null);
+    }
+
+    /**
+     * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnError callback.
+     *
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @param onError callback invoked when the transaction failed.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     */
+    public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnError onError) {
+        if (onError == null) {
+            throw new IllegalArgumentException("onError callback can't be null");
+        }
+
+        return executeTransactionAsync(transaction, null, onError);
+    }
+
+    /**
+     * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnSuccess and OnError callbacks.
+     *
+     * @param transaction {@link io.realm.Realm.Transaction} to execute.
+     * @param onSuccess callback invoked when the transaction succeeds.
+     * @param onError callback invoked when the transaction failed.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from another thread.
+     */
+    public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess, final Realm.Transaction.OnError onError) {
+        checkIfValid();
+
+        if (transaction == null) {
+            throw new IllegalArgumentException("Transaction should not be null");
+        }
+
+        // If the user provided a Callback then we make sure, the current Realm has a Handler
+        // we can use to deliver the result
+        if ((onSuccess != null || onError != null)  && handler == null) {
+            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
+                    " and you provided a callback, we need a Handler to invoke your callback");
+        }
+
+        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the transaction
+        final RealmConfiguration realmConfiguration = getConfiguration();
+
+        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                if (Thread.currentThread().isInterrupted()) {
+                    return;
+                }
+
+                boolean transactionCommitted = false;
+                final Throwable[] exception = new Throwable[1];
+                final Realm bgRealm = Realm.getInstance(realmConfiguration);
+                bgRealm.beginTransaction();
+                try {
+                    transaction.execute(bgRealm);
+
+                    if (!Thread.currentThread().isInterrupted()) {
+                        bgRealm.commitTransaction(false, new Runnable() {
+                            @Override
+                            public void run() {
+                                // The bgRealm needs to be closed before post event to caller's handler to avoid
+                                // concurrency problem. eg.: User wants to delete Realm in the callbacks.
+                                // This will close Realm before sending REALM_CHANGED.
+                                bgRealm.close();
+                            }
+                        });
+                        transactionCommitted = true;
+                    }
+                } catch (final Throwable e) {
+                    exception[0] = e;
+                } finally {
+                    if (!bgRealm.isClosed()) {
+                        if (bgRealm.isInTransaction()) {
+                            bgRealm.cancelTransaction();
+                        } else if (exception[0] != null) {
+                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                        }
+                        bgRealm.close();
+                    }
+
+                    final Throwable backgroundException = exception[0];
+                    // Send response as the final step to ensure the bg thread quit before others get the response!
+                    if (handler != null
+                            && !Thread.currentThread().isInterrupted()
+                            && handler.getLooper().getThread().isAlive()) {
+                        if (onSuccess != null && transactionCommitted) {
+                            handler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    onSuccess.onSuccess();
+                                }
+                            });
+                        }
+
+                        if (backgroundException != null) {
+                            if (onError != null) {
+                                handler.post(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        onError.onError(backgroundException);
+                                    }
+                                });
+                            } else {
+                                handler.post(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        if (backgroundException instanceof RuntimeException) {
+                                            throw (RuntimeException) backgroundException;
+                                        } else if (backgroundException instanceof Exception) {
+                                            throw new RealmException("Async transaction failed", backgroundException);
+                                        } else if (backgroundException instanceof Error) {
+                                            throw (Error) backgroundException;
+                                        }
+                                    }
+                                });
+                            }
+                        }
+                    } else {
+                        // Throw exception in the worker thread if the caller thread terminated
+                        if (backgroundException != null) {
+                            if (backgroundException instanceof RuntimeException) {
+                                //noinspection ThrowFromFinallyBlock
+                                throw (RuntimeException) backgroundException;
+                            } else if (backgroundException instanceof Exception) {
+                                //noinspection ThrowFromFinallyBlock
+                                throw new RealmException("Async transaction failed", backgroundException);
+                            } else if (backgroundException instanceof Error) {
+                                //noinspection ThrowFromFinallyBlock
+                                throw (Error) backgroundException;
+                            }
+                        }
+                    }
+                }
+            }
+        });
+
+        return new RealmAsyncTask(pendingQuery);
+    }
+
+
+    /**
+     * Removes all objects of the specified class.
+     *
+     * @param clazz the class which objects should be removed.
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    public void clear(Class<? extends RealmObject> clazz) {
+        checkIfValid();
+        getTable(clazz).clear();
+    }
+
+    @SuppressWarnings("unchecked")
+    private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
+        checkIfValid();
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmObject, RealmObjectProxy>());
+    }
+
+    private <E extends RealmObject> E createDetachedCopy(E object, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+        checkIfValid();
+        return configuration.getSchemaMediator().createDetachedCopy(object, maxDepth, cache);
+    }
+
+    private <E extends RealmObject> void checkNotNullObject(E object) {
+        if (object == null) {
+            throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
+        }
+    }
+
+    private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
+        if (!getTable(clazz).hasPrimaryKey()) {
+            throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
+        }
+    }
+
+    private void checkMaxDepth(int maxDepth) {
+        if (maxDepth < 0) {
+            throw new IllegalArgumentException("maxDepth must be > 0. It was: " + maxDepth);
+        }
+    }
+
+    private <E extends RealmObject> void checkValidObjectForDetach(E realmObject) {
+        if (realmObject == null) {
+            throw new IllegalArgumentException("Null objects cannot be copied from Realm.");
+        }
+        if (!realmObject.isValid()) {
+            throw new IllegalArgumentException("RealmObject is not valid, so it cannot be copied.");
+        }
+        if (realmObject instanceof DynamicRealmObject) {
+            throw new IllegalArgumentException("DynamicRealmObject cannot be copied from Realm.");
+        }
+    }
+
+    /**
+     * Manually trigger the migration associated with a given RealmConfiguration. If Realm is already at the latest
+     * version, nothing will happen.
+     *
+     * @param configuration {@link RealmConfiguration}
+     * @throws FileNotFoundException if the Realm file doesn't exist.
+     */
+    public static void migrateRealm(RealmConfiguration configuration) throws FileNotFoundException {
+        migrateRealm(configuration, null);
+    }
+
+    /**
+     * Manually trigger a migration on a RealmMigration.
+     *
+     * @param configuration the{@link RealmConfiguration}.
+     * @param migration the {@link RealmMigration} to run on the Realm. This will override any migration set on the
+     *                  configuration.
+     * @throws FileNotFoundException if the Realm file doesn't exist.
+     */
+    public static void migrateRealm(RealmConfiguration configuration, RealmMigration migration)
+            throws FileNotFoundException {
+        BaseRealm.migrateRealm(configuration, migration, new MigrationCallback() {
+            @Override
+            public void migrationComplete() {
+            }
+        });
+    }
+
+    /**
+     * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
+     * The Realm must be unused and closed before calling this method.
+     *
+     * @param configuration a {@link RealmConfiguration}.
+     * @return {@code false} if a file could not be deleted. The failing file will be logged.
+     */
+    public static boolean deleteRealm(RealmConfiguration configuration) {
+        return BaseRealm.deleteRealm(configuration);
+    }
+
+    /**
+     * Compacts a Realm file. A Realm file usually contain free/unused space.
+     * This method removes this free space and the file size is thereby reduced.
+     * Objects within the Realm files are untouched.
+     * <p>
+     * The file must be closed before this method is called, otherwise {@code false} will be returned.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
+     *
+     * @param configuration a {@link RealmConfiguration} pointing to a Realm file.
+     * @return {@code true} if successful, {@code false} if any file operation failed.
+     * @throws IllegalArgumentException if the realm file is encrypted. Compacting an encrypted Realm file is not
+     * supported yet.
+     */
+    public static boolean compactRealm(RealmConfiguration configuration) {
+        return BaseRealm.compactRealm(configuration);
+    }
+
+    // Get the canonical path for a given file
+    static String getCanonicalPath(File realmFile) {
+        try {
+            return realmFile.getCanonicalPath();
+        } catch (IOException e) {
+            throw new RealmException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+        }
+    }
+
+    @Deprecated
+    public Table getTable(Class<? extends RealmObject> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table == null) {
+            clazz = Util.getOriginalModelClass(clazz);
+            table = sharedGroupManager.getTable(configuration.getSchemaMediator().getTableName(clazz));
+            classToTable.put(clazz, table);
+        }
+        return table;
+    }
+
+    /**
+     * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
+     * from library or project dependencies. Realm classes in these should be exposed using their own module.
+     *
+     * @return the default Realm module or null if no default module exists.
+     * @throws RealmException if unable to create an instance of the module.
+     * @see io.realm.RealmConfiguration.Builder#setModules(Object, Object...)
+     */
+    public static Object getDefaultModule() {
+        String moduleName = "io.realm.DefaultRealmModule";
+        Class<?> clazz;
+        //noinspection TryWithIdenticalCatches
+        try {
+            clazz = Class.forName(moduleName);
+            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
+            constructor.setAccessible(true);
+            return constructor.newInstance();
+        } catch (ClassNotFoundException e) {
+            return null;
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
+        } catch (InstantiationException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
+        }
+    }
+
+    /**
+     * Encapsulates a Realm transaction.
+     * <p>
+     * Using this class will automatically handle {@link #beginTransaction()} and {@link #commitTransaction()}
+     * If any exception is thrown during the transaction {@link #cancelTransaction()} will be called instead of
+     * {@link #commitTransaction()}.
+     */
+    public interface Transaction {
+        void execute(Realm realm);
+
+        /**
+         * Callback invoked to notify the caller thread.
+         */
+        class Callback {
+            public void onSuccess() {}
+            public void onError(Exception e) {}
+        }
+
+        /**
+         * Callback invoked to notify the caller thread about the success of the transaction.
+         */
+        interface OnSuccess {
+            void onSuccess();
+        }
+
+        /**
+         * Callback invoked to notify the caller thread about error during the transaction.
+         * The transaction will be rolled back and the background Realm will be closed before
+         * invoking {@link #onError(Throwable)}.
+         */
+        interface OnError {
+            void onError(Throwable error);
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
new file mode 100644
index 0000000000..df1ec5987d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.concurrent.Future;
+
+/**
+ * Represents a pending asynchronous Realm transaction.
+ * <p>
+ * Users are responsible for maintaining a reference to {@code RealmAsyncTask} in order to call {@link #cancel()} in
+ * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
+ * caller's thread callback).
+ */
+public class RealmAsyncTask {
+    private final Future<?> pendingQuery;
+    private volatile boolean isCancelled = false;
+
+    public RealmAsyncTask(Future<?> pendingQuery) {
+        this.pendingQuery = pendingQuery;
+    }
+
+    /**
+     * Attempts to cancel execution of this transaction (if it hasn't already completed or previously cancelled).
+     */
+    public void cancel() {
+        pendingQuery.cancel(true);
+        isCancelled = true;
+
+        // From "Java Threads": By Scott Oaks & Henry Wong
+        // cancelled tasks are never executed, but may
+        // accumulate in work queues, which may causes a memory leak
+        // if the task hold references (to an enclosing class for example)
+        // we can use purge() but one caveat applies: if a second thread attempts to add
+        // something to the pool (using the execute() method) at the same time the
+        // first thread is attempting to purge the queue the attempt to purge
+        // the queue fails and the cancelled object remain in the queue.
+        // A better way to cancel objects with thread pools is to use the remove()
+        Realm.asyncQueryExecutor.getQueue().remove(pendingQuery);
+    }
+
+    /**
+     * Checks whether an attempt to cancel the transaction was performed.
+     *
+     * @return {@code true} if {@link #cancel()} has already been called, {@code false} otherwise.
+     */
+    public boolean isCancelled() {
+        return isCancelled;
+    }
+}
diff --git a/realm/src/main/java/io/realm/RealmBaseAdapter.java b/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
similarity index 70%
rename from realm/src/main/java/io/realm/RealmBaseAdapter.java
rename to realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
index 531c95422c..0d579c84d3 100644
--- a/realm/src/main/java/io/realm/RealmBaseAdapter.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmBaseAdapter.java
@@ -21,15 +21,15 @@
 import android.widget.BaseAdapter;
 
 /**
- * The RealmBaseAdapter class is an abstract utility class for binding UI elements to Realm data,
- * much like an {@link android.widget.CursorAdapter}.
+ * The RealmBaseAdapter class is an abstract utility class for binding UI elements to Realm data, much like an
+ * {@link android.widget.CursorAdapter}.
  * <p>
- * This adapter will automatically handle any updates to its data and call
- * {@link #notifyDataSetChanged()} as appropriate.
+ * This adapter will automatically handle any updates to its data and call {@link #notifyDataSetChanged()} as
+ * appropriate.
  * <p>
- * The RealmAdapter will stop receiving updates if the Realm instance providing the
- * {@link io.realm.RealmResults} is closed. Trying to access read objects, will at this point also
- * result in a {@link io.realm.exceptions.RealmException}.
+ * The RealmAdapter will stop receiving updates if the Realm instance providing the {@link io.realm.RealmResults} is
+ * closed. Trying to access read objects, will at this point also result in a
+ * {@link io.realm.exceptions.RealmException}.
  */
 public abstract class RealmBaseAdapter<T extends RealmObject> extends BaseAdapter {
 
@@ -53,10 +53,15 @@ public void onChange() {
         };
 
         if (listener != null && realmResults != null) {
-            realmResults.getRealm().addChangeListener(listener);
+            realmResults.realm.handlerController.addChangeListenerAsWeakReference(listener);
         }
     }
 
+    /**
+     * Returns how many items are in the data set.
+     *
+     * @return count of items.
+     */
     @Override
     public int getCount() {
         if (realmResults == null) {
@@ -65,6 +70,12 @@ public int getCount() {
         return realmResults.size();
     }
 
+    /**
+     * Returns the item associated with the specified position.
+     *
+     * @param i index of item whose data we want.
+     * @return the item at the specified position.
+     */
     @Override
     public T getItem(int i) {
         if (realmResults == null) {
@@ -74,12 +85,11 @@ public T getItem(int i) {
     }
 
     /**
-     * Returns the current ID for an item. Note that item IDs are not stable so you cannot rely on
-     * the item ID being the same after {@link #notifyDataSetChanged()} or
-     * {@link #updateRealmResults(RealmResults)} has been called.
+     * Returns the current ID for an item. Note that item IDs are not stable so you cannot rely on the item ID being the
+     * same after {@link #notifyDataSetChanged()} or {@link #updateRealmResults(RealmResults)} has been called.
      *
-     * @param i Index of item in the adapter
-     * @return Current item ID.
+     * @param i index of item in the adapter.
+     * @return current item ID.
      */
     @Override
     public long getItemId(int i) {
@@ -88,8 +98,8 @@ public long getItemId(int i) {
     }
 
     /**
-     * Update the RealmResults associated to the Adapter. Useful when the query has been changed.
-     * If the query does not change you might consider using the automaticUpdate feature
+     * Updates the RealmResults associated to the Adapter. Useful when the query has been changed.
+     * If the query does not change you might consider using the automaticUpdate feature.
      *
      * @param queryResults the new RealmResults coming from the new query.
      */
@@ -97,10 +107,10 @@ public void updateRealmResults(RealmResults<T> queryResults) {
         if (listener != null) {
             // Making sure that Adapter is refreshed correctly if new RealmResults come from another Realm
             if (this.realmResults != null) {
-                this.realmResults.getRealm().removeChangeListener(listener);
+                this.realmResults.realm.removeChangeListener(listener);
             }
             if (queryResults != null) {
-                queryResults.getRealm().addChangeListener(listener);
+                queryResults.realm.addChangeListener(listener);
             }
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
new file mode 100644
index 0000000000..5283cb590c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * To cache {@link Realm}, {@link DynamicRealm} instances and related resources.
+ * Every thread will share the same {@link Realm} and {@link DynamicRealm} instances which are referred to the same
+ * {@link RealmConfiguration}.
+ * One {@link RealmCache} is created for each {@link RealmConfiguration}, and it caches all the {@link Realm} and
+ * {@link DynamicRealm} instances which are created from the same {@link RealmConfiguration}.
+ */
+class RealmCache {
+
+    interface Callback {
+        void onResult(int count);
+    }
+
+    private static class RefAndCount {
+        // The Realm instance in this thread.
+        private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<BaseRealm>();
+        // How many references to this Realm instance in this thread.
+        private final ThreadLocal<Integer> localCount = new ThreadLocal<Integer>();
+        // How many threads have instances refer to this configuration.
+        private int globalCount = 0;
+    }
+    private enum RealmCacheType {
+        TYPED_REALM,
+        DYNAMIC_REALM;
+
+        static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
+            if (clazz == Realm.class) {
+                return TYPED_REALM;
+            } else if (clazz == DynamicRealm.class) {
+                return DYNAMIC_REALM;
+            }
+
+            throw new IllegalArgumentException(WRONG_REALM_CLASS_MESSAGE);
+        }
+    }
+    // Separated references and counters for typed Realm and dynamic Realm.
+    private final EnumMap<RealmCacheType, RefAndCount> refAndCountMap;
+
+    final private RealmConfiguration configuration;
+
+    // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
+    // Realm instances in other threads doesn't have to initialize the column indices again.
+    private ColumnIndices typedColumnIndices;
+
+    // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
+    // are not allowed and an exception will be thrown when trying to add it to the cache map.
+    private static Map<String, RealmCache> cachesMap = new HashMap<String, RealmCache>();
+
+    private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
+    private static final String WRONG_REALM_CLASS_MESSAGE = "The type of Realm class must be Realm or DynamicRealm.";
+
+    private RealmCache(RealmConfiguration config) {
+        configuration = config;
+        refAndCountMap = new EnumMap<RealmCacheType, RefAndCount>(RealmCacheType.class);
+        for (RealmCacheType type : RealmCacheType.values()) {
+            refAndCountMap.put(type, new RefAndCount());
+        }
+    }
+
+    /**
+     * Creates a new Realm instance or get an existing instance for current thread.
+     *
+     * @param configuration {@link RealmConfiguration} will be used to create or get the instance.
+     * @param realmClass class of {@link Realm} or {@link DynamicRealm} to be created in or gotten from the cache.
+     * @return the {@link Realm} or {@link DynamicRealm} instance.
+     */
+    static synchronized <E extends BaseRealm> E createRealmOrGetFromCache(RealmConfiguration configuration,
+                                                        Class<E> realmClass) {
+        boolean isCacheInMap = true;
+        RealmCache cache = cachesMap.get(configuration.getPath());
+        if (cache == null) {
+            // Create a new cache
+            cache = new RealmCache(configuration);
+            // The new cache should be added to the map later.
+            isCacheInMap = false;
+        } else {
+            // Throw the exception if validation failed.
+            cache.validateConfiguration(configuration);
+        }
+
+        RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+
+        if (refAndCount.localRealm.get() == null) {
+            // Create a new local Realm instance
+            BaseRealm realm;
+
+            if (realmClass == Realm.class) {
+                // RealmMigrationNeededException might be thrown here.
+                realm = Realm.createInstance(configuration, cache.typedColumnIndices);
+            } else if (realmClass == DynamicRealm.class) {
+                realm = DynamicRealm.createInstance(configuration);
+            } else {
+                throw new IllegalArgumentException(WRONG_REALM_CLASS_MESSAGE);
+            }
+
+            // The Realm instance has been created without exceptions. Cache and reference count can be updated now.
+
+            // The cache is not in the map yet. Add it to the map after the Realm instance created successfully.
+            if (!isCacheInMap) {
+                cachesMap.put(configuration.getPath(), cache);
+            }
+            refAndCount.localRealm.set(realm);
+            refAndCount.localCount.set(0);
+        }
+
+        Integer refCount = refAndCount.localCount.get();
+        if (refCount == 0) {
+            if (realmClass == Realm.class && refAndCount.globalCount == 0) {
+                cache.typedColumnIndices = refAndCount.localRealm.get().schema.columnIndices;
+            }
+            // This is the first instance in current thread, increase the global count.
+            refAndCount.globalCount++;
+        }
+        refAndCount.localCount.set(refCount + 1);
+
+        @SuppressWarnings("unchecked")
+        E realm = (E) refAndCount.localRealm.get();
+        return realm;
+    }
+
+    /**
+     * Releases a given {@link Realm} or {@link DynamicRealm} from cache. The instance will be closed by this method
+     * if there is no more local reference to this Realm instance in current Thread.
+     *
+     * @param realm Realm instance to be released from cache.
+     */
+    static synchronized void release(BaseRealm realm) {
+        String canonicalPath = realm.getPath();
+        RealmCache cache = cachesMap.get(canonicalPath);
+        Integer refCount = null;
+        RefAndCount refAndCount = null;
+
+        if (cache != null) {
+            refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realm.getClass()));
+            refCount = refAndCount.localCount.get();
+        }
+        if (refCount == null) {
+            refCount = 0;
+        }
+
+        if (refCount <= 0) {
+            RealmLog.w("Realm " + canonicalPath + " has been closed already.");
+            return;
+        }
+
+        // Decrease the local counter.
+        refCount -= 1;
+
+        if (refCount == 0) {
+            // The last instance in this thread.
+            // Clear local ref & counter
+            refAndCount.localCount.set(null);
+            refAndCount.localRealm.set(null);
+
+            // Clear global counter
+            refAndCount.globalCount--;
+            if (refAndCount.globalCount < 0) {
+                // Should never happen.
+                throw new IllegalStateException("Global reference counter of Realm" + canonicalPath +
+                        " got corrupted.");
+            }
+
+            // Clear the column indices cache if needed
+            if (realm instanceof Realm && refAndCount.globalCount == 0) {
+                // All typed Realm instances of this file are cleared from cache
+                cache.typedColumnIndices = null;
+            }
+
+            int totalRefCount = 0;
+            for (RealmCacheType type : RealmCacheType.values()) {
+                totalRefCount += cache.refAndCountMap.get(type).globalCount;
+            }
+            // No more instance of typed Realm and dynamic Realm. Remove the configuration from cache.
+            if (totalRefCount == 0) {
+                cachesMap.remove(canonicalPath);
+            }
+
+            // No more local reference to this Realm in current thread, close the instance.
+            realm.doClose();
+        } else {
+            refAndCount.localCount.set(refCount);
+        }
+    }
+
+    /**
+     * Make sure that the new configuration doesn't clash with any cached configurations for the
+     * Realm.
+     *
+     * @throws IllegalArgumentException if the new configuration isn't valid.
+     */
+    private void validateConfiguration(RealmConfiguration newConfiguration) {
+        if (configuration.equals(newConfiguration)) {
+            // Same configuration objects
+            return;
+        }
+
+        // Check that encryption keys aren't different. key is not in RealmConfiguration's toString.
+        if (!Arrays.equals(configuration.getEncryptionKey(), newConfiguration.getEncryptionKey())) {
+            throw new IllegalArgumentException(DIFFERENT_KEY_MESSAGE);
+        } else {
+            throw new IllegalArgumentException("Configurations cannot be different if used to open the same file. " +
+                    "\nCached configuration: \n" + configuration +
+                    "\n\nNew configuration: \n" + newConfiguration);
+        }
+    }
+
+    /**
+     * Runs the callback function with the total reference count of {@link Realm} and {@link DynamicRealm} who refer to
+     * the given {@link RealmConfiguration}.
+     *
+     * @param configuration the {@link RealmConfiguration} of {@link Realm} or {@link DynamicRealm}.
+     * @param callback the callback will be executed with the global reference count.
+     */
+    static synchronized void invokeWithGlobalRefCount(RealmConfiguration configuration, Callback callback) {
+        RealmCache cache = cachesMap.get(configuration.getPath());
+        if (cache == null) {
+            callback.onResult(0);
+            return;
+        }
+        int totalRefCount = 0;
+        for (RealmCacheType type : RealmCacheType.values()) {
+            totalRefCount += cache.refAndCountMap.get(type).globalCount;
+        }
+        callback.onResult(totalRefCount);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
new file mode 100644
index 0000000000..290910d634
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * RealmChangeListener can be registered with a {@link Realm}, {@link RealmResults} or {@link RealmObject}
+ * to receive a notification about updates.
+ * <p>
+ * When registered against a {@code Realm} you'll get notified when a Realm instance has been updated.
+ * Register against a {@code RealmResults} or {@code RealmObject} to only get notified about changes to them.
+ *
+ * <p>
+ * Realm instances on a thread without an {@link android.os.Looper} (almost all background threads) don't get updated
+ * automatically, but have to call {@link Realm#refresh()} manually. This will in turn trigger the RealmChangeListener
+ * for that background thread.
+ * <p>
+ * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain their new values when
+ * the {@link #onChange()} method is called. Normally this means that it isn't necessary to query again for those
+ * objects, but just invalidate any UI elements that are using them. If there is a chance that a object has been been
+ * deleted, it can be verified by using {@link RealmObject#isValid()}.
+ *
+ * @see Realm#addChangeListener(RealmChangeListener)
+ * @see Realm#removeAllChangeListeners()
+ * @see Realm#removeChangeListener(RealmChangeListener)
+ */
+public interface RealmChangeListener {
+
+    /**
+     * Called when a transaction is committed.
+     */
+    void onChange();
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
new file mode 100644
index 0000000000..46a77d2535
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -0,0 +1,527 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import io.realm.annotations.RealmModule;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.RealmCore;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.SharedGroup;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+import io.realm.rx.RealmObservableFactory;
+import io.realm.rx.RxObservableFactory;
+
+/**
+ * A RealmConfiguration is used to setup a specific Realm instance.
+ *
+ * Instances of a RealmConfiguration can only created by using the {@link io.realm.RealmConfiguration.Builder} and calling
+ * its {@link io.realm.RealmConfiguration.Builder#build()} method.
+ *
+ * A commonly used RealmConfiguration can easily be accessed by first saving it as
+ * {@link Realm#setDefaultConfiguration(RealmConfiguration)} and then using {@link io.realm.Realm#getDefaultInstance()}.
+ *
+ * A minimal configuration can be created using:
+ *
+ * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
+ *
+ * This will create a RealmConfiguration with the following properties.
+ * - Realm file is called "default.realm"
+ * - It is saved in Context.getFilesDir()
+ * - It has its schema version set to 0.
+ */
+public class RealmConfiguration {
+
+    public static final String DEFAULT_REALM_NAME = "default.realm";
+    public static final int KEY_LENGTH = 64;
+
+    private static final Object DEFAULT_MODULE;
+    private static final RealmProxyMediator DEFAULT_MODULE_MEDIATOR;
+    private static Boolean rxJavaAvailable;
+
+    static {
+        DEFAULT_MODULE = Realm.getDefaultModule();
+        if (DEFAULT_MODULE != null) {
+            final RealmProxyMediator mediator = getModuleMediator(DEFAULT_MODULE.getClass().getCanonicalName());
+            if (!mediator.transformerApplied()) {
+                throw new ExceptionInInitializerError("RealmTransformer doesn't seem to be applied." +
+                        " Please update the project configuration to use the Realm Gradle plugin." +
+                        " See https://realm.io/news/android-installation-change/");
+            }
+            DEFAULT_MODULE_MEDIATOR = mediator;
+        } else {
+            DEFAULT_MODULE_MEDIATOR = null;
+        }
+    }
+
+    private final File realmFolder;
+    private final String realmFileName;
+    private final String canonicalPath;
+    private final byte[] key;
+    private final long schemaVersion;
+    private final RealmMigration migration;
+    private final boolean deleteRealmIfMigrationNeeded;
+    private final SharedGroup.Durability durability;
+    private final RealmProxyMediator schemaMediator;
+    private final RxObservableFactory rxObservableFactory;
+
+    private RealmConfiguration(Builder builder) {
+        this.realmFolder = builder.folder;
+        this.realmFileName = builder.fileName;
+        this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.key = builder.key;
+        this.schemaVersion = builder.schemaVersion;
+        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
+        this.migration = builder.migration;
+        this.durability = builder.durability;
+        this.schemaMediator = createSchemaMediator(builder);
+        this.rxObservableFactory = builder.rxFactory;
+    }
+
+    public File getRealmFolder() {
+        return realmFolder;
+    }
+
+    public String getRealmFileName() {
+        return realmFileName;
+    }
+
+    public byte[] getEncryptionKey() {
+        return key == null ? null : Arrays.copyOf(key, key.length);
+    }
+
+    public long getSchemaVersion() {
+        return schemaVersion;
+    }
+
+    public RealmMigration getMigration() {
+        return migration;
+    }
+
+    public boolean shouldDeleteRealmIfMigrationNeeded() {
+        return deleteRealmIfMigrationNeeded;
+    }
+
+    public SharedGroup.Durability getDurability() {
+        return durability;
+    }
+
+    /**
+     * Returns the mediator instance of schema which is defined by this configuration.
+     *
+     * @return the mediator of the schema.
+     */
+    RealmProxyMediator getSchemaMediator() {
+        return schemaMediator;
+    }
+
+    /**
+     * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
+     *
+     * @return unmodifiable {@link Set} of model classes.
+     */
+    public Set<Class<? extends RealmObject>> getRealmObjectClasses() {
+        return schemaMediator.getModelClasses();
+    }
+
+    public String getPath() {
+        return canonicalPath;
+    }
+
+    /**
+     * Returns the {@link RxObservableFactory} that is used to create Rx Observables from Realm objects.
+     *
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
+     * @return the factory instance used to create Rx Observables.
+     */
+    public RxObservableFactory getRxFactory() {
+        // Since RxJava doesn't exist, rxObservableFactory is not initialized.
+        if (rxObservableFactory == null) {
+            throw new UnsupportedOperationException("RxJava seems to be missing from the classpath. " +
+                    "Remember to add it as a compile dependency." +
+                    " See https://realm.io/docs/java/latest/#rxjava for more details.");
+        }
+        return rxObservableFactory;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null || getClass() != obj.getClass()) return false;
+
+        RealmConfiguration that = (RealmConfiguration) obj;
+
+        if (schemaVersion != that.schemaVersion) return false;
+        if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) return false;
+        if (!realmFolder.equals(that.realmFolder)) return false;
+        if (!realmFileName.equals(that.realmFileName)) return false;
+        if (!canonicalPath.equals(that.canonicalPath)) return false;
+        if (!Arrays.equals(key, that.key)) return false;
+        if (!durability.equals(that.durability)) return false;
+        if (migration != null ? !migration.equals(that.migration) : that.migration != null) return false;
+        if (!rxObservableFactory.equals(that.rxObservableFactory)) return false;
+        return schemaMediator.equals(that.schemaMediator);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = realmFolder.hashCode();
+        result = 31 * result + realmFileName.hashCode();
+        result = 31 * result + canonicalPath.hashCode();
+        result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
+        result = 31 * result + (int)schemaVersion;
+        result = 31 * result + (migration != null ? migration.hashCode() : 0);
+        result = 31 * result + (deleteRealmIfMigrationNeeded ? 1 : 0);
+        result = 31 * result + schemaMediator.hashCode();
+        result = 31 * result + durability.hashCode();
+
+        return result;
+    }
+
+    // Creates the mediator that defines the current schema
+    private RealmProxyMediator createSchemaMediator(Builder builder) {
+
+        Set<Object> modules = builder.modules;
+        Set<Class<? extends RealmObject>> debugSchema = builder.debugSchema;
+
+        // If using debug schema, use special mediator
+        if (debugSchema.size() > 0) {
+            return new FilterableMediator(DEFAULT_MODULE_MEDIATOR, debugSchema);
+        }
+
+        // If only one module, use that mediator directly
+        if (modules.size() == 1) {
+            return getModuleMediator(modules.iterator().next().getClass().getCanonicalName());
+        }
+
+        // Otherwise combine all mediators
+        RealmProxyMediator[] mediators = new RealmProxyMediator[modules.size()];
+        int i = 0;
+        for (Object module : modules) {
+            mediators[i] = getModuleMediator(module.getClass().getCanonicalName());
+            i++;
+        }
+        return new CompositeMediator(mediators);
+    }
+
+    // Finds the mediator associated with a given module
+    private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleClassName) {
+        String[] moduleNameParts = fullyQualifiedModuleClassName.split("\\.");
+        String moduleSimpleName = moduleNameParts[moduleNameParts.length - 1];
+        String mediatorName = String.format("io.realm.%s%s", moduleSimpleName, "Mediator");
+        Class<?> clazz;
+        //noinspection TryWithIdenticalCatches
+        try {
+            clazz = Class.forName(mediatorName);
+            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
+            constructor.setAccessible(true);
+            return (RealmProxyMediator) constructor.newInstance();
+        } catch (ClassNotFoundException e) {
+            throw new RealmException("Could not find " + mediatorName, e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        } catch (InstantiationException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        }
+    }
+
+    @Override
+    public String toString() {
+        //noinspection StringBufferReplaceableByString
+        StringBuilder stringBuilder = new StringBuilder();
+        stringBuilder.append("realmFolder: ").append(realmFolder.toString());
+        stringBuilder.append("\n");
+        stringBuilder.append("realmFileName : ").append(realmFileName);
+        stringBuilder.append("\n");
+        stringBuilder.append("canonicalPath: ").append(canonicalPath);
+        stringBuilder.append("\n");
+        stringBuilder.append("key: ").append("[length: ").append(key == null ? 0 : KEY_LENGTH).append("]");
+        stringBuilder.append("\n");
+        stringBuilder.append("schemaVersion: ").append(Long.toString(schemaVersion));
+        stringBuilder.append("\n");
+        stringBuilder.append("migration: ").append(migration);
+        stringBuilder.append("\n");
+        stringBuilder.append("deleteRealmIfMigrationNeeded: ").append(deleteRealmIfMigrationNeeded);
+        stringBuilder.append("\n");
+        stringBuilder.append("durability: ").append(durability);
+        stringBuilder.append("\n");
+        stringBuilder.append("schemaMediator: ").append(schemaMediator);
+
+        return stringBuilder.toString();
+    }
+
+    /**
+     * Check if RxJava is can be loaded.
+     *
+     * @return true if RxJava dependency exist.
+     */
+    private static synchronized boolean isRxJavaAvailable() {
+        if (rxJavaAvailable == null) {
+            try {
+                Class.forName("rx.Observable");
+                rxJavaAvailable = true;
+            } catch (ClassNotFoundException ignore) {
+                rxJavaAvailable = false;
+            }
+        }
+        return rxJavaAvailable;
+    }
+
+    /**
+     * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
+     */
+    public static class Builder {
+        private File folder;
+        private String fileName;
+        private byte[] key;
+        private long schemaVersion;
+        private RealmMigration migration;
+        private boolean deleteRealmIfMigrationNeeded;
+        private SharedGroup.Durability durability;
+        private HashSet<Object> modules = new HashSet<Object>();
+        private HashSet<Class<? extends RealmObject>> debugSchema = new HashSet<Class<? extends RealmObject>>();
+        private RxObservableFactory rxFactory;
+
+        /**
+         * Creates an instance of the Builder for the RealmConfiguration.
+         * The Realm file will be saved in the provided folder.
+         *
+         * @param folder Folder to save Realm file in. Folder must be writable.
+         * @throws IllegalArgumentException if folder doesn't exists or isn't writable.
+         */
+        public Builder(File folder) {
+            RealmCore.loadLibrary();
+            initializeBuilder(folder);
+        }
+
+        /**
+         * Creates an instance of the Builder for the RealmConfiguration.
+         *
+         * This will use the apps own internal directory for storing the Realm file. This does not require any
+         * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
+         * change depending on vendor implementations of Android.
+         *
+         * @param context Android context.
+         */
+        public Builder(Context context) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            RealmCore.loadLibrary(context);
+            initializeBuilder(context.getFilesDir());
+        }
+
+        // Setup builder in its initial state
+        private void initializeBuilder(File folder) {
+            if (folder == null || !folder.isDirectory()) {
+                throw new IllegalArgumentException(("An existing folder must be provided. " +
+                        "Yours was " + (folder != null ? folder.getAbsolutePath() : "null")));
+            }
+            if (!folder.canWrite()) {
+                throw new IllegalArgumentException("Folder is not writable: " + folder.getAbsolutePath());
+            }
+
+            this.folder = folder;
+            this.fileName = Realm.DEFAULT_REALM_NAME;
+            this.key = null;
+            this.schemaVersion = 0;
+            this.migration = null;
+            this.deleteRealmIfMigrationNeeded = false;
+            this.durability = SharedGroup.Durability.FULL;
+            if (DEFAULT_MODULE != null) {
+                this.modules.add(DEFAULT_MODULE);
+            }
+        }
+
+        /**
+         * Sets the filename for the Realm.
+         */
+        public Builder name(String filename) {
+            if (filename == null || filename.isEmpty()) {
+                throw new IllegalArgumentException("A non-empty filename must be provided");
+            }
+
+            this.fileName = filename;
+            return this;
+        }
+
+        /**
+         * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         */
+        public Builder encryptionKey(byte[] key) {
+            if (key == null) {
+                throw new IllegalArgumentException("A non-null key must be provided");
+            }
+            if (key.length != KEY_LENGTH) {
+                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                        KEY_LENGTH, key.length));
+            }
+            this.key = Arrays.copyOf(key, key.length);
+            return this;
+        }
+
+        /**
+         * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
+         * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
+         *
+         * If no migration code is provided, Realm will throw a
+         * {@link io.realm.exceptions.RealmMigrationNeededException}.
+         *
+         * @see #migration(RealmMigration)
+         */
+        public Builder schemaVersion(long schemaVersion) {
+            if (schemaVersion < 0) {
+                throw new IllegalArgumentException("Realm schema version numbers must be 0 (zero) or higher. Yours was: " + schemaVersion);
+            }
+            this.schemaVersion = schemaVersion;
+            return this;
+        }
+
+        /**
+         * Sets the {@link io.realm.RealmMigration} to be run if a migration is needed. If this migration fails to
+         * upgrade the on-disc schema to the runtime schema, a {@link io.realm.exceptions.RealmMigrationNeededException}
+         * will be thrown.
+         */
+        public Builder migration(RealmMigration migration) {
+            if (migration == null) {
+                throw new IllegalArgumentException("A non-null migration must be provided");
+            }
+            this.migration = migration;
+            return this;
+        }
+
+        /**
+         * Setting this will change the behavior of how migration exceptions are handled. Instead of throwing a
+         * {@link io.realm.exceptions.RealmMigrationNeededException} the on-disc Realm will be cleared and recreated
+         * with the new Realm schema.
+         *
+         * <b>WARNING!</b> This will result in loss of data.
+         */
+        public Builder deleteRealmIfMigrationNeeded() {
+            this.deleteRealmIfMigrationNeeded = true;
+            return this;
+        }
+
+        /**
+         * Setting this will create an in-memory Realm instead of saving it to disk. In-memory Realms might still use
+         * disk space if memory is running low, but all files created by an in-memory Realm will be deleted when the
+         * Realm is closed.
+         * <p>
+         * Note that because in-memory Realms are not persisted, you must be sure to hold on to at least one non-closed
+         * reference to the in-memory Realm object with the specific name as long as you want the data to last.
+         */
+        public Builder inMemory() {
+            this.durability = SharedGroup.Durability.MEM_ONLY;
+            return this;
+        }
+
+        /**
+         * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
+         * current schema for this Realm with the schema defined by the provided modules.
+         *
+         * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
+         * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
+         * dependency is thus done using the following code:
+         *
+         * {@code builder.setModules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         *
+         * @param baseModule the first Realm module (required).
+         * @param additionalModules the additional Realm modules
+         * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
+         * @see Realm#getDefaultModule()
+         */
+        public Builder setModules(Object baseModule, Object... additionalModules) {
+            modules.clear();
+            addModule(baseModule);
+            if (additionalModules != null) {
+                for (int i = 0; i < additionalModules.length; i++) {
+                    Object module = additionalModules[i];
+                    addModule(module);
+                }
+            }
+            return this;
+        }
+
+        /**
+         * Sets the {@link RxObservableFactory} used to create Rx Observables from Realm objects.
+         * The default factory is {@link RealmObservableFactory}.
+         *
+         * @param factory factory to use.
+         */
+        public Builder rxFactory(RxObservableFactory factory) {
+            rxFactory = factory;
+            return this;
+        }
+
+        private void addModule(Object module) {
+            if (module != null) {
+                checkModule(module);
+                modules.add(module);
+            }
+        }
+
+        /**
+         * DEBUG method. This restricts the Realm schema to only consist of the provided classes without having to
+         * create a module. These classes must be available in the default module. Calling this will remove any
+         * previously configured modules.
+         */
+        Builder schema(Class<? extends RealmObject> firstClass, Class<? extends RealmObject>... additionalClasses) {
+            if (firstClass == null) {
+                throw new IllegalArgumentException("A non-null class must be provided");
+            }
+            modules.clear();
+            modules.add(DEFAULT_MODULE_MEDIATOR);
+            debugSchema.add(firstClass);
+            if (additionalClasses != null) {
+                Collections.addAll(debugSchema, additionalClasses);
+            }
+
+            return this;
+        }
+
+        /**
+         * Creates the RealmConfiguration based on the builder parameters.
+         *
+         * @return the created {@link RealmConfiguration}.
+         */
+        public RealmConfiguration build() {
+            if (rxFactory == null && isRxJavaAvailable()) {
+                rxFactory = new RealmObservableFactory();
+            }
+            return new RealmConfiguration(this);
+        }
+
+        private void checkModule(Object module) {
+            if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                        "Add @RealmModule to the class definition.");
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
new file mode 100644
index 0000000000..b5b4df2c0f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.nio.ByteBuffer;
+
+import io.realm.internal.Keep;
+import io.realm.internal.Mixed;
+
+/**
+ * List of the types used by Realm's underlying storage engine.
+ *
+ * Normally there is no reason to interact with the underlying Realm types as Realm will automatically
+ * convert between normal Java types and the Realm types. However it is possible to access these
+ * types through a {@link DynamicRealmObject}.
+ */
+@Keep
+public enum RealmFieldType {
+    // Make sure numbers match with <realm/column_type.hpp>
+    INTEGER(0),
+    BOOLEAN(1),
+    STRING(2),
+    BINARY(4),
+    UNSUPPORTED_TABLE(5),
+    UNSUPPORTED_MIXED(6),
+    DATE(7),
+    FLOAT(9),
+    DOUBLE(10),
+    OBJECT(12),
+    LIST(13);
+    // BACKLINK(14); Not exposed until needed
+
+    // Primitive array for fast mapping between between native values and their Realm type.
+    private static RealmFieldType[] typeList = new RealmFieldType[15];
+    static {
+        RealmFieldType[] columnTypes = values();
+        for (int i = 0; i < columnTypes.length; i++) {
+            int v = columnTypes[i].nativeValue;
+            typeList[v] = columnTypes[i];
+        }
+    }
+
+    private final int nativeValue;
+
+    RealmFieldType(int nativeValue) {
+        this.nativeValue = nativeValue;
+    }
+
+    /**
+     * Returns the native value representing this type.
+     *
+     * @return The value used by the underlying storage engine to represent this type.
+     */
+    public int getNativeValue() {
+        return nativeValue;
+    }
+
+    /**
+     * Checks if the given Java object can be converted to the underlying Realm type.
+     * @param obj Object to test compatibility on.
+     * @return {@code true} if object can be converted to the Realm type, {@code false} otherwise.
+     */
+    public boolean isValid(Object obj) {
+        switch (nativeValue) {
+            case 0: return (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte);
+            case 1: return (obj instanceof Boolean);
+            case 2: return (obj instanceof String);
+            case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
+            case 5: return (obj == null || obj instanceof Object[][]);
+            case 6: return (obj instanceof Mixed ||
+                    obj instanceof Long || obj instanceof Integer ||
+                    obj instanceof Short || obj instanceof Byte || obj instanceof Boolean ||
+                    obj instanceof Float || obj instanceof Double ||
+                    obj instanceof String ||
+                    obj instanceof byte[] || obj instanceof ByteBuffer ||
+                    obj == null || obj instanceof Object[][] ||
+                    obj instanceof java.util.Date);
+            case 7: return (obj instanceof java.util.Date);
+            case 9: return (obj instanceof Float);
+            case 10: return (obj instanceof Double);
+            case 12: return false;
+            case 13: return false;
+            case 14: return false;
+            default: throw new RuntimeException("Unsupported Realm type:  " + this);
+        }
+    }
+
+    /**
+     * Converts the underlying value used by the storage engine to the proper Realm type.
+     *
+     * @param value Value to convert
+     * @return The corresponding Realm type.
+     * @throws IllegalArgumentException if value isn't valid.
+     */
+    public static RealmFieldType fromNativeValue(int value) {
+        if (0 <= value && value < typeList.length) {
+            RealmFieldType e = typeList[value];
+            if (e != null) {
+                return e;
+            }
+        }
+        throw new IllegalArgumentException("Invalid native Realm type: " + value);
+    }
+}
+
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
new file mode 100644
index 0000000000..5cdd3e4e82
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import io.realm.exceptions.RealmException;
+import io.realm.internal.InvalidRow;
+import io.realm.internal.LinkView;
+import io.realm.internal.Table;
+
+/**
+ * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
+ * RealmList has two modes: A managed and non-managed mode. In managed mode all objects are persisted inside a Realm, in
+ * non-managed mode it works as a normal ArrayList.
+ * <p>
+ * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the
+ * underlying Realm is updated, and can only be accessed using the getter of a {@link io.realm.RealmObject}.
+ * <p>
+ * Non-managed RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
+ * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
+ * Non-managed elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
+ * <p>
+ * {@link RealmList} can contain more elements than {@code Integer.MAX_VALUE}.
+ * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
+ *
+ * @param <E> the class of objects in list.
+ */
+
+public class RealmList<E extends RealmObject> extends AbstractList<E> {
+
+    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
+    private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
+
+    private final boolean managedMode;
+    protected Class<E> clazz;
+    protected String className;
+    protected LinkView view;
+    protected BaseRealm realm;
+    private List<E> nonManagedList;
+
+    /**
+     * Creates a RealmList in non-managed mode, where the elements are not controlled by a Realm.
+     * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
+     * the objects in this state.
+     * <p>
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist it's elements in Realm.
+     */
+    public RealmList() {
+        managedMode = false;
+        nonManagedList = new ArrayList<E>();
+    }
+
+    /**
+     * Creates a RealmList in non-managed mode with an initial list of elements.
+     * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not possible to query the
+     * objects in this state.
+     *
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements in Realm.
+     *
+     * @param objects initial objects in the list.
+     */
+    public RealmList(E... objects) {
+        if (objects == null) {
+            throw new IllegalArgumentException("The objects argument cannot be null");
+        }
+        managedMode = false;
+        nonManagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(nonManagedList, objects);
+    }
+
+    /**
+     * Creates a RealmList from a LinkView, so its elements are managed by Realm.
+     *
+     * @param clazz type of elements in the Array
+     * @param linkView  backing LinkView
+     * @param realm reference to Realm containing the data
+     */
+    RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
+        this.managedMode = true;
+        this.clazz = clazz;
+        this.view = linkView;
+        this.realm = realm;
+    }
+
+    RealmList(String className, LinkView linkView, BaseRealm realm) {
+        this.managedMode = true;
+        this.view = linkView;
+        this.realm = realm;
+        this.className = className;
+    }
+
+    /**
+     * Checks if {@link io.realm.RealmResults} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't
+     * been closed.
+     *
+     * @return {@code true} if still valid to use, {@code false} otherwise or if it is a standalone object.
+     */
+    public boolean isValid() {
+        //noinspection SimplifiableIfStatement
+        if (!managedMode) {
+            return false;
+        }
+
+        return isAttached();
+    }
+
+    private boolean isAttached() {
+        return view != null && view.isAttached();
+    }
+
+    /**
+     * Inserts the specified object into this List at the specified location. The object is inserted before any previous
+     * element at the specified location. If the location is equal to the size of this List, the object is added at the
+     * end.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     *
+     * @param location the index at which to insert.
+     * @param object the object to add.
+     * @throws IllegalStateException if Realm instance has been closed or container object has been removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
+     */
+    @Override
+    public void add(int location, E object) {
+        checkValidObject(object);
+        if (managedMode) {
+            checkValidView();
+            object = copyToRealmIfNeeded(object);
+            view.insert(location, object.row.getIndex());
+        } else {
+            nonManagedList.add(location, object);
+        }
+    }
+
+    /**
+     * Adds the specified object at the end of this List.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     *
+     * @param object the object to add.
+     * @return always true
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     */
+    @Override
+    public boolean add(E object) {
+        checkValidObject(object);
+        if (managedMode) {
+            checkValidView();
+            object = copyToRealmIfNeeded(object);
+            view.add(object.row.getIndex());
+        } else {
+            nonManagedList.add(object);
+        }
+        return true;
+    }
+
+    /**
+     * Replaces the element at the specified location in this list with the specified object.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed.
+     * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)} or
+     * {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     * @param location the index at which to put the specified object.
+     * @param object the object to add.
+     * @return the previous element at the index.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     */
+    @Override
+    public E set(int location, E object) {
+        checkValidObject(object);
+        if (managedMode) {
+            checkValidView();
+            object = copyToRealmIfNeeded(object);
+            E oldObject = get(location);
+            view.set(location, object.row.getIndex());
+            return oldObject;
+        } else {
+            return nonManagedList.set(location, object);
+        }
+    }
+
+    // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
+    private E copyToRealmIfNeeded(E object) {
+        if (object instanceof DynamicRealmObject) {
+            String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
+            String objectClassName = ((DynamicRealmObject) object).getType();
+            if (object.realm == realm) {
+                if (listClassName.equals(objectClassName)) {
+                    // Same Realm instance and same target table
+                    return object;
+                } else {
+                    // Different target table
+                    throw new IllegalArgumentException(String.format("The object has a different type from list's." +
+                            " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
+                }
+            } else if (realm.threadId == object.realm.threadId) {
+                // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
+                // you have to run a full schema validation for each object.
+                // And copying from another Realm instance pointed to the same Realm file is not supported as well.
+                throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
+            } else {
+                throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
+            }
+        } else {
+            // Object is already in this realm
+            if (object.row != null && object.realm.getPath().equals(realm.getPath())) {
+                if (realm != object.realm) {
+                    throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
+                }
+                return object;
+            }
+        }
+
+        // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
+        Realm realm = (Realm) this.realm;
+        if (realm.getTable(object.getClass()).hasPrimaryKey()) {
+            return realm.copyToRealmOrUpdate(object);
+        } else {
+            return realm.copyToRealm(object);
+        }
+    }
+
+    /**
+     * Moves an object from one position to another, while maintaining a fixed sized list.
+     * RealmObjects will be shifted so no null values are introduced.
+     *
+     * @param oldPos index of RealmObject to move.
+     * @param newPos target position. If newPos &lt; oldPos the object at the location will be shifted to the right. If
+     *               oldPos &lt; newPos, indexes &gt; oldPos will be shifted once to the left.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @throws java.lang.IndexOutOfBoundsException if any position is outside [0, size()].
+     */
+    public void move(int oldPos, int newPos) {
+        if (managedMode) {
+            checkValidView();
+            view.move(oldPos, newPos);
+        } else {
+            checkIndex(oldPos);
+            checkIndex(newPos);
+            E object = nonManagedList.remove(oldPos);
+            if (newPos > oldPos) {
+                nonManagedList.add(newPos - 1, object);
+            } else {
+                nonManagedList.add(newPos, object);
+            }
+        }
+    }
+
+    /**
+     * Removes all elements from this list, leaving it empty. This method doesn't remove the objects from the Realm.
+     *
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @see List#isEmpty
+     * @see List#size
+     * @see #deleteAllFromRealm()
+     */
+    @Override
+    public void clear() {
+        if (managedMode) {
+            checkValidView();
+            view.clear();
+        } else {
+            nonManagedList.clear();
+        }
+    }
+
+    /**
+     * Removes the object at the specified location from this list.
+     *
+     * @param location the index of the object to remove.
+     * @return the removed object.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     */
+    @Override
+    public E remove(int location) {
+        if (managedMode) {
+            checkValidView();
+            E removedItem = get(location);
+            view.remove(location);
+            return removedItem;
+        } else {
+            return nonManagedList.remove(location);
+        }
+    }
+
+    /**
+     * Removes all elements from this list and delete them from the corresponding Realm. This method can be called on a
+     * non-managed {@link RealmList} if all of the RealmObjects in the list are managed by Realm.
+     *
+     * @throws IllegalStateException if the Realm instance has been closed, the parent object has been removed, the
+     * method is called in a wrong thread or any RealmObject in the list is not managed by Realm.
+     * @see #clear()
+     */
+    public void deleteAllFromRealm() {
+        if (managedMode) {
+            checkValidView();
+            view.removeAllTargetRows();
+        } else {
+            for (RealmObject object : nonManagedList) {
+                object.removeFromRealm();
+            }
+            nonManagedList.clear();
+        }
+    }
+
+    /**
+     * Returns the element at the specified location in this list.
+     *
+     * @param location the index of the element to return.
+     * @return the element at the specified index.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     */
+    @Override
+    public E get(int location) {
+        if (managedMode) {
+            checkValidView();
+            long rowIndex = view.getTargetRowIndex(location);
+            return realm.get(clazz, className, rowIndex);
+        } else {
+            return nonManagedList.get(location);
+        }
+    }
+
+    /**
+     * Finds the first object.
+     *
+     * @return the first object or {@code null} if the list is empty.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     */
+    public E first() {
+        if (managedMode) {
+            checkValidView();
+            return view.isEmpty() ? null : get(0);
+        } else if (nonManagedList != null && nonManagedList.size() > 0) {
+            return nonManagedList.get(0);
+        }
+        return null;
+    }
+
+    /**
+     * Finds the last object.
+     *
+     * @return the last object or {@code null} if the list is empty.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     */
+    public E last() {
+        if (managedMode) {
+            checkValidView();
+            return view.isEmpty() ? null : get((int) view.size() - 1);
+        } else if (nonManagedList != null && nonManagedList.size() > 0) {
+            return nonManagedList.get(nonManagedList.size() - 1);
+        }
+        return null;
+    }
+
+    /**
+     * Returns the number of elements in this {@code List}.
+     *
+     * @return the number of elements in this {@code List}.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     */
+    @Override
+    public int size() {
+        if (managedMode) {
+            checkValidView();
+            long size = view.size();
+            return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
+        } else {
+            return nonManagedList.size();
+        }
+    }
+
+    /**
+     * Returns a RealmQuery, which can be used to query for specific objects of this class.
+     *
+     * @return a RealmQuery object.
+     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * @see io.realm.RealmQuery
+     */
+    public RealmQuery<E> where() {
+        if (managedMode) {
+            checkValidView();
+            return RealmQuery.createQueryFromList(this);
+        } else {
+            throw new RealmException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+    }
+
+    /**
+     * Returns true if the list contains the specified element when attached to a Realm. This
+     * method will query the native Realm underlying storage engine to quickly find the specified element.
+     *
+     * If this list is not attached to a Realm the default {@link List#contains(Object)}
+     * implementation will occur.
+     *
+     * @param object the element whose presence in this list is to be tested.
+     * @return {@code true} if this list contains the specified element otherwise {@code false}.
+     */
+    @Override
+    public boolean contains(Object object) {
+        boolean contains = false;
+        if (managedMode) {
+            if (object instanceof RealmObject) {
+                RealmObject realmObject = (RealmObject) object;
+                if (realmObject.row != null && realm.getPath().equals(realmObject.realm.getPath()) && realmObject.row != InvalidRow.INSTANCE) {
+                    contains = view.contains(realmObject.row.getIndex());
+                }
+            }
+        } else {
+            contains = nonManagedList.contains(object);
+        }
+        return contains;
+    }
+
+    private void checkValidObject(E object) {
+        if (object == null) {
+            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
+        }
+    }
+
+    private void checkIndex(int location) {
+        int size = size();
+        if (location < 0 || location >= size) {
+            throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size);
+        }
+    }
+
+    private void checkValidView() {
+        realm.checkIfValid();
+        if (view == null || !view.isAttached()) {
+            throw new IllegalStateException("Realm instance has been closed or parent object has been removed.");
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(managedMode ? clazz.getSimpleName() : getClass().getSimpleName());
+        sb.append("@[");
+        if (managedMode && !isAttached()) {
+            sb.append("invalid");
+        } else {
+            for (int i = 0; i < size(); i++) {
+                if (managedMode) {
+                    sb.append(get(i).row.getIndex());
+                } else {
+                    sb.append(System.identityHashCode(get(i)));
+                }
+                if (i < size() - 1) {
+                    sb.append(',');
+                }
+            }
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmMigration.java b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
new file mode 100644
index 0000000000..70ec9df868
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * The RealmMigration class is used to perform the migration of one Realm schema to another.
+ * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}, so any
+ * changes to these classes will require a migration.
+ *
+ * To support migrations from any previous schemaVersion to the newest, the following pattern is recommended when
+ * writing a migration:
+ *
+ * <pre>
+ * {@code
+ * public class CustomMigration implements RealmMigration {
+ *   \@Override
+ *   public long migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+ *     RealmSchema schema = realm.getSchema();
+ *
+ *     if (oldVersion == 0) {
+ *       // Migrate from v0 to v1
+ *       oldVersion++;
+ *     }
+ *
+ *     if (oldVersion == 1) {
+ *       // Migrate from v1 to v2
+ *       oldVersion++;
+ *     }
+ *
+ *     if (oldVersion < newVersion) {
+ *         throw new IllegalStateException(String.format("Migration missing from v%d to v%d", oldVersion, newVersion));
+ *     }
+ *   }
+ * }
+ * }
+ * </pre>
+ *
+ * During development when RealmObject classes can change frequently, it is possible to use
+ * {@link io.realm.Realm#deleteRealm(RealmConfiguration)}. This will delete the database file and eliminate the need for
+ * any migrations.
+ *
+ * @see io.realm.RealmConfiguration.Builder#schemaVersion(long)
+ * @see io.realm.RealmConfiguration.Builder#migration(RealmMigration)
+ * @see io.realm.RealmConfiguration.Builder#deleteRealmIfMigrationNeeded()
+ */
+public interface RealmMigration {
+
+    /**
+     * This method will be called if a migration is needed. The entire method is wrapped in a
+     * write transaction so it is possible to create/change or delete any existing objects
+     * without wrapping it in your own transaction.
+     *
+     * @param realm the Realm schema on which to perform the migration.
+     * @param oldVersion the schema version of the Realm at the start of the migration.
+     * @param newVersion the schema version of the Realm after executing the migration.
+     */
+    void migrate(DynamicRealm realm, long oldVersion, long newVersion);
+}
+
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
new file mode 100644
index 0000000000..03827e330e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
+
+import io.realm.annotations.RealmClass;
+import io.realm.internal.InvalidRow;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+import io.realm.internal.TableQuery;
+import io.realm.internal.log.RealmLog;
+import rx.Observable;
+
+/**
+ * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then 
+ * create your objects within a Realm, and use your custom subclasses instead of using the RealmObject class directly.
+ * <p>
+ * An annotation processor will create a proxy class for your RealmObject subclass.
+ * <p>
+ * The following field data types are supported:
+ * <ul>
+ *   <li>boolean/Boolean</li>
+ *   <li>short/Short</li>
+ *   <li>int/Integer</li>
+ *   <li>long/Long</li>
+ *   <li>float/Float</li>
+ *   <li>double/Double</li>
+ *   <li>byte[]</li>
+ *   <li>String</li>
+ *   <li>Date</li>
+ *   <li>Any RealmObject subclass</li>
+ *   <li>RealmList</li>
+ * </ul>
+ * <p>
+ * The types <code>short</code>, <code>int</code>, and <code>long</code> are mapped to <code>long</code> when storing
+ * within a Realm.
+ * <p>
+ * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
+ * Any method as well as public fields are allowed.
+ * <p>
+ * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
+ * getter or setter.
+ * <p>
+ * Realm will create indexes for fields annotated with {@link io.realm.annotations.Index}. This will speedup queries but
+ * will have a negative impact on inserts and updates.
+ * <p>
+ * A RealmObject cannot be passed between different threads.
+ *
+ * @see Realm#createObject(Class)
+ * @see Realm#copyToRealm(RealmObject)
+ */
+
+@RealmClass
+public abstract class RealmObject {
+
+    protected Row row;
+    protected BaseRealm realm;
+
+    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    private Future<Long> pendingQuery;
+    private boolean isCompleted = false;
+    private long currentTableVersion = -1;
+
+    /**
+     * Removes the object from the Realm it is currently associated to.
+     * <p>
+     * After this method is called the object will be invalid and any operation (read or write) performed on it will
+     * fail with an IllegalStateException
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    public void removeFromRealm() {
+        if (row == null) {
+            throw new IllegalStateException("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
+        }
+        if (realm == null) {
+            throw new IllegalStateException("Object malformed: missing Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
+        }
+        realm.checkIfValid();
+
+        row.getTable().moveLastOver(row.getIndex());
+        row = InvalidRow.INSTANCE;
+    }
+
+    /**
+     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     *
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     */
+    public final boolean isValid() {
+        return row != null && row.isAttached();
+    }
+
+    protected Table getTable () {
+        return realm.schema.getTable(getClass());
+    }
+
+    /**
+     * Sets the Future instance returned by the worker thread, we need this instance to force {@link #load()} an async
+     * query, we use it to determine if the current RealmResults is a sync or async one.
+     *
+     * @param pendingQuery pending query.
+     */
+    void setPendingQuery(Future<Long> pendingQuery) {
+        this.pendingQuery = pendingQuery;
+        if (isLoaded()) {
+            // the query completed before RealmQuery
+            // had a chance to call setPendingQuery to register the pendingQuery (used btw
+            // to determine isLoaded behaviour)
+            onCompleted();
+
+        } // else, it will be handled by the Realm#handler
+    }
+
+    /**
+     * Determines if the current RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
+     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     *
+     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * progress.
+     */
+    public final boolean isLoaded() {
+        if (realm == null) {
+            return true;
+        }
+        realm.checkIfValid();
+        return pendingQuery == null || isCompleted;
+    }
+
+    /**
+     * Makes an asynchronous query blocking. This will also trigger any registered listeners.
+     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     *
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     */
+    public final boolean load() {
+        //noinspection SimplifiableIfStatement
+        if (isLoaded()) {
+            return true;
+        } else {
+            // doesn't guarantee to import correctly the result (because the user may have advanced)
+            // in this case the Realm#handler will be responsible of retrying
+            return onCompleted();
+        }
+    }
+
+    /**
+     * Called to import the handover row pointer & notify listeners.
+     *
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     */
+    boolean onCompleted() {
+        try {
+            Long handoverResult = pendingQuery.get();// make the query blocking
+            if (handoverResult != 0) {
+                // this may fail with BadVersionException if the caller and/or the worker thread
+                // are not in sync (same shared_group version).
+                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread
+                // this should handle more complex use cases like retry, ignore etc
+                onCompleted(handoverResult);
+                notifyChangeListeners();
+            } else {
+                isCompleted = true;
+            }
+        } catch (Exception e) {
+            RealmLog.d(e.getMessage());
+            return false;
+        }
+        return true;
+    }
+
+    void onCompleted(Long handoverRowPointer) {
+        if (handoverRowPointer == 0) {
+            // we'll retry later to update the row pointer, but we consider
+            // the query done
+            isCompleted = true;
+
+        } else if (!isCompleted || row == Row.EMPTY_ROW) {
+            isCompleted = true;
+            long nativeRowPointer = TableQuery.nativeImportHandoverRowIntoSharedGroup(handoverRowPointer, realm.sharedGroupManager.getNativePointer());
+            Table table = getTable();
+            this.row = table.getUncheckedRowByPointer(nativeRowPointer);
+        }// else: already loaded query no need to import again the pointer
+    }
+
+    /**
+     * Adds a change listener to this RealmObject.
+     *
+     * @param listener the change listener to be notified.
+     */
+    public final void addChangeListener(RealmChangeListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
+        if (realm != null) {
+            realm.checkIfValid();
+        } else {
+            throw new IllegalArgumentException("Cannot add listener from this unmanaged RealmObject (created outside of Realm)");
+        }
+        if (realm.handler == null) {
+            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+        }
+        if (!listeners.contains(listener)) {
+            listeners.add(listener);
+        }
+    }
+
+    /**
+     * Removes a previously registered listener.
+     *
+     * @param listener the instance to be removed.
+     */
+    public final void removeChangeListener(RealmChangeListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
+        if (realm != null) {
+            realm.checkIfValid();
+        } else {
+            throw new IllegalArgumentException("Cannot remove listener from this unmanaged RealmObject (created outside of Realm)");
+        }
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all registered listeners.
+     */
+    public final void removeChangeListeners() {
+        if (realm != null) {
+            realm.checkIfValid();
+        } else {
+            throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
+        }
+        listeners.clear();
+    }
+
+    /**
+     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
+     * {@code onComplete} will never be called.
+     *
+     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * type information, otherwise the type of the following observables will be {@code RealmObject}.
+     *
+     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * only emit only the first item by using the {@code first()} operator:
+     *
+     * <pre>
+     * {@code
+     * obj.asObservable()
+     *      .filter(obj -> obj.isLoaded())
+     *      .first()
+     *      .subscribe( ... ) // You only get the object once
+     * }
+     * </pre>
+     *
+     * @param <E> RealmObject class that is being observed. Must be this class or its super types.
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public <E extends RealmObject> Observable<E> asObservable() {
+        if (realm instanceof Realm) {
+            @SuppressWarnings("unchecked")
+            E obj = (E) this;
+            return realm.configuration.getRxFactory().from((Realm) realm, obj);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            DynamicRealmObject dynamicObject = (DynamicRealmObject) this;
+            @SuppressWarnings("unchecked")
+            Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm,
+                    dynamicObject);
+            return observable;
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
+                    " See https://realm.io/docs/java/latest/#rxjava for more details.");
+        }
+    }
+
+    /**
+     * Notifies all registered listeners.
+     */
+    void notifyChangeListeners() {
+        if (!listeners.isEmpty()) {
+            boolean notify = false;
+
+            Table table = row.getTable();
+            if (table == null) {
+                // Completed async queries might result in `table == null`, `isCompleted == true` and `row == Row.EMPTY_ROW`
+                // We still want to trigger change notifications for these cases.
+                // isLoaded / isValid should be considered properties on RealmObjects as well so any change to these
+                // should trigger a RealmChangeListener.
+                notify = true;
+            } else {
+                long version = table.version();
+                if (currentTableVersion != version) {
+                    currentTableVersion = version;
+                    notify = true;
+                }
+            }
+
+            if (notify) {
+                for (RealmChangeListener listener : listeners) {
+                    listener.onChange();
+                }
+            }
+        }
+    }
+
+    void setTableVersion() {
+        if (row.getTable() != null) {
+            currentTableVersion = row.getTable().version();
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
new file mode 100644
index 0000000000..47966ecc27
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -0,0 +1,702 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.annotations.Required;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+
+/**
+ * Class for interacting with the schema for a given RealmObject class. This makes it possible to
+ * add, delete or change the fields for given class.
+ *
+ * @see io.realm.RealmMigration
+ */
+public final class RealmObjectSchema {
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
+    static {
+        SUPPORTED_SIMPLE_FIELDS = new HashMap<Class<?>, FieldMetaData>();
+        SUPPORTED_SIMPLE_FIELDS.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
+        SUPPORTED_SIMPLE_FIELDS.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        SUPPORTED_SIMPLE_FIELDS.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        SUPPORTED_SIMPLE_FIELDS.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        SUPPORTED_SIMPLE_FIELDS.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
+        SUPPORTED_SIMPLE_FIELDS.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
+        SUPPORTED_SIMPLE_FIELDS.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
+        SUPPORTED_SIMPLE_FIELDS.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        SUPPORTED_SIMPLE_FIELDS.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        SUPPORTED_SIMPLE_FIELDS.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
+        SUPPORTED_SIMPLE_FIELDS.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+    }
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
+    static {
+        SUPPORTED_LINKED_FIELDS = new HashMap<Class<?>, FieldMetaData>();
+        SUPPORTED_LINKED_FIELDS.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
+        SUPPORTED_LINKED_FIELDS.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+    }
+
+    private final BaseRealm realm;
+    final Table table;
+    private final ImplicitTransaction transaction;
+    private final Map<String, Long> columnIndices;
+
+    /**
+     * Creates a schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     * @param columnIndices mapping between field names and column indexes for the given table
+     */
+    RealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
+        this.realm = realm;
+        this.transaction = realm.sharedGroupManager.getTransaction();
+        this.table = table;
+        this.columnIndices = columnIndices;
+    }
+
+    /**
+     * Returns the name of the RealmObject class being represented by this schema.
+     * <p>
+     * When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.
+     * When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.
+     *
+     * @return the name of the RealmObject class represented by this schema.
+     */
+    public String getClassName() {
+        return table.getName().substring(Table.TABLE_PREFIX.length());
+    }
+
+    /**
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
+     *
+     * @param className the new name for this class.
+     * @see RealmSchema#rename(String, String)
+     */
+    public RealmObjectSchema setClassName(String className) {
+        checkEmpty(className);
+        String internalTableName = Table.TABLE_PREFIX + className;
+        if (transaction.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        transaction.renameTable(table.getName(), internalTableName);
+        return this;
+    }
+
+    /**
+     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See {@link RealmObject}
+     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.
+     * {@code Integer.class} instead of {@code int.class}.
+     * <p>
+     * To add fields that reference other RealmObjects or RealmLists use {@link #addRealmObjectField(String, RealmObjectSchema)}
+     * or {@link #addRealmListField(String, RealmObjectSchema)} instead.
+     *
+     * @param fieldName name of the field to add.
+     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
+     * @param attributes set of attributes for this field.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
+     * already exists.
+     */
+    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
+        if (metadata == null) {
+            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
+                throw new IllegalArgumentException("Use addLinkField() instead to add fields that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
+                        fieldName, fieldType));
+            }
+        }
+
+        checkNewFieldName(fieldName);
+        boolean nullable = metadata.defaultNullable;
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED) ||
+                containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+            nullable = false;
+        }
+        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
+
+        try {
+            addModifiers(fieldName, attributes);
+        } catch (Exception e) {
+            // Modifiers have been removed by the addModifiers method()
+            table.removeColumn(columnIndex);
+            throw e;
+        }
+        return this;
+    }
+
+    /**
+     * Adds a new field that references another {@link RealmObject}.
+     *
+     * @param fieldName  name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
+     */
+    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Adds a new field that references a {@link RealmList}.
+     *
+     * @param fieldName  name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
+     */
+    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.LIST, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Removes a field from the class.
+     *
+     * @param fieldName field name to remove.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     */
+    public RealmObjectSchema removeField(String fieldName) {
+        checkLegalName(fieldName);
+        if (!hasField(fieldName)) {
+            throw new IllegalStateException(fieldName + " does not exist.");
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.getPrimaryKey() == columnIndex) {
+            table.setPrimaryKey(null);
+        }
+        table.removeColumn(columnIndex);
+        return this;
+    }
+
+    /**
+     * Renames a field from one name to another.
+     *
+     * @param currentFieldName field name to rename.
+     * @param newFieldName     the new field name.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
+     */
+    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        checkLegalName(currentFieldName);
+        checkFieldExists(currentFieldName);
+        checkLegalName(newFieldName);
+        checkFieldNameIsAvailable(newFieldName);
+        long columnIndex = getColumnIndex(currentFieldName);
+        table.renameColumn(columnIndex, newFieldName);
+        return this;
+    }
+
+    /**
+     * Tests if the class has field defined with the given name.
+     *
+     * @param fieldName field name to test.
+     * @return {@code true} if the field exists, {@code false} otherwise.
+     */
+    public boolean hasField(String fieldName) {
+        return table.getColumnIndex(fieldName) != TableOrView.NO_MATCH;
+    }
+
+    /**
+     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index} annotation
+     * on the field.
+     *
+     * @param fieldName field to add index to.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
+     * index defined.
+     */
+    public RealmObjectSchema addIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException(fieldName + " already has an index.");
+        }
+        table.addSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Checks if a given field has an index defined.
+     *
+     * @param fieldName existing field name to check.
+     * @return {@code true} if field is indexed, {@code false} otherwise.
+     * @see io.realm.annotations.Index
+     */
+    public boolean hasIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        return table.hasSearchIndex(table.getColumnIndex(fieldName));
+    }
+
+
+    /**
+     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
+     *
+     * @param fieldName field to remove index from.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
+     */
+    public RealmObjectSchema removeIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException("Field is not indexed: " + fieldName);
+        }
+        table.removeSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
+     * annotation on the field.
+     *
+     * @param fieldName field to set as primary key.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
+     * has a primary key defined.
+     */
+    public RealmObjectSchema addPrimaryKey(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        if (table.hasPrimaryKey()) {
+            throw new IllegalStateException("A primary key is already defined");
+        }
+        table.setPrimaryKey(fieldName);
+        return this;
+    }
+
+    /**
+     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
+     * annotation from the class.
+     *
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
+     */
+    public RealmObjectSchema removePrimaryKey() {
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        table.setPrimaryKey("");
+        return this;
+    }
+
+    /**
+     * Sets a field to be required, i.e. not allowed to hold {@code null values}. This is equivalent to switching
+     * between boxed types and their primitive variant e.g. {@code Integer} to {@code int}.
+     *
+     * @param fieldName name of field in the class.
+     * @param required  {@code true} if field should be required, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
+     *                                  the field already have been set as required.
+     * @see Required
+     */
+    public RealmObjectSchema setRequired(String fieldName, boolean required) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        boolean currentColumnRequired = isRequired(fieldName);
+        RealmFieldType type = table.getColumnType(columnIndex);
+
+        if (type == RealmFieldType.OBJECT) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
+        }
+        if (type == RealmFieldType.LIST) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
+        }
+        if (required && currentColumnRequired) {
+            throw new IllegalStateException("Field is already required: " + fieldName);
+        }
+        if (!required && !currentColumnRequired) {
+            throw new IllegalStateException("Field is already nullable: " + fieldName);
+        }
+
+        if (required) {
+            table.convertColumnToNotNullable(columnIndex);
+        } else {
+            table.convertColumnToNullable(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Sets a field to be nullable, i.e. it should be able to hold {@code null values}. This is equivalent to switching
+     * between primitive types and their boxed variant e.g. {@code int} to {@code Integer}.
+     *
+     * @param fieldName name of field in the class.
+     * @param nullable  {@code true} if field should be nullable, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
+     */
+    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        setRequired(fieldName, !nullable);
+        return this;
+    }
+
+    /**
+     * Checks if a given field is required, i.e. is not allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is requied, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setRequired(String, boolean)
+     */
+    public boolean isRequired(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        return !table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if a given field is nullable, i.e. is allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is requied, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setNullable(String, boolean)
+     */
+    public boolean isNullable(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        return table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if the class has a primary key defined.
+     *
+     * @return {@code true} if a primary key is defined, {@code false} otherwise.
+     * @see io.realm.annotations.PrimaryKey
+     */
+    public boolean hasPrimaryKey() {
+        return table.hasPrimaryKey();
+    }
+
+    /**
+     * Return all fields in this class.
+     *
+     * @return a list of all the fields in this class.
+     */
+    public Set<String> getFieldNames() {
+        int columnCount = (int) table.getColumnCount();
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        for (int i = 0; i < columnCount; i++) {
+            columnNames.add(table.getColumnName(i));
+        }
+        return columnNames;
+    }
+
+    /**
+     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
+     * as a {@link DynamicRealmObject}.
+     *
+     * @return this schema.
+     */
+    public RealmObjectSchema transform(Function function) {
+        if (function != null) {
+            long size = table.size();
+            for (long i = 0; i < size; i++) {
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+            }
+        }
+
+        return this;
+    }
+
+    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
+    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
+        boolean indexAdded = false;
+        try {
+            if (attributes != null && attributes.length > 0) {
+                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                }
+
+                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                    addPrimaryKey(fieldName);
+                }
+
+                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
+            }
+        } catch (Exception e) {
+            // If something went wrong, revert all attributes
+            long columnIndex = getColumnIndex(fieldName);
+            if (indexAdded) {
+                table.removeSearchIndex(columnIndex);
+            }
+            throw e;
+        }
+    }
+
+    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+        if (attributeList == null || attributeList.length == 0) {
+            return false;
+        }
+        for (int i = 0; i < attributeList.length; i++) {
+            if (attributeList[i] == attribute) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void checkNewFieldName(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+    }
+
+    private void checkLegalName(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Field name can not be null or empty");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Field name can not contain '.'");
+        }
+    }
+
+    private void checkFieldNameIsAvailable(String fieldName) {
+        if (table.getColumnIndex(fieldName) != TableOrView.NO_MATCH) {
+            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private void checkFieldExists(String fieldName) {
+        if (table.getColumnIndex(fieldName) == TableOrView.NO_MATCH) {
+            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private long getColumnIndex(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(
+                    String.format("Field name '%s' does not exist on schema for '%s",
+                            fieldName, getClassName()
+                    ));
+        }
+        return columnIndex;
+    }
+
+    private void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    /**
+     * Returns the column indices for the given field name. If a linked field is defined, the column index for
+     * each field is returned
+     *
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validColumnTypes Legal field type for the last field in a linked field
+     * @return list of column indices.
+     */
+    // TODO: consider another caching strategy so linked classes are included in the cache.
+    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        if (fieldDescription == null || fieldDescription.equals("")) {
+            throw new IllegalArgumentException("Non-empty fieldname must be provided");
+        }
+        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
+        }
+        Table table = this.table;
+        boolean checkColumnType = validColumnTypes != null && validColumnTypes.length > 0;
+        if (fieldDescription.contains(".")) {
+            // Resolve field description down to last field name
+            String[] names = fieldDescription.split("\\.");
+            long[] columnIndices = new long[names.length];
+            for (int i = 0; i < names.length - 1; i++) {
+                long index = table.getColumnIndex(names[i]);
+                if (index < 0) {
+                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
+                }
+                RealmFieldType type = table.getColumnType(index);
+                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                    table = table.getLinkTarget(index);
+                    columnIndices[i] = index;
+                } else {
+                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
+                }
+            }
+
+            // Check if last field name is a valid field
+            String columnName = names[names.length - 1];
+            long columnIndex = table.getColumnIndex(columnName);
+            columnIndices[names.length - 1] = columnIndex;
+            if (columnIndex < 0) {
+                throw new IllegalArgumentException(columnName + " is not a field name in class " + table.getName());
+            }
+            if (checkColumnType && !isValidType(table.getColumnType(columnIndex), validColumnTypes)) {
+                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length - 1]));
+            }
+            return columnIndices;
+        } else {
+            if (getFieldIndex(fieldDescription) == null) {
+                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
+            }
+            RealmFieldType tableColumnType = table.getColumnType(getFieldIndex(fieldDescription));
+            if (checkColumnType && !isValidType(tableColumnType, validColumnTypes)) {
+                throw new IllegalArgumentException(String.format("Field '%s': type mismatch. Was %s, expected %s.",
+                        fieldDescription, tableColumnType, Arrays.toString(validColumnTypes)));
+            }
+            return new long[] {getFieldIndex(fieldDescription)};
+        }
+    }
+
+    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
+        for (int i = 0; i < validColumnTypes.length; i++) {
+            if (validColumnTypes[i] == columnType) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     * INVARIANT: fieldName should be present.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index
+     */
+    Long getFieldIndex(String fieldName) {
+        return columnIndices.get(fieldName);
+    }
+
+    /**
+     * Returns the type used by the underlying storage engine to represent this field.
+     *
+     * @return the underlying type used by Realm to represent this field.
+     */
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.getColumnType(columnIndex);
+    }
+
+    /**
+     * Function interface, used when traversing all objects of the current class and apply a function on each.
+     *
+     * @see #transform(Function)
+     */
+    public interface Function {
+        void apply(DynamicRealmObject obj);
+    }
+
+    // Tuple containing data about each supported Java type
+    private static class FieldMetaData {
+        public final RealmFieldType realmType;
+        public final boolean defaultNullable;
+
+        public FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
+            this.realmType = realmType;
+            this.defaultNullable = defaultNullable;
+        }
+    }
+
+    static class DynamicColumnMap implements Map<String, Long> {
+        private final Table table;
+
+        public DynamicColumnMap(Table table) {
+            this.table = table;
+        }
+
+        @Override
+        public Long get(Object key) {
+            return table.getColumnIndex((String) key);
+        }
+
+        @Override
+        public void clear() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsValue(Object value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<Entry<String, Long>> entrySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<String> keySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long put(String key, Long value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void putAll(Map<? extends String, ? extends Long> map) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long remove(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int size() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Collection<Long> values() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
new file mode 100644
index 0000000000..11a461ad68
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -0,0 +1,2063 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.os.Handler;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+
+import io.realm.annotations.Required;
+import io.realm.internal.LinkView;
+import io.realm.internal.Row;
+import io.realm.internal.SharedGroup;
+import io.realm.internal.Table;
+import io.realm.internal.TableOrView;
+import io.realm.internal.TableQuery;
+import io.realm.internal.TableView;
+import io.realm.internal.async.ArgumentsHolder;
+import io.realm.internal.async.QueryUpdateTask;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
+ * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}
+ * <p>
+ * The input to many of the query functions take a field name as String. Note that this is not type safe. If a 
+ * RealmObject class is refactored care has to be taken to not break any queries.
+ * <p>
+ * A {@link io.realm.Realm} is unordered, which means that there is no guarantee that querying a Realm will return the
+ * objects in the order they where inserted. Use {@link #findAllSorted(String)} and similar methods if a specific order
+ * is required.
+ * <p>
+ * A RealmQuery cannot be passed between different threads.
+ *
+ * @param <E> the class of the objects to be queried.
+ * @see <a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a>
+ * @see Realm#where(Class)
+ * @see RealmResults#where()
+ */
+public class RealmQuery<E extends RealmObject> {
+
+    private BaseRealm realm;
+    private Class<E> clazz;
+    private String className;
+    private TableOrView table;
+    private RealmObjectSchema schema;
+    private LinkView view;
+    private TableQuery query;
+    private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
+
+    private final static Long INVALID_NATIVE_POINTER = 0L;
+    private ArgumentsHolder argumentsHolder;
+
+    /**
+     * Creates a query for objects of a given class from a {@link Realm}.
+     *
+     * @param realm  the realm to query within.
+     * @param clazz  the class to query.
+     * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
+     * to run it.
+     */
+    public static <E extends RealmObject> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
+        return new RealmQuery<E>(realm, clazz);
+    }
+
+    /**
+     * Creates a query for dynamic objects of a given type from a {@link DynamicRealm}.
+     *
+     * @param realm  the realm to query within.
+     * @param className  the type to query.
+     * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
+     * to run it.
+     */
+    public static <E extends RealmObject> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
+        return new RealmQuery<E>(realm, className);
+    }
+
+    /**
+     * Creates a query from a existing {@link RealmResults}.
+     *
+     * @param queryResults   a existing @{link io.realm.RealmResults} to query against.
+     * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
+     * to run it.
+     */
+
+    @SuppressWarnings("unchecked")
+    public static <E extends RealmObject> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
+        if (queryResults.classSpec != null) {
+            return new RealmQuery<E>(queryResults, queryResults.classSpec);
+        } else {
+            return new RealmQuery(queryResults, queryResults.className);
+        }
+    }
+
+    /**
+     * Creates a query from a existing {@link RealmList}.
+     *
+     * @param list   a existing @{link io.realm.RealmList} to query against.
+     * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
+     * to run it.
+     */
+    @SuppressWarnings("unchecked")
+    public static <E extends RealmObject> RealmQuery<E> createQueryFromList(RealmList<E> list) {
+        if (list.clazz != null) {
+            return new RealmQuery(list.realm, list.view, list.clazz);
+        } else {
+            return new RealmQuery(list.realm, list.view, list.className);
+        }
+    }
+
+    private RealmQuery(Realm realm, Class<E> clazz) {
+        this.realm = realm;
+        this.clazz = clazz;
+        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.table = schema.table;
+        this.view = null;
+        this.query = table.where();
+    }
+
+    private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
+        this.realm = queryResults.realm;
+        this.clazz = clazz;
+        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.table = queryResults.getTable();
+        this.view = null;
+        this.query = queryResults.getTable().where();
+    }
+
+    private RealmQuery(BaseRealm realm, LinkView view, Class<E> clazz) {
+        this.realm = realm;
+        this.clazz = clazz;
+        this.query = view.where();
+        this.view = view;
+        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.table = schema.table;
+    }
+
+    private RealmQuery(BaseRealm realm, String className) {
+        this.realm = realm;
+        this.className = className;
+        this.schema = realm.schema.getSchemaForClass(className);
+        this.table = schema.table;
+        this.query = table.where();
+    }
+
+    private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
+        this.realm = queryResults.realm;
+        this.className = className;
+        this.schema = realm.schema.getSchemaForClass(className);
+        this.table = schema.table;
+        this.query = queryResults.getTable().where();
+    }
+
+    private RealmQuery(BaseRealm realm, LinkView view, String className) {
+        this.realm = realm;
+        this.className = className;
+        this.query = view.where();
+        this.view = view;
+        this.schema = realm.schema.getSchemaForClass(className);
+        this.table = schema.table;
+    }
+
+    /**
+     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't been
+     * closed and any parent {@link io.realm.RealmResults} is still valid.
+     *
+     * @return {@code true} if still valid to use, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        if (realm == null || realm.isClosed()) {
+            return false;
+        }
+
+        if (view != null) {
+            return view.isAttached();
+        }
+        return table != null && table.getTable().isValid();
+    }
+
+    /**
+     * Tests if a field is {@code null}. Only works for nullable fields.
+     *
+     * For link queries, if any part of the link path is {@code null} the whole path is considered to be {@code null}
+     * e.g. {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
+     * {@code linkField.stringField} is {@code null}.
+     *
+     * @param fieldName the field name.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field is not nullable.
+     * @see Required for further infomation.
+     */
+    public RealmQuery<E> isNull(String fieldName) {
+        long columnIndices[] = schema.getColumnIndices(fieldName);
+
+        // checking that fieldName has the correct type is done in C++
+        this.query.isNull(columnIndices);
+        return this;
+    }
+
+    /**
+     * Tests if a field is not {@code null}. Only works for nullable fields.
+     *
+     * @param fieldName the field name.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field is not nullable.
+     * @see Required for further infomation.
+     */
+    public RealmQuery<E> isNotNull(String fieldName) {
+        long columnIndices[] = schema.getColumnIndices(fieldName);
+
+        // checking that fieldName has the correct type is done in C++
+        this.query.isNotNull(columnIndices);
+        return this;
+    }
+
+    // Equal
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, String value) {
+        return this.equalTo(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.equalTo(columnIndices, value, casing);
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Byte value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Short value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Integer value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Long value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Double value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return The query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Float value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Boolean value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, Date value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.equalTo(columnIndices, value);
+        return this;
+    }
+
+    // Not Equal
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, String value) {
+        return this.notEqualTo(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @param casing     How casing is handled. {@link Case#INSENSITIVE} works only for the English locale characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        if (columnIndices.length > 1 && !casing.getValue()) {
+            throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
+        }
+        this.query.notEqualTo(columnIndices, value, casing);
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Byte value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Short value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Integer value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Long value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Double value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Float value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Boolean value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, !value);
+        }
+        return this;
+    }
+
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, Date value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
+    // Greater Than
+
+    /**
+     * Greater-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThan(String fieldName, int value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThan(String fieldName, long value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThan(String fieldName, double value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThan(String fieldName, float value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThan(String fieldName, Date value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type
+     */
+    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Greater-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    // Less Than
+
+    /**
+     * Less-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThan(String fieldName, int value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThan(String fieldName, long value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThan(String fieldName, double value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThan(String fieldName, float value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThan(String fieldName, Date value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThan(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    /**
+     * Less-than-or-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThanOrEqual(columnIndices, value);
+        return this;
+    }
+
+    // Between
+
+    /**
+     * Between condition.
+     *
+     * @param fieldName the field to compare.
+     * @param from lowest value (inclusive).
+     * @param to highest value (inclusive).
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> between(String fieldName, int from, int to) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(columnIndices, from, to);
+        return this;
+    }
+
+    /**
+     * Between condition.
+     *
+     * @param fieldName the field to compare.
+     * @param from lowest value (inclusive).
+     * @param to highest value (inclusive).
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> between(String fieldName, long from, long to) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(columnIndices, from, to);
+        return this;
+    }
+
+    /**
+     * Between condition.
+     *
+     * @param fieldName the field to compare.
+     * @param from lowest value (inclusive).
+     * @param to highest value (inclusive).
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> between(String fieldName, double from, double to) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.between(columnIndices, from, to);
+        return this;
+    }
+
+    /**
+     * Between condition.
+     *
+     * @param fieldName the field to compare.
+     * @param from lowest value (inclusive).
+     * @param to highest value (inclusive).
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> between(String fieldName, float from, float to) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.between(columnIndices, from, to);
+        return this;
+    }
+
+    /**
+     * Between condition.
+     *
+     * @param fieldName the field to compare.
+     * @param from lowest value (inclusive).
+     * @param to highest value (inclusive).
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> between(String fieldName, Date from, Date to) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.between(columnIndices, from, to);
+        return this;
+    }
+
+
+    // Contains
+
+    /**
+     * Condition that value of field contains the specified substring.
+     *
+     * @param fieldName the field to compare.
+     * @param value the substring.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> contains(String fieldName, String value) {
+        return contains(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Condition that value of field contains the specified substring.
+     *
+     * @param fieldName the field to compare.
+     * @param value the substring.
+     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @return The query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> contains(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.contains(columnIndices, value, casing);
+        return this;
+    }
+
+    /**
+     * Condition that the value of field begins with the specified string.
+     *
+     * @param fieldName the field to compare.
+     * @param value the string.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> beginsWith(String fieldName, String value) {
+        return beginsWith(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Condition that the value of field begins with the specified substring.
+     *
+     * @param fieldName the field to compare.
+     * @param value the substring.
+     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @return the query object
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.beginsWith(columnIndices, value, casing);
+        return this;
+    }
+
+    /**
+     * Condition that the value of field ends with the specified string.
+     *
+     * @param fieldName the field to compare.
+     * @param value the string.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> endsWith(String fieldName, String value) {
+        return endsWith(fieldName, value, Case.SENSITIVE);
+    }
+
+    /**
+     * Condition that the value of field ends with the specified substring.
+     *
+     * @param fieldName the field to compare.
+     * @param value the substring.
+     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.endsWith(columnIndices, value, casing);
+        return this;
+    }
+
+    // Grouping
+
+    /**
+     * Begin grouping of conditions ("left parenthesis"). A group must be closed with a call to {@code endGroup()}.
+     *
+     * @return the query object.
+     * @see #endGroup()
+     */
+    public RealmQuery<E> beginGroup() {
+        this.query.group();
+        return this;
+    }
+
+    /**
+     * End grouping of conditions ("right parenthesis") which was opened by a call to {@code beginGroup()}.
+     *
+     * @return the query object.
+     * @see #beginGroup()
+     */
+    public RealmQuery<E> endGroup() {
+        this.query.endGroup();
+        return this;
+    }
+
+    /**
+     * Logical-or two conditions.
+     *
+     * @return the query object.
+     */
+    public RealmQuery<E> or() {
+        this.query.or();
+        return this;
+    }
+
+    /**
+     * Negate condition.
+     *
+     * @return the query object.
+     */
+    public RealmQuery<E> not() {
+        this.query.not();
+        return this;
+    }
+
+    /**
+     * Condition that find values that are considered "empty", i.e. an empty list, the 0-length string or byte array.
+     *
+     * @param fieldName the field to compare.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field name isn't valid or its type isn't either a RealmList,
+     * String or byte array.
+     */
+    public RealmQuery<E> isEmpty(String fieldName) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        this.query.isEmpty(columnIndices);
+        return this;
+    }
+
+    /**
+     * Condition that find values that are considered "Not-empty", i.e. a list, a string or a byte array with not-empty values.
+     *
+     * @param fieldName the field to compare.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field name isn't valid or its type isn't either a RealmList,
+     * String or byte array.
+     */
+    public RealmQuery<E> isNotEmpty(String fieldName) {
+        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        this.query.isNotEmpty(columnIndices);
+        return this;
+    }
+
+    /**
+     * Returns a distinct set of objects of a specific class. If the result is sorted, the first
+     * object will be returned in case of multiple occurrences, otherwise it is undefined which
+     * object is returned.
+     *
+     * @param fieldName the field name.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<E> distinct(String fieldName) {
+        checkQueryIsNotReused();
+        long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
+        TableView tableView = this.query.findAll();
+        tableView.distinct(columnIndex);
+
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
+        } else {
+            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
+        }
+        return realmResults;
+    }
+
+    /**
+     * Asynchronously returns a distinct set of objects of a specific class. If the result is
+     * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
+     * undefined which object is returned.
+     *
+     * @param fieldName the field name.
+     * @return immediately a {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
+     * query completes.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<E> distinctAsync(String fieldName) {
+        checkQueryIsNotReused();
+        final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
+        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+
+        // handover the query (to be used by a worker thread)
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+
+        // save query arguments (for future update)
+        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
+        argumentsHolder.columnIndex = columnIndex;
+
+        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        // prepare an empty reference of the RealmResults, so we can return it immediately (promise)
+        // then update it once the query completes in the background.
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
+        } else {
+            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
+        }
+
+        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+
+        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                if (!Thread.currentThread().isInterrupted()) {
+                    SharedGroup sharedGroup = null;
+
+                    try {
+                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                                SharedGroup.IMPLICIT_TRANSACTION,
+                                realmConfiguration.getDurability(),
+                                realmConfiguration.getEncryptionKey());
+
+                        long handoverTableViewPointer = query.
+                                findDistinctWithHandover(sharedGroup.getNativePointer(),
+                                        sharedGroup.getNativeReplicationPointer(),
+                                        handoverQueryPointer,
+                                        columnIndex);
+
+                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
+                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
+                        result.versionID = sharedGroup.getVersion();
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+
+                        return handoverTableViewPointer;
+                    } catch (Exception e) {
+                        RealmLog.e(e.getMessage(), e);
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+
+                    } finally {
+                        if (sharedGroup != null && !sharedGroup.isClosed()) {
+                            sharedGroup.close();
+                        }
+                    }
+                } else {
+                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
+                }
+
+                return INVALID_NATIVE_POINTER;
+            }
+        });
+
+        realmResults.setPendingQuery(pendingQuery);
+        return realmResults;
+    }
+
+    // Find and validate the column index for the field name used to create a distinctive TableView.
+    static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
+        // Check empty field name
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Non-empty field name must be provided.");
+        }
+        long columnIndex = table.getColumnIndex(fieldName);
+        // Check if field exists
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+        }
+        // Check linked fields
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Distinct operation on linked properties is not supported: " + fieldName);
+        }
+        // check if the field is indexed
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalArgumentException(String.format("Field name '%s' must be indexed in order to use it for distinct queries.", fieldName));
+        }
+        return columnIndex;
+    }
+
+    /**
+     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     */
+    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
+        checkQueryIsNotReused();
+        List<Long> columnIndexes = getValidatedColumIndexes(this.table.getTable(), firstFieldName, remainingFieldNames);
+        TableView tableView = this.query.findAll();
+        tableView.distinct(columnIndexes);
+
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
+        } else {
+            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
+        }
+        return realmResults;
+    }
+
+    // find and validate the column indices of fields for building a distinctive TableView with multi-args
+    static List<Long> getValidatedColumIndexes(Table table, String firstFieldName, String... remainingFieldNames) {
+        List<Long> columnIndexes = new ArrayList<Long>();
+        // find the first index
+        long firstIndex = getAndValidateDistinctColumnIndex(firstFieldName, table);
+        columnIndexes.add(firstIndex);
+        // add remaining of indexes
+        if (remainingFieldNames != null && 0 < remainingFieldNames.length) {
+            for (String field : remainingFieldNames) {
+                long index = getAndValidateDistinctColumnIndex(field, table);
+                columnIndexes.add(index);
+            }
+        }
+        return columnIndexes;
+    }
+
+    // Aggregates
+
+    // Sum
+
+    /**
+     * Calculates the sum of a given field.
+     *
+     * @param fieldName the field to sum. Only number fields are supported.
+     * @return the sum if no objects exist or they all have {@code null} as the value for the given field, {@code 0}
+     * will be returned. When computing the sum, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number sum(String fieldName) {
+        long columnIndex = schema.getFieldIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return query.sumInt(columnIndex);
+            case FLOAT:
+                return query.sumFloat(columnIndex);
+            case DOUBLE:
+                return query.sumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    // Average
+
+    /**
+     * Returns the average of a given field.
+     *
+     * @param fieldName the field to calculate average on. Only number fields are supported.
+     * @return the average for the given field amongst objects in query results. This will be of type double for all
+     * types of number fields. If no objects exist or they all have {@code null} as the value for the given field,
+     * {@code 0} will be returned. When computing the average, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public double average(String fieldName) {
+        long columnIndex = schema.getFieldIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return query.averageInt(columnIndex);
+            case DOUBLE:
+                return query.averageDouble(columnIndex);
+            case FLOAT:
+                return query.averageFloat(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    // Min
+
+    /**
+     * Finds the minimum value of a field.
+     *
+     * @param fieldName the field to look for a minimum on. Only number fields are supported.
+     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the minimum value is returned. When determining the minimum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number min(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return this.query.minimumInt(columnIndex);
+            case FLOAT:
+                return this.query.minimumFloat(columnIndex);
+            case DOUBLE:
+                return this.query.minimumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    /**
+     * Finds the minimum value of a field.
+     *
+     * @param fieldName the field name
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
+     */
+    public Date minimumDate(String fieldName) {
+        long columnIndex = schema.getFieldIndex(fieldName);
+        return this.query.minimumDate(columnIndex);
+    }
+
+    // Max
+
+    /**
+     * Finds the maximum value of a field.
+     *
+     * @param fieldName the field to look for a maximum on. Only number fields are supported.
+     * @return  if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the maximum value is returned. When determining the maximum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number max(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return this.query.maximumInt(columnIndex);
+            case FLOAT:
+                return this.query.maximumFloat(columnIndex);
+            case DOUBLE:
+                return this.query.maximumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    /**
+     * Finds the maximum value of a field.
+     *
+     * @param fieldName the field name.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
+     */
+    public Date maximumDate(String fieldName) {
+        long columnIndex = schema.getFieldIndex(fieldName);
+        return this.query.maximumDate(columnIndex);
+    }
+
+    /**
+     * Counts the number of objects that fulfill the query conditions.
+     *
+     * @return the number of matching objects.
+     * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
+     */
+    public long count() {
+        return this.query.count();
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions.
+     *
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
+     * objects is returned.
+     * @see io.realm.RealmResults
+     */
+    @SuppressWarnings("unchecked")
+    public RealmResults<E> findAll() {
+        checkQueryIsNotReused();
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            realmResults =  (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, query.findAll(), className);
+        } else {
+            realmResults = RealmResults.createFromTableOrView(realm, query.findAll(), clazz);
+        }
+        return realmResults;
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field name.
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @see io.realm.RealmResults
+     */
+    public RealmResults<E> findAllAsync() {
+        checkQueryIsNotReused();
+        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+
+        // handover the query (to be used by a worker thread)
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+
+        // save query arguments (for future update)
+        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL);
+
+        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        // prepare an empty reference of the RealmResults, so we can return it immediately (promise)
+        // then update it once the query completes in the background.
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
+        } else {
+            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
+        }
+
+        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+
+        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                if (!Thread.currentThread().isInterrupted()) {
+                    SharedGroup sharedGroup = null;
+
+                    try {
+                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                                SharedGroup.IMPLICIT_TRANSACTION,
+                                realmConfiguration.getDurability(),
+                                realmConfiguration.getEncryptionKey());
+
+                        // Run the query & handover the table view for the caller thread
+                        // Note: the handoverQueryPointer contains the versionID needed by the SG in order
+                        // to import it.
+                        long handoverTableViewPointer = query.findAllWithHandover(sharedGroup.getNativePointer(), sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+
+                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
+                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
+                        result.versionID = sharedGroup.getVersion();
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+
+                        return handoverTableViewPointer;
+
+                    } catch (Exception e) {
+                        RealmLog.e(e.getMessage(), e);
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+
+                    } finally {
+                        if (sharedGroup != null && !sharedGroup.isClosed()) {
+                            sharedGroup.close();
+                        }
+                    }
+                } else {
+                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
+                }
+
+                return INVALID_NATIVE_POINTER;
+            }
+        });
+
+        realmResults.setPendingQuery(pendingQuery);
+        return realmResults;
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field name.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @param sortOrder how to sort the results.
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
+     * objects is returned.
+     * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
+     */
+    @SuppressWarnings("unchecked")
+    public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
+        checkQueryIsNotReused();
+        TableView tableView = query.findAll();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        tableView.sort(columnIndex, sortOrder);
+
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
+        } else {
+            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
+        }
+        return realmResults;
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String, Sort)} but runs asynchronously on a worker thread
+     * (Need a Realm opened from a looper thread to work).
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
+     */
+    public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
+        checkQueryIsNotReused();
+        long columnIndex = getColumnIndexForSort(fieldName);
+
+        // capture the query arguments for future retries & update
+        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
+        argumentsHolder.sortOrder = sortOrder;
+        argumentsHolder.columnIndex = columnIndex;
+
+        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+
+        // handover the query (to be used by a worker thread)
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+
+        // we need to use the same configuration to open a background SharedGroup to perform the query
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        RealmResults<E> realmResults;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
+        } else {
+            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
+        }
+
+        final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults =
+                realm.handlerController.addToAsyncRealmResults(realmResults, this);
+
+        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                if (!Thread.currentThread().isInterrupted()) {
+                    SharedGroup sharedGroup = null;
+
+                    try {
+                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                                SharedGroup.IMPLICIT_TRANSACTION,
+                                realmConfiguration.getDurability(),
+                                realmConfiguration.getEncryptionKey());
+
+                        long columnIndex = getColumnIndexForSort(fieldName);
+
+                        // run the query & handover the table view for the caller thread
+                        long handoverTableViewPointer = query.findAllSortedWithHandover(sharedGroup.getNativePointer(),
+                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, columnIndex, sortOrder);
+
+                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
+                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
+                        result.versionID = sharedGroup.getVersion();
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+
+                        return handoverTableViewPointer;
+                    } catch (Exception e) {
+                        RealmLog.e(e.getMessage(), e);
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+
+                    } finally {
+                        if (sharedGroup != null && !sharedGroup.isClosed()) {
+                            sharedGroup.close();
+                        }
+                    }
+                } else {
+                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
+                }
+
+                return INVALID_NATIVE_POINTER;
+            }
+        });
+        realmResults.setPendingQuery(pendingQuery);
+        return realmResults;
+    }
+
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field name in ascending order.
+     *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
+     * objects is returned.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public RealmResults<E> findAllSorted(String fieldName) {
+        return findAllSorted(fieldName, Sort.ASCENDING);
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String)} but runs asynchronously on a worker thread
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public RealmResults<E> findAllSortedAsync(String fieldName) {
+        return findAllSortedAsync(fieldName, Sort.ASCENDING);
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field names.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldNames an array of field names to sort by.
+     * @param sortOrders how to sort the field names.
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero 
+     *         objects is returned.
+     * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
+     */
+    @SuppressWarnings("unchecked")
+    public RealmResults<E> findAllSorted(String fieldNames[], Sort sortOrders[]) {
+        checkSortParameters(fieldNames, sortOrders);
+
+        if (fieldNames.length == 1 && sortOrders.length == 1) {
+            return findAllSorted(fieldNames[0], sortOrders[0]);
+        } else {
+            TableView tableView = query.findAll();
+            List<Long> columnIndices = new ArrayList<Long>();
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < fieldNames.length; i++) {
+                String fieldName = fieldNames[i];
+                long columnIndex = getColumnIndexForSort(fieldName);
+                columnIndices.add(columnIndex);
+            }
+            tableView.sort(columnIndices, sortOrders);
+
+            RealmResults<E> realmResults;
+            if (isDynamicQuery()) {
+                realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
+            } else {
+                realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
+            }
+            return realmResults;
+        }
+    }
+
+    private boolean isDynamicQuery() {
+        return className != null;
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously
+     * from a worker thread.
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @see io.realm.RealmResults
+     * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
+     */
+    public RealmResults<E> findAllSortedAsync(String fieldNames[], final Sort[] sortOrders) {
+        checkQueryIsNotReused();
+        checkSortParameters(fieldNames, sortOrders);
+
+        if (fieldNames.length == 1 && sortOrders.length == 1) {
+            return findAllSortedAsync(fieldNames[0], sortOrders[0]);
+
+        } else {
+            final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+
+            // Handover the query (to be used by a worker thread)
+            final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+
+            // We need to use the same configuration to open a background SharedGroup to perform the query
+            final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+            final long indices[] = new long[fieldNames.length];
+            for (int i = 0; i < fieldNames.length; i++) {
+                String fieldName = fieldNames[i];
+                long columnIndex = getColumnIndexForSort(fieldName);
+                indices[i] = columnIndex;
+            }
+
+            // capture the query arguments for future retries & update
+            argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED);
+            argumentsHolder.sortOrders = sortOrders;
+            argumentsHolder.columnIndices = indices;
+
+            // prepare the promise result
+            RealmResults<E> realmResults;
+            if (isDynamicQuery()) {
+                //noinspection unchecked
+                realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
+            } else {
+                realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
+            }
+
+            final WeakReference<RealmResults<? extends RealmObject>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
+
+            final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+                @Override
+                public Long call() throws Exception {
+                    if (!Thread.currentThread().isInterrupted()) {
+                        SharedGroup sharedGroup = null;
+
+                        try {
+                            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                                    SharedGroup.IMPLICIT_TRANSACTION,
+                                    realmConfiguration.getDurability(),
+                                    realmConfiguration.getEncryptionKey());
+
+                            // run the query & handover the table view for the caller thread
+                            long handoverTableViewPointer = query.findAllMultiSortedWithHandover(sharedGroup.getNativePointer(),
+                                    sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, indices, sortOrders);
+
+                            QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
+                            result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
+                            result.versionID = sharedGroup.getVersion();
+                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                    weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+
+                            return handoverTableViewPointer;
+                        } catch (Exception e) {
+                            RealmLog.e(e.getMessage(), e);
+                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                    weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+
+                        } finally {
+                            if (sharedGroup != null && !sharedGroup.isClosed()) {
+                                sharedGroup.close();
+                            }
+                        }
+                    } else {
+                        TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
+                    }
+
+                    return INVALID_NATIVE_POINTER;
+                }
+            });
+
+            realmResults.setPendingQuery(pendingQuery);
+            return realmResults;
+        }
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field names in ascending order.
+     *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName1 first field name
+     * @param sortOrder1 sort order for first field
+     * @param fieldName2 second field name
+     * @param sortOrder2 sort order for second field
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
+     * objects is returned.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
+                                   String fieldName2, Sort sortOrder2) {
+        return findAllSorted(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String, Sort, String, Sort)} but runs asynchronously on a worker thread
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
+                                              String fieldName2, Sort sortOrder2) {
+        return findAllSortedAsync(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    }
+
+    /**
+     * Finds all objects that fulfill the query conditions and sorted by specific field names in
+     * ascending order.
+     *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName1 first field name
+     * @param sortOrder1 sort order for first field
+     * @param fieldName2 second field name
+     * @param sortOrder2 sort order for second field
+     * @param fieldName3 third field names
+     * @param sortOrder3 sort order for third field
+     * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
+     * objects is returned.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
+                                   String fieldName2, Sort sortOrder2,
+                                   String fieldName3, Sort sortOrder3) {
+        return findAllSorted(new String[]{fieldName1, fieldName2, fieldName3},
+                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
+    }
+
+    /**
+     * Similar to {@link #findAllSorted(String, Sort, String, Sort, String, Sort)} but
+     * runs asynchronously on a worker thread.
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
+                                              String fieldName2, Sort sortOrder2,
+                                              String fieldName3, Sort sortOrder3) {
+        return findAllSortedAsync(new String[]{fieldName1, fieldName2, fieldName3},
+                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
+    }
+
+    /**
+     * Finds the first object that fulfills the query conditions.
+     *
+     * @return the object found or {@code null} if no object matches the query conditions.
+     * @see io.realm.RealmObject
+     */
+    public E findFirst() {
+        checkQueryIsNotReused();
+        long sourceRowIndex = getSourceRowIndexForFirstObject();
+        if (sourceRowIndex >= 0) {
+            E realmObject = realm.get(clazz, className, sourceRowIndex);
+            if (realm.handlerController != null) { // non Looper Thread doesn't have a handlerController
+                WeakReference<RealmObject> realmObjectWeakReference
+                        = new WeakReference<RealmObject>(realmObject, realm.handlerController.referenceQueueRealmObject);
+                realm.handlerController.realmObjects.put(realmObjectWeakReference, this);
+            }
+            return realmObject;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Similar to {@link #findFirst()} but runs asynchronously on a worker thread
+     * This method is only available from a Looper thread.
+     *
+     * @return immediately an empty {@link RealmObject}. Trying to access any field on the returned object
+     * before it is loaded will throw an {@code IllegalStateException}. Use {@link RealmObject#isLoaded()} to check if
+     * the object is fully loaded or register a listener {@link io.realm.RealmObject#addChangeListener}
+     * to be notified when the query completes. If no RealmObject was found after the query completed, the returned
+     * RealmObject will have {@link RealmObject#isLoaded()} set to {@code true} and {@link RealmObject#isValid()} set to
+     * {@code false}.
+     */
+    public E findFirstAsync() {
+        checkQueryIsNotReused();
+        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+
+        // handover the query (to be used by a worker thread)
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+
+        // save query arguments (for future update)
+        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);
+
+        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+
+        // prepare an empty reference of the RealmObject, so we can return it immediately (promise)
+        // then update it once the query complete in the background.
+        final E result;
+        if (isDynamicQuery()) {
+            //noinspection unchecked
+            result = (E) new DynamicRealmObject(className);
+        } else {
+            result = realm.getConfiguration().getSchemaMediator().newInstance(clazz, realm.getSchema().getColumnInfo(clazz));
+        }
+
+        final WeakReference<RealmObject> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(result, this);
+        result.realm = realm;
+        result.row = Row.EMPTY_ROW;
+
+        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            @Override
+            public Long call() throws Exception {
+                if (!Thread.currentThread().isInterrupted()) {
+                    SharedGroup sharedGroup = null;
+
+                    try {
+                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                                SharedGroup.IMPLICIT_TRANSACTION,
+                                realmConfiguration.getDurability(),
+                                realmConfiguration.getEncryptionKey());
+
+                        long handoverRowPointer = query.findWithHandover(sharedGroup.getNativePointer(),
+                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+                        if (handoverRowPointer == 0) { // empty row
+                            realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
+                            realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
+                        }
+
+                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmObjectResponse();
+                        result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
+                        result.versionID = sharedGroup.getVersion();
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_OBJECT, result);
+
+                        return handoverRowPointer;
+
+                    } catch (Exception e) {
+                        RealmLog.e(e.getMessage(), e);
+                        // handler can't throw a checked exception need to wrap it into unchecked Exception
+                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
+                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+
+                    } finally {
+                        if (sharedGroup != null && !sharedGroup.isClosed()) {
+                            sharedGroup.close();
+                        }
+                    }
+                } else {
+                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
+                }
+
+                return INVALID_NATIVE_POINTER;
+            }
+        });
+        result.setPendingQuery(pendingQuery);
+
+        return result;
+    }
+
+    private void checkSortParameters(String fieldNames[], final Sort[] sortOrders) {
+        if (fieldNames == null) {
+            throw new IllegalArgumentException("fieldNames cannot be 'null'.");
+        } else if (sortOrders == null) {
+            throw new IllegalArgumentException("sortOrders cannot be 'null'.");
+        } else if (fieldNames.length == 0) {
+            throw new IllegalArgumentException("At least one field name must be specified.");
+        } else if (fieldNames.length != sortOrders.length) {
+            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                    "Number of field names (%d) and sort orders (%d) does not match.",
+                    fieldNames.length, sortOrders.length));
+        }
+    }
+
+    private WeakReference<Handler> getWeakReferenceHandler() {
+        if (realm.handler == null) {
+            throw new IllegalStateException("Your Realm is opened from a thread without a Looper." +
+                    " Async queries need a Handler to send results of your query");
+        }
+        return new WeakReference<Handler>(realm.handler); // use caller Realm's Looper
+    }
+
+    // The shared group needs to be closed before sending the message to other threads to avoid timing problems.
+    // eg.: The other thread wants to delete Realm when getting notified.
+    private void closeSharedGroupAndSendMessageToHandler(SharedGroup sharedGroup, WeakReference<Handler> weakHandler, int what, Object obj) {
+        if (sharedGroup != null) {
+            sharedGroup.close();
+        }
+        Handler handler = weakHandler.get();
+        if (handler != null && handler.getLooper().getThread().isAlive()) {
+            handler.obtainMessage(what, obj).sendToTarget();
+        }
+    }
+
+    // We need to prevent the user from using the query again (mostly for async)
+    // Ex: if the first query fail with findFirstAsync, if the user reuse the same RealmQuery
+    //     with findAllSorted, argumentsHolder of the first query will be overridden,
+    //     which cause any retry to use the findAllSorted argumentsHolder.
+    private void checkQueryIsNotReused() {
+        if (argumentsHolder != null) {
+            throw new IllegalStateException("This RealmQuery is already used by a find* query, please create a new query");
+        }
+    }
+
+    private long getSourceRowIndexForFirstObject() {
+        long rowIndex = this.query.find();
+        if (rowIndex < 0) {
+            return rowIndex;
+        }
+        if (this.view != null) {
+            return view.getTargetRowIndex(rowIndex);
+        } else if (table instanceof TableView){
+            return ((TableView) table).getSourceRowIndex(rowIndex);
+        } else {
+            return rowIndex;
+        }
+    }
+
+    // Get the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
+    // or it belongs to the child object.
+    private long getColumnIndexForSort(String fieldName) {
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
+        }
+
+        Long columnIndex = schema.getFieldIndex(fieldName);
+        if (columnIndex == null || columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
+        }
+
+        return columnIndex;
+    }
+
+    public ArgumentsHolder getArgument() {
+        return argumentsHolder;
+    }
+
+    /**
+     * Exports & handovers the query to be used by a worker thread.
+     *
+     * @return the exported handover pointer for this RealmQuery.
+     */
+    long handoverQueryPointer() {
+        return query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
new file mode 100644
index 0000000000..017a1e0013
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -0,0 +1,972 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.ConcurrentModificationException;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.Future;
+
+import io.realm.exceptions.RealmException;
+import io.realm.internal.InvalidRow;
+import io.realm.internal.TableOrView;
+import io.realm.internal.TableQuery;
+import io.realm.internal.TableView;
+import io.realm.internal.Table;
+import io.realm.internal.log.RealmLog;
+import rx.Observable;
+
+/**
+ * This class holds all the matches of a {@link io.realm.RealmQuery} for a given Realm. The objects are not copied from
+ * the Realm to the RealmResults list, but are just referenced from the RealmResult instead. This saves memory and
+ * increases speed.
+ * <p>
+ * RealmResults are live views, which means that if it is on an {@link android.os.Looper} thread, it will automatically
+ * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#refresh()}
+ * must be called to update the results.
+ * <p>
+ * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the modified objects are
+ * persisted to the Realm file during the commit of the transaction.
+ * <p>
+ * A RealmResults object cannot be passed between different threads.
+ * <p>
+ * Notice that a RealmResults is never {@code null} not even in the case where it contains no objects. You should always
+ * use the size() method to check if a RealmResults is empty or not.
+ * <p>
+ * If a RealmResults is built on RealmList through {@link RealmList#where()}, it will become empty when the source
+ * RealmList gets deleted.
+ * <p>
+ * {@link RealmResults} can contain more elements than {@code Integer.MAX_VALUE}.
+ * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
+ *
+ * @param <E> The class of objects in this list.
+ * @see RealmQuery#findAll()
+ * @see Realm#allObjects(Class)
+ * @see io.realm.Realm#beginTransaction()
+ */
+public final class RealmResults<E extends RealmObject> extends AbstractList<E> {
+
+    BaseRealm realm;
+    Class<E> classSpec;   // Return type
+    String className;     // Class name used by DynamicRealmObjects
+    private TableOrView table = null;
+
+    private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
+    private static final long TABLE_VIEW_VERSION_NONE = -1;
+    private long currentTableViewVersion = TABLE_VIEW_VERSION_NONE;
+
+    private final TableQuery query;
+    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    private Future<Long> pendingQuery;
+    private boolean isCompleted = false;
+
+    static <E extends RealmObject> RealmResults<E> createFromTableQuery(BaseRealm realm, TableQuery query, Class<E> clazz) {
+        return new RealmResults<E>(realm, query, clazz);
+    }
+
+    static <E extends RealmObject> RealmResults<E> createFromTableOrView(BaseRealm realm, TableOrView table, Class<E> clazz) {
+        RealmResults<E> realmResults = new RealmResults<E>(realm, table, clazz);
+        if (realm.handlerController != null) {
+            realm.handlerController.addToRealmResults(realmResults);
+        }
+        return realmResults;
+    }
+
+    static RealmResults<DynamicRealmObject> createFromDynamicClass(BaseRealm realm, TableQuery query, String className) {
+        return new RealmResults<DynamicRealmObject>(realm, query, className);
+    }
+
+    static RealmResults<DynamicRealmObject> createFromDynamicTableOrView(BaseRealm realm, TableOrView table, String className) {
+        RealmResults<DynamicRealmObject> realmResults = new RealmResults<DynamicRealmObject>(realm, table, className);
+        if (realm.handlerController != null) {
+            realm.handlerController.addToRealmResults(realmResults);
+        }
+        return realmResults;
+    }
+
+    private RealmResults(BaseRealm realm, TableQuery query, Class<E> clazz) {
+        this.realm = realm;
+        this.classSpec = clazz;
+        this.query = query;
+    }
+
+    private RealmResults(BaseRealm realm, TableQuery query, String className) {
+        this.realm = realm;
+        this.query = query;
+        this.className = className;
+    }
+
+    private RealmResults(BaseRealm realm, TableOrView table, Class<E> classSpec) {
+        this.realm = realm;
+        this.classSpec = classSpec;
+        this.table = table;
+
+        this.pendingQuery = null;
+        this.query = null;
+        this.currentTableViewVersion = table.sync();
+    }
+
+    private RealmResults(BaseRealm realm, String className) {
+        this.realm = realm;
+        this.className = className;
+
+        pendingQuery = null;
+        query = null;
+    }
+
+    private RealmResults(BaseRealm realm, TableOrView table, String className) {
+        this(realm, className);
+        this.table = table;
+    }
+
+    TableOrView getTable() {
+        if (table == null) {
+            return realm.schema.getTable(classSpec);
+        } else {
+            return table;
+        }
+    }
+
+    /**
+     * Checks if {@link io.realm.RealmResults} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't
+     * been closed.
+     *
+     * @return {@code true} if still valid to use, {@code false} otherwise.
+     */
+    public boolean isValid() {
+        return realm != null && !realm.isClosed();
+    }
+
+    /**
+     * Returns a typed {@link io.realm.RealmQuery}, which can be used to query for specific objects of this type.
+     *
+     * @return a typed RealmQuery.
+     * @see io.realm.RealmQuery
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    public RealmQuery<E> where() {
+        realm.checkIfValid();
+
+        return RealmQuery.createQueryFromResult(this);
+    }
+
+    /**
+     * Searches this {@link RealmResults} for the specified object.
+     *
+     * @param object the object to search for.
+     * @return {@code true} if {@code object} is an element of this {@code RealmResults},
+     *         {@code false} otherwise
+     */
+    @Override
+    public boolean contains(Object object) {
+        boolean contains = false;
+        if (isLoaded() && object instanceof RealmObject) {
+            RealmObject realmObject = (RealmObject) object;
+            if (realmObject.row != null && realm.getPath().equals(realmObject.realm.getPath()) && realmObject.row != InvalidRow.INSTANCE) {
+                contains = (table.sourceRowIndex(realmObject.row.getIndex()) != TableOrView.NO_MATCH);
+            }
+        }
+        return contains;
+    }
+
+    /**
+     * Returns the element at the specified location in this list.
+     *
+     * @param location the index of the element to return.
+     * @return the element at the specified index.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     */
+    @Override
+    public E get(int location) {
+        E obj;
+        realm.checkIfValid();
+        TableOrView table = getTable();
+        if (table instanceof TableView) {
+            obj = realm.get(classSpec, className, ((TableView) table).getSourceRowIndex(location));
+        } else {
+            obj = realm.get(classSpec, className, location);
+        }
+
+        return obj;
+    }
+
+    /**
+     * This method is not supported.
+     *
+     * @throws NoSuchMethodError always.
+     */
+    @Override
+    public int indexOf(Object o) {
+        throw new NoSuchMethodError("indexOf is not supported on RealmResults");
+    }
+
+    /**
+     * Gets the first object from the list.
+     *
+     * @return the first object.
+     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
+     */
+    public E first() {
+        return get(0);
+    }
+
+    /**
+     * Gets the last object from the list.
+     *
+     * @return the last object.
+     * @throws ArrayIndexOutOfBoundsException if RealmResults is empty.
+     */
+    public E last() {
+        return get(size()-1);
+    }
+
+    /**
+     * Returns an iterator for the results of a query. Any change to Realm while iterating will cause this iterator to
+     * throw a {@link java.util.ConcurrentModificationException} if accessed.
+     *
+     * @return an iterator on the elements of this list.
+     * @see Iterator
+     */
+    @Override
+    public Iterator<E> iterator() {
+        if (!isLoaded()) {
+            // Collections.emptyIterator(); is only available since API 19
+            return Collections.<E>emptyList().iterator();
+        }
+        return new RealmResultsIterator();
+    }
+
+    /**
+     * Returns a list iterator for the results of a query. Any change to Realm while iterating will cause the iterator
+     * to throw a {@link java.util.ConcurrentModificationException} if accessed.
+     *
+     * @return a ListIterator on the elements of this list.
+     * @see ListIterator
+     */
+    @Override
+    public ListIterator<E> listIterator() {
+        if (!isLoaded()) {
+            // Collections.emptyListIterator() is only available since API 19
+            return Collections.<E>emptyList().listIterator();
+        }
+        return new RealmResultsListIterator(0);
+    }
+
+    /**
+     * Returns a list iterator on the results of a query. Any change to Realm while iterating will cause the iterator to
+     * throw a {@link java.util.ConcurrentModificationException} if accessed.
+     *
+     * @param location the index at which to start the iteration.
+     * @return a ListIterator on the elements of this list.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
+     * @see ListIterator
+     */
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        if (!isLoaded()) {
+            // Collections.emptyListIterator() is only available since API 19
+            return Collections.<E>emptyList().listIterator(location);
+        }
+        return new RealmResultsListIterator(location);
+    }
+
+    // Sorting
+
+    // aux. method used by sort methods
+    private long getColumnIndex(String fieldName) {
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
+        }
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
+        }
+        return columnIndex;
+    }
+
+    /**
+     * Sorts (ascending) an existing {@link io.realm.RealmResults}.
+     *
+     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
+     *                  and String are supported.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public void sort(String fieldName) {
+        this.sort(fieldName, Sort.ASCENDING);
+    }
+
+    /**
+     * Sorts existing {@link io.realm.RealmResults}.
+     *
+     * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
+     *                  and String are supported.
+     * @param sortOrder the direction to sort by.
+     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     */
+    public void sort(String fieldName, Sort sortOrder) {
+        if (fieldName == null) {
+            throw new IllegalArgumentException("fieldName must be provided");
+        }
+        realm.checkIfValid();
+        TableOrView table = getTable();
+
+        if (table instanceof TableView) {
+            long columnIndex = getColumnIndex(fieldName);
+            ((TableView) table).sort(columnIndex, sortOrder);
+        } else {
+            throw new IllegalArgumentException("Only RealmResults can be sorted - please use allObject() to create a RealmResults.");
+        }
+    }
+
+    /**
+     * Sorts existing {@link io.realm.RealmResults}.
+     *
+     * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int, long, float,
+     *                   double, Date, and String are supported.
+     * @param sortOrders the directions to sort by.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public void sort(String fieldNames[], Sort sortOrders[]) {
+        if (fieldNames == null) {
+            throw new IllegalArgumentException("fieldNames must be provided.");
+        } else if (sortOrders == null) {
+            throw new IllegalArgumentException("sortOrder must be provided.");
+        }
+
+        if (fieldNames.length == 1 && sortOrders.length == 1) {
+            sort(fieldNames[0], sortOrders[0]);
+        } else {
+            realm.checkIfValid();
+            TableOrView table = getTable();
+            if (table instanceof TableView) {
+                List<Long> columnIndices = new ArrayList<Long>();
+                for (int i = 0; i < fieldNames.length; i++) {
+                    String fieldName = fieldNames[i];
+                    long columnIndex = getColumnIndex(fieldName);
+                    columnIndices.add(columnIndex);
+                }
+                ((TableView) table).sort(columnIndices, sortOrders);
+            }
+        }
+    }
+
+    /**
+     * Sorts existing {@link io.realm.RealmResults} using two fields.
+     *
+     * @param fieldName1 first field name.
+     * @param sortOrder1 sort order for first field.
+     * @param fieldName2 second field name.
+     * @param sortOrder2 sort order for second field.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    }
+
+    /**
+     * Sorts existing {@link io.realm.RealmResults} using three fields.
+     *
+     * @param fieldName1 first field name.
+     * @param sortOrder1 sort order for first field.
+     * @param fieldName2 second field name.
+     * @param sortOrder2 sort order for second field.
+     * @param fieldName3 third field name.
+     * @param sortOrder3 sort order for third field.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     */
+    public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2, String fieldName3, Sort sortOrder3) {
+        sort(new String[]{fieldName1, fieldName2, fieldName3}, new Sort[]{sortOrder1, sortOrder2, sortOrder3});
+    }
+
+    // Aggregates
+
+    /**
+     * Returns the number of elements in this query result.
+     *
+     * @return the number of elements in this query result.
+     */
+    @Override
+    public int size() {
+        if (!isLoaded()) {
+            return 0;
+        } else {
+            long size = getTable().size();
+            return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
+        }
+    }
+
+    /**
+     * Finds the minimum value of a field.
+     *
+     * @param fieldName the field to look for a minimum on. Only number fields are supported.
+     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the minimum value is returned. When determining the minimum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number min(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return table.minimumLong(columnIndex);
+            case FLOAT:
+                return table.minimumFloat(columnIndex);
+            case DOUBLE:
+                return table.minimumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    /**
+     * Finds the minimum date.
+     *
+     * @param fieldName the field to look for the minimum date. If fieldName is not of Date type, an exception is
+     *                  thrown.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
+     */
+    public Date minDate(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
+            return table.minimumDate(columnIndex);
+        }
+        else {
+            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
+        }
+    }
+
+    /**
+     * Finds the maximum value of a field.
+     *
+     * @param fieldName the field to look for a maximum on. Only number fields are supported.
+     * @return if no objects exist or they all have {@code null} as the value for the given field, {@code null} will be
+     * returned. Otherwise the maximum value is returned. When determining the maximum value, objects with {@code null}
+     * values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number max(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return table.maximumLong(columnIndex);
+            case FLOAT:
+                return table.maximumFloat(columnIndex);
+            case DOUBLE:
+                return table.maximumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    /**
+     * Finds the maximum date.
+     *
+     * @param fieldName the field to look for the maximum date. If fieldName is not of Date type, an exception is
+     *                  thrown.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with
+     * {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
+     */
+    public Date maxDate(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
+            return table.maximumDate(columnIndex);
+        }
+        else {
+            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
+        }
+    }
+
+
+    /**
+     * Calculates the sum of a given field.
+     *
+     * @param fieldName the field to sum. Only number fields are supported.
+     * @return the sum. If no objects exist or they all have {@code null} as the value for the given field, {@code 0}
+     * will be returned. When computing the sum, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public Number sum(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return table.sumLong(columnIndex);
+            case FLOAT:
+                return table.sumFloat(columnIndex);
+            case DOUBLE:
+                return table.sumDouble(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+
+    /**
+     * Returns the average of a given field.
+     *
+     * @param fieldName the field to calculate average on. Only number fields are supported.
+     * @return the average for the given field amongst objects in query results. This will be of type double for all
+     * types of number fields. If no objects exist or they all have {@code null} as the value for the given field,
+     * {@code 0} will be returned. When computing the average, objects with {@code null} values are ignored.
+     * @throws java.lang.IllegalArgumentException if the field is not a number type.
+     */
+    public double average(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = table.getColumnIndex(fieldName);
+        switch (table.getColumnType(columnIndex)) {
+            case INTEGER:
+                return table.averageLong(columnIndex);
+            case DOUBLE:
+                return table.averageDouble(columnIndex);
+            case FLOAT:
+                return table.averageFloat(columnIndex);
+            default:
+                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+        }
+    }
+
+    /**
+     * Returns a distinct set of objects of a specific class. If the result is sorted, the first
+     * object will be returned in case of multiple occurrences, otherwise it is undefined which
+     * object is returned.
+     *
+     * @param fieldName the field name.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<E> distinct(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
+
+        TableOrView tableOrView = getTable();
+        if (tableOrView instanceof Table) {
+            this.table = ((Table) tableOrView).getDistinctView(columnIndex);
+        } else {
+            ((TableView) tableOrView).distinct(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Asynchronously returns a distinct set of objects of a specific class. If the result is
+     * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
+     * undefined which object is returned.
+     *
+     * @param fieldName the field name.
+     * @return immediately a {@link RealmResults}. Users need to register a listener
+     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
+     * query completes.
+     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * is not indexed, or points to linked fields.
+     */
+    public RealmResults<E> distinctAsync(String fieldName) {
+        return where().distinctAsync(fieldName);
+    }
+
+    /**
+     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @return a non-null {@link RealmResults} containing the distinct objects.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     */
+    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
+        return where().distinct(firstFieldName, remainingFieldNames);
+    }
+
+    // Deleting
+
+    /**
+     * Removes an object at a given index. This also deletes the object from the underlying Realm.
+     *
+     * Using this method while iterating the list can result in a undefined behavior. Use
+     * {@link io.realm.RealmResults.RealmResultsIterator#remove()} instead.
+     *
+     * @param index the array index identifying the object to be removed.
+     * @return always return {@code null}.
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    @Override
+    public E remove(int index) {
+        realm.checkIfValid();
+        TableOrView table = getTable();
+        table.remove(index);
+        return null; // Returning the object doesn't make sense, since it could no longer access any data.
+    }
+
+    /**
+     * Removes the last object in the list. This also deletes the object from the underlying Realm.
+     *
+     * Using this method while iterating the list can result in a undefined behavior. Use
+     * {@link io.realm.RealmResults.RealmResultsListIterator#removeLast()} instead.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    public void removeLast() {
+        realm.checkIfValid();
+        TableOrView table = getTable();
+        table.removeLast();
+    }
+
+    /**
+     * Removes all objects from the list. This also deletes the objects from the underlying Realm.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    public void clear() {
+        realm.checkIfValid();
+        TableOrView table = getTable();
+        table.clear();
+    }
+
+    // Adding objects
+
+    @Override
+    @Deprecated
+    public boolean add(E element) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    @Deprecated
+    public void add(int index, E element) {
+        throw new UnsupportedOperationException();
+    }
+//
+//    /**
+//     * Replaces an object at the given index with a new object.
+//     *
+//     * @param index the array index of the object to be replaced.
+//     * @param element an object.
+//     */
+//    public void replace(int index, E element) {
+//        throw new NoSuchMethodError();
+//    }
+
+
+
+    // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
+    private class RealmResultsIterator implements Iterator<E> {
+        long tableViewVersion = 0;
+        int pos = -1;
+
+        RealmResultsIterator() {
+            tableViewVersion = table.sync();
+        }
+
+        public boolean hasNext() {
+            assertRealmIsStable();
+            return pos + 1 < size();
+        }
+
+        public E next() {
+            assertRealmIsStable();
+            pos++;
+            if (pos >= size()) {
+                throw new IndexOutOfBoundsException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
+            }
+            return get(pos);
+        }
+
+        /**
+         * Removes the RealmObject at the current position from both the list and the underlying Realm.
+         *
+         * WARNING: This method is currently disabled and will always throw an
+         * {@link io.realm.exceptions.RealmException}
+         */
+        public void remove() {
+            throw new RealmException("Removing is not supported.");
+    /*        assertRealmIsStable();
+            if (pos == -1) {
+                throw new IllegalStateException("Must call next() before calling remove()");
+            }
+            if (removeUsed) {
+                throw new IllegalStateException("Cannot call remove() twice. Must call next() in between");
+            }
+
+            RealmResults.this.remove(pos);
+            pos--;
+            removeUsed = true;
+            currentTableViewVersion = getTable().sync();
+     */   }
+
+        protected void assertRealmIsStable() {
+            long version = table.sync();
+            if (tableViewVersion > -1 && version != tableViewVersion) {
+                throw new ConcurrentModificationException("No outside changes to a Realm is allowed while iterating a RealmResults. Use iterators methods instead.");
+            }
+            tableViewVersion = version;
+        }
+    }
+
+    // Custom RealmResults list iterator. It ensures that we only iterate on a Realm that hasn't changed.
+    private class RealmResultsListIterator extends RealmResultsIterator implements ListIterator<E> {
+
+        RealmResultsListIterator(int start) {
+            if (start >= 0 && start <= size()) {
+                pos = start - 1;
+            } else {
+                throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, " + (size() - 1) + "]. Yours was " + start);
+            }
+        }
+
+        @Override
+        public void add(E object) {
+            throw new RealmException("Adding elements not supported. Use Realm.createObject() instead.");
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            assertRealmIsStable();
+            return pos > 0;
+        }
+
+        @Override
+        public int nextIndex() {
+            assertRealmIsStable();
+            return pos + 1;
+        }
+
+        @Override
+        public E previous() {
+            assertRealmIsStable();
+            pos--;
+            if (pos < 0) {
+                throw new IndexOutOfBoundsException("Cannot access index less than zero. This was " + pos + ". Remember to check hasPrevious() before using previous().");
+            }
+            return get(pos);
+        }
+
+        @Override
+        public int previousIndex() {
+            assertRealmIsStable();
+            return pos;
+        }
+
+        @Override
+        public void set(E object) {
+            throw new RealmException("Replacing elements not supported.");
+        }
+
+
+        /**
+         * Removes the RealmObject at the current position from both the list and the underlying Realm.
+         *
+         * WARNING: This method is currently disabled and will always throw an
+         * {@link io.realm.exceptions.RealmException}
+         */
+        @Override
+        public void remove() { throw new RealmException("Removing elements not supported."); }
+    }
+
+    /**
+     * Swaps the table_view pointer used by this RealmResults mostly called when updating the RealmResults from a worker
+     * thread.
+     *
+     * @param handoverTableViewPointer handover pointer to the new table_view.
+     */
+    void swapTableViewPointer(long handoverTableViewPointer) {
+        table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
+        isCompleted = true;
+    }
+
+    /**
+     * Sets the Future instance returned by the worker thread, we need this instance to force {@link #load()} an async
+     * query, we use it to determine if the current RealmResults is a sync or async one.
+     *
+     * @param pendingQuery pending query.
+     */
+    void setPendingQuery(Future<Long> pendingQuery) {
+        this.pendingQuery = pendingQuery;
+        if (isLoaded()) {
+            // the query completed before RealmQuery
+            // had a chance to call setPendingQuery to register the pendingQuery (used btw
+            // to determine isLoaded behaviour)
+            onCompleted();
+        } // else, it will be handled by the {@link BaseRealm#handlerController#handleMessage}
+    }
+
+    /**
+     * Returns {@code true} if the results are not yet loaded, {@code false} if they are still loading. Synchronous
+     * query methods like findAll() will always return {@code true}, while asynchronous query methods like
+     * findAllAsync() will return {@code false} until the results are available.
+     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     *
+     * @return {@code true} if the query has completed and the data is available {@code false} if the query is still
+     * running.
+     */
+    public boolean isLoaded() {
+        realm.checkIfValid();
+        return pendingQuery == null || isCompleted;
+    }
+
+    /**
+     * Makes an asynchronous query blocking. This will also trigger any registered listeners.
+     * This will return {@code true} for standalone object (created outside of Realm). {@link RealmChangeListener} when
+     * the query completes.
+     *
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     */
+    public boolean load() {
+        //noinspection SimplifiableIfStatement
+        if (isLoaded()) {
+            return true;
+        } else {
+            // doesn't guarantee to import correctly the result (because the user may have advanced)
+            // in this case the Realm#handler will be responsible of retrying
+            return onCompleted();
+        }
+    }
+
+    /**
+     * Called to import the handover table_view pointer & notify listeners.
+     * This should be invoked once the {@link #pendingQuery} finish, unless the user force {@link #load()}.
+     *
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     */
+    private boolean onCompleted() {
+        try {
+            long tvHandover = pendingQuery.get();// make the query blocking
+            // this may fail with BadVersionException if the caller and/or the worker thread
+            // are not in sync. COMPLETED_ASYNC_REALM_RESULTS will be fired by the worker thread
+            // this should handle more complex use cases like retry, ignore etc
+            table = query.importHandoverTableView(tvHandover, realm.sharedGroupManager.getNativePointer());
+            isCompleted = true;
+            notifyChangeListeners();
+        } catch (Exception e) {
+            RealmLog.d(e.getMessage());
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Adds a change listener to this RealmResults.
+     *
+     * @param listener the change listener to be notified.
+     */
+    public void addChangeListener(RealmChangeListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
+        realm.checkIfValid();
+        if (realm.handler == null) {
+            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+        }
+        if (!listeners.contains(listener)) {
+            listeners.add(listener);
+        }
+    }
+
+    /**
+     * Removes a previously registered listener.
+     *
+     * @param listener the instance to be removed.
+     */
+    public void removeChangeListener(RealmChangeListener listener) {
+        if (listener == null)
+            throw new IllegalArgumentException("Listener should not be null");
+
+        realm.checkIfValid();
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all registered listeners.
+     */
+    public void removeChangeListeners() {
+        realm.checkIfValid();
+        listeners.clear();
+    }
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmResults. It will emit the current RealmResults when
+     * subscribed to. RealmResults will continually be emitted as the RealmResults are updated -
+     * {@code onComplete} will never be called.
+     *
+     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * only emit only the first item by using the {@code first()} operator:
+     *
+     *<pre>
+     * {@code
+     * realm.where(Foo.class).findAllAsync().asObservable()
+     *      .filter(results -> results.isLoaded())
+     *      .first()
+     *      .subscribe( ... ) // You only get the results once
+     * }
+     * </pre>
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    @SuppressWarnings("unchecked")
+    public Observable<RealmResults<E>> asObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().from((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
+            @SuppressWarnings("UnnecessaryLocalVariable")
+            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicResults);
+            return results;
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+        }
+    }
+
+    /**
+     * Notifies all registered listeners.
+     */
+    void notifyChangeListeners() {
+        if (listeners != null && !listeners.isEmpty()) {
+            // table might be null (if the async query didn't complete
+            // but we have already registered listeners for it)
+            if (pendingQuery != null && !isCompleted) return;
+            long version = table.sync();
+            if (currentTableViewVersion != version) {
+                currentTableViewVersion = version;
+                for (RealmChangeListener listener : listeners) {
+                    listener.onChange();
+                }
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
new file mode 100644
index 0000000000..2957d646ce
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.Table;
+import io.realm.internal.Util;
+
+/**
+ * Class for interacting with the Realm schema using a dynamic API. This makes it possible
+ * to add, delete and change the classes in the Realm.
+ *
+ * All changes must happen inside a write transaction for that Realm.
+ *
+ * @see io.realm.RealmMigration
+ */
+public final class RealmSchema {
+
+    private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
+    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+
+    // Caches Dynamic Class objects given as Strings (both model classes and proxy classes) to Realm Tables
+    private final Map<String, Table> dynamicClassToTable = new HashMap<String, Table>();
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmObject>, Table> classToTable = new HashMap<Class<? extends RealmObject>, Table>();
+    // Caches Class objects (both model classes and proxy classes) to their Schema object
+    private final Map<Class<? extends RealmObject>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmObject>, RealmObjectSchema>();
+    // Caches Class Strings (both model classes and proxy classes) to their Schema object
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
+
+    private final ImplicitTransaction transaction;
+    private final BaseRealm realm;
+    ColumnIndices columnIndices; // Cached field look up
+
+    /**
+     * Creates a wrapper to easily manipulate the current schema of a Realm.
+     */
+    RealmSchema(BaseRealm realm, ImplicitTransaction transaction) {
+        this.realm = realm;
+        this.transaction = transaction;
+    }
+
+    /**
+     * Returns the Realm schema for a given class.
+     *
+     * @param className name of the class
+     * @return schema object for that class or {@code null} if the class doesn't exists.
+     *
+     */
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalClassName = TABLE_PREFIX + className;
+        if (transaction.hasTable(internalClassName)) {
+            Table table = transaction.getTable(internalClassName);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            return new RealmObjectSchema(realm, table, columnIndices);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     *
+     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
+     */
+    public Set<RealmObjectSchema> getAll() {
+        int tableCount = (int) transaction.size();
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+        for (int i = 0; i < tableCount; i++) {
+            String tableName = transaction.getTableName(i);
+            if (Table.isMetaTable(tableName)) {
+                continue;
+            }
+            Table table = transaction.getTable(tableName);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+        }
+        return schemas;
+    }
+
+    /**
+     * Adds a new class to the Realm.
+     *
+     * @param className name of the class.
+     * @return a Realm schema object for that class.
+     */
+    public RealmObjectSchema create(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = TABLE_PREFIX + className;
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
+        }
+        if (transaction.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        Table table = transaction.getTable(internalTableName);
+        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+        return new RealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
+     * to it will throw an {@link IllegalStateException}. Remove those classes or fields first.
+     *
+     * @param className name of the class to remove.
+     */
+    public void remove(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = TABLE_PREFIX + className;
+        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        transaction.removeTable(internalTableName);
+    }
+
+    /**
+     * Renames a class already in the Realm.
+     *
+     * @param oldClassName old class name.
+     * @param newClassName new class name.
+     * @return a schema object for renamed class.
+     */
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        checkEmpty(oldClassName, "Class names cannot be empty or null");
+        checkEmpty(newClassName, "Class names cannot be empty or null");
+        String oldInternalName = TABLE_PREFIX + oldClassName;
+        String newInternalName = TABLE_PREFIX + newClassName;
+        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
+        if (transaction.hasTable(newInternalName)) {
+            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
+        }
+        transaction.renameTable(oldInternalName, newInternalName);
+        Table table = transaction.getTable(newInternalName);
+        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+        return new RealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Checks if a given class already exists in the schema.
+     *
+     * @param className class name to check.
+     * @return {@code true} if the class already exists. {@code false} otherwise.
+     */
+    public boolean contains(String className) {
+        return transaction.hasTable(Table.TABLE_PREFIX + className);
+    }
+
+    private void checkEmpty(String str, String error) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException(error);
+        }
+    }
+
+    private void checkHasTable(String className, String errorMsg) {
+        String internalTableName = TABLE_PREFIX + className;
+        if (!transaction.hasTable(internalTableName)) {
+            throw new IllegalArgumentException(errorMsg);
+        }
+    }
+
+    ColumnInfo getColumnInfo(Class<? extends RealmObject> clazz) {
+        final ColumnInfo columnInfo = columnIndices.getColumnInfo(clazz);
+        if (columnInfo == null) {
+            throw new IllegalStateException("No validated schema information found for " + realm.configuration.getSchemaMediator().getTableName(clazz));
+        }
+        return columnInfo;
+    }
+
+    Table getTable(String className) {
+        className = Table.TABLE_PREFIX + className;
+        Table table = dynamicClassToTable.get(className);
+        if (table == null) {
+            if (!transaction.hasTable(className)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            table = transaction.getTable(className);
+            dynamicClassToTable.put(className, table);
+        }
+        return table;
+    }
+
+    Table getTable(Class<? extends RealmObject> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table == null) {
+            clazz = Util.getOriginalModelClass(clazz);
+            table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(clazz));
+            classToTable.put(clazz, table);
+        }
+        return table;
+    }
+
+    RealmObjectSchema getSchemaForClass(Class<? extends RealmObject> clazz) {
+        RealmObjectSchema classSchema = classToSchema.get(clazz);
+        if (classSchema == null) {
+            clazz = Util.getOriginalModelClass(clazz);
+            Table table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(clazz));
+            classSchema = new RealmObjectSchema(realm, table, columnIndices.getColumnInfo(clazz).getIndicesMap());
+            classToSchema.put(clazz, classSchema);
+        }
+        return classSchema;
+    }
+
+    RealmObjectSchema getSchemaForClass(String className) {
+        className = Table.TABLE_PREFIX + className;
+        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
+        if (dynamicSchema == null) {
+            if (!transaction.hasTable(className)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            Table table = transaction.getTable(className);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
+            dynamicClassToSchema.put(className, dynamicSchema);
+        }
+        return dynamicSchema;
+    }
+
+    void setColumnIndices(ColumnIndices columnIndices) {
+        this.columnIndices = columnIndices;
+    }
+
+    static String getSchemaForTable(Table table) {
+        return table.getName().substring(Table.TABLE_PREFIX.length());
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
new file mode 100644
index 0000000000..71329ed351
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * This class describes the sorting order used in Realm queries.
+ *
+ * @see io.realm.Realm#allObjectsSorted(Class, String, Sort)
+ * @see io.realm.RealmQuery#findAllSorted(String, Sort)
+ */
+public enum Sort {
+    ASCENDING(true),
+    DESCENDING(false);
+
+    private final boolean value;
+
+    Sort(boolean value) {
+        this.value = value;
+    }
+
+    /**
+     * Returns the value for this setting that is used by the underlying query engine.
+     * @return The value used by the underlying query engine to indicate this value.
+     */
+    public boolean getValue() {
+        return value;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
new file mode 100644
index 0000000000..f726575adf
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmError.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import io.realm.internal.Keep;
+
+/**
+ * RealmError is Realm specific Error used when unrecoverable problems happen in the underlying storage engine. An
+ * RealmError should never be caught or ignored. By doing so, the Realm could possibly get corrupted.
+ */
+@Keep
+public class RealmError extends Error {
+    public RealmError(String detailMessage) {
+        super(detailMessage);
+    }
+}
diff --git a/realm/src/main/java/io/realm/exceptions/RealmException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
similarity index 96%
rename from realm/src/main/java/io/realm/exceptions/RealmException.java
rename to realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
index ce8057fd66..354e2ce5f0 100644
--- a/realm/src/main/java/io/realm/exceptions/RealmException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmException.java
@@ -16,9 +16,12 @@
 
 package io.realm.exceptions;
 
+import io.realm.internal.Keep;
+
 /**
  * RealmException is Realm specific exceptions.
  */
+@Keep
 public class RealmException extends RuntimeException {
 
     public RealmException(String detailMessage) {
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
new file mode 100644
index 0000000000..3d59ed049e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import io.realm.internal.Keep;
+
+/**
+ * Class for reporting problems with Realm files.
+ */
+@Keep
+public class RealmIOException extends RuntimeException {
+
+    public RealmIOException(Throwable cause) {
+        super(cause);
+    }
+
+    public RealmIOException() {
+    }
+
+    public RealmIOException(String message) {
+        super(message);
+    }
+
+    public RealmIOException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+}
diff --git a/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
similarity index 87%
rename from realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
rename to realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index 0ac92a4bbc..d1093d6313 100644
--- a/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -13,10 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package io.realm.exceptions;
 
 import java.io.File;
 
+import io.realm.internal.Keep;
+
+@Keep
 public class RealmMigrationNeededException extends RuntimeException {
 
     private final String canonicalRealmPath;
@@ -36,14 +40,6 @@ public RealmMigrationNeededException(String canonicalRealmPath, String detailMes
      *
      * This can be used for easy reference during a migration:
      *
-     * <pre>
-     * try {
-     *   Realm.getInstance(context);
-     * } catch (RealmMigrationNeededException e) {
-     *   Realm.migrateRealmAtPath(e.getRealmPath(), new CustomMigration());
-     * }
-     * </pre>
-     *
      * @return Canonical path to the Realm file.
      * @see File#getCanonicalPath()
      */
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
new file mode 100644
index 0000000000..e24a380ba2
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmPrimaryKeyConstraintException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import io.realm.internal.Keep;
+
+/**
+ * Class for reporting problems when the primary key constraint is being broken.
+ *
+ * @see io.realm.annotations.PrimaryKey
+ */
+@Keep
+public class RealmPrimaryKeyConstraintException extends RuntimeException {
+    public RealmPrimaryKeyConstraintException(String message) {
+        super(message);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
new file mode 100644
index 0000000000..ae0b460365
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Checked wrapper for Row data in Realm Core. All methods called through this will check that input parameters are
+ * valid or throw an appropriate exception.
+ * <p>
+ * For low-level access to a Realm where safety checks were already performed, use {@link UncheckedRow} instead for
+ * improved performance.
+ */
+public class CheckedRow extends UncheckedRow {
+
+    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and it's
+    // underlying native data.
+    @SuppressWarnings("unused")
+    private UncheckedRow originalRow;
+
+    private CheckedRow(Context context, Table parent, long nativePtr) {
+        super(context, parent, nativePtr);
+    }
+
+    private CheckedRow(UncheckedRow row) {
+        super(row.context, row.parent, row.nativePointer);
+        this.originalRow = row;
+    }
+
+    /**
+     * Gets the row object associated to an index in a {@link Table}.
+     *
+     * @param context the Realm context.
+     * @param table the {@link Table} that holds the row.
+     * @param index the index of the row.
+     * @return an instance of Row for the table and index specified.
+     */
+    public static CheckedRow get(Context context, Table table, long index) {
+        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        CheckedRow row = new CheckedRow(context, table, nativeRowPointer);
+        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
+                Context.NATIVE_REFERENCES_VALUE);
+        return row;
+    }
+
+    /**
+     * Gets the row object associated to an index in a {@link LinkView}.
+     *
+     * @param context the Realm context.
+     * @param linkView the {@link LinkView} holding the row.
+     * @param index the index of the row.
+     * @return a checked instance of {@link Row} for the {@link LinkView} and index specified.
+     */
+    public static CheckedRow get(Context context, LinkView linkView, long index) {
+        long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
+        CheckedRow row = new CheckedRow(context, linkView.getTargetTable(),
+                nativeRowPointer);
+        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
+                Context.NATIVE_REFERENCES_VALUE);
+        return row;
+    }
+
+    /**
+     * Converts a {@link UncheckedRow} to a {@link CheckedRow}.
+     *
+     * @return an checked instance of {@link Row}.
+     */
+    public static CheckedRow getFromRow(UncheckedRow row) {
+        return new CheckedRow(row);
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        RealmFieldType columnType = getColumnType(columnIndex);
+        if (columnType == RealmFieldType.OBJECT || columnType == RealmFieldType.LIST) {
+            return super.isNullLink(columnIndex);
+        } else {
+            return false; // Unsupported types always return false
+        }
+    }
+
+    @Override
+    public boolean isNull(long columnIndex) {
+        return super.isNull(columnIndex);
+    }
+
+    @Override
+    public void setNull(long columnIndex) {
+        RealmFieldType columnType = getColumnType(columnIndex);
+        if (columnType == RealmFieldType.STRING) {
+            super.setString(columnIndex, null);
+        }
+        else if (columnType == RealmFieldType.BINARY) {
+            super.setBinaryByteArray(columnIndex, null);
+        }
+        else {
+            if (!this.getTable().isColumnNullable(columnIndex)) {
+                throw new IllegalArgumentException("field is not nullable");
+            }
+            super.setNull(columnIndex);
+        }
+    }
+
+    protected native long nativeGetColumnCount(long nativeTablePtr);
+    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
+    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
+    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
+    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native String nativeGetString(long nativePtr, long columnIndex);
+    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
+    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
+    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
+    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
+    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
+    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
+}
diff --git a/realm/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
similarity index 62%
rename from realm/src/main/java/io/realm/internal/ColumnIndices.java
rename to realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 759c93d350..f05a702b9b 100644
--- a/realm/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -16,9 +16,7 @@
 
 package io.realm.internal;
 
-import java.util.HashMap;
 import java.util.Map;
-import java.util.Set;
 
 import io.realm.RealmObject;
 
@@ -27,29 +25,26 @@
  */
 public class ColumnIndices {
 
-    private Map<Class<? extends RealmObject>, Map<String, Long>> classes = new HashMap<Class<? extends RealmObject>, Map<String, Long>>();
+    private final Map<Class<? extends RealmObject>, ColumnInfo> classes;
 
-    /**
-     * Add column indices from a given model class
-     */
-    public void addClass(Class<? extends RealmObject> clazz, Map<String, Long> indicies) {
-        classes.put(clazz, indicies);
+    public ColumnIndices(Map<Class<? extends RealmObject>, ColumnInfo> classes) {
+        this.classes = classes;
     }
 
     /**
-     * Return mappings for the given class or null if no mapping exists.
+     * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
      */
-    public Map<String, Long> getClassFields(Class<? extends RealmObject> clazz) {
+    public ColumnInfo getColumnInfo(Class<? extends RealmObject> clazz) {
         return classes.get(clazz);
     }
 
     /**
-     * Returns the column index for a given field on a clazz or -1 if no such field exists.
+     * Returns the column index for a given field on a clazz or {@code -1} if no such field exists.
      */
     public long getColumnIndex(Class<? extends RealmObject> clazz, String fieldName) {
-        Map<String, Long> mapping = classes.get(clazz);
-        if (mapping != null) {
-            Long index = mapping.get(fieldName);
+        final ColumnInfo columnInfo = classes.get(clazz);
+        if (columnInfo != null) {
+            Long index = columnInfo.getIndicesMap().get(fieldName);
             return (index != null) ? index : -1;
         } else {
             return -1;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
new file mode 100644
index 0000000000..1bd57372f8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.Collections;
+import java.util.Map;
+
+import io.realm.exceptions.RealmMigrationNeededException;
+
+public class ColumnInfo {
+    private Map<String, Long> indicesMap;
+
+    protected final long getValidColumnIndex(String realmPath, Table table,
+                                             String className, String columnName) {
+        final long columnIndex = table.getColumnIndex(columnName);
+        if (columnIndex == -1) {
+            throw new RealmMigrationNeededException(realmPath,
+                    "Field '" + columnName + "' not found for type " + className);
+        }
+        return columnIndex;
+    }
+
+    protected final void setIndicesMap(Map<String, Long> indicesMap) {
+        this.indicesMap = Collections.unmodifiableMap(indicesMap);
+    }
+
+    public Map<String, Long> getIndicesMap() {
+        return indicesMap;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/Context.java
similarity index 69%
rename from realm/src/main/java/io/realm/internal/Context.java
rename to realm/realm-library/src/main/java/io/realm/internal/Context.java
index 29ccb9122b..f2f5f5215b 100644
--- a/realm/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Context.java
@@ -16,10 +16,13 @@
 
 package io.realm.internal;
 
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 
-class Context {
+public class Context {
 
     // Each group of related Realm objects will have a Context object in the root.
     // The root can be a table, a group, or a shared group.
@@ -27,34 +30,48 @@
     // whose disposal need to be handed over from the garbage 
     // collection thread to the users thread.
 
+    // Reserved to be used only as a placeholder by native references Map to avoid autoboxing allocations
+    static final Integer NATIVE_REFERENCES_VALUE = 0;
+
     private List<Long> abandonedTables = new ArrayList<Long>();
     private List<Long> abandonedTableViews = new ArrayList<Long>();
     private List<Long> abandonedQueries = new ArrayList<Long>();
-    private List<Long> abandonedRows = new ArrayList<Long>();
+
+    HashMap<Reference<?>, Integer> rowReferences = new HashMap<Reference<?>, Integer>();
+    ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
 
     private boolean isFinalized = false;
 
     public void executeDelayedDisposal() {
         synchronized (this) {
-            for (long nativePointer: abandonedTables) {
+            for (int i = 0; i < abandonedTables.size(); i++) {
+                long nativePointer = abandonedTables.get(i);
                 Table.nativeClose(nativePointer);
             }
             abandonedTables.clear();
 
-            for (long nativePointer: abandonedRows) {
-                Row.nativeClose(nativePointer);
-            }
-            abandonedRows.clear();
-
-            for (long nativePointer: abandonedTableViews) {
+            for (int i = 0; i < abandonedTableViews.size(); i++) {
+                long nativePointer = abandonedTableViews.get(i);
                 TableView.nativeClose(nativePointer);
             }
             abandonedTableViews.clear();
 
-            for (long nativePointer: abandonedQueries) {
+            for (int i = 0; i < abandonedQueries.size(); i++) {
+                long nativePointer = abandonedQueries.get(i);
                 TableQuery.nativeClose(nativePointer);
             }
             abandonedQueries.clear();
+
+            cleanNativeReferences();
+        }
+    }
+
+    public void cleanNativeReferences() {
+        NativeObjectReference reference = (NativeObjectReference) referenceQueue.poll();
+        while (reference != null) {
+            reference.clear();
+            rowReferences.remove(reference);
+            reference = (NativeObjectReference) referenceQueue.poll();
         }
     }
 
@@ -67,15 +84,6 @@ public void asyncDisposeTable(long nativePointer, boolean isRoot) {
         }
     }
 
-    public void asyncDisposeRow(long nativePointer) {
-        if (isFinalized) {
-            Row.nativeClose(nativePointer);
-        }
-        else {
-            abandonedRows.add(nativePointer);
-        }
-    }
-
     public void asyncDisposeTableView(long nativePointer) {
         if (isFinalized) {
             TableView.nativeClose(nativePointer);
diff --git a/realm/src/main/java/io/realm/internal/DefineTable.java b/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
similarity index 96%
rename from realm/src/main/java/io/realm/internal/DefineTable.java
rename to realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
index a91baed585..c4ed8e4632 100644
--- a/realm/src/main/java/io/realm/internal/DefineTable.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
@@ -23,8 +23,7 @@
 
 /**
  * This annotation is used to mark the classes that serve as entity description.
- * For each such class, e.g. Xyz, the classes XyzTable, XyzView, XyzRow and
- * XyzQuery will be generated.
+ * For each such class, e.g. Xyz, the classes XyzTable, XyzView, XyzRow and XyzQuery will be generated.
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.TYPE)
diff --git a/realm/src/main/java/io/realm/internal/Group.java b/realm/realm-library/src/main/java/io/realm/internal/Group.java
similarity index 71%
rename from realm/src/main/java/io/realm/internal/Group.java
rename to realm/realm-library/src/main/java/io/realm/internal/Group.java
index 20d724562c..be068092b2 100644
--- a/realm/src/main/java/io/realm/internal/Group.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Group.java
@@ -22,23 +22,19 @@
 import java.nio.ByteBuffer;
 
 /**
- * This class is used to serialize tables to either disk or memory. It consists
- * of a collection of tables.
+ * This class is used to serialize tables to either disk or memory. It consists of a collection of tables.
  */
 public class Group implements Closeable {
-    
+
+    // Below values must match the values in realm::group::OpenMode in C++
+    public static final int MODE_READONLY = 0; // Open in read-only mode. Fail if the file does not already exist.
+    public static final int MODE_READWRITE = 1; // Open in read/write mode. Create the file if it doesn't exist.
+    public static final int MODE_READWRITE_NOCREATE = 2; // Open in read/write mode. Fail if the file does not already exist.
+
     protected long nativePtr;
     protected boolean immutable;
     private final Context context;
 
-    static {
-        RealmCore.loadLibrary();
-    }
-
-    //
-    // Group construction and destruction
-    //
-
     private void checkNativePtrNotZero() {
         if (this.nativePtr == 0)
             // FIXME: It is wrong to assume that a null pointer means 'out
@@ -55,38 +51,19 @@ public Group() {
         checkNativePtrNotZero();
     }
 
-    protected native long createNative();
-
-    public enum OpenMode {
-        // Below values must match the values in realm::group::OpenMode in C++
-        READ_ONLY(0),
-        READ_WRITE(1),
-        READ_WRITE_NO_CREATE(2);
-        private int value;
-        private OpenMode(int value) {
-            this.value = value;
-        }
-    };
-
-    public Group(String filepath, OpenMode mode) {
-        if (mode.equals(OpenMode.READ_ONLY))
-            this.immutable = true;
-        else
-            this.immutable = false;
-        
+    public Group(String filepath, int mode) {
+        this.immutable = (mode == MODE_READONLY);
         this.context = new Context();
-        this.nativePtr = createNative(filepath, mode.value);
+        this.nativePtr = createNative(filepath, mode);
         checkNativePtrNotZero();
     }
 
-    protected native long createNative(String filepath, int value);
-
     public Group(String filepath) {
-        this(filepath, OpenMode.READ_ONLY);
+        this(filepath, MODE_READONLY);
     }
 
     public Group(File file) {
-        this(file.getAbsolutePath(), file.canWrite() ? OpenMode.READ_WRITE : OpenMode.READ_ONLY);
+        this(file.getAbsolutePath(), file.canWrite() ? MODE_READWRITE : MODE_READONLY);
     }
 
     public Group(byte[] data) {
@@ -100,8 +77,6 @@ public Group(byte[] data) {
         }
     }
 
-    protected native long createNative(byte[] data);
-
     public Group(ByteBuffer buffer) {
         this.immutable = false;
         this.context = new Context();
@@ -113,8 +88,6 @@ public Group(ByteBuffer buffer) {
         }
     }
 
-    protected native long createNative(ByteBuffer buffer);
-
     Group(Context context, long nativePointer, boolean immutable) {
         this.context = context;
         this.nativePtr = nativePointer;
@@ -132,12 +105,10 @@ public void close() {
         }
     }
 
-    protected static native void nativeClose(long nativeGroupPtr);
-
     /**
      * Checks if a group has been closed and can no longer be used.
      *
-     * @return True if closed, false otherwise.
+     * @return {@code true} if closed, {@code false} otherwise.
      */
     boolean isClosed() {
         return nativePtr == 0;
@@ -152,10 +123,6 @@ protected void finalize() {
         }
     }
 
-    //
-    // Group methods
-    //
-
     private void verifyGroupIsValid() {
         if (nativePtr == 0) {
             throw new IllegalStateException("Illegal to call methods on a closed Group.");
@@ -167,30 +134,21 @@ public long size() {
         return nativeSize(nativePtr);
     }
 
-    protected native long nativeSize(long nativeGroupPtr);
-
-
     public boolean isEmpty(){
         return size() == 0;
     }
 
-
     /**
-     * Checks whether table exists in the Group.
+     * Checks whether {@link Table} exists in the Group.
      *
-     * @param name  The name of the table.
-     * @return      true if the table exists, otherwise false.
+     * @param name the name of the {@link Table}.
+     * @return {@code true} if the table exists, otherwise {@code false}.
      */
     public boolean hasTable(String name) {
         verifyGroupIsValid();
-        if (name == null) {
-            return false;
-        }
-        return nativeHasTable(nativePtr, name);
+        return name != null && nativeHasTable(nativePtr, name);
     }
 
-    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
-
     public String getTableName(int index) {
         verifyGroupIsValid();
         long cnt = size();
@@ -202,24 +160,38 @@ public String getTableName(int index) {
         return nativeGetTableName(nativePtr, index);
     }
 
-    protected native String nativeGetTableName(long nativeGroupPtr, int index);
+    /**
+     * Removes a table from the group and delete all data.
+     */
+    public void removeTable(String name) {
+        nativeRemoveTable(nativePtr, name);
+    }
+
+    native void nativeRemoveTable(long nativeGroupPtr, String tableName);
+
+    /**
+     * Renames a table
+     */
+    public void renameTable(String oldName, String newName) {
+        nativeRenameTable(nativePtr, oldName, newName);
+    }
+
+    native void nativeRenameTable(long nativeGroupPtr, String oldName, String newName);
 
     /**
      * Returns a table with the specified name.
      *
-     * @param name  The name of the table.
-     * @return      The table if it exists, otherwise create it.
+     * @param name the name of the {@link Table}.
+     * @return the {@link Table} if it exists, otherwise create it.
      */
     public Table getTable(String name) {
         verifyGroupIsValid();
         if (name == null || name.isEmpty()) {
             throw new IllegalArgumentException("Invalid name. Name must be a non-empty String.");
         }
-        if (immutable) {
-            if (!hasTable(name)) {
-                throw new IllegalStateException("Requested table is not in this Realm. " +
-                        "Creating it requires a transaction: " + name);
-            }
+        if (immutable && !hasTable(name)) {
+            throw new IllegalStateException("Requested table is not in this Realm. " +
+                    "Creating it requires a transaction: " + name);
         }
 
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -234,19 +206,13 @@ public Table getTable(String name) {
         }
     }
 
-    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
-
-    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray)
-            throws IOException;
-
     /**
-     * Serialize the group to the specific file on the disk using encryption.
+     * Serializes the group to the specific file on the disk using encryption.
      *
-     * @param file
-     *            A File object representing the file.
-     * @param key A 64 bytes long byte array containing the key to the encrypted Realm file. Can be null if
-     *            encryption is not required.
-     * @throws IOException
+     * @param file a File object representing the file.
+     * @param key A 64 bytes long byte array containing the key to the encrypted Realm file. Can be null if encryption
+     *            is not required.
+     * @throws IOException.
      */
     public void writeToFile(File file, byte[] key) throws IOException {
         verifyGroupIsValid();
@@ -260,19 +226,26 @@ public void writeToFile(File file, byte[] key) throws IOException {
         nativeWriteToFile(nativePtr, file.getAbsolutePath(), key);
     }
 
-    protected static native long nativeLoadFromMem(byte[] buffer);
-
     /**
-     * Serialize the group to a memory buffer. The byte[] is owned by the JVM.
+     * Serializes the group to a memory buffer. The byte[] is owned by the JVM.
      *
-     * @return Binary array of the serialized group.
+     * @return the binary array of the serialized group.
      */
     public byte[] writeToMem() {
         verifyGroupIsValid();
         return nativeWriteToMem(nativePtr);
     }
 
-    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
+    /*
+     * Check if the Group contains any objects. It only checks for "class_" tables or non-metadata tables, e.g. this
+     * return true if the "pk" table contained information.
+     *
+     * @return {@code true} if empty, @{code false} otherwise.
+     */
+    public boolean isObjectTablesEmpty() {
+        return nativeIsEmpty(nativePtr);
+    }
+
 /*
  * TODO: Find a way to release the malloc'ed native memory automatically
 
@@ -293,31 +266,25 @@ public String toJson() {
         return nativeToJson(nativePtr);
     }
 
-    protected native String nativeToJson(long nativeGroupPtr);
-
     public String toString() {
         return nativeToString(nativePtr);
     }
 
-    protected native void nativeCommit(long nativeGroupPtr);
 
+    protected native long createNative();
+    protected native long createNative(String filepath, int value);
+    protected native long createNative(byte[] data);
+    protected native long createNative(ByteBuffer buffer);
+    protected static native void nativeClose(long nativeGroupPtr);
+    protected native long nativeSize(long nativeGroupPtr);
+    protected native String nativeGetTableName(long nativeGroupPtr, int index);
+    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
+    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray) throws IOException;
+    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
+    protected native long nativeLoadFromMem(byte[] buffer);
+    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
+    protected native String nativeToJson(long nativeGroupPtr);
+    protected native void nativeCommit(long nativeGroupPtr);
     protected native String nativeToString(long nativeGroupPtr);
-
-    public boolean equals(Object other) {
-        if (other == null)
-            return false;
-        if (other == this)
-            return true;
-        if (!(other instanceof Group))
-            return false;
-
-        Group otherGroup = (Group) other;
-        return nativeEquals(nativePtr, otherGroup.nativePtr);
-    }
-
-    protected native boolean nativeEquals(long nativeGroupPtr, long nativeGroupToComparePtr);
-
-    private void throwImmutable() {
-        throw new IllegalStateException("Objects cannot be changed outside a transaction; see beginTransaction() for details.");
-    }
+    protected native boolean nativeIsEmpty(long nativeGroupPtr);
 }
diff --git a/realm/src/main/java/io/realm/internal/IOException.java b/realm/realm-library/src/main/java/io/realm/internal/IOException.java
similarity index 100%
rename from realm/src/main/java/io/realm/internal/IOException.java
rename to realm/realm-library/src/main/java/io/realm/internal/IOException.java
diff --git a/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java b/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java
new file mode 100644
index 0000000000..2df4ead5d8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/IdentitySet.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import java.util.IdentityHashMap;
+
+/**
+ * Identity based Set, that guarantee store & retrieve in O(1)
+ * without a huge overhead in space complexity.
+ */
+public class IdentitySet<K> extends IdentityHashMap<K,Integer> {
+    private final static Integer PLACE_HOLDER = 0;
+
+    public void add(K key)  {
+        put(key, PLACE_HOLDER);
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/IllegalMixedTypeException.java b/realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
similarity index 100%
rename from realm/src/main/java/io/realm/internal/IllegalMixedTypeException.java
rename to realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
diff --git a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
similarity index 72%
rename from realm/src/main/java/io/realm/internal/ImplicitTransaction.java
rename to realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
index 4dbb442dd4..55d55c4ad0 100644
--- a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
@@ -25,23 +25,38 @@ public ImplicitTransaction(Context context, SharedGroup sharedGroup, long native
         parent = sharedGroup;
     }
 
+    /**
+     * Positions the shared group to the latest version.
+     */
     public void advanceRead() {
         assertNotClosed();
         parent.advanceRead();
     }
 
+    /**
+     * Positions the shared group at the specified version.
+     *
+     * @param versionID version of the shared group.
+     */
+    public void advanceRead(SharedGroup.VersionID versionID) {
+        assertNotClosed();
+        parent.advanceRead(versionID);
+    }
+
     public void promoteToWrite() {
         assertNotClosed();
-        if (immutable) {
-            immutable = false;
-            parent.promoteToWrite();
-        } else {
+        if (!immutable) {
             throw new IllegalStateException("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().");
         }
+        immutable = false;
+        parent.promoteToWrite();
     }
 
     public void commitAndContinueAsRead() {
         assertNotClosed();
+        if (immutable) {
+            throw new IllegalStateException("Not inside a transaction.");
+        }
         parent.commitAndContinueAsRead();
         immutable = true;
     }
@@ -53,12 +68,11 @@ public void endRead() {
 
     public void rollbackAndContinueAsRead() {
         assertNotClosed();
-        if (!immutable) {
-            parent.rollbackAndContinueAsRead();
-            immutable = true;
-        } else {
-            throw new IllegalStateException("Cannot cancel a non-write transaction.");
+        if (immutable) {
+            throw new IllegalStateException("Not inside a transaction.");
         }
+        parent.rollbackAndContinueAsRead();
+        immutable = true;
     }
 
     private void assertNotClosed() {
@@ -68,12 +82,11 @@ private void assertNotClosed() {
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the absolute path to the Realm file backing this transaction.
      */
     public String getPath() {
         return parent.getPath();
     }
 
-
     protected void finalize() {} // Nullify the actions of Group.finalize()
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
new file mode 100644
index 0000000000..cb708bf4ac
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.Date;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Row wrapper that stubs all access with IllegalStateExceptions except for isAttached. This can be used instead of
+ * adding null checks everywhere when the underlying Row accessor in Realm's underlying storage engine is no longer
+ * available.
+ */
+public enum InvalidRow implements Row {
+    INSTANCE;
+
+    @Override
+    public long getColumnCount() {
+        throw getStubException();
+    }
+
+    @Override
+    public String getColumnName(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public long getColumnIndex(String columnName) {
+        throw getStubException();
+    }
+
+    @Override
+    public RealmFieldType getColumnType(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Table getTable() {
+        throw getStubException();
+    }
+
+    @Override
+    public long getIndex() {
+        throw getStubException();
+    }
+
+    @Override
+    public long getLong(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean getBoolean(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public float getFloat(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public double getDouble(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Date getDate(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public String getString(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public byte[] getBinaryByteArray(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Mixed getMixed(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public RealmFieldType getMixedType(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public long getLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public LinkView getLinkList(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setLong(long columnIndex, long value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setBoolean(long columnIndex, boolean value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setFloat(long columnIndex, float value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setDouble(long columnIndex, double value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setDate(long columnIndex, Date date) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setString(long columnIndex, String value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setBinaryByteArray(long columnIndex, byte[] data) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setMixed(long columnIndex, Mixed data) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setLink(long columnIndex, long value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void nullifyLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean isNull(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setNull(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean isAttached() {
+        return false;
+    }
+
+    @Override
+    public boolean hasColumn(String fieldName) {
+        throw getStubException();
+    }
+
+    private RuntimeException getStubException() {
+        return new IllegalStateException("Object is no longer managed by Realm. Has it been deleted?");
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Keep.java b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
new file mode 100644
index 0000000000..45f86dc70a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark the classes to be kept by ProGuard/DexGuard.
+ * The ProGuard configuration must have '-keep class io.realm.internal.Keep'
+ * and '-keep @io.realm.internal.Keep class *'.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.TYPE)
+public @interface Keep {
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
new file mode 100644
index 0000000000..98887cdcde
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.RealmFieldType;
+import java.lang.ref.ReferenceQueue;
+
+/**
+ * The LinkView class represents a core {@link RealmFieldType#LIST}.
+ */
+public class LinkView extends NativeObject {
+
+    private static class LinkViewReference extends NativeObjectReference {
+
+        public LinkViewReference(NativeObject referent, ReferenceQueue<? super NativeObject> referenceQueue) {
+            super(referent, referenceQueue);
+        }
+
+        @Override
+        protected void cleanup() {
+            nativeClose(nativePointer);
+        }
+    }
+
+    private final Context context;
+    final Table parent;
+    final long columnIndexInParent;
+
+    public LinkView(Context context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
+        this.context = context;
+        this.parent = parent;
+        this.columnIndexInParent = columnIndexInParent;
+        this.nativePointer = nativeLinkViewPtr;
+
+        context.cleanNativeReferences();
+        context.rowReferences.put(new LinkViewReference(this, context.referenceQueue), Context.NATIVE_REFERENCES_VALUE);
+    }
+
+    /**
+     * Returns a non-checking {@link Row}. Incorrect use of this Row will cause a hard Realm Core crash (SIGSEGV).
+     * Only use this method if you are sure that input parameters are valid, otherwise use {@link #getCheckedRow(long)}
+     * which will throw appropriate exceptions if used incorrectly.
+     *
+     * @param index the index of row to fetch.
+     * @return the unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRow(long index) {
+        return UncheckedRow.getByRowIndex(context, this, index);
+    }
+
+    /**
+     * Returns a wrapper for {@link Row} access. All access will be error checked at the JNI layer and will throw an
+     * appropriate {@link RuntimeException} if used incorrectly.
+     *
+     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
+     *
+     * @param index the index of row to fetch.
+     * @return the safe row wrapper object.
+     */
+    public CheckedRow getCheckedRow(long index) {
+        return CheckedRow.get(context, this, index);
+    }
+
+    public long getTargetRowIndex(long pos) {
+        return nativeGetTargetRowIndex(nativePointer, pos);
+    }
+
+    public void add(long rowIndex) {
+        checkImmutable();
+        nativeAdd(nativePointer, rowIndex);
+    }
+
+    public void insert(long pos, long rowIndex) {
+        checkImmutable();
+        nativeInsert(nativePointer, pos, rowIndex);
+    }
+
+    public void set(long pos, long rowIndex) {
+        checkImmutable();
+        nativeSet(nativePointer, pos, rowIndex);
+    }
+
+    public void move(long oldPos, long newPos) {
+        checkImmutable();
+        nativeMove(nativePointer, oldPos, newPos);
+    }
+
+    public void remove(long pos) {
+        checkImmutable();
+        nativeRemove(nativePointer, pos);
+    }
+
+    public void clear() {
+        checkImmutable();
+        nativeClear(nativePointer);
+    }
+
+    public boolean contains(long tableRowIndex) {
+        long index = nativeFind(nativePointer, tableRowIndex);
+        return (index != TableOrView.NO_MATCH);
+    }
+
+    public long size() {
+        return nativeSize(nativePointer);
+    }
+
+    public boolean isEmpty() {
+        return nativeIsEmpty(nativePointer);
+    }
+
+    public TableQuery where() {
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        this.context.executeDelayedDisposal();
+        long nativeQueryPtr = nativeWhere(nativePointer);
+        try {
+            return new TableQuery(this.context, this.parent, nativeQueryPtr);
+        } catch (RuntimeException e) {
+            TableQuery.nativeClose(nativeQueryPtr);
+            throw e;
+        }
+    }
+
+    public boolean isAttached() {
+        return nativeIsAttached(nativePointer);
+    }
+
+    /**
+     * Returns the {@link Table} which all links point to.
+     */
+    public Table getTable() {
+        return parent;
+    }
+
+    /**
+     * Remove all target rows pointed to by links in this link view, and clear this link view.
+     */
+    public void removeAllTargetRows() {
+        checkImmutable();
+        nativeRemoveAllTargetRows(nativePointer);
+    }
+
+    public Table getTargetTable() {
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        long nativeTablePointer = nativeGetTargetTable(nativePointer);
+        try {
+            // Copy context reference from parent
+            return new Table(context, this.parent, nativeTablePointer);
+        } catch (RuntimeException e) {
+            Table.nativeClose(nativeTablePointer);
+            throw e;
+        }
+    }
+
+    private void checkImmutable() {
+        if (parent.isImmutable()) {
+            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+        }
+    }
+
+    private static native void nativeClose(long nativeLinkViewPtr);
+    native long nativeGetRow(long nativeLinkViewPtr, long pos);
+    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
+    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
+    private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
+    private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
+    private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
+    private native void nativeRemove(long nativeLinkViewPtr, long pos);
+    private native void nativeClear(long nativeLinkViewPtr);
+    private native long nativeSize(long nativeLinkViewPtr);
+    private native boolean nativeIsEmpty(long nativeLinkViewPtr);
+    protected native long nativeWhere(long nativeLinkViewPtr);
+    private native boolean nativeIsAttached(long nativeLinkViewPtr);
+    private native long nativeFind(long nativeLinkViewPtr, long targetRowIndex);
+    private native void nativeRemoveAllTargetRows(long nativeLinkViewPtr);
+    private native long nativeGetTargetTable(long nativeLinkViewPtr);
+}
diff --git a/realm/src/main/java/io/realm/internal/Mixed.java b/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
similarity index 71%
rename from realm/src/main/java/io/realm/internal/Mixed.java
rename to realm/realm-library/src/main/java/io/realm/internal/Mixed.java
index 4e795c6106..af103c077b 100644
--- a/realm/src/main/java/io/realm/internal/Mixed.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
@@ -17,13 +17,18 @@
 package io.realm.internal;
 
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Date;
 
+import io.realm.RealmFieldType;
+
 public class Mixed {
 
     public static final int BINARY_TYPE_BYTE_ARRAY = 0;
     public static final int BINARY_TYPE_BYTE_BUFFER = 1;
 
+    private Object value;
+
     public Mixed(long value) {
         this.value = value;
     }
@@ -36,9 +41,9 @@ public Mixed(double value) {
         this.value = value;
     }
 
-    public Mixed(ColumnType columnType) {
+    public Mixed(RealmFieldType columnType) {
         // It's actually ok to call with any columnType - it will however be assumed to be a ColumnTypeTable.
-        if (columnType == null  || columnType == ColumnType.TABLE) {
+        if (columnType == null  || columnType == RealmFieldType.UNSUPPORTED_TABLE) {
             throw new AssertionError();
         }
         this.value = null;
@@ -68,71 +73,56 @@ public Mixed(byte[] value) {
         this.value = value;
     }
 
-    public boolean equals(Object second) {
-        if (second == null)
-            return false;
-        if (!(second instanceof Mixed))
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
             return false;
-        Mixed secondMixed = (Mixed) second;
-        if (value == null) {
-            if (secondMixed.value == null) {
-                return true;
-            } else {
-                return false;
-            }
         }
-        if (!getType().equals(secondMixed.getType())) {
+
+        Mixed mixed = (Mixed) obj;
+
+        if (value.getClass() != mixed.value.getClass()) {
             return false;
         }
+
         if (value instanceof byte[]) {
-            if (!(secondMixed.value instanceof byte[])) {
-                return false;
-            }
-            byte[] firstBytes = (byte[]) value;
-            byte[] secondBytes = (byte[]) secondMixed.value;
-            if (firstBytes.length != secondBytes.length) {
-                return false;
-            }
-            for (int i = 0; i < firstBytes.length; i++) {
-                if (firstBytes[i] != secondBytes[i]) {
-                    return false;
-                }
-            }
-            return true;
+            return Arrays.equals((byte[]) value, (byte[]) mixed.value);
         }
         if (value instanceof ByteBuffer) {
-            ByteBuffer firstByteBuffer = (ByteBuffer) value;
-            ByteBuffer secondByteBuffer = (ByteBuffer) secondMixed.value;
-            if (firstByteBuffer.capacity() != secondByteBuffer.capacity()) {
-                return false;
-            }
-            for (int i = 0; i < firstByteBuffer.capacity(); i++) {
-                if (firstByteBuffer.get(i) != secondByteBuffer.get(i))
-                    return false;
-            }
-            return true;
+            return ((ByteBuffer) value).compareTo((ByteBuffer) mixed.value) == 0;
         }
-        return this.value.equals(secondMixed.value);
+        return value.equals(mixed.value);
     }
 
-    public ColumnType getType() {
+    @Override
+    public int hashCode() {
+        if (value instanceof byte[]) {
+            return Arrays.hashCode((byte[]) value);
+        }
+        return value.hashCode();
+    }
+
+    public RealmFieldType getType() {
         if (value == null) {
-            return ColumnType.TABLE;
+            return RealmFieldType.UNSUPPORTED_TABLE;
         }
         if (value instanceof String)
-            return ColumnType.STRING;
+            return RealmFieldType.STRING;
         else if (value instanceof Long)
-            return ColumnType.INTEGER;
+            return RealmFieldType.INTEGER;
         else if (value instanceof Float)
-            return ColumnType.FLOAT;
+            return RealmFieldType.FLOAT;
         else if (value instanceof Double)
-            return ColumnType.DOUBLE;
+            return RealmFieldType.DOUBLE;
         else if (value instanceof Date)
-            return ColumnType.DATE;
+            return RealmFieldType.DATE;
         else if (value instanceof Boolean)
-            return ColumnType.BOOLEAN;
+            return RealmFieldType.BOOLEAN;
         else if (value instanceof ByteBuffer || (value instanceof byte[])) {
-            return ColumnType.BINARY;
+            return RealmFieldType.BINARY;
         }
 
         throw new IllegalStateException("Unknown column type!");
@@ -167,38 +157,38 @@ public static Mixed mixedValue(Object value) {
 
     public long getLongValue() {
         if (!(value instanceof Long)) {
-            throw new IllegalMixedTypeException("Can't get a long from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a long from a Mixed containing a " + getType());
         }
-        return ((Long)value).longValue();
+        return (Long) value;
     }
 
     public boolean getBooleanValue() {
         if (!(value instanceof Boolean))
-            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containg a " + getType());
-        return ((Boolean) value).booleanValue();
+            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containing a " + getType());
+        return (Boolean) value;
     }
 
     public float getFloatValue() {
         if (!(value instanceof Float))
-            throw new IllegalMixedTypeException("Can't get a float from a Mixed containg a " + getType());
-        return ((Float) value).floatValue();
+            throw new IllegalMixedTypeException("Can't get a float from a Mixed containing a " + getType());
+        return (Float) value;
     }
 
     public double getDoubleValue() {
         if (!(value instanceof Double))
-            throw new IllegalMixedTypeException("Can't get a double from a Mixed containg a " + getType());
-        return ((Double) value).doubleValue();
+            throw new IllegalMixedTypeException("Can't get a double from a Mixed containing a " + getType());
+        return (Double) value;
     }
 
     public String getStringValue() {
         if (!(value instanceof String))
-            throw new IllegalMixedTypeException("Can't get a String from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a String from a Mixed containing a " + getType());
         return (String) value;
     }
 
     public Date getDateValue() {
         if (!(value instanceof Date)) {
-            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containing a " + getType());
         }
         return (Date) value;
     }
@@ -209,14 +199,14 @@ protected long getDateTimeValue() {
 
     public ByteBuffer getBinaryValue() {
         if (!(value instanceof ByteBuffer)) {
-            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containing a " + getType());
         }
         return (ByteBuffer) value;
     }
 
     public byte[] getBinaryByteArray() {
         if (!(value instanceof byte[])) {
-            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containing a " + getType());
         }
         return (byte[]) value;
     }
@@ -231,14 +221,12 @@ public int getBinaryType() {
         return -1;
     }
 
-    private Object value;
-
     public Object getValue() {
         return value;
     }
 
     public String getReadableValue() {
-        ColumnType type = getType();
+        RealmFieldType type = getType();
         try {
             switch (type) {
             case BINARY:
@@ -255,12 +243,12 @@ public String getReadableValue() {
                 return String.valueOf(getLongValue());
             case STRING:
                 return String.valueOf(getStringValue());
-            case TABLE:
+            case UNSUPPORTED_TABLE:
                 return "Subtable";
-            case MIXED:
+            case UNSUPPORTED_MIXED:
                 break; // error
             }
-        } catch (Exception e) {
+        } catch (Exception ignored) {
         }
         return "ERROR";
     }
diff --git a/realm/src/main/java/io/realm/internal/RealmObjectProxy.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
similarity index 70%
rename from realm/src/main/java/io/realm/internal/RealmObjectProxy.java
rename to realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
index a2b2dccb97..cad7f390cc 100644
--- a/realm/src/main/java/io/realm/internal/RealmObjectProxy.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
@@ -17,10 +17,10 @@
 package io.realm.internal;
 
 /**
- * Empty interface making it easy to determine if an object is the generated RealmProxy class or the original
- * class.
- *
- * Ideally all the static methods was also present here, but that is not supported before Java 8.
+ * This abstract class represents a native object from core.
+ * It specifies the operations common to all such objects.
+ * All Java classes wrapping a core class should extend NativeObject.
  */
-public interface RealmObjectProxy {
+public abstract class NativeObject {
+    long nativePointer;
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
new file mode 100644
index 0000000000..5989fbf60b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObjectReference.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+
+/**
+ * This class is used for holding the reference to the native pointers present in NativeObjects.
+ * This is required as phantom references cannot access the original objects for this value.
+ */
+public abstract class NativeObjectReference extends PhantomReference<NativeObject> {
+
+    // The pointer to the native object to be handled
+    protected final long nativePointer;
+
+    public NativeObjectReference(NativeObject referent, ReferenceQueue<? super NativeObject> referenceQueue) {
+        super(referent, referenceQueue);
+        nativePointer = referent.nativePointer;
+    }
+
+    /**
+     * This method is called when this reference gets cleared.
+     * Subclasses should implement this method to dealloc the native pointer.
+     */
+    protected abstract void cleanup();
+
+    @Override
+    public void clear() {
+        cleanup();
+        super.clear();
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/OutOfMemoryError.java b/realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java
similarity index 90%
rename from realm/src/main/java/io/realm/internal/OutOfMemoryError.java
rename to realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java
index 21e6f1039e..88b664f797 100644
--- a/realm/src/main/java/io/realm/internal/OutOfMemoryError.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java
@@ -18,12 +18,11 @@
 
 
 /**
- * Can be thrown when realm runs out of memory.
- * A JVM that catches this will be able to cleanup, e.g. release other resources
- * to avoid also running out of memory.
- *
+ * Can be thrown when Realm runs out of memory.
+ * A JVM that catches this will be able to cleanup, e.g. release other resources to avoid also running out of memory.
  */
 @SuppressWarnings("serial")
+@Keep
 public class OutOfMemoryError extends Error {
 
     public OutOfMemoryError() {
diff --git a/realm/src/main/java/io/realm/internal/ReadTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
similarity index 100%
rename from realm/src/main/java/io/realm/internal/ReadTransaction.java
rename to realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
diff --git a/realm/src/main/java/io/realm/internal/RealmCore.java b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
similarity index 57%
rename from realm/src/main/java/io/realm/internal/RealmCore.java
rename to realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
index 6c02c63a75..78deddf9b5 100644
--- a/realm/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
@@ -16,124 +16,49 @@
 
 package io.realm.internal;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
+import android.content.Context;
+
+import com.getkeepsafe.relinker.ReLinker;
+
 import java.io.File;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.lang.ref.WeakReference;
 import java.lang.reflect.Field;
-import java.nio.ByteBuffer;
 import java.util.Locale;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Utility methods for Realm Core.
  */
 public class RealmCore {
 
-///*
     private static final String FILE_SEP = File.separator;
     private static final String PATH_SEP = File.pathSeparator;          // On Windows ";"
     private static final String BINARIES_PATH = "lib" + PATH_SEP + ".." + FILE_SEP + "lib";
     private static final String JAVA_LIBRARY_PATH = "java.library.path";
-//*/
 
-    private static AtomicBoolean libraryIsLoaded = new AtomicBoolean(false);
+    private static volatile boolean libraryIsLoaded = false;
 
-/*
-    private static String getJniFileName()
-    {
-        String os = System.getProperty("os.name").toLowerCase();
-        if (os.indexOf("win") >= 0)
-            return "realm_jni32.dll or realm_jni64.dll";
-        if (os.indexOf("mac") >= 0)
-            return "librealm-jni.jnilib";
-        if (os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0 || os.indexOf("sunos") >= 0)
-            return "librealm-jni.so";
-        return "realm-jni";
-    }
-*/
-
-    public static boolean osIsWindows()
-    {
+    public static boolean osIsWindows() {
         String os = System.getProperty("os.name").toLowerCase(Locale.getDefault());
-        return (os.indexOf("win") >= 0);
+        return (os.contains("win"));
     }
 
-    public static byte[] serialize(Serializable value) {
-        try {
-            ByteArrayOutputStream mem = new ByteArrayOutputStream();
-            ObjectOutputStream output = new ObjectOutputStream(mem);
-            output.writeObject(value);
-            output.close();
-            return mem.toByteArray();
-        } catch (Exception e) {
-            throw new RuntimeException("Cannot serialize the object!", e);
-        }
-    }
-
-    public static Serializable deserialize(ByteBuffer buf) {
-        return deserialize(buf.array());
-    }
-
-    public static Serializable deserialize(byte[] value) {
-        try {
-            ByteArrayInputStream mem = new ByteArrayInputStream(value);
-            ObjectInputStream output = new ObjectInputStream(mem);
-            Object obj = output.readObject();
-            output.close();
-            return (Serializable) obj;
-        } catch (Exception e) {
-            throw new RuntimeException("Cannot deserialize the object!", e);
-        }
-    }
-/*
-    public static void print(String caption, AbstractCursor<?> cursor) {
-        System.out.println(caption + ": " + cursor);
-    }
-*/
     /**
-     * Guarantee gc is done.
+     * Loads the .so file. This method is useful for static blocks as it does not rely on access to a Context.
+     *
+     * Although loadLibrary is synchronized internally from AOSP 4.3, for compatibility reasons,
+     * KEEP synchronized here for old devices!
      */
-    public static void gcGuaranteed(){
-        Object obj = new Object();
-        WeakReference<Object> ref = new WeakReference<Object>(obj);
-        obj = null;
-        while(ref.get()!=null)
-            System.gc();
-    }
-
-    /**
-     * Guarantee gc is done after JVM shutdown.
-     */
-    public static void gcOnExit(){
-        Runtime.getRuntime().addShutdownHook(new Thread(){
-            @Override
-            public void run(){
-                gcGuaranteed();
-            }
-        });
-    }
-
-    private static void init() {
-        // Guarantee gc is done on JVM exit to clean up any native resources
-        gcOnExit();
-    }
-
-    public static void loadLibrary() {
-        if (libraryIsLoaded.get())
-            // only load library once
+    public static synchronized void loadLibrary() {
+        if (libraryIsLoaded) {
+            // The java native should ensure only load the lib once, but we met some problems before.
+            // So keep the flag.
             return;
+        }
 
-        init();
-
-        String jnilib;
         if (osIsWindows()) {
-            jnilib = loadLibraryWindows();
+            loadLibraryWindows();
         }
         else {
+            String jnilib;
             String debug = System.getenv("REALM_JAVA_DEBUG");
             if (debug == null || debug.isEmpty()) {
                 jnilib = "realm-jni";
@@ -143,11 +68,28 @@ public static void loadLibrary() {
             }
             System.loadLibrary(jnilib);
         }
-        libraryIsLoaded.set(true);
+        libraryIsLoaded = true;
 
         Version.coreLibVersionCompatible(true);
     }
 
+    /**
+     * Loads the .so file. Typically, the .so file is installed and can be found by System.loadLibrary() but
+     * can be damaged or missing. This happens for the Android installer, especially when apps are installed
+     * through other means than the official Play store. In this case, the .so file can be found in the .apk.
+     * In other to access the .apk, an {@link android.content.Context} must be provided.
+     *
+     * Although loadLibrary is synchronized internally from AOSP 4.3, for compatibility reasons,
+     * KEEP synchronized here for old devices!
+     */
+    public static synchronized void loadLibrary(Context context) {
+        if (libraryIsLoaded) {
+            return;
+        }
+        ReLinker.loadLibrary(context, "realm-jni");
+        libraryIsLoaded = true;
+    }
+
     private static String loadLibraryWindows() {
 ///*
         try {
@@ -163,8 +105,7 @@ private static String loadLibraryWindows() {
         jnilib = loadCorrectLibrary("realm_jni32d", "realm_jni64d");
         if (jnilib != null) {
             System.out.println("!!! Realm debug version loaded. !!!\n");
-        }
-        else {
+        } else {
             jnilib = loadCorrectLibrary("realm_jni32", "realm_jni64");
             if (jnilib == null) {
                 System.err.println("Searched java.library.path=" + System.getProperty("java.library.path"));
@@ -180,13 +121,12 @@ private static String loadCorrectLibrary(String... libraryCandidateNames) {
             try {
                 System.loadLibrary(libraryCandidateName);
                 return libraryCandidateName;
-            } catch (Throwable e) {
+            } catch (Throwable ignored) {
             }
         }
         return null;
     }
 
-// /*
     public static void addNativeLibraryPath(String path) {
         try {
             String libraryPath = System.getProperty(JAVA_LIBRARY_PATH) + PATH_SEP + path + PATH_SEP;
@@ -197,11 +137,10 @@ public static void addNativeLibraryPath(String path) {
     }
 
     // Hack for having a cross platform location for the lib:
-    // The Classloader has a static field (sys_paths) that contains the paths.
+    // The ClassLoader has a static field (sys_paths) that contains the paths.
     // If that field is set to null, it is initialized automatically.
     // Therefore forcing that field to null will result into the reevaluation of the library path
     // as soon as loadLibrary() is called
-
     private static void resetLibraryPath() {
         try {
             // reset the library path (a hack)
@@ -212,5 +151,4 @@ private static void resetLibraryPath() {
             throw new RuntimeException("Cannot reset the library path!", e);
         }
     }
-// */
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
new file mode 100644
index 0000000000..3de17bb722
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.RealmObject;
+
+/**
+ * Empty interface making it easy to determine if an object is the generated RealmProxy class or the original class.
+ *
+ * Ideally all the static methods was also present here, but that is not supported before Java 8.
+ */
+public interface RealmObjectProxy {
+
+    /**
+     * Tuple class for saving meta data about a cached RealmObject.
+     */
+    class CacheData<E extends RealmObject> {
+        public int minDepth;
+        public final E object;
+
+        public CacheData(int minDepth, E object) {
+            this.minDepth = minDepth;
+            this.object = object;
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
new file mode 100644
index 0000000000..636d45e3c0
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.util.JsonReader;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.Realm;
+import io.realm.RealmObject;
+import io.realm.exceptions.RealmException;
+
+/**
+ * Superclass for the RealmProxyMediator class'. This class contain all static methods introduced by the annotation
+ * processor as part of the RealmProxy classes.
+ *
+ * Classes extending this class act as binders between the static methods inside each RealmProxy and the code at
+ * runtime. We cannot rely on using reflection as the RealmProxies are generated by the annotation processor before
+ * ProGuard is run. So after ProGuard has run there is a mismatch between the name of the RealmProxy and the original
+ * RealmObject class.
+ */
+public abstract class RealmProxyMediator {
+
+    /**
+     * Creates the backing table in Realm for the given RealmObject class.
+     *
+     * @param clazz the {@link RealmObject} model class to create backing table for.
+     * @param transaction the read transaction for the Realm to create table in.
+     */
+    public abstract Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+
+    /**
+     * Validates the backing table in Realm for the given RealmObject class.
+     *
+     * @param clazz the {@link RealmObject} model class to validate.
+     * @param transaction the read transaction for the Realm to validate against.
+     * @return the field indices map.
+     */
+    public abstract ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+
+    /**
+     * Returns a map of non-obfuscated object field names to their internal Realm name.
+     *
+     * @param clazz the {@link RealmObject} class reference.
+     * @return The simple name of an RealmObject class (before it has been obfuscated).
+     */
+    public abstract List<String> getFieldNames(Class<? extends RealmObject> clazz);
+
+    /**
+     * Returns the name that Realm should use for all it's internal tables. This is the un-obfuscated name of the
+     * class.
+     *
+     * @param clazz the {@link RealmObject} class reference.
+     * @return the simple name of an RealmObject class (before it has been obfuscated).
+     * @throws java.lang.NullPointerException if null is given as argument.
+     */
+    public abstract String getTableName(Class<? extends RealmObject> clazz);
+
+    /**
+     * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
+     *
+     * @param clazz the {@link RealmObject} to create {@link RealmObjectProxy} for.
+     * @param columnInfo the {@link ColumnInfo} object for the RealmObject class of {@code E}.
+     * @return created {@link RealmObjectProxy} object.
+     */
+    public abstract <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo);
+
+    /**
+     * Returns the list of RealmObject classes that can be saved in this Realm.
+     *
+     * @return list of class references to RealmObject classes. Empty list if no RealmObjects are supported.
+     */
+    public abstract Set<Class<? extends RealmObject>> getModelClasses();
+
+    /**
+     * Copy a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied any
+     * changes to the original object will not be persisted.
+     *
+     * @param object the object to copy properties from.
+     * @param update {@code true} if object has a primary key and should try to update already existing data,
+     * {@code false} otherwise.
+     * @param cache the cache for mapping between standalone objects and their {@link RealmObjectProxy} representation.
+     * @return the managed Realm object.
+     */
+    public abstract <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache);
+
+    /**
+     * Creates or updates a {@link RealmObject} using the provided JSON data.
+     *
+     * @param clazz the type of {@link RealmObject}
+     * @param realm the reference to {@link Realm} where to create the object.
+     * @param json the JSON data
+     * @param update {@code true} if Realm should try to update a existing object. This requires that the RealmObject 
+     *               class has a @PrimaryKey.
+     * @return RealmObject that has been created or updated.
+     * @throws JSONException if the JSON mapping doesn't match the expected class.
+     */
+    public abstract <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
+
+    /**
+     * Creates new {@link RealmObject} based on a JSON input stream.
+     *
+     * @param clazz the type of {@link RealmObject}
+     * @param realm the reference to Realm where to create the object.
+     * @param reader the reference to the InputStream containing the JSON data.
+     * @return the created {@link RealmObject}
+     * @throws IOException if an error occurs with the input stream.
+     */
+    public abstract <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
+
+    /**
+     * Creates a deep standalone copy of a RealmObject. This is a deep copy so all links will be copied as well.
+     * The depth can be restricted to a maximum depth after which all links will be turned into null values instead.
+     *
+     * @param realmObject RealmObject to copy. It must be a valid object.
+     * @param maxDepth restrict the depth of the copy to this level. The root object is depth {@code 0}.
+     * @param cache cache used to make sure standalone objects are reused correctly.
+     * @return a standalone copy of the given object.
+     */
+    public abstract <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache);
+
+    /**
+     * Returns whether Realm transformer has been applied or not. Subclasses of this class are
+     * created by the annotation processor and the Realm transformer will add an override of
+     * this method that always return {@code true} if the transform was successful.
+     *
+     * @return {@code true} if Realm transformer was applied, {@code false} otherwise.
+     */
+    public boolean transformerApplied() {
+        return false;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof RealmProxyMediator)) {
+            return false;
+        }
+        RealmProxyMediator other = (RealmProxyMediator) o;
+        return getModelClasses().equals(other.getModelClasses());
+    }
+
+    @Override
+    public int hashCode() {
+        return getModelClasses().hashCode();
+    }
+
+    protected static void checkClass(Class<? extends RealmObject> clazz) {
+        if (clazz == null) {
+            throw new NullPointerException("A class extending RealmObject must be provided");
+        }
+    }
+
+    protected static RealmException getMissingProxyClassException(Class<? extends RealmObject> clazz) {
+        return new RealmException(clazz + " is not part of the schema for this Realm.");
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
new file mode 100644
index 0000000000..d61a0bc531
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.Date;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Interface for Row objects that act as wrappers around the Realm Core Row object.
+ */
+public interface Row {
+
+    long getColumnCount();
+
+    /**
+     * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
+     *
+     * @param columnIndex the column index.
+     * @return the name of the column.
+     */
+    String getColumnName(long columnIndex);
+
+    /**
+     * Returns the 0-based index of a column based on the name.
+     *
+     * @param columnName column name
+     * @return the index, {@code -1} if not found
+     */
+    long getColumnIndex(String columnName);
+
+    /**
+     * Gets the type of a column identified by the columnIndex.
+     *
+     * @param columnIndex index of the column.
+     * @return the type of the particular column.
+     */
+    RealmFieldType getColumnType(long columnIndex);
+
+    Table getTable();
+
+    long getIndex();
+
+    long getLong(long columnIndex);
+
+    boolean getBoolean(long columnIndex);
+
+    float getFloat(long columnIndex);
+
+    double getDouble(long columnIndex);
+
+    Date getDate(long columnIndex);
+
+    String getString(long columnIndex);
+
+    byte[] getBinaryByteArray(long columnIndex);
+
+    Mixed getMixed(long columnIndex);
+
+    RealmFieldType getMixedType(long columnIndex);
+
+    long getLink(long columnIndex);
+
+    boolean isNullLink(long columnIndex);
+
+    LinkView getLinkList(long columnIndex);
+
+    void setLong(long columnIndex, long value);
+
+    void setBoolean(long columnIndex, boolean value);
+
+    void setFloat(long columnIndex, float value);
+
+    void setDouble(long columnIndex, double value);
+
+    void setDate(long columnIndex, Date date);
+
+    void setString(long columnIndex, String value);
+
+    void setBinaryByteArray(long columnIndex, byte[] data);
+
+    void setMixed(long columnIndex, Mixed data);
+
+    void setLink(long columnIndex, long value);
+
+    void nullifyLink(long columnIndex);
+
+    boolean isNull(long columnIndex);
+
+    void setNull(long columnIndex);
+
+    /**
+     * Checks if the row is still valid.
+     *
+     * @return {@code true} if the row is still valid and attached to the underlying data. {@code false} otherwise.
+     */
+    boolean isAttached();
+
+    /**
+     * Returns {@code true} if the field name exists.
+     *
+     * @param fieldName Field name to check.
+     * @return {@code true} if field name exists, {@code false} otherwise.
+     */
+    boolean hasColumn(String fieldName);
+
+    Row EMPTY_ROW = new Row() {
+        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded, make sure the instance" +
+                " is loaded by calling RealmObject.isLoaded().";
+
+        @Override
+        public long getColumnCount() {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public String getColumnName(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public long getColumnIndex(String columnName) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public RealmFieldType getColumnType(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public Table getTable() {
+            return null;
+        }
+
+        @Override
+        public long getIndex() {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public long getLong(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public boolean getBoolean(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public float getFloat(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public double getDouble(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public Date getDate(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public String getString(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public byte[] getBinaryByteArray(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public Mixed getMixed(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public RealmFieldType getMixedType(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public long getLink(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public boolean isNullLink(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public boolean isNull(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setNull(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public LinkView getLinkList(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setLong(long columnIndex, long value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setBoolean(long columnIndex, boolean value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setFloat(long columnIndex, float value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setDouble(long columnIndex, double value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setDate(long columnIndex, Date date) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setString(long columnIndex, String value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setBinaryByteArray(long columnIndex, byte[] data) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void setMixed(long columnIndex, Mixed data) {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void setLink(long columnIndex, long value) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public void nullifyLink(long columnIndex) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+
+        @Override
+        public boolean isAttached() {
+            return false;
+        }
+
+        @Override
+        public boolean hasColumn(String fieldName) {
+            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
+        }
+    };
+}
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
similarity index 68%
rename from realm/src/main/java/io/realm/internal/SharedGroup.java
rename to realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
index fc21040721..8868f43d31 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
@@ -18,12 +18,19 @@
 
 import java.io.Closeable;
 import java.io.IOError;
-import java.lang.*;
 
 import io.realm.exceptions.RealmIOException;
 
 public class SharedGroup implements Closeable {
 
+    public static final boolean IMPLICIT_TRANSACTION = true;
+    public static final boolean EXPLICIT_TRANSACTION = false;
+
+    private static final boolean CREATE_FILE_YES = false;
+    private static final boolean CREATE_FILE_NO = true;
+    private static final boolean ENABLE_REPLICATION = true;
+    private static final boolean DISABLE_REPLICATION = false;
+
     private final String path;
     private long nativePtr;
     private long nativeReplicationPtr;
@@ -31,10 +38,6 @@
     private boolean activeTransaction;
     private final Context context;
 
-    static {
-        RealmCore.loadLibrary();
-    }
-
     public enum Durability {
         FULL(0),
         MEM_ONLY(1);
@@ -42,7 +45,7 @@
 
         final int value;
 
-        private Durability(int value) {
+        Durability(int value) {
             this.value = value;
         }
     }
@@ -50,65 +53,51 @@ private Durability(int value) {
     public SharedGroup(String databaseFile) {
         context = new Context();
         path = databaseFile;
-        nativePtr = nativeCreate(databaseFile, Durability.FULL.value, false, false, null);
+        nativePtr = nativeCreate(databaseFile, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, null);
         checkNativePtrNotZero();
     }
 
-    public SharedGroup(String databaseFile, boolean enableImplicitTransactions, byte[] key) {
+    public SharedGroup(String canonicalPath, boolean enableImplicitTransactions, Durability durability, byte[] key) {
         if (enableImplicitTransactions) {
-            nativeReplicationPtr = nativeCreateReplication(databaseFile, key);
-            nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr, key);
+            nativeReplicationPtr = nativeCreateReplication(canonicalPath, key);
+            nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr,
+                    durability.value, key);
             implicitTransactionsEnabled = true;
         } else {
-            nativePtr = nativeCreate(databaseFile, Durability.FULL.value, false, false, key);
+            nativePtr = nativeCreate(canonicalPath, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, key);
         }
         context = new Context();
-        path = databaseFile;
+        path = canonicalPath;
         checkNativePtrNotZero();
     }
 
-    public SharedGroup(String databaseFile, Durability durability, byte[] key) {
-        path = databaseFile;
+    public SharedGroup(String canonicalPath, Durability durability, byte[] key) {
+        path = canonicalPath;
         context = new Context();
-        nativePtr = nativeCreate(databaseFile, durability.value, false, false, key);
+        nativePtr = nativeCreate(canonicalPath, durability.value, false, false, key);
         checkNativePtrNotZero();
     }
 
-    public SharedGroup(String databaseFile, Durability durability, boolean fileMustExist) {
-        path = databaseFile;
-        context = new Context();
-        nativePtr = nativeCreate(databaseFile, durability.value, fileMustExist, false, null);
-        checkNativePtrNotZero();
-    }
-
-    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, byte[] key);
-
-    private native long nativeCreateReplication(String databaseFile, byte[] key);
-
     void advanceRead() {
         nativeAdvanceRead(nativePtr);
     }
 
-    private native void nativeAdvanceRead(long nativePtr);
+    void advanceRead(VersionID versionID) {
+        nativeAdvanceReadToVersion(nativePtr, versionID.version, versionID.index);
+    }
 
     void promoteToWrite() {
         nativePromoteToWrite(nativePtr);
     }
 
-    private native void nativePromoteToWrite(long nativePtr);
-
     void commitAndContinueAsRead() {
         nativeCommitAndContinueAsRead(nativePtr);
     }
 
-    private native void nativeCommitAndContinueAsRead(long nativePtr);
-
     void rollbackAndContinueAsRead() {
         nativeRollbackAndContinueAsRead(nativePtr);
     }
 
-    private native void nativeRollbackAndContinueAsRead(long nativePtr);
-
     public ImplicitTransaction beginImplicitTransaction() {
         if (activeTransaction) {
             throw new IllegalStateException(
@@ -120,8 +109,6 @@ public ImplicitTransaction beginImplicitTransaction() {
         return transaction;
     }
 
-    private native long nativeBeginImplicit(long nativePtr);
-
     public WriteTransaction beginWrite() {
         if (activeTransaction)
             throw new IllegalStateException(
@@ -159,7 +146,8 @@ public ReadTransaction beginRead() {
 
     void endRead() {
         if (isClosed())
-            throw new IllegalStateException("Can't endRead() on closed group. ReadTransaction is invalid.");
+            throw new IllegalStateException("Can't endRead() on closed group. " +
+                    "ReadTransaction is invalid.");
         nativeEndRead(nativePtr);
         activeTransaction = false;
     }
@@ -206,8 +194,7 @@ void rollback() {
         activeTransaction = false;
     }
 
-
-    boolean isClosed() {
+    public boolean isClosed() {
         return nativePtr == 0;
     }
 
@@ -222,54 +209,114 @@ public void reserve(long bytes) {
     /**
      * Compacts a shared group. This will block access to the shared group until done.
      *
-     * @return True if compaction succeeded, false otherwise.
+     * @return {@code true} if compaction succeeded, {@code false} otherwise.
      * @throws RuntimeException if using this within either a read or or write transaction.
      */
     public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
-
     /**
      * Returns the absolute path to the file backing this SharedGroup.
      *
-     * @return Absolute path to the Realm file.
+     * @return the canonical path to the Realm file.
      */
     public String getPath() {
         return path;
     }
 
+    private void checkNativePtrNotZero() {
+        if (this.nativePtr == 0) {
+            throw new IOError(new RealmIOException("Realm could not be opened"));
+        }
+    }
+
+    public long getNativePointer () {
+        return nativePtr;
+    }
+
+    public long getNativeReplicationPointer () {
+        return nativeReplicationPtr;
+    }
+
+    public VersionID getVersion () {
+        long[] versionId = nativeGetVersionID (nativePtr);
+        return new VersionID (versionId[0], versionId[1]);
+
+    }
+
+    public static class VersionID implements Comparable<VersionID> {
+        final long version;
+        final long index;
+
+        VersionID(long version, long index) {
+            this.version = version;
+            this.index = index;
+        }
+
+        @Override
+        public int compareTo(VersionID another) {
+            if (version > another.version) {
+                return 1;
+            } else if (version < another.version) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "VersionID{" +
+                    "version=" + version +
+                    ", index=" + index +
+                    '}';
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) return true;
+            if (object == null || getClass() != object.getClass()) return false;
+            if (!super.equals(object)) return false;
+
+            VersionID versionID = (VersionID) object;
+            return (version == versionID.version && index == versionID.index);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode();
+            result = 31 * result + (int) (version ^ (version >>> 32));
+            result = 31 * result + (int) (index ^ (index >>> 32));
+            return result;
+        }
+    }
+
+    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr,
+                                                             int durability, byte[] key);
+    private native long nativeCreateReplication(String databaseFile, byte[] key);
+    private native void nativeCommitAndContinueAsRead(long nativePtr);
+    private native long nativeBeginImplicit(long nativePtr);
     private native String nativeGetDefaultReplicationDatabaseFileName();
 
     private native void nativeReserve(long nativePtr, long bytes);
-
     private native boolean nativeHasChanged(long nativePtr);
-
     private native long nativeBeginRead(long nativePtr);
-
     private native void nativeEndRead(long nativePtr);
-
     private native long nativeBeginWrite(long nativePtr);
-
     private native void nativeCommit(long nativePtr);
-
     private native void nativeRollback(long nativePtr);
-
     private native long nativeCreate(String databaseFile,
                                      int durabilityValue,
-                                     boolean no_create,
+                                     boolean dontCreateFile,
                                      boolean enableReplication,
                                      byte[] key);
-
     private native boolean nativeCompact(long nativePtr);
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0) {
-            throw new IOError(new RealmIOException("Realm could not be opened"));
-        }
-    }
-
     protected static native void nativeClose(long nativePtr);
-
     private native void nativeCloseReplication(long nativeReplicationPtr);
+    private native void nativeRollbackAndContinueAsRead(long nativePtr);
+    private native long[] nativeGetVersionID (long nativePtr);
+    private native void nativeAdvanceRead(long nativePtr);
+    private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index);
+    private native void nativePromoteToWrite(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
new file mode 100644
index 0000000000..49e285b0b6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+
+import io.realm.RealmConfiguration;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * This class wraps access to a given Realm file on a single thread including its {@link SharedGroup} and
+ * {@link ImplicitTransaction}. By nature this means that this class is not thread safe and should only be used from the
+ * thread that created it.
+ *
+ * Realm is a MVCC database (Multiversion concurrency control), which means that multiple versions of the data might
+ * exist in the same file. By default the file is always opened on the latest version and it is possible to advance to
+ * the latest version by calling {@link #advanceRead()}.
+ */
+public class SharedGroupManager implements Closeable {
+
+    private SharedGroup sharedGroup;
+    private ImplicitTransaction transaction;
+
+    /**
+     * Creates a new instance of the FileWrapper for the given configuration on this thread.
+     */
+    public SharedGroupManager(RealmConfiguration configuration) {
+        this.sharedGroup = new SharedGroup(
+                configuration.getPath(),
+                SharedGroup.IMPLICIT_TRANSACTION,
+                configuration.getDurability(),
+                configuration.getEncryptionKey());
+        this.transaction = sharedGroup.beginImplicitTransaction();
+    }
+
+    /**
+     * Closes the underlying {@link SharedGroup} and free any native resources.
+     */
+    @Override
+    public void close() {
+        sharedGroup.close();
+        sharedGroup = null;
+        transaction = null;
+    }
+
+    /**
+     * Checks if the Realm file is accessible.
+     *
+     * @return {@code true} if the file is open and data can be accessed, {@code false} otherwise.
+     */
+    public boolean isOpen() {
+        return sharedGroup != null;
+    }
+
+    /**
+     * Advances the Realm file to the latest version.
+     */
+    public void advanceRead() {
+        transaction.advanceRead();
+    }
+
+    /**
+     * Advances the Realm file to the given version.
+     */
+    public void advanceRead(SharedGroup.VersionID version) {
+        transaction.advanceRead(version);
+    }
+
+
+    // Public because of migrations. Gets the full table name. Prefix will not be added.
+    // TODO Remove when new Migration API is introduced.
+    public Table getTable(String tableName) {
+        return transaction.getTable(tableName);
+    }
+
+    /**
+     * Checks if a Realm file can be advanced to a newer version.
+     */
+    public boolean hasChanged() {
+        return sharedGroup.hasChanged();
+    }
+
+    /**
+     * Returns the version for the SharedGroup.
+     */
+    public SharedGroup.VersionID getVersion() {
+        return sharedGroup.getVersion();
+    }
+
+    /**
+     * Makes the file writable. This will block all other threads and processes from making it writable as well.
+     */
+    public void promoteToWrite() {
+        transaction.promoteToWrite();
+    }
+
+    /**
+     * Commits any pending changes to the file and return to read-only mode.
+     */
+    public void commitAndContinueAsRead() {
+        transaction.commitAndContinueAsRead();
+    }
+
+    /**
+     * Rollbacks any changes to the file since it was made writable and continue in read-only mode.
+     */
+    public void rollbackAndContinueAsRead() {
+        transaction.rollbackAndContinueAsRead();
+    }
+
+    /**
+     * Checks if a given table exists.
+     *
+     * @return {code true} if the table exists. {@code false} otherwise.
+     */
+    public boolean hasTable(String tableName) {
+        return transaction.hasTable(tableName);
+    }
+
+    /**
+     * Writes a copy of this Realm file to another location.
+     */
+    public void copyToFile(File destination, byte[] key) throws IOException {
+        transaction.writeToFile(destination, key);
+    }
+
+    /**
+     * Returns a reference to current {@link SharedGroup}.
+     */
+    public SharedGroup getSharedGroup() {
+        return sharedGroup;
+    }
+
+    /**
+     * Returns a reference to the current {@link ImplicitTransaction}.
+     */
+    public ImplicitTransaction getTransaction() {
+        return transaction;
+    }
+
+    /**
+     * Returns if the Realm is currently not in a transaction.
+     */
+    public boolean isImmutable() {
+        return transaction.immutable;
+    }
+
+    /**
+     * Compacts a Realm file. It cannot be open when calling this method.
+     * Returns true if compaction succeeded, false otherwise.
+     */
+    public static boolean compact(RealmConfiguration configuration) {
+        SharedGroup sharedGroup = null;
+        boolean result = false;
+        try {
+            sharedGroup = new SharedGroup(
+                    configuration.getPath(),
+                    SharedGroup.IMPLICIT_TRANSACTION,
+                    SharedGroup.Durability.FULL,
+                    configuration.getEncryptionKey());
+            result = sharedGroup.compact();
+        } catch (Exception e) {
+            RealmLog.i(e.getMessage());
+            return false;
+        } finally {
+            if (sharedGroup != null) {
+                sharedGroup.close();
+            }
+        }
+        return result;
+    }
+
+    public long getNativePointer() {
+        return sharedGroup.getNativePointer();
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/SubtableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
similarity index 82%
rename from realm/src/main/java/io/realm/internal/SubtableSchema.java
rename to realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
index 2697b1dd28..dda38d3e5a 100644
--- a/realm/src/main/java/io/realm/internal/SubtableSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
@@ -16,6 +16,7 @@
 
 package io.realm.internal;
 
+import io.realm.RealmFieldType;
 
 public class SubtableSchema implements TableSchema {
 
@@ -29,11 +30,9 @@
 
     @Override
     public SubtableSchema getSubtableSchema(long columnIndex) {
-        long[] newPath = new long[this.path.length+1];
-        for (int i = 0; i < this.path.length; i++) {
-            newPath[i] = path[i];
-        }
-        newPath[this.path.length] = columnIndex;
+        long[] newPath = new long[path.length + 1];
+        System.arraycopy(path, 0, newPath, 0, path.length);
+        newPath[path.length] = columnIndex;
         return new SubtableSchema(this.parentNativePtr, newPath);
     }
 
@@ -44,15 +43,15 @@ private void verifyColumnName(String name) {
     }
 
     @Override
-    public long addColumn(ColumnType type, String name) {
+    public long addColumn(RealmFieldType type, String name) {
         verifyColumnName(name);
-        return nativeAddColumn(parentNativePtr, path, type.getValue(), name);
+        return nativeAddColumn(parentNativePtr, path, type.getNativeValue(), name);
     }
 
     protected native long nativeAddColumn(long nativeTablePtr, long[] path, int type, String name);
 
     /**
-     * Remove a column in the table dynamically.
+     * Removes a column in the table dynamically.
      */
     @Override
     public void removeColumn(long columnIndex) {
@@ -62,7 +61,7 @@ public void removeColumn(long columnIndex) {
     protected native void nativeRemoveColumn(long nativeTablePtr, long[] path, long columnIndex);
 
     /**
-     * Rename a column in the table.
+     * Renames a column in the table.
      */
     @Override
     public void renameColumn(long columnIndex, String newName) {
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
similarity index 60%
rename from realm/src/main/java/io/realm/internal/Table.java
rename to realm/realm-library/src/main/java/io/realm/internal/Table.java
index a2073c1797..7987364a2b 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -18,20 +18,30 @@
 
 import java.io.Closeable;
 import java.util.Date;
+import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.RealmFieldType;
+import io.realm.Sort;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.log.RealmLog;
 
 
 /**
- * This class is a base class for all Realm tables. The class supports all low
- * level methods (define/insert/delete/update) a table has. All the native
- * communications to the Realm C++ library are also handled by this class.
+ * This class is a base class for all Realm tables. The class supports all low level methods
+ * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
+ * this class.
  */
 public class Table implements TableOrView, TableSchema, Closeable {
 
+    public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
+    public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
     public static final String STRING_DEFAULT_VALUE = "";
     public static final long INTEGER_DEFAULT_VALUE = 0;
+    public static final String METADATA_TABLE_NAME = "metadata";
+    public static final boolean NULLABLE = true;
+    public static final boolean NOT_NULLABLE = false;
 
     private static final String PRIMARY_KEY_TABLE_NAME = "pk";
     private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
@@ -41,25 +51,22 @@
     private static final long NO_PRIMARY_KEY = -2;
 
     protected long nativePtr;
-    
     protected final Object parent;
     private final Context context;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
     // test:
     protected int tableNo;
-    protected boolean DEBUG = false;
-    protected static int TableCount = 0;
+    private static final boolean DEBUG = false;
+    static AtomicInteger tableCount = new AtomicInteger(0);
 
     static {
         RealmCore.loadLibrary();
     }
 
-
     /**
-     * Construct a Table base object. It can be used to register columns in this
-     * table. Registering into table is allowed only for empty tables. It
-     * creates a native reference of the object and keeps a reference to it.
+     * Constructs a Table base object. It can be used to register columns in this table. Registering into table is
+     * allowed only for empty tables. It creates a native reference of the object and keeps a reference to it.
      */
     public Table() {
         this.parent = null; // No parent in free-standing table
@@ -72,21 +79,18 @@ public Table() {
             throw new java.lang.OutOfMemoryError("Out of native memory.");
         }
         if (DEBUG) {
-            tableNo = ++TableCount;
-            System.err.println("====== New Tablebase " + tableNo + " : ptr = " + nativePtr);
+            tableNo = tableCount.incrementAndGet();
+            RealmLog.d("====== New Tablebase " + tableNo + " : ptr = " + nativePtr);
         }
     }
 
-    protected native long createNative();
-    
     Table(Context context, Object parent, long nativePointer) {
         this.context = context;
         this.parent  = parent;
         this.nativePtr = nativePointer;
-
         if (DEBUG) {
-            tableNo = ++TableCount;
-            System.err.println("===== New Tablebase(ptr) " + tableNo + " : ptr = " + nativePtr);
+            tableNo = tableCount.incrementAndGet();
+            RealmLog.d("===== New Tablebase(ptr) " + tableNo + " : ptr = " + nativePtr);
         }
     }
 
@@ -103,17 +107,14 @@ public void close() {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
                 if (DEBUG) {
-                    TableCount--;
-                    System.err.println("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + TableCount);
+                    tableCount.decrementAndGet();
+                    RealmLog.d("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + tableCount.get());
                 }
-                
                 nativePtr = 0;
-            }   
+            }
         }
     }
 
-    protected static native void nativeClose(long nativeTablePtr);
-    
     @Override
     protected void finalize() {
         synchronized (context) {
@@ -123,13 +124,13 @@ protected void finalize() {
                 nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
             }
         }
-
-        if (DEBUG) 
-            System.err.println("==== FINALIZE " + tableNo + "...");
+        if (DEBUG) {
+            RealmLog.d("==== FINALIZE " + tableNo + "...");
+        }
     }
 
     /*
-     * Check if the Table is valid.
+     * Checks if the Table is valid.
      * Whenever a Table/subtable is changed/updated all it's subtables are invalidated.
      * You can no longer perform any actions on the table, and if done anyway, an exception is thrown.
      * The only method you can call is 'isValid()'.
@@ -139,26 +140,6 @@ public boolean isValid() {
         return nativePtr != 0 && nativeIsValid(nativePtr);
     }
 
-    protected native boolean nativeIsValid(long nativeTablePtr);
-
-    @Override
-    public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-        if (other == null) {
-            return false;
-        }
-        if (!(other instanceof Table)) {
-            return false; // Has to work for all the typed tables as well
-        }
-
-        Table otherTable = (Table) other;
-        return nativeEquals(nativePtr, otherTable.nativePtr);
-    }
-
-    protected native boolean nativeEquals(long nativeTablePtr, long nativeTableToComparePtr);
-
     private void verifyColumnName(String name) {
         if (name.length() > 63) {
             throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
@@ -167,7 +148,7 @@ private void verifyColumnName(String name) {
 
     @Override
     public TableSchema getSubtableSchema(long columnIndex) {
-        if(!nativeIsRootTable(nativePtr)) {
+        if (!nativeIsRootTable(nativePtr)) {
             throw new UnsupportedOperationException("This is a subtable. Can only be called on root table.");
         }
 
@@ -176,43 +157,49 @@ public TableSchema getSubtableSchema(long columnIndex) {
         return new SubtableSchema(nativePtr, newPath);
     }
 
-    protected native boolean nativeIsRootTable(long nativeTablePtr);
-
     /**
-     * Add a column to the table dynamically.
-     * @return Index of the new column.
+     * Adds a column to the table dynamically.
+     *
+     * @param type the column type.
+     * @param name the field/column name.
+     * @param isNullable {@code true} if column can contain null values, {@ code false}e otherwise.
+     * @return the index of the new column.
      */
-    @Override
-    public long addColumn (ColumnType type, String name) {
+    public long addColumn(RealmFieldType type, String name, boolean isNullable) {
         verifyColumnName(name);
-        return nativeAddColumn(nativePtr, type.getValue(), name);
+        return nativeAddColumn(nativePtr, type.getNativeValue(), name, isNullable);
     }
 
-    protected native long nativeAddColumn(long nativeTablePtr, int type, String name);
+    /**
+     * Adds a non-nullable column to the table dynamically.
+     *
+     * @return the index of the new column.
+     */
+    @Override
+    public long addColumn(RealmFieldType type, String name) {
+        return addColumn(type, name, false);
+    }
 
     /**
-     * Add a link column to the table dynamically.
-     * @return Index of the new column.
+     * Adds a link column to the table dynamically.
+     *
+     * @return the index of the new column.
      */
-    public long addColumnLink (ColumnType type, String name, Table table) {
+    public long addColumnLink (RealmFieldType type, String name, Table table) {
         verifyColumnName(name);
-        return nativeAddColumnLink(nativePtr, type.getValue(), name, table.nativePtr);
+        return nativeAddColumnLink(nativePtr, type.getNativeValue(), name, table.nativePtr);
     }
 
-    protected native long nativeAddColumnLink(long nativeTablePtr, int type, String name, long targetTablePtr);
-
     /**
-     * Remove a column in the table dynamically.
+     * Removes a column in the table dynamically.
      */
     @Override
     public void removeColumn(long columnIndex) {
         nativeRemoveColumn(nativePtr, columnIndex);
     }
 
-    protected native void nativeRemoveColumn(long nativeTablePtr, long columnIndex);
-
     /**
-     * Rename a column in the table.
+     * Renames a column in the table.
      */
     @Override
     public void renameColumn(long columnIndex, String newName) {
@@ -220,8 +207,33 @@ public void renameColumn(long columnIndex, String newName) {
         nativeRenameColumn(nativePtr, columnIndex, newName);
     }
 
-    protected native void nativeRenameColumn(long nativeTablePtr, long columnIndex, String name);
+    /**
+     * Checks whether the specific column is nullable?
+     *
+     * @param columnIndex the column index.
+     * @return {@code true} if column is nullable, {@code false} otherwise.
+     */
+    public boolean isColumnNullable(long columnIndex) {
+        return nativeIsColumnNullable(nativePtr, columnIndex);
+    }
 
+    /**
+     * Converts a column to be nullable.
+     *
+     * @param columnIndex the column index.
+     */
+    public void convertColumnToNullable(long columnIndex) {
+        nativeConvertColumnToNullable(nativePtr, columnIndex);
+    }
+
+    /**
+     * Converts a column to be not nullable. null values will be converted to default values.
+     *
+     * @param columnIndex the column index.
+     */
+    public void convertColumnToNotNullable(long columnIndex) {
+        nativeConvertColumnToNotNullable(nativePtr, columnIndex);
+    }
 
     /**
      * Updates a table specification from a Table specification structure.
@@ -231,26 +243,22 @@ public void updateFromSpec(TableSpec tableSpec) {
         nativeUpdateFromSpec(nativePtr, tableSpec);
     }
 
-    protected native void nativeUpdateFromSpec(long nativeTablePtr, TableSpec tableSpec);
-
     // Table Size and deletion. AutoGenerated subclasses are nothing to do with this
     // class.
     /**
-     * Get the number of entries/rows of this table.
+     * Gets the number of entries/rows of this table.
      *
-     * @return The number of rows.
+     * @return the number of rows.
      */
     @Override
     public long size() {
         return nativeSize(nativePtr);
     }
 
-    protected native long nativeSize(long nativeTablePtr);
-
     /**
      * Checks whether this table is empty or not.
      *
-     * @return true if empty, otherwise false.
+     * @return {@code true} if empty, otherwise {@code false}.
      */
     @Override
     public boolean isEmpty() {
@@ -266,8 +274,6 @@ public void clear() {
         nativeClear(nativePtr);
     }
 
-    protected native void nativeClear(long nativeTablePtr);
-
     // Column Information.
     /**
      * Returns the number of columns in the table.
@@ -279,34 +285,26 @@ public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
     }
 
-    protected native long nativeGetColumnCount(long nativeTablePtr);
-
-
     public TableSpec getTableSpec(){
         return nativeGetTableSpec(nativePtr);
     }
 
-    protected native TableSpec nativeGetTableSpec(long nativeTablePtr);
-
     /**
-     * Returns the name of a column identified by columnIndex. Notice that the
-     * index is zero based.
+     * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
      *
-     * @param columnIndex the column index
-     * @return the name of the column
+     * @param columnIndex the column index.
+     * @return the name of the column.
      */
     @Override
     public String getColumnName(long columnIndex) {
         return nativeGetColumnName(nativePtr, columnIndex);
     }
 
-    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
-
     /**
      * Returns the 0-based index of a column based on the name.
      *
-     * @param columnName column name
-     * @return the index, {@link #NO_MATCH} if not found
+     * @param columnName column name.
+     * @return the index, {@link #NO_MATCH} if not found.
      */
     @Override
     public long getColumnIndex(String columnName) {
@@ -315,26 +313,21 @@ public long getColumnIndex(String columnName) {
         }
         return nativeGetColumnIndex(nativePtr, columnName);
     }
-    
-    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
-
 
     /**
-     * Get the type of a column identified by the columnIdex.
+     * Gets the type of a column identified by the columnIndex.
      *
      * @param columnIndex index of the column.
-     * @return Type of the particular column.
+     * @return the type of the particular column.
      */
     @Override
-    public ColumnType getColumnType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
+    public RealmFieldType getColumnType(long columnIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
     }
 
-    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
 
     /**
-     * Removes a row from the specific index. As of now the entry is simply
-     * removed from the table.
+     * Removes a row from the specific index. As of now the entry is simply removed from the table.
      *
      * @param rowIndex the row index (starting with 0)
      *
@@ -345,28 +338,22 @@ public void remove(long rowIndex) {
         nativeRemove(nativePtr, rowIndex);
     }
 
-    protected native void nativeRemove(long nativeTablePtr, long rowIndex);
-
     @Override
     public void removeLast() {
         checkImmutable();
         nativeRemoveLast(nativePtr);
     }
 
-    protected native void nativeRemoveLast(long nativeTablePtr);
-
     public void moveLastOver(long rowIndex) {
         checkImmutable();
         nativeMoveLastOver(nativePtr, rowIndex);
     }
 
-    protected native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
-
     public long addEmptyRow() {
         checkImmutable();
         if (hasPrimaryKey()) {
             long primaryKeyColumnIndex = getPrimaryKey();
-            ColumnType type = getColumnType(primaryKeyColumnIndex);
+            RealmFieldType type = getColumnType(primaryKeyColumnIndex);
             switch (type) {
                 case STRING:
                     if (findFirstString(primaryKeyColumnIndex, STRING_DEFAULT_VALUE) != NO_MATCH) {
@@ -390,11 +377,11 @@ public long addEmptyRow() {
     public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
         checkImmutable();
         checkHasPrimaryKey();
-        
+
         long primaryKeyColumnIndex = getPrimaryKey();
-        ColumnType type = getColumnType(primaryKeyColumnIndex);
+        RealmFieldType type = getColumnType(primaryKeyColumnIndex);
         long rowIndex;
-        Row row;
+        UncheckedRow row;
 
         // Add with primary key initially set
         switch (type) {
@@ -406,14 +393,14 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(primaryKeyValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getRow(rowIndex);
+                row = getUncheckedRow(rowIndex);
                 row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
                 break;
 
             case INTEGER:
                 long pkValue;
                 try {
-                    pkValue = Long.valueOf(primaryKeyValue.toString());
+                    pkValue = Long.parseLong(primaryKeyValue.toString());
                 } catch (RuntimeException e) {
                     throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
                 }
@@ -421,7 +408,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(pkValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getRow(rowIndex);
+                row = getUncheckedRow(rowIndex);
                 row.setLong(primaryKeyColumnIndex, pkValue);
                 break;
 
@@ -446,36 +433,17 @@ public long addEmptyRows(long rows) {
         return nativeAddEmptyRow(nativePtr, rows);
     }
 
-    protected native long nativeAddEmptyRow(long nativeTablePtr, long rows);
-
-
     /**
-     * Appends the specified row to the end of the table
-     * @param values
-     * @return The row index of the appended row
+     * Appends the specified row to the end of the table. For internal testing usage only.
+     *
+     * @param values values.
+     * @return the row index of the appended row.
      */
-    public long add(Object... values) {
-        long rowIndex = size();
-        addAt(rowIndex, values);
-        return rowIndex;
-    }
+    protected long add(Object... values) {
+        long rowIndex = addEmptyRow();
 
-
-    /**
-     * Inserts a row at the specified row index. Shifts the row currently at that row index and any subsequent rows down (adds one to their row index).
-     * @param rowIndex
-     * @param values
-     */
-    public void addAt(long rowIndex, Object... values) {
         checkImmutable();
 
-        // Check index
-        long size = size();
-        if (rowIndex > size) {
-            throw new IllegalArgumentException("rowIndex " + String.valueOf(rowIndex) +
-                    " must be <= table.size() " + String.valueOf(size) + ".");
-        }
-
         // Check values types
         int columns = (int)getColumnCount();
         if (columns != values.length) {
@@ -484,18 +452,19 @@ public void addAt(long rowIndex, Object... values) {
                     ") does not match the number of columns in the table (" +
                     String.valueOf(columns) + ").");
         }
-        ColumnType colTypes[] = new ColumnType[columns];
+        RealmFieldType colTypes[] = new RealmFieldType[columns];
         for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
             Object value = values[columnIndex];
-            ColumnType colType = getColumnType(columnIndex);
+            RealmFieldType colType = getColumnType(columnIndex);
             colTypes[columnIndex] = colType;
-            if (!colType.matchObject(value)) {
+            if (!colType.isValid(value)) {
                 //String representation of the provided value type
                 String providedType;
-                if (value == null)
+                if (value == null) {
                     providedType = "null";
-                else
+                } else {
                     providedType = value.getClass().toString();
+                }
 
                 throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
                         ". Expected a value compatible with column type " + colType + ", but got " + providedType + ".");
@@ -507,81 +476,64 @@ public void addAt(long rowIndex, Object... values) {
             Object value = values[(int)columnIndex];
             switch (colTypes[(int)columnIndex]) {
             case BOOLEAN:
-                nativeInsertBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
+                nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean)value);
                 break;
             case INTEGER:
                 long intValue = ((Number) value).longValue();
                 checkIntValueIsLegal(columnIndex, rowIndex, intValue);
-                nativeInsertLong(nativePtr, columnIndex, rowIndex, intValue);
+                nativeSetLong(nativePtr, columnIndex, rowIndex, intValue);
                 break;
             case FLOAT:
-                nativeInsertFloat(nativePtr, columnIndex, rowIndex, (Float) value);
+                nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value);
                 break;
             case DOUBLE:
-                nativeInsertDouble(nativePtr, columnIndex, rowIndex, (Double) value);
+                nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value);
                 break;
             case STRING:
                 String stringValue = (String) value;
                 checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
-                nativeInsertString(nativePtr, columnIndex, rowIndex, (String)value);
+                nativeSetString(nativePtr, columnIndex, rowIndex, (String) value);
                 break;
             case DATE:
-                nativeInsertDate(nativePtr, columnIndex, rowIndex, ((Date)value).getTime()/1000);
+                if (value == null)
+                    throw new IllegalArgumentException("Null Date is not allowed.");
+                nativeSetDate(nativePtr, columnIndex, rowIndex, ((Date) value).getTime() / 1000);
                 break;
-            case MIXED:
-                nativeInsertMixed(nativePtr, columnIndex, rowIndex, Mixed.mixedValue(value));
+            case UNSUPPORTED_MIXED:
+                if (value == null)
+                    throw new IllegalArgumentException("Null Mixed data is not allowed");
+                nativeSetMixed(nativePtr, columnIndex, rowIndex, Mixed.mixedValue(value));
                 break;
             case BINARY:
-                nativeInsertByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
+                if (value == null)
+                    throw new IllegalArgumentException("Null Array is not allowed");
+                nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
                 break;
-            case TABLE:
-                nativeInsertSubtable(nativePtr, columnIndex, rowIndex);
-                insertSubtableValues(rowIndex, columnIndex, value);
+            case UNSUPPORTED_TABLE:
+                insertSubTable(columnIndex, rowIndex, value);
                 break;
             default:
                 throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int)columnIndex]));
             }
         }
-        //Insert done. Use native, no need to check for immutable again here
-        nativeInsertDone(nativePtr);
-
+        return rowIndex;
     }
 
     private boolean isPrimaryKeyColumn(long columnIndex) {
         return columnIndex == getPrimaryKey();
     }
 
-    private void insertSubtableValues(long rowIndex, long columnIndex, Object value) {
-        if (value != null) {
-            // insert rows in subtable recursively
-            Table subtable = getSubtableDuringInsert(columnIndex, rowIndex);
-            int rows = ((Object[])value).length;
-            for (int i=0; i<rows; ++i) {
-                Object rowArr = ((Object[])value)[i];
-                subtable.addAt(i, (Object[])rowArr);
-            }
-        }
-    }
-
-    // LinkList
-
-    public void insertLinkList(long columnIndex, long rowIndex) {
-        nativeInsertLinkList(nativePtr, columnIndex, rowIndex);
-        getInternalMethods().insertDone();
-    }
-
-    private native void nativeInsertLinkList(long nativePtr, long columnIndex, long rowIndex);
-
     /**
-     * Returns a view sorted by the specified column and order
-     * @param columnIndex
-     * @param order
-     * @return
+     * Returns a view sorted by the specified column and order.
+     *
+     * @param columnIndex the column index.
+     * @param sortOrder the sort order.
+     * @return a sorted view.
      */
-    public TableView getSortedView(long columnIndex, TableView.Order order){
+    public TableView getSortedView(long columnIndex, Sort sortOrder){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, (order == TableView.Order.ascending));
+        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, sortOrder.getValue());
         try {
             return new TableView(this.context, this, nativeViewPtr);
         } catch (RuntimeException e) {
@@ -591,9 +543,10 @@ public TableView getSortedView(long columnIndex, TableView.Order order){
     }
 
     /**
-     * Returns a view sorted by the specified column by the default order
-     * @param columnIndex
-     * @return
+     * Returns a view sorted by the specified column by the default order.
+     *
+     * @param columnIndex the column index.
+     * @return a sorted view.
      */
     public TableView getSortedView(long columnIndex) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -602,69 +555,20 @@ public TableView getSortedView(long columnIndex) {
         return new TableView(this.context, this, nativeViewPtr);
     }
 
-    protected native long nativeGetSortedView(long nativeTableViewPtr, long columnIndex, boolean ascending);
-
-
-    public TableView getSortedView(long columnIndices[], boolean orders[]) {
+    public TableView getSortedView(long columnIndices[], Sort sortOrders[]) {
         context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedViewMulti(nativePtr, columnIndices, orders);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    protected native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
-
-    /**
-     * Replaces the row at the specified position with the specified row.
-     * @param rowIndex
-     * @param values
-     */
-    public void set(long rowIndex, Object... values) {
-        checkImmutable();
-
-        // Check index
-        long size = size();
-        if (rowIndex >= size) {
-            throw new IllegalArgumentException("rowIndex " + String.valueOf(rowIndex) +
-                    " must be < table.size() " + String.valueOf(size) + ".");
-        }
-
-        // Verify number of 'values'
-        int columns = (int)getColumnCount();
-        if (columns != values.length) {
-            throw new IllegalArgumentException("The number of value parameters (" +
-                    String.valueOf(values.length) +
-                    ") does not match the number of columns in the table (" +
-                    String.valueOf(columns) + ").");
+        boolean[] nativeSortOrder = new boolean[sortOrders.length];
+        for (int i = 0; i < sortOrders.length; i++) {
+            nativeSortOrder[i] = sortOrders[i].getValue();
         }
-
-        // Verify type of 'values'
-        for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
-            Object value = values[columnIndex];
-            ColumnType colType = getColumnType(columnIndex);
-            if (!colType.matchObject(value)) {
-                throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
-                        ". Expected a value compatible with column type " + colType + ", but got " + value.getClass() + ".");
-            }
-        }
-
-        // Now that all values are verified, we can remove the row and insert it again.
-        // TODO: Can be optimized to only set the values (but clear any subtables)
-        remove(rowIndex);
-        addAt(rowIndex, values);
-    }
-
-    //Instance of the inner class InternalMethods.
-    private InternalMethods internal = new InternalMethods();
-
-    //Returns InternalMethods instance with public internal methods. Should only be called by AbstractTable
-    public InternalMethods getInternalMethods(){
-        return this.internal;
+        long nativeViewPtr = nativeGetSortedViewMulti(nativePtr, columnIndices, nativeSortOrder);
+        return new TableView(this.context, this, nativeViewPtr);
     }
 
     /**
      * Returns the column index for the primary key.
      *
-     * @return Column index or {@code #NO_MATCH} if no primary key is set.
+     * @return the column index or {@code #NO_MATCH} if no primary key is set.
      */
     public long getPrimaryKey() {
         if (cachedPrimaryKeyColumnIndex >= 0 || cachedPrimaryKeyColumnIndex == NO_PRIMARY_KEY) {
@@ -674,9 +578,14 @@ public long getPrimaryKey() {
             if (pkTable == null) {
                 return NO_PRIMARY_KEY; // Free table = No primary key
             }
-            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getName());
+
+            String tableName = getName();
+            if (tableName.startsWith(TABLE_PREFIX)) {
+                tableName = tableName.substring(TABLE_PREFIX.length());
+            }
+            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, tableName);
             if (rowIndex != NO_MATCH) {
-                String pkColumnName = pkTable.getRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
                 cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
             } else {
                 cachedPrimaryKeyColumnIndex = NO_PRIMARY_KEY;
@@ -688,25 +597,24 @@ public long getPrimaryKey() {
 
     /**
      * Checks if a given column is a primary key column.
-     * @param columnIndex   Index of column in the table.
-     * @return              True if column is a primary key, false otherwise.
+     *
+     * @param columnIndex the index of column in the table.
+     * @return {@code true} if column is a primary key, {@code false} otherwise.
      */
     public boolean isPrimaryKey(long columnIndex) {
         return columnIndex >= 0 && columnIndex == getPrimaryKey();
     }
 
     /**
-     * Check if a table has a primary key.
-     * @return True if primary key is defined, false otherwise.
+     * Checks if a table has a primary key.
+     *
+     * @return {@code true} if primary key is defined, {@code false} otherwise.
      */
     public boolean hasPrimaryKey() {
         return getPrimaryKey() >= 0;
     }
 
     void checkStringValueIsLegal(long columnIndex, long rowToUpdate, String value) {
-        if (value == null) {
-            throw new IllegalArgumentException("Null String is not allowed.");
-        }
         if (isPrimaryKey(columnIndex)) {
             long rowIndex = findFirstString(columnIndex, value);
             if (rowIndex != rowToUpdate && rowIndex != TableOrView.NO_MATCH) {
@@ -725,110 +633,9 @@ void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
     }
 
     private void throwDuplicatePrimaryKeyException(Object value) {
-        throw new RealmException("Primary key constraint broken. Value already exists: " + value);
+        throw new RealmPrimaryKeyConstraintException("Value already exists: " + value);
     }
 
-    //Holds methods that must be publicly available for AbstractClass.
-    //Should not be called when using the dynamic interface. The methods can be accessed by calling getInternalMethods() in Table class
-    public class InternalMethods{
-
-        public void insertLong(long columnIndex, long rowIndex, long value) {
-            checkImmutable();
-            nativeInsertLong(nativePtr, columnIndex, rowIndex, value);
-        }
-
-        public void insertDouble(long columnIndex, long rowIndex, double value) {
-            checkImmutable();
-            nativeInsertDouble(nativePtr, columnIndex, rowIndex, value);
-        }
-
-        public void insertFloat(long columnIndex, long rowIndex, float value) {
-            checkImmutable();
-            nativeInsertFloat(nativePtr, columnIndex, rowIndex, value);
-        }
-
-        public void insertBoolean(long columnIndex, long rowIndex, boolean value) {
-            checkImmutable();
-            nativeInsertBoolean(nativePtr, columnIndex, rowIndex, value);
-        }
-
-        public void insertDate(long columnIndex, long rowIndex, Date date) {
-            checkImmutable();
-            nativeInsertDate(nativePtr, columnIndex, rowIndex, date.getTime()/1000);
-        }
-
-        public void insertString(long columnIndex, long rowIndex, String value) {
-            checkImmutable();
-            nativeInsertString(nativePtr, columnIndex, rowIndex, value);
-        }
-
-        public void insertMixed(long columnIndex, long rowIndex, Mixed data) {
-            checkImmutable();
-            nativeInsertMixed(nativePtr, columnIndex, rowIndex, data);
-        }
-
-        /*
-
-        public void insertBinary(long columnIndex, long rowIndex, ByteBuffer data) {
-            if (immutable) throwImmutable();
-            //System.err.printf("\ninsertBinary(col %d, row %d, ByteBuffer)\n", columnIndex, rowIndex);
-            //System.err.println("-- HasArray: " + (data.hasArray() ? "yes":"no") + " len= " + data.array().length);
-            if (data.isDirect())
-                nativeInsertByteBuffer(nativePtr, columnIndex, rowIndex, data);
-            else
-                throw new RuntimeException("Currently ByteBuffer must be allocateDirect().");   // FIXME: support other than allocateDirect
-        }
-
-         */
-
-        public void insertBinary(long columnIndex, long rowIndex, byte[] data) {
-            checkImmutable();
-            if(data != null)
-                nativeInsertByteArray(nativePtr, columnIndex, rowIndex, data);
-            else
-                throw new IllegalArgumentException("byte[] must not be null. Alternatively insert empty array.");
-        }
-
-        public void insertSubtable(long columnIndex, long rowIndex, Object[][] values) {
-            checkImmutable();
-            nativeInsertSubtable(nativePtr, columnIndex, rowIndex);
-            insertSubtableValues(rowIndex, columnIndex, values);
-        }
-
-        public void insertDone() {
-            checkImmutable();
-            nativeInsertDone(nativePtr);
-        }
-    }
-
-    protected native void nativeInsertFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-
-    protected native void nativeInsertDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-
-    protected native void nativeInsertLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-
-    protected native void nativeInsertBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-
-    protected native void nativeInsertDate(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
-
-    protected native void nativeInsertString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-
-    protected native void nativeInsertMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed mixed);
-
-
-    /* public void insertBinary(long columnIndex, long rowIndex, byte[] data) {
-        if (data == null)
-            throw new IllegalArgumentException("Null Array");
-        if (immutable) throwImmutable();
-        nativeInsertByteArray(nativePtr, columnIndex, rowIndex, data);
-    }*/
-
-    protected native void nativeInsertByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-
-    protected native void nativeInsertSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-
-    protected native void nativeInsertDone(long nativeTablePtr);
-
     //
     // Getters
     //
@@ -838,43 +645,31 @@ public long getLong(long columnIndex, long rowIndex) {
         return nativeGetLong(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
-
     @Override
     public boolean getBoolean(long columnIndex, long rowIndex) {
         return nativeGetBoolean(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
-
     @Override
     public float getFloat(long columnIndex, long rowIndex) {
         return nativeGetFloat(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native float nativeGetFloat(long nativeTablePtr, long columnIndex, long rowIndex);
-
     @Override
     public double getDouble(long columnIndex, long rowIndex) {
         return nativeGetDouble(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native double nativeGetDouble(long nativeTablePtr, long columnIndex, long rowIndex);
-
     @Override
     public Date getDate(long columnIndex, long rowIndex) {
         return new Date(nativeGetDateTime(nativePtr, columnIndex, rowIndex)*1000);
     }
 
-    protected native long nativeGetDateTime(long nativeTablePtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of a (string )cell.
+     * Gets the value of a (string )cell.
      *
-     * @param columnIndex
-     *            0 based index value of the column
-     * @param rowIndex
-     *            0 based index of the row.
+     * @param columnIndex 0 based index value of the column
+     * @param rowIndex 0 based index of the row.
      * @return value of the particular cell
      */
     @Override
@@ -882,15 +677,11 @@ public String getString(long columnIndex, long rowIndex) {
         return nativeGetString(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native String nativeGetString(long nativePtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of a (binary) cell.
+     * Gets the value of a (binary) cell.
      *
-     * @param columnIndex
-     *            0 based index value of the cell column
-     * @param rowIndex
-     *            0 based index value of the cell row
+     * @param columnIndex 0 based index value of the cell column.
+     * @param rowIndex 0 based index value of the cell row.
      * @return value of the particular cell.
      */
     /*
@@ -907,29 +698,20 @@ public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-
     @Override
     public Mixed getMixed(long columnIndex, long rowIndex) {
         return nativeGetMixed(nativePtr, columnIndex, rowIndex);
     }
 
     @Override
-    public ColumnType getMixedType(long columnIndex, long rowIndex) {
-        return ColumnType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
+    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
     }
 
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex, long rowIndex);
-
-    protected native Mixed nativeGetMixed(long nativeTablePtr, long columnIndex, long rowIndex);
-
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
-
-
     public Table getLinkTarget(long columnIndex) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
@@ -944,18 +726,14 @@ public Table getLinkTarget(long columnIndex) {
         }
     }
 
-    protected native long nativeGetLinkTarget(long nativePtr, long columnIndex);
-
-
     /**
      *
      * Note: The subtable returned will have to be closed again after use.
-     * You can let javas garbage collector handle that or better yet call close()
-     * after use.
+     * You can let javas garbage collector handle that or better yet call close() after use.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @return TableBase the subtable at the requested cell
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @return the TableBase the subtable at the requested.
      */
     @Override
     public Table getSubtable(long columnIndex, long rowIndex) {
@@ -972,8 +750,6 @@ public Table getSubtable(long columnIndex, long rowIndex) {
         }
     }
 
-    protected native long nativeGetSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-
     // Below version will allow to getSubtable when number of available rows are not updated yet -
     // which happens before an insertDone().
 
@@ -990,30 +766,49 @@ private Table getSubtableDuringInsert(long columnIndex, long rowIndex) {
         }
     }
 
-    private native long nativeGetSubtableDuringInsert(long nativeTablePtr, long columnIndex, long rowIndex);
-
-
     public long getSubtableSize(long columnIndex, long rowIndex) {
         return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-
     public void clearSubtable(long columnIndex, long rowIndex) {
         checkImmutable();
         nativeClearSubtable(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-
-
-    public Row getRow(long index) {
-        long nativeRowPtr = nativeGetRowPtr(nativePtr, index);
-        return new Row(context, this, nativeRowPtr);
+    /**
+     * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
+     * If error checking is required, use {@link #getCheckedRow(long)} instead.
+     *
+     * @param index the index of row to fetch.
+     * @return the unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRow(long index) {
+        return UncheckedRow.getByRowIndex(context, this, index);
     }
 
-    protected native long nativeGetRowPtr(long nativePtr, long index);
+    /**
+     * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
+     * If error checking is required, use {@link #getCheckedRow(long)} instead.
+     *
+     * @param nativeRowPointer the pointer to the row to fetch.
+     * @return the unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRowByPointer(long nativeRowPointer) {
+        return UncheckedRow.getByRowPointer(context, this, nativeRowPointer);
+    }
 
+    /**
+     * Returns a wrapper around Row access. All access will be error checked in JNI and will throw an appropriate
+     * {@link RuntimeException} if used incorrectly.
+     *
+     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
+     *
+     * @param index the index of row to fetch.
+     * @return the safe row wrapper object.
+     */
+    public CheckedRow getCheckedRow(long index) {
+        return CheckedRow.get(context, this, index);
+    }
 
     //
     // Setters
@@ -1026,32 +821,24 @@ public void setLong(long columnIndex, long rowIndex, long value) {
         nativeSetLong(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-
     @Override
     public void setBoolean(long columnIndex, long rowIndex, boolean value) {
         checkImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-
     @Override
     public void setFloat(long columnIndex, long rowIndex, float value) {
         checkImmutable();
         nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-
     @Override
     public void setDouble(long columnIndex, long rowIndex, double value) {
         checkImmutable();
         nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-
     @Override
     public void setDate(long columnIndex, long rowIndex, Date date) {
         if (date == null)
@@ -1060,8 +847,6 @@ public void setDate(long columnIndex, long rowIndex, Date date) {
         nativeSetDate(nativePtr, columnIndex, rowIndex, date.getTime() / 1000);
     }
 
-    protected native void nativeSetDate(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
-
     @Override
     public void setString(long columnIndex, long rowIndex, String value) {
         checkImmutable();
@@ -1069,17 +854,12 @@ public void setString(long columnIndex, long rowIndex, String value) {
         nativeSetString(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-
     /**
      * Sets the value for a (binary) cell.
      *
-     * @param columnIndex
-     *            column index of the cell
-     * @param rowIndex
-     *            row index of the cell
-     * @param data
-     *            the ByteBuffer must be allocated with ByteBuffer.allocateDirect(len)
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param data the ByteBuffer must be allocated with {@code ByteBuffer.allocateDirect(len)}.
      */
 
     /*
@@ -1101,21 +881,15 @@ public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data
     @Override
     public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data) {
         checkImmutable();
-        if (data == null)
-            throw new IllegalArgumentException("Null Array");
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    protected native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-
     /**
      * Sets the value for a (mixed typed) cell.
      *
-     * @param columnIndex
-     *            column index of the cell
-     * @param rowIndex
-     *            row index of the cell
-     * @param data
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param data the value.
      */
     @Override
     public void setMixed(long columnIndex, long rowIndex, Mixed data) {
@@ -1125,30 +899,25 @@ public void setMixed(long columnIndex, long rowIndex, Mixed data) {
         nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
     }
 
-    protected native void nativeSetMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed data);
-
     public void setLink(long columnIndex, long rowIndex, long value) {
         checkImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-
-    /**
-     * Add the value for to all cells in the column.
-     *
-     * @param columnIndex column index of the cell
-     * @param value
-     */
-    //!!!TODO: New. Support in highlevel API
-    @Override
-    public void adjust(long columnIndex, long value) {
+    //TODO: Clean up this function
+    private void insertSubTable(long columnIndex, long rowIndex, Object value) {
         checkImmutable();
-        nativeAddInt(nativePtr, columnIndex, value);
+        if (value != null) {
+            // insert rows in subtable recursively
+            Table subtable = getSubtableDuringInsert(columnIndex, rowIndex);
+            int rows = ((Object[])value).length;
+            for (int i=0; i<rows; ++i) {
+                Object rowArr = ((Object[])value)[i];
+                subtable.add((Object[])rowArr);
+            }
+        }
     }
 
-    protected native void nativeAddInt(long nativeViewPtr, long columnIndex, long value);
-
     public void addSearchIndex(long columnIndex) {
         checkImmutable();
         nativeAddSearchIndex(nativePtr, columnIndex);
@@ -1160,15 +929,12 @@ public void removeSearchIndex(long columnIndex) {
     }
 
     /**
-     * Define a primary key for this table. This needs to be called manually before inserting data
-     * into the table.
+     * Define a primary key for this table. This needs to be called manually before inserting data into the table.
      *
-     * @param columnName    Name of the field that will function primary key. "" or <code>null</code>
-     *                      will remove any previous set magic key.
-     *
-     * @throws              {@link io.realm.exceptions.RealmException} if it is not possible to set
-     *                      the primary key due to the column not having distinct values (ie.
-     *                      violating the primary key constraint).
+     * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
+     *                   previous set magic key.
+     * @throws {@link io.realm.exceptions.RealmException} if it is not possible to set the primary key due to the column
+     * not having distinct values (i.e. violating the primary key constraint).
      */
     public void setPrimaryKey(String columnName) {
         Table pkTable = getPrimaryKeyTable();
@@ -1178,7 +944,9 @@ public void setPrimaryKey(String columnName) {
         cachedPrimaryKeyColumnIndex = nativeSetPrimaryKey(pkTable.nativePtr, nativePtr, columnName);
     }
 
-    private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
+    public void setPrimaryKey(long columnIndex) {
+        setPrimaryKey(nativeGetColumnName(nativePtr, columnIndex));
+    }
 
     private Table getPrimaryKeyTable() {
         Group group = getTableGroup();
@@ -1188,8 +956,8 @@ private Table getPrimaryKeyTable() {
 
         Table pkTable = group.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
-            pkTable.addColumn(ColumnType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
-            pkTable.addColumn(ColumnType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
+            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
+            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
         } else {
             migratePrimaryKeyTableIfNeeded(group, pkTable);
         }
@@ -1197,15 +965,19 @@ private Table getPrimaryKeyTable() {
         return pkTable;
     }
 
-    // Migration required to fix https://github.com/realm/realm-java/issues/1059
-    // This will convert INTEGER column to the corresponding STRING column if needed.
-    // Any database created on Realm-Java 0.80.1 and below will have this error.
+    /*
+     * 1) Migration required to fix https://github.com/realm/realm-java/issues/1059
+     * This will convert INTEGER column to the corresponding STRING column if needed.
+     * Any database created on Realm-Java 0.80.1 and below will have this error.
+     *
+     * 2) Migration required to fix: https://github.com/realm/realm-java/issues/1703
+     * This will remove the prefix "class_" from all table names in the pk_column
+     * Any database created on Realm-Java 0.84.1 and below will have this error.
+     */
     private void migratePrimaryKeyTableIfNeeded(Group group, Table pkTable) {
         nativeMigratePrimaryKeyTableIfNeeded(group.nativePtr, pkTable.nativePtr);
     }
 
-    private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
-
     // Recursively look at parents until either a Group or null is found
     Group getTableGroup() {
         if (parent instanceof Group)  {
@@ -1217,30 +989,18 @@ Group getTableGroup() {
         }
     }
 
-    protected native void nativeAddSearchIndex(long nativePtr, long columnIndex);
-
-    protected native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
-
     public boolean hasSearchIndex(long columnIndex) {
         return nativeHasSearchIndex(nativePtr, columnIndex);
     }
 
-    protected native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
-
-
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
-
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
-
-
     boolean isImmutable() {
         if (!(parent instanceof Table)) {
             return parent != null && ((Group) parent).immutable;
@@ -1271,87 +1031,63 @@ public long sumLong(long columnIndex) {
         return nativeSumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeSumInt(long nativePtr, long columnIndex);
-
     @Override
-    public long maximumLong(long columnIndex) {
+    public Long maximumLong(long columnIndex) {
         return nativeMaximumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeMaximumInt(long nativePtr, long columnIndex);
-
     @Override
-    public long minimumLong(long columnIndex) {
+    public Long minimumLong(long columnIndex) {
         return nativeMinimumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeMinimumInt(long nativePtr, long columnnIndex);
-
     @Override
     public double averageLong(long columnIndex) {
         return nativeAverageInt(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageInt(long nativePtr, long columnIndex);
-
     // Floats
     @Override
     public double sumFloat(long columnIndex) {
         return nativeSumFloat(nativePtr, columnIndex);
     }
 
-    protected native double nativeSumFloat(long nativePtr, long columnIndex);
-
     @Override
-    public float maximumFloat(long columnIndex) {
+    public Float maximumFloat(long columnIndex) {
         return nativeMaximumFloat(nativePtr, columnIndex);
     }
 
-    protected native float nativeMaximumFloat(long nativePtr, long columnIndex);
-
     @Override
-    public float minimumFloat(long columnIndex) {
+    public Float minimumFloat(long columnIndex) {
         return nativeMinimumFloat(nativePtr, columnIndex);
     }
 
-    protected native float nativeMinimumFloat(long nativePtr, long columnnIndex);
-
     @Override
     public double averageFloat(long columnIndex) {
         return nativeAverageFloat(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageFloat(long nativePtr, long columnIndex);
-
     // Doubles
     @Override
     public double sumDouble(long columnIndex) {
         return nativeSumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeSumDouble(long nativePtr, long columnIndex);
-
     @Override
-    public double maximumDouble(long columnIndex) {
+    public Double maximumDouble(long columnIndex) {
         return nativeMaximumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeMaximumDouble(long nativePtr, long columnIndex);
-
     @Override
-    public double minimumDouble(long columnIndex) {
+    public Double minimumDouble(long columnIndex) {
         return nativeMinimumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeMinimumDouble(long nativePtr, long columnnIndex);
-
     @Override
     public double averageDouble(long columnIndex) {
         return nativeAverageDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageDouble(long nativePtr, long columnIndex);
-
     // Date aggregates
 
     @Override
@@ -1359,16 +1095,11 @@ public Date maximumDate(long columnIndex) {
         return new Date(nativeMaximumDate(nativePtr, columnIndex) * 1000);
     }
 
-    protected native long nativeMaximumDate(long nativePtr, long columnIndex);
-
     @Override
     public Date minimumDate(long columnIndex) {
         return new Date(nativeMinimumDate(nativePtr, columnIndex) * 1000);
     }
 
-    protected native long nativeMinimumDate(long nativePtr, long columnnIndex);
-
-
     //
     // Count
     //
@@ -1377,29 +1108,19 @@ public long count(long columnIndex, long value) {
         return nativeCountLong(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeCountLong(long nativePtr, long columnIndex, long value);
-
-
     public long count(long columnIndex, float value) {
         return nativeCountFloat(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeCountFloat(long nativePtr, long columnIndex, float value);
-
     public long count(long columnIndex, double value) {
         return nativeCountDouble(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeCountDouble(long nativePtr, long columnIndex, double value);
-
     @Override
     public long count(long columnIndex, String value) {
         return nativeCountString(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeCountString(long nativePtr, long columnIndex, String value);
-
-
     //
     // Searching methods.
     //
@@ -1418,50 +1139,55 @@ public TableQuery where() {
         }
     }
 
-    protected native long nativeWhere(long nativeTablePtr);
+    /**
+     * Returns the same rowIndex that is passed in via the {@code rowIndex}.
+     * This interface method allows for contains() usage in the {@link TableView} class.
+     * See {@link TableView#sourceRowIndex(long)} for more information.
+     *
+     * @param rowIndex the index of the row.
+     * @return the row index.
+     */
+    @Override
+    public long sourceRowIndex(long rowIndex) {
+        return rowIndex;
+    }
 
     @Override
     public long findFirstLong(long columnIndex, long value) {
         return nativeFindFirstInt(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
-
     @Override
     public long findFirstBoolean(long columnIndex, boolean value) {
         return nativeFindFirstBool(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
-
     @Override
     public long findFirstFloat(long columnIndex, float value) {
         return nativeFindFirstFloat(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
-
     @Override
     public long findFirstDouble(long columnIndex, double value) {
         return nativeFindFirstDouble(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
-
     @Override
     public long findFirstDate(long columnIndex, Date date) {
+        if (date == null) {
+            throw new IllegalArgumentException("null is not supported");
+        }
         return nativeFindFirstDate(nativePtr, columnIndex, date.getTime() / 1000);
     }
 
-    protected native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
-
     @Override
     public long findFirstString(long columnIndex, String value) {
+        if (value == null) {
+            throw new IllegalArgumentException("null is not supported");
+        }
         return nativeFindFirstString(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
-
     @Override
     public TableView findAllLong(long columnIndex, long value) {
         context.executeDelayedDisposal();
@@ -1474,8 +1200,6 @@ public TableView findAllLong(long columnIndex, long value) {
         }
     }
 
-    protected native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
-
     @Override
     public TableView findAllBoolean(long columnIndex, boolean value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1489,8 +1213,6 @@ public TableView findAllBoolean(long columnIndex, boolean value) {
         }
     }
 
-    protected native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
-
     @Override
     public TableView findAllFloat(long columnIndex, float value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1504,8 +1226,6 @@ public TableView findAllFloat(long columnIndex, float value) {
         }
     }
 
-    protected native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
-
     @Override
     public TableView findAllDouble(long columnIndex, double value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1519,8 +1239,6 @@ public TableView findAllDouble(long columnIndex, double value) {
         }
     }
 
-    protected native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-
     @Override
     public TableView findAllDate(long columnIndex, Date date) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1534,8 +1252,6 @@ public TableView findAllDate(long columnIndex, Date date) {
         }
     }
 
-    protected native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
-
     @Override
     public TableView findAllString(long columnIndex, String value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1549,8 +1265,6 @@ public TableView findAllString(long columnIndex, String value) {
         }
     }
 
-    protected native long nativeFindAllString(long nativePtr, long columnIndex, String value);
-
     // Experimental feature
     @Override
     public long lowerBoundLong(long columnIndex, long value) {
@@ -1561,23 +1275,17 @@ public long upperBoundLong(long columnIndex, long value) {
         return nativeUpperBoundInt(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
-    protected native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
-    
-    
     @Override
-    public Table pivot(long stringCol, long intCol, PivotType pivotType){
-        if (! this.getColumnType(stringCol).equals(ColumnType.STRING ))
+    public Table pivot(long stringCol, long intCol, PivotType pivotType) {
+        if (! this.getColumnType(stringCol).equals(RealmFieldType.STRING ))
             throw new UnsupportedOperationException("Group by column must be of type String");
-        if (! this.getColumnType(intCol).equals(ColumnType.INTEGER ))
+        if (! this.getColumnType(intCol).equals(RealmFieldType.INTEGER ))
             throw new UnsupportedOperationException("Aggregation column must be of type Int");
         Table result = new Table();
         nativePivot(nativePtr, stringCol, intCol, pivotType.value, result.nativePtr);
         return result;
     }
 
-    protected native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
-
     //
 
     public TableView getDistinctView(long columnIndex) {
@@ -1592,8 +1300,6 @@ public TableView getDistinctView(long columnIndex) {
         }
     }
 
-    protected native long nativeGetDistinctView(long nativePtr, long columnIndex);
-
     /**
      * Return the table name as it is in the associated group.
      *
@@ -1603,7 +1309,6 @@ public String getName() {
         return nativeGetName(nativePtr);
     }
 
-    protected native String nativeGetName(long nativeTablePtr);
 
     // Optimize
     public void optimize() {
@@ -1611,15 +1316,11 @@ public void optimize() {
         nativeOptimize(nativePtr);
     }
 
-    protected native void nativeOptimize(long nativeTablePtr);
-
     @Override
     public String toJson() {
         return nativeToJson(nativePtr);
     }
 
-    protected native String nativeToJson(long nativeTablePtr);
-
     @Override
     public String toString() {
         return nativeToString(nativePtr, INFINITE);
@@ -1630,15 +1331,11 @@ public String toString(long maxRows) {
         return nativeToString(nativePtr, maxRows);
     }
 
-    protected native String nativeToString(long nativeTablePtr, long maxRows);
-
     @Override
     public String rowToString(long rowIndex) {
         return nativeRowToString(nativePtr, rowIndex);
     }
 
-    protected native String nativeRowToString(long nativeTablePtr, long rowIndex);
-
     @Override
     public long sync() {
         throw new RuntimeException("Not supported for tables");
@@ -1647,4 +1344,135 @@ public long sync() {
     private void throwImmutable() {
         throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
     }
+
+    /**
+     * Compares the schema of the current instance of Table with another instance.
+     *
+     * @param table the instance to compare with. It cannot be null.
+     * @return {@code true} if the two instances have the same schema (column names and types).
+     */
+    public boolean hasSameSchema(Table table) {
+        if (table == null) {
+            throw new IllegalArgumentException("The argument cannot be null");
+        }
+        return nativeHasSameSchema(this.nativePtr, table.nativePtr);
+    }
+
+    /**
+     * Checks if a given table name is a meta-table, i.e. a table used by Realm to track its internal state.
+     */
+    public static boolean isMetaTable(String tableName) {
+        return (tableName.equals(METADATA_TABLE_NAME) || tableName.equals(PRIMARY_KEY_TABLE_NAME));
+    }
+
+    /**
+     * Report the current versioning counter for the table. The versioning counter is guaranteed to
+     * change when the contents of the table changes after advance_read() or promote_to_write(), or
+     * immediately after calls to methods which change the table.
+     *
+     * @return version_counter for the table.
+     */
+    public long version() {
+        return nativeVersion(nativePtr);
+    }
+
+    protected native long createNative();
+    static native void nativeClose(long nativeTablePtr);
+    private native boolean nativeIsValid(long nativeTablePtr);
+    private native boolean nativeIsRootTable(long nativeTablePtr);
+    private native long nativeAddColumn(long nativeTablePtr, int type, String name, boolean isNullable);
+    private native long nativeAddColumnLink(long nativeTablePtr, int type, String name, long targetTablePtr);
+    private native void nativeRenameColumn(long nativeTablePtr, long columnIndex, String name);
+    private native void nativeRemoveColumn(long nativeTablePtr, long columnIndex);
+    private native boolean nativeIsColumnNullable(long nativePtr, long columnIndex);
+    private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex);
+    private native void nativeConvertColumnToNotNullable(long nativePtr, long columnIndex);
+    private native void nativeUpdateFromSpec(long nativeTablePtr, TableSpec tableSpec);
+    private native long nativeSize(long nativeTablePtr);
+    private native void nativeClear(long nativeTablePtr);
+    private native long nativeGetColumnCount(long nativeTablePtr);
+    private native TableSpec nativeGetTableSpec(long nativeTablePtr);
+    private native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    private native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    private native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    private native void nativeRemove(long nativeTablePtr, long rowIndex);
+    private native void nativeRemoveLast(long nativeTablePtr);
+    private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
+    private native long nativeAddEmptyRow(long nativeTablePtr, long rows);
+    private native long nativeGetSortedView(long nativeTableViewPtr, long columnIndex, boolean ascending);
+    private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
+    private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native float nativeGetFloat(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native double nativeGetDouble(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetDateTime(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native String nativeGetString(long nativePtr, long columnIndex, long rowIndex);
+    private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
+    private native int nativeGetMixedType(long nativePtr, long columnIndex, long rowIndex);
+    private native Mixed nativeGetMixed(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
+    private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
+    private native long nativeGetSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetSubtableDuringInsert(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
+    native long nativeGetRowPtr(long nativePtr, long index);
+    private native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    private native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
+    private native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
+    private native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
+    private native void nativeSetDate(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    private native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
+    private native void nativeSetMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed data);
+    private native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
+    private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+    private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
+    private native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
+    private native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
+    private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
+    private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
+    private native long nativeSumInt(long nativePtr, long columnIndex);
+    private native long nativeMaximumInt(long nativePtr, long columnIndex);
+    private native long nativeMinimumInt(long nativePtr, long columnIndex);
+    private native double nativeAverageInt(long nativePtr, long columnIndex);
+    private native double nativeSumFloat(long nativePtr, long columnIndex);
+    private native float nativeMaximumFloat(long nativePtr, long columnIndex);
+    private native float nativeMinimumFloat(long nativePtr, long columnIndex);
+    private native double nativeAverageFloat(long nativePtr, long columnIndex);
+    private native double nativeSumDouble(long nativePtr, long columnIndex);
+    private native double nativeMaximumDouble(long nativePtr, long columnIndex);
+    private native double nativeMinimumDouble(long nativePtr, long columnIndex);
+    private native double nativeAverageDouble(long nativePtr, long columnIndex);
+    private native long nativeMaximumDate(long nativePtr, long columnIndex);
+    private native long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native long nativeCountLong(long nativePtr, long columnIndex, long value);
+    private native long nativeCountFloat(long nativePtr, long columnIndex, float value);
+    private native long nativeCountDouble(long nativePtr, long columnIndex, double value);
+    private native long nativeCountString(long nativePtr, long columnIndex, String value);
+    private native long nativeWhere(long nativeTablePtr);
+    private native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
+    private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
+    private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
+    private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
+    private native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
+    private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
+    private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
+    private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
+    private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
+    private native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
+    private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
+    private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
+    private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
+    private native long nativeGetDistinctView(long nativePtr, long columnIndex);
+    private native String nativeGetName(long nativeTablePtr);
+    private native void nativeOptimize(long nativeTablePtr);
+    private native String nativeToJson(long nativeTablePtr);
+    private native String nativeToString(long nativeTablePtr, long maxRows);
+    private native boolean nativeHasSameSchema(long thisTable, long otherTable);
+    private native long nativeVersion(long nativeTablePtr);
+    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
 }
diff --git a/realm/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
similarity index 70%
rename from realm/src/main/java/io/realm/internal/TableOrView.java
rename to realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 63435e8991..2dc6ce7c08 100644
--- a/realm/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -18,17 +18,19 @@
 
 import java.util.Date;
 
+import io.realm.RealmFieldType;
+
 /**
  * Specification of the common operations for the low-level table and view API.
  */
 public interface TableOrView {
 
-    public static final int NO_MATCH = -1;
+    int NO_MATCH = -1;
 
     void clear();
 
     /**
-     * Returns the table
+     * Returns the table.
      *
      * @return
      */
@@ -46,14 +48,13 @@
     /**
      * Checks whether the table/view is empty or not.
      *
-     * @return true if empty, otherwise false.
+     * @return {@code true} if empty, otherwise {@code false}.
      */
     boolean isEmpty();
 
     /**
      * Removes a particular row identified by the index from the table/view.
-     * [citation needed] The corresponding row of the table also get deleted for
-     * which the table/view is part of.
+     * [citation needed] The corresponding row of the table also gets deleted for which the table/view is part of.
      *
      * @param index
      */
@@ -67,11 +68,10 @@
 
     long getColumnIndex(String name);
 
-    ColumnType getColumnType(long columnIndex);
+    RealmFieldType getColumnType(long columnIndex);
 
     /**
-     * Get the long value of a cell of the table/view identified by the
-     * columnIndex and rowIndex.
+     * Gets the long value of a cell of the table/view identified by the columnIndex and rowIndex.
      *
      * @param columnIndex
      * @param rowIndex
@@ -80,8 +80,7 @@
     long getLong(long columnIndex, long rowIndex);
 
     /**
-     * Get the boolean value of a cell of the table identified by the
-     * columnIndex and rowIndex.
+     * Gets the boolean value of a cell of the table identified by the columnIndex and rowIndex.
      *
      * @param columnIndex
      * @param rowIndex
@@ -90,8 +89,7 @@
     boolean getBoolean(long columnIndex, long rowIndex);
 
     /**
-     * Get the float value of a cell of the table identified by the
-     * columnIndex and rowIndex.
+     * Gets the float value of a cell of the table identified by the columnIndex and rowIndex.
      *
      * @param columnIndex
      * @param rowIndex
@@ -100,8 +98,7 @@
     float getFloat(long columnIndex, long rowIndex);
 
     /**
-     * Get the double value of a cell of the table identified by the
-     * columnIndex and rowIndex.
+     * Gets the double value of a cell of the table identified by the columnIndex and rowIndex.
      *
      * @param columnIndex
      * @param rowIndex
@@ -110,8 +107,7 @@
     double getDouble(long columnIndex, long rowIndex);
 
     /**
-     * Gets the string value of a cell identified by the columnIndex and
-     * rowIndex of the cell.
+     * Gets the string value of a cell identified by the columnIndex and rowIndex of the cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -120,8 +116,8 @@
     String getString(long columnIndex, long rowIndex);
 
     /**
-     * Returns the Date value (java.util.Date) for a particular cell specified
-     * by the columnIndex and rowIndex of the cell.
+     * Returns the Date value (java.util.Date) for a particular cell specified by the columnIndex and rowIndex of the
+     * cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -130,8 +126,7 @@
     Date getDate(long columnIndex, long rowIndex);
 
     /**
-     * Returns the binary data for a cell identified by the columnIndex
-     * and rowIndex of that cell.
+     * Returns the binary data for a cell identified by the columnIndex and rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -144,8 +139,7 @@
     Mixed getMixed(long columnIndex, long rowIndex);
 
     /**
-     * Get the link index of a cell of the table/view identified by the
-     * columnIndex and rowIndex.
+     * Gets the link index of a cell of the table/view identified by the columnIndex and rowIndex.
      *
      * @param columnIndex
      * @param rowIndex
@@ -153,7 +147,7 @@
      */
     long getLink(long columnIndex, long rowIndex);
 
-    ColumnType getMixedType(long columnIndex, long rowIndex);
+    RealmFieldType getMixedType(long columnIndex, long rowIndex);
 
     Table getSubtable(long columnIndex, long rowIndex);
 
@@ -162,8 +156,7 @@
     long getSubtableSize(long columnIndex, long rowIndex);
 
     /**
-     * Sets the long value for a particular cell identified by columnIndex and
-     * rowIndex of that cell.
+     * Sets the long value for a particular cell identified by columnIndex and rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -172,8 +165,7 @@
     void setLong(long columnIndex, long rowIndex, long value);
 
     /**
-     * Sets the boolean value of a cell identified by the columnIndex and the
-     * rowIndex of that cell.
+     * Sets the boolean value of a cell identified by the columnIndex and the rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -182,8 +174,7 @@
     void setBoolean(long columnIndex, long rowIndex, boolean value);
 
     /**
-     * Sets the float value of a cell identified by the columnIndex and the
-     * rowIndex of that cell.
+     * Sets the float value of a cell identified by the columnIndex and the rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -192,8 +183,7 @@
     void setFloat(long columnIndex, long rowIndex, float value);
 
     /**
-     * Sets the double value of a cell identified by the columnIndex and the
-     * rowIndex of that cell.
+     * Sets the double value of a cell identified by the columnIndex and the rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -202,8 +192,8 @@
     void setDouble(long columnIndex, long rowIndex, double value);
 
     /**
-     * Sets the string value of a particular cell of the table/view identified
-     * by the columnIndex and the rowIndex of this table/view
+     * Sets the string value of a particular cell of the table/view identified by the columnIndex and the rowIndex of
+     * this table/view
      *
      * @param columnIndex
      * @param rowIndex
@@ -212,8 +202,7 @@
     void setString(long columnIndex, long rowIndex, String value);
 
     /**
-     * Sets the binary value for a particular cell identified by the
-     * rowIndex and columnIndex of the cell.
+     * Sets the binary value for a particular cell identified by the rowIndex and columnIndex of the cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -232,8 +221,7 @@
     void nullifyLink(long columnIndex, long rowIndex);
 
     /**
-     * Sets the link index for a particular cell identified by columnIndex and
-     * rowIndex of that cell.
+     * Sets the link index for a particular cell identified by columnIndex and rowIndex of that cell.
      *
      * @param columnIndex
      * @param rowIndex
@@ -241,32 +229,29 @@
      */
     void setLink(long columnIndex, long rowIndex, long value);
 
-    //Increments all rows in the specified column with the provided value
-    void adjust(long columnIndex, long value);
-
     long sumLong(long columnIndex);
 
-    long maximumLong(long columnIndex);
+    Long maximumLong(long columnIndex);
 
-    long minimumLong(long columnIndex);
+    Long minimumLong(long columnIndex);
 
     double averageLong(long columnIndex);
 
 
     double sumFloat(long columnIndex);
 
-    float maximumFloat(long columnIndex);
+    Float maximumFloat(long columnIndex);
 
-    float minimumFloat(long columnIndex);
+    Float minimumFloat(long columnIndex);
 
     double averageFloat(long columnIndex);
 
 
     double sumDouble(long columnIndex);
 
-    double maximumDouble(long columnIndex);
+    Double maximumDouble(long columnIndex);
 
-    double minimumDouble(long columnIndex);
+    Double minimumDouble(long columnIndex);
 
     double averageDouble(long columnIndex);
 
@@ -279,54 +264,54 @@
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the value to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstLong(long columnIndex, long value);
 
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the alue to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstBoolean(long columnIndex, boolean value);
 
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the value to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstFloat(long columnIndex, float value);
 
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the value to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstDouble(long columnIndex, double value);
 
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the value to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstDate(long columnIndex, Date value);
 
     /**
      * Searches for first occurrence of a value. Beware that the order in the column is undefined.
      *
-     * @param columnIndex   Column to search in.
-     * @param value         Value to search for.
-     * @return              Row index for the first match found or {@link #NO_MATCH}.
+     * @param columnIndex the column to search in.
+     * @param value the value to search for.
+     * @return the row index for the first match found or {@link #NO_MATCH}.
      */
     long findFirstString(long columnIndex, String value);
 
@@ -356,11 +341,19 @@
 
     TableQuery where();
 
+    /**
+     * Find a row with in the table or view with the given index.
+     *
+     * @param rowIndex the index of the row.
+     * @return the index if found, or -1 for not found.
+     */
+    long sourceRowIndex(long rowIndex);
+
     // Experimental:
 
     long count(long columnIndex, String value);
 
-    public enum PivotType {
+    enum PivotType {
         COUNT(0),
         SUM(1),
         AVG(2),
@@ -369,18 +362,18 @@
 
         final int value; // Package protected, accessible from Table and TableView
 
-        private PivotType(int value) {
+        PivotType(int value) {
             this.value = value;
         }
     }
 
-    public Table pivot(long stringCol, long intCol, PivotType pivotType);
+    Table pivot(long stringCol, long intCol, PivotType pivotType);
 
     /**
-     * Syncs the tableview with the underlying table data. It is not required to call this
-     * explicitly, all other API methods will automatically sync the view as well.
+     * Syncs the tableview with the underlying table data. It is not required to call this explicitly, all other API
+     * methods will automatically sync the view as well.
      *
-     * @return Version number for the updated tableview.
+     * @return the version number for the updated tableview.
      */
-    public long sync();
+    long sync();
 }
diff --git a/realm/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
similarity index 55%
rename from realm/src/main/java/io/realm/internal/TableQuery.java
rename to realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index e82eaa7c63..56c6e502a7 100644
--- a/realm/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -19,28 +19,50 @@
 import java.io.Closeable;
 import java.util.Date;
 
+import io.realm.Case;
+import io.realm.Sort;
+
 public class TableQuery implements Closeable {
     protected boolean DEBUG = false;
 
     protected long nativePtr;
-    protected final Table parent;
+    protected final Table table;
+    // Don't convert this into local variable and don't remove this.
+    // Core requests Query to hold the TableView reference which it is built from.
+    @SuppressWarnings({"unused"})
+    private final TableOrView origin; // Table or TableView which created this TableQuery
     private final Context context;
 
+    // All actions (find(), findAll(), sum(), etc.) must call validateQuery() before performing
+    // the actual action. The other methods must set queryValidated to false in order to enforce
+    // the first action to validate the syntax of the query.
     private boolean queryValidated = true;
 
     // TODO: Can we protect this?
-    public TableQuery(Context context, Table parent, long nativeQueryPtr){
-        if (DEBUG)
+    public TableQuery(Context context, Table table, long nativeQueryPtr) {
+        if (DEBUG) {
+            System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+        }
+        this.context = context;
+        this.table = table;
+        this.nativePtr = nativeQueryPtr;
+        this.origin = null;
+    }
+
+    public TableQuery(Context context, Table table, long nativeQueryPtr, TableOrView origin) {
+        if (DEBUG) {
             System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+        }
         this.context = context;
-        this.parent = parent;
+        this.table = table;
         this.nativePtr = nativeQueryPtr;
+        this.origin = origin;
     }
 
     public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
-                nativeClose(nativePtr);  
+                nativeClose(nativePtr);
 
                 if (DEBUG)
                     System.err.println("++++ Query CLOSE, ptr= " + nativePtr);
@@ -50,12 +72,10 @@ public void close() {
         }
     }
 
-    protected static native void nativeClose(long nativeQueryPtr);
-
     protected void finalize() {
         synchronized (context) {
             if (nativePtr != 0) {
-                context.asyncDisposeQuery(nativePtr); 
+                context.asyncDisposeQuery(nativePtr);
                 nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
             }
         }
@@ -74,57 +94,49 @@ private void validateQuery() {
         }
     }
 
-    protected native String nativeValidateQuery(long nativeQueryPtr);
-
     // Query TableView
     public TableQuery tableview(TableView tv) {
         nativeTableview(nativePtr, tv.nativePtr);
         return this;
     }
-    protected native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
 
     // Grouping
 
     public TableQuery group() {
         nativeGroup(nativePtr);
+        queryValidated = false;
         return this;
     }
-    protected native void nativeGroup(long nativeQueryPtr);
 
     public TableQuery endGroup() {
         nativeEndGroup(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeEndGroup(long nativeQueryPtr);
 
     public TableQuery subtable(long columnIndex) {
         nativeSubtable(nativePtr, columnIndex);
         queryValidated = false;
         return this;
     }
-    protected native void nativeSubtable(long nativeQueryPtr, long columnIndex);
 
     public TableQuery endSubtable() {
         nativeParent(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeParent(long nativeQueryPtr);
 
     public TableQuery or() {
         nativeOr(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeOr(long nativeQueryPtr);
 
     public TableQuery not() {
         nativeNot(nativePtr);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNot(long nativeQueryPtr);
 
     // Query for integer values.
 
@@ -133,50 +145,42 @@ public TableQuery equalTo(long columnIndexes[], long value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery notEqualTo(long columnIndex[], long value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThan(long columnIndex[], long value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], long value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery lessThan(long columnIndex[], long value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], long value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery between(long columnIndex[], long value1, long value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
-
 
     // Query for float values.
 
@@ -185,50 +189,42 @@ public TableQuery equalTo(long columnIndex[], float value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery notEqualTo(long columnIndex[], float value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery greaterThan(long columnIndex[], float value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], float value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery lessThan(long columnIndex[], float value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], float value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
 
     public TableQuery between(long columnIndex[], float value1, float value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
-
 
     // Query for double values.
 
@@ -237,72 +233,64 @@ public TableQuery equalTo(long columnIndex[], double value) {
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery notEqualTo(long columnIndex[], double value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery greaterThan(long columnIndex[], double value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery greaterThanOrEqual(long columnIndex[], double value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery lessThan(long columnIndex[], double value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery lessThanOrEqual(long columnIndex[], double value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
 
     public TableQuery between(long columnIndex[], double value1, double value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
-
 
     // Query for boolean values.
 
-    public TableQuery equalTo(long columnIndex[], boolean value){
+    public TableQuery equalTo(long columnIndex[], boolean value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
 
     // Query for Date values
 
     private final static String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
     public TableQuery equalTo(long columnIndex[], Date value){
-        if (value == null)
-            throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        if (value == null) {
+            nativeIsNull(nativePtr, columnIndex);
+        } else {
+            nativeEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        }
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery notEqualTo(long columnIndex[], Date value){
         if (value == null)
@@ -311,7 +299,6 @@ public TableQuery notEqualTo(long columnIndex[], Date value){
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
 
     public TableQuery greaterThan(long columnIndex[], Date value){
         if (value == null)
@@ -321,9 +308,6 @@ public TableQuery greaterThan(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
-
-
     public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
@@ -332,8 +316,6 @@ public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-
     public TableQuery lessThan(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
@@ -342,9 +324,6 @@ public TableQuery lessThan(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
-
-
     public TableQuery lessThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
@@ -353,8 +332,6 @@ public TableQuery lessThanOrEqual(long columnIndex[], Date value){
         return this;
     }
 
-    protected native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-
     public TableQuery between(long columnIndex[], Date value1, Date value2){
         if (value1 == null || value2 == null)
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
@@ -362,94 +339,81 @@ public TableQuery between(long columnIndex[], Date value1, Date value2){
         queryValidated = false;
         return this;
     }
-    protected native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
 
     // Query for String values.
-    
+
     private final static String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
 
     // Equal
-    public TableQuery equalTo(long[] columnIndexes, String value, boolean caseSensitive) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
-        nativeEqual(nativePtr, columnIndexes, value, caseSensitive);
+    public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
+        nativeEqual(nativePtr, columnIndexes, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
+
     public TableQuery equalTo(long[] columnIndexes, String value) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
         nativeEqual(nativePtr, columnIndexes, value, true);
         queryValidated = false;
         return this;
     }
-    protected native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
 
     // Not Equal
-    public TableQuery notEqualTo(long columnIndex[], String value, boolean caseSensitive) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
-        nativeNotEqual(nativePtr, columnIndex, value, caseSensitive);
+    public TableQuery notEqualTo(long columnIndex[], String value, Case caseSensitive) {
+        nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
     public TableQuery notEqualTo(long columnIndex[], String value) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
         nativeNotEqual(nativePtr, columnIndex, value, true);
         queryValidated = false;
         return this;
     }
-    protected native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
 
-    public TableQuery beginsWith(long columnIndices[], String value, boolean caseSensitive) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
-        nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive);
+    public TableQuery beginsWith(long columnIndices[], String value, Case caseSensitive) {
+        nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
+
     public TableQuery beginsWith(long columnIndices[], String value) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
         nativeBeginsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
-    protected native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
-    public TableQuery endsWith(long columnIndices[], String value, boolean caseSensitive) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
-        nativeEndsWith(nativePtr, columnIndices, value, caseSensitive);
+    public TableQuery endsWith(long columnIndices[], String value, Case caseSensitive) {
+        nativeEndsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
+
     public TableQuery endsWith(long columnIndices[], String value) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
         nativeEndsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
-    protected native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
-    public TableQuery contains(long columnIndices[], String value, boolean caseSensitive) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
-        nativeContains(nativePtr, columnIndices, value, caseSensitive);
+    public TableQuery contains(long columnIndices[], String value, Case caseSensitive) {
+        nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
+
     public TableQuery contains(long columnIndices[], String value) {
-        if (value == null)
-            throw new IllegalArgumentException(STRING_NULL_ERROR_MESSAGE);
         nativeContains(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
-    protected native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
 
+    public TableQuery isEmpty(long[] columnIndices) {
+        nativeIsEmpty(nativePtr, columnIndices);
+        queryValidated = false;
+        return this;
+    }
+
+    public TableQuery isNotEmpty(long[] columnIndices) {
+        return not().isEmpty(columnIndices);
+    }
 
     // Searching methods.
 
@@ -463,7 +427,20 @@ public long find() {
         return nativeFind(nativePtr, 0);
     }
 
-    protected native long nativeFind(long nativeQueryPtr, long fromTableRow);
+    /**
+     * Performs a find query then handover the resulted Row (ready to be imported by another thread/shared_group).
+     *
+     * @param bgSharedGroupPtr current shared_group from which to operate the query.
+     * @param nativeReplicationPtr replication pointer associated with the shared_group.
+     * @param ptrQuery query to run the the find against.
+     * @return pointer to the handover result (table_view).
+     */
+    public long findWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindWithHandover(bgSharedGroupPtr, ptrQuery, 0);
+    }
 
     public TableView findAll(long start, long end, long limit) {
         validateQuery();
@@ -472,7 +449,7 @@ public TableView findAll(long start, long end, long limit) {
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, start, end, limit);
         try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
+            return new TableView(this.context, this.table, nativeViewPtr, this);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
@@ -486,14 +463,67 @@ public TableView findAll() {
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAll(nativePtr, 0, Table.INFINITE, Table.INFINITE);
         try {
-            return new TableView(this.context, this.parent, nativeViewPtr);
+            return new TableView(this.context, this.table, nativeViewPtr, this);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
         }
     }
 
-    protected native long nativeFindAll(long nativeQueryPtr, long start, long end, long limit);
+    // handover find* methods
+    // this will use a background SharedGroup to import the query (using the handover object)
+    // run the query, and return the table view to the caller SharedGroup using the handover object.
+    public long findAllWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindAllWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE);
+    }
+
+    public long findDistinctWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery, long columnIndex) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeGetDistinctViewWithHandover(bgSharedGroupPtr, ptrQuery, columnIndex);
+    }
+
+    public long findAllSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long columnIndex, Sort sortOrder) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        return nativeFindAllSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
+    }
+
+    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long[] columnIndices, Sort[] sortOrders) {
+        validateQuery();
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        context.executeDelayedDisposal();
+        boolean[] ascendings = getNativeSortOrderValues(sortOrders);
+        return nativeFindAllMultiSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
+    }
+
+    // Suppose to be called from the caller SharedGroup thread
+    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) {
+        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
+        try {
+            return new TableView(this.context, this.table, nativeTvPtr);
+        } catch (RuntimeException e) {
+            if (nativeTvPtr != 0) {
+                TableView.nativeClose(nativeTvPtr);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Handovers the query, so it can be used by other SharedGroup (in different thread)
+     *
+     * @param callerSharedGroupPtr native pointer to the SharedGroup holding the query
+     * @return native pointer to the handover query
+     */
+    public long handoverQuery(long callerSharedGroupPtr) {
+        return nativeHandoverQuery(callerSharedGroupPtr, nativePtr);
+    }
 
     //
     // Aggregation methods
@@ -509,30 +539,24 @@ public long sumInt(long columnIndex) {
         validateQuery();
         return nativeSumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeSumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
-    public long maximumInt(long columnIndex, long start, long end, long limit) {
+    public Long maximumInt(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMaximumInt(nativePtr, columnIndex, start, end, limit);
     }
-    public long maximumInt(long columnIndex) {
+    public Long maximumInt(long columnIndex) {
         validateQuery();
         return nativeMaximumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeMaximumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
-    public long minimumInt(long columnIndex, long start, long end, long limit) {
+    public Long minimumInt(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMinimumInt(nativePtr, columnIndex, start, end, limit);
     }
-    public long minimumInt(long columnIndex) {
+    public Long minimumInt(long columnIndex) {
         validateQuery();
         return nativeMinimumInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native long nativeMinimumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     public double averageInt(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -542,8 +566,6 @@ public double averageInt(long columnIndex) {
         validateQuery();
         return nativeAverageInt(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     // float aggregation
 
@@ -555,30 +577,24 @@ public double sumFloat(long columnIndex) {
         validateQuery();
         return nativeSumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeSumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-
-    public float maximumFloat(long columnIndex, long start, long end, long limit) {
+    public Float maximumFloat(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMaximumFloat(nativePtr, columnIndex, start, end, limit);
     }
-    public float maximumFloat(long columnIndex) {
+    public Float maximumFloat(long columnIndex) {
         validateQuery();
         return nativeMaximumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native float nativeMaximumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
-    public float minimumFloat(long columnIndex, long start, long end, long limit) {
+    public Float minimumFloat(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMinimumFloat(nativePtr, columnIndex, start, end, limit);
     }
-    public float minimumFloat(long columnIndex) {
+    public Float minimumFloat(long columnIndex) {
         validateQuery();
         return nativeMinimumFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native float nativeMinimumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     public double averageFloat(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -588,8 +604,6 @@ public double averageFloat(long columnIndex) {
         validateQuery();
         return nativeAverageFloat(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     // double aggregation
 
@@ -601,30 +615,24 @@ public double sumDouble(long columnIndex) {
         validateQuery();
         return nativeSumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeSumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
-    public double maximumDouble(long columnIndex, long start, long end, long limit) {
+    public Double maximumDouble(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMaximumDouble(nativePtr, columnIndex, start, end, limit);
     }
-    public double maximumDouble(long columnIndex) {
+    public Double maximumDouble(long columnIndex) {
         validateQuery();
         return nativeMaximumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-
-    public double minimumDouble(long columnIndex, long start, long end, long limit) {
+    public Double minimumDouble(long columnIndex, long start, long end, long limit) {
         validateQuery();
         return nativeMinimumDouble(nativePtr, columnIndex, start, end, limit);
     }
-    public double minimumDouble(long columnIndex) {
+    public Double minimumDouble(long columnIndex) {
         validateQuery();
         return nativeMinimumDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     public double averageDouble(long columnIndex, long start, long end, long limit) {
         validateQuery();
@@ -634,39 +642,55 @@ public double averageDouble(long columnIndex) {
         validateQuery();
         return nativeAverageDouble(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
     }
-    protected native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
     // date aggregation
 
     public Date maximumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        return new Date(nativeMaximumDate(nativePtr, columnIndex, start, end, limit) * 1000);
+        Long result = nativeMaximumDate(nativePtr, columnIndex, start, end, limit);
+        if (result != null) {
+            return new Date(result * 1000);
+        }
+        return null;
     }
     public Date maximumDate(long columnIndex) {
         validateQuery();
-        return new Date(nativeMaximumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE) * 1000);
+        Long result = nativeMaximumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        if (result != null) {
+            return new Date(result * 1000);
+        }
+        return null;
     }
-    protected native long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     public Date minimumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        return new Date(nativeMinimumDate(nativePtr, columnIndex, start, end, limit) * 1000);
+        Long result = nativeMinimumDate(nativePtr, columnIndex, start, end, limit);
+        if (result != null) {
+            return new Date(result * 1000);
+        }
+        return null;
     }
     public Date minimumDate(long columnIndex) {
         validateQuery();
-        return new Date(nativeMinimumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE) * 1000);
+        Long result = nativeMinimumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        if (result != null) {
+            return new Date(result * 1000);
+        }
+        return null;
     }
-    protected native long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-
 
     // isNull and isNotNull
-    public TableQuery isNull(long columnIndex) {
-        nativeIsNull(nativePtr, columnIndex);
+    public TableQuery isNull(long columnIndices[]) {
+        nativeIsNull(nativePtr, columnIndices);
+        queryValidated = false;
         return this;
     }
 
-    protected native void nativeIsNull(long nativePtr, long columnIndex);
+    public TableQuery isNotNull(long columnIndices[]) {
+        nativeIsNotNull(nativePtr, columnIndices);
+        queryValidated = false;
+        return this;
+    }
 
     // count
 
@@ -681,25 +705,106 @@ public long count() {
         return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    protected native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
-
-
     // Deletion.
     public long remove(long start, long end) {
         validateQuery();
-        if (parent.isImmutable()) throwImmutable();
+        if (table.isImmutable()) throwImmutable();
         return nativeRemove(nativePtr, start, end, Table.INFINITE);
     }
 
     public long remove() {
         validateQuery();
-        if (parent.isImmutable()) throwImmutable();
+        if (table.isImmutable()) throwImmutable();
         return nativeRemove(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    protected native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
+    /**
+     * Converts a list of sort orders to their native values.
+     */
+    public static boolean[] getNativeSortOrderValues(Sort[] sortOrders) {
+        boolean[] nativeValues = new boolean[sortOrders.length];
+        for (int i = 0; i < sortOrders.length; i++) {
+            nativeValues[i] = sortOrders[i].getValue();
+        }
+        return nativeValues;
+    }
 
     private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
     }
+
+    protected static native void nativeClose(long nativeQueryPtr);
+    private native String nativeValidateQuery(long nativeQueryPtr);
+    private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
+    private native void nativeGroup(long nativeQueryPtr);
+    private native void nativeEndGroup(long nativeQueryPtr);
+    private native void nativeSubtable(long nativeQueryPtr, long columnIndex);
+    private native void nativeParent(long nativeQueryPtr);
+    private native void nativeOr(long nativeQueryPtr);
+    private native void nativeNot(long nativeQueryPtr);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
+    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
+    private native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
+    private native long nativeFind(long nativeQueryPtr, long fromTableRow);
+    private native long nativeFindAll(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeSumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMaximumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMinimumInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageInt(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeSumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Float nativeMaximumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Float nativeMinimumFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageFloat(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeSumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native void nativeIsNull(long nativePtr, long columnIndices[]);
+    private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
+    private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
+    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr);
+    private native long nativeHandoverQuery(long callerSharedGroupPtr, long nativeQueryPtr);
+    public static native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending);
+    public static native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit);
+    public static native long nativeGetDistinctViewWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long columnIndex);
+    public static native long nativeFindWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long fromTableRow);
+    public static native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending);
+    public static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedGroupPtr);
+    public static native void nativeCloseQueryHandover(long nativePtr);
+    public static native long[] nativeBatchUpdateQueries(long bgSharedGroupPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder);
 }
diff --git a/realm/src/main/java/io/realm/internal/TableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
similarity index 93%
rename from realm/src/main/java/io/realm/internal/TableSchema.java
rename to realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
index f1d56ed882..0b7f8dfbe4 100644
--- a/realm/src/main/java/io/realm/internal/TableSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
@@ -17,11 +17,13 @@
 package io.realm.internal;
 
 
+import io.realm.RealmFieldType;
+
 public interface TableSchema {
 
     TableSchema getSubtableSchema(long columnIndex);
 
-    long addColumn(ColumnType type, String name);
+    long addColumn(RealmFieldType type, String name);
 
     void removeColumn(long columnIndex);
 
diff --git a/realm/src/main/java/io/realm/internal/TableSpec.java b/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
similarity index 88%
rename from realm/src/main/java/io/realm/internal/TableSpec.java
rename to realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
index c5242e536d..b3a7cfbcf6 100644
--- a/realm/src/main/java/io/realm/internal/TableSpec.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
@@ -19,18 +19,21 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+
+@Keep
 public class TableSpec {
 
     public static class ColumnInfo {
 
-        protected final ColumnType type;
+        protected final RealmFieldType type;
         protected final String name;
         protected final TableSpec tableSpec;
 
-        public ColumnInfo(ColumnType type, String name) {
+        public ColumnInfo(RealmFieldType type, String name) {
             this.name = name;
             this.type = type;
-            this.tableSpec = (type == ColumnType.TABLE) ? new TableSpec() : null;
+            this.tableSpec = (type == RealmFieldType.UNSUPPORTED_TABLE) ? new TableSpec() : null;
         }
 
         @Override
@@ -74,7 +77,7 @@ public TableSpec() {
         columnInfos = new ArrayList<ColumnInfo>();
     }
 
-    public void addColumn(ColumnType type, String name) {
+    public void addColumn(RealmFieldType type, String name) {
         if (name.length() > 63) {
             throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
         }
@@ -82,14 +85,14 @@ public void addColumn(ColumnType type, String name) {
     }
 
     protected void addColumn(int colTypeIndex, String name) {
-        addColumn(ColumnType.fromNativeValue(colTypeIndex), name);
+        addColumn(RealmFieldType.fromNativeValue(colTypeIndex), name);
     }
 
     public TableSpec addSubtableColumn(String name) {
         if (name.length() > 63) {
             throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
         }
-        ColumnInfo columnInfo = new ColumnInfo(ColumnType.TABLE, name);
+        ColumnInfo columnInfo = new ColumnInfo(RealmFieldType.UNSUPPORTED_TABLE, name);
         columnInfos.add(columnInfo);
         return columnInfo.tableSpec;
     }
@@ -102,7 +105,7 @@ public long getColumnCount() {
         return columnInfos.size();
     }
 
-    public ColumnType getColumnType(long columnIndex) {
+    public RealmFieldType getColumnType(long columnIndex) {
         return columnInfos.get((int) columnIndex).type;
     }
 
diff --git a/realm/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
similarity index 58%
rename from realm/src/main/java/io/realm/internal/TableView.java
rename to realm/realm-library/src/main/java/io/realm/internal/TableView.java
index da409689b9..1c0aed2c02 100644
--- a/realm/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -20,63 +20,52 @@
 import java.util.Date;
 import java.util.List;
 
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+import io.realm.internal.log.RealmLog;
 
 /**
- * This class represents a view of a particular table. We can think of
- * a tableview is a subset of a table. It contains less than or
- * equal to the number of entries of a table. A table view is often a
- * result of a query.
- *
- * The view don't copy data from the table, but merely has a list of
- * row-references into the original table with the real data.
- *
- * The class serves as a base class of all table view. It is a raw level table view, users
- * are not encouraged to use this class. Instead users are advised to use
- * the generated subclass version of the table.
- *
- * Let us assume we are going to keep track of a table to store the employees
- * of a company or an organization.
- *
- * Following is a small example how to use the autogenerated class of the
- * tableview. For that purpose we will first define the spec of an employee
- * entity
- *
- *  @DefineTable
- *  public class employee {
- *      String name;
- *      long age;
- *      boolean hired;
- *      byte[] imageData;
- *  }
- *
- * Once this class is compiled along with Realm annotation processor
- * this will produce following classes.
- *
- * 1. Employee
- * 2. EmployeeTable
- * 3. EmployeeView.
- *
- * In this class context our interest is EmployeeView which will be inherited from
- * this class.
- *
- * The generated class will have more specialized method to do operations on TableView.
+ * This class represents a view of a particular table. We can think of a tableview as a subset of a table. It contains
+ * less than or equal to the number of entries of a table. A table view is often a result of a query.
  *
+ * The view doesn't copy data from the table, but contains merely a list of row-references into the original table
+ * with the real data.
  */
 public class TableView implements TableOrView, Closeable {
-    protected boolean DEBUG = false; //true;
+    private static final boolean DEBUG = false; //true;
+    // Don't convert this into local variable and don't remove this.
+    // Core requests TableView to hold the Query reference.
+    @SuppressWarnings({"unused"})
+    private final TableQuery query; // the query which created this TableView
 
-     /**
-     * Creates a TableView with already created Java TableView Object and a
-     * native native TableView object reference. The method is not supposed to
-     * be called by the user of the db. The method is for internal use only.
+    /**
+     * Creates a TableView. This constructor is used if the TableView is created from a table.
      *
+     * @param context
+     * @param parent
+     * @param nativePtr
+     */
+    protected TableView(Context context, Table parent, long nativePtr) {
+        this.context = context;
+        this.parent = parent;
+        this.nativePtr = nativePtr;
+        this.query = null;
+    }
+
+    /**
+     * Creates a TableView with already created Java TableView Object and a native native TableView object reference.
+     * The method is not supposed to be called by the user of the db. The method is for internal use only.
+     *
+     * @param context
      * @param parent A table.
-     * @param nativePtr pointer to table.
+     * @param nativePtr pointer to table view.
+     * @param query a reference to the query which the table view is based.
      */
-    protected TableView(Context context, Table parent, long nativePtr){
+    protected TableView(Context context, Table parent, long nativePtr, TableQuery query) {
         this.context = context;
         this.parent = parent;
         this.nativePtr = nativePtr;
+        this.query = query;
     }
 
     @Override
@@ -85,19 +74,20 @@ public Table getTable() {
     }
 
     @Override
-    public void close(){
+    public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
                 
-                if (DEBUG) 
-                    System.err.println("==== TableView CLOSE, ptr= " + nativePtr);
-              
+                if (DEBUG) {
+                    RealmLog.d("==== TableView CLOSE, ptr= " + nativePtr);
+                }
                 nativePtr = 0;
             } 
         }
     }
-    
+
+    @Override
     protected void finalize() {
         synchronized (context) {
             if (nativePtr != 0) {
@@ -107,12 +97,10 @@ protected void finalize() {
         }
     }
 
-    protected static native void nativeClose(long nativeViewPtr);
-
     /**
      * Checks whether this table is empty or not.
      *
-     * @return true if empty, otherwise false.
+     * @return {@code true} if empty, otherwise {@code false}.
      */
     @Override
     public boolean isEmpty(){
@@ -120,28 +108,25 @@ public boolean isEmpty(){
     }
 
     /**
-     * Get the number of entries/rows of this table.
+     * Gets the number of entries/rows of this table.
      *
-     * @return The number of rows.
+     * @return the number of rows.
      */
     @Override
     public long size() {
         return nativeSize(nativePtr);
     }
 
-    protected native long nativeSize(long nativeViewPtr);
-
     /**
-     * Returns the index of the row in the source table
-     * @param rowIndex in the TableView
-     * @return the translated row number in the source table
+     * Returns the index of the row in the source table.
+     *
+     * @param rowIndex row index in the TableView.
+     * @return the translated row number in the source table.
      */
     public long getSourceRowIndex(long rowIndex) {
         return nativeGetSourceRowIndex(nativePtr, rowIndex);
     }
 
-    protected native long nativeGetSourceRowIndex(long nativeViewPtr, long rowIndex);
-
     /**
      * Returns the number of columns in the table.
      *
@@ -152,27 +137,22 @@ public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
     }
 
-    protected native long nativeGetColumnCount(long nativeViewPtr);
-
     /**
-     * Returns the name of a column identified by columnIndex. Notice that the
-     * index is zero based.
+     * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
      *
-     * @param columnIndex the column index
-     * @return the name of the column
+     * @param columnIndex the column index.
+     * @return the name of the column.
      */
     @Override
     public String getColumnName(long columnIndex) {
         return nativeGetColumnName(nativePtr, columnIndex);
     }
 
-    protected native String nativeGetColumnName(long nativeViewPtr, long columnIndex);
-
     /**
      * Returns the 0-based index of a column based on the name.
      *
-     * @param columnName column name
-     * @return the index, -1 if not found
+     * @param columnName column name.
+     * @return the index, {@code -1} if not found.
      */
     @Override
     public long getColumnIndex(String columnName) {
@@ -180,25 +160,20 @@ public long getColumnIndex(String columnName) {
             throw new IllegalArgumentException("Column name can not be null.");
         return nativeGetColumnIndex(nativePtr, columnName);
     }
-    
-    protected native long nativeGetColumnIndex(long nativeViewPtr, String columnName);
-
 
     /**
-     * Get the type of a column identified by the columnIdex.
+     * Gets the type of a column identified by the columnIndex.
      *
      * @param columnIndex index of the column.
-     * @return Type of the particular column.
+     * @return type of the particular column.
      */
     @Override
-    public ColumnType getColumnType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
+    public RealmFieldType getColumnType(long columnIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
     }
 
-    protected native int nativeGetColumnType(long nativeViewPtr, long columnIndex);
-
     /**
-     * Get the value of the particular (integer) cell.
+     * Gets the value of the particular (integer) cell.
      *
      * @param columnIndex 0 based index value of the column.
      * @param rowIndex 0 based row value of the column.
@@ -209,10 +184,8 @@ public long getLong(long columnIndex, long rowIndex){
         return nativeGetLong(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetLong(long nativeViewPtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of the particular (boolean) cell.
+     * Gets the value of the particular (boolean) cell.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param rowIndex 0 based index of the row.
@@ -223,10 +196,8 @@ public boolean getBoolean(long columnIndex, long rowIndex){
         return nativeGetBoolean(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native boolean nativeGetBoolean(long nativeViewPtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of the particular (float) cell.
+     * Gets the value of the particular (float) cell.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param rowIndex 0 based index of the row.
@@ -237,10 +208,8 @@ public float getFloat(long columnIndex, long rowIndex){
         return nativeGetFloat(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native float nativeGetFloat(long nativeViewPtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of the particular (double) cell.
+     * Gets the value of the particular (double) cell.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param rowIndex 0 based index of the row.
@@ -251,10 +220,8 @@ public double getDouble(long columnIndex, long rowIndex){
         return nativeGetDouble(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native double nativeGetDouble(long nativeViewPtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of the particular (date) cell.
+     * Gets the value of the particular (date) cell.
      *
      * @param columnIndex 0 based index value of the cell column.
      * @param rowIndex 0 based index of the row.
@@ -265,28 +232,23 @@ public Date getDate(long columnIndex, long rowIndex){
         return new Date(nativeGetDateTimeValue(nativePtr, columnIndex, rowIndex)*1000);
     }
 
-    protected native long nativeGetDateTimeValue(long nativeViewPtr, long columnIndex, long rowIndex);
-
     /**
-     * Get the value of a (string )cell.
+     * Gets the value of a (string )cell.
      *
-     * @param columnIndex 0 based index value of the column
+     * @param columnIndex 0 based index value of the column.
      * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell
+     * @return value of the particular cell.
      */
     @Override
     public String getString(long columnIndex, long rowIndex){
         return nativeGetString(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native String nativeGetString(long nativeViewPtr, long columnInde, long rowIndex);
-
-
     /**
-     * Get the  value of a (binary) cell.
+     * Gets the  value of a (binary) cell.
      *
-     * @param columnIndex 0 based index value of the cell column
-     * @param rowIndex 0 based index value of the cell row
+     * @param columnIndex 0 based index value of the cell column.
+     * @param rowIndex 0 based index value of the cell row.
      * @return value of the particular cell.
      */
     /*
@@ -303,29 +265,20 @@ public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex){
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-
     @Override
-    public ColumnType getMixedType(long columnIndex, long rowIndex) {
-        return ColumnType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
+    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
     }
 
-    protected native int nativeGetMixedType(long nativeViewPtr, long columnIndex, long rowIndex);
-
     @Override
     public Mixed getMixed(long columnIndex, long rowIndex){
         return nativeGetMixed(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native Mixed nativeGetMixed(long nativeViewPtr, long columnIndex, long rowIndex);
-
-
     public long getLink(long columnIndex, long rowIndex){
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
-
     @Override
     public Table getSubtable(long columnIndex, long rowIndex) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -341,32 +294,25 @@ public Table getSubtable(long columnIndex, long rowIndex) {
         }
     }
 
-    protected native long nativeGetSubtable(long nativeViewPtr, long columnIndex, long rowIndex);
-
     @Override
     public long getSubtableSize(long columnIndex, long rowIndex) {
         return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-
     @Override
     public void clearSubtable(long columnIndex, long rowIndex) {
         if (parent.isImmutable()) throwImmutable();
         nativeClearSubtable(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-
-
     // Methods for setting values.
 
     /**
      * Sets the value for a particular (integer) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setLong(long columnIndex, long rowIndex, long value){
@@ -374,14 +320,12 @@ public void setLong(long columnIndex, long rowIndex, long value){
         nativeSetLong(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
-
     /**
      * Sets the value for a particular (boolean) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setBoolean(long columnIndex, long rowIndex, boolean value){
@@ -389,14 +333,12 @@ public void setBoolean(long columnIndex, long rowIndex, boolean value){
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
-
     /**
      * Sets the value for a particular (float) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setFloat(long columnIndex, long rowIndex, float value){
@@ -404,14 +346,12 @@ public void setFloat(long columnIndex, long rowIndex, float value){
         nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
-
     /**
      * Sets the value for a particular (double) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setDouble(long columnIndex, long rowIndex, double value){
@@ -419,14 +359,12 @@ public void setDouble(long columnIndex, long rowIndex, double value){
         nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetDouble(long nativeViewPtr, long columnIndex, long rowIndex, double value);
-
     /**
      * Sets the value for a particular (date) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setDate(long columnIndex, long rowIndex, Date value){
@@ -434,14 +372,12 @@ public void setDate(long columnIndex, long rowIndex, Date value){
         nativeSetDateTimeValue(nativePtr, columnIndex, rowIndex, value.getTime()/1000);
     }
 
-    protected native void nativeSetDateTimeValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
-
     /**
      * Sets the value for a particular (sting) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param value
+     * @param columnIndex column index of the.
+     * @param rowIndex row index of the cell.
+     * @param value the value.
      */
     @Override
     public void setString(long columnIndex, long rowIndex, String value){
@@ -449,14 +385,12 @@ public void setString(long columnIndex, long rowIndex, String value){
         nativeSetString(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
-
     /**
      * Sets the value for a particular (binary) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param data
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param data the value.
      */
     /*
     @Override
@@ -474,14 +408,12 @@ public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data){
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    protected native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-
     /**
      * Sets the value for a particular (mixed typed) cell.
      *
-     * @param columnIndex column index of the cell
-     * @param rowIndex row index of the cell
-     * @param data
+     * @param columnIndex column index of the cell.
+     * @param rowIndex row index of the cell.
+     * @param data the value.
      */
     @Override
     public void setMixed(long columnIndex, long rowIndex, Mixed data){
@@ -489,42 +421,19 @@ public void setMixed(long columnIndex, long rowIndex, Mixed data){
         nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
     }
 
-    protected native void nativeSetMixed(long nativeViewPtr, long columnIndex, long rowIndex, Mixed value);
-
     public void setLink(long columnIndex, long rowIndex, long value){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
-    protected native void nativeSetLink(long nativeViewPtr, long columnIndex, long rowIndex, long value);
-
-
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
-
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
 
-    protected native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
-
-    /**
-     * Add the value for to all cells in the column.
-     *
-     * @param columnIndex column index of the cell
-     * @param value
-     */
-    @Override
-    public void adjust(long columnIndex, long value) {
-        if (parent.isImmutable()) throwImmutable();
-        nativeAddInt(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeAddInt(long nativeViewPtr, long columnIndex, long value);
-
     // Methods for deleting.
     @Override
     public void clear(){
@@ -532,13 +441,11 @@ public void clear(){
         nativeClear(nativePtr);
     }
 
-    protected native void nativeClear(long nativeViewPtr);
-
     /**
      * Removes a particular row identified by the index from the tableview.
      * The corresponding row of the underlying table also get deleted.
      *
-     * @param rowIndex the row index
+     * @param rowIndex the row index.
      */
     @Override
     public void remove(long rowIndex){
@@ -546,8 +453,6 @@ public void remove(long rowIndex){
         nativeRemoveRow(nativePtr, rowIndex);
     }
 
-    protected native void nativeRemoveRow(long nativeViewPtr, long rowIndex);
-
     @Override
     public void removeLast() {
         if (parent.isImmutable()) throwImmutable();
@@ -562,44 +467,31 @@ public long findFirstLong(long columnIndex, long value){
         return nativeFindFirstInt(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstInt(long nativeTableViewPtr, long columnIndex, long value);
-
     @Override
     public long findFirstBoolean(long columnIndex, boolean value) {
         return nativeFindFirstBool(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
-
     @Override
     public long findFirstFloat(long columnIndex, float value) {
         return nativeFindFirstFloat(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
-
     @Override
     public long findFirstDouble(long columnIndex, double value) {
         return nativeFindFirstDouble(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
-
     @Override
     public long findFirstDate(long columnIndex, Date date) {
         return nativeFindFirstDate(nativePtr, columnIndex, date.getTime()/1000);
     }
 
-    protected native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
-
     @Override
     public long findFirstString(long columnIndex, String value){
         return nativeFindFirstString(nativePtr, columnIndex, value);
     }
 
-    protected native long nativeFindFirstString(long nativePtr, long columnIndex, String value);
-
-
     // Search for all matches
 
     // TODO..
@@ -627,8 +519,6 @@ public TableView findAllLong(long columnIndex, long value){
         }
     }
 
-    protected native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
-
     @Override
     public TableView findAllBoolean(long columnIndex, boolean value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -642,8 +532,6 @@ public TableView findAllBoolean(long columnIndex, boolean value) {
         }  
     }
 
-    protected native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
-
     @Override
     public TableView findAllFloat(long columnIndex, float value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -657,8 +545,6 @@ public TableView findAllFloat(long columnIndex, float value) {
         }  
     }
 
-    protected native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
-
     @Override
     public TableView findAllDouble(long columnIndex, double value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -672,8 +558,6 @@ public TableView findAllDouble(long columnIndex, double value) {
         }   
     }
 
-    protected native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-
     @Override
     public TableView findAllDate(long columnIndex, Date date) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -687,8 +571,6 @@ public TableView findAllDate(long columnIndex, Date date) {
         }  
     }
 
-    protected native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
-
     @Override
     public TableView findAllString(long columnIndex, String value){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -702,71 +584,56 @@ public TableView findAllString(long columnIndex, String value){
         }
     }
 
-    protected native long nativeFindAllString(long nativePtr, long columnIndex, String value);
-
-
-
     //
     // Integer Aggregates
     //
 
     /**
-     * Calculate the sum of the values in a particular column of this
-     * tableview.
+     * Calculate the sum of the values in a particular column of this tableview.
      *
-     * Note: the type of the column marked by the columnIndex has to be of
-     * type ColumnType.ColumnTypeInt.
+     * Note: the type of the column marked by the columnIndex has to be of type RealmFieldType.INTEGER.
      *
-     * @param columnIndex column index
-     * @return the sum of the values in the column
+     * @param columnIndex column index.
+     * @return the sum of the values in the column.
      */
     @Override
     public long sumLong(long columnIndex){
         return nativeSumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeSumInt(long nativeViewPtr, long columnIndex);
-
     /**
      * Returns the maximum value of the cells in a column.
      *
-     * Note: for this method to work the Type of the column
-     * identified by the columnIndex has to be ColumnType.ColumnTypeInt.
+     * Note: for this method to work the Type of the column identified by the columnIndex has to be
+     * RealmFieldType.INTEGER.
      *
-     * @param columnIndex column index
-     * @return the maximum value
+     * @param columnIndex column index.
+     * @return the maximum value.
      */
     @Override
-    public long maximumLong(long columnIndex){
+    public Long maximumLong(long columnIndex){
         return nativeMaximumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeMaximumInt(long nativeViewPtr, long columnIndex);
-
     /**
      * Returns the minimum value of the cells in a column.
      *
-     * Note: for this method to work the Type of the column
-     * identified by the columnIndex has to be ColumnType.ColumnTypeInt.
+     * Note: for this method to work the Type of the column identified by the columnIndex has to be
+     * RealmFieldType.INTEGER.
      *
-     * @param columnIndex column index
-     * @return the minimum value
+     * @param columnIndex column index.
+     * @return the minimum value.
      */
     @Override
-    public long minimumLong(long columnIndex){
+    public Long minimumLong(long columnIndex){
         return nativeMinimumInt(nativePtr, columnIndex);
     }
 
-    protected native long nativeMinimumInt(long nativeViewPtr, long columnIndex);
-
     @Override
     public double averageLong(long columnIndex) {
         return nativeAverageInt(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageInt(long nativePtr, long columnIndex);
-
-
     // Float aggregates
 
     @Override
@@ -774,30 +641,21 @@ public double sumFloat(long columnIndex){
         return nativeSumFloat(nativePtr, columnIndex);
     }
 
-    protected native double nativeSumFloat(long nativeViewPtr, long columnIndex);
-
     @Override
-    public float maximumFloat(long columnIndex){
+    public Float maximumFloat(long columnIndex){
         return nativeMaximumFloat(nativePtr, columnIndex);
     }
 
-    protected native float nativeMaximumFloat(long nativeViewPtr, long columnIndex);
-
     @Override
-    public float minimumFloat(long columnIndex){
+    public Float minimumFloat(long columnIndex){
         return nativeMinimumFloat(nativePtr, columnIndex);
     }
 
-    protected native float nativeMinimumFloat(long nativeViewPtr, long columnIndex);
-
     @Override
     public double averageFloat(long columnIndex) {
         return nativeAverageFloat(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageFloat(long nativePtr, long columnIndex);
-
-
     // Double aggregates
 
     @Override
@@ -805,54 +663,46 @@ public double sumDouble(long columnIndex){
         return nativeSumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeSumDouble(long nativeViewPtr, long columnIndex);
-
     @Override
-    public double maximumDouble(long columnIndex){
+    public Double maximumDouble(long columnIndex){
         return nativeMaximumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeMaximumDouble(long nativeViewPtr, long columnIndex);
 
     @Override
-    public double minimumDouble(long columnIndex){
+    public Double minimumDouble(long columnIndex){
         return nativeMinimumDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeMinimumDouble(long nativeViewPtr, long columnIndex);
-
     @Override
     public double averageDouble(long columnIndex) {
         return nativeAverageDouble(nativePtr, columnIndex);
     }
 
-    protected native double nativeAverageDouble(long nativePtr, long columnIndex);
-
-
     // Date aggregates
 
     @Override
     public Date maximumDate(long columnIndex) {
-        return new Date(nativeMaximumDate(nativePtr, columnIndex) * 1000);
+        Long result = nativeMaximumDate(nativePtr, columnIndex);
+        if (result == null) {
+            return null;
+        }
+        return new Date(result * 1000);
     }
 
-    protected native long nativeMaximumDate(long nativePtr, long columnIndex);
-
     @Override
     public Date minimumDate(long columnIndex) {
-        return new Date(nativeMinimumDate(nativePtr, columnIndex) * 1000);
+        Long result = nativeMinimumDate(nativePtr, columnIndex);
+        if (result == null) {
+            return null;
+        }
+        return new Date(result * 1000);
     }
 
-    protected native long nativeMinimumDate(long nativePtr, long columnnIndex);
-
-
     // Sorting
-
-    public enum Order { ascending, descending };
-
-    public void sort(long columnIndex, Order order) {
+    public void sort(long columnIndex, Sort sortOrder) {
         // Don't check for immutable. Sorting does not modify original table
-        nativeSort(nativePtr, columnIndex, (order == Order.ascending));
+        nativeSort(nativePtr, columnIndex, sortOrder.getValue());
     }
 
     public void sort(long columnIndex) {
@@ -860,31 +710,20 @@ public void sort(long columnIndex) {
         nativeSort(nativePtr, columnIndex, true);
     }
 
-    protected native void nativeSort(long nativeTableViewPtr, long columnIndex, boolean ascending);
-
-    public void sort(List<Long> columnIndices, List<Order> order) {
+    public void sort(List<Long> columnIndices, Sort[] sortOrders) {
         long indices[] = new long[columnIndices.size()];
-        boolean sortOrder[] = new boolean[order.size()];
         for (int i = 0; i < columnIndices.size(); i++) {
             indices[i] = columnIndices.get(i);
         }
-        for (int i = 0; i < order.size(); i++) {
-            sortOrder[i] = order.get(i) == Order.ascending;
-        }
-        nativeSortMulti(nativePtr, indices, sortOrder);
+        boolean nativeSortOrder[] = TableQuery.getNativeSortOrderValues(sortOrders);
+        nativeSortMulti(nativePtr, indices, nativeSortOrder);
     }
 
-    protected native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
-
-    protected native long createNativeTableView(Table table, long nativeTablePtr);
-
     @Override
     public String toJson() {
         return nativeToJson(nativePtr);
     }
 
-    protected native String nativeToJson(long nativeViewPtr);
-
     @Override
     public String toString() {
         return nativeToString(nativePtr, 500);
@@ -895,29 +734,35 @@ public String toString(long maxRows) {
         return nativeToString(nativePtr, maxRows);
     }
 
-    protected native String nativeToString(long nativeTablePtr, long maxRows);
-
     @Override
     public String rowToString(long rowIndex) {
         return nativeRowToString(nativePtr, rowIndex);
     }
 
-    protected native String nativeRowToString(long nativeTablePtr, long rowIndex);
-
     @Override
     public TableQuery where() {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         this.context.executeDelayedDisposal();
         long nativeQueryPtr = nativeWhere(nativePtr);
         try {
-            return new TableQuery(this.context, this.parent, nativeQueryPtr);
+            return new TableQuery(this.context, this.parent, nativeQueryPtr, this);
         } catch (RuntimeException e) {
             TableQuery.nativeClose(nativeQueryPtr);
             throw e;
         }
     }
 
-    protected native long nativeWhere(long nativeViewPtr);
+    /**
+     * Finds a row in the parent table with the given {@code rowIndex}
+     *
+     * @param rowIndex the index of the row.
+     * @return the row index or -1 for not found.
+     */
+    @Override
+    public long sourceRowIndex(long rowIndex) {
+        return nativeFindBySourceNdx(nativePtr, rowIndex);
+    }
+
 
     private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
@@ -935,22 +780,123 @@ public long count(long columnIndex, String value) {
 
     @Override
     public Table pivot(long stringCol, long intCol, PivotType pivotType){
-        if (! this.getColumnType(stringCol).equals(ColumnType.STRING ))
+        if (! this.getColumnType(stringCol).equals(RealmFieldType.STRING ))
             throw new UnsupportedOperationException("Group by column must be of type String");
-        if (! this.getColumnType(intCol).equals(ColumnType.INTEGER ))
-            throw new UnsupportedOperationException("Aggregeation column must be of type Int");
+        if (! this.getColumnType(intCol).equals(RealmFieldType.INTEGER ))
+            throw new UnsupportedOperationException("Aggregation column must be of type Int");
         Table result = new Table();
         nativePivot(nativePtr, stringCol, intCol, pivotType.value, result.nativePtr);
         return result;
    }
 
-    protected native void nativePivot(long nativeTablePtr, long sringCol, long intCol, int pivotType, long result);
+    /**
+     * Removes rows that are duplicated with respect to the column set passed as argument.
+     * If two rows are indentical (for the given set of distinct-columns), then the last row is
+     * removed unless sorted, in which case the first object is returned.
+     *
+     * @param columnIndex the column index.
+     * @throws IllegalArgumentException if the type of the column is unsupported.
+     * @throws UnsupportedOperationException if a column is not indexed.
+     */
+    public void distinct(long columnIndex) {
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        this.context.executeDelayedDisposal();
+        nativeDistinct(nativePtr, columnIndex);
+    }
 
+    /**
+     * If two rows are indentical (for the given set of distinct-columns), then the last row is
+     * removed unless sorted, in which case the first object is returned.
+     * Each time distinct() gets called, it will first fetch the full original TableView contents
+     * and then apply distinct() on that, invalidating previous distinct().
+     *
+     * @param columnIndexes the column indexes.
+     * @throws IllegalArgumentException if a column is unsupported type, or is not indexed.
+     */
+    public void distinct(List<Long> columnIndexes) {
+        // Execute the disposal of abandoned realm objects each time a new realm object is created
+        this.context.executeDelayedDisposal();
+        long[] indexes = new long[columnIndexes.size()];
+        for (int i = 0; i < columnIndexes.size(); i++) {
+            indexes[i] = columnIndexes.get(i);
+        }
+        nativeDistinctMulti(nativePtr, indexes);
+    }
 
     @Override
     public long sync() {
         return nativeSync(nativePtr);
     }
 
-    protected native long nativeSync(long nativeTablePtr);
+    static native void nativeClose(long nativeViewPtr);
+    private native long nativeSize(long nativeViewPtr);
+    private native long nativeGetSourceRowIndex(long nativeViewPtr, long rowIndex);
+    private native long nativeGetColumnCount(long nativeViewPtr);
+    private native String nativeGetColumnName(long nativeViewPtr, long columnIndex);
+    private native long nativeGetColumnIndex(long nativeViewPtr, String columnName);
+    private native int nativeGetColumnType(long nativeViewPtr, long columnIndex);
+    private native long nativeGetLong(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native boolean nativeGetBoolean(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native float nativeGetFloat(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native double nativeGetDouble(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetDateTimeValue(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
+    private native int nativeGetMixedType(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native Mixed nativeGetMixed(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetSubtable(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
+    private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
+    private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
+    private native void nativeSetDouble(long nativeViewPtr, long columnIndex, long rowIndex, double value);
+    private native void nativeSetDateTimeValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    private native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
+    private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
+    private native void nativeSetMixed(long nativeViewPtr, long columnIndex, long rowIndex, Mixed value);
+    private native void nativeSetLink(long nativeViewPtr, long columnIndex, long rowIndex, long value);
+    private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
+    private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
+    private native void nativeClear(long nativeViewPtr);
+    private native void nativeRemoveRow(long nativeViewPtr, long rowIndex);
+    private native long nativeFindFirstInt(long nativeTableViewPtr, long columnIndex, long value);
+    private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
+    private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
+    private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
+    private native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindFirstString(long nativePtr, long columnIndex, String value);
+    private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
+    private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
+    private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
+    private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
+    private native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindBySourceNdx(long nativePtr, long rowIndex);
+    private native long nativeSumInt(long nativeViewPtr, long columnIndex);
+    private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
+    private native Long nativeMaximumInt(long nativeViewPtr, long columnIndex);
+    private native Long nativeMinimumInt(long nativeViewPtr, long columnIndex);
+    private native double nativeAverageInt(long nativePtr, long columnIndex);
+    private native double nativeSumFloat(long nativeViewPtr, long columnIndex);
+    private native Float nativeMaximumFloat(long nativeViewPtr, long columnIndex);
+    private native Float nativeMinimumFloat(long nativeViewPtr, long columnIndex);
+    private native double nativeAverageFloat(long nativePtr, long columnIndex);
+    private native double nativeSumDouble(long nativeViewPtr, long columnIndex);
+    private native Double nativeMaximumDouble(long nativeViewPtr, long columnIndex);
+    private native Double nativeMinimumDouble(long nativeViewPtr, long columnIndex);
+    private native double nativeAverageDouble(long nativePtr, long columnIndex);
+    private native Long nativeMaximumDate(long nativePtr, long columnIndex);
+    private native Long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native void nativeSort(long nativeTableViewPtr, long columnIndex, boolean sortOrder);
+    private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
+    private native long createNativeTableView(Table table, long nativeTablePtr);
+    private native String nativeToJson(long nativeViewPtr);
+    private native String nativeToString(long nativeTablePtr, long maxRows);
+    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
+    private native long nativeWhere(long nativeViewPtr);
+    private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
+    private native long nativeDistinct(long nativeViewPtr, long columnIndex);
+    private native long nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
+    private native long nativeSync(long nativeTablePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
new file mode 100644
index 0000000000..3f591b2130
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.ref.ReferenceQueue;
+import java.util.Date;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Wrapper around a Row in Realm Core.
+ *
+ * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the annotation
+ * processor and {@link RealmProxyMediator#validateTable(Class, ImplicitTransaction)} which is called before the typed
+ * API can be used.
+ *
+ * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
+ */
+public class UncheckedRow extends NativeObject implements Row {
+
+    protected static class UncheckedRowNativeObjectReference extends NativeObjectReference {
+        public UncheckedRowNativeObjectReference(NativeObject referent,
+                                                 ReferenceQueue<? super NativeObject> referenceQueue) {
+            super(referent, referenceQueue);
+        }
+
+        @Override
+        protected void cleanup() {
+            nativeClose(nativePointer);
+        }
+    }
+
+    final Context context; // This is only kept because for now it's needed by the constructor of LinkView
+    final Table parent;
+
+    protected UncheckedRow(Context context, Table parent, long nativePtr) {
+        this.context = context;
+        this.parent = parent;
+        this.nativePointer = nativePtr;
+
+        context.cleanNativeReferences();
+    }
+
+    /**
+     * Gets the row object associated to an index in a Table.
+     *
+     * @param context the Realm context.
+     * @param table the Table that holds the row.
+     * @param index the index of the row.
+     * @return an instance of Row for the table and index specified.
+     */
+    public static UncheckedRow getByRowIndex(Context context, Table table, long index) {
+        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
+        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
+                Context.NATIVE_REFERENCES_VALUE);
+        return row;
+    }
+
+    /**
+     * Gets the row object from a row pointer.
+     *
+     * @param context the Realm context.
+     * @param table the Table that holds the row.
+     * @param nativeRowPointer pointer of a row.
+     * @return an instance of Row for the table and row specified.
+     */
+    public static UncheckedRow getByRowPointer(Context context, Table table, long nativeRowPointer) {
+        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
+        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
+                Context.NATIVE_REFERENCES_VALUE);
+        return row;
+    }
+
+    /**
+     * Gets the row object associated to an index in a LinkView.
+     *
+     * @param context the Realm context.
+     * @param linkView the LinkView holding the row.
+     * @param index the index of the row.
+     * @return an instance of Row for the LinkView and index specified.
+     */
+    public static UncheckedRow getByRowIndex(Context context, LinkView linkView, long index) {
+        long nativeRowPointer = linkView.nativeGetRow(linkView.nativePointer, index);
+        UncheckedRow row = new UncheckedRow(context, linkView.getTargetTable(),
+                nativeRowPointer);
+        context.rowReferences.put(new UncheckedRowNativeObjectReference(row, context.referenceQueue),
+                Context.NATIVE_REFERENCES_VALUE);
+        return row;
+    }
+
+    @Override
+    public long getColumnCount() {
+        return nativeGetColumnCount(nativePointer);
+    }
+
+    @Override
+    public String getColumnName(long columnIndex) {
+        return nativeGetColumnName(nativePointer, columnIndex);
+    }
+
+
+    @Override
+    public long getColumnIndex(String columnName) {
+        if (columnName == null) {
+            throw new IllegalArgumentException("Column name can not be null.");
+        }
+        return nativeGetColumnIndex(nativePointer, columnName);
+    }
+
+    @Override
+    public RealmFieldType getColumnType(long columnIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePointer, columnIndex));
+    }
+
+    // Getters
+
+    @Override
+    public Table getTable() {
+        return parent;
+    }
+
+    @Override
+    public long getIndex() {
+        return nativeGetIndex(nativePointer);
+    }
+
+    @Override
+    public long getLong(long columnIndex) {
+        return nativeGetLong(nativePointer, columnIndex);
+    }
+
+    @Override
+    public boolean getBoolean(long columnIndex) {
+        return nativeGetBoolean(nativePointer, columnIndex);
+    }
+
+    @Override
+    public float getFloat(long columnIndex) {
+        return nativeGetFloat(nativePointer, columnIndex);
+    }
+
+    @Override
+    public double getDouble(long columnIndex) {
+        return nativeGetDouble(nativePointer, columnIndex);
+    }
+
+    @Override
+    public Date getDate(long columnIndex) {
+        return new Date(nativeGetDateTime(nativePointer, columnIndex)*1000);
+    }
+
+    @Override
+    public String getString(long columnIndex) {
+        return nativeGetString(nativePointer, columnIndex);
+    }
+
+    @Override
+    public byte[] getBinaryByteArray(long columnIndex) {
+        return nativeGetByteArray(nativePointer, columnIndex);
+    }
+
+    @Override
+    public Mixed getMixed(long columnIndex) {
+        return nativeGetMixed(nativePointer, columnIndex);
+    }
+
+    @Override
+    public RealmFieldType getMixedType(long columnIndex) {
+        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePointer, columnIndex));
+    }
+
+    @Override
+    public long getLink(long columnIndex) {
+        return nativeGetLink(nativePointer, columnIndex);
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        return nativeIsNullLink(nativePointer, columnIndex);
+    }
+
+    @Override
+    public LinkView getLinkList(long columnIndex) {
+        long nativeLinkViewPtr = nativeGetLinkView(nativePointer, columnIndex);
+        return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
+    }
+
+    // Setters
+
+    @Override
+    public void setLong(long columnIndex, long value) {
+        parent.checkImmutable();
+        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
+        nativeSetLong(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setBoolean(long columnIndex, boolean value) {
+        parent.checkImmutable();
+        nativeSetBoolean(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setFloat(long columnIndex, float value) {
+        parent.checkImmutable();
+        nativeSetFloat(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setDouble(long columnIndex, double value) {
+        parent.checkImmutable();
+        nativeSetDouble(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setDate(long columnIndex, Date date) {
+        parent.checkImmutable();
+        if (date == null) {
+            throw new IllegalArgumentException("Null Date is not allowed.");
+        }
+        long timestamp = date.getTime() / 1000;
+        nativeSetDate(nativePointer, columnIndex, timestamp);
+    }
+
+    @Override
+    public void setString(long columnIndex, String value) {
+        parent.checkImmutable();
+        getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
+        nativeSetString(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setBinaryByteArray(long columnIndex, byte[] data) {
+        parent.checkImmutable();
+        nativeSetByteArray(nativePointer, columnIndex, data);
+    }
+
+    @Override
+    public void setMixed(long columnIndex, Mixed data) {
+        parent.checkImmutable();
+        if (data == null) {
+            throw new IllegalArgumentException("Null data is not allowed");
+        }
+        nativeSetMixed(nativePointer, columnIndex, data);
+    }
+
+    @Override
+    public void setLink(long columnIndex, long value) {
+        parent.checkImmutable();
+        nativeSetLink(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void nullifyLink(long columnIndex) {
+        parent.checkImmutable();
+        nativeNullifyLink(nativePointer, columnIndex);
+    }
+
+    @Override
+    public boolean isNull(long columnIndex) {
+        return nativeIsNull(nativePointer, columnIndex);
+    }
+
+    @Override
+    public void setNull(long columnIndex) {
+        nativeSetNull(nativePointer, columnIndex);
+    }
+
+    /**
+     * Converts the unchecked Row to a checked variant.
+     *
+     * @return the {@link CheckedRow} wrapping the same Realm data as the original {@link Row}.
+     */
+    public CheckedRow convertToChecked() {
+        return CheckedRow.getFromRow(this);
+    }
+
+    @Override
+    public boolean isAttached() {
+        return nativePointer != 0 && nativeIsAttached(nativePointer);
+    }
+
+    @Override
+    public boolean hasColumn(String fieldName) {
+        return nativeHasColumn(nativePointer, fieldName);
+    }
+
+    protected native long nativeGetColumnCount(long nativeTablePtr);
+    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetIndex(long nativeRowPtr);
+    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
+    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
+    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
+    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native String nativeGetString(long nativePtr, long columnIndex);
+    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
+    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
+    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
+    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
+    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
+    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
+    private static native void nativeClose(long nativeRowPtr);
+    protected native boolean nativeIsAttached(long nativeRowPtr);
+    protected native boolean nativeHasColumn(long nativeRowPtr, String columnName);
+    protected native boolean nativeIsNull(long nativeRowPtr, long columnIndex);
+    protected native void nativeSetNull(long nativeRowPtr, long columnIndex);
+}
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
similarity index 62%
rename from realm/src/main/java/io/realm/internal/Util.java
rename to realm/realm-library/src/main/java/io/realm/internal/Util.java
index 3e0110f75b..a1b5d0b23b 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -16,11 +16,13 @@
 
 package io.realm.internal;
 
-import java.util.Scanner;
+import io.realm.RealmObject;
 
 public class Util {
 
     static {
+        // Any internal class with static native methods that uses Realm Core must load the Realm Core library
+        // themselves as it otherwise might not have been loaded.
         RealmCore.loadLibrary();
     }
 
@@ -40,12 +42,11 @@ static void javaPrint(String txt) {
         System.out.print(txt);
     }
 
-    public static void waitForEnter() {
-        System.out.println("Press Enter to continue...");
-        Scanner sc = new Scanner(System.in);
-           while(!sc.nextLine().equals(""));
-        sc.close();
+    public static String getTablePrefix() {
+        return nativeGetTablePrefix();
     }
+    static native String nativeGetTablePrefix();
+
 
     // Testcases run in nativeCode
     public enum Testcase {
@@ -60,13 +61,15 @@ public static void waitForEnter() {
         Exception_TableInvalid(8),
         Exception_UnsupportedOperation(9),
         Exception_OutOfMemory(10),
-        Exception_Unspecified(11),
+        Exception_FatalError(11),
         Exception_RuntimeError(12),
-        Exception_RowInvalid(13);
+        Exception_RowInvalid(13),
+        Exception_EncryptionNotSupported(14),
+        Exception_CrossTableLink(15),
+        Exception_BadVersion(16);
 
         private final int nativeTestcase;
-        private Testcase(int nativeValue)
-        {
+        Testcase(int nativeValue) {
             this.nativeTestcase = nativeValue;
         }
 
@@ -80,4 +83,20 @@ public String execute(long parm1) {
 
     static native String nativeTestcase(int testcase, boolean dotest, long parm1);
 
+    /**
+     * Normalizes a input class to it's original RealmObject class so it is transparent whether or not the input class
+     * was a RealmProxy class.
+     */
+    public static Class<? extends RealmObject> getOriginalModelClass(Class<? extends RealmObject> clazz) {
+        //This cast is correct because 'clazz' is either the type
+        //generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked")
+        Class<? extends RealmObject> superclass = (Class<? extends RealmObject>) clazz.getSuperclass();
+
+        if (!superclass.equals(RealmObject.class)) {
+            clazz = superclass;
+        }
+
+        return clazz;
+    }
 }
diff --git a/realm/src/main/java/io/realm/internal/Version.java b/realm/realm-library/src/main/java/io/realm/internal/Version.java
similarity index 97%
rename from realm/src/main/java/io/realm/internal/Version.java
rename to realm/realm-library/src/main/java/io/realm/internal/Version.java
index 97b0e32f0f..fa47bb34d9 100644
--- a/realm/src/main/java/io/realm/internal/Version.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Version.java
@@ -27,8 +27,7 @@
         Feature_Debug(0),
         Feature_Replication(1);
 
-        private Feature(int nativeValue)
-        {
+        Feature(int nativeValue) {
             this.nativeFeature = nativeValue;
         }
 
@@ -50,7 +49,7 @@ public static boolean hasFeature(Feature feature) {
     }
 
     public static boolean coreLibVersionCompatible(boolean throwIfNot) {
-        String errTxt = "";
+        String errTxt;
         boolean compatible = nativeIsAtLeast(CORE_MIN_MAJOR, CORE_MIN_MINOR, CORE_MIN_PATCH);
         if (!compatible) {
             errTxt = "Version mismatch between realm.jar ("
diff --git a/realm/src/main/java/io/realm/internal/WriteTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
similarity index 100%
rename from realm/src/main/java/io/realm/internal/WriteTransaction.java
rename to realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
diff --git a/realm/src/main/java/io/realm/internal/android/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
similarity index 81%
rename from realm/src/main/java/io/realm/internal/android/AndroidLogger.java
rename to realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
index db3a9bfc4e..196b0450b3 100644
--- a/realm/src/main/java/io/realm/internal/android/AndroidLogger.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.android;
 
 import android.util.Log;
@@ -12,7 +28,8 @@
     private String logTag = "REALM";
 
     /**
-     * Manually set a logging tag.
+     * Manually sets a logging tag.
+     *
      * @param tag Logging tag to use for all subsequent logging calls.
      */
     public void setTag(String tag) {
@@ -20,8 +37,9 @@ public void setTag(String tag) {
     }
 
     /**
-     * Override the provided logger behavior and only log if log entry has a level equal or higher.
-     * @param logLevel Minimum log level to report.
+     * Overrides the provided logger behavior and only log if log entry has a level equal or higher.
+     *
+     * @param logLevel the minimum log level to report.
      */
     public void setMinimumLogLevel(int logLevel) {
         minimumLogLevel = logLevel;
diff --git a/gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java b/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
similarity index 64%
rename from gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java
rename to realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
index 4c3e5e42d7..bf2de63996 100644
--- a/gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
@@ -14,16 +14,16 @@
  * limitations under the License.
  */
 
-package io.realm.example.sample;
+package io.realm.internal.android;
 
-import android.app.Application;
-import android.test.ApplicationTestCase;
+import io.realm.internal.log.RealmLog;
 
 /**
- * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ * RealmLogger for Android debug builds. This logs everything as default.
  */
-public class ApplicationTest extends ApplicationTestCase<Application> {
-    public ApplicationTest() {
-        super(Application.class);
+public class DebugAndroidLogger extends AndroidLogger {
+
+    public DebugAndroidLogger() {
+        setMinimumLogLevel(RealmLog.VERBOSE);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
new file mode 100644
index 0000000000..4509b04237
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2015 FasterXML
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package io.realm.internal.android;
+
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.util.*;
+
+/**
+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
+ * highly suitable if you (un)serialize lots of date objects.
+ *
+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
+ *
+ * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
+ * @see <a href="https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java">Original Source</a>
+ */
+public class ISO8601Utils {
+
+    /**
+     * ID to represent the 'UTC' string, default timezone since Jackson 2.7
+     *
+     * @since 2.7
+     */
+    private static final String UTC_ID = "UTC";
+
+    /**
+     * The UTC timezone, prefetched to avoid more lookups.
+     *
+     * @since 2.7
+     */
+    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);
+
+    /**
+     * Timezone we use for 'Z' in ISO-8601 date/time values: since 2.7
+     * {@link #TIMEZONE_UTC};
+     */
+    private static final TimeZone TIMEZONE_Z = TIMEZONE_UTC;
+
+    /**
+     * Parse a date from ISO-8601 formatted string. It expects a format
+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
+     *
+     * @param date ISO string to parse in the appropriate format.
+     * @param pos The position to start parsing from, updated to where parsing stopped.
+     * @return the parsed date
+     * @throws ParseException if the date is not in the appropriate format
+     */
+    public static Date parse(String date, ParsePosition pos) throws ParseException {
+        Exception fail;
+        //noinspection TryWithIdenticalCatches
+        try {
+            int offset = pos.getIndex();
+
+            // extract year
+            int year = parseInt(date, offset, offset += 4);
+            if (checkOffset(date, offset, '-')) {
+                offset += 1;
+            }
+
+            // extract month
+            int month = parseInt(date, offset, offset += 2);
+            if (checkOffset(date, offset, '-')) {
+                offset += 1;
+            }
+
+            // extract day
+            int day = parseInt(date, offset, offset += 2);
+            // default time value
+            int hour = 0;
+            int minutes = 0;
+            int seconds = 0;
+            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time
+
+            // if the value has no time component (and no time zone), we are done
+            boolean hasT = checkOffset(date, offset, 'T');
+
+            if (!hasT && (date.length() <= offset)) {
+                Calendar calendar = new GregorianCalendar(year, month - 1, day);
+
+                pos.setIndex(offset);
+                return calendar.getTime();
+            }
+
+            if (hasT) {
+
+                // extract hours, minutes, seconds and milliseconds
+                hour = parseInt(date, offset += 1, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+
+                minutes = parseInt(date, offset, offset += 2);
+                if (checkOffset(date, offset, ':')) {
+                    offset += 1;
+                }
+                // second and milliseconds can be optional
+                if (date.length() > offset) {
+                    char c = date.charAt(offset);
+                    if (c != 'Z' && c != '+' && c != '-') {
+                        seconds = parseInt(date, offset, offset += 2);
+                        if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
+                        // milliseconds can be optional in the format
+                        if (checkOffset(date, offset, '.')) {
+                            offset += 1;
+                            int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
+                            int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
+                            int fraction = parseInt(date, offset, parseEndOffset);
+                            // compensate for "missing" digits
+                            switch (parseEndOffset - offset) { // number of digits parsed
+                                case 2:
+                                    milliseconds = fraction * 10;
+                                    break;
+                                case 1:
+                                    milliseconds = fraction * 100;
+                                    break;
+                                default:
+                                    milliseconds = fraction;
+                            }
+                            offset = endOffset;
+                        }
+                    }
+                }
+            }
+
+            // extract timezone
+            if (date.length() <= offset) {
+                throw new IllegalArgumentException("No time zone indicator");
+            }
+
+            TimeZone timezone;
+            char timezoneIndicator = date.charAt(offset);
+
+            if (timezoneIndicator == 'Z') {
+                timezone = TIMEZONE_Z;
+                offset += 1;
+            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
+                String timezoneOffset = date.substring(offset);
+                offset += timezoneOffset.length();
+                // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
+                if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
+                    timezone = TIMEZONE_Z;
+                } else {
+                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
+                    //    not sure why, but that's the way it looks. Further, Javadocs for
+                    //    `java.util.TimeZone` specifically instruct use of GMT as base for
+                    //    custom timezones... odd.
+                    String timezoneId = "GMT" + timezoneOffset;
+//                    String timezoneId = "UTC" + timezoneOffset;
+
+                    timezone = TimeZone.getTimeZone(timezoneId);
+
+                    String act = timezone.getID();
+                    if (!act.equals(timezoneId)) {
+                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
+                         *    one without. If so, don't sweat.
+                         *   Yes, very inefficient. Hopefully not hit often.
+                         *   If it becomes a perf problem, add 'loose' comparison instead.
+                         */
+                        String cleaned = act.replace(":", "");
+                        if (!cleaned.equals(timezoneId)) {
+                            throw new IndexOutOfBoundsException("Mismatching time zone indicator: "+timezoneId+" given, resolves to "
+                                    +timezone.getID());
+                        }
+                    }
+                }
+            } else {
+                throw new IndexOutOfBoundsException("Invalid time zone indicator '" + timezoneIndicator+"'");
+            }
+
+            Calendar calendar = new GregorianCalendar(timezone);
+            calendar.setLenient(false);
+            calendar.set(Calendar.YEAR, year);
+            calendar.set(Calendar.MONTH, month - 1);
+            calendar.set(Calendar.DAY_OF_MONTH, day);
+            calendar.set(Calendar.HOUR_OF_DAY, hour);
+            calendar.set(Calendar.MINUTE, minutes);
+            calendar.set(Calendar.SECOND, seconds);
+            calendar.set(Calendar.MILLISECOND, milliseconds);
+
+            pos.setIndex(offset);
+            return calendar.getTime();
+            // If we get a ParseException it'll already have the right message/offset.
+            // Other exception types can convert here.
+        } catch (IndexOutOfBoundsException e) {
+            fail = e;
+        } catch (NumberFormatException e) {
+            fail = e;
+        } catch (IllegalArgumentException e) {
+            fail = e;
+        }
+        String input = (date == null) ? null : ('"' + date + "'");
+        String msg = fail.getMessage();
+        if (msg == null || msg.isEmpty()) {
+            msg = "("+fail.getClass().getName()+")";
+        }
+        ParseException ex = new ParseException("Failed to parse date [" + input + "]: " + msg, pos.getIndex());
+        ex.initCause(fail);
+        throw ex;
+    }
+
+
+    /**
+     * Check if the expected character exist at the given offset in the value.
+     *
+     * @param value the string to check at the specified offset
+     * @param offset the offset to look for the expected character
+     * @param expected the expected character
+     * @return true if the expected character exist at the given offset
+     */
+    private static boolean checkOffset(String value, int offset, char expected) {
+        return (offset < value.length()) && (value.charAt(offset) == expected);
+    }
+
+    /**
+     * Parse an integer located between 2 given offsets in a string
+     *
+     * @param value the string to parse
+     * @param beginIndex the start index for the integer in the string
+     * @param endIndex the end index for the integer in the string
+     * @return the int
+     * @throws NumberFormatException if the value is not a number
+     */
+    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {
+        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
+            throw new NumberFormatException(value);
+        }
+        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
+        int i = beginIndex;
+        int result = 0;
+        int digit;
+        if (i < endIndex) {
+            digit = Character.digit(value.charAt(i++), 10);
+            if (digit < 0) {
+                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+            }
+            result = -digit;
+        }
+        while (i < endIndex) {
+            digit = Character.digit(value.charAt(i++), 10);
+            if (digit < 0) {
+                throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+            }
+            result *= 10;
+            result -= digit;
+        }
+        return -result;
+    }
+
+    /**
+     * Returns the index of the first character in the string that is not a digit, starting at offset.
+     */
+    private static int indexOfNonDigit(String string, int offset) {
+        for (int i = offset; i < string.length(); i++) {
+            char c = string.charAt(i);
+            if (c < '0' || c > '9') return i;
+        }
+        return string.length();
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/android/JsonUtils.java b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
similarity index 51%
rename from realm/src/main/java/io/realm/internal/android/JsonUtils.java
rename to realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
index 2115795202..3bc9da984a 100644
--- a/realm/src/main/java/io/realm/internal/android/JsonUtils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
@@ -17,39 +17,63 @@
 package io.realm.internal.android;
 
 import android.util.Base64;
+
+import java.text.ParseException;
+import java.text.ParsePosition;
 import java.util.Date;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import io.realm.exceptions.RealmException;
+
 public class JsonUtils {
 
-    private static Pattern jsonDate = Pattern.compile("/Date\\((\\d*)\\)/");
+    private static Pattern jsonDate = Pattern.compile("/Date\\((\\d*)(?:[+-]\\d*)?\\)/");
+    private static Pattern numericOnly = Pattern.compile("-?\\d+");
+    private static ParsePosition parsePosition = new ParsePosition(0);
 
     /**
      * Converts a Json string to a Java Date object. Currently supports 2 types:
      * - "<long>"
-     * - "/Date(<long>)/"
+     * - "/Date(<long>[+-Zone])/"
      *
-     * @param date   String input of date of the the supported types.
-     * @return Date object or null if invalid input.
-     *
-     * @throws NumberFormatException If date is not a proper long or has an illegal format.
+     * @param date the String input of date of the the supported types.
+     * @return the Date object or null if invalid input.
+     * @throws NumberFormatException if date is not a proper long or has an illegal format.
      */
     public static Date stringToDate(String date) {
         if (date == null || date.length() == 0) return null;
+
+        // Check for JSON date
         Matcher matcher = jsonDate.matcher(date);
-        if (matcher.matches()) {
-            return new Date(Long.parseLong(matcher.group(1)));
-        } else {
-            return new Date(Long.parseLong(date));
+        if (matcher.find()) {
+            String dateMatch = matcher.group(1);
+            return new Date(Long.parseLong(dateMatch));
+        }
+
+        // Check for millisecond based date
+        if (numericOnly.matcher(date).matches()) {
+            try {
+                return new Date(Long.parseLong(date));
+            } catch (NumberFormatException e) {
+                throw new RealmException(e.getMessage(), e);
+            }
+        }
+
+        // Try for ISO8601 date
+        try {
+            parsePosition.setIndex(0); // reset the position each time
+            return ISO8601Utils.parse(date, parsePosition);
+        } catch (ParseException e) {
+            throw new RealmException(e.getMessage(), e);
         }
     }
 
     /**
      * Converts a Json string to byte[]. String must be Base64 encoded.
      *
-     * @param str   Base 64 encoded bytes.
-     * @return Byte array or empty byte array
+     * @param str the base 64 encoded bytes.
+     * @return the Byte array or empty byte array.
      */
     public static byte[] stringToBytes(String str) {
         if (str == null || str.length() == 0) return new byte[0];
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
new file mode 100644
index 0000000000..ce7e28966f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.android;
+
+import io.realm.internal.log.RealmLog;
+
+/**
+ * This is the RealmLogger used by Realm in Release builds. It only logs warnings and errors by default.
+ */
+public class ReleaseAndroidLogger extends AndroidLogger {
+
+    public ReleaseAndroidLogger() {
+        setMinimumLogLevel(RealmLog.WARN);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java b/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java
new file mode 100644
index 0000000000..8fed5b45c6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import io.realm.Sort;
+
+/**
+ * Value holder class to encapsulate the arguments of a RealmQuery (in case we want to re-query).
+ */
+public class ArgumentsHolder {
+    public final static int TYPE_FIND_ALL = 0;
+    public final static int TYPE_FIND_ALL_SORTED = 1;
+    public final static int TYPE_FIND_ALL_MULTI_SORTED = 2;
+    public final static int TYPE_FIND_FIRST = 3;
+    public final static int TYPE_DISTINCT = 4;
+
+    public final int type;
+    public long columnIndex;
+    public Sort sortOrder;
+    public long[] columnIndices;
+    public Sort[] sortOrders;
+
+    public ArgumentsHolder(int type) {
+        this.type = type;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java b/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java
new file mode 100644
index 0000000000..2a0569c41f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/BadVersionException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import io.realm.exceptions.RealmException;
+import io.realm.internal.Keep;
+
+/**
+ * Triggered from JNI level when the result of a query (from a different thread) could not be used against the current
+ * state of the Realm which might be more up-to-date than the provided results or vice versa.
+ */
+@Keep
+public class BadVersionException extends RealmException {
+
+    public BadVersionException(String detailMessage) {
+        super(detailMessage);
+    }
+
+    public BadVersionException(String detailMessage, Throwable exception) {
+        super(detailMessage, exception);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityCallable.java b/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityCallable.java
new file mode 100644
index 0000000000..22af6503ad
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityCallable.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import java.util.concurrent.Callable;
+
+/**
+ * Decorator to set the thread priority according to
+ * <a href="https://developer.android.com/training/multiple-threads/define-runnable.html"> Androids recommendation</a>.
+ */
+public class BgPriorityCallable<T> implements Callable<T> {
+    private final Callable<T> callable;
+
+    BgPriorityCallable(Callable<T> callable) {
+        this.callable = callable;
+    }
+
+    @Override
+    public T call() throws Exception {
+        // Moves the current Thread into the background
+        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+        return callable.call();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityRunnable.java b/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityRunnable.java
new file mode 100644
index 0000000000..7e56cb48af
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/BgPriorityRunnable.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+/**
+ * Decorator to set the thread priority according to
+ * <a href="https://developer.android.com/training/multiple-threads/define-runnable.html"> Androids recommendation</a>.
+ */
+public class BgPriorityRunnable implements Runnable {
+    private final Runnable runnable;
+
+    BgPriorityRunnable(Runnable runnable) {
+        this.runnable = runnable;
+    }
+
+    @Override
+    public void run() {
+        // Moves the current Thread into the background
+        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
+        runnable.run();
+    }
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
new file mode 100644
index 0000000000..63d8948c52
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -0,0 +1,339 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import android.os.Handler;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.internal.SharedGroup;
+import io.realm.internal.Table;
+import io.realm.internal.TableQuery;
+import io.realm.internal.log.RealmLog;
+
+/**
+ * Manage the update of async queries.
+ */
+public class QueryUpdateTask implements Runnable {
+    // true if updating RealmResults, false if updating RealmObject, can't mix both
+    // the builder pattern will prevent this.
+    private final static int MODE_UPDATE_REALM_RESULTS = 0;
+    private final static int MODE_UPDATE_REALM_OBJECT = 1;
+    private final int updateMode;
+
+    private RealmConfiguration realmConfiguration;
+    private List<Builder.QueryEntry> realmResultsEntries;
+    private Builder.QueryEntry realmObjectEntry;
+    private WeakReference<Handler> callerHandler;
+    private int message;
+
+    private QueryUpdateTask (int mode,
+                             RealmConfiguration realmConfiguration,
+                             List<Builder.QueryEntry> listOfRealmResults,
+                             Builder.QueryEntry realmObject,
+                             WeakReference<Handler> handler,
+                             int message) {
+        this.updateMode = mode;
+        this.realmConfiguration = realmConfiguration;
+        this.realmResultsEntries = listOfRealmResults;
+        this.realmObjectEntry = realmObject;
+        this.callerHandler = handler;
+        this.message = message;
+    }
+
+    public static Builder.RealmConfigurationStep newBuilder() {
+        return new Builder.Steps();
+    }
+
+    @Override
+    public void run() {
+        SharedGroup sharedGroup = null;
+        try {
+            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
+                    SharedGroup.IMPLICIT_TRANSACTION,
+                    realmConfiguration.getDurability(),
+                    realmConfiguration.getEncryptionKey());
+
+            Result result;
+            boolean updateSuccessful;
+            if (updateMode == MODE_UPDATE_REALM_RESULTS) {
+                result = Result.newRealmResultsResponse();
+                AlignedQueriesParameters alignedParameters = prepareQueriesParameters();
+                long[] handoverTableViewPointer = TableQuery.nativeBatchUpdateQueries(sharedGroup.getNativePointer(),
+                        alignedParameters.handoverQueries,
+                        alignedParameters.queriesParameters,
+                        alignedParameters.multiSortColumnIndices,
+                        alignedParameters.multiSortOrder);
+                swapPointers(result, handoverTableViewPointer);
+                updateSuccessful = true;
+                result.versionID = sharedGroup.getVersion();
+
+            } else {
+                result = Result.newRealmObjectResponse();
+                updateSuccessful = updateRealmObjectQuery(sharedGroup, result);
+                result.versionID = sharedGroup.getVersion();
+            }
+
+            Handler handler = callerHandler.get();
+            if (updateSuccessful && !isTaskCancelled() && isAliveHandler(handler)) {
+                handler.obtainMessage(message, result).sendToTarget();
+            }
+
+        } catch (Exception e) {
+            RealmLog.e(e.getMessage(), e);
+
+        } finally {
+            if (sharedGroup != null) {
+                sharedGroup.close();
+            }
+        }
+    }
+
+    private AlignedQueriesParameters prepareQueriesParameters() {
+        long[] handoverQueries = new long[realmResultsEntries.size()];
+        long[][] queriesParameters = new long[realmResultsEntries.size()][6];
+        long[][] multiSortColumnIndices = new long[realmResultsEntries.size()][];
+        boolean[][] multiSortOrder = new boolean[realmResultsEntries.size()][];
+
+        int i = 0;
+        for (Builder.QueryEntry  queryEntry : realmResultsEntries) {
+            switch (queryEntry.queryArguments.type) {
+                case ArgumentsHolder.TYPE_FIND_ALL: {
+                    handoverQueries[i] = queryEntry.handoverQueryPointer;
+                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL;
+                    queriesParameters[i][1] = 0;
+                    queriesParameters[i][2] = Table.INFINITE;
+                    queriesParameters[i][3] = Table.INFINITE;
+                    break;
+                }
+                case ArgumentsHolder.TYPE_DISTINCT: {
+                    handoverQueries[i] = queryEntry.handoverQueryPointer;
+                    queriesParameters[i][0] = ArgumentsHolder.TYPE_DISTINCT;
+                    queriesParameters[i][1] = queryEntry.queryArguments.columnIndex;
+                    break;
+                }
+                case ArgumentsHolder.TYPE_FIND_ALL_SORTED: {
+                    handoverQueries[i] = queryEntry.handoverQueryPointer;
+                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL_SORTED;
+                    queriesParameters[i][1] = 0;
+                    queriesParameters[i][2] = Table.INFINITE;
+                    queriesParameters[i][3] = Table.INFINITE;
+                    queriesParameters[i][4] = queryEntry.queryArguments.columnIndex;
+                    queriesParameters[i][5] = (queryEntry.queryArguments.sortOrder.getValue()) ? 1 : 0;
+                    break;
+                }
+                case ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED:
+                    handoverQueries[i] = queryEntry.handoverQueryPointer;
+                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED;
+                    queriesParameters[i][1] = 0;
+                    queriesParameters[i][2] = Table.INFINITE;
+                    queriesParameters[i][3] = Table.INFINITE;
+                    multiSortColumnIndices[i] = queryEntry.queryArguments.columnIndices;
+                    multiSortOrder[i] = TableQuery.getNativeSortOrderValues(queryEntry.queryArguments.sortOrders);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Query mode " + queryEntry.queryArguments.type + " not supported");
+            }
+            i++;
+        }
+        AlignedQueriesParameters alignedParameters = new AlignedQueriesParameters();
+
+        alignedParameters.handoverQueries = handoverQueries;
+        alignedParameters.multiSortColumnIndices = multiSortColumnIndices;
+        alignedParameters.multiSortOrder = multiSortOrder;
+        alignedParameters.queriesParameters = queriesParameters;
+
+        return alignedParameters;
+    }
+
+    private void swapPointers(Result result, long[] handoverTableViewPointer) {
+        int i = 0;
+        for (Builder.QueryEntry  queryEntry : realmResultsEntries) {
+            result.updatedTableViews.put(queryEntry.element, handoverTableViewPointer[i++]);
+        }
+    }
+
+    private boolean updateRealmObjectQuery(SharedGroup sharedGroup, Result result) {
+        if (!isTaskCancelled()) {
+            switch (realmObjectEntry.queryArguments.type) {
+                case ArgumentsHolder.TYPE_FIND_FIRST: {
+                    long handoverRowPointer = TableQuery.
+                            nativeFindWithHandover(sharedGroup.getNativePointer(),
+                                    realmObjectEntry.handoverQueryPointer, 0);
+                    result.updatedRow.put(realmObjectEntry.element, handoverRowPointer);
+                    break;
+                }
+                default:
+                    throw new IllegalArgumentException("Query mode " + realmObjectEntry.queryArguments.type + " not supported");
+            }
+        } else {
+            TableQuery.nativeCloseQueryHandover(realmObjectEntry.handoverQueryPointer);
+            return false;
+        }
+        return true;
+    }
+
+    private boolean isTaskCancelled() {
+        // no point continuing if the caller thread was stopped or this thread was interrupted
+        return Thread.currentThread().isInterrupted();
+    }
+
+    private boolean isAliveHandler(Handler handler) {
+        return handler != null && handler.getLooper().getThread().isAlive();
+    }
+
+    // result of the async query
+    public static class Result {
+        public IdentityHashMap<WeakReference<RealmResults<? extends RealmObject>>, Long> updatedTableViews;
+        public IdentityHashMap<WeakReference<RealmObject>, Long> updatedRow;
+        public SharedGroup.VersionID versionID;
+
+        public static Result newRealmResultsResponse() {
+            Result result = new Result();
+            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<?>>, Long>(1);
+            return result;
+        }
+
+        public static Result newRealmObjectResponse() {
+            Result result = new Result();
+            result.updatedRow = new IdentityHashMap<WeakReference<RealmObject>, Long>(1);
+            return result;
+        }
+    }
+    private static class AlignedQueriesParameters {
+        long[] handoverQueries;
+        long[][] queriesParameters;
+        long[][] multiSortColumnIndices;
+        boolean[][] multiSortOrder;
+    }
+    /*
+      This uses the step builder pattern to guide the caller throughout the creation of the instance
+      http://rdafbn.blogspot.ie/2012/07/step-builder-pattern_28.html
+      Example of call:
+      QueryUpdateTask task = QueryUpdateTask.newBuilder()
+         .realmConfiguration(null, null)
+         .add(null, 0, null)
+         .add(null, 0, null)
+         .sendToHandler(null, 0)
+         .build();
+
+     QueryUpdateTask task2 = QueryUpdateTask.newBuilder()
+         .realmConfiguration(null, null)
+         .addObject(null, 0, null)
+         .sendToHandler(null, 0)
+         .build();
+     */
+    public static class Builder {
+        public interface RealmConfigurationStep {
+            UpdateQueryStep realmConfiguration (RealmConfiguration realmConfiguration);
+        }
+
+        public interface UpdateQueryStep {
+            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmObject>> weakReference,
+                                          long handoverQueryPointer,
+                                          ArgumentsHolder queryArguments);
+            HandlerStep addObject(WeakReference<? extends RealmObject> weakReference,
+                                  long handoverQueryPointer,
+                                  ArgumentsHolder queryArguments);// can only update 1 element
+        }
+
+        public interface RealmResultsQueryStep {
+            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmObject>> weakReference,
+                                          long handoverQueryPointer,
+                                          ArgumentsHolder queryArguments);
+            BuilderStep sendToHandler(Handler handler, int message);
+        }
+
+        public interface HandlerStep {
+            BuilderStep sendToHandler (Handler handler, int message);
+        }
+
+        public interface BuilderStep {
+            QueryUpdateTask build();
+        }
+
+        private static class Steps implements RealmConfigurationStep, UpdateQueryStep, RealmResultsQueryStep, HandlerStep, BuilderStep {
+            private RealmConfiguration realmConfiguration;
+            private List<QueryEntry> realmResultsEntries;
+            private QueryEntry realmObjectEntry;
+            private WeakReference<Handler> callerHandler;
+            private int message;
+
+            @Override
+            public UpdateQueryStep realmConfiguration(RealmConfiguration realmConfiguration) {
+                this.realmConfiguration = realmConfiguration;
+                return this;
+            }
+
+            @Override
+            public RealmResultsQueryStep add(WeakReference<RealmResults<?>> weakReference,
+                                             long handoverQueryPointer,
+                                             ArgumentsHolder queryArguments) {
+                if (this.realmResultsEntries == null) {
+                    this.realmResultsEntries = new ArrayList<QueryEntry>(1);
+                }
+                this.realmResultsEntries.add(new QueryEntry(weakReference, handoverQueryPointer, queryArguments));
+                return this;
+            }
+
+            @Override
+            public HandlerStep addObject(WeakReference<? extends RealmObject> weakReference,
+                                         long handoverQueryPointer,
+                                         ArgumentsHolder queryArguments) {
+                realmObjectEntry =
+                        new QueryEntry(weakReference, handoverQueryPointer, queryArguments);
+                return this;
+            }
+
+            @Override
+            public BuilderStep sendToHandler(Handler handler, int message) {
+                this.callerHandler = new WeakReference<Handler>(handler);
+                this.message = message;
+                return this;
+            }
+
+            @Override
+            public QueryUpdateTask build() {
+                return new QueryUpdateTask(
+                        (realmResultsEntries != null) ? MODE_UPDATE_REALM_RESULTS : MODE_UPDATE_REALM_OBJECT,
+                        realmConfiguration,
+                        realmResultsEntries,
+                        realmObjectEntry,
+                        callerHandler,
+                        message);
+            }
+        }
+
+        private static class QueryEntry {
+            final WeakReference element;
+            long handoverQueryPointer;
+            final ArgumentsHolder queryArguments;
+
+            private QueryEntry(WeakReference element, long handoverQueryPointer, ArgumentsHolder queryArguments) {
+                this.element = element;
+                this.handoverQueryPointer = handoverQueryPointer;
+                this.queryArguments = queryArguments;
+            }
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
new file mode 100644
index 0000000000..523410ec24
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.async;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * Custom thread pool settings, instances of this executor can be paused, and resumed, this will also set
+ * appropriate number of Threads & wrap submitted tasks to set the thread priority according to
+ * <a href="https://developer.android.com/training/multiple-threads/define-runnable.html"> Androids recommendation</a>.
+ */
+public class RealmThreadPoolExecutor extends ThreadPoolExecutor {
+    // reduce context switch by using a number of thread proportionate to the number of cores
+    // from AOSP https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/os/AsyncTask.java#182
+    private static final int CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2 + 1;
+    private static final int QUEUE_SIZE = 100;
+
+    private boolean isPaused;
+    private ReentrantLock pauseLock = new ReentrantLock();
+    private Condition unpaused = pauseLock.newCondition();
+
+    private static volatile RealmThreadPoolExecutor instance;
+
+    public static RealmThreadPoolExecutor getInstance() {
+           if (instance == null) {
+               synchronized (RealmThreadPoolExecutor.class) {
+                   if (instance == null) {
+                       instance = new RealmThreadPoolExecutor();
+                   }
+               }
+           }
+        return instance;
+    }
+
+    private RealmThreadPoolExecutor() {
+        super(CORE_POOL_SIZE, CORE_POOL_SIZE,
+                0L, TimeUnit.MILLISECONDS, //terminated idle thread
+                new ArrayBlockingQueue<Runnable>(QUEUE_SIZE));
+    }
+
+    @Override
+    public Future<?> submit(Runnable task) {
+        return super.submit(new BgPriorityRunnable(task));
+    }
+
+    @Override
+    public <T> Future<T> submit(Callable<T> task) {
+        return super.submit(new BgPriorityCallable<T>(task));
+    }
+
+    @Override
+    protected void beforeExecute(Thread t, Runnable r) {
+            super.beforeExecute(t, r);
+        pauseLock.lock();
+        try {
+            while (isPaused) unpaused.await();
+        } catch (InterruptedException ie) {
+            t.interrupt();
+        } finally {
+            pauseLock.unlock();
+        }
+    }
+
+    /**
+     * Pauses the executor. Pausing means the executor will stop starting new tasks (but complete current ones).
+     */
+    public void pause() {
+        pauseLock.lock();
+        try {
+            isPaused = true;
+        } finally {
+            pauseLock.unlock();
+        }
+    }
+
+    public void resume() {
+        pauseLock.lock();
+        try {
+            isPaused = false;
+            unpaused.signalAll();
+        } finally {
+            pauseLock.unlock();
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java b/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
new file mode 100644
index 0000000000..50eba1905c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.log;
+
+/**
+ * Interface for Realm logger implementations.
+ */
+public interface Logger {
+    void v(String message);
+    void v(String message, Throwable t);
+    void d(String message);
+    void d(String message, Throwable t);
+    void i(String message);
+    void i(String message, Throwable t);
+    void w(String message);
+    void w(String message, Throwable t);
+    void e(String message);
+    void e(String message, Throwable t);
+}
diff --git a/realm/src/main/java/io/realm/internal/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
similarity index 64%
rename from realm/src/main/java/io/realm/internal/log/RealmLog.java
rename to realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
index 3b82a72e6e..5c1ef9f3d4 100644
--- a/realm/src/main/java/io/realm/internal/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
@@ -1,11 +1,26 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.internal.log;
 
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
- * Logger implementation for Realm. This can be used to transparently change logging behavior
- * between Android and Java.
+ * Logger implementation for Realm. This can be used to transparently change logging behavior between Android and Java.
  *
  * This class supports adding multiple logger implementations.
  */
@@ -23,9 +38,9 @@
     private static final List<Logger> LOGGERS = new CopyOnWriteArrayList<Logger>();
 
     /**
-     * Add a logger implementation.
+     * Adds a logger implementation.
      *
-     * @param logger Reference to a {@link Logger} implementation.
+     * @param logger the reference to a {@link Logger} implementation.
      */
     public static void add(Logger logger) {
         if (logger == null) {
@@ -35,8 +50,9 @@ public static void add(Logger logger) {
     }
 
     /**
-     * Remove a current logger implementation.
-     * @param logger
+     * Removes a current logger implementation.
+     *
+     * @param logger.
      */
     public static void remove(Logger logger) {
         if (logger == null) {
@@ -47,61 +63,61 @@ public static void remove(Logger logger) {
 
     public static void v(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message);
+            LOGGERS.get(i).v(message);
         }
     }
 
     public static void v(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message, t);
+            LOGGERS.get(i).v(message, t);
         }
     }
 
     public static void d(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).d(message);
+            LOGGERS.get(i).d(message);
         }
     }
 
     public static void d(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).d(message, t);
+            LOGGERS.get(i).d(message, t);
         }
     }
 
     public static void i(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).i(message);
+            LOGGERS.get(i).i(message);
         }
     }
 
     public static void i(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).i(message, t);
+            LOGGERS.get(i).i(message, t);
         }
     }
 
     public static void w(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).w(message);
+            LOGGERS.get(i).w(message);
         }
     }
 
     public static void w(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).w(message, null);
+            LOGGERS.get(i).w(message, null);
         }
     }
 
     public static void e(String message)  {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).e(message);
+            LOGGERS.get(i).e(message);
         }
     }
 
     public static void e(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message, t);
+            LOGGERS.get(i).v(message, t);
         }
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
similarity index 62%
rename from realm/src/main/java/io/realm/internal/modules/CompositeMediator.java
rename to realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 69b679fd73..1c665475c4 100644
--- a/realm/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -22,29 +22,38 @@
 import org.json.JSONObject;
 
 import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import io.realm.Realm;
 import io.realm.RealmObject;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
 
 /**
  * This class is able to merge different RealmProxyMediators, so they look like one.
  */
 public class CompositeMediator extends RealmProxyMediator {
 
-    Map<Class<? extends RealmObject>, RealmProxyMediator> mediators = new HashMap<Class<? extends RealmObject>, RealmProxyMediator>();
+    private final Map<Class<? extends RealmObject>, RealmProxyMediator> mediators;
 
-    public void addMediator(RealmProxyMediator mediator) {
-        for (Class<? extends RealmObject> realmClass : mediator.getModelClasses()) {
-            mediators.put(realmClass, mediator);
+    public CompositeMediator(RealmProxyMediator... mediators) {
+        final HashMap<Class<? extends RealmObject>, RealmProxyMediator> tempMediators = new HashMap<>();
+        if (mediators != null) {
+            for (RealmProxyMediator mediator : mediators) {
+                for (Class<? extends RealmObject> realmClass : mediator.getModelClasses()) {
+                    tempMediators.put(realmClass, mediator);
+                }
+            }
         }
+        this.mediators = Collections.unmodifiableMap(tempMediators);
     }
 
     @Override
@@ -54,9 +63,9 @@ public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction
     }
 
     @Override
-    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
         RealmProxyMediator mediator = getMediator(clazz);
-        mediator.validateTable(clazz, transaction);
+        return mediator.validateTable(clazz, transaction);
     }
 
     @Override
@@ -72,29 +81,19 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.newInstance(clazz);
+        return mediator.newInstance(clazz, columnInfo);
     }
 
     @Override
-    public List<Class<? extends RealmObject>> getModelClasses() {
-        List<Class<? extends RealmObject>> list = new ArrayList<Class<? extends RealmObject>>();
-        for (RealmProxyMediator mediator : mediators.values()) {
-            list.addAll(mediator.getModelClasses());
-        }
-        return list;
-    }
-
-    @Override
-    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.getColumnIndices(clazz);
+    public Set<Class<? extends RealmObject>> getModelClasses() {
+        return mediators.keySet();
     }
 
     @Override
     public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
-        RealmProxyMediator mediator = getMediator(object.getClass());
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
         return mediator.copyOrUpdate(realm, object, update, cache);
     }
 
@@ -110,6 +109,23 @@ public String getTableName(Class<? extends RealmObject> clazz) {
         return mediator.createUsingJsonStream(clazz, realm, reader);
     }
 
+    @Override
+    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(realmObject.getClass()));
+        return mediator.createDetachedCopy(realmObject, maxDepth, cache);
+    }
+
+    @Override
+    public boolean transformerApplied() {
+        for (Map.Entry<Class<? extends RealmObject>, RealmProxyMediator> entry : mediators.entrySet()) {
+            if (!entry.getValue().transformerApplied()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // Returns the mediator for a given model class (not RealmProxy) or throws exception
     private RealmProxyMediator getMediator(Class<? extends RealmObject> clazz) {
         RealmProxyMediator mediator = mediators.get(clazz);
         if (mediator == null) {
diff --git a/realm/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
similarity index 58%
rename from realm/src/main/java/io/realm/internal/modules/FilterableMediator.java
rename to realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 3a8c2f53ab..c200323c85 100644
--- a/realm/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -22,7 +22,8 @@
 import org.json.JSONObject;
 
 import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -30,33 +31,41 @@
 
 import io.realm.Realm;
 import io.realm.RealmObject;
+import io.realm.internal.ColumnInfo;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
 
 /**
- * Specialized version of a RealmProxyMediator that can further filter the available classes based on provided filter
+ * Specialized version of a {@link RealmProxyMediator} that can further filter the available classes based on provided
+ * filter.
  */
 public class FilterableMediator extends RealmProxyMediator {
 
-    private RealmProxyMediator originalMediator;
-    private Set<Class<? extends RealmObject>> allowedClasses = new HashSet<Class<? extends RealmObject>>();
+    private final RealmProxyMediator originalMediator;
+    private final Set<Class<? extends RealmObject>> allowedClasses;
 
     /**
-     * Creates a filterable Mediator.
+     * Creates a filterable {@link RealmProxyMediator}.
      *
-     * @param originalMediator      Original auto generated mediator.
-     * @param allowedClasses                Subset of classes from original mediator to allow.
+     * @param originalMediator the original auto generated mediator.
+     * @param allowedClasses the subset of classes from original mediator to allow.
      */
-    public FilterableMediator(RealmProxyMediator originalMediator, List<Class<? extends RealmObject>> allowedClasses) {
+    public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmObject>> allowedClasses) {
         this.originalMediator = originalMediator;
-        List<Class<? extends RealmObject>> originalClasses = originalMediator.getModelClasses();
-        for (Class<? extends RealmObject> clazz : allowedClasses) {
-            if (originalClasses.contains(clazz)) {
-                this.allowedClasses.add(clazz);
+
+        Set<Class<? extends RealmObject>> tempAllowedClasses = new HashSet<Class<? extends RealmObject>>();
+        if (originalMediator != null) {
+            Set<Class<? extends RealmObject>> originalClasses = originalMediator.getModelClasses();
+            for (Class<? extends RealmObject> clazz : allowedClasses) {
+                if (originalClasses.contains(clazz)) {
+                    tempAllowedClasses.add(clazz);
+                }
             }
         }
+        this.allowedClasses = Collections.unmodifiableSet(tempAllowedClasses);
     }
 
     public RealmProxyMediator getOriginalMediator() {
@@ -70,9 +79,9 @@ public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction
     }
 
     @Override
-    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
         checkSchemaHasClass(clazz);
-        originalMediator.validateTable(clazz, transaction);
+        return originalMediator.validateTable(clazz, transaction);
     }
 
     @Override
@@ -88,25 +97,19 @@ public String getTableName(Class<? extends RealmObject> clazz) {
     }
 
     @Override
-    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+    public <E extends RealmObject> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         checkSchemaHasClass(clazz);
-        return originalMediator.newInstance(clazz);
-    }
-
-    @Override
-    public List<Class<? extends RealmObject>> getModelClasses() {
-        return new ArrayList<Class<? extends RealmObject>>(allowedClasses);
+        return originalMediator.newInstance(clazz, columnInfo);
     }
 
     @Override
-    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.getColumnIndices(clazz);
+    public Set<Class<? extends RealmObject>> getModelClasses() {
+        return allowedClasses;
     }
 
     @Override
     public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
-        checkSchemaHasClass(object.getClass());
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
         return originalMediator.copyOrUpdate(realm, object, update, cache);
     }
 
@@ -122,6 +125,22 @@ public String getTableName(Class<? extends RealmObject> clazz) {
         return originalMediator.createUsingJsonStream(clazz, realm, reader);
     }
 
+    @Override
+    public <E extends RealmObject> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmObject, RealmObjectProxy.CacheData<RealmObject>> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(realmObject.getClass()));
+        return originalMediator.createDetachedCopy(realmObject, maxDepth, cache);
+    }
+
+    @Override
+    public boolean transformerApplied() {
+        //noinspection SimplifiableIfStatement
+        if (originalMediator == null) {
+            return true;
+        }
+        return originalMediator.transformerApplied();
+    }
+
+    // Validate if a model class (not RealmProxy) is part of this Schema.
     private void checkSchemaHasClass(Class<? extends RealmObject> clazz) {
         if (!allowedClasses.contains(clazz)) {
             throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
new file mode 100644
index 0000000000..65933f7487
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rx;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmChangeListener;
+import io.realm.RealmConfiguration;
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmQuery;
+import io.realm.RealmResults;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * Factory class for creating Observables for RxJava (&lt;=1.1.*).
+ *
+ * @see Realm#asObservable()
+ * @see RealmObject#asObservable()
+ * @see RealmResults#asObservable()
+ * @see DynamicRealm#asObservable()
+ * @see DynamicRealmObject#asObservable()
+ */
+public class RealmObservableFactory implements RxObservableFactory {
+
+    @Override
+    public Observable<Realm> from(Realm realm) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<Realm>() {
+            @Override
+            public void call(final Subscriber<? super Realm> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(observableRealm);
+                        }
+                    }
+                };
+                observableRealm.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        observableRealm.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+                subscriber.onNext(observableRealm);
+            }
+        });
+    }
+
+    @Override
+    public Observable<DynamicRealm> from(DynamicRealm realm) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<DynamicRealm>() {
+            @Override
+            public void call(final Subscriber<? super DynamicRealm> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(observableRealm);
+                        }
+                    }
+                };
+                observableRealm.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        observableRealm.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+
+                    // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(observableRealm);
+            }
+        });
+    }
+
+    @Override
+    public <E extends RealmObject> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
+            @Override
+            public void call(final Subscriber<? super RealmResults<E>> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(results);
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+
+                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(results);
+            }
+        });
+    }
+
+    @Override
+    public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(results);
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+
+                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(results);
+            }
+        });
+    }
+
+    @Override
+    public <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+        return getRealmListObservable();
+    }
+
+    @Override
+    public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+        return getRealmListObservable();
+    }
+
+    private <E extends RealmObject> Observable<RealmList<E>> getRealmListObservable() {
+        throw new RuntimeException("RealmList does not support change listeners yet, so cannot create an Observable");
+    }
+
+    @Override
+    public <E extends RealmObject> Observable<E> from(final Realm realm, final E object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<E>() {
+            @Override
+            public void call(final Subscriber<? super E> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(object);
+                        }
+                    }
+                };
+                object.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        object.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+
+                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(object);
+            }
+        });
+    }
+
+    @Override
+    public Observable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() {
+            @Override
+            public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
+                // Get instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                final RealmChangeListener listener = new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(object);
+                        }
+                    }
+                };
+                object.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        object.removeChangeListener(listener);
+                        observableRealm.close();
+                    }
+                }));
+
+                // Immediately call onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(object);
+            }
+        });
+    }
+
+    @Override
+    public <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+        throw new RuntimeException("RealmQuery not supported yet.");
+    }
+
+    @Override
+    public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+        throw new RuntimeException("RealmQuery not supported yet.");
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return o instanceof RealmObservableFactory;
+    }
+
+    @Override
+    public int hashCode() {
+        return 37;
+    }
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
new file mode 100644
index 0000000000..a0ddeddf1b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rx;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmQuery;
+import io.realm.RealmResults;
+import rx.Observable;
+
+/**
+ * Factory interface for creating Rx Observables for Realm classes.
+ */
+public interface RxObservableFactory {
+
+    /**
+     * Creates an Observable for a {@link Realm}. It should emit the initial state of the Realm when subscribed to and
+     * on each subsequent update of the Realm.
+     *
+     * Realm observables are hot observables as Realms are automatically kept up to date.
+     *
+     * @param realm {@link Realm} to listen to changes for.
+     * @return Rx observable that emit all updates to the Realm.
+     */
+    Observable<Realm> from(Realm realm);
+
+    /**
+     * Creates an Observable for a {@link DynamicRealm}. It should emit the initial state of the Realm when subscribed
+     * to and on each subsequent update of the Realm.
+     *
+     * DynamicRealm observables are hot observables as DynamicRealms are automatically kept up to date.
+     *
+     * @param realm {@link DynamicRealm} to listen to changes for.
+     * @return Rx observable that emit all updates to the DynamicRealm.
+     */
+    Observable<DynamicRealm> from(DynamicRealm realm);
+
+    /**
+     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults.
+     *
+     * RealmResults observables are hot observables as RealmResults are automatically kept up to date.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link Realm} instance results are coming from.
+     * @param <E> type of RealmObject
+     * @return Rx observable that emit all updates to the RealmObject.
+     */
+    <E extends RealmObject> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
+
+    /**
+     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults.
+     *
+     * Realm observables are hot observables as RealmResults are automatically kept up to date.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link DynamicRealm} instance results are coming from.
+     * @return Rx observable that emit all updates to the RealmResults.
+     */
+    Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+
+    /**
+     * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
+     * subsequent update of the RealmList.
+     *
+     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     *
+     * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
+     *
+     * @param list RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance list is coming from.
+     * @param <E> type of RealmObject
+     */
+    <E extends RealmObject> Observable<RealmList<E>> from(Realm realm, RealmList<E> list);
+
+    /**
+     * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
+     * subsequent update of the RealmList.
+     *
+     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     *
+     * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
+     *
+     * @param list RealmList to listen to changes for.
+     * @param realm {@link DynamicRealm} instance list is coming from.
+     */
+    Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+
+    /**
+     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * subsequent update of the object.
+     *
+     * RealmObject observables are hot observables as RealmObjects are automatically kept up to date.
+     *
+     * @param object RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance object is coming from.
+     * @param <E> type of RealmObject
+     */
+    <E extends RealmObject> Observable<E> from(Realm realm, E object);
+
+    /**
+     * Creates an Observable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
+     * on each subsequent update of the object.
+     *
+     * DynamicRealmObject observables are hot observables as DynamicRealmObjects automatically are kept up to date.
+     *
+     * @param object DynamicRealmObject to listen to changes for.
+     * @param realm {@link DynamicRealm} instance object is coming from.
+     */
+    Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object);
+
+    /**
+     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     *
+     * A RealmQuery observable is cold.
+     *
+     * @param query RealmQuery to emit.
+     * @param realm {@link Realm} instance query is coming from.
+     * @param <E> type of RealmObject
+     */
+    <E extends RealmObject> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
+
+    /**
+     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     *
+     * A RealmQuery observable is cold.
+     *
+     * @param query RealmObject to listen to changes for.
+     * @param realm {@link DynamicRealm} instance query is coming from.
+     */
+    Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query);
+}
diff --git a/realm/realm-library/src/overview.html b/realm/realm-library/src/overview.html
new file mode 100644
index 0000000000..9d0915de4c
--- /dev/null
+++ b/realm/realm-library/src/overview.html
@@ -0,0 +1,49 @@
+<body>
+<h2>Quick start</h2>
+
+<img src="./realm-overview.png" alt="Overview of Realm" style="display: block; margin: 0 auto;" width="35%"/>
+
+<ul>
+    <li><b>{@link io.realm.Realm}</b><br/> The Realm database. The storage and transactional manager of your object
+        persistent store. It is in charge of creating and removing instances of your RealmObjects, querying, and
+        performing transactions.
+        <a href="https://realm.io/docs/java/latest/#realms">Read more</a>.
+        <p />
+    </li>
+
+    <li><b>{@link io.realm.RealmConfiguration}</b><br/>
+        A configuration object that is used to setup a specific Realm instance.
+        <a href="https://realm.io/docs/java/latest/#configuring-a-realm">Read more</a>.
+        <p />
+    </li>
+
+    <li><b>{@link io.realm.RealmObject}</b><br/>
+        The super class of all objects (models) that are to be stored in Realm. A Java object must extend
+        {@link io.realm.RealmObject} in order to be considered a <i>RealmObject</i>.
+        <a href="https://realm.io/docs/java/latest/#models">Read more</a>.
+        <p />
+    </li>
+
+    <li><b>{@link io.realm.RealmList}</b><br/>
+        A <a href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html">List</a> that is used in
+        <i>RealmObject</i>s to model one-to-many relationships with other <i>RealmObject</i>s.
+        <a href="https://realm.io/docs/java/latest/#many-to-many">Read more</a>.
+        <p />
+    </li>
+
+    <li><b>{@link io.realm.RealmQuery}</b><br/>
+        An object that encapsulates a query as defined through Realms fluent query interface. Queries are executed
+        using either the {@link io.realm.RealmQuery#findAll}, {@link io.realm.RealmQuery#findFirst} or their variants.
+        <a href="https://realm.io/docs/java/latest/#queries">Read more</a>.
+        <p />
+    </li>
+
+    <li><b>{@link io.realm.RealmResults}</b><br/>
+        The result set of an executed <i>RealmQuery</i> for a given Realm. <i>RealmResults</i> are live,
+        <a href="https://realm.io/docs/java/latest/#auto-updating-results">auto-updating</a> views into the underlying
+        data, which means results never have to be re-fetched.
+        <a href="https://realm.io/docs/java/latest/#queries">Read more</a>.
+        <p />
+    </li>
+</ul>
+</body>
\ No newline at end of file
diff --git a/realm/realm-library/src/realm-overview.png b/realm/realm-library/src/realm-overview.png
new file mode 100644
index 0000000000..b4f49dc902
Binary files /dev/null and b/realm/realm-library/src/realm-overview.png differ
diff --git a/realm/settings.gradle b/realm/settings.gradle
new file mode 100644
index 0000000000..82a197b850
--- /dev/null
+++ b/realm/settings.gradle
@@ -0,0 +1,4 @@
+// Realm projects
+include 'realm-library'
+include 'realm-annotations-processor'
+include 'realm-jni'
diff --git a/realm/src/androidTest/assets/ios/0.90.4-alltypes.realm b/realm/src/androidTest/assets/ios/0.90.4-alltypes.realm
deleted file mode 100644
index 3f32700fb1..0000000000
Binary files a/realm/src/androidTest/assets/ios/0.90.4-alltypes.realm and /dev/null differ
diff --git a/realm/src/androidTest/assets/ios/0.90.5-alltypes-default-encrypted.realm b/realm/src/androidTest/assets/ios/0.90.5-alltypes-default-encrypted.realm
deleted file mode 100644
index 5c5c91e361..0000000000
Binary files a/realm/src/androidTest/assets/ios/0.90.5-alltypes-default-encrypted.realm and /dev/null differ
diff --git a/realm/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/src/androidTest/java/io/realm/IOSRealmTests.java
deleted file mode 100644
index ce4d4ac057..0000000000
--- a/realm/src/androidTest/java/io/realm/IOSRealmTests.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.io.IOException;
-import java.util.Date;
-
-import io.realm.entities.IOSAllTypes;
-import io.realm.entities.IOSChild;
-
-import static io.realm.internal.test.ExtraTests.assertArrayEquals;
-
-/**
- * This class test interoperability with Realms created on iOS.
- */
-public class IOSRealmTests extends AndroidTestCase {
-
-    private static final String REALM_NAME = "alltypes.realm";
-    private Realm realm;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        Realm.setSchema(IOSAllTypes.class, IOSChild.class);
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        Realm.setSchema(null);
-        if (realm != null) {
-            realm.close();
-        }
-    }
-
-    // Test relationships and that data in general can be retrieved from an iOS realm
-    public void testIOSDatatypes() throws IOException {
-        TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
-        RealmResults<IOSAllTypes> result = realm.allObjectsSorted(IOSAllTypes.class, "longCol", RealmResults.SORT_ORDER_ASCENDING);
-
-        IOSAllTypes obj = result.get(1);
-        assertTrue(obj.isBoolCol());
-        assertEquals(2, obj.getShortCol());
-        assertEquals(11, obj.getIntCol());
-        assertEquals(101L, obj.getLongCol());
-        assertEquals(2.23F, obj.getFloatCol());
-        assertEquals(2.234D, obj.getDoubleCol());
-        assertArrayEquals(new byte[] {1,2,3}, obj.getByteCol());
-        assertEquals("String 1", obj.getStringCol());
-        assertEquals(new Date(1001 * 1000), obj.getDateCol());
-        assertEquals("Foo", result.get(1).getChild().getName());
-        assertEquals(10, result.size());
-        assertEquals(10, result.get(1).getChildren().size());
-        assertEquals("Name: 1", result.get(1).getChildren().get(1).getName());
-    }
-
-    public void testIOSDatatypesDefaultValues() throws IOException {
-        TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-default.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
-
-        IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
-        assertFalse(obj.isBoolCol());
-        assertEquals(0, obj.getShortCol());
-        assertEquals(0, obj.getIntCol());
-        assertEquals(0L, obj.getLongCol());
-        assertEquals(0.0F, obj.getFloatCol());
-        assertEquals(0.0D, obj.getDoubleCol());
-        assertArrayEquals(new byte[0], obj.getByteCol());
-        assertEquals("", obj.getStringCol());
-        assertEquals(new Date(0), obj.getDateCol());
-        assertNull(obj.getChild());
-        assertEquals(0, obj.getChildren().size());
-    }
-
-    public void testIOSDatatypesMinimumValues() throws IOException {
-        TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-min.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
-
-        IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
-        assertEquals(Short.MIN_VALUE, obj.getShortCol());
-        assertEquals(Integer.MIN_VALUE, obj.getIntCol());
-        assertEquals(Long.MIN_VALUE, obj.getLongCol());
-        assertEquals(Float.MIN_NORMAL, obj.getFloatCol());
-        assertEquals(Double.MIN_NORMAL, obj.getDoubleCol());
-    }
-
-    public void testIOSDatatypesMaximumValues() throws IOException {
-        TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-max.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
-
-        IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
-        assertEquals(Short.MAX_VALUE, obj.getShortCol());
-        assertEquals(Integer.MAX_VALUE, obj.getIntCol());
-        assertEquals(Long.MAX_VALUE, obj.getLongCol());
-        assertEquals(Float.MAX_VALUE, obj.getFloatCol());
-        assertEquals(Double.MAX_VALUE, obj.getDoubleCol());
-    }
-
-    public void testIOSEncryptedRealm() throws IOException {
-        TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.5-alltypes-default-encrypted.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME, getIOSKey());
-
-        IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
-        assertFalse(obj.isBoolCol());
-        assertEquals(0, obj.getShortCol());
-        assertEquals(0, obj.getIntCol());
-        assertEquals(0L, obj.getLongCol());
-        assertEquals(0.0F, obj.getFloatCol());
-        assertEquals(0.0D, obj.getDoubleCol());
-        assertArrayEquals(new byte[0], obj.getByteCol());
-        assertEquals("", obj.getStringCol());
-        assertEquals(new Date(0), obj.getDateCol());
-        assertNull(obj.getChild());
-        assertEquals(0, obj.getChildren().size());
-    }
-
-    public byte[] getIOSKey() {
-        byte[] keyData = new byte[64];
-        for (int i = 0; i < keyData.length; i++) {
-            keyData[i] = 1;
-        }
-        return keyData;
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/NotificationsTest.java b/realm/src/androidTest/java/io/realm/NotificationsTest.java
deleted file mode 100644
index ccf2768f4a..0000000000
--- a/realm/src/androidTest/java/io/realm/NotificationsTest.java
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.test.AndroidTestCase;
-
-import java.lang.ref.WeakReference;
-import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.Dog;
-
-public class NotificationsTest extends AndroidTestCase {
-
-    private Realm realm;
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        if (realm != null) {
-            realm.close();
-        }
-    }
-
-    public void testFailingSetAutoRefreshOnNonLooperThread() throws ExecutionException, InterruptedException {
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                Realm realm = Realm.getInstance(getContext());
-                boolean autoRefresh = realm.isAutoRefresh();
-                assertFalse(autoRefresh);
-                try {
-                    realm.setAutoRefresh(true);
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
-                } finally {
-                    realm.close();
-                }
-            }
-        });
-        assertTrue(future.get());
-        assertTrue(Realm.realmsCache.get().isEmpty());
-    }
-
-    public void testSetAutoRefreshOnHandlerThread() throws ExecutionException, InterruptedException {
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                Looper.prepare();
-                Realm realm = Realm.getInstance(getContext());
-                assertTrue(realm.isAutoRefresh());
-                realm.setAutoRefresh(false);
-                assertFalse(realm.isAutoRefresh());
-                realm.setAutoRefresh(true);
-                assertTrue(realm.isAutoRefresh());
-                realm.close();
-                return true;
-            }
-        });
-        assertTrue(future.get());
-        assertTrue(Realm.realmsCache.get().isEmpty());
-    }
-
-    public void testRemoveNotifications () throws InterruptedException, ExecutionException {
-        final AtomicInteger counter= new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter.incrementAndGet();
-            }
-        };
-
-        realm = Realm.getInstance(getContext());
-        realm.addChangeListener(listener);
-        realm.removeChangeListener(listener);
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        assertEquals(0, counter.get());
-    }
-
-    public void testAddDuplicatedListener() {
-        final AtomicInteger counter= new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter.incrementAndGet();
-            }
-        };
-
-        realm = Realm.getInstance(getContext());
-        realm.addChangeListener(listener);
-        realm.addChangeListener(listener);
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        assertEquals(1, counter.get());
-    }
-
-    public void testNotificationsNumber () throws InterruptedException, ExecutionException {
-        final AtomicInteger counter = new AtomicInteger(0);
-        final AtomicBoolean isReady = new AtomicBoolean(false);
-        final Looper[] looper = new Looper[1];
-        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
-        final RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter.incrementAndGet();
-            }
-        };
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                Realm realm = null;
-                try {
-                    Looper.prepare();
-                    looper[0] = Looper.myLooper();
-                    realm = Realm.getInstance(getContext());
-                    realm.addChangeListener(listener);
-                    isReady.set(true);
-                    Looper.loop();
-                } finally {
-                    if (realm != null) {
-                        realm.close();
-                        isRealmOpen.set(false);
-                    }
-                }
-                return true;
-            }
-        });
-
-        // Wait until the looper in the background thread is started
-        while (!isReady.get()) {
-            Thread.sleep(5);
-        }
-        Thread.sleep(100); 
-
-        // Trigger OnRealmChanged on background thread
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        Dog dog = realm.createObject(Dog.class);
-        dog.setName("Rex");
-        realm.commitTransaction();
-        realm.close();
-
-        try {
-            future.get(1, TimeUnit.SECONDS);
-        } catch (TimeoutException ignore) {
-        } finally {
-            looper[0].quit();
-        }
-
-        // Wait until the Looper thread is actually closed
-        while (isRealmOpen.get()) {
-            Thread.sleep(5);
-        }
-
-        assertEquals(1, counter.get());
-        assertTrue(Realm.realmsCache.get().isEmpty());
-    }
-
-    public void testAutoUpdateRealmResults() throws InterruptedException, ExecutionException {
-        final int TEST_SIZE = 10;
-        final AtomicInteger counter = new AtomicInteger(0);
-        final AtomicBoolean isReady = new AtomicBoolean(false);
-        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
-        final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
-        final Looper[] looper = new Looper[1];
-        final RealmChangeListener listener[] = new RealmChangeListener[1];
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-
-            @Override
-            public Boolean call() throws Exception {
-                Looper.prepare();
-                looper[0] = Looper.myLooper();
-                Realm realm = null;
-                try {
-                    realm = Realm.getInstance(getContext());
-                    final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
-                    assertEquals(0, dogs.size());
-                    listener[0] = new RealmChangeListener() {
-                        @Override
-                        public void onChange() {
-                            int c = counter.incrementAndGet();
-                            results.put(c, dogs.size());
-                        }
-                    };
-                    realm.addChangeListener(listener[0]);
-                    isReady.set(true);
-                    Looper.loop();
-                } finally {
-                    if (realm != null) {
-                        realm.close();
-                        isRealmOpen.set(false);
-                    }
-                }
-                return true;
-            }
-        });
-
-        // Wait until the looper is started
-        while (!isReady.get()) {
-            Thread.sleep(5);
-        }
-        Thread.sleep(100);
-
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        for (int i = 0; i < TEST_SIZE; i++) {
-            Dog dog = realm.createObject(Dog.class);
-            dog.setName("Rex " + i);
-        }
-        realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
-        realm.close();
-
-        try {
-            future.get(2, TimeUnit.SECONDS);
-        } catch (TimeoutException ignore) {
-        } finally {
-            looper[0].quit();
-        }
-
-        // Wait until the Looper thread is actually closed
-        while (isRealmOpen.get()) {
-            Thread.sleep(5);
-        }
-
-        assertEquals(1, results.size());
-
-        assertTrue(results.containsKey(1));
-        assertEquals(TEST_SIZE, results.get(1).intValue());
-
-        assertEquals(1, counter.get());
-        assertTrue(Realm.realmsCache.get().isEmpty());
-    }
-
-    // TODO Disabled until we can figure out why this times out so often on the build server
-    public void DISABLEDtestCloseClearingHandlerMessages() throws InterruptedException, TimeoutException, ExecutionException {
-        final int TEST_SIZE = 10;
-        final CountDownLatch backgroundLooperStarted = new CountDownLatch(1);
-        final CountDownLatch addHandlerMessages = new CountDownLatch(1);
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                Looper.prepare(); // Fake background thread with a looper, eg. a IntentService
-                Realm realm = Realm.getInstance(getContext());
-                backgroundLooperStarted.countDown();
-
-                // Random operation in the client code
-                final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
-                if (dogs.size() != 0) {
-                    return false;
-                }
-                addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages
-
-                // Find the current Handler for the thread now. All message and references will be
-                // cleared once we call close().
-                Handler threadHandler = realm.getHandler();
-                realm.close(); // Close native resources + associated handlers.
-
-                // Looper now reads the update message from the main thread if the Handler was not
-                // cleared. This will cause an IllegalStateException and should not happen.
-                // If it works correctly. The looper will just block on an empty message queue.
-                // This is normal behavior but is bad for testing, so we add a custom quit message
-                // at the end so we can evaluate results faster.
-                threadHandler.post(new Runnable() {
-                    @Override
-                    public void run() {
-                        Looper.myLooper().quit();
-                    }
-                });
-
-                try {
-                    Looper.loop();
-                } catch (IllegalStateException e) {
-                    return false;
-                }
-                return true;
-            }
-        });
-
-        // Wait until the looper is started on a background thread
-        backgroundLooperStarted.await(1, TimeUnit.SECONDS);
-
-        // Execute a transaction that will trigger a Realm update
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        for (int i = 0; i < TEST_SIZE; i++) {
-            Dog dog = realm.createObject(Dog.class);
-            dog.setName("Rex " + i);
-        }
-        realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
-        realm.close();
-        addHandlerMessages.countDown();
-
-        // Check that messages was properly cleared
-        // It looks like getting this future sometimes takes a while for some reason. Setting to
-        // 10s. now.
-        Boolean result = future.get(10, TimeUnit.SECONDS);
-        assertTrue(result);
-    }
-
-    public void testHandlerNotRemovedToSoon() {
-        Realm.deleteRealmFile(getContext(), "private-realm");
-        Realm instance1 = Realm.getInstance(getContext(), "private-realm");
-        Realm instance2 = Realm.getInstance(getContext(), "private-realm");
-        assertEquals(instance1.getPath(), instance2.getPath());
-        assertNotNull(instance1.getHandler());
-
-        // If multiple instances are open on the same thread, don't remove handler on that thread
-        // until last instance is closed.
-        instance2.close();
-        assertNotNull(instance1.getHandler());
-        instance1.close();
-        assertNull(instance1.getHandler());
-    }
-
-    public void testImmediateNotificationsOnSameThread() {
-        final AtomicBoolean success = new AtomicBoolean(false);
-        final RealmChangeListener listener[] = new RealmChangeListener[1];
-        realm = Realm.getInstance(getContext());
-        listener[0] = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                // Listener should only be called once
-                assertFalse(success.get());
-                success.set(true);
-            }
-        };
-        realm.addChangeListener(listener[0]);
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-        assertTrue(success.get());
-    }
-
-    public void testEmptyCommitTriggerChangeListener() {
-        final AtomicBoolean success = new AtomicBoolean(false);
-        final RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                success.set(true);
-            }
-        };
-        realm = Realm.getInstance(getContext());
-        realm.addChangeListener(listener);
-        realm.beginTransaction();
-        realm.commitTransaction();
-        assertTrue(success.get());
-    }
-
-    public void testAddRemoveListenerConcurrency() {
-        final AtomicInteger counter1 = new AtomicInteger(0);
-        final AtomicInteger counter2 = new AtomicInteger(0);
-        final AtomicInteger counter3 = new AtomicInteger(0);
-
-        // At least we need 2 listeners existing in the list to make sure
-        // the iterator.next get called
-
-        // This one will be added when listener2's onChange called
-        final RealmChangeListener listener1 = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter1.incrementAndGet();
-            }
-        };
-
-        // This one will be existing in the list all the time
-        final RealmChangeListener listener2 = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter2.incrementAndGet();
-                realm.addChangeListener(listener1);
-            }
-        };
-
-        // This one will be removed after first transaction
-        RealmChangeListener listener3 = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter3.incrementAndGet();
-                realm.removeChangeListener(this);
-            }
-        };
-
-        realm = Realm.getInstance(getContext());
-        realm.addChangeListener(listener2);
-        realm.addChangeListener(listener3);
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        // [listener2, listener3]
-        realm.commitTransaction();
-        // after listener2.onChange
-        // [listener2, listener3, listener1]
-        // after listener3.onChange
-        // [listener2, listener1]
-        assertEquals(0, counter1.get());
-        assertEquals(1, counter2.get());
-        assertEquals(1, counter3.get());
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        // [listener2, listener1]
-        realm.commitTransaction();
-        // after listener2.onChange
-        // Since duplicated entries will be ignored, we still have:
-        // [listener2, listener1]
-
-        assertEquals(1, counter1.get());
-        assertEquals(2, counter2.get());
-        assertEquals(1, counter3.get());
-    }
-
-    public void testWeakReferenceListener() throws InterruptedException {
-        final AtomicInteger counter = new AtomicInteger(0);
-        realm = Realm.getInstance(getContext());
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                counter.incrementAndGet();
-            }
-        };
-        realm.addChangeListener(listener);
-
-        // There is no guaranteed way to release the WeakReference,
-        // just clear it.
-        for (WeakReference<RealmChangeListener> weakRef: realm.getChangeListeners()) {
-            weakRef.clear();
-        }
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        assertEquals(0, counter.get());
-        assertEquals(0, realm.getChangeListeners().size());
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
deleted file mode 100644
index 445465ec90..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import io.realm.entities.AnnotationNameConventions;
-import io.realm.entities.AnnotationTypes;
-import io.realm.entities.PrimaryKeyAsLong;
-import io.realm.entities.PrimaryKeyAsString;
-import io.realm.exceptions.RealmException;
-import io.realm.internal.Table;
-
-public class RealmAnnotationTest extends AndroidTestCase {
-    protected Realm testRealm;
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-        testRealm.beginTransaction();
-        AnnotationTypes object = testRealm.createObject(AnnotationTypes.class);
-        object.setNotIndexString("String 1");
-        object.setIndexString("String 2");
-        object.setIgnoreString("String 3");
-        testRealm.commitTransaction();
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    public void testIgnore() {
-        Table table = testRealm.getTable(AnnotationTypes.class);
-        assertEquals(-1, table.getColumnIndex("ignoreString"));
-    }
-
-    public void testIndex() {
-        Table table = testRealm.getTable(AnnotationTypes.class);
-        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
-        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexString")));
-    }
-
-    public void testHasPrimaryKeyNoIntIndex() {
-        Table table = testRealm.getTable(AnnotationTypes.class);
-        assertTrue(table.hasPrimaryKey());
-        assertFalse(table.hasSearchIndex(table.getColumnIndex("id")));
-    }
-
-    public void testHasPrimaryKeyStringIndex() {
-        Table table = testRealm.getTable(PrimaryKeyAsString.class);
-        assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasSearchIndex(table.getColumnIndex("name")));
-    }
-
-    // Test migrating primary key from string to long with existing data
-    public void testPrimaryKeyMigration_long() {
-        testRealm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = testRealm.createObject(PrimaryKeyAsString.class);
-            obj.setId(i);
-            obj.setName("String" + i);
-        }
-
-        Table table = testRealm.getTable(PrimaryKeyAsString.class);
-        table.setPrimaryKey("id");
-        assertEquals(1, table.getPrimaryKey());
-        testRealm.cancelTransaction();
-    }
-
-    // Test migrating primary key from string to long with existing data
-    public void testPrimaryKeyMigration_longDuplicateValues() {
-        testRealm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = testRealm.createObject(PrimaryKeyAsString.class);
-            obj.setId(1); // Create duplicate values
-            obj.setName("String" + i);
-        }
-
-        Table table = testRealm.getTable(PrimaryKeyAsString.class);
-        try {
-            table.setPrimaryKey("id");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException expected) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    // Test migrating primary key from long to str with existing data
-    public void testPrimaryKeyMigration_string() {
-        testRealm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = testRealm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
-            obj.setName("String" + i);
-        }
-
-        Table table = testRealm.getTable(PrimaryKeyAsLong.class);
-        table.setPrimaryKey("name");
-        assertEquals(1, table.getPrimaryKey());
-        testRealm.cancelTransaction();
-    }
-
-    // Test migrating primary key from long to str with existing data
-    public void testPrimaryKeyMigration_stringDuplicateValues() {
-        testRealm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = testRealm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
-            obj.setName("String"); // Create duplicate values
-        }
-
-        Table table = testRealm.getTable(PrimaryKeyAsLong.class);
-        try {
-            table.setPrimaryKey("name");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException expected) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testPrimaryKey_checkPrimaryKeyOnCreate() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.createObject(AnnotationTypes.class);
-            fail("Two empty objects cannot be created on the same table if a primary key is defined");
-        } catch (RealmException expected) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    // It should be allowed to override the primary key value with the same value
-    public void testPrimaryKey_defaultStringValue() {
-        testRealm.beginTransaction();
-        PrimaryKeyAsString str = testRealm.createObject(PrimaryKeyAsString.class);
-        str.setName("");
-        testRealm.commitTransaction();
-    }
-
-    // It should be allowed to override the primary key value with the same value
-    public void testPrimaryKey_defaultLongValue() {
-        testRealm.beginTransaction();
-        PrimaryKeyAsLong str = testRealm.createObject(PrimaryKeyAsLong.class);
-        str.setId(0);
-        testRealm.commitTransaction();
-    }
-
-    public void testPrimaryKey_errorOnInsertingSameObject() {
-        try {
-            testRealm.beginTransaction();
-            AnnotationTypes obj1 = testRealm.createObject(AnnotationTypes.class);
-            obj1.setId(1);
-            AnnotationTypes obj2 = testRealm.createObject(AnnotationTypes.class);
-            obj2.setId(1);
-            fail("Inserting two objects with same primary key should fail");
-        } catch (RealmException expected) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testPrimaryKeyIsIndexed() {
-        Table table = testRealm.getTable(PrimaryKeyAsString.class);
-        assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasSearchIndex(0));
-    }
-
-    // Annotation processor honors common naming conventions
-    // We check if setters and getters are generated and working
-    public void testNamingConvention() {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        realm.clear(AnnotationNameConventions.class);
-        AnnotationNameConventions anc1 = realm.createObject(AnnotationNameConventions.class);
-        anc1.setHasObject(true);
-        anc1.setId_object(1);
-        anc1.setmObject(2);
-        anc1.setObject_id(3);
-        anc1.setObject(true);
-        realm.commitTransaction();
-
-        AnnotationNameConventions anc2 = realm.allObjects(AnnotationNameConventions.class).first();
-        assertTrue(anc2.isHasObject());
-        assertEquals(1, anc2.getId_object());
-        assertEquals(2, anc2.getmObject());
-        assertEquals(3, anc2.getObject_id());
-        assertTrue(anc2.isObject());
-        realm.close();
-    }
-}
\ No newline at end of file
diff --git a/realm/src/androidTest/java/io/realm/RealmJsonTest.java b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
deleted file mode 100644
index 754ea23aa1..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmJsonTest.java
+++ /dev/null
@@ -1,624 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import android.content.res.AssetManager;
-import android.test.AndroidTestCase;
-import android.util.Base64;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Date;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.AllTypesPrimaryKey;
-import io.realm.entities.AnnotationTypes;
-import io.realm.entities.Dog;
-import io.realm.exceptions.RealmException;
-
-import static io.realm.internal.test.ExtraTests.assertArrayEquals;
-
-public class RealmJsonTest extends AndroidTestCase {
-
-    protected Realm testRealm;
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    private InputStream loadJsonFromAssets(String file) {
-        AssetManager assetManager = getContext().getAssets();
-        InputStream input = null;
-        try {
-            input = assetManager.open(file);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        } finally {
-            return input;
-        }
-    }
-
-    public void testCreateObjectFromJson_nullObject() {
-        testRealm.createObjectFromJson(AllTypes.class, (JSONObject) null);
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
-
-    public void testCreateObjectFromJson_nullArray() {
-        testRealm.createAllFromJson(AllTypes.class, (JSONArray) null);
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-
-    }
-
-    public void testCreateObjectFromJson_allSimpleObjectAllTypes() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("columnString", "String");
-        json.put("columnLong", 1l);
-        json.put("columnFloat", 1.23f);
-        json.put("columnDouble", 1.23d);
-        json.put("columnBoolean", true);
-        json.put("columnBinary", new String(Base64.encode(new byte[] {1,2,3}, Base64.DEFAULT)));
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, json);
-        testRealm.commitTransaction();
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-
-        // Check that all primitive types are imported correctly
-        assertEquals("String", obj.getColumnString());
-        assertEquals(1l, obj.getColumnLong());
-        assertEquals(1.23f, obj.getColumnFloat());
-        assertEquals(1.23d, obj.getColumnDouble());
-        assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
-    }
-
-    public void testCreateObjectFromJson_dateAsLong() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("columnDate", 1000L); // Realm operates at seconds level granularity
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, json);
-        testRealm.commitTransaction();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(new Date(1000), obj.getColumnDate());
-    }
-
-    public void testCreateObjectFromJson_dateAsString() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("columnDate", "/Date(1000)/");
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, json);
-        testRealm.commitTransaction();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(new Date(1000), obj.getColumnDate());
-    }
-
-    public void testCreateObjectFromJson_childObject() throws JSONException {
-        JSONObject allTypesObject = new JSONObject();
-        JSONObject dogObject = new JSONObject();
-        dogObject.put("name", "Fido");
-        allTypesObject.put("columnRealmObject", dogObject);
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
-        testRealm.commitTransaction();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals("Fido", obj.getColumnRealmObject().getName());
-    }
-
-    public void testCreateObjectFromJson_childObjectList() throws JSONException {
-        JSONObject allTypesObject = new JSONObject();
-        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
-        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
-        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
-        JSONArray dogList = new JSONArray();
-        dogList.put(dog1);
-        dogList.put(dog2);
-        dogList.put(dog3);
-
-        allTypesObject.put("columnRealmList", dogList);
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
-        testRealm.commitTransaction();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(3, obj.getColumnRealmList().size());
-        assertEquals("Fido-3", obj.getColumnRealmList().get(2).getName());
-    }
-
-    public void testCreateObjectFromJson_emptyChildObjectList() throws JSONException {
-        JSONObject allTypesObject = new JSONObject();
-        JSONArray dogList = new JSONArray();
-
-        allTypesObject.put("columnRealmList", dogList);
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, allTypesObject);
-        testRealm.commitTransaction();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(0, obj.getColumnRealmList().size());
-    }
-
-    public void testCreateObjectFromJsonString_simpleObject() {
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObjectFromJson(Dog.class, "{ name: \"Foo\" }");
-        testRealm. commitTransaction();
-
-        assertEquals("Foo", dog.getName());
-        assertEquals("Foo", testRealm.allObjects(Dog.class).first().getName());
-    }
-
-
-    public void testCreateObjectFromJsonString_faultyJsonThrows() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.createObjectFromJson(Dog.class, "{ name \"Foo\" }");
-        } catch (RealmException e) {
-            return;
-        } finally {
-            testRealm.commitTransaction();
-        }
-
-        fail("Faulty JSON should result in a RealmException");
-    }
-
-
-    public void testCreateObjectFromJsonString_null() {
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObjectFromJson(Dog.class, (String) null);
-        testRealm.commitTransaction();
-
-        assertNull(dog);
-        assertEquals(0, testRealm.allObjects(Dog.class).size());
-    }
-
-    public void testCreateAllFromJsonArray_empty() {
-        JSONArray array = new JSONArray();
-        testRealm.beginTransaction();
-        testRealm.createAllFromJson(AllTypes.class, array);
-        testRealm.commitTransaction();
-
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
-
-    public void testCreateAllFromJsonArray() throws JSONException {
-        JSONObject dog1 = new JSONObject(); dog1.put("name", "Fido-1");
-        JSONObject dog2 = new JSONObject(); dog2.put("name", "Fido-2");
-        JSONObject dog3 = new JSONObject(); dog3.put("name", "Fido-3");
-        JSONArray dogList = new JSONArray();
-        dogList.put(dog1);
-        dogList.put(dog2);
-        dogList.put(dog3);
-
-        testRealm.beginTransaction();
-        testRealm.createAllFromJson(Dog.class, dogList);
-        testRealm.commitTransaction();
-
-        assertEquals(3, testRealm.allObjects(Dog.class).size());
-        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
-    }
-
-    public void testCreateObjectFromJson_nullValues() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("columnString", JSONObject.NULL);
-        json.put("columnLong", JSONObject.NULL);
-        json.put("columnFloat", JSONObject.NULL);
-        json.put("columnDouble", JSONObject.NULL);
-        json.put("columnBoolean", JSONObject.NULL);
-        json.put("columnBinary", JSONObject.NULL);
-        json.put("columnDate", JSONObject.NULL);
-        json.put("columnRealmObject", JSONObject.NULL);
-        json.put("columnRealmList", JSONObject.NULL);
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, json);
-        testRealm.commitTransaction();
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-
-        // Check that all primitive types are imported correctly
-        assertEquals("", obj.getColumnString());
-        assertEquals(0L, obj.getColumnLong());
-        assertEquals(0f, obj.getColumnFloat());
-        assertEquals(0d, obj.getColumnDouble());
-        assertEquals(false, obj.isColumnBoolean());
-        assertEquals(new Date(0), obj.getColumnDate());
-        assertArrayEquals(new byte[0], obj.getColumnBinary());
-        assertNull(obj.getColumnRealmObject());
-        assertEquals(0, obj.getColumnRealmList().size());
-    }
-
-    // Test that given an exception everything up to the exception is saved
-    public void testCreateObjectFromJson_jsonException() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("columnString", "Foo");
-        json.put("columnDate", "Boom");
-
-        try {
-            testRealm.beginTransaction();
-            testRealm.createObjectFromJson(AllTypes.class, json);
-        } catch (RealmException e) {
-            // Ignore
-        } finally {
-            testRealm.commitTransaction();
-        }
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals("Foo", obj.getColumnString());
-        assertEquals(new Date(0), obj.getColumnDate());
-    }
-
-    public void testCreateObjectFromJson_respectIgnoredFields() throws JSONException {
-        JSONObject json = new JSONObject();
-        json.put("indexString", "Foo");
-        json.put("notIndexString", "Bar");
-        json.put("ignoreString", "Baz");
-
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AnnotationTypes.class, json);
-        testRealm.commitTransaction();
-
-        AnnotationTypes annotationsObject = testRealm.allObjects(AnnotationTypes.class).first();
-        assertEquals("Foo", annotationsObject.getIndexString());
-        assertEquals(null, annotationsObject.getIgnoreString());
-    }
-
-    public void testCreateAllFromJsonStringArray_simpleArray() {
-        testRealm.beginTransaction();
-        testRealm.createAllFromJson(Dog.class, "[{ name: \"Foo\" }, { name: \"Bar\" }]");
-        testRealm. commitTransaction();
-
-        assertEquals(2, testRealm.allObjects(Dog.class).size());
-    }
-
-    public void testCreateAllFromJsonStringArray_faultyJsonThrows() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.createAllFromJson(Dog.class, "[{ name : \"Foo\" ]");
-        } catch (RealmException e) {
-            return;
-        } finally {
-            testRealm.commitTransaction();
-        }
-
-        fail("Faulty JSON should result in a RealmException");
-    }
-
-
-    public void testCreateAllFromJsonStringArray_null() {
-        testRealm.beginTransaction();
-        testRealm.createAllFromJson(Dog.class, (String) null);
-        testRealm.commitTransaction();
-
-        assertEquals(0, testRealm.allObjects(Dog.class).size());
-    }
-
-   public void testCreateAllFromJsonStream_null() throws IOException {
-        testRealm.createAllFromJson(AllTypes.class, (InputStream) null);
-        assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-   }
-
-    public void testCreateObjectFromJsonStream_allSimpleTypes() throws IOException {
-        InputStream in = loadJsonFromAssets("all_simple_types.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        // Check that all primitive types are imported correctly
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals("String", obj.getColumnString());
-        assertEquals(1l, obj.getColumnLong());
-        assertEquals(1.23f, obj.getColumnFloat());
-        assertEquals(1.23d, obj.getColumnDouble());
-        assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
-    }
-
-    public void testCreateObjectFromJsonStream_dateAsLong() throws IOException {
-        InputStream in = loadJsonFromAssets("date_as_long.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        // Check that all primitive types are imported correctly
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(new Date(1000), obj.getColumnDate());
-    }
-
-    public void testCreateObjectFromJsonStream_dateAsString() throws IOException {
-        InputStream in = loadJsonFromAssets("date_as_string.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        // Check that all primitive types are imported correctly
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(new Date(1000), obj.getColumnDate());
-    }
-
-    public void testCreateObjectFromJsonStream_childObject() throws IOException {
-        InputStream in = loadJsonFromAssets("single_child_object.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals("Fido", obj.getColumnRealmObject().getName());
-    }
-
-    public void testCreateObjectFromJsonStream_emptyChildObjectList() throws IOException {
-        InputStream in = loadJsonFromAssets("realmlist_empty.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals(0, obj.getColumnRealmList().size());
-    }
-
-    public void testCreateObjectFromJsonStream_childObjectList() throws IOException {
-        InputStream in = loadJsonFromAssets("realmlist.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        assertEquals(3, testRealm.allObjects(Dog.class).size());
-        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
-    }
-
-    public void testCreateObjectFromJsonStream_array() throws IOException {
-        InputStream in = loadJsonFromAssets("array.json");
-
-        testRealm.beginTransaction();
-        testRealm.createAllFromJson(Dog.class, in);
-        testRealm.commitTransaction();
-
-        assertEquals(3, testRealm.allObjects(Dog.class).size());
-        assertEquals(1, testRealm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
-    }
-
-
-    public void testCreateObjectFromJsonStream_nullValues() throws IOException {
-        InputStream in = loadJsonFromAssets("all_types_null.json");
-        testRealm.beginTransaction();
-        testRealm.createObjectFromJson(AllTypes.class, in);
-        testRealm.commitTransaction();
-        in.close();
-
-        // Check that all primitive types are imported correctly
-        AllTypes obj = testRealm.allObjects(AllTypes.class).first();
-        assertEquals("", obj.getColumnString());
-        assertEquals(0L, obj.getColumnLong());
-        assertEquals(0f, obj.getColumnFloat());
-        assertEquals(0d, obj.getColumnDouble());
-        assertEquals(false, obj.isColumnBoolean());
-        assertEquals(new Date(0), obj.getColumnDate());
-        assertArrayEquals(new byte[0], obj.getColumnBinary());
-        assertNull(obj.getColumnRealmObject());
-        assertEquals(0, obj.getColumnRealmList().size());
-    }
-
-    public void testCreateOrUpdateObject_noPrimaryKeyThrows() {
-        try {
-            testRealm.createOrUpdateObjectFromJson(AllTypes.class, new JSONObject());
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateObjectStream_noPrimaryKeyThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateObjectFromJson(AllTypes.class, new TestHelper.StubInputStream());
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateObjectStream_invalidJSonThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
-        } catch (RealmException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateObjectString_noPrimaryKeyThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateJsonObject() throws JSONException {
-        testRealm.beginTransaction();
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        testRealm.copyToRealm(obj);
-
-        JSONObject json = new JSONObject();
-        json.put("columnLong", 1);
-        json.put("columnString", "bar");
-
-        AllTypesPrimaryKey newObj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
-        testRealm.commitTransaction();
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals("bar", newObj.getColumnString());
-    }
-
-    public void testCreateOrUpdateJsonObject_ignoreUnsetProperties() throws IOException {
-        String json = TestHelper.streamToString(loadJsonFromAssets("list_alltypes_primarykey.json"));
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
-        testRealm.commitTransaction();
-
-        // No-op as no properties should be updated
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1 }");
-        testRealm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
-    }
-
-    public void testCreateOrUpdateJsonStream_ignoreUnsetProperties() throws IOException {
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, loadJsonFromAssets("list_alltypes_primarykey.json"));
-        testRealm.commitTransaction();
-
-        // No-op as no properties should be updated
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
-        testRealm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
-    }
-
-    public void testCreateOrUpdateInputStream() throws IOException {
-        testRealm.beginTransaction();
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        testRealm.copyToRealm(obj);
-
-        InputStream in = TestHelper.stringToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
-        AllTypesPrimaryKey newObj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
-        testRealm.commitTransaction();
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals("bar", newObj.getColumnString());
-    }
-
-    public void testCreateOrUpdateString() throws IOException {
-        testRealm.beginTransaction();
-        AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-        obj.setColumnLong(1);
-        obj.setColumnString("Foo");
-        testRealm.copyToRealm(obj);
-
-        AllTypesPrimaryKey newObj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
-        testRealm.commitTransaction();
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals("bar", newObj.getColumnString());
-    }
-
-
-    public void testCreateOrUpdateAll_noPrimaryKeyThrows() {
-        try {
-            testRealm.createOrUpdateAllFromJson(AllTypes.class, new JSONArray());
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateAllStream_noPrimaryKeyThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateAllFromJson(AllTypes.class, new TestHelper.StubInputStream());
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateAllStream_invalidJSonThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("["));
-        } catch (RealmException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateAllString_noPrimaryKeyThrows() throws IOException {
-        try {
-            testRealm.createOrUpdateAllFromJson(AllTypes.class, "{}");
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCreateOrUpdateAllJsonArray() throws JSONException, IOException {
-        String json = TestHelper.streamToString(loadJsonFromAssets("list_alltypes_primarykey.json"));
-        JSONArray array = new JSONArray(json);
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, array);
-        testRealm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
-    }
-
-    public void testCreateOrUpdateAllInputStream() throws IOException {
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, loadJsonFromAssets("list_alltypes_primarykey.json"));
-        testRealm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
-    }
-
-    public void testCreateOrUpdateAllString() throws IOException {
-        String json = TestHelper.streamToString(loadJsonFromAssets("list_alltypes_primarykey.json"));
-        testRealm.beginTransaction();
-        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
-        testRealm.commitTransaction();
-
-        assertAllTypesPrimaryKeyUpdated();
-    }
-
-    // Assert that the list of AllTypesPrimaryKey objects where inserted and updated properly.
-    private void assertAllTypesPrimaryKeyUpdated() {
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = testRealm.allObjects(AllTypesPrimaryKey.class).first();
-        assertEquals("Bar", obj.getColumnString());
-        assertEquals(2.23F, obj.getColumnFloat());
-        assertEquals(2.234D, obj.getColumnDouble());
-        assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[] {1,2,3}, obj.getColumnBinary());
-        assertEquals(new Date(2000), obj.getColumnDate());
-        assertEquals("Dog4", obj.getColumnRealmObject().getName());
-        assertEquals(2, obj.getColumnRealmList().size());
-        assertEquals("Dog5", obj.getColumnRealmList().get(0).getName());
-    }
-}
\ No newline at end of file
diff --git a/realm/src/androidTest/java/io/realm/RealmListTest.java b/realm/src/androidTest/java/io/realm/RealmListTest.java
deleted file mode 100644
index 0416875699..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmListTest.java
+++ /dev/null
@@ -1,468 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.CyclicType;
-import io.realm.entities.Dog;
-import io.realm.entities.Owner;
-import io.realm.exceptions.RealmException;
-
-public class RealmListTest extends AndroidTestCase {
-
-    public static final int TEST_OBJECTS = 10;
-    private Realm testRealm;
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
-        owner.setName("Owner");
-        for (int i = 0; i < TEST_OBJECTS; i++) {
-            Dog dog = testRealm.createObject(Dog.class);
-            dog.setName("Dog " + i);
-            owner.getDogs().add(dog);
-        }
-        testRealm.commitTransaction();
-    }
-
-    private RealmList<Dog> createNonManagedDogList() {
-        RealmList<Dog> list = new RealmList<Dog>();
-        for (int i = 0; i < TEST_OBJECTS; i++) {
-            list.add(new Dog("Dog " + i));
-        }
-        return list;
-    }
-
-    // Check that all methods work correctly on a empty RealmList
-    private void checkMethodsOnEmptyList(Realm realm, RealmList<Dog> list) {
-        realm.beginTransaction();
-        for (int i = 0; i < 4; i++) {
-            try {
-                switch(i) {
-                    case 0: list.get(0); break;
-                    case 1: list.remove(0); break;
-                    case 2: list.set(0, new Dog()); break;
-                    case 3: list.move(0,0); break;
-                }
-                fail();
-            } catch (IndexOutOfBoundsException expected) {
-            } catch (RealmException expected) {
-            }
-        }
-        realm.cancelTransaction();
-
-        assertEquals(0, list.size());
-        assertNull(list.first());
-        assertNull(list.last());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    /*********************************************************
-     * Non-Managed mode tests                                *
-     *********************************************************/
-
-    public void testPublicNoArgConstructor() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        assertNotNull(list);
-    }
-
-    public void testUnavailableMethods_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        try {
-            list.where();
-            fail("where() should fail in non-managed mode.");
-        } catch (RealmException ignore) {
-        }
-    }
-
-    public void testAdd_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object = new AllTypes();
-        object.setColumnString("String");
-        list.add(object);
-        assertEquals(1, list.size());
-        assertEquals(object, list.get(0));
-    }
-
-    public void testAddNull_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        try {
-            list.add(null);
-            fail("Adding null should not be be allowed");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    public void testAddManagedObject_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes =  testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
-        list.add(managedAllTypes);
-
-        assertEquals(managedAllTypes, list.get(0));
-    }
-
-    public void testAddAtIndex_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object = new AllTypes();
-        object.setColumnString("String");
-        list.add(0, object);
-        assertEquals(1, list.size());
-        assertEquals(object, list.get(0));
-    }
-
-    public void testAddManagedObjectAtIndex_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
-        list.add(0, managedAllTypes);
-
-        assertEquals(managedAllTypes, list.get(0));
-    }
-
-    public void testAddNullAtIndex_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        try {
-            list.add(null);
-            fail("Adding null should not be be allowed");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    public void testSet_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        list.set(0, new AllTypes());
-        assertEquals(1, list.size());
-    }
-
-    public void testSetNull_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        try {
-            list.set(0, null);
-            fail("Setting a null value should result in a exception");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    public void testSetManagedObject_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        testRealm.beginTransaction();
-        AllTypes managedAllTypes = testRealm.createObject(AllTypes.class);
-        testRealm.commitTransaction();
-        list.set(0, managedAllTypes);
-
-        assertEquals(managedAllTypes, list.get(0));
-    }
-
-    public void testClear_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        assertEquals(1, list.size());
-        list.clear();
-        assertTrue(list.isEmpty());
-    }
-
-    public void testRemove_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        list.add(object1);
-        AllTypes object2 = list.remove(0);
-        assertEquals(object1, object2);
-    }
-
-    public void testGet_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        list.add(object1);
-        AllTypes object2 = list.get(0);
-        assertEquals(object1, object2);
-    }
-
-    public void testSize_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        list.add(new AllTypes());
-        assertEquals(1, list.size());
-    }
-
-    // Test move where oldPosition > newPosition
-    public void testMoveDown() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        Dog dog1 = owner.getDogs().get(1);
-        testRealm.beginTransaction();
-        owner.getDogs().move(1, 0);
-        testRealm.commitTransaction();
-
-        assertEquals(0, owner.getDogs().indexOf(dog1));
-    }
-
-    // Test move where oldPosition < newPosition
-    public void testMoveUp() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        int oldIndex = TEST_OBJECTS / 2;
-        int newIndex = oldIndex + 1;
-        Dog dog = owner.getDogs().get(oldIndex);
-        testRealm.beginTransaction();
-        owner.getDogs().move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
-        testRealm.commitTransaction();
-
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
-        assertEquals(oldIndex, owner.getDogs().indexOf(dog));
-    }
-
-    public void testFirstAndLast_nonManagedMode() {
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
-        AllTypes object1 = new AllTypes();
-        AllTypes object2 = new AllTypes();
-        list.add(object1);
-        list.add(object2);
-
-        assertEquals(object1, list.first());
-        assertEquals(object2, list.last());
-    }
-
-    public void testEmptyList_nonManagedMode() {
-        RealmList<Dog> list = new RealmList<Dog>();
-        checkMethodsOnEmptyList(testRealm, list);
-    }
-
-    /*********************************************************
-     * Managed mode tests                                    *
-     *********************************************************/
-
-    // Test move where oldPosition > newPosition
-    public void testMoveDown_nonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
-        Dog dog1 = dogs.get(1);
-        dogs.move(1, 0);
-
-        assertEquals(0, dogs.indexOf(dog1));
-    }
-
-    // Test move where oldPosition < newPosition
-    public void testMoveUp_nonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
-        int oldIndex = TEST_OBJECTS / 2;
-        int newIndex = oldIndex + 1;
-        Dog dog = dogs.get(oldIndex);
-        dogs.move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
-
-        assertEquals(TEST_OBJECTS, dogs.size());
-        assertEquals(oldIndex, dogs.indexOf(dog));
-    }
-
-    public void testMoveOutOfBoundsLowerThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        try {
-            owner.getDogs().move(0, -1);
-            fail("Indexes < 0 should throw an exception");
-        } catch (IndexOutOfBoundsException ignored) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testMoveOutOfBoundsHigherThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        try {
-            int lastIndex = TEST_OBJECTS - 1;
-            int outOfBoundsIndex = TEST_OBJECTS;
-            owner.getDogs().move(lastIndex, outOfBoundsIndex);
-            fail("Indexes >= size() should throw an exception");
-        } catch (IndexOutOfBoundsException ignored) {
-            ignored.printStackTrace();
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testAddObject() {
-        testRealm.beginTransaction();
-        testRealm.clear(Owner.class);
-        Owner owner = testRealm.createObject(Owner.class);
-        Dog dog = testRealm.createObject(Dog.class);
-        owner.getDogs().add(dog);
-        testRealm.commitTransaction();
-
-        assertEquals(1, testRealm.where(Owner.class).findFirst().getDogs().size());
-    }
-
-    public void testAddObjectNullThrows() {
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
-        try {
-            owner.getDogs().add(null);
-            fail("Adding null values is not supported");
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testSize() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
-    }
-
-    public void testGetObjects() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        assertNotNull(dogs);
-        assertEquals("Dog 1", dogs.get(1).getName());
-    }
-
-    public void testFirstLast() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        assertEquals("Dog 0", dogs.first().getName());
-        assertEquals("Dog " + (TEST_OBJECTS - 1), dogs.last().getName());
-    }
-
-    public void testRemoveByIndex() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        Dog dog5 = dogs.get(5);
-
-        testRealm.beginTransaction();
-        Dog removedDog = dogs.remove(5);
-        testRealm.commitTransaction();
-
-        assertEquals(dog5, removedDog);
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
-    }
-
-    public void testRemoveLast() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        testRealm.beginTransaction();
-        dogs.remove(TEST_OBJECTS - 1);
-        testRealm.commitTransaction();
-
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
-    }
-
-    public void testRemoveFromEmptyListThrows() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-
-        testRealm.beginTransaction();
-        dogs.clear();
-        try {
-            dogs.remove(0);
-        } catch (IndexOutOfBoundsException expected) {
-            return;
-        } finally {
-            testRealm.cancelTransaction();
-        }
-        fail("Calling remove() should fail on an empty list.");
-    }
-
-    public void testRemoveByObject() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        Dog dog = dogs.get(0);
-
-        testRealm.beginTransaction();
-        boolean result = dogs.remove(dog);
-        testRealm.commitTransaction();
-
-        assertTrue(result);
-        assertEquals(TEST_OBJECTS - 1, dogs.size());
-    }
-
-    public void testQuery() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        Dog firstDog = dogs.where().equalTo("name", "Dog 0").findFirst();
-
-        assertNotNull(firstDog);
-    }
-
-    public void testEmptyListMethods() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        owner.getDogs().clear();
-        testRealm.commitTransaction();
-
-        checkMethodsOnEmptyList(testRealm, owner.getDogs());
-    }
-
-    public void testClear() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        assertEquals(TEST_OBJECTS, owner.getDogs().size());
-        owner.getDogs().clear();
-        assertEquals(0, owner.getDogs().size());
-        testRealm.commitTransaction();
-    }
-
-    public void testClearNotDeleting() {
-        Owner owner = testRealm.where(Owner.class).findFirst();
-        testRealm.beginTransaction();
-        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
-        owner.getDogs().clear();
-        assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
-        testRealm.commitTransaction();
-    }
-
-    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
-    public void testMutableMethodsOutsideWriteTransactions() {
-        testRealm.beginTransaction();
-        RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
-        Dog dog = testRealm.createObject(Dog.class);
-        list.add(dog);
-        testRealm.commitTransaction();
-
-        try { list.add(dog);    fail(); } catch (IllegalStateException expected) {}
-        try { list.add(0, dog); fail(); } catch (IllegalStateException expected) {}
-        try { list.clear();     fail(); } catch (IllegalStateException expected) {}
-        try { list.move(0, 1);  fail(); } catch (IllegalStateException expected) {}
-        try { list.remove(0);   fail(); } catch (IllegalStateException expected) {}
-        try { list.set(0, dog); fail(); } catch (IllegalStateException expected) {}
-    }
-
-    public void testSettingListClearsOldItems() {
-        testRealm.beginTransaction();
-        CyclicType one = testRealm.copyToRealm(new CyclicType());
-        CyclicType two = testRealm.copyToRealm(new CyclicType());
-        two.setObjects(new RealmList<CyclicType>(one));
-        two.setObjects(new RealmList<CyclicType>(one));
-        testRealm.commitTransaction();
-
-        assertEquals(1, two.getObjects().size());
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
deleted file mode 100644
index af6114b6cb..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ /dev/null
@@ -1,177 +0,0 @@
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.io.File;
-import java.io.IOException;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.FieldOrder;
-import io.realm.entities.AnnotationTypes;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.ColumnType;
-import io.realm.internal.Table;
-
-public class RealmMigrationTests extends AndroidTestCase {
-
-    public Realm realm;
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        Realm.deleteRealmFile(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        super.tearDown();
-        if (realm != null) {
-            realm.close();
-        }
-        Realm.setSchema(null);
-    }
-
-    public void testRealmClosedAfterMigrationException() throws IOException {
-        String REALM_NAME = "default0.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        TestHelper.copyRealmFromAssets(getContext(), REALM_NAME, REALM_NAME);
-        try {
-            Realm.getInstance(getContext(), REALM_NAME);
-            fail("A migration should be triggered");
-        } catch (RealmMigrationNeededException expected) {
-            Realm.deleteRealmFile(getContext(), REALM_NAME); // Delete old realm
-        }
-
-        // This should recreate the Realm with proper schema
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
-        int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
-        assertEquals(0, result);
-    }
-
-    // If a migration creates a different ordering of columns on Realm A, while another ordering is generated by
-    // creating a new Realm B. Global column indices will not work. They must be calculated for each Realm.
-    public void testLocalColumnIndices() throws IOException {
-        String MIGRATED_REALM = "migrated.realm";
-        String NEW_REALM = "new.realm";
-
-        // Migrate old Realm to proper schema
-        Realm.deleteRealmFile(getContext(), MIGRATED_REALM);
-        Realm.setSchema(AllTypes.class);
-        Realm migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
-        migratedRealm.close();
-        Realm.setSchema(AllTypes.class, FieldOrder.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), MIGRATED_REALM).getAbsolutePath(), new RealmMigration() {
-            @Override
-            public long execute(Realm realm, long version) {
-                Table languageTable = realm.getTable(FieldOrder.class);
-                if (languageTable.getColumnCount() == 0) {
-                    languageTable.addColumn(ColumnType.INTEGER, "field2");
-                    languageTable.addColumn(ColumnType.BOOLEAN, "field1");
-                }
-
-                return version + 1;
-            }
-        });
-
-        // Open migrated Realm and populate column indices based on migration ordering.
-        Realm.setSchema(AllTypes.class, FieldOrder.class);
-        migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
-
-        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
-        // instead of the migration
-        Realm.deleteRealmFile(getContext(), NEW_REALM);
-        Realm newRealm = Realm.getInstance(getContext(), NEW_REALM);
-        newRealm.close();
-
-        // Try to query migrated realm. With local column indices this will work. With global it will fail.
-        assertEquals(0, migratedRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
-    }
-
-    public void testNotSettingIndexThrows() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
-            @Override
-            public long execute(Realm realm, long version) {
-                Table table = realm.getTable(AnnotationTypes.class);
-                table.addColumn(ColumnType.INTEGER, "id");
-                table.setPrimaryKey("id");
-                table.addColumn(ColumnType.STRING, "indexString");
-                table.addColumn(ColumnType.STRING, "notIndexString");
-                // Forget to set @Index
-                return 1;
-            }
-        });
-
-        try {
-            realm = Realm.getInstance(getContext());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-        }
-    }
-
-    public void testNotSettingPrimaryKeyThrows() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
-            @Override
-            public long execute(Realm realm, long version) {
-                Table table = realm.getTable(AnnotationTypes.class);
-                table.addColumn(ColumnType.INTEGER, "id");
-                // Forget to set @PrimaryKey
-                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
-                table.addSearchIndex(columnIndex);
-                table.addColumn(ColumnType.STRING, "notIndexString");
-                return 1;
-            }
-        });
-
-        try {
-            realm = Realm.getInstance(getContext());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-        }
-    }
-
-    public void testSetAnnotations() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
-            @Override
-            public long execute(Realm realm, long version) {
-                Table table = realm.getTable(AnnotationTypes.class);
-                table.addColumn(ColumnType.INTEGER, "id");
-                table.setPrimaryKey("id");
-                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
-                table.addSearchIndex(columnIndex);
-                table.addColumn(ColumnType.STRING, "notIndexString");
-                return 1;
-            }
-        });
-
-        realm = Realm.getInstance(getContext());
-        Table table = realm.getTable(AnnotationTypes.class);
-        assertEquals(3, table.getColumnCount());
-        assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
-    }
-
-    public void testGetPathFromMigrationException() throws IOException {
-        TestHelper.copyRealmFromAssets(getContext(), "default0.realm", Realm.DEFAULT_REALM_NAME);
-        File realm = new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME);
-        try {
-            Realm.getInstance(getContext());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-            assertEquals(expected.getPath(), realm.getCanonicalPath());
-        }
-    }
-
-    // In default-before-migration.realm, CatOwner has a RealmList<Dog> field.
-    // This is changed to RealmList<Cat> and getInstance() must throw an exception.
-    public void testRealmListChanged() throws IOException {
-        TestHelper.copyRealmFromAssets(getContext(), "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
-        try {
-            realm = Realm.getInstance(getContext());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-        }
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
deleted file mode 100644
index b1d07dc5dd..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ /dev/null
@@ -1,513 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.util.Calendar;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.CyclicType;
-import io.realm.entities.Dog;
-import io.realm.entities.Thread;
-import io.realm.internal.Row;
-
-
-public class RealmObjectTest extends AndroidTestCase {
-
-    private Realm testRealm;
-
-    private static final int TEST_SIZE = 5;
-    private static final boolean REMOVE_FIRST = true;
-    private static final boolean REMOVE_LAST = false;
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-    // Row realmGetRow()
-    public void testRealmGetRowReturnsValidRow() {
-
-        testRealm.beginTransaction();
-        RealmObject realmObject = testRealm.createObject(AllTypes.class);
-
-        Row row = realmObject.row;
-
-        testRealm.commitTransaction();
-        assertNotNull("RealmObject.realmGetRow returns zero ", row);
-        assertEquals(9, row.getColumnCount());
-    }
-
-    public void testStringEncoding() {
-        String[] strings = {"ABCD", "ÆØÅ", "Ö∫Ë", "ΠΑΟΚ", "Здравей"};
-
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-
-        for (String str : strings) {
-            AllTypes obj1 = testRealm.createObject(AllTypes.class);
-            obj1.setColumnString(str);
-        }
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> objects = testRealm.allObjects(AllTypes.class);
-        assertEquals(strings.length, objects.size());
-        int i = 0;
-        for (AllTypes obj : objects) {
-            String s = obj.getColumnString();
-            assertEquals(strings[i], s);
-            i++;
-        }
-    }
-
-    // removing original object and see if has been removed
-    public void testRemoveFromRealm() {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        Dog rex = realm.createObject(Dog.class);
-        rex.setName("Rex");
-        Dog fido = realm.createObject(Dog.class);
-        fido.setName("Fido");
-        realm.commitTransaction();
-
-        RealmResults<Dog> allDogsBefore = realm.where(Dog.class).equalTo("name", "Rex").findAll();
-        assertEquals(1, allDogsBefore.size());
-
-        realm.beginTransaction();
-        rex.removeFromRealm();
-        realm.commitTransaction();
-
-        RealmResults<Dog> allDogsAfter = realm.where(Dog.class).equalTo("name", "Rex").findAll();
-        assertEquals(0  , allDogsAfter.size());
-
-        fido.getName();
-        try {
-            rex.getName();
-            realm.close();
-            fail();
-        } catch (IllegalStateException ignored) {}
-
-        // deleting rex twice should fail
-        realm.beginTransaction();
-        try {
-            rex.removeFromRealm();
-            realm.close();
-            fail();
-        } catch (IllegalStateException ignored) {}
-        realm.commitTransaction();
-        realm.close();
-    }
-
-    // query for an object, remove it and see it has been removed from realm
-    public void testRemoveResultFromRealm() {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        realm.clear(Dog.class);
-        Dog dogToAdd = realm.createObject(Dog.class);
-        dogToAdd.setName("Rex");
-        realm.commitTransaction();
-
-        assertEquals(1, realm.allObjects(Dog.class).size());
-
-        Dog dogToRemove = realm.where(Dog.class).findFirst();
-        assertNotNull(dogToRemove);
-        realm.beginTransaction();
-        dogToRemove.removeFromRealm();
-        realm.commitTransaction();
-
-        assertEquals(0, realm.allObjects(Dog.class).size());
-        try {
-            dogToAdd.getName();
-            realm.close();
-            fail();
-        }
-        catch (IllegalStateException ignored) {}
-        try {
-            dogToRemove.getName();
-            realm.close();
-            fail();
-        }
-        catch (IllegalStateException ignored) {}
-        realm.close();
-    }
-
-    public void removeOneByOne(boolean atFirst) {
-        Set<Long> ages = new HashSet<Long>();
-        testRealm.beginTransaction();
-        testRealm.clear(Dog.class);
-        for (int i = 0; i < TEST_SIZE; i++) {
-            Dog dog = testRealm.createObject(Dog.class);
-            dog.setAge(i);
-            ages.add((long) i);
-        }
-        testRealm.commitTransaction();
-
-        assertEquals(TEST_SIZE, testRealm.allObjects(Dog.class).size());
-
-        RealmResults<Dog> dogs = testRealm.allObjects(Dog.class);
-        for (int i = 0; i < TEST_SIZE; i++) {
-            testRealm.beginTransaction();
-            Dog dogToRemove;
-            if (atFirst) {
-                dogToRemove = dogs.first();
-            } else {
-                dogToRemove = dogs.last();
-            }
-            ages.remove(Long.valueOf(dogToRemove.getAge()));
-            dogToRemove.removeFromRealm();
-
-            // object is no longer valid
-            try {
-                dogToRemove.getAge();
-                fail();
-            }
-            catch (IllegalStateException ignored) {}
-
-            testRealm.commitTransaction();
-
-            // and removed from realm and remaining objects are place correctly
-            RealmResults<Dog> remainingDogs = testRealm.allObjects(Dog.class);
-            assertEquals(TEST_SIZE - i - 1, remainingDogs.size());
-            for (Dog dog : remainingDogs) {
-                assertTrue(ages.contains(Long.valueOf(dog.getAge())));
-            }
-        }
-    }
-
-    public void testRemoveFromRealmAtPosition() {
-        removeOneByOne(REMOVE_FIRST);
-        removeOneByOne(REMOVE_LAST);
-    }
-
-    public boolean methodWrongThread(final boolean callGetter) throws ExecutionException, InterruptedException {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-        final AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                try {
-                    if (callGetter) {
-                        allTypes.getColumnFloat();
-                    } else {
-                        allTypes.setColumnFloat(1.0f);
-                    }
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
-                }
-            }
-        });
-
-        Boolean result = future.get();
-        realm.close();
-        return result;
-    }
-
-    public void testGetSetWrongThread() throws ExecutionException, InterruptedException {
-        assertTrue(methodWrongThread(true));
-        assertTrue(methodWrongThread(false));
-    }
-
-    public void testEqualsSameRealmObject() {
-        testRealm.beginTransaction();
-        CyclicType ct = testRealm.createObject(CyclicType.class);
-        ct.setName("Foo");
-        testRealm.commitTransaction();
-
-        CyclicType ct1 = testRealm.where(CyclicType.class).findFirst();
-        CyclicType ct2 = testRealm.where(CyclicType.class).findFirst();
-
-        assertTrue(ct1.equals(ct2));
-        assertTrue(ct2.equals(ct1));
-    }
-
-    public void testEqualsDifferentRealmObjects() {
-        testRealm.beginTransaction();
-        CyclicType objA = testRealm.createObject(CyclicType.class);
-        objA.setName("Foo");
-        CyclicType objB = testRealm.createObject(CyclicType.class);
-        objB.setName("Bar");
-        testRealm.commitTransaction();
-
-        assertFalse(objA.equals(objB));
-        assertFalse(objB.equals(objA));
-    }
-
-    public void testEqualsAfterModification() {
-        testRealm.beginTransaction();
-        CyclicType ct = testRealm.createObject(CyclicType.class);
-        ct.setName("Foo");
-        testRealm.commitTransaction();
-
-        CyclicType ct1 = testRealm.where(CyclicType.class).findFirst();
-        CyclicType ct2 = testRealm.where(CyclicType.class).findFirst();
-
-        testRealm.beginTransaction();
-        ct1.setName("Baz");
-        testRealm.commitTransaction();
-
-        assertTrue(ct1.equals(ct1));
-        assertTrue(ct2.equals(ct2));
-    }
-
-    public void testEqualsStandAlone() {
-        testRealm.beginTransaction();
-        CyclicType ct1 = testRealm.createObject(CyclicType.class);
-        ct1.setName("Foo");
-        testRealm.commitTransaction();
-
-        CyclicType ct2 = new CyclicType();
-        ct2.setName("Bar");
-
-        assertFalse(ct1.equals(ct2));
-        assertFalse(ct2.equals(ct1));
-    }
-
-    public void testCyclicEquals() {
-        testRealm.beginTransaction();
-        CyclicType foo = createCyclicData();
-        testRealm.commitTransaction();
-
-        assertEquals(foo, testRealm.where(CyclicType.class).equalTo("name", "Foo").findFirst());
-    }
-
-    public void testCyclicToString() {
-        testRealm.beginTransaction();
-        CyclicType foo = createCyclicData();
-        testRealm.commitTransaction();
-
-        String expected = "CyclicType = [{name:Foo},{object:CyclicType},{objects:RealmList<CyclicType>[0]}]";
-        assertEquals(expected, foo.toString());
-    }
-
-    public void testCyclicHashCode() {
-        testRealm.beginTransaction();
-        CyclicType foo = createCyclicData();
-        testRealm.commitTransaction();
-
-        assertEquals(1344723738, foo.hashCode());
-    }
-
-    private CyclicType createCyclicData() {
-        CyclicType foo = testRealm.createObject(CyclicType.class);
-        foo.setName("Foo");
-        CyclicType bar = testRealm.createObject(CyclicType.class);
-        bar.setName("Bar");
-
-        // Setup cycle on normal object references
-        foo.setObject(bar);
-        bar.setObject(foo);
-        return foo;
-    }
-
-    public void testDateType() {
-        long testDatesNotValid[] = {Long.MIN_VALUE, Long.MAX_VALUE};
-        long testDatesValid[] = {-1000, 0, 1000};
-        long testDatesLoosePrecision[] = {1, 1001};
-
-        // test valid dates
-        testRealm.beginTransaction();
-        for (long value : testDatesValid) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnDate(new Date(value));
-        }
-        testRealm.commitTransaction();
-
-        int i = 0;
-        for (AllTypes allTypes : testRealm.allObjects(AllTypes.class)) {
-            assertEquals("Item " + i, new Date(testDatesValid[i]), allTypes.getColumnDate());
-            i++;
-        }
-
-        // test valid dates but with precision lost
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        for (long value : testDatesLoosePrecision) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnDate(new Date(value));
-        }
-        testRealm.commitTransaction();
-
-        i = 0;
-        for (AllTypes allTypes : testRealm.allObjects(AllTypes.class)) {
-            assertFalse("Item " + i, new Date(testDatesLoosePrecision[i]) == allTypes.getColumnDate());
-            assertEquals("Item " + i, new Date(1000*(testDatesLoosePrecision[i]/1000)), allTypes.getColumnDate());
-            i++;
-        }
-
-        // test invalid dates
-        for (long value : testDatesNotValid) {
-            try {
-                testRealm.beginTransaction();
-                testRealm.clear(AllTypes.class);
-                AllTypes allTypes = testRealm.createObject(AllTypes.class);
-                allTypes.setColumnDate(new Date(value));
-                testRealm.commitTransaction();
-                fail();
-            } catch (IllegalArgumentException ignored) { testRealm.cancelTransaction(); }
-        }
-    }
-
-    private Date newDate(int year, int month, int dayOfMonth) {
-        Calendar cal = Calendar.getInstance();
-        cal.set(Calendar.YEAR, year);
-        cal.set(Calendar.MONTH, month);
-        cal.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-        cal.set(Calendar.HOUR, 0);
-        cal.set(Calendar.MINUTE, 0);
-        cal.set(Calendar.MILLISECOND, 0);
-        return cal.getTime();
-    }
-
-    private void addDate(int year, int month, int dayOfMonth) {
-        Date date = newDate(year, month, dayOfMonth);
-
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnDate(date);
-        testRealm.commitTransaction();
-
-        AllTypes object = testRealm.allObjects(AllTypes.class).first();
-
-        // Realm does not support millisec precision
-        assertEquals(1000 * (date.getTime() / 1000), 1000 * (object.getColumnDate().getTime() / 1000));
-    }
-
-    public void testDateTypeOutOfRange() {
-        // ** Must throw if date is too old
-        for (int i = 0; i < 2; i++) {
-            try {
-                addDate(1900 + i, 1, 1);
-                fail();
-            } catch (IllegalArgumentException ignored) {
-                testRealm.cancelTransaction();
-            }
-        }
-
-        // ** Supported dates works
-        for (int i = 2; i < 10; i++) {
-            addDate(1900 + i, 1, 1);
-        }
-
-        // ** Must throw if date is too new
-        for (int i = 0; i < 2; i++) {
-            try {
-                addDate(2038 + i, 1, 20);
-                fail();
-            } catch (IllegalArgumentException ignored) {
-                testRealm.cancelTransaction();
-            }
-        }
-    }
-
-    public void testWriteMustThrowOutOfTransaction() {
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
-        testRealm.commitTransaction();
-
-        try {
-            dog.setName("Rex");
-            fail();
-        } catch (IllegalStateException ignored) {
-            // Don't fail
-        } catch (Exception ignored) {
-            fail();
-        }
-
-    }
-
-    public void testSetNullLink() {
-        testRealm.beginTransaction();
-        CyclicType objA = testRealm.createObject(CyclicType.class);
-        objA.setName("Foo");
-        CyclicType objB = testRealm.createObject(CyclicType.class);
-        objB.setName("Bar");
-
-        objA.setObject(objB);
-
-        assertNotNull(objA.getObject());
-
-        try {
-            objA.setObject(null);
-        } catch (NullPointerException nullPointer) {
-            fail();
-        }
-        testRealm.commitTransaction();
-        assertNull(objA.getObject());
-    }
-
-    public void testThreadModelClass() {
-        // The model class' name (Thread) clashed with a common Java class.
-        // The annotation process must be able to handle that.
-        testRealm.beginTransaction();
-        Thread thread = testRealm.createObject(Thread.class);
-        testRealm.commitTransaction();
-    }
-
-    public void testIsValidUnManagedObject() {
-        AllTypes allTypes = new AllTypes();
-        assertFalse(allTypes.isValid());
-    }
-
-    public void testIsValidClosedRealm() {
-        Realm.deleteRealmFile(getContext(), "other-realm");
-        Realm testRealm = Realm.getInstance(getContext(), "other-realm");
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        assertTrue(allTypes.isValid());
-        testRealm.commitTransaction();
-        testRealm.close();
-        assertFalse(allTypes.isValid());
-    }
-
-    public void testIsValidDeletedObject() {
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        assertTrue(allTypes.isValid());
-        testRealm.clear(AllTypes.class);
-        testRealm.commitTransaction();
-        assertFalse(allTypes.isValid());
-    }
-
-    public void testIsValidManagedObject() {
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        assertTrue(allTypes.isValid());
-        testRealm.commitTransaction();
-        assertTrue(allTypes.isValid());
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmQueryTest.java b/realm/src/androidTest/java/io/realm/RealmQueryTest.java
deleted file mode 100644
index 718c5195f0..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmQueryTest.java
+++ /dev/null
@@ -1,462 +0,0 @@
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.util.Date;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.Dog;
-import io.realm.entities.NonLatinFieldNames;
-import io.realm.entities.Owner;
-import io.realm.entities.StringOnly;
-
-public class RealmQueryTest extends AndroidTestCase{
-
-    protected final static int TEST_DATA_SIZE = 10;
-
-    protected Realm testRealm;
-
-    private final static String FIELD_STRING = "columnString";
-    private final static String FIELD_LONG = "columnLong";
-    private final static String FIELD_FLOAT = "columnFloat";
-    private final static String FIELD_LONG_KOREAN_CHAR = "델타";
-    private final static String FIELD_LONG_GREEK_CHAR = "Δέλτα";
-    private final static String FIELD_FLOAT_KOREAN_CHAR = "베타";
-    private final static String FIELD_FLOAT_GREEK_CHAR = "βήτα";
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        if (testRealm != null)
-            testRealm.close();
-    }
-
-    private void populateTestRealm(int objects) {
-        testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
-        for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 3) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
-            allTypes.setColumnFloat(1.234567f + i);
-            allTypes.setColumnString("test data " + i);
-            allTypes.setColumnLong(i);
-            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
-            nonLatinFieldNames.set델타(i);
-            nonLatinFieldNames.setΔέλτα(i);
-            nonLatinFieldNames.set베타(1.234567f + i);
-            nonLatinFieldNames.setΒήτα(1.234567f + i);
-        }
-        testRealm.commitTransaction();
-    }
-
-    private void populateTestRealm() {
-        populateTestRealm(TEST_DATA_SIZE);
-    }
-
-    public void testRealmQueryBetween() {
-        final int TEST_OBJECTS_COUNT = 200;
-        populateTestRealm(TEST_OBJECTS_COUNT);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .between(FIELD_LONG, 0, 9).findAll();
-        assertEquals(10, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).beginsWith(FIELD_STRING, "test data ").findAll();
-        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).beginsWith(FIELD_STRING, "test data 1")
-                .between(FIELD_LONG, 2, 20).findAll();
-        assertEquals(10, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).between(FIELD_LONG, 2, 20)
-                .beginsWith(FIELD_STRING, "test data 1").findAll();
-        assertEquals(10, resultList.size());
-    }
-
-    public void testRealmQueryGreaterThan() {
-        final int TEST_OBJECTS_COUNT = 200;
-        populateTestRealm(TEST_OBJECTS_COUNT);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .greaterThan(FIELD_FLOAT, 10.234567f).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 10, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).beginsWith(FIELD_STRING, "test data 1")
-                .greaterThan(FIELD_FLOAT, 50.234567f).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
-
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).greaterThan(FIELD_FLOAT, 11.234567f);
-        resultList = query.between(FIELD_LONG, 1, 20).findAll();
-        assertEquals(10, resultList.size());
-    }
-
-
-    public void testRealmQueryGreaterThanOrEqualTo() {
-        final int TEST_OBJECTS_COUNT = 200;
-        populateTestRealm(TEST_OBJECTS_COUNT);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .greaterThanOrEqualTo(FIELD_FLOAT, 10.234567f).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 9, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).beginsWith(FIELD_STRING, "test data 1")
-                .greaterThanOrEqualTo(FIELD_FLOAT, 50.234567f).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 100, resultList.size());
-
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class)
-                .greaterThanOrEqualTo(FIELD_FLOAT, 11.234567f);
-        query = query.between(FIELD_LONG, 1, 20);
-
-        resultList = query.beginsWith(FIELD_STRING, "test data 15").findAll();
-        assertEquals(1, resultList.size());
-    }
-
-    public void testRealmQueryOr() {
-        populateTestRealm(200);
-
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).equalTo(FIELD_FLOAT, 31.234567f);
-        RealmResults<AllTypes> resultList = query.or().between(FIELD_LONG, 1, 20).findAll();
-        assertEquals(21, resultList.size());
-
-        resultList = query.or().equalTo(FIELD_STRING, "test data 15").findAll();
-        assertEquals(21, resultList.size());
-
-        resultList = query.or().equalTo(FIELD_STRING, "test data 117").findAll();
-        assertEquals(22, resultList.size());
-    }
-
-    public void testRealmQueryNot() {
-        populateTestRealm(); // create TEST_DATA_SIZE objects
-
-        // only one object with value 5 -> TEST_DATA_SIZE-1 object with value "not 5"
-        RealmResults<AllTypes> list1 = testRealm.where(AllTypes.class).not().equalTo(FIELD_LONG, 5).findAll();
-        assertEquals(TEST_DATA_SIZE - 1, list1.size());
-
-        // not().greater() and lessThenOrEqual() must be the same
-        RealmResults<AllTypes> list2 = testRealm.where(AllTypes.class).not().greaterThan(FIELD_LONG, 5).findAll();
-        RealmResults<AllTypes> list3 = testRealm.where(AllTypes.class).lessThanOrEqualTo(FIELD_LONG, 5).findAll();
-        assertEquals(list2.size(), list3.size());
-        for (int i = 0; i < list2.size(); i++) {
-            assertEquals(list2.get(i).getColumnLong(), list3.get(i).getColumnLong());
-        }
-
-        // excepted result: 0, 1, 2, 5
-        long expected[] = {0, 1, 2, 5};
-        RealmResults<AllTypes> list4 = testRealm.where(AllTypes.class)
-                .equalTo(FIELD_LONG, 5)
-                .or()
-                .not().beginGroup()
-                    .greaterThan(FIELD_LONG, 2)
-                 .endGroup()
-                .findAll();
-        assertEquals(4, list4.size());
-        for (int i = 0; i < list4.size(); i++) {
-            assertEquals(expected[i], list4.get(i).getColumnLong());
-        }
-    }
-
-    public void testRealmQueryNotFailure() {
-        // a not() alone must fail
-        try {
-            RealmResults<AllTypes> list = testRealm.where(AllTypes.class).not().findAll();
-            fail();
-        } catch (RuntimeException ignored) {
-        }
-    }
-
-    public void testRealmQueryImplicitAnd() {
-        populateTestRealm(200);
-
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).equalTo(FIELD_FLOAT, 31.234567f);
-        RealmResults<AllTypes> resultList = query.between(FIELD_LONG, 1, 10).findAll();
-        assertEquals(0, resultList.size());
-
-        query = testRealm.where(AllTypes.class).equalTo(FIELD_FLOAT, 81.234567f);
-        resultList = query.between(FIELD_LONG, 1, 100).findAll();
-        assertEquals(1, resultList.size());
-    }
-
-    public void testRealmQueryLessThan() {
-        populateTestRealm(200);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).
-                lessThan(FIELD_FLOAT, 31.234567f).findAll();
-        assertEquals(30, resultList.size());
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).lessThan(FIELD_FLOAT, 31.234567f);
-        resultList = query.between(FIELD_LONG, 1, 10).findAll();
-        assertEquals(10, resultList.size());
-    }
-
-    public void testRealmQueryLessThanOrEqual() {
-        populateTestRealm(200);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .lessThanOrEqualTo(FIELD_FLOAT, 31.234567f).findAll();
-        assertEquals(31, resultList.size());
-        resultList = testRealm.where(AllTypes.class).lessThanOrEqualTo(FIELD_FLOAT, 31.234567f)
-                .between(FIELD_LONG, 11, 20).findAll();
-        assertEquals(10, resultList.size());
-    }
-
-    public void testRealmQueryEqualTo() {
-        populateTestRealm(200);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .equalTo(FIELD_FLOAT, 31.234567f).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(AllTypes.class).greaterThan(FIELD_FLOAT, 11.0f)
-                .equalTo(FIELD_LONG, 10).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(AllTypes.class).greaterThan(FIELD_FLOAT, 11.0f)
-                .equalTo(FIELD_LONG, 1).findAll();
-        assertEquals(0, resultList.size());
-    }
-
-    public void testRealmQueryEqualToNonLatinCharacters() {
-        populateTestRealm(200);
-
-        RealmResults<NonLatinFieldNames> resultList = testRealm.where(NonLatinFieldNames.class)
-                .equalTo(FIELD_LONG_KOREAN_CHAR, 13).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(NonLatinFieldNames.class)
-                .greaterThan(FIELD_FLOAT_KOREAN_CHAR, 11.0f)
-                .equalTo(FIELD_LONG_KOREAN_CHAR, 10).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(NonLatinFieldNames.class)
-                .greaterThan(FIELD_FLOAT_KOREAN_CHAR, 11.0f)
-                .equalTo(FIELD_LONG_KOREAN_CHAR, 1).findAll();
-        assertEquals(0, resultList.size());
-
-        resultList = testRealm.where(NonLatinFieldNames.class)
-                .equalTo(FIELD_LONG_GREEK_CHAR, 13).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(NonLatinFieldNames.class)
-                .greaterThan(FIELD_FLOAT_GREEK_CHAR, 11.0f)
-                .equalTo(FIELD_LONG_GREEK_CHAR, 10).findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(NonLatinFieldNames.class)
-                .greaterThan(FIELD_FLOAT_GREEK_CHAR, 11.0f)
-                .equalTo(FIELD_LONG_GREEK_CHAR, 1).findAll();
-        assertEquals(0, resultList.size());
-    }
-
-    public void testRealmQueryNotEqualTo() {
-        final int TEST_OBJECTS_COUNT = 200;
-        populateTestRealm(TEST_OBJECTS_COUNT);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .notEqualTo(FIELD_LONG, 31).findAll();
-        assertEquals(TEST_OBJECTS_COUNT - 1, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).notEqualTo(FIELD_FLOAT, 11.234567f)
-                .equalTo(FIELD_LONG, 10).findAll();
-        assertEquals(0, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).notEqualTo(FIELD_FLOAT, 11.234567f)
-                .equalTo(FIELD_LONG, 1).findAll();
-        assertEquals(1, resultList.size());
-    }
-
-    public void testRealmQueryContainsAndCaseSensitive() {
-        final int TEST_OBJECTS_COUNT = 200;
-        populateTestRealm(TEST_OBJECTS_COUNT);
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .contains("columnString", "DaTa 0", RealmQuery.CASE_INSENSITIVE)
-                .or().contains("columnString", "20")
-                .findAll();
-        assertEquals(3, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).contains("columnString", "DATA").findAll();
-        assertEquals(0, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class)
-                .contains("columnString", "TEST", RealmQuery.CASE_INSENSITIVE).findAll();
-        assertEquals(TEST_OBJECTS_COUNT, resultList.size());
-    }
-
-    public void testRealmQueryContainsAndCaseSensitiveWithNonLatinCharacters() {
-        populateTestRealm();
-
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes at1 = testRealm.createObject(AllTypes.class);
-        at1.setColumnString("Αλφα");
-        AllTypes at2 = testRealm.createObject(AllTypes.class);
-        at2.setColumnString("βήτα");
-        AllTypes at3 = testRealm.createObject(AllTypes.class);
-        at3.setColumnString("δέλτα");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class)
-                .contains("columnString", "Α", RealmQuery.CASE_INSENSITIVE)
-                .or().contains("columnString", "δ")
-                .findAll();
-        // Without case sensitive there is 3, Α = α
-        // assertEquals(3,resultList.size());
-        assertEquals(2, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).contains("columnString", "α").findAll();
-        assertEquals(3, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).contains("columnString", "Δ").findAll();
-        assertEquals(0, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).contains("columnString", "Δ",
-                RealmQuery.CASE_INSENSITIVE).findAll();
-        // Without case sensitive there is 1, Δ = δ
-        // assertEquals(1,resultList.size());
-        assertEquals(0, resultList.size());
-    }
-
-    public void testQueryWithNonExistingField() {
-        try {
-            testRealm.where(AllTypes.class).equalTo("NotAField", 13).findAll();
-            fail("Should throw exception");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    public void testRealmQueryLink() {
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
-        Dog dog1 = testRealm.createObject(Dog.class);
-        dog1.setName("Dog 1");
-        dog1.setWeight(1);
-        Dog dog2 = testRealm.createObject(Dog.class);
-        dog2.setName("Dog 2");
-        dog2.setWeight(2);
-        owner.getDogs().add(dog1);
-        owner.getDogs().add(dog2);
-        testRealm.commitTransaction();
-
-        // Dog.weight has index 4 which is more than the total number of columns in Owner
-        // This tests exposes a subtle error where the Owner tablespec is used instead of Dog tablespec.
-        RealmResults<Dog> dogs = testRealm.where(Owner.class).findFirst().getDogs().where()
-                .findAllSorted("name", RealmResults.SORT_ORDER_ASCENDING);
-        Dog dog = dogs.where().equalTo("weight", 1d).findFirst();
-        assertEquals(dog1, dog);
-    }
-
-
-    public void testSortMultiFailures() {
-        // zero fields specified
-        try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class)
-                    .findAllSorted(new String[]{}, new boolean[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-
-        // number of fields and sorting orders don't match
-        try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class)
-                    .findAllSorted(new String[]{FIELD_STRING},
-                            new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-
-        // null is not allowed
-        try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class).findAllSorted(null, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-        try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class).findAllSorted(new String[]{FIELD_STRING},
-                    null);
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-
-        // non-existing field name
-        try {
-            RealmResults<AllTypes> results = testRealm.where(AllTypes.class)
-                    .findAllSorted(new String[]{FIELD_STRING, "dont-exist"},
-                            new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-    }
-
-    public void testSortSingleField() {
-        testRealm.beginTransaction();
-        for (int i = 0; i < TEST_DATA_SIZE; i++) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnLong(i);
-        }
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> sortedList = testRealm.where(AllTypes.class)
-                .findAllSorted(new String[]{FIELD_LONG}, new boolean[]{RealmResults.SORT_ORDER_DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    public void testSubqueryScope() {
-        populateTestRealm();
-        RealmResults<AllTypes> result = testRealm.where(AllTypes.class).lessThan("columnLong", 5).findAll();
-        RealmResults<AllTypes> subQueryResult = result.where().greaterThan("columnLong", 3).findAll();
-        assertEquals(1, subQueryResult.size());
-    }
-
-    public void testFindFirst() {
-        testRealm.beginTransaction();
-        Owner owner1 = testRealm.createObject(Owner.class);
-        owner1.setName("Owner 1");
-        Dog dog1 = testRealm.createObject(Dog.class);
-        dog1.setName("Dog 1");
-        dog1.setWeight(1);
-        Dog dog2 = testRealm.createObject(Dog.class);
-        dog2.setName("Dog 2");
-        dog2.setWeight(2);
-        owner1.getDogs().add(dog1);
-        owner1.getDogs().add(dog2);
-
-        Owner owner2 = testRealm.createObject(Owner.class);
-        owner2.setName("Owner 2");
-        Dog dog3 = testRealm.createObject(Dog.class);
-        dog3.setName("Dog 3");
-        dog3.setWeight(1);
-        Dog dog4 = testRealm.createObject(Dog.class);
-        dog4.setName("Dog 4");
-        dog4.setWeight(2);
-        owner2.getDogs().add(dog3);
-        owner2.getDogs().add(dog4);
-        testRealm.commitTransaction();
-
-        RealmList<Dog> dogs = testRealm.where(Owner.class).equalTo("name", "Owner 2").findFirst().getDogs();
-        Dog dog = dogs.where().equalTo("name", "Dog 4").findFirst();
-        assertEquals(dog4, dog);
-    }
-
-    public void testGeorgian() {
-        String words[] = {"მონაცემთა ბაზა", "მიწისქვეშა გადასასვლელი", "რუსთაველის გამზირი",
-                "მთავარი ქუჩა", "სადგურის მოედანი", "ველოცირაპტორების ჯოგი"};
-        String sorted[] = {"ველოცირაპტორების ჯოგი", "მთავარი ქუჩა", "მიწისქვეშა გადასასვლელი",
-                "მონაცემთა ბაზა", "რუსთაველის გამზირი", "სადგურის მოედანი"};
-
-        testRealm.beginTransaction();
-        testRealm.clear(StringOnly.class);
-        for (String word : words) {
-            StringOnly stringOnly = testRealm.createObject(StringOnly.class);
-            stringOnly.setChars(word);
-        }
-        testRealm.commitTransaction();
-
-        RealmResults<StringOnly> stringOnlies1 = testRealm.where(StringOnly.class).contains("chars", "მთავარი").findAll();
-        assertEquals(1, stringOnlies1.size());
-
-        RealmResults<StringOnly> stringOnlies2 = testRealm.allObjects(StringOnly.class);
-        stringOnlies2.sort("chars");
-        for (int i = 0; i < stringOnlies2.size(); i++) {
-            assertEquals(sorted[i], stringOnlies2.get(i).getChars());
-        }
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsTest.java b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
deleted file mode 100644
index 96a63007b8..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmResultsTest.java
+++ /dev/null
@@ -1,726 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.test.AndroidTestCase;
-
-import java.util.Date;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.Cat;
-import io.realm.entities.Dog;
-import io.realm.entities.NonLatinFieldNames;
-import io.realm.entities.Owner;
-
-public class RealmResultsTest extends AndroidTestCase {
-    protected final static int TEST_DATA_SIZE = 2516;
-    protected final static int TEST_DATA_FIRST_HALF = 2 * (TEST_DATA_SIZE / 4) - 1;
-    protected final static int TEST_DATA_LAST_HALF = 2 * (TEST_DATA_SIZE / 4) + 1;
-
-
-    protected Realm testRealm;
-
-    private final static String FIELD_STRING = "columnString";
-    private final static String FIELD_LONG = "columnLong";
-    private final static String FIELD_FLOAT = "columnFloat";
-    private final static String FIELD_DOUBLE = "columnDouble";
-    private final static String FIELD_BOOLEAN = "columnBoolean";
-    private final static String FIELD_DATE = "columnDate";
-    private final static String FIELD_KOREAN_CHAR = "델타";
-    private final static String FIELD_GREEK_CHAR = "Δέλτα";
-
-    @Override
-    protected void setUp() throws InterruptedException {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-        populateTestRealm();
-    }
-
-    private void populateTestRealm(int objects) {
-        testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
-
-        for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 2) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date((long) 1000 * i));
-            allTypes.setColumnDouble(3.1415 + i);
-            allTypes.setColumnFloat(1.234567f + i);
-            allTypes.setColumnString("test data " + i);
-            allTypes.setColumnLong(i);
-            Dog d = testRealm.createObject(Dog.class);
-            d.setName("Foo " + i);
-            allTypes.setColumnRealmObject(d);
-            allTypes.getColumnRealmList().add(d);
-            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
-            nonLatinFieldNames.set델타(i);
-            nonLatinFieldNames.setΔέλτα(i);
-        }
-        testRealm.commitTransaction();
-    }
-
-    private void populateTestRealm() {
-        populateTestRealm(TEST_DATA_SIZE);
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
-    }
-
-
-    public void testMethodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
-        for (Method method : Method.values()) {
-            assertTrue(methodWrongThread(method));
-        }
-    }
-
-    private enum Method {
-        METHOD_MIN,
-        METHOD_MAX,
-        METHOD_SUM,
-        METHOD_AVG,
-        METHOD_SORT,
-        METHOD_WHERE
-    }
-
-    public boolean methodWrongThread(final Method method) throws ExecutionException, InterruptedException {
-        final RealmResults<AllTypes> allTypeses = testRealm.where(AllTypes.class).findAll();
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                try {
-                    switch (method) {
-                        case METHOD_MIN:
-                            allTypeses.min(FIELD_FLOAT);
-                            break;
-                        case METHOD_MAX:
-                            allTypeses.max(FIELD_FLOAT);
-                            break;
-                        case METHOD_SUM:
-                            allTypeses.sum(FIELD_FLOAT);
-                            break;
-                        case METHOD_AVG:
-                            allTypeses.average(FIELD_FLOAT);
-                            break;
-                        case METHOD_SORT:
-                            allTypeses.sort(FIELD_FLOAT);
-                            break;
-                        case METHOD_WHERE:
-                            allTypeses.where();
-                    }
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
-                }
-            }
-        });
-        return future.get();
-    }
-
-    // test io.realm.ResultList Api
-
-    // void clear(Class<?> classSpec)
-    public void testClearEmptiesTable() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, resultList.size());
-
-        testRealm.beginTransaction();
-        resultList.clear();
-        testRealm.commitTransaction();
-
-        assertEquals(0, resultList.size());
-    }
-
-    /*public void testRemoveLastShouldFail() {
-        RealmResults<AllTypes> resultsList = realm.where(AllTypes.class).equalTo(FIELD_STRING, "Not there").findAll();
-        try {
-            realm.beginTransaction();
-            resultsList.removeLast();
-            fail("Should give exception");
-        } catch (IllegalArgumentException e) {
-
-        } finally {
-            realm.commitTransaction();
-        }
-    }*/
-
-    public void testResultListGet() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.get(0);
-        assertTrue(allTypes.getColumnString().startsWith("test data"));
-    }
-
-    public void testResultListFirstIsFirst() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.first();
-        assertTrue(allTypes.getColumnString().startsWith("test data 0"));
-    }
-
-    public void testResultListLastIsLast() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        AllTypes allTypes = resultList.last();
-        assertEquals((TEST_DATA_SIZE - 1), allTypes.getColumnLong());
-    }
-
-    public void testMinValueIsMinValue() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        Number minimum = resultList.min(FIELD_LONG);
-        assertEquals(0, minimum.intValue());
-    }
-
-    public void testMaxValueIsMaxValue() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        Number maximum = resultList.max(FIELD_LONG);
-        assertEquals(TEST_DATA_SIZE - 1, maximum.intValue());
-    }
-
-    public void testSumGivesCorrectValue() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-
-        Number sum = resultList.sum(FIELD_LONG);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-    }
-
-    public void testSumGivesCorrectValueWithNonLatinColumnNames() {
-        RealmResults<NonLatinFieldNames> resultList = testRealm.where(NonLatinFieldNames.class).findAll();
-
-        Number sum = resultList.sum(FIELD_KOREAN_CHAR);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-
-        sum = resultList.sum(FIELD_GREEK_CHAR);
-        // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_DATA_SIZE - 1) * TEST_DATA_SIZE / 2, sum.intValue());
-    }
-
-    public void testAvgGivesCorrectValue() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        double N = (double) TEST_DATA_SIZE;
-
-        // Sum of numbers 1 to M: M*(M+1)/2
-        // See setUp() for values of fields
-        // N = TEST_DATA_SIZE
-
-        // Type: double; a = 3.1415
-        // a, a+1, ..., a+i, ..., a+N-1
-        // sum = 3.1415*N + N*(N-1)/2
-        // average = sum/N = 3.1415+(N-1)/2
-        double average = 3.1415 + (N - 1.0) * 0.5;
-        assertEquals(average, resultList.average(FIELD_DOUBLE), 0.0001);
-
-        // Type: long
-        // 0, 1, ..., N-1
-        // sum = N*(N-1)/2
-        // average = sum/N = (N-1)/2
-        assertEquals(0.5 * (N - 1), resultList.average(FIELD_LONG), 0.0001);
-
-        // Type: float; b = 1.234567
-        // b, b+1, ..., b+i, ..., b+N-1
-        // sum = b*N + N*(N-1)/2
-        // average = sum/N = b + (N-1)/2
-        assertEquals(1.234567 + 0.5 * (N - 1.0), resultList.average(FIELD_FLOAT), 0.0001);
-    }
-
-    public void testRemove() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        testRealm.beginTransaction();
-        resultList.remove(0);
-        testRealm.commitTransaction();
-
-        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
-
-        AllTypes allTypes = resultList.get(0);
-        assertEquals(1, allTypes.getColumnLong());
-    }
-
-    public void testRemoveLast() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        testRealm.beginTransaction();
-        resultList.removeLast();
-        testRealm.commitTransaction();
-
-        assertEquals("ResultList.removeLast did not remove record", TEST_DATA_SIZE - 1, resultList.size());
-
-        AllTypes allTypes = resultList.get(resultList.size() - 1);
-        assertEquals("ResultList.removeLast unexpected last record", TEST_DATA_SIZE - 2, allTypes.getColumnLong());
-
-        RealmResults<AllTypes> resultListCheck = testRealm.where(AllTypes.class).findAll();
-        assertEquals("ResultList.removeLast not committed", TEST_DATA_SIZE - 1, resultListCheck.size());
-    }
-
-    public void testRemoveLastEmptyList() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        testRealm.beginTransaction();
-        resultList.clear();
-        assertEquals(0, resultList.size());
-        resultList.removeLast();
-        testRealm.commitTransaction();
-
-        assertEquals(0, resultList.size());
-    }
-
-    public void testSortByLong() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = testRealm.allObjects(AllTypes.class);
-        sortedList.sort(FIELD_LONG, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals("Should have same size", resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("First excepted to be last", resultList.first().getColumnLong(), sortedList.last().getColumnLong());
-
-        RealmResults<AllTypes> reverseList = sortedList;
-        reverseList.sort(FIELD_LONG, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("First excepted to be first", resultList.first().getColumnLong(), reverseList.first().getColumnLong());
-        assertEquals("Last excepted to be last", resultList.last().getColumnLong(), reverseList.last().getColumnLong());
-
-        RealmResults<AllTypes> reserveSortedList = reverseList;
-        reverseList.sort(FIELD_LONG, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
-    }
-
-    public void testSortByDate() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(FIELD_DATE, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnDate(), sortedList.last().getColumnDate());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(FIELD_DATE, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnDate(), reverseList.first().getColumnDate());
-        assertEquals(resultList.last().getColumnDate(), reverseList.last().getColumnDate());
-
-        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
-        reserveSortedList.sort(FIELD_DATE, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
-    }
-
-    public void testSortByBoolean() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(false, sortedList.last().isColumnBoolean());
-        assertEquals(true, sortedList.first().isColumnBoolean());
-        assertEquals(true, sortedList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
-        assertEquals(false, sortedList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(true, reverseList.last().isColumnBoolean());
-        assertEquals(false, reverseList.first().isColumnBoolean());
-        assertEquals(false, reverseList.get(TEST_DATA_FIRST_HALF).isColumnBoolean());
-        assertEquals(true, reverseList.get(TEST_DATA_LAST_HALF).isColumnBoolean());
-
-        RealmResults<AllTypes> reserveSortedList = reverseList.where().findAll();
-        reserveSortedList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
-        assertEquals(reserveSortedList.first(), sortedList.first());
-    }
-
-    public void testSortByString() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnString(), sortedList.last().getColumnString());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(FIELD_STRING, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnString(), reverseList.first().getColumnString());
-
-        int numberOfDigits = 1 + ((int) Math.log10(TEST_DATA_SIZE));
-        int largestNumber = 1;
-        for (int i = 1; i < numberOfDigits; i++)
-            largestNumber *= 10;  // 10*10* ... *10
-        largestNumber = largestNumber - 1;
-        assertEquals(resultList.get(largestNumber).getColumnString(), reverseList.last().getColumnString());
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseList.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    public void testSortByDouble() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnDouble(), sortedList.last().getColumnDouble());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnDouble(), reverseList.first().getColumnDouble());
-        assertEquals(resultList.last().getColumnDouble(), reverseList.last().getColumnDouble());
-
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseSortedList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    public void testSortByFloat() {
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.where().findAll();
-        sortedList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(resultList.size(), sortedList.size());
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(resultList.first().getColumnFloat(), sortedList.last().getColumnFloat());
-
-        RealmResults<AllTypes> reverseList = sortedList.where().findAll();
-        reverseList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(resultList.first().getColumnFloat(), reverseList.first().getColumnFloat());
-        assertEquals(resultList.last().getColumnFloat(), reverseList.last().getColumnFloat());
-
-        RealmResults<AllTypes> reverseSortedList = reverseList.where().findAll();
-        reverseSortedList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseSortedList.size());
-    }
-
-    public void testSortOnNonExistingColumn() {
-        try {
-            RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-            resultList.sort("Non-existing");
-            fail("Column should not exist");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    public void testSortWithDanishCharacters() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes at1 = testRealm.createObject(AllTypes.class);
-        at1.setColumnString("Æble");
-        AllTypes at2 = testRealm.createObject(AllTypes.class);
-        at2.setColumnString("Øl");
-        AllTypes at3 = testRealm.createObject(AllTypes.class);
-        at3.setColumnString("Århus");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("Æble", sortedResult.first().getColumnString());
-        assertEquals("Æble", sortedResult.get(0).getColumnString());
-        assertEquals("Øl", sortedResult.get(1).getColumnString());
-        assertEquals("Århus", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("Æble", reverseResult.last().getColumnString());
-        assertEquals("Århus", reverseResult.get(0).getColumnString());
-        assertEquals("Øl", reverseResult.get(1).getColumnString());
-        assertEquals("Æble", reverseResult.get(2).getColumnString());
-    }
-
-    public void testSortWithRussianCharacters() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes at1 = testRealm.createObject(AllTypes.class);
-        at1.setColumnString("Санкт-Петербург");
-        AllTypes at2 = testRealm.createObject(AllTypes.class);
-        at2.setColumnString("Москва");
-        AllTypes at3 = testRealm.createObject(AllTypes.class);
-        at3.setColumnString("Новороссийск");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("Москва", sortedResult.first().getColumnString());
-        assertEquals("Москва", sortedResult.get(0).getColumnString());
-        assertEquals("Новороссийск", sortedResult.get(1).getColumnString());
-        assertEquals("Санкт-Петербург", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("Москва", reverseResult.last().getColumnString());
-        assertEquals("Санкт-Петербург", reverseResult.get(0).getColumnString());
-        assertEquals("Новороссийск", reverseResult.get(1).getColumnString());
-        assertEquals("Москва", reverseResult.get(2).getColumnString());
-    }
-
-    public void testSortWithGreekCharacters() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes at1 = testRealm.createObject(AllTypes.class);
-        at1.setColumnString("αύριο");
-        AllTypes at2 = testRealm.createObject(AllTypes.class);
-        at2.setColumnString("ημέρες");
-        AllTypes at3 = testRealm.createObject(AllTypes.class);
-        at3.setColumnString("δοκιμές");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(FIELD_STRING);
-
-        assertEquals(3, sortedResult.size());
-        assertEquals("αύριο", sortedResult.first().getColumnString());
-        assertEquals("αύριο", sortedResult.get(0).getColumnString());
-        assertEquals("δοκιμές", sortedResult.get(1).getColumnString());
-        assertEquals("ημέρες", sortedResult.get(2).getColumnString());
-
-        RealmResults<AllTypes> reverseResult = result.where().findAll();
-        reverseResult.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(3, reverseResult.size());
-        assertEquals("αύριο", reverseResult.last().getColumnString());
-        assertEquals("ημέρες", reverseResult.get(0).getColumnString());
-        assertEquals("δοκιμές", reverseResult.get(1).getColumnString());
-        assertEquals("αύριο", reverseResult.get(2).getColumnString());
-    }
-
-    //No sorting order defined. There are Korean, Arabic and Chinese characters.
-    public void testSortWithManyDifferentCharacters() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes at1 = testRealm.createObject(AllTypes.class);
-        at1.setColumnString("단위");
-        AllTypes at2 = testRealm.createObject(AllTypes.class);
-        at2.setColumnString("테스트");
-        AllTypes at3 = testRealm.createObject(AllTypes.class);
-        at3.setColumnString("وحدة");
-        AllTypes at4 = testRealm.createObject(AllTypes.class);
-        at4.setColumnString("اختبار");
-        AllTypes at5 = testRealm.createObject(AllTypes.class);
-        at5.setColumnString("单位");
-        AllTypes at6 = testRealm.createObject(AllTypes.class);
-        at6.setColumnString("试验");
-        AllTypes at7 = testRealm.createObject(AllTypes.class);
-        at7.setColumnString("單位");
-        AllTypes at8 = testRealm.createObject(AllTypes.class);
-        at8.setColumnString("測試");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-        RealmResults<AllTypes> sortedResult = result.where().findAll();
-        sortedResult.sort(FIELD_STRING);
-
-        assertEquals(8, sortedResult.size());
-
-        RealmResults<AllTypes> reverseResult = result;
-        reverseResult.sort(FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(8, reverseResult.size());
-    }
-
-    public void testSortWithTwoLanguages() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes allTypes1 = testRealm.createObject(AllTypes.class);
-        allTypes1.setColumnString("test");
-        AllTypes allTypes2 = testRealm.createObject(AllTypes.class);
-        allTypes2.setColumnString("αύριο");
-        AllTypes allTypes3 = testRealm.createObject(AllTypes.class);
-        allTypes3.setColumnString("work");
-        testRealm.commitTransaction();
-
-        try {
-            RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-            result.sort(FIELD_STRING);
-        } catch (IllegalArgumentException e) {
-            fail("Failed to sort with two kinds of alphabets");
-        }
-    }
-
-    public void testSortByChildObject() {
-        testRealm.beginTransaction();
-        Owner owner = testRealm.createObject(Owner.class);
-        owner.setName("owner");
-        Cat cat = testRealm.createObject(Cat.class);
-        cat.setName("cat");
-        owner.setCat(cat);
-        testRealm.commitTransaction();
-
-        RealmQuery<Owner> query = testRealm.where(Owner.class);
-        RealmResults<Owner> owners = query.findAll();
-
-        try {
-            owners.sort("cat.name");
-            fail("Sorting by child object properties should result in a IllegalArgumentException");
-        } catch (IllegalArgumentException ignore) {
-        }
-    }
-
-    public void testSortWithNullThrows() {
-        RealmResults<AllTypes> result = testRealm.allObjects(AllTypes.class);
-        try {
-            result.sort((String)null);
-            fail("Sorting with a null field name should throw an IllegalArgumentException");
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            result.sort((String[])null, (boolean[])null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    public void testWithEmptyRealmObjects() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        testRealm.commitTransaction();
-        try {
-            testRealm.where(AllTypes.class).findAll().sort(FIELD_STRING);
-        } catch (IllegalArgumentException e) {
-            fail("Failed to sort an empty RealmResults");
-        }
-    }
-
-    public void testSortSingleField() {
-        RealmResults<AllTypes> sortedList = testRealm.allObjects(AllTypes.class);
-        sortedList.sort(new String[]{FIELD_LONG}, new boolean[]{RealmResults.SORT_ORDER_DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    public void testCount() {
-        assertEquals(TEST_DATA_SIZE, testRealm.where(AllTypes.class).count());
-    }
-
-    public void testFindFirst() {
-        AllTypes result = testRealm.where(AllTypes.class).findFirst();
-        assertEquals(0, result.getColumnLong());
-        assertEquals("test data 0", result.getColumnString());
-
-        AllTypes none = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "smurf").findFirst();
-        assertNull(none);
-    }
-
-    public void testManyConditions() {
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class);
-        query.equalTo(FIELD_LONG, 0);
-        for (int i = 1; i < TEST_DATA_SIZE; i++) {
-            query.or().equalTo(FIELD_LONG, i);
-        }
-        RealmResults<AllTypes> allTypesRealmResults = query.findAll();
-        assertEquals(TEST_DATA_SIZE, allTypesRealmResults.size());
-    }
-
-    public void testWhere() {
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).findAll().where();
-        assertNotNull(query);
-    }
-
-    public void testQueryResult() {
-        RealmResults<AllTypes> allTypes = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, allTypes.size());
-
-        // querying a RealmResults should find objects that fulfill the condition
-        RealmResults<AllTypes> onedigits = allTypes.where().lessThan(FIELD_LONG, 10).findAll();
-        assertEquals(Math.min(10, TEST_DATA_SIZE), onedigits.size());
-
-        // if no objects fulfill conditions, the result has zero objects
-        RealmResults<AllTypes> none = allTypes.where().greaterThan(FIELD_LONG, TEST_DATA_SIZE).findAll();
-        assertEquals(0, none.size());
-
-        // querying a result with zero objects must give zero objects
-        RealmResults<AllTypes> stillNone = none.where().greaterThan(FIELD_LONG, TEST_DATA_SIZE).findAll();
-        assertEquals(0, stillNone.size());
-    }
-
-    public void testFindAllSorted() {
-        RealmResults<AllTypes> allTypes = testRealm.where(AllTypes.class).findAllSorted(FIELD_LONG,
-                RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, allTypes.size());
-        assertEquals(0, allTypes.first().getColumnLong());
-        assertEquals(TEST_DATA_SIZE - 1, allTypes.last().getColumnLong());
-
-        RealmResults<AllTypes> reverseList = testRealm.where(AllTypes.class).findAllSorted(FIELD_LONG,
-                RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals(0, reverseList.last().getColumnLong());
-        assertEquals(TEST_DATA_SIZE - 1, reverseList.first().getColumnLong());
-
-        try {
-            RealmResults<AllTypes> none = testRealm.where(AllTypes.class).findAllSorted("invalid",
-                    RealmResults.SORT_ORDER_DESCENDING);
-            fail();
-        } catch (IllegalArgumentException ignored) {}
-    }
-
-    public void testQueryDateField() {
-        RealmQuery<AllTypes> query = testRealm.where(AllTypes.class).equalTo(FIELD_DATE, new Date(5000));
-        RealmResults<AllTypes> all = query.findAll();
-        assertEquals(1, query.count());
-        assertEquals(1, all.size());
-    }
-
-    public void testIndexOf() {
-        try {
-            RealmResults<AllTypes> all = testRealm.allObjects(AllTypes.class);
-            int index = all.indexOf(all.first());
-            fail();
-        } catch (NoSuchMethodError e) {}
-    }
-
-    public void testSubList() {
-        RealmResults<AllTypes> list = testRealm.allObjects(AllTypes.class);
-        list.sort("columnLong");
-        List<AllTypes> sublist = list.subList(Math.max(list.size() - 20, 0), list.size());
-        assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
-    }
-
-    public void testUnsupportedMethods() {
-        RealmResults<AllTypes> result = testRealm.where(AllTypes.class).findAll();
-
-        try { result.add(null);     fail(); } catch (UnsupportedOperationException expected) {}
-        try { result.set(0, null);  fail(); } catch (UnsupportedOperationException expected) {}
-    }
-
-
-    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
-    public void testMutableMethodsOutsideWriteTransactions() {
-        RealmResults<AllTypes> result = testRealm.where(AllTypes.class).findAll();
-
-        try { result.clear();       fail(); } catch (IllegalStateException expected) {}
-        try { result.remove(0);     fail(); } catch (IllegalStateException expected) {}
-        try { result.removeLast();  fail(); } catch (IllegalStateException expected) {}
-    }
-
-    // TODO: More extended tests of querying all types must be done.
-}
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
deleted file mode 100644
index 628a51fdfc..0000000000
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ /dev/null
@@ -1,1679 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import android.content.Context;
-import android.test.AndroidTestCase;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Random;
-import java.util.Scanner;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-
-import io.realm.entities.AllTypes;
-import io.realm.entities.AllTypesPrimaryKey;
-import io.realm.entities.Cat;
-import io.realm.entities.CyclicType;
-import io.realm.entities.CyclicTypePrimaryKey;
-import io.realm.entities.Dog;
-import io.realm.entities.DogPrimaryKey;
-import io.realm.entities.NonLatinFieldNames;
-import io.realm.entities.Owner;
-import io.realm.entities.OwnerPrimaryKey;
-import io.realm.entities.PrimaryKeyAsLong;
-import io.realm.entities.PrimaryKeyAsString;
-import io.realm.entities.PrimaryKeyMix;
-import io.realm.entities.StringOnly;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
-import io.realm.internal.Table;
-
-import static io.realm.internal.test.ExtraTests.assertArrayEquals;
-
-public class RealmTest extends AndroidTestCase {
-
-    protected final static int TEST_DATA_SIZE = 10;
-
-    protected Realm testRealm;
-
-    protected List<String> columnData = new ArrayList<String>();
-
-    private final static String FIELD_STRING = "columnString";
-    private final static String FIELD_LONG = "columnLong";
-    private final static String FIELD_FLOAT = "columnFloat";
-    private final static String FIELD_DOUBLE = "columnDouble";
-    private final static String FIELD_BOOLEAN = "columnBoolean";
-    private final static String FIELD_DATE = "columnDate";
-
-    protected void setColumnData() {
-        columnData.add(0, FIELD_BOOLEAN);
-        columnData.add(1, FIELD_DATE);
-        columnData.add(2, FIELD_DOUBLE);
-        columnData.add(3, FIELD_FLOAT);
-        columnData.add(4, FIELD_STRING);
-        columnData.add(5, FIELD_LONG);
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        if (testRealm != null) {
-            testRealm.close();
-        }
-    }
-
-    private void populateTestRealm(Realm realm, int objects) {
-        realm.beginTransaction();
-        realm.allObjects(AllTypes.class).clear();
-        realm.allObjects(NonLatinFieldNames.class).clear();
-        for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnBoolean((i % 3) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
-            allTypes.setColumnFloat(1.234567f + i);
-            allTypes.setColumnString("test data " + i);
-            allTypes.setColumnLong(i);
-            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
-            nonLatinFieldNames.set델타(i);
-            nonLatinFieldNames.setΔέλτα(i);
-            nonLatinFieldNames.set베타(1.234567f + i);
-            nonLatinFieldNames.setΒήτα(1.234567f + i);
-        }
-        realm.commitTransaction();
-    }
-
-    private void populateTestRealm() {
-        populateTestRealm(testRealm, TEST_DATA_SIZE);
-    }
-
-
-    public void testGetInstanceNullFolderThrows() {
-        try {
-            Realm.getInstance((File) null);
-            fail("Parsing null as folder should throw an error");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testGetInstanceNullNameThrows() {
-        try {
-            Realm.getInstance(getContext(), (String) null);
-            fail("Parsing null as realm name should throw an error");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testGetInstanceCreateSubFoldersThrows() {
-        File folder = new File(getContext().getFilesDir().getAbsolutePath() + "/subfolder1/subfolder2/");
-        try {
-            Realm.getInstance(getContext(), (String) null);
-            fail("Assuming that subfolders are created automatically should fail");
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testGetInstanceFolderNoWritePermissionThrows() {
-        File folder = new File("/");
-        try {
-            Realm realm = Realm.getInstance(folder);
-            fail("Pointing to a folder with no write permission should throw an error");
-        } catch (RealmIOException expected) {
-        }
-    }
-
-    public void testGetInstanceFileNoWritePermissionThrows() throws IOException {
-        String REALM_FILE = "readonly.realm";
-        File folder = getContext().getFilesDir();
-        File realmFile = new File(folder, REALM_FILE);
-        if (realmFile.exists()) {
-            realmFile.delete(); // Reset old test data
-        }
-
-        assertTrue(realmFile.createNewFile());
-        assertTrue(realmFile.setWritable(false));
-
-        try {
-            Realm.getInstance(folder, REALM_FILE);
-            fail("Trying to open a read-only file should fail");
-        } catch (RealmIOException expected) {
-        }
-    }
-
-    public void testGetInstanceClearsCacheWhenFailed() {
-        String REALM_NAME = "invalid_cache.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Random random = new Random();
-        byte[] key = new byte[64];
-        random.nextBytes(key);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key); // Create starting Realm with key1
-        realm.close();
-        random.nextBytes(key);
-        try {
-            Realm.getInstance(getContext(), REALM_NAME, key); // Try to open with key 2
-        } catch (IllegalArgumentException expected) {
-            // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
-            // if initialization failed.
-            assertTrue(Realm.deleteRealmFile(getContext(), REALM_NAME));
-            Realm.getInstance(getContext(), REALM_NAME, key);
-            realm.close();
-        }
-    }
-
-    public void testInstanceIdForHashCollision() {
-        // Ea.hashCode() == FB.hashCode()
-        Realm.deleteRealmFile(getContext(), "Ea");
-        Realm.deleteRealmFile(getContext(), "FB");
-        Realm r1 = Realm.getInstance(getContext(), "Ea");
-        Realm r2 = Realm.getInstance(getContext(), "FB");
-        assertNotSame(r1, r2);
-    }
-
-    public void testRealmCache() {
-        Realm newRealm = Realm.getInstance(getContext());
-        assertEquals(testRealm, newRealm);
-        newRealm.close();
-    }
-
-    public void testInternalRealmChangedHandlersRemoved() {
-        final String REALM_NAME = "test-internalhandlers";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Realm.handlers.clear(); // Make sure that handlers from other unit tests doesn't interfere.
-
-        // Open and close first instance of a Realm
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(getContext(), REALM_NAME);
-            assertEquals(1, Realm.handlers.size());
-            realm.close();
-
-            // All Realms closed. No handlers should be alive.
-            assertEquals(0, Realm.handlers.size());
-
-            // Open instance the 2nd time. Old handler should now be gone
-            realm = Realm.getInstance(getContext(), REALM_NAME);
-            assertEquals(1, Realm.handlers.size());
-            realm.close();
-
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    public void testShouldCreateRealm() {
-        assertNotNull("Realm.getInstance unexpectedly returns null", testRealm);
-        assertTrue("Realm.getInstance does not contain expected table", testRealm.contains(AllTypes.class));
-    }
-
-    public void testShouldNotFailCreateRealmWithNullContext() {
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance((Context) null); // throws when c.getDirectory() is called;
-            // has nothing to do with Realm
-            fail("Should throw an exception");
-        } catch (NullPointerException ignore) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    // Table getTable(Class<?> clazz)
-    public void testShouldGetTable() {
-        Table table = testRealm.getTable(AllTypes.class);
-        assertNotNull(table);
-    }
-
-    // <E> void remove(Class<E> clazz, long objectIndex)
-    public void testShouldRemoveRow() {
-        populateTestRealm();
-        testRealm.beginTransaction();
-        testRealm.remove(AllTypes.class, 0);
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
-    }
-
-    // <E extends RealmObject> E get(Class<E> clazz, long rowIndex)
-    public void testShouldGetObject() {
-        populateTestRealm();
-        AllTypes allTypes = testRealm.get(AllTypes.class, 0);
-        assertNotNull(allTypes);
-        assertEquals("test data 0", allTypes.getColumnString());
-    }
-
-    // boolean contains(Class<?> clazz)
-    public void testShouldContainTable() {
-        testRealm.beginTransaction();
-        testRealm.createObject(Dog.class);
-        testRealm.commitTransaction();
-        assertTrue("contains returns false for newly created table", testRealm.contains(Dog.class));
-        assertFalse("contains returns true for non-existing table", testRealm.contains(null));
-    }
-
-    // <E extends RealmObject> RealmQuery<E> where(Class<E> clazz)
-    public void testShouldReturnResultSet() {
-        populateTestRealm();
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, resultList.size());
-    }
-
-    // Note that this test is relying on the values set while initializing the test dataset
-    public void testQueriesResults() throws IOException {
-        populateTestRealm(testRealm, 159);
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).equalTo(FIELD_LONG, 33).findAll();
-        assertEquals(1, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_LONG, 3333).findAll();
-        assertEquals(0, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "test data 0").findAll();
-        assertEquals(1, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "test data 0", RealmQuery.CASE_INSENSITIVE).findAll();
-        assertEquals(1, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "Test data 0", RealmQuery.CASE_SENSITIVE).findAll();
-        assertEquals(0, resultList.size());
-    }
-
-    public void testQueriesWithDataTypes() throws IOException {
-        populateTestRealm();
-        setColumnData();
-
-        for (int i = 0; i < columnData.size(); i++) {
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), true).findAll();
-                if (i != 0) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), new Date()).findAll();
-                if (i != 1) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), 13.37d).findAll();
-                if (i != 2) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711f).findAll();
-                if (i != 3) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), "test").findAll();
-                if (i != 4) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-
-            try {
-                testRealm.where(AllTypes.class).equalTo(columnData.get(i), 1337).findAll();
-                if (i != 5) {
-                    fail("Realm.where should fail with illegal argument");
-                }
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    public void testQueriesFailWithInvalidDataTypes() throws IOException {
-        try {
-            testRealm.where(AllTypes.class).equalTo("invalidcolumnname", 33).findAll();
-            fail("Invalid field name");
-        } catch (Exception ignored) {
-        }
-
-        try {
-            testRealm.where(AllTypes.class).equalTo("invalidcolumnname", "test").findAll();
-            fail("Invalid field name");
-        } catch (Exception ignored) {
-        }
-
-        try {
-            testRealm.where(AllTypes.class).equalTo("invalidcolumnname", true).findAll();
-            fail("Invalid field name");
-        } catch (Exception ignored) {
-        }
-
-        try {
-            testRealm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415d).findAll();
-            fail("Invalid field name");
-        } catch (Exception ignored) {
-        }
-
-        try {
-            testRealm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415f).findAll();
-            fail("Invalid field name");
-        } catch (Exception ignored) {
-        }
-    }
-
-    public void testQueriesFailWithNullQueryValue() throws IOException {
-        try {
-            testRealm.where(AllTypes.class).equalTo(FIELD_STRING, (String) null).findAll();
-            fail("Realm.where should fail with illegal argument");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    // <E extends RealmObject> RealmTableOrViewList<E> allObjects(Class<E> clazz)
-    public void testShouldReturnTableOrViewList() {
-        populateTestRealm();
-        RealmResults<AllTypes> resultList = testRealm.allObjects(AllTypes.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
-    }
-
-    public void testAllObjectsSorted() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = testRealm.allObjectsSorted(AllTypes.class, FIELD_STRING, RealmResults.SORT_ORDER_ASCENDING);
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals("test data 0", sortedList.first().getColumnString());
-
-        RealmResults<AllTypes> reverseList = testRealm.allObjectsSorted(AllTypes.class, FIELD_STRING, RealmResults.SORT_ORDER_DESCENDING);
-        assertEquals(TEST_DATA_SIZE, reverseList.size());
-        assertEquals("test data 0", reverseList.last().getColumnString());
-
-        try {
-            RealmResults<AllTypes> none = testRealm.allObjectsSorted(AllTypes.class, "invalid", RealmResults.SORT_ORDER_ASCENDING);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    public void testSortTwoFields() {
-        io.realm.internal.test.TestHelper.populateForMultiSort(testRealm);
-
-        RealmResults<AllTypes> results1 = testRealm.allObjectsSorted(AllTypes.class,
-                new String[]{FIELD_STRING, FIELD_LONG},
-                new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-
-        assertEquals(3, results1.size());
-
-        assertEquals("Adam", results1.get(0).getColumnString());
-        assertEquals(4, results1.get(0).getColumnLong());
-
-        assertEquals("Adam", results1.get(1).getColumnString());
-        assertEquals(5, results1.get(1).getColumnLong());
-
-        assertEquals("Brian", results1.get(2).getColumnString());
-        assertEquals(4, results1.get(2).getColumnLong());
-
-        RealmResults<AllTypes> results2 = testRealm.allObjectsSorted(AllTypes.class,
-                new String[]{FIELD_LONG, FIELD_STRING},
-                new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-
-        assertEquals(3, results2.size());
-
-        assertEquals("Adam", results2.get(0).getColumnString());
-        assertEquals(4, results2.get(0).getColumnLong());
-
-        assertEquals("Brian", results2.get(1).getColumnString());
-        assertEquals(4, results2.get(1).getColumnLong());
-
-        assertEquals("Adam", results2.get(2).getColumnString());
-        assertEquals(5, results2.get(2).getColumnLong());
-    }
-
-    public void testSortMultiFailures() {
-        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
-
-        // zero fields specified
-        try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{}, new boolean[]{});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // number of fields and sorting orders don't match
-        try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING},
-                    new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // null is not allowed
-        try {
-            testRealm.allObjectsSorted(AllTypes.class, null, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-        try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{FIELD_STRING}, null);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        // non-existing field name
-        try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING, "dont-exist"},
-                    new boolean[]{RealmResults.SORT_ORDER_ASCENDING, RealmResults.SORT_ORDER_ASCENDING});
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    public void testSortSingleField() {
-        populateTestRealm();
-        RealmResults<AllTypes> sortedList = testRealm.allObjectsSorted(AllTypes.class,
-                new String[]{FIELD_LONG},
-                new boolean[]{RealmResults.SORT_ORDER_DESCENDING});
-        assertEquals(TEST_DATA_SIZE, sortedList.size());
-        assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
-        assertEquals(0, sortedList.last().getColumnLong());
-    }
-
-    // void beginTransaction()
-    public void testBeginTransaction() throws IOException {
-        populateTestRealm();
-
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnFloat(3.1415f);
-        allTypes.setColumnString("a unique string");
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE + 1, resultList.size());
-
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_STRING, "a unique string").findAll();
-        assertEquals(1, resultList.size());
-        resultList = testRealm.where(AllTypes.class).equalTo(FIELD_FLOAT, 3.1415f).findAll();
-        assertEquals(1, resultList.size());
-    }
-
-    public void testNestedTransaction() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.beginTransaction();
-            fail();
-        } catch (IllegalStateException e) {
-            assertEquals("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().", e.getMessage());
-        }
-        testRealm.commitTransaction();
-    }
-
-    private enum TransactionMethod {
-        METHOD_BEGIN,
-        METHOD_COMMIT,
-        METHOD_CANCEL
-    }
-
-    // Starting a transaction on the wrong thread will fail
-    private boolean transactionMethodWrongThread(final TransactionMethod method) throws InterruptedException,
-            ExecutionException {
-        if (method != TransactionMethod.METHOD_BEGIN) {
-            testRealm.beginTransaction();
-            testRealm.createObject(Dog.class); // FIXME: Empty transactions cannot be cancelled
-        }
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-            @Override
-            public Boolean call() throws Exception {
-                try {
-                    switch (method) {
-                        case METHOD_BEGIN:
-                            testRealm.beginTransaction();
-                            break;
-                        case METHOD_COMMIT:
-                            testRealm.commitTransaction();
-                            break;
-                        case METHOD_CANCEL:
-                            testRealm.cancelTransaction();
-                            break;
-                    }
-                    return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
-                }
-            }
-        });
-
-        boolean result = future.get();
-        if (result && method != TransactionMethod.METHOD_BEGIN) {
-            testRealm.cancelTransaction();
-        }
-        return result;
-    }
-
-    public void testTransactionWrongThread() throws ExecutionException, InterruptedException {
-        for (TransactionMethod method : TransactionMethod.values()) {
-            assertTrue(method.toString(), transactionMethodWrongThread(method));
-        }
-    }
-
-    // void commitTransaction()
-    public void testCommitTransaction() {
-        populateTestRealm();
-
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnBoolean(true);
-        testRealm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE + 1, resultList.size());
-    }
-
-
-    public void testCancelTransaction() {
-        populateTestRealm();
-
-        testRealm.beginTransaction();
-        testRealm.createObject(AllTypes.class);
-        testRealm.cancelTransaction();
-        assertEquals(TEST_DATA_SIZE, testRealm.allObjects(AllTypes.class).size());
-
-        try {
-            testRealm.cancelTransaction();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
-
-    public void testExecuteTransactionNull() {
-        testRealm.executeTransaction(null); // Nothing happens
-        assertFalse(testRealm.hasChanged());
-    }
-
-    public void testExecuteTransactionCommit() {
-        assertEquals(0, testRealm.allObjects(Owner.class).size());
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                Owner owner = realm.createObject(Owner.class);
-                owner.setName("Owner");
-            }
-        });
-        assertEquals(1, testRealm.allObjects(Owner.class).size());
-    }
-
-    public void testExecuteTransactionCancel() {
-        assertEquals(0, testRealm.allObjects(Owner.class).size());
-        try {
-            testRealm.executeTransaction(new Realm.Transaction() {
-                @Override
-                public void execute(Realm realm) {
-                    Owner owner = realm.createObject(Owner.class);
-                    owner.setName("Owner");
-                    throw new RuntimeException("Boom");
-                }
-            });
-        } catch (RealmException ignore) {
-        }
-        assertEquals(0, testRealm.allObjects(Owner.class).size());
-    }
-
-
-    // void clear(Class<?> classSpec)
-    public void testClear() {
-        // ** clear non existing table should succeed
-
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        testRealm.commitTransaction();
-
-        // ** clear existing class, but leave other classes classes
-
-        // Add two classes
-        populateTestRealm();
-        testRealm.beginTransaction();
-        Dog dog = testRealm.createObject(Dog.class);
-        dog.setName("Castro");
-        testRealm.commitTransaction();
-        // Clear
-        testRealm.beginTransaction();
-        testRealm.clear(Dog.class);
-        testRealm.commitTransaction();
-        // Check one class is cleared but other class is still there
-        RealmResults<AllTypes> resultListTypes = testRealm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE, resultListTypes.size());
-        RealmResults<Dog> resultListDogs = testRealm.where(Dog.class).findAll();
-        assertEquals(0, resultListDogs.size());
-
-        // ** clear() must throw outside a transaction
-        try {
-            testRealm.clear(AllTypes.class);
-            fail("Expected exception");
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
-    // int getVersion() AND void setVersion(int version)
-    public void testGetVersionAndSetVersion() throws IOException {
-        // ** Initial version must be 0
-        populateTestRealm();
-        long version = testRealm.getVersion();
-        assertEquals(0, version);
-
-        // ** Version should be updateable
-        version = 42;
-        testRealm.beginTransaction();
-        testRealm.setVersion(version);
-        testRealm.commitTransaction();
-        assertEquals(version, testRealm.getVersion());
-    }
-
-    public void testShouldFailOutsideTransaction() {
-        // These calls should fail outside a Transaction:
-        try {
-            testRealm.createObject(AllTypes.class);
-            fail("Realm.createObject should fail outside write transaction");
-        } catch (IllegalStateException ignored) {
-        }
-        try {
-            testRealm.remove(AllTypes.class, 0);
-            fail("Realm.remove should fail outside write transaction");
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
-    public void createAndTestFilename(String language, String fileName) {
-        Realm.deleteRealmFile(getContext(), fileName);
-        Realm realm1 = Realm.getInstance(getContext(), fileName);
-        realm1.beginTransaction();
-        Dog dog1 = realm1.createObject(Dog.class);
-        dog1.setName("Rex");
-        realm1.commitTransaction();
-        realm1.close();
-
-        File file = new File(getContext().getFilesDir(), fileName);
-        assertTrue(language, file.exists());
-
-        Realm realm2 = Realm.getInstance(getContext(), fileName);
-        Dog dog2 = realm2.allObjects(Dog.class).first();
-        assertEquals(language, "Rex", dog2.getName());
-        realm2.close();
-    }
-
-    public void testCreateFile() {
-        createAndTestFilename("American", "Washington");
-        createAndTestFilename("Danish", "København");
-        createAndTestFilename("Russian", "Москва");
-        createAndTestFilename("Greek", "Αθήνα");
-        createAndTestFilename("Chinese", "北京市");
-        createAndTestFilename("Korean", "서울시");
-        createAndTestFilename("Arabic", "الرياض");
-        createAndTestFilename("India", "नई दिल्ली");
-        createAndTestFilename("Japanese", "東京都");
-    }
-
-    // This test is slow. Move it to another testsuite that runs once a day on Jenkins.
-    public void rarely_run_testUTF8() {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        testRealm.commitTransaction();
-
-        String file = "assets/unicode_codepoints.csv";
-        Scanner scanner = new Scanner(getClass().getClassLoader().getResourceAsStream(file));
-        int i = 0;
-        String currentUnicode = null;
-        try {
-            testRealm.beginTransaction();
-            while (scanner.hasNextLine()) {
-                currentUnicode = scanner.nextLine();
-                char[] chars = Character.toChars(Integer.parseInt(currentUnicode, 16));
-                String codePoint = new String(chars);
-                AllTypes o = testRealm.createObject(AllTypes.class);
-                o.setColumnLong(i);
-                o.setColumnString(codePoint);
-
-                AllTypes realmType = testRealm.where(AllTypes.class).equalTo("columnLong", i).findFirst();
-                if (i > 1) {
-                    assertEquals("Codepoint: " + i + " / " + currentUnicode, codePoint,
-                            realmType.getColumnString()); // codepoint 0 is NULL, ignore for now.
-                }
-                i++;
-            }
-            testRealm.commitTransaction();
-        } catch (Exception e) {
-            fail("Failure, Codepoint: " + i + " / " + currentUnicode + " " + e.getMessage());
-        }
-    }
-
-    private List<String> getCharacterArray() {
-        List<String> chars_array = new ArrayList<String>();
-        String file = "assets/unicode_codepoints.csv";
-        Scanner scanner = new Scanner(getClass().getClassLoader().getResourceAsStream(file));
-        int i = 0;
-        String currentUnicode = null;
-        try {
-            while (scanner.hasNextLine()) {
-                currentUnicode = scanner.nextLine();
-                char[] chars = Character.toChars(Integer.parseInt(currentUnicode, 16));
-                String codePoint = new String(chars);
-                chars_array.add(codePoint);
-                i++;
-            }
-        } catch (Exception e) {
-            fail("Failure, Codepoint: " + i + " / " + currentUnicode + " " + e.getMessage());
-        }
-        return chars_array;
-    }
-
-    // This test is disabled.
-    // The test writes and reads random Strings.
-    public void disabledTestUnicodeString() {
-        List<String> chars_array = getCharacterArray();
-        // Change seed value for new random values.
-        long seed = 20;
-        Random random = new Random(seed);
-
-        int random_value = 0;
-
-        String test_char = "";
-        String test_char_old = "";
-        String get_data = "";
-
-        for (int i = 0; i < 1000; i++) {
-            random_value = random.nextInt(25);
-
-            for (int j = 0; j < random_value; j++) {
-                test_char = test_char_old + chars_array.get(random.nextInt(27261));
-                test_char_old = test_char;
-            }
-            testRealm.beginTransaction();
-            StringOnly stringOnly = testRealm.createObject(StringOnly.class);
-            stringOnly.setChars(test_char);
-            testRealm.commitTransaction();
-
-            get_data = testRealm.allObjects(StringOnly.class).get(0).getChars();
-
-            testRealm.beginTransaction();
-            testRealm.clear(StringOnly.class);
-            testRealm.commitTransaction();
-        }
-    }
-
-    public void testReferenceCounting() {
-        // At this point reference count should be one because of the setUp method
-        try {
-            testRealm.where(AllTypes.class).count();
-        } catch (IllegalStateException e) {
-            fail();
-        }
-
-        // Make sure the reference counter is per realm file
-        Realm.deleteRealmFile(getContext(), "anotherRealm.realm");
-        Realm otherRealm = Realm.getInstance(getContext(), "anotherRealm.realm");
-
-        // Raise the reference
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(getContext());
-        } finally {
-            if (realm != null) realm.close();
-        }
-
-        try {
-            // This should not fail because the reference is now 1
-            if (realm != null) {
-                realm.where(AllTypes.class).count();
-            }
-        } catch (IllegalStateException e) {
-            fail();
-        }
-
-        testRealm.close();
-        try {
-            testRealm.where(AllTypes.class).count();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-
-        try {
-            otherRealm.where(AllTypes.class).count();
-        } catch (IllegalStateException e) {
-            fail();
-        } finally {
-            otherRealm.close();
-        }
-
-        try {
-            otherRealm.where(AllTypes.class).count();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
-    public void testReferenceCountingDoubleClose() {
-        testRealm.close();
-        testRealm.close(); // Count down once too many. Counter is now potentially negative
-        testRealm = Realm.getInstance(getContext());
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        RealmResults<AllTypes> queryResult = testRealm.allObjects(AllTypes.class);
-        assertEquals(allTypes, queryResult.get(0));
-        testRealm.commitTransaction();
-        testRealm.close(); // This might not close the Realm if the reference count is wrong
-        try {
-            allTypes.getColumnString();
-            fail("Realm should be closed");
-        } catch (IllegalStateException expected) {
-        }
-    }
-
-    public void testWriteCopyTo() throws IOException {
-        Realm.deleteRealmFile(getContext(), "file1.realm");
-        Realm.deleteRealmFile(getContext(), "file2.realm");
-
-        Realm realm1 = null;
-        try {
-            realm1 = Realm.getInstance(getContext(), "file1.realm");
-            realm1.beginTransaction();
-            AllTypes allTypes = realm1.createObject(AllTypes.class);
-            allTypes.setColumnString("Hello World");
-            realm1.commitTransaction();
-
-            realm1.writeCopyTo(new File(getContext().getFilesDir(), "file2.realm"));
-        } finally {
-            if (realm1 != null) {
-                realm1.close();
-            }
-        }
-
-        // Copy is compacted i.e. smaller than original
-        File file1 = new File(getContext().getFilesDir(), "file1.realm");
-        File file2 = new File(getContext().getFilesDir(), "file2.realm");
-        assertTrue(file1.length() >= file2.length());
-
-        Realm realm2 = null;
-        try {
-            // Contents is copied too
-            realm2 = Realm.getInstance(getContext(), "file2.realm");
-            RealmResults<AllTypes> results = realm2.allObjects(AllTypes.class);
-            assertEquals(1, results.size());
-            assertEquals("Hello World", results.first().getColumnString());
-        } finally {
-            if (realm2 != null) {
-                realm2.close();
-            }
-        }
-    }
-
-
-    public void testCompactRealmFileThrowsIfOpen() throws IOException {
-        try {
-            Realm.compactRealmFile(getContext());
-            fail();
-        } catch (IllegalStateException expected) {
-        }
-    }
-
-    public void testCompactEncryptedEmptyRealmFile() {
-        String REALM_NAME = "enc.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        byte[] key = new byte[64];
-        new Random(42).nextBytes(key);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key);
-        realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME, key));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testCompactEncryptedPopulatedRealmFile() {
-        String REALM_NAME = "enc.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        byte[] key = new byte[64];
-        new Random(42).nextBytes(key);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key);
-        populateTestRealm(realm, 100);
-        realm.close();
-        // TODO: remove try/catch block when compacting encrypted Realms is supported
-        try {
-            assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME, key));
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testCompactEmptyRealmFile() throws IOException {
-        final String REALM_NAME = "test.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
-        realm.close();
-        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
-        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(before >= after);
-    }
-
-    public void testCompactPopulateRealmFile() throws IOException {
-        final String REALM_NAME = "test.realm";
-        Realm.deleteRealmFile(getContext(), REALM_NAME);
-        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
-        populateTestRealm(realm, 100);
-        realm.close();
-        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
-        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
-        assertTrue(before >= after);
-    }
-
-    public void testCopyToRealmNullObjectThrows() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.copyToRealm((AllTypes) null);
-            fail("Copying null objects into Realm should not be allowed");
-        } catch (IllegalArgumentException ignore) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testCopyManagedObjectIsNoop() {
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnString("Test");
-        testRealm.commitTransaction();
-
-        testRealm.commitTransaction();
-        AllTypes copiedAllTypes = testRealm.copyToRealm(allTypes);
-        testRealm.commitTransaction();
-
-        assertTrue(allTypes == copiedAllTypes);
-    }
-
-    public void testCopManagedObjectToOtherRealm() {
-        testRealm.beginTransaction();
-        AllTypes allTypes = testRealm.createObject(AllTypes.class);
-        allTypes.setColumnString("Test");
-        testRealm.commitTransaction();
-
-        Realm.deleteRealmFile(getContext(), "other-realm");
-        Realm otherRealm = Realm.getInstance(getContext(), "other-realm");
-        otherRealm.beginTransaction();
-        AllTypes copiedAllTypes = otherRealm.copyToRealm(allTypes);
-        otherRealm.commitTransaction();
-
-        assertNotSame(allTypes, copiedAllTypes); // Same object in different Realms is not the same
-        assertEquals(allTypes.getColumnString(), copiedAllTypes.getColumnString()); // But data is still the same
-        otherRealm.close();
-    }
-
-    public void testCopyToRealmObject() {
-        Date date = new Date();
-        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
-        Dog dog = new Dog();
-        dog.setName("Fido");
-        RealmList<Dog> list = new RealmList<Dog>();
-        list.add(dog);
-
-        AllTypes allTypes = new AllTypes();
-        allTypes.setColumnString("String");
-        allTypes.setColumnLong(1l);
-        allTypes.setColumnFloat(1f);
-        allTypes.setColumnDouble(1d);
-        allTypes.setColumnBoolean(true);
-        allTypes.setColumnDate(date);
-        allTypes.setColumnBinary(new byte[]{1, 2, 3});
-        allTypes.setColumnRealmObject(dog);
-        allTypes.setColumnRealmList(list);
-
-        testRealm.beginTransaction();
-        AllTypes realmTypes = testRealm.copyToRealm(allTypes);
-        testRealm.commitTransaction();
-
-        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal
-        assertEquals(allTypes.getColumnString(), realmTypes.getColumnString()); // But they contain the same data
-        assertEquals(allTypes.getColumnLong(), realmTypes.getColumnLong());
-        assertEquals(allTypes.getColumnFloat(), realmTypes.getColumnFloat());
-        assertEquals(allTypes.getColumnDouble(), realmTypes.getColumnDouble());
-        assertEquals(allTypes.isColumnBoolean(), realmTypes.isColumnBoolean());
-        assertEquals(allTypes.getColumnDate(), realmTypes.getColumnDate());
-        assertArrayEquals(allTypes.getColumnBinary(), realmTypes.getColumnBinary());
-        assertEquals(allTypes.getColumnRealmObject().getName(), dog.getName());
-        assertEquals(list.size(), realmTypes.getColumnRealmList().size());
-        assertEquals(list.get(0).getName(), realmTypes.getColumnRealmList().get(0).getName());
-    }
-
-    public void testCopyToRealmCyclic() {
-        CyclicType oneCyclicType = new CyclicType();
-        oneCyclicType.setName("One");
-        CyclicType anotherCyclicType = new CyclicType();
-        anotherCyclicType.setName("Two");
-        oneCyclicType.setObject(anotherCyclicType);
-        anotherCyclicType.setObject(oneCyclicType);
-
-        testRealm.beginTransaction();
-        CyclicType realmObject = testRealm.copyToRealm(oneCyclicType);
-        testRealm.commitTransaction();
-
-        assertEquals("One", realmObject.getName());
-        assertEquals("Two", realmObject.getObject().getName());
-        assertEquals(2, testRealm.allObjects(CyclicType.class).size());
-    }
-
-    public void testCopyToRealmCyclicList() {
-        CyclicType oneCyclicType = new CyclicType();
-        oneCyclicType.setName("One");
-        CyclicType anotherCyclicType = new CyclicType();
-        anotherCyclicType.setName("Two");
-        oneCyclicType.setObjects(new RealmList(anotherCyclicType));
-        anotherCyclicType.setObjects(new RealmList(oneCyclicType));
-
-        testRealm.beginTransaction();
-        CyclicType realmObject = testRealm.copyToRealm(oneCyclicType);
-        testRealm.commitTransaction();
-
-        assertEquals("One", realmObject.getName());
-        assertEquals(2, testRealm.allObjects(CyclicType.class).size());
-    }
-
-    // Check that if a field has a null value it gets converted to the default value for that type
-    public void testCopyToRealmDefaultValues() {
-        testRealm.beginTransaction();
-        AllTypes realmTypes = testRealm.copyToRealm(new AllTypes());
-        testRealm.commitTransaction();
-
-        assertEquals("", realmTypes.getColumnString());
-        assertEquals(new Date(0), realmTypes.getColumnDate());
-        assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
-    }
-
-    // Check that using copyToRealm will set the primary key directly instead of first setting
-    // it to the default value (which can fail)
-    public void testCopyToRealmWithPrimaryKeySetValueDirectly() {
-        testRealm.beginTransaction();
-        testRealm.createObject(OwnerPrimaryKey.class);
-        testRealm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
-        testRealm.commitTransaction();
-        assertEquals(2, testRealm.where(OwnerPrimaryKey.class).count());
-    }
-
-    public void testCopyToRealmWithPrimaryAsNullThrows() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.copyToRealm(new PrimaryKeyAsString());
-            fail();
-        } catch (IllegalArgumentException expected) {
-        } finally {
-            testRealm.cancelTransaction();
-        }
-    }
-
-    public void testCopyToRealmDontCopyNestedRealmObjets() {
-        testRealm.beginTransaction();
-        CyclicTypePrimaryKey childObj = testRealm.createObject(CyclicTypePrimaryKey.class);
-        childObj.setName("Child");
-        childObj.setId(1);
-
-        CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
-        parentObj.setObject(childObj);
-        testRealm.copyToRealm(parentObj);
-        testRealm.commitTransaction();
-
-        assertEquals(2, testRealm.where(CyclicTypePrimaryKey.class).count());
-    }
-
-    public void testCopyToRealmList() {
-        Dog dog1 = new Dog();
-        dog1.setName("Dog 1");
-        Dog dog2 = new Dog();
-        dog2.setName("Dog 2");
-        RealmList<Dog> list = new RealmList<Dog>();
-        list.addAll(Arrays.asList(dog1, dog2));
-
-        testRealm.beginTransaction();
-        List<Dog> copiedList = new ArrayList<Dog>(testRealm.copyToRealm(list));
-        testRealm.commitTransaction();
-
-        assertEquals(2, copiedList.size());
-        assertEquals(dog1.getName(), copiedList.get(0).getName());
-        assertEquals(dog2.getName(), copiedList.get(1).getName());
-    }
-
-    public void testCopyToRealmOrUpdateNullThrows() {
-        try {
-            testRealm.copyToRealmOrUpdate((AllTypes) null);
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCopyToRealmOrUpdateNullPrimaryKeyThrows() {
-        testRealm.beginTransaction();
-        try {
-            testRealm.copyToRealmOrUpdate(new PrimaryKeyAsString());
-            fail();
-        } catch (IllegalArgumentException expected) {
-        }
-    }
-
-    public void testCopyOrUpdateNoPrimaryKeyThrows() {
-        try {
-            testRealm.copyToRealmOrUpdate(new AllTypes());
-        } catch (IllegalArgumentException expected) {
-            return;
-        }
-        fail();
-    }
-
-    public void testCopyOrUpdateAddObject() {
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
-                obj.setId(1);
-                obj.setName("Foo");
-                realm.copyToRealm(obj);
-
-                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
-                obj2.setId(2);
-                obj2.setName("Bar");
-                realm.copyToRealmOrUpdate(obj2);
-            }
-        });
-
-        assertEquals(2, testRealm.allObjects(PrimaryKeyAsLong.class).size());
-    }
-
-    public void testCopyOrUpdateObject() {
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-                obj.setColumnString("Foo");
-                obj.setColumnLong(1);
-                obj.setColumnFloat(1.23F);
-                obj.setColumnDouble(1.234D);
-                obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
-                obj.setColumnDate(new Date(1000));
-                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
-                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
-                realm.copyToRealm(obj);
-
-                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
-                obj2.setColumnString("Bar");
-                obj2.setColumnLong(1);
-                obj2.setColumnFloat(2.23F);
-                obj2.setColumnDouble(2.234D);
-                obj2.setColumnBoolean(true);
-                obj2.setColumnBinary(new byte[] {2, 3, 4});
-                obj2.setColumnDate(new Date(2000));
-                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
-                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
-                realm.copyToRealmOrUpdate(obj2);
-            }
-        });
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = testRealm.allObjects(AllTypesPrimaryKey.class).first();
-
-        // Check that the the only element has all its properties updated
-        assertEquals("Bar", obj.getColumnString());
-        assertEquals(1, obj.getColumnLong());
-        assertEquals(2.23F, obj.getColumnFloat());
-        assertEquals(2.234D, obj.getColumnDouble());
-        assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
-        assertEquals(new Date(2000), obj.getColumnDate());
-        assertEquals("Dog3", obj.getColumnRealmObject().getName());
-        assertEquals(1, obj.getColumnRealmList().size());
-        assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
-    }
-
-    public void testUpdateCyclicObject() {
-        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1);
-        oneCyclicType.setName("One");
-        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2);
-        anotherCyclicType.setName("Two");
-        oneCyclicType.setObject(anotherCyclicType);
-        anotherCyclicType.setObject(oneCyclicType);
-
-        testRealm.beginTransaction();
-        testRealm.copyToRealm(oneCyclicType);
-        testRealm.commitTransaction();
-
-        oneCyclicType.setName("Three");
-        anotherCyclicType.setName("Four");
-        testRealm.beginTransaction();
-        testRealm.copyToRealmOrUpdate(oneCyclicType);
-        testRealm.commitTransaction();
-
-        assertEquals(2, testRealm.allObjects(CyclicTypePrimaryKey.class).size());
-        assertEquals("Three", testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getName());
-    }
-
-
-    // Checks that a standalone object with only default values can override data
-    public void testCopyOrUpdateWithStandaloneDefaultObject() {
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-                obj.setColumnString("Foo");
-                obj.setColumnLong(1);
-                obj.setColumnFloat(1.23F);
-                obj.setColumnDouble(1.234D);
-                obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
-                obj.setColumnDate(new Date(1000));
-                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
-                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
-                realm.copyToRealm(obj);
-
-                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
-                obj2.setColumnLong(1);
-                realm.copyToRealmOrUpdate(obj2);
-            }
-        });
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-
-        AllTypesPrimaryKey obj = testRealm.allObjects(AllTypesPrimaryKey.class).first();
-        assertEquals("", obj.getColumnString());
-        assertEquals(1, obj.getColumnLong());
-        assertEquals(0.0F, obj.getColumnFloat());
-        assertEquals(0.0D, obj.getColumnDouble());
-        assertEquals(false, obj.isColumnBoolean());
-        assertArrayEquals(new byte[0], obj.getColumnBinary());
-        assertEquals(new Date(0), obj.getColumnDate());
-        assertNull(obj.getColumnRealmObject());
-        assertEquals(0, obj.getColumnRealmList().size());
-    }
-
-
-    // Tests that if references to objects are removed, the objects are still in the Realm
-    public void testCopyOrUpdateReferencesNotDeleted() {
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-                obj.setColumnLong(1);
-                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
-                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
-                realm.copyToRealm(obj);
-
-                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
-                obj2.setColumnLong(1);
-                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
-                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
-                realm.copyToRealmOrUpdate(obj2);
-            }
-        });
-
-        assertEquals(1, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(4, testRealm.allObjects(DogPrimaryKey.class).size());
-    }
-
-    public void testCopyOrUpdatePrimaryKeyMix() {
-        // Crate Object graph where tier 2 consists of 1 object with primary key and one doesn't.
-        // Tier 3 both have objects with primary keys.
-        //
-        //        PK
-        //     /      \
-        //    PK      nonPK
-        //    |        |
-        //    PK       PK
-        DogPrimaryKey dog = new DogPrimaryKey(1, "Dog");
-        OwnerPrimaryKey owner = new OwnerPrimaryKey(1, "Owner");
-        owner.setDog(dog);
-
-        Cat cat = new Cat();
-        cat.setScaredOfDog(dog);
-
-        PrimaryKeyMix mixObject = new PrimaryKeyMix(1);
-        mixObject.setDogOwner(owner);
-        mixObject.setCat(cat);
-
-        testRealm.beginTransaction();
-        PrimaryKeyMix realmObject = testRealm.copyToRealmOrUpdate(mixObject);
-        testRealm.commitTransaction();
-
-        assertEquals("Dog", realmObject.getCat().getScaredOfDog().getName());
-        assertEquals("Dog", realmObject.getDogOwner().getDog().getName());
-    }
-
-   public void testCopyOrUpdateIterable() {
-        testRealm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
-                obj.setId(1);
-                obj.setName("Foo");
-                realm.copyToRealm(obj);
-
-                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
-                obj2.setId(1);
-                obj2.setName("Bar");
-
-                PrimaryKeyAsLong obj3 = new PrimaryKeyAsLong();
-                obj3.setId(1);
-                obj3.setName("Baz");
-
-                realm.copyToRealmOrUpdate(Arrays.asList(obj2, obj3));
-            }
-        });
-
-        assertEquals(1, testRealm.allObjects(PrimaryKeyAsLong.class).size());
-        assertEquals("Baz", testRealm.allObjects(PrimaryKeyAsLong.class).first().getName());
-    }
-
-    public void testCopyOrUpdateIterableChildObjects() {
-        DogPrimaryKey dog = new DogPrimaryKey(1, "Snoop");
-
-        AllTypesPrimaryKey allTypes1 = new AllTypesPrimaryKey();
-        allTypes1.setColumnLong(1);
-        allTypes1.setColumnRealmObject(dog);
-
-        AllTypesPrimaryKey allTypes2 = new AllTypesPrimaryKey();
-        allTypes1.setColumnLong(2);
-        allTypes2.setColumnRealmObject(dog);
-
-        testRealm.beginTransaction();
-        testRealm.copyToRealmOrUpdate(Arrays.asList(allTypes1, allTypes2));
-        testRealm.commitTransaction();
-
-        assertEquals(2, testRealm.allObjects(AllTypesPrimaryKey.class).size());
-        assertEquals(1, testRealm.allObjects(DogPrimaryKey.class).size());
-    }
-
-    public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
-        byte[] key1 = new byte[64];
-        byte[] key2 = new byte[64];
-        new Random(42).nextBytes(key1);
-        new Random(42).nextBytes(key2);
-
-        // Make sure the key is the same, but in two different instances
-        assertArrayEquals(key1, key2);
-        assertTrue(key1 != key2);
-
-        final String ENCRYPTED_REALM = "differentKeys.realm";
-        Realm.deleteRealmFile(getContext(), ENCRYPTED_REALM);
-        Realm realm1 = null;
-        Realm realm2 = null;
-        try {
-            realm1 = Realm.getInstance(getContext(), ENCRYPTED_REALM, key1);
-            try {
-                realm2 = Realm.getInstance(getContext(), ENCRYPTED_REALM, key2);
-            } catch (Exception e) {
-                fail();
-            } finally {
-                if (realm2 != null) {
-                    realm2.close();
-                }
-            }
-        } finally {
-            if (realm1 != null) {
-                realm1.close();
-            }
-        }
-    }
-
-    public void testWriteEncryptedCopy() throws Exception {
-        populateTestRealm();
-        long before = testRealm.where(AllTypes.class).count();
-        assertEquals(TEST_DATA_SIZE, before);
-
-        final String ENCRYPTED_REALM_FILE_NAME = "encryptedTestRealm.realm";
-        final String RE_ENCRYPTED_REALM_FILE_NAME = "reEncryptedTestRealm.realm";
-        final String DECRYPTED_REALM_FILE_NAME = "decryptedTestRealm.realm";
-
-        // Delete files if present
-        for (String fileName : Arrays.asList(ENCRYPTED_REALM_FILE_NAME, RE_ENCRYPTED_REALM_FILE_NAME, DECRYPTED_REALM_FILE_NAME)) {
-            File fileToDelete = new File(getContext().getFilesDir(), fileName);
-            if (fileToDelete.exists() && !fileToDelete.delete()) {
-                fail();
-            }
-        }
-
-        File destination = new File(getContext().getFilesDir(), ENCRYPTED_REALM_FILE_NAME);
-        byte[] key = new byte[64];
-        new Random(42).nextBytes(key);
-        try {
-            // Unencrypted to encrypted
-            testRealm.writeEncryptedCopyTo(destination, key);
-        } catch(Exception e) {
-            e.printStackTrace();
-            fail();
-        }
-
-        Realm encryptedRealm = null;
-        try {
-            encryptedRealm = Realm.getInstance(getContext(), ENCRYPTED_REALM_FILE_NAME, key);
-            assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
-
-            destination = new File(getContext().getFilesDir(), RE_ENCRYPTED_REALM_FILE_NAME);
-            new Random(1234321).nextBytes(key);
-            try {
-                // Encrypted to encrypted
-                encryptedRealm.writeEncryptedCopyTo(destination, key);
-            } catch (Exception e) {
-                e.printStackTrace();
-                fail();
-            }
-            Realm reEncryptedRealm = null;
-            try {
-                reEncryptedRealm = Realm.getInstance(getContext(), RE_ENCRYPTED_REALM_FILE_NAME, key);
-                assertEquals(TEST_DATA_SIZE, reEncryptedRealm.where(AllTypes.class).count());
-            } finally {
-                if (reEncryptedRealm != null) {
-                    reEncryptedRealm.close();
-                    boolean isDeleted = new File(reEncryptedRealm.getPath()).delete();
-                    if (!isDeleted) {
-                        fail();
-                    }
-                }
-            }
-
-            destination = new File(getContext().getFilesDir(), DECRYPTED_REALM_FILE_NAME);
-            try {
-                // Encrypted to decrypted
-                encryptedRealm.writeEncryptedCopyTo(destination, null);
-            } catch (Exception e) {
-                fail();
-            }
-            Realm decryptedRealm = null;
-            try {
-                decryptedRealm = Realm.getInstance(getContext(), DECRYPTED_REALM_FILE_NAME);
-                assertEquals(TEST_DATA_SIZE, decryptedRealm.where(AllTypes.class).count());
-            } finally {
-                if (decryptedRealm != null) {
-                    decryptedRealm.close();
-                    boolean isDeleted = new File(decryptedRealm.getPath()).delete();
-                    if (!isDeleted) {
-                        fail();
-                    }
-                }
-            }
-        } finally {
-            if (encryptedRealm != null) {
-                encryptedRealm.close();
-                boolean isDeleted = new File(encryptedRealm.getPath()).delete();
-                if (!isDeleted) {
-                    fail();
-                }
-            }
-        }
-    }
-
-    public void testOpenRealmFileDeletionShouldThrow() {
-        final String OTHER_REALM_NAME = "yetAnotherRealm.realm";
-
-        // This instance is already cached because of the setUp() method so this deletion should throw
-        try {
-            Realm.deleteRealmFile(getContext());
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-
-        // Create a new Realm file
-        Realm yetAnotherRealm = Realm.getInstance(getContext(), OTHER_REALM_NAME);
-
-        // Deleting it should fail
-        try {
-            Realm.deleteRealmFile(getContext(), OTHER_REALM_NAME);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-
-        // But now that we close it deletion should work
-        yetAnotherRealm.close();
-        try {
-            Realm.deleteRealmFile(getContext(), OTHER_REALM_NAME);
-        } catch (Exception e) {
-            fail();
-        }
-    }
-
-    public void testWrongKeyShouldThrow() {
-        final String WRONG_KEY_REALM = "wrong-key-realm.realm";
-        Realm.deleteRealmFile(getContext(), WRONG_KEY_REALM);
-
-        // Wrong key size
-        try {
-            Realm.getInstance(getContext(), WRONG_KEY_REALM, new byte[63]);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        Realm.getInstance(getContext(), WRONG_KEY_REALM);
-
-        try {
-            Realm.getInstance(getContext(), WRONG_KEY_REALM, new byte[64]);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
-    public void testUpdateObjectWithLinks() throws Exception {
-        testRealm.beginTransaction();
-
-        // Create an owner with two dogs
-        OwnerPrimaryKey owner = testRealm.createObject(OwnerPrimaryKey.class);
-        owner.setId(1);
-        owner.setName("Jack");
-        Dog rex = testRealm.createObject(Dog.class);
-        rex.setName("Rex");
-        Dog fido = testRealm.createObject(Dog.class);
-        fido.setName("Fido");
-        owner.getDogs().add(rex);
-        owner.getDogs().add(fido);
-        assertEquals(2, owner.getDogs().size());
-
-        // Changing the name of the owner should not affect the number of dogs
-        owner.setName("Peter");
-        assertEquals(2, owner.getDogs().size());
-
-        // Updating the user should not affect it either. This is actually a no-op since owner is a Realm backed object
-        OwnerPrimaryKey owner2 = testRealm.copyToRealmOrUpdate(owner);
-        assertEquals(2, owner.getDogs().size());
-        assertEquals(2, owner2.getDogs().size());
-
-        testRealm.commitTransaction();
-    }
-
-    public void testDeleteNonRealmFile() throws IOException {
-        File tmpFile = new File(getContext().getFilesDir(), "tmp");
-        tmpFile.delete();
-        assertTrue(tmpFile.createNewFile());
-        assertTrue(Realm.deleteRealmFile(tmpFile));
-    }
-
-    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
-    public void testMutableMethodsOutsideWriteTransactions() throws JSONException, IOException {
-
-        // Prepare standalone object data
-        AllTypesPrimaryKey t = new AllTypesPrimaryKey();
-        List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
-
-        // Prepare JSON data
-        String jsonObjStr = "{ \"columnLong\" : 1 }";
-        JSONObject jsonObj = new JSONObject(jsonObjStr);
-        InputStream jsonObjStream = TestHelper.stringToStream(jsonObjStr);
-        InputStream jsonObjStream2 = TestHelper.stringToStream(jsonObjStr);
-
-        String jsonArrStr = " [{ \"columnLong\" : 1 }] ";
-        JSONArray jsonArr = new JSONArray(jsonArrStr);
-        InputStream jsonArrStream = TestHelper.stringToStream(jsonArrStr);
-        InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
-
-        // Test all methods that should require a write transaction
-        try { testRealm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.clear(AllTypes.class);          fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.setVersion(42);                 fail(); } catch (IllegalStateException expected) {}
-
-        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
-        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
-        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream);          fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
-
-        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (RealmException expected) {}
-        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (RealmException expected) {}
-        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStream);             fail(); } catch (IllegalStateException expected) {}
-        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (RealmException expected) {}
-        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (RealmException expected) {}
-        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/TestHelper.java b/realm/src/androidTest/java/io/realm/TestHelper.java
deleted file mode 100644
index 865c9b1076..0000000000
--- a/realm/src/androidTest/java/io/realm/TestHelper.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.content.Context;
-import android.content.res.AssetManager;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-
-import java.io.InputStreamReader;
-import java.nio.charset.Charset;
-
-public class TestHelper {
-
-    public static String streamToString(InputStream in) throws IOException {
-        BufferedReader br = null;
-        StringBuilder sb = new StringBuilder();
-        String line;
-        try {
-            br = new BufferedReader(new InputStreamReader(in));
-            while ((line = br.readLine()) != null) {
-                sb.append(line);
-            }
-        } finally {
-            if (br != null) {
-                br.close();
-            }
-        }
-
-        return sb.toString();
-    }
-
-    public static InputStream stringToStream(String str) {
-        return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
-    }
-
-    // Copies a Realm file from assets to app files dir
-    public static void copyRealmFromAssets(Context context, String realmPath, String newName) throws IOException {
-        AssetManager assetManager = context.getAssets();
-        InputStream is = assetManager.open(realmPath);
-        File file = new File(context.getFilesDir(), newName);
-        FileOutputStream outputStream = new FileOutputStream(file);
-        byte[] buf = new byte[1024];
-        int bytesRead;
-        while ((bytesRead = is.read(buf)) > -1) {
-            outputStream.write(buf, 0, bytesRead);
-        }
-        outputStream.close();
-        is.close();
-    }
-
-    // Deletes the old database and copies a new one into its place
-    public static void prepareDatabaseFromAssets(Context context, String realmPath, String newName) throws IOException {
-        Realm.deleteRealmFile(context, newName);
-        TestHelper.copyRealmFromAssets(context, realmPath, newName);
-    }
-
-    public static class StubInputStream extends InputStream {
-        @Override
-        public int read() throws IOException {
-            return 0; // Stub implementation
-        }
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/entities/CyclicType.java b/realm/src/androidTest/java/io/realm/entities/CyclicType.java
deleted file mode 100644
index f9e771bd02..0000000000
--- a/realm/src/androidTest/java/io/realm/entities/CyclicType.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package io.realm.entities;
-
-import io.realm.RealmList;
-import io.realm.RealmObject;
-
-public class CyclicType extends RealmObject {
-
-    private String name;
-    private CyclicType object;
-    private RealmList<CyclicType> objects;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public CyclicType getObject() {
-        return object;
-    }
-
-    public void setObject(CyclicType object) {
-        this.object = object;
-    }
-
-    public RealmList<CyclicType> getObjects() {
-        return objects;
-    }
-
-    public void setObjects(RealmList<CyclicType> objects) {
-        this.objects = objects;
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/entities/IOSChild.java b/realm/src/androidTest/java/io/realm/entities/IOSChild.java
deleted file mode 100644
index f041de1f21..0000000000
--- a/realm/src/androidTest/java/io/realm/entities/IOSChild.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package io.realm.entities;
-
-import io.realm.RealmObject;
-
-public class IOSChild extends RealmObject {
-    private String name;
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
deleted file mode 100644
index 51280a6a6c..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-public class JNIBinaryTypeTest extends TestCase {
-
-    protected Table table;
-    protected byte [] testArray = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
-
-    @Override
-    public void setUp() {
-        RealmCore.loadLibrary();
-        //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
-
-        table = new Table();
-        table.addColumn(ColumnType.BINARY, "bin");
-    }
-
-    @Override
-    public void tearDown() {
-        //table.close();
-        table = null;
-    }
-
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
deleted file mode 100644
index 76b3407c17..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-public class JNIColumnInfoTest extends TestCase {
-
-    Table table;
-
-    @Override
-    public void setUp() {
-        table = new Table();
-        table.addColumn(ColumnType.STRING, "firstName");
-        table.addColumn(ColumnType.STRING, "lastName");
-    }
-
-    public void testShouldGetColumnInformation() {
-
-        assertEquals(2, table.getColumnCount());
-
-        assertEquals("lastName", table.getColumnName(1));
-
-        assertEquals(1, table.getColumnIndex("lastName"));
-
-        assertEquals(ColumnType.STRING, table.getColumnType(1));
-
-    }
-
-    public void testValidateColumnInfo() {
-
-        TableView view = table.where().findAll();
-
-        assertEquals(2, view.getColumnCount());
-
-        assertEquals("lastName", view.getColumnName(1));
-
-        assertEquals(1, view.getColumnIndex("lastName"));
-
-        assertEquals(ColumnType.STRING, view.getColumnType(1));
-
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
deleted file mode 100644
index aa47ed5672..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-public class JNILinkTest extends TestCase {
-
-    public void testLinkColumns() {
-
-        Group group = new Group();
-
-        Table table1 = group.getTable("table1");
-
-
-        Table table2 = group.getTable("table2");
-        table2.addColumn(ColumnType.INTEGER, "int");
-        table2.addColumn(ColumnType.STRING, "string");
-
-        table2.add(1, "c");
-        table2.add(2, "b");
-        table2.add(3, "a");
-
-        table1.addColumnLink(ColumnType.LINK, "Link", table2);
-
-
-        table1.addEmptyRow();
-        table1.setLink(0, 0, 1);
-
-        Table target = table1.getLinkTarget(0);
-
-        System.gc();
-
-
-        assertEquals(target.getColumnCount(), 2);
-
-
-        String test = target.getString(1, table1.getLink(0, 0));
-
-        assertEquals(test, "b");
-
-
-
-    }
-
-    public void testLinkList() {
-
-        Group group = new Group();
-
-        Table table1 = group.getTable("table1");
-        table1.addColumn(ColumnType.INTEGER, "int");
-        table1.addColumn(ColumnType.STRING, "string");
-        table1.add(1, "c");
-        table1.add(2, "b");
-        table1.add(3, "a");
-
-
-        Table table2 = group.getTable("table2");
-
-        table2.addColumnLink(ColumnType.LINK_LIST, "LinkList", table1);
-
-        table2.insertLinkList(0,0);
-
-        LinkView links = table2.getRow(0).getLinkList(0);
-
-        assertEquals(links.isEmpty(), true);
-        assertEquals(links.size(), 0);
-
-        links.add(2);
-        links.add(1);
-
-        assertEquals(links.isEmpty(), false);
-        assertEquals(links.size(), 2);
-
-        assertEquals(links.get(0).getColumnName(1), "string");
-
-        assertEquals(links.get(0).getString(1), "a");
-
-        links.move(1, 0);
-
-        assertEquals(links.get(0).getString(1), "b");
-
-        links.remove(0);
-
-        assertEquals(links.get(0).getString(1), "a");
-        assertEquals(links.size(), 1);
-
-
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java b/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
deleted file mode 100644
index 7a17a4de91..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.internal.test.MixedData;
-
-public class JNIMixedTypeTest extends TestCase {
-
-    static List<MixedData> mixedDataList = new ArrayList<MixedData>();
-
-    public static Collection<Object[]> parameters() {
-        //Adding MixedData to the list
-        mixedDataList.add(0, new MixedData(ColumnType.INTEGER, 123L));
-        mixedDataList.add(1, new MixedData(ColumnType.FLOAT, 987.123f));
-        mixedDataList.add(2, new MixedData(ColumnType.DOUBLE, 1234567.898d));
-        mixedDataList.add(3, new MixedData(ColumnType.BOOLEAN, true));
-        mixedDataList.add(4, new MixedData(ColumnType.STRING, "abc"));
-        mixedDataList.add(5, new MixedData(ColumnType.BINARY, new byte[]{1, 2, 3, 4, 5}));
-        mixedDataList.add(6, new MixedData(ColumnType.DATE, new Date(645342)));
-
-        return Arrays.asList(
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList}
-        );
-    }
-
-    public JNIMixedTypeTest(ArrayList mixedDataList) {
-        this.mixedDataList = mixedDataList;
-
-    }
-
-    public void testShouldMatchMixedValues() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            for (int j = 0; j < mixedDataList.size(); j++) {
-                if (mixedDataList.get(i).value == mixedDataList.get(j).value) {
-                    assertEquals(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                } else {
-                    assertNotSame(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                }
-            }
-        }
-    }
-
-    public void testShouldFailOnWrongTypeRetrieval() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            Object value = mixedDataList.get(i).type != ColumnType.STRING ? "abc" : 123;
-            Mixed mixed = Mixed.mixedValue(value);
-
-            switch (mixedDataList.get(i).type) {
-                case BINARY:
-                    try {
-                        mixed.getBinaryByteArray();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case DATE:
-                    try {
-                        mixed.getDateValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case BOOLEAN:
-                    try {
-                        mixed.getBooleanValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case INTEGER:
-                    try {
-                        mixed.getLongValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case FLOAT:
-                    try {
-                        mixed.getFloatValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case DOUBLE:
-                    try {
-                        mixed.getDoubleValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                case STRING:
-                    try {
-                        mixed.getStringValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
-                    }
-                    break;
-                default:
-                    fail("wrong type");
-                    break;
-            }
-        }
-    }
-
-    public void testShouldStoreValuesOfMixedType() throws Throwable {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            for (int j = 0; j < mixedDataList.size(); j++) {
-                for (int k = 0; k < mixedDataList.size(); k++) {
-
-                    Table table = new Table();
-                    table.addColumn(ColumnType.MIXED, "mix");
-
-                    table.add(mixedDataList.get(i).value);
-
-                    checkMixedCell(table, 0, 0, mixedDataList.get(i).type, mixedDataList.get(i).value);
-
-                    table.setMixed(0, 0, Mixed.mixedValue(mixedDataList.get(j).value));
-
-                    checkMixedCell(table, 0, 0, mixedDataList.get(j).type, mixedDataList.get(j).value);
-
-                    table.setMixed(0, 0, Mixed.mixedValue(mixedDataList.get(k).value));
-
-                    checkMixedCell(table, 0, 0, mixedDataList.get(k).type, mixedDataList.get(k).value);
-                    table.close();
-                }
-            }
-        }
-    }
-
-    private void checkMixedCell(Table table, long col, long row, ColumnType columnType, Object value) throws IllegalMixedTypeException {
-        ColumnType mixedType = table.getMixedType(col, row);
-        assertEquals(columnType, mixedType);
-
-        Mixed mixed = table.getMixed(col, row);
-        if (columnType == ColumnType.BINARY) {
-            if (mixed.getBinaryType() == Mixed.BINARY_TYPE_BYTE_ARRAY) {
-                // NOTE: We never get here because we always "get" a ByteBuffer.
-                byte[] bin = mixed.getBinaryByteArray();
-                assertEquals(Mixed.mixedValue(value), bin);
-            } else {
-                ByteBuffer binBuf = mixed.getBinaryValue();
-                // TODO: Below is sort of hack to compare the content of the
-                // buffers, since you always will get a ByteBuffer from a Mixed.
-                ByteBuffer valueBuf = ByteBuffer.wrap((byte[]) value);
-                if (!binBuf.equals(valueBuf))
-                    System.out.println("***failed");
-                assertEquals(Mixed.mixedValue(valueBuf), Mixed.mixedValue(binBuf));
-            }
-        } else {
-            assertEquals(value, mixed.getValue());
-        }
-    }
-
-    public static Test suite() {
-        return new JNITestSuite(JNIMixedTypeTest.class, parameters());
-
-    }
-}
-
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIParameterizedTestExample.java b/realm/src/androidTest/java/io/realm/internal/JNIParameterizedTestExample.java
deleted file mode 100644
index a9ca2f08b9..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNIParameterizedTestExample.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-
-import java.util.Arrays;
-import java.util.Collection;
-
-public class JNIParameterizedTestExample extends TestCase {
-
-    private int input_one;
-    private int input_two;
-    private int expected_value;
-
-    //set up parameters for tests
-    public static Collection<Object[]> parameters() {
-        return Arrays.asList(
-                new Object[]{2, 1, 3},
-                new Object[]{1, 1, 2},
-                new Object[]{-2, 1, -1}
-        );
-    }
-
-    // {2, 1, 2} will be set to 2= input_one, 1= input_two and 3=expected_value
-    public JNIParameterizedTestExample(int input_one, int input_two, int expected_value) {
-        this.input_one = input_one;
-        this.input_two = input_two;
-        this.expected_value = expected_value;
-    }
-
-    // The test suite is set to method name must start with 'test',return type void and empty parameters.
-    public void testIntAdd() {
-        final int actual_value = input_one + input_two;
-        System.out.println(expected_value + "+" + actual_value);
-        assertEquals(expected_value, actual_value);
-    }
-
-    //Returns the test class and parameters
-    public static Test suite() {
-        return new JNITestSuite(JNIParameterizedTestExample.class, parameters());
-
-    }
-
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
deleted file mode 100644
index 0124afd7ac..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package io.realm.internal;
-
-import android.test.MoreAsserts;
-
-import junit.framework.TestCase;
-
-import java.util.Date;
-
-public class JNIRowTest extends TestCase {
-
-    public void testRow() {
-
-        Table table = new Table();
-
-        table.addColumn(ColumnType.STRING, "string");
-        table.addColumn(ColumnType.INTEGER, "integer");
-        table.addColumn(ColumnType.FLOAT, "float");
-        table.addColumn(ColumnType.DOUBLE, "double");
-        table.addColumn(ColumnType.BOOLEAN, "boolean");
-        table.addColumn(ColumnType.DATE, "date");
-        table.addColumn(ColumnType.BINARY, "binary");
-
-
-        byte[] data = new byte[2];
-
-        table.add("abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
-
-
-        Row row = table.getRow(0);
-
-        assertEquals("abc", row.getString(0));
-        assertEquals(3, row.getLong(1));
-        assertEquals((float) 1.2, row.getFloat(2), 0.0001);
-        assertEquals(1.3, row.getDouble(3));
-        assertEquals(true, row.getBoolean(4));
-        assertEquals(new Date(0), row.getDate(5));
-        MoreAsserts.assertEquals(data, row.getBinaryByteArray(6));
-
-
-        row.setString(0, "a");
-        row.setLong(1, 1);
-        row.setFloat(2, (float) 8.8);
-        row.setDouble(3, 9.9);
-        row.setBoolean(4, false);
-        row.setDate(5, new Date(10000));
-
-        byte[] newData = new byte[3];
-        row.setBinaryByteArray(6, newData);
-
-        assertEquals("a", row.getString(0));
-        assertEquals(1, row.getLong(1));
-        assertEquals((float) 8.8, row.getFloat(2), 0.0001);
-        assertEquals(9.9, row.getDouble(3));
-        assertEquals(false, row.getBoolean(4));
-        assertEquals(new Date(10000), row.getDate(5));
-        MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
-    }
-
-    public void testMixed() {
-        Table table = new Table();
-
-        table.addColumn(ColumnType.MIXED, "mixed");
-
-        table.addEmptyRows(2);
-
-        Row row = table.getRow(0);
-        row.setMixed(0, new Mixed(1.5));
-
-        assertEquals(1.5, row.getMixed(0).getDoubleValue());
-
-        Row row2 = table.getRow(1);
-        row2.setMixed(0, new Mixed("test"));
-
-        assertEquals("test", row2.getMixed(0).getStringValue());
-
-
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
deleted file mode 100644
index a15bfbac12..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import android.test.MoreAsserts;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.internal.test.TestHelper;
-
-
-public class JNITableInsertTest extends TestCase {
-
-    static List<Object> value = new ArrayList<Object>();
-    Object tv = new Object();
-    Object ct = new Object();
-
-    public static Collection<Object[]> parameters() {
-        value.add(0, true);
-        value.add(1, "abc");
-        value.add(2, 123L);
-        value.add(3, 987.123f);
-        value.add(4, 1234567.898d);
-        value.add(5, new Date(645342));
-        value.add(6, new byte[]{1, 2, 3, 4, 5});
-        return Arrays.asList(
-                new Object[]{value},
-                new Object[]{value}
-        );
-    }
-
-    public JNITableInsertTest(ArrayList value) {
-        this.value = value;
-    }
-
-    public void verifyRow(Table tbl, long rowIndex, Object[] values) {
-        assertTrue((Boolean) (values[0]) == tbl.getBoolean(0, rowIndex));
-        assertEquals(((Number) values[1]).longValue(), tbl.getLong(1, rowIndex));
-        assertEquals((String) values[2], tbl.getString(2, rowIndex));
-        if (values[3] instanceof byte[])
-            MoreAsserts.assertEquals((byte[]) values[3], tbl.getBinaryByteArray(3, rowIndex));
-        assertEquals(((Date) values[4]).getTime() / 1000, tbl.getDate(4, rowIndex).getTime() / 1000);
-
-        //      Mixed mix1 = Mixed.mixedValue(values[5]);
-        //      Mixed mix2 =  tbl.getMixed(5, rowIndex);
-        // TODO:        assertTrue(mix1.equals(mix2));
-
-        Table subtable = tbl.getSubtable(6, rowIndex);
-        Object[] subValues = (Object[]) values[6];
-        for (long i = 0; i < subtable.size(); i++) {
-            Object[] val = (Object[]) subValues[(int) i];
-            assertTrue(((Number) val[0]).longValue() == subtable.getLong(0, i));
-            assertEquals(((String) val[1]), subtable.getString(1, i));
-        }
-        assertTrue(tbl.isValid());
-    }
-
-
-    public void testShouldInsertAddAndSetRows() {
-        Table table = new Table();
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.BOOLEAN, "bool");
-        tableSpec.addColumn(ColumnType.INTEGER, "number");
-        tableSpec.addColumn(ColumnType.STRING, "string");
-        tableSpec.addColumn(ColumnType.BINARY, "Bin");
-        tableSpec.addColumn(ColumnType.DATE, "date");
-        tableSpec.addColumn(ColumnType.MIXED, "mix");
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(ColumnType.INTEGER, "sub-num");
-        subspec.addColumn(ColumnType.STRING, "sub-str");
-        table.updateFromSpec(tableSpec);
-
-        byte[] buf = new byte[23];
-        Mixed mixedSubtable = new Mixed(ColumnType.TABLE);
-        Date date = new Date();
-        long mixed = 123;
-
-        // Check subtable
-        Object[][] subTblData = new Object[][]{{234, "row0"},
-                {345, "row1"},
-                {456, "row2"}};
-        Object[] rowData0 = new Object[]{false, (short) 2, "hi", buf, date, mixed, subTblData};
-        long index = table.add(rowData0);
-        assertEquals(0, index);
-        verifyRow(table, 0, rowData0);
-
-        Object[] rowData1 = new Object[]{false, 7, "hi1", new byte[]{0, 2, 3}, date, "mix1", null};
-        Object[] rowData2 = new Object[]{true, 12345567789L, "hello", new byte[]{0}, date, buf, null};
-        Object[] rowData3 = new Object[]{false, (byte) 17, "hi3", buf, date, mixedSubtable, null};
-        // TODO: support insert of mixed subtable
-
-        table.addAt(1, rowData1);
-        index = table.add(rowData2);
-        assertEquals(2, index);
-        table.addAt(0, rowData3);
-
-        verifyRow(table, 0, rowData3);
-        verifyRow(table, 1, rowData0);
-        verifyRow(table, 2, rowData1);
-        verifyRow(table, 3, rowData2);
-
-        // Same test - but a one-liner...
-        table.add(false, (short) 2, "hi", buf, date, mixed, new Object[][]{{234, "row0"},
-                {345, "row1"},
-                {456, "row2"}});
-        verifyRow(table, 4, rowData0);
-
-        // Test set()
-        Date date2 = new Date(123);
-        Object[] newRowData = new Object[]{true, 321, "new", new byte[]{5},
-                date2, "hey", new Object[][]{{432, "new"}}};
-        table.set(2, newRowData);
-        verifyRow(table, 0, rowData3);
-        verifyRow(table, 1, rowData0);
-        verifyRow(table, 2, newRowData);
-        verifyRow(table, 3, rowData2);
-
-    }
-
-    public void testAddAtMethod() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "col1");
-        t.addColumn(ColumnType.INTEGER, "col2");
-
-        t.add("s1", 1);
-        t.add("s2", 2);
-
-        t.addAt(1, "s22", 22);
-
-        assertEquals(t.getString(0, 1), "s22");
-    }
-
-    public void testShouldFailInsert() {
-        Table table = new Table();
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(ColumnType.BOOLEAN, "bool");
-        tableSpec.addColumn(ColumnType.INTEGER, "number");
-        tableSpec.addColumn(ColumnType.STRING, "string");
-        tableSpec.addColumn(ColumnType.BINARY, "Bin");
-        tableSpec.addColumn(ColumnType.DATE, "date");
-        tableSpec.addColumn(ColumnType.MIXED, "mix");
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(ColumnType.INTEGER, "sub-num");
-        table.updateFromSpec(tableSpec);
-
-        // Wrong number of parameters
-        byte[] buf = new byte[23];
-        try {
-            table.addAt(0, false);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // wrong row index
-        long mix = 123;
-        try {
-            table.addAt(1, false, 1, "hi", buf, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // wrong row index
-        table.addAt(0, false, 1, "hi", buf, new Date(), 123, null);
-        table.addAt(1, false, 1, "hi", buf, new Date(), 123, null);
-        try {
-            table.addAt(3, false, 1, "hi", buf, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (999 instead of bool)
-        try {
-            table.addAt(0, 999, 1, "hi", buf, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (bool instead of 1)
-        try {
-            table.addAt(0, true, false, "hi", buf, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (999 instead of string)
-        try {
-            table.addAt(0, false, 1, 999, buf, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (999 instead of Binary)
-        try {
-            table.addAt(0, false, 1, "hi", 999, new Date(), mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (999 instead of Date)
-        try {
-            table.addAt(0, false, 1, "hi", buf, 999, mix, null);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (999 instead of subtable)
-        try {
-            table.addAt(0, false, 1, "hi", buf, new Date(), mix, 999);
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (String instead of subtable-Int)
-        try {
-            table.addAt(0, false, 1, "hi", buf, new Date(), mix, new Object[][]{{"err", 2, 3}});
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-
-        // Wrong type of parameter (String instead of subtable-Int)
-        try {
-            table.addAt(0, false, 1, "hi", buf, new Date(), mix, new Object[]{1, 2, 3});
-            fail("expected exception.");
-        } catch (IllegalArgumentException e) {
-        }
-    }
-
-
-    public void testIncrementInColumnTest() {
-
-        Table table = new Table();
-        table.addColumn(ColumnType.STRING, "col0");
-        table.addColumn(ColumnType.INTEGER, "col1");
-
-        table.add("row0", 0);
-        table.add("row1", 10);
-        table.add("row2", 20);
-        table.add("row3", 30);
-        table.add("row4", 40);
-
-        table.adjust(1, 3); //Adding 3 to all rows in col1
-
-        assertEquals(3, table.getLong(1, 0));
-        assertEquals(13, table.getLong(1, 1));
-        assertEquals(23, table.getLong(1, 2));
-        assertEquals(33, table.getLong(1, 3));
-        assertEquals(43, table.getLong(1, 4));
-    }
-
-
-    public void testAdjustColumnValuesOnUnsupportedColumnTypeTest() {
-
-        Table table = TestHelper.getTableWithAllColumnTypes();
-
-        for (long c = 0; c < table.getColumnCount(); c++) {
-
-            if (table.getColumnType(c).equals(ColumnType.INTEGER) == false) { // Do not check if it is a Long column
-                try {
-                    table.adjust(c, 10);
-                    assertTrue(false); //We should never get here, as an exception is thrown above
-                } catch (IllegalArgumentException e) {
-                    assertTrue(true); // All other column types than long will throw exception
-                }
-            }
-        }
-    }
-
-    public void testShouldThrowExceptionWhenColumnNameIsTooLong() {
-
-        Table table = new Table();
-        try {
-            table.addColumn(ColumnType.STRING, "THIS STRING HAS 64 CHARACTERS, "
-                    + "LONGER THAN THE MAX 63 CHARACTERS");
-            fail("Too long name");
-        } catch (IllegalArgumentException e) {
-        }
-    }
-
-    public void testWhenColumnNameIsExcactly63CharLong() {
-
-        Table table = new Table();
-        table.addColumn(ColumnType.STRING, "THIS STRING HAS 63 CHARACTERS PERFECT FOR THE MAX 63 CHARACTERS");
-    }
-
-    public void testGenericAddOnTable() {
-        for (int i = 0; i < value.size(); i++) {
-            for (int j = 0; j < value.size(); j++) {
-
-                Table t = new Table();
-
-                //If the objects matches no exception will be thrown
-                if (value.get(i).getClass().equals(value.get(j).getClass())) {
-                    assertTrue(true);
-
-                } else {
-                    //Add column
-                    t.addColumn(TestHelper.getColumnType(value.get(j)), value.get(j).getClass().getSimpleName());
-                    //Add value
-                    try {
-                        t.add(value.get(i));
-                        fail("No matching type");
-                    } catch (IllegalArgumentException e) {
-                    }
-                }
-            }
-        }
-    }
-
-
-    public static Test suite() {
-        return new JNITestSuite(JNITableInsertTest.class, parameters());
-
-    }
-}
-
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
deleted file mode 100644
index 125d450f9f..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ /dev/null
@@ -1,473 +0,0 @@
-package io.realm.internal;
-
-import android.test.AndroidTestCase;
-import android.test.MoreAsserts;
-
-import java.io.File;
-import java.util.Date;
-
-import io.realm.internal.test.TestHelper;
-
-public class JNITableTest extends AndroidTestCase {
-
-    Table t = new Table();
-
-    Table createTestTable() {
-        Table t = new Table();
-        t.addColumn(ColumnType.BINARY, "binary"); // 0
-        t.addColumn(ColumnType.BOOLEAN, "boolean");  // 1
-        t.addColumn(ColumnType.DATE, "date");     // 2
-        t.addColumn(ColumnType.DOUBLE, "double"); // 3
-        t.addColumn(ColumnType.FLOAT, "float");   // 4
-        t.addColumn(ColumnType.INTEGER, "long");      // 5
-        t.addColumn(ColumnType.MIXED, "mixed");   // 6
-        t.addColumn(ColumnType.STRING, "string"); // 7
-        t.addColumn(ColumnType.TABLE, "table");   // 8
-        return t;
-    }
-
-    @Override
-    public void setUp() {
-        t = createTestTable();
-    }
-
-    public void testTableToString() {
-        Table t = new Table();
-
-        t.addColumn(ColumnType.STRING, "stringCol");
-        t.addColumn(ColumnType.INTEGER, "intCol");
-        t.addColumn(ColumnType.BOOLEAN, "boolCol");
-
-        t.add("s1", 1, true);
-        t.add("s2", 2, false);
-
-        String expected =
-"    stringCol  intCol  boolCol\n" +
-"0:  s1              1     true\n" +
-"1:  s2              2    false\n" ;
-
-        assertEquals(expected, t.toString());
-    }
-
-    public void testGroupEquals() {
-        Table t2 = createTestTable();
-        assertEquals(true, t.equals(t2));
-        t.addEmptyRow();
-        assertEquals(false, t.equals(t2));
-    }
-
-
-    public void testRowOperationsOnZeroRow(){
-
-        Table t = new Table();
-        // Remove rows without columns
-        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-
-        // Column added, remove rows again
-        t.addColumn(ColumnType.STRING, "");
-        try { t.remove(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { t.remove(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-
-    }
-
-    public void testZeroColOperations() {
-        Table tableZeroCols = new Table();
-
-        // Add rows
-        try { tableZeroCols.add("val");         fail("No columns in table"); } catch (IllegalArgumentException e) {}
-        try { tableZeroCols.addEmptyRow();      fail("No columns in table"); } catch (IndexOutOfBoundsException e) {}
-        try { tableZeroCols.addEmptyRows(10);   fail("No columns in table"); } catch (IndexOutOfBoundsException e) {}
-
-
-        // Col operations
-        try { tableZeroCols.removeColumn(0);                fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { tableZeroCols.renameColumn(0, "newName");     fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { tableZeroCols.removeColumn(10);               fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException e) {}
-    }
-
-    public void testTableBinaryTest() {
-        Table t = new Table();
-        t.addColumn(ColumnType.BINARY, "binary");
-
-        byte[] row0 = new byte[] { 1, 2, 3 };
-        byte[] row1 = new byte[] { 10, 20, 30 };
-
-        t.getInternalMethods().insertBinary(0, 0, row0);
-        t.getInternalMethods().insertDone();
-        t.getInternalMethods().insertBinary(0, 1, row1);
-        t.getInternalMethods().insertDone();
-
-        byte[] nullByte = null;
-
-        try { t.getInternalMethods().insertBinary(0, 2, nullByte); fail("Inserting null array"); } catch(IllegalArgumentException e) { }
-
-
-        MoreAsserts.assertEquals(new byte[]{1, 2, 3}, t.getBinaryByteArray(0, 0));
-        assertEquals(false, t.getBinaryByteArray(0, 0) == new byte[]{1, 2, 3});
-
-        byte[] newRow0 = new byte[] { 7, 77, 77 };
-        t.setBinaryByteArray(0, 0, newRow0);
-
-        MoreAsserts.assertEquals(new byte[]{7, 77, 77}, t.getBinaryByteArray(0, 0));
-        assertEquals(false, t.getBinaryByteArray(0, 0) == new byte[] { 1, 2, 3 });
-
-        try { t.setBinaryByteArray(0, 2, nullByte); fail("Inserting null array"); } catch(IllegalArgumentException e) { }
-    }
-
-
-    public void testFindFirstNonExisting() {
-        Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
-
-        assertEquals(-1, t.findFirstBoolean(1, false));
-        assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
-        assertEquals(-1, t.findFirstDouble(3, 1.0d));
-        assertEquals(-1, t.findFirstFloat(4, 1.0f));
-        assertEquals(-1, t.findFirstLong(5, 50));
-        assertEquals(-1, t.findFirstString(7, "other string"));
-    }
-
-
-    public void testGetValuesFromNonExistingColumn() {
-        Table t = TestHelper.getTableWithAllColumnTypes();
-        t.addEmptyRows(10);
-
-        try { t.getBinaryByteArray(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getBinaryByteArray(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getBinaryByteArray(9, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getBoolean(-1, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getBoolean(-10, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getBoolean(9, 0);                   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getDate(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getDate(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getDate(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getDouble(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getDouble(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getDouble(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getFloat(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getFloat(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getFloat(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getLong(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getMixed(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getMixed(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getMixed(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { t.getSubtable(-1, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getSubtable(-10, 0);                fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getSubtable(9, 0);                  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-    }
-
-    public void testGetNonExistingColumn() {
-        Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "int");
-
-        assertEquals(-1, t.getColumnIndex("non-existing column"));
-        try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException e) { }
-    }
-
-
-    public void testGetSortedView() {
-        Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "");
-        t.addColumn(ColumnType.STRING, "");
-        t.addColumn(ColumnType.DOUBLE, "");
-
-        t.add(1, "s", 1000d);
-        t.add(3,"sss", 10d);
-        t.add(2, "ss", 100d);
-
-
-        // Check the order is as it is added
-        assertEquals(1, t.getLong(0, 0));
-        assertEquals(3, t.getLong(0, 1));
-        assertEquals(2, t.getLong(0, 2));
-        assertEquals("s", t.getString(1, 0));
-        assertEquals("sss", t.getString(1, 1));
-        assertEquals("ss", t.getString(1, 2));
-        assertEquals(1000d, t.getDouble(2, 0));
-        assertEquals(10d, t.getDouble(2, 1));
-        assertEquals(100d, t.getDouble(2, 2));
-
-        // Get the sorted view on first column
-        TableView v = t.getSortedView(0);
-
-        // Check the new order
-        assertEquals(1, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(3, v.getLong(0, 2));
-        assertEquals("s", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("sss", v.getString(1, 2));
-        assertEquals(1000d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(10d, v.getDouble(2, 2));
-
-        // Get the sorted view on first column descending
-        v = t.getSortedView(0, TableView.Order.descending);
-
-        // Check the new order
-        assertEquals(3, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(1, v.getLong(0, 2));
-        assertEquals("sss", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("s", v.getString(1, 2));
-        assertEquals(10d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(1000d, v.getDouble(2, 2));
-
-        // Some out of bounds test cases
-        try { t.getSortedView(-1, TableView.Order.descending);    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getSortedView(-100, TableView.Order.descending);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { t.getSortedView(100, TableView.Order.descending);   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-    }
-
-    public void testSetDataInNonExistingRow() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "colName");
-        t.add("String val");
-
-        try { t.set(1, "new string val"); fail("Row 1 does not exist"); } catch (IllegalArgumentException e) { }
-    }
-
-
-    public void testSetNulls() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "");
-        t.addColumn(ColumnType.DATE, "");
-        t.addColumn(ColumnType.MIXED, "");
-        t.addColumn(ColumnType.BINARY, "");
-        t.add("String val", new Date(), new Mixed(""), new byte[] { 1,2,3} );
-
-        try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException e) { }
-        try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException e) { }
-    }
-
-    public void testSetDataWithWrongColumnAmountParameters() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "colName");
-        t.add("String val");
-
-        try { t.set(0, "new string val", "This column does not exist"); fail("Table only has 1 column"); } catch (IllegalArgumentException e) { }
-    }
-
-    public void testAddNegativeEmptyRows() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "colName");
-
-        try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException e ) { }
-    }
-
-    public void testAddNullInMixedColumn() {
-        Table t = new Table();
-        t.addColumn(ColumnType.MIXED, "mixed");
-        t.add(new Mixed(true));
-
-        try { t.setMixed(0, 0, null); fail("Argument is null"); } catch (IllegalArgumentException e) { }
-    }
-
-    public void testSetDataWithWrongColumnTypes() {
-        Table t = new Table();
-        t.addColumn(ColumnType.STRING, "colName");
-        t.add("String val");
-
-        try { t.set(0, 100); fail("Table has string column, and here an integer is inserted"); } catch (IllegalArgumentException e) { }
-    }
-
-    public void testImmutableInsertNotAllowed() {
-
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
-
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
-
-        // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
-        try {
-            Table table = wt.getTable(TABLENAME);
-            table.addColumn(ColumnType.STRING, "col0");
-            table.add("value0");
-            table.add("value1");
-            table.add("value2");
-
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
-        }
-
-        ReadTransaction rt = group.beginRead();
-        try {
-            Table table = rt.getTable(TABLENAME);
-
-            try {  table.addAt(1, "NewValue"); fail("Exception expected when inserting in read transaction"); } catch (IllegalStateException e) { }
-
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    public void testGetName() {
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
-
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
-
-        // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
-        try {
-            Table table = wt.getTable(TABLENAME);
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
-        }
-
-        ReadTransaction rt = group.beginRead();
-        Table table = rt.getTable(TABLENAME);
-        assertEquals(TABLENAME, table.getName());
-    }
-
-    public void testShouldThrowWhenSetIndexOnWrongColumnType() {
-        for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
-
-            // Check all other column types than String throws exception when using addSearchIndex()/hasSearchIndex()
-            boolean exceptionExpected = (t.getColumnType(colIndex) != ColumnType.STRING);
-
-            // Try to addSearchIndex()
-            try {
-                t.addSearchIndex(colIndex);
-                if (exceptionExpected)
-                    fail("expected exception for colIndex " + colIndex);
-            } catch (IllegalArgumentException e) {
-            }
-
-            // Try to hasSearchIndex() for all columnTypes
-            t.hasSearchIndex(colIndex);
-        }
-    }
-
-
-    /**
-     * Returns a table with a few columns and values
-     * @return
-     */
-    private Table getTableWithSimpleData(){
-        Table table =  new Table();
-        table.addColumn(ColumnType.STRING, "col");
-        table.addColumn(ColumnType.INTEGER, "int");
-        table.add("val1", 100);
-        table.add("val2", 200);
-        table.add("val3", 300);
-
-        return table;
-    }
-
-    public void testTableEquals() {
-
-        Table table1 = getTableWithSimpleData();
-        Table table2 = getTableWithSimpleData();
-
-        assertEquals(true, table1.equals(table2));
-        assertEquals(true, table1.equals(table1)); // Same table
-        assertEquals(false, table1.equals(null)); // Null object
-        assertEquals(false, table1.equals("String")); // Other object
-    }
-
-    public void testColumnName() {
-        Table t = new Table();
-        try { t.addColumn(ColumnType.STRING, "I am 64 chracters..............................................."); fail("Only 63 chracters supported"); } catch (IllegalArgumentException e) { }
-        t.addColumn(ColumnType.STRING, "I am 63 chracters..............................................");
-    }
-
-    public void testTableNumbers() {
-        Table t = new Table();
-        t.addColumn(ColumnType.INTEGER, "intCol");
-        t.addColumn(ColumnType.DOUBLE, "doubleCol");
-        t.addColumn(ColumnType.FLOAT, "floatCol");
-        t.addColumn(ColumnType.STRING, "StringCol");
-
-        // Add 3 rows of data with same values in each column
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
-
-        // Add other values
-        t.add(10, 20.0d, 30.0f, "s10");
-        t.add(100, 200.0d, 300.0f, "s100");
-        t.add(1000, 2000.0d, 3000.0f, "s1000");
-
-        // Count instances of values added in the first 3 rows
-        assertEquals(3, t.count(0, 1));
-        assertEquals(3, t.count(1, 2.0d));
-        assertEquals(3, t.count(2, 3.0f));
-        assertEquals(3, t.count(3, "s1"));
-
-        assertEquals(3, t.findAllDouble(1, 2.0d).size());
-        assertEquals(3, t.findAllFloat(2, 3.0f).size());
-
-        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1
-        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2
-
-        // Set double and float
-        t.setDouble(1, 2, -2.0d);
-        t.setFloat(2, 2, -3.0f);
-
-        // Get double tests
-        assertEquals(-2.0d, t.getDouble(1, 2));
-        assertEquals(20.0d, t.getDouble(1, 3));
-        assertEquals(200.0d, t.getDouble(1, 4));
-        assertEquals(2000.0d, t.getDouble(1, 5));
-
-        // Get float test
-        assertEquals(-3.0f, t.getFloat(2, 2));
-        assertEquals(30.0f, t.getFloat(2, 3));
-        assertEquals(300.0f, t.getFloat(2, 4));
-        assertEquals(3000.0f, t.getFloat(2, 5));
-    }
-
-    public void testMaximumDate() {
-
-        Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
-
-        table.add(new Date(0));
-        table.add(new Date(10000));
-        table.add(new Date(1000));
-
-        assertEquals(new Date(10000), table.maximumDate(0));
-
-    }
-
-    public void testMinimumDate() {
-
-        Table table = new Table();
-        table.addColumn(ColumnType.DATE, "date");
-
-        table.add(new Date(10000));
-        table.add(new Date(0));
-        table.add(new Date(1000));
-
-        assertEquals(new Date(0), table.minimumDate(0));
-
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITestSuite.java b/realm/src/androidTest/java/io/realm/internal/JNITestSuite.java
deleted file mode 100644
index 87715b6963..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNITestSuite.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import android.annotation.TargetApi;
-import android.os.Build;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collection;
-
-public class JNITestSuite extends TestSuite {
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    public JNITestSuite(
-            final Class<? extends TestCase> testCaseClass,
-            final Collection<Object[]> parameters) {
-
-        setName(testCaseClass.getName());
-
-        final Constructor<?>[] constructors = testCaseClass.getConstructors();
-        if (constructors.length != 1) {
-            addTest(warning(testCaseClass.getName()
-                    + " must have a single public constructor."));
-            return;
-        }
-
-        final Collection<String> names = getTestMethods(testCaseClass);
-
-        final Constructor<?> constructor = constructors[0];
-        final Collection<TestCase> testCaseInstances = new ArrayList<TestCase>();
-        try {
-            for (final Object[] objects : parameters) {
-                for (final String name : names) {
-                    TestCase testCase = (TestCase) constructor.newInstance(objects);
-                    testCase.setName(name);
-                    testCaseInstances.add(testCase);
-                }
-            }
-        } catch (IllegalArgumentException e) {
-            addConstructionException(e);
-            return;
-        } catch (InstantiationException e) {
-            addConstructionException(e);
-            return;
-        } catch (IllegalAccessException e) {
-            addConstructionException(e);
-            return;
-        } catch (InvocationTargetException e) {
-            addConstructionException(e);
-            return;
-        }
-
-
-        for (final TestCase testCase : testCaseInstances) {
-            addTest(testCase);
-
-        }
-    }
-
-    private Collection<String> getTestMethods(
-            final Class<? extends TestCase> testCaseClass) {
-        Class<?> superClass = testCaseClass;
-        final Collection<String> names = new ArrayList<String>();
-        while (Test.class.isAssignableFrom(superClass)) {
-            Method[] methods = superClass.getDeclaredMethods();
-            for (int i = 0; i < methods.length; i++) {
-                addTestMethod(methods[i], names, testCaseClass);
-            }
-            superClass = superClass.getSuperclass();
-        }
-        return names;
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    private void addTestMethod(Method m, Collection<String> names, Class<?> theClass) {
-        String name = m.getName();
-        if (names.contains(name))
-            return;
-        if (!isPublicTestMethod(m)) {
-            if (isTestMethod(m))
-                addTest(warning("Test method isn't public: " + m.getName()));
-            return;
-        }
-        names.add(name);
-    }
-
-    private boolean isPublicTestMethod(Method m) {
-        return isTestMethod(m) && Modifier.isPublic(m.getModifiers());
-    }
-
-    private boolean isTestMethod(Method m) {
-        String name = m.getName();
-        Class<?>[] parameters = m.getParameterTypes();
-        Class<?> returnType = m.getReturnType();
-        return parameters.length == 0 && name.startsWith("test") && returnType.equals(Void.TYPE);
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    private void addConstructionException(Exception e) {
-        addTest(warning("Instantiation of a testCase failed "
-                + e.getClass().getName() + " " + e.getMessage()));
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNI_nativeTests.java b/realm/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
deleted file mode 100644
index 862123d4b8..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-public class JNI_nativeTests extends TestCase {
-
-    public void testNativeExceptions() {
-        String expect = "";
-        for (Util.Testcase test: Util.Testcase.values()) {
-            expect = test.expectedResult(0);
-            try {
-                test.execute(0);
-            } catch (Exception e) {
-                assertEquals(expect, e.toString());
-            } catch (Error e) {
-                assertEquals(expect, e.toString());
-            }
-
-        }
-    }
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java b/realm/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
deleted file mode 100644
index 97c15d84cc..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-public class TableSpecEqualityTest extends TestCase {
-
-    public void testShouldMatchIdenticalSimpleSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(ColumnType.STRING, "foo");
-        spec1.addColumn(ColumnType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(ColumnType.STRING, "foo");
-        spec2.addColumn(ColumnType.BOOLEAN, "bar");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnNames() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(ColumnType.STRING, "foo");
-        spec1.addColumn(ColumnType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(ColumnType.STRING, "foo");
-        spec2.addColumn(ColumnType.BOOLEAN, "bar2");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnTypes() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(ColumnType.STRING, "foo");
-        spec1.addColumn(ColumnType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(ColumnType.STRING, "foo");
-        spec2.addColumn(ColumnType.BINARY, "bar");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldMatchDeepRecursiveIdenticalSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(ColumnType.STRING, "foo");
-        spec1.addColumn(ColumnType.TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(ColumnType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(ColumnType.TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(ColumnType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(ColumnType.STRING, "foo");
-        spec2.addColumn(ColumnType.TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(ColumnType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(ColumnType.TABLE, "sub");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(ColumnType.BOOLEAN, "b");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldNotMatchDeepRecursiveDifferentSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(ColumnType.STRING, "foo");
-        spec1.addColumn(ColumnType.TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(ColumnType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(ColumnType.TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(ColumnType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(ColumnType.STRING, "foo");
-        spec2.addColumn(ColumnType.TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(ColumnType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(ColumnType.TABLE, "sub2");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(ColumnType.BOOLEAN, "b");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/CodeGenTest.java b/realm/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
deleted file mode 100644
index 67ff1e5b76..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package io.realm.internal.test;
-
-import io.realm.internal.DefineTable;
-
-/**
- * A helper class containing model(s) for simple code generation tests.
- */
-class CodeGenTest {
-
-    @DefineTable // this is enabled only for occasional local tests
-    class someModel {
-        String name;
-        int age;
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java b/realm/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
deleted file mode 100644
index 345f3cce7e..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package io.realm.internal.test;
-
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-
-public class DataProviderUtil {
-
-    public static Iterator<Object[]> allCombinations(List<?>... lists) {
-        Iterator<Object[]> iterator = new VariationsIterator<Object>(Arrays.asList(lists));
-        return iterator;
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/MixedData.java b/realm/src/androidTest/java/io/realm/internal/test/MixedData.java
deleted file mode 100644
index d261cddb92..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/test/MixedData.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package io.realm.internal.test;
-
-import io.realm.internal.ColumnType;
-
-public class MixedData {
-
-    public ColumnType type;
-
-    public Object value;
-
-    public MixedData(ColumnType type, Object value) {
-        this.type = type;
-        this.value = value;
-    }
-
-    @Override
-    public String toString() {
-        return "MixedData [type=" + type + ", value=" + value + "]";
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/PhoneData.java b/realm/src/androidTest/java/io/realm/internal/test/PhoneData.java
deleted file mode 100644
index 5815f783ab..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/test/PhoneData.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package io.realm.internal.test;
-
-public class PhoneData {
-
-    public String type;
-    public String number;
-
-    public PhoneData(String type, String number) {
-        this.type = type;
-        this.number = number;
-    }
-
-}
diff --git a/realm/src/androidTest/java/io/realm/internal/test/TestHelper.java b/realm/src/androidTest/java/io/realm/internal/test/TestHelper.java
deleted file mode 100644
index fa2884058e..0000000000
--- a/realm/src/androidTest/java/io/realm/internal/test/TestHelper.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package io.realm.internal.test;
-
-import java.util.Date;
-
-import io.realm.Realm;
-import io.realm.entities.AllTypes;
-import io.realm.internal.ColumnType;
-import io.realm.internal.Table;
-
-
-/**
- * Class holds helper methods for the test cases
- *
- */
-public class TestHelper {
-
-
-    /**
-     * Returns the corresponding column type for an object.
-     * @param o
-     * @return
-     */
-    public static ColumnType getColumnType(Object o){
-
-        if (o instanceof Boolean)
-            return ColumnType.BOOLEAN;
-        if (o instanceof String)
-            return ColumnType.STRING;
-        if (o instanceof Long)
-            return ColumnType.INTEGER;
-        if (o instanceof Float)
-            return ColumnType.FLOAT;
-        if (o instanceof Double)
-            return ColumnType.DOUBLE;
-        if (o instanceof Date)
-            return ColumnType.DATE;
-        if (o instanceof byte[])
-            return ColumnType.BINARY;
-
-        return ColumnType.MIXED;
-    }
-
-
-    /**
-     * Creates an empty table with 1 column of all our supported column types, currently 9 columns
-     * @return
-     */
-    public static Table getTableWithAllColumnTypes(){
-
-        Table t = new Table();
-
-        t.addColumn(ColumnType.BINARY, "binary");
-        t.addColumn(ColumnType.BOOLEAN, "boolean");
-        t.addColumn(ColumnType.DATE, "date");
-        t.addColumn(ColumnType.DOUBLE, "double");
-        t.addColumn(ColumnType.FLOAT, "float");
-        t.addColumn(ColumnType.INTEGER, "long");
-        t.addColumn(ColumnType.MIXED, "mixed");
-        t.addColumn(ColumnType.STRING, "string");
-        t.addColumn(ColumnType.TABLE, "table");
-
-        return t;
-    }
-
-    public static void populateForMultiSort(Realm testRealm) {
-        testRealm.beginTransaction();
-        testRealm.clear(AllTypes.class);
-        AllTypes object1 = testRealm.createObject(AllTypes.class);
-        object1.setColumnLong(5);
-        object1.setColumnString("Adam");
-
-        AllTypes object2 = testRealm.createObject(AllTypes.class);
-        object2.setColumnLong(4);
-        object2.setColumnString("Brian");
-
-        AllTypes object3 = testRealm.createObject(AllTypes.class);
-        object3.setColumnLong(4);
-        object3.setColumnString("Adam");
-        testRealm.commitTransaction();
-    }
-}
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
deleted file mode 100644
index 890f6f77e1..0000000000
--- a/realm/src/main/java/io/realm/Realm.java
+++ /dev/null
@@ -1,1672 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.JsonReader;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.lang.ref.WeakReference;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Scanner;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
-import io.realm.exceptions.RealmMigrationNeededException;
-import io.realm.internal.ColumnIndices;
-import io.realm.internal.ColumnType;
-import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.Row;
-import io.realm.internal.SharedGroup;
-import io.realm.internal.Table;
-import io.realm.internal.TableView;
-import io.realm.internal.android.DebugAndroidLogger;
-import io.realm.internal.android.ReleaseAndroidLogger;
-import io.realm.internal.log.RealmLog;
-import io.realm.internal.modules.FilterableMediator;
-
-
-/**
- * The Realm class is the storage and transactional manager of your object persistent store. It
- * is in charge of creating instances of your RealmObjects. Objects within a Realm can be queried
- * and read at any time. Creating, modifying, and deleting objects must be done while inside a
- * transaction. See {@link #beginTransaction()}
- * <p>
- * The transactions ensure that multiple instances (on multiple threads) can access the same
- * objects in a consistent state with full ACID guarantees.
- * <p>
- * It is important to remember to call the {@link #close()} method when done with a Realm
- * instance. Failing to do so can lead to {@link java.lang.OutOfMemoryError} as the native
- * resources cannot be freed.
- * <p>
- * Realm instances cannot be used across different threads. This means that you have to open an
- * instance on each thread you want to use Realm. Realm instances are cached automatically per
- * thread using reference counting, so as long as the reference count doesn't reach zero, calling
- * {@link #getInstance(android.content.Context)} will just return the cached Realm and should be
- * considered a lightweight operation.
- * <p>
- * For the UI thread this means that opening and closing Realms should occur in either
- * onCreate/onDestroy or onStart/onStop.
- * <p>
- * Realm instances coordinate their state across threads using the {@link android.os.Handler}
- * mechanism. This also means that Realm instances on threads without a {@link android.os.Looper}
- * cannot receive updates unless {@link #refresh()} is manually called.
- * <p>
- * A standard pattern for working with Realm in Android activities can be seen below:
- * <p>
- * <pre>
- * public class RealmActivity extends Activity {
- *
- *   private Realm realm;
- *
- *   \@Override
- *   protected void onCreate(Bundle savedInstanceState) {
- *     super.onCreate(savedInstanceState);
- *     setContentView(R.layout.layout_main);
- *     realm = Realm.getInstance(this);
- *   }
- *
- *   \@Override
- *   protected void onDestroy() {
- *     super.onDestroy();
- *     realm.close();
- *   }
- * }
- * </pre>
- * <p>
- * Realm supports String and byte fields containing up to 16 MB.
- * <p>
- * @see <a href="http://en.wikipedia.org/wiki/ACID">ACID</a>
- * @see <a href="https://github.com/realm/realm-java/tree/master/examples">Examples using Realm</a>
- */
-public final class Realm implements Closeable {
-    public static final String DEFAULT_REALM_NAME = "default.realm";
-
-    private static final String TAG = "REALM";
-    private static final String TABLE_PREFIX = "class_";
-    protected static final ThreadLocal<Map<String, Realm>> realmsCache = new ThreadLocal<Map<String, Realm>>() {
-        @SuppressLint("UseSparseArrays")
-        @Override
-        protected Map<String, Realm> initialValue() {
-            return new HashMap<String, Realm>(); // On Android we could use SparseArray<Realm> which is faster,
-                                                  // but incompatible with Java
-        }
-    };
-    private static final ThreadLocal<Map<String, Integer>> referenceCount = new ThreadLocal<Map<String,Integer>>() {
-        @SuppressLint("UseSparseArrays")
-        @Override
-        protected Map<String, Integer> initialValue() {
-            return new HashMap<String, Integer>();
-        }
-    };
-    private static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
-    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
-
-    // Maps ids to a boolean set to true if the Realm is open. This is only needed by deleteRealmFile
-    private static final Map<String, AtomicInteger> openRealms = new ConcurrentHashMap<String, AtomicInteger>();
-    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
-    private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
-    private static final String INVALID_KEY_MESSAGE = "The provided key is invalid. It should either be null or be 64" +
-            " bytes long.";
-    private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
-
-    @SuppressWarnings("UnusedDeclaration")
-    private static SharedGroup.Durability defaultDurability = SharedGroup.Durability.FULL;
-    private boolean autoRefresh;
-    private Handler handler;
-
-    private final byte[] key;
-    private final String canonicalPath;
-    private SharedGroup sharedGroup;
-    private final ImplicitTransaction transaction;
-
-    private final List<WeakReference<RealmChangeListener>> changeListeners =
-            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
-    private static RealmProxyMediator proxyMediator = getDefaultMediator();
-
-    private static final long UNVERSIONED = -1;
-
-    final ColumnIndices columnIndices = new ColumnIndices();
-
-    static {
-        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
-    }
-
-    protected void checkIfValid() {
-        // Check if the Realm instance has been closed
-        if (sharedGroup == null) {
-            throw new IllegalStateException(CLOSED_REALM_MESSAGE);
-        }
-
-        // Check if we are in the right thread
-        Realm currentRealm = realmsCache.get().get(canonicalPath);
-        if (currentRealm != this) {
-            throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
-        }
-    }
-
-    // The constructor in private to enforce the use of the static one
-    private Realm(String canonicalPath, byte[] key, boolean autoRefresh) {
-        if (key != null && key.length != 64) {
-            throw new IllegalArgumentException(INVALID_KEY_MESSAGE);
-        }
-        this.sharedGroup = new SharedGroup(canonicalPath, true, key);
-        this.transaction = sharedGroup.beginImplicitTransaction();
-        this.canonicalPath = canonicalPath;
-        this.key = key;
-        setAutoRefresh(autoRefresh);
-    }
-
-    @Override
-    protected void finalize() throws Throwable {
-        if (sharedGroup != null) {
-            RealmLog.w("Remember to call close() on all Realm instances. " +
-                            "Realm " + canonicalPath + " is being finalized without being closed, " +
-                            "this can lead to running out of native memory."
-            );
-        }
-        super.finalize();
-    }
-
-    /**
-     * Closes the Realm instance and all its resources.
-     * <p>
-     * It's important to always remember to close Realm instances when you're done with it in order 
-     * not to leak memory, file descriptors or grow the size of Realm file out of measure.
-     */
-    @Override
-    public void close() {
-        Map<String, Integer> localRefCount = referenceCount.get();
-        Integer references = localRefCount.get(canonicalPath);
-        if (references == null) {
-            references = 0;
-        }
-        if (sharedGroup != null && references == 1) {
-            realmsCache.get().remove(canonicalPath);
-            sharedGroup.close();
-            sharedGroup = null;
-            AtomicInteger counter = openRealms.get(canonicalPath);
-            counter.decrementAndGet();
-        }
-
-        int refCount = references - 1;
-        if (refCount < 0) {
-            RealmLog.w("Calling close() on a Realm that is already closed: " + canonicalPath);
-        }
-        localRefCount.put(canonicalPath, Math.max(0, refCount));
-
-        if (handler != null && refCount <= 0) {
-            removeHandler(handler);
-        }
-    }
-
-    private void removeHandler(Handler handler) {
-        handler.removeCallbacksAndMessages(null);
-        handlers.remove(handler);
-    }
-
-    private static RealmProxyMediator getDefaultMediator() {
-        Class<?> clazz;
-        try {
-            clazz = Class.forName("io.realm.DefaultRealmModuleMediator");
-            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
-            constructor.setAccessible(true);
-            return (RealmProxyMediator) constructor.newInstance();
-        } catch (ClassNotFoundException e) {
-            throw new RealmException("Could not find io.realm.DefaultRealmModuleMediator", e);
-        } catch (InvocationTargetException e) {
-            throw new RealmException("Could not create an instance of io.realm.DefaultRealmModuleMediator", e);
-        } catch (InstantiationException e) {
-            throw new RealmException("Could not create an instance of io.realm.DefaultRealmModuleMediator", e);
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not create an instance of io.realm.DefaultRealmModuleMediator", e);
-        }
-    }
-
-    private class RealmCallback implements Handler.Callback {
-        @Override
-        public boolean handleMessage(Message message) {
-            if (message.what == REALM_CHANGED) {
-                transaction.advanceRead();
-                sendNotifications();
-            }
-            return true;
-        }
-    }
-
-    /**
-     * Retrieve the auto-refresh status of the Realm instance.
-     * @return the auto-refresh status
-     */
-    public boolean isAutoRefresh() {
-        return autoRefresh;
-    }
-
-    /**
-     * Set the auto-refresh status of the Realm instance.
-     * <p>
-     * Auto-refresh is a feature that enables automatic update of the current realm instance and all its derived objects
-     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in another thread.
-     * This feature is only available if the realm instance lives is a {@link android.os.Looper} enabled thread.
-     *
-     * @param autoRefresh true will turn auto-refresh on, false will turn it off.
-     * @throws java.lang.IllegalStateException if trying to enable auto-refresh in a thread without Looper.
-     */
-    public void setAutoRefresh(boolean autoRefresh) {
-        if (autoRefresh && Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
-        }
-
-        if (autoRefresh && !this.autoRefresh) { // Switch it on
-            handler = new Handler(new RealmCallback());
-            handlers.put(handler, canonicalPath);
-        } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
-            removeHandler(handler);
-        }
-        this.autoRefresh = autoRefresh;
-    }
-
-    // Public because of migrations
-    public Table getTable(Class<? extends RealmObject> clazz) {
-        Class<?> superclass = clazz.getSuperclass();
-        if (!superclass.equals(RealmObject.class)) {
-            clazz = (Class<? extends RealmObject>) superclass;
-        }
-        return transaction.getTable(proxyMediator.getTableName(clazz));
-    }
-
-    /**
-     * Realm static constructor for the default realm "default.realm".
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context an Android {@link android.content.Context}
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    public static Realm getInstance(Context context) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context  an Android {@link android.content.Context}
-     * @param fileName the name of the file to save the Realm to
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(Context context, String fileName) {
-        return Realm.getInstance(context, fileName, null);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(Context context, byte[] key) {
-        return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(Context context, String fileName, byte[] key) {
-        return Realm.create(context.getFilesDir(), fileName, key);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writeableFolder a File object representing a writeable folder
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder) {
-        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, null);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()}
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writeableFolder a File object representing a writeable folder
-     * @param fileName the name of the Realm file
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, String fileName) {
-        return Realm.create(writeableFolder, fileName, null);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writeableFolder a File object representing a writeable folder
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, byte[] key) {
-        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, key);
-    }
-
-    /**
-     * Realm static constructor.
-     * {@link #close()} must be called when you are done using the Realm instance.
-     * <p>
-     * It sets auto-refresh on if the current thread has a Looper, off otherwise.
-     *
-     * @param writeableFolder a File object representing a writeable folder
-     * @param fileName the name of the Realm file
-     * @param key     a 64-byte encryption key
-     * @return an instance of the Realm class
-     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
-     *                                       must be migrated
-     * @throws RealmIOException              Error when accessing underlying file
-     * @throws RealmException                Other errors
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, String fileName, byte[] key) {
-        return Realm.create(writeableFolder, fileName, key);
-    }
-
-    private static Realm create(File writableFolder, String filename, byte[] key) {
-        checkValidRealmPath(writableFolder, filename);
-        String canonicalPath = getCanonicalPath(new File(writableFolder, filename));
-        if (Looper.myLooper() != null) {
-            return createAndValidate(canonicalPath, key, true, true);
-        } else {
-            return createAndValidate(canonicalPath, key, true, false);
-        }
-    }
-
-    private static synchronized Realm createAndValidate(String canonicalPath, byte[] key, boolean validateSchema,
-                                                        boolean autoRefresh) {
-        // Check thread local cache for existing Realm
-        String id = canonicalPath;
-        Map<String, Integer> localRefCount = referenceCount.get();
-        Integer references = localRefCount.get(id);
-        if (references == null) {
-            references = 0;
-        }
-        Map<String, Realm> realms = realmsCache.get();
-        Realm realm = realms.get(id);
-        if (realm != null) {
-            if (!Arrays.equals(realm.key, key)) {
-                throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
-            }
-            localRefCount.put(id, references + 1);
-            return realm;
-        }
-
-        // Create new Realm and cache it. All exception code paths must close the Realm otherwise
-        // we risk serving faulty cache data.
-        realm = new Realm(canonicalPath, key, autoRefresh);
-        realms.put(id, realm);
-        realmsCache.set(realms);
-        localRefCount.put(id, references + 1);
-
-        // Increment global reference counter
-        if (references == 0) {
-            AtomicInteger counter = openRealms.get(id);
-            if (counter == null) {
-                openRealms.put(id, new AtomicInteger(1));
-            } else {
-                counter.incrementAndGet();
-            }
-        }
-
-        // Initialize Realm schema if needed
-        if (validateSchema) {
-            try {
-                initializeRealm(realm);
-            } catch (RuntimeException e) {
-                realm.close();
-                throw e;
-            }
-        }
-
-        return realm;
-    }
-
-    private static void checkValidRealmPath(File writableFolder, String filename) {
-        if (filename == null || filename.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty filename must be provided");
-        }
-        if (writableFolder == null || !writableFolder.isDirectory()) {
-            throw new IllegalArgumentException(("An existing folder must be provided. Yours was " + (writableFolder != null ? writableFolder.getAbsolutePath() : "null")));
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private static void initializeRealm(Realm realm) {
-        long version = realm.getVersion();
-        boolean commitNeeded = false;
-        try {
-            realm.beginTransaction();
-            if (version == UNVERSIONED) {
-                realm.setVersion(0);
-                commitNeeded = true;
-            }
-
-            for (Class<? extends RealmObject> modelClass : proxyMediator.getModelClasses()) {
-                String modelClassName = modelClass.getSimpleName();
-
-                // Create and validate table
-                if (version == UNVERSIONED) {
-                    proxyMediator.createTable(modelClass, realm.transaction);
-                }
-                proxyMediator.validateTable(modelClass, realm.transaction);
-                realm.columnIndices.addClass(modelClass, proxyMediator.getColumnIndices(modelClass));
-            }
-        } finally {
-            if (commitNeeded) {
-                realm.commitTransaction();
-            } else {
-                realm.cancelTransaction();
-            }
-        }
-    }
-
-    /**
-     * Create a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm
-     * and unknown properties will be ignored.
-     *
-     * @param clazz Type of Realm objects to create.
-     * @param json  Array where each JSONObject must map to the specified class.
-     *
-     * @throws RealmException if mapping from JSON fails.
-     */
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json) {
-        if (clazz == null || json == null) {
-            return;
-        }
-
-        for (int i = 0; i < json.length(); i++) {
-            try {
-                proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
-            }
-        }
-    }
-
-    /**
-     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
-     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param json  Array with object data.
-     *
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     * @see #createAllFromJson(Class, org.json.JSONArray)
-     */
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, JSONArray json) {
-        if (clazz == null || json == null) {
-            return;
-        }
-        checkHasPrimaryKey(clazz);
-        for (int i = 0; i < json.length(); i++) {
-            try {
-                proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
-            } catch (Exception e) {
-                throw new RealmException("Could not map Json", e);
-            }
-        }
-    }
-
-    /**
-     * Create a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm
-     * and unknown properties will be ignored.
-     *
-     * @param clazz Type of Realm objects to create.
-     * @param json  JSON array as a String where each object can map to the specified class.
-     *
-     * @throws RealmException if mapping from JSON fails.
-     */
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, String json) {
-        if (clazz == null || json == null || json.length() == 0) {
-            return;
-        }
-
-        JSONArray arr;
-        try {
-            arr = new JSONArray(json);
-        } catch (Exception e) {
-            throw new RealmException("Could not create JSON array from string", e);
-        }
-
-        createAllFromJson(clazz, arr);
-    }
-
-    /**
-     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
-     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param json  String with an array of JSON objects.
-     *
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     * @see #createAllFromJson(Class, String)
-     */
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
-        if (clazz == null || json == null || json.length() == 0) {
-            return;
-        }
-        checkHasPrimaryKey(clazz);
-
-        JSONArray arr;
-        try {
-            arr = new JSONArray(json);
-        } catch (JSONException e) {
-            throw new RealmException("Could not create JSON array from string", e);
-        }
-
-        createOrUpdateAllFromJson(clazz, arr);
-    }
-
-    /**
-     * Create a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm
-     * and unknown properties will be ignored.
-     *
-     * @param clazz         Type of Realm objects created.
-     * @param inputStream   JSON array as a InputStream. All objects in the array must be of the
-     *                      specified class.
-     *
-     * @throws RealmException if mapping from JSON fails.
-     * @throws IOException if something was wrong with the input stream.
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
-        if (clazz == null || inputStream == null) {
-            return;
-        }
-
-        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
-        try {
-            reader.beginArray();
-            while (reader.hasNext()) {
-                proxyMediator.createUsingJsonStream(clazz, this, reader);
-            }
-            reader.endArray();
-        } finally {
-            reader.close();
-        }
-    }
-
-    /**
-     * Tries to update a list of existing objects identified by their primary key with new JSON data. If an existing
-     * object could not be found in the Realm, a new object will be created. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param in    InputStream with a list of object data in JSON format.
-     *
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
-        if (clazz == null || in == null) {
-            return;
-        }
-        checkHasPrimaryKey(clazz);
-
-        // As we need the primary key value we have to first parse the entire input stream as in the general
-        // case that value might be the last property :(
-        Scanner scanner = null;
-        try {
-            scanner = getFullStringScanner(in);
-            JSONArray json = new JSONArray(scanner.next());
-            for (int i = 0; i < json.length(); i++) {
-                proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
-            }
-        } catch (JSONException e) {
-            throw new RealmException("Failed to read JSON", e);
-        } finally {
-            if (scanner != null) {
-                scanner.close();
-            }
-        }
-    }
-
-    /**
-     * Create a Realm object prefilled with data from a JSON object. This must be done inside a
-     * transaction. JSON properties with a null value will map to the default value for the data
-     * type in Realm and unknown properties will be ignored.
-     *
-     * @param clazz Type of Realm object to create.
-     * @param json  JSONObject with object data.
-     * @return Created object or null if no json data was provided.
-     *
-     * @throws RealmException if the mapping from JSON fails.
-     * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
-     */
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, JSONObject json) {
-        if (clazz == null || json == null) {
-            return null;
-        }
-
-        try {
-            return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json, false);
-        } catch (Exception e) {
-            throw new RealmException("Could not map Json", e);
-        }
-    }
-
-    /**
-     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
-     * found a new object will be saved in the Realm. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param json  {@link org.json.JSONObject} with object data.
-     * @return Created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     * @see #createObjectFromJson(Class, org.json.JSONObject)
-     */
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
-        if (clazz == null || json == null) {
-            return null;
-        }
-        checkHasPrimaryKey(clazz);
-        try {
-            return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json, true);
-        } catch (JSONException e) {
-            throw new RealmException("Could not map Json", e);
-        }
-    }
-
-    /**
-     * Create a Realm object prefilled with data from a JSON object. This must be done inside a
-     * transaction. JSON properties with a null value will map to the default value for the data
-     * type in Realm and unknown properties will be ignored.
-     *
-     * @param clazz Type of Realm object to create.
-     * @param json  JSON string with object data.
-     * @return Created object or null if json string was empty or null.
-     *
-     * @throws RealmException if mapping to json failed.
-     */
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, String json) {
-        if (clazz == null || json == null || json.length() == 0) {
-            return null;
-        }
-
-        JSONObject obj;
-        try {
-            obj = new JSONObject(json);
-        } catch (Exception e) {
-            throw new RealmException("Could not create Json object from string", e);
-        }
-
-        return createObjectFromJson(clazz, obj);
-    }
-
-    /**
-     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
-     * found a new object will be saved in the Realm. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param json  String with object data in JSON format.
-     * @return Created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     *
-     * @see #createObjectFromJson(Class, String) 
-     */
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
-        if (clazz == null || json == null || json.length() == 0) {
-            return null;
-        }
-        checkHasPrimaryKey(clazz);
-
-        JSONObject obj;
-        try {
-            obj = new JSONObject(json);
-        } catch (Exception e) {
-            throw new RealmException("Could not create Json object from string", e);
-        }
-
-        return createOrUpdateObjectFromJson(clazz, obj);
-    }
-
-    /**
-     * Create a Realm object pre-filled with data from a JSON object. This must be done inside a
-     * transaction. JSON properties with a null value will map to the default value for the data
-     * type in Realm and unknown properties will be ignored.
-     *
-     * @param clazz         Type of Realm object to create.
-     * @param inputStream   JSON object data as a InputStream.
-     * @return Created object or null if json string was empty or null.
-     *
-     * @throws RealmException if the mapping from JSON failed.
-     * @throws IOException if something was wrong with the input stream.
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
-        if (clazz == null || inputStream == null) {
-            return null;
-        }
-
-        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
-        try {
-            return proxyMediator.createUsingJsonStream(clazz, this, reader);
-        } finally {
-            reader.close();
-        }
-    }
-
-    /**
-     * Tries to update an existing object defined by its primary key with new JSON data. If no existing object could be
-     * found a new object will be saved in the Realm. This must happen within a transaction.
-     *
-     * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param in    Inputstream with object data in JSON format.
-     * @return Created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     * {@link io.realm.annotations.PrimaryKey}.
-     * @see #createObjectFromJson(Class, java.io.InputStream)
-     */
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
-        if (clazz == null || in == null) {
-            return null;
-        }
-        checkHasPrimaryKey(clazz);
-
-        // As we need the primary key value we have to first parse the entire input stream as in the general
-        // case that value might be the last property :(
-        Scanner scanner = null;
-        try {
-            scanner = getFullStringScanner(in);
-            JSONObject json = new JSONObject(scanner.next());
-            return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json, true);
-        } catch (JSONException e) {
-            throw new RealmException("Failed to read JSON", e);
-        } finally {
-            if (scanner != null) {
-                scanner.close();
-            }
-        }
-    }
-
-    private Scanner getFullStringScanner(InputStream in) {
-        return new Scanner(in, "UTF-8").useDelimiter("\\A");
-    }
-
-    /**
-     * Write a compacted copy of the Realm to the given destination File.
-     * <p>
-     * The destination file cannot already exist.
-     * <p>
-     * Note that if this is called from within a write transaction it writes the
-     * current data, and not the data as it was when the last write transaction was committed.
-     *
-     * @param destination File to save the Realm to
-     * @throws java.io.IOException if any write operation fails
-     */
-    public void writeCopyTo(File destination) throws IOException {
-        writeEncryptedCopyTo(destination, null);
-    }
-
-    /**
-     * Write a compacted and encrypted copy of the Realm to the given destination File.
-     * <p>
-     * The destination file cannot already exist.
-     * <p>
-     * Note that if this is called from within a write transaction it writes the
-     * current data, and not the data as it was when the last write transaction was committed.
-     * <p>
-     * @param destination File to save the Realm to
-     * @throws java.io.IOException if any write operation fails
-     */
-    public void writeEncryptedCopyTo(File destination, byte[] key) throws IOException {
-        if (destination == null) {
-            throw new IllegalArgumentException("The destination argument cannot be null");
-        }
-        checkIfValid();
-        transaction.writeToFile(destination, key);
-    }
-
-
-    /**
-     * Instantiates and adds a new object to the realm
-     *
-     * @param clazz The Class of the object to create
-     * @return The new object
-     * @throws RealmException An object could not be created
-     */
-    public <E extends RealmObject> E createObject(Class<E> clazz) {
-        Table table = getTable(clazz);
-        long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
-    }
-
-    /**
-     * Creates a new object inside the Realm with the Primary key value initially set.
-     * If the value violates the primary key constraint, no object will be added and a
-     * {@link RealmException} will be thrown.
-     *
-     * @param clazz The Class of the object to create
-     * @param primaryKeyValue Value for the primary key field.
-     * @return The new object
-     * @throws {@link RealmException} if object could not be created.
-     */
-    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
-        Table table = getTable(clazz);
-        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return get(clazz, rowIndex);
-    }
-
-    void remove(Class<? extends RealmObject> clazz, long objectIndex) {
-        getTable(clazz).moveLastOver(objectIndex);
-    }
-
-    <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
-        Table table = getTable(clazz);
-        Row row = table.getRow(rowIndex);
-        E result = proxyMediator.newInstance(clazz);
-        result.row = row;
-        result.realm = this;
-        return result;
-    }
-
-    /**
-     * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
-     * will not be reflected in the Realm copy.
-     *
-     * @param object {@link io.realm.RealmObject} to copy to the Realm.
-     * @return A managed RealmObject with its properties backed by the Realm.
-     *
-     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null}.
-     */
-    public <E extends RealmObject> E copyToRealm(E object) {
-        checkNotNullObject(object);
-        return copyOrUpdate(object, false);
-    }
-
-    /**
-     * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or create
-     * a new copy if no existing object could be found.
-     *
-     * @param object    {@link io.realm.RealmObject} to copy or update.
-     * @return The new or updated RealmObject with all its properties backed by the Realm.
-     *
-     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
-     * @see #copyToRealm(RealmObject)
-     */
-    public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
-        checkNotNullObject(object);
-        checkHasPrimaryKey(object.getClass());
-        return copyOrUpdate(object, true);
-    }
-
-    /**
-     * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes
-     * to the original RealmObjects will not be reflected in the Realm copies.
-     *
-     * @param objects RealmObjects to copy to the Realm.
-     * @return A list of the the converted RealmObjects that all has their properties managed by the Realm.
-     *
-     * @throws io.realm.exceptions.RealmException if any of the objects has already been added to Realm.
-     * @throws java.lang.IllegalArgumentException if any of the elements in the input collection is {@code null}.
-     */
-    public <E extends RealmObject> List<E> copyToRealm(Iterable<E> objects) {
-        if (objects == null) {
-            return new ArrayList<E>();
-        }
-
-        ArrayList<E> realmObjects = new ArrayList<E>();
-        for (E object : objects) {
-            realmObjects.add(copyToRealm(object));
-        }
-
-        return realmObjects;
-    }
-
-    /**
-     * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or create a
-     * new copy if no existing object could be found.
-     *
-     * @param objects   List of objects to update or copy into Realm.
-     * @return A list of all the new or updated RealmObjects.
-     *
-     * @throws java.lang.IllegalArgumentException if RealmObject is {@code null} or doesn't have a Primary key defined.
-     * @see #copyToRealm(Iterable)
-     */
-    public <E extends RealmObject> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
-        if (objects == null) {
-            return new ArrayList<E>();
-        }
-
-        ArrayList<E> realmObjects = new ArrayList<E>();
-        for (E object : objects) {
-            realmObjects.add(copyToRealmOrUpdate(object));
-        }
-
-        return realmObjects;
-    }
-
-    private static String getProxyClassName(String simpleClassName) {
-        return "io.realm." + simpleClassName + "RealmProxy";
-    }
-
-    boolean contains(Class<? extends RealmObject> clazz) {
-        return proxyMediator.getModelClasses().contains(clazz);
-    }
-
-    /**
-     * Returns a typed RealmQuery, which can be used to query for specific objects of this type
-     *
-     * @param clazz The class of the object which is to be queried for
-     * @return A typed RealmQuery, which can be used to query for specific objects of this type
-     * @throws java.lang.RuntimeException Any other error
-     * @see io.realm.RealmQuery
-     */
-    public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz) {
-        checkIfValid();
-        return new RealmQuery<E>(this, clazz);
-    }
-
-    /**
-     * Get all objects of a specific Class. If no objects exist, the returned RealmResults will not
-     * be null. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of
-     * @return A RealmResult list containing the objects
-     * @throws java.lang.RuntimeException Any other error
-     * @see io.realm.RealmResults
-     */
-    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz) {
-        return where(clazz).findAll();
-    }
-
-    /**
-     * Get all objects of a specific Class sorted by a field.  If no objects exist, the returned
-     * RealmResults will not be null. The RealmResults.size() to check the number of objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param fieldName the field name to sort by.
-     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
-     * @return A sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
-     */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
-                                                               boolean sortAscending) {
-        checkIfValid();
-        Table table = getTable(clazz);
-        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
-        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        TableView tableView = table.getSortedView(columnIndex, order);
-        return new RealmResults<E>(this, tableView, clazz);
-    }
-
-
-    /**
-     * Get all objects of a specific class sorted by two specific field names.  If no objects exist,
-     * the returned RealmResults will not be null. The RealmResults.size() to check the number of
-     * objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortAscending1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortAscending2 sort order for second field.
-     * @return A sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                               boolean sortAscending1, String fieldName2,
-                                                               boolean sortAscending2) {
-        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new boolean[]{sortAscending1,
-                sortAscending2});
-    }
-
-    /**
-     * Get all objects of a specific class sorted by two specific field names.  If no objects exist,
-     * the returned RealmResults will not be null. The RealmResults.size() to check the number of
-     * objects instead.
-     *
-     * @param clazz the class ti get objects of.
-     * @param fieldName1 first field name to sort by.
-     * @param sortAscending1 sort order for first field.
-     * @param fieldName2 second field name to sort by.
-     * @param sortAscending2 sort order for second field.
-     * @param fieldName3 third field name to sort by.
-     * @param sortAscending3 sort order for third field.
-     * @return A sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                               boolean sortAscending1,
-                                                              String fieldName2, boolean sortAscending2,
-                                                              String fieldName3, boolean sortAscending3) {
-        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2, fieldName3},
-                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
-    }
-
-    /**
-     * Get all objects of a specific Class sorted by multiple fields.  If no objects exist, the
-     * returned RealmResults will not be null. The RealmResults.size() to check the number of
-     * objects instead.
-     *
-     * @param clazz the Class to get objects of.
-     * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
-     * @param fieldNames an array of fieldnames to sort objects by.
-     *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
-     * @return A sorted RealmResults containing the objects.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    @SuppressWarnings("unchecked")
-    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
-                                                               boolean sortAscending[]) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames must be provided.");
-        } else if (sortAscending == null) {
-            throw new IllegalArgumentException("sortAscending must be provided.");
-        }
-
-        // Convert field names to column indices
-        Table table = this.getTable(clazz);
-        long columnIndices[] = new long[fieldNames.length];
-        for (int i = 0; i < fieldNames.length; i++) {
-            String fieldName = fieldNames[i];
-            long columnIndex = table.getColumnIndex(fieldName);
-            if (columnIndex == -1) {
-                throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-            }
-            columnIndices[i] = columnIndex;
-        }
-        
-        // Perform sort
-        TableView tableView = table.getSortedView(columnIndices, sortAscending);
-        return new RealmResults(this, tableView, clazz);
-    }
-
-    // Notifications
-
-    /**
-     * Add a change listener to the Realm
-     *
-     * @param listener the change listener
-     * @see io.realm.RealmChangeListener
-     */
-    public void addChangeListener(RealmChangeListener listener) {
-        checkIfValid();
-        for (WeakReference<RealmChangeListener> ref : changeListeners) {
-            if (ref.get() == listener) {
-                // It has already been added before
-                return;
-            }
-        }
-
-        changeListeners.add(new WeakReference<RealmChangeListener>(listener));
-    }
-
-    /**
-     * Remove the specified change listener
-     *
-     * @param listener the change listener to be removed
-     * @see io.realm.RealmChangeListener
-     */
-    public void removeChangeListener(RealmChangeListener listener) {
-        checkIfValid();
-        WeakReference<RealmChangeListener> weakRefToRemove = null;
-        for (WeakReference<RealmChangeListener> weakRef : changeListeners) {
-            if (listener == weakRef.get()) {
-                weakRefToRemove = weakRef;
-                // There won't be duplicated entries, checking is done when adding
-                break;
-            }
-        }
-        if (weakRefToRemove != null) {
-            changeListeners.remove(weakRefToRemove);
-        }
-    }
-
-    /**
-     * Remove all user-defined change listeners
-     *
-     * @see io.realm.RealmChangeListener
-     */
-    public void removeAllChangeListeners() {
-        checkIfValid();
-        changeListeners.clear();
-    }
-
-    /**
-     * Return change listeners
-     * For internal testing purpose only
-     *
-     * @return changeListeners list of this realm instance
-     */
-    protected List<WeakReference<RealmChangeListener>> getChangeListeners() {
-        return changeListeners;
-    }
-
-    void sendNotifications() {
-        Iterator<WeakReference<RealmChangeListener>> iterator = changeListeners.iterator();
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
-        while (iterator.hasNext()) {
-            WeakReference<RealmChangeListener> weakRef = iterator.next();
-            RealmChangeListener listener = weakRef.get();
-            if (listener == null) {
-                if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(changeListeners.size());
-                }
-                toRemoveList.add(weakRef);
-            } else {
-                listener.onChange();
-            }
-        }
-        if (toRemoveList != null) {
-            changeListeners.removeAll(toRemoveList);
-        }
-    }
-
-    @SuppressWarnings("UnusedDeclaration")
-    boolean hasChanged() {
-        return sharedGroup.hasChanged();
-    }
-
-    /**
-     * Transactions
-     */
-
-    /**
-     * Refresh the Realm instance and all the RealmResults and RealmObjects instances coming from it
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public void refresh() {
-        checkIfValid();
-        transaction.advanceRead();
-    }
-
-    /**
-     * Starts a write transaction, this must be closed with {@link io.realm.Realm#commitTransaction()}
-     * or aborted by {@link io.realm.Realm#cancelTransaction()}. Write transactions are used to
-     * atomically create, update and delete objects within a realm.
-     * <br>
-     * Before beginning the write transaction, {@link io.realm.Realm#beginTransaction()} updates the
-     * realm in the case of pending updates from other threads.
-     * <br>
-     * Notice: it is not possible to nest write transactions. If you start a write
-     * transaction within a write transaction an exception is thrown.
-     * <br>
-     * @throws java.lang.IllegalStateException If already in a write transaction or incorrect thread.
-     *
-     */
-    public void beginTransaction() {
-        checkIfValid();
-        transaction.promoteToWrite();
-    }
-
-    /**
-     * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the
-     * realm reverts back to being read-only. An event is sent to notify all other realm instances
-     * that a change has occurred. When the event is received, the other realms will get their
-     * objects and {@link io.realm.RealmResults} updated to reflect
-     * the changes from this commit.
-     * 
-     * @throws java.lang.IllegalStateException If the write transaction is in an invalid state or incorrect thread.
-     */
-    public void commitTransaction() {
-        checkIfValid();
-        transaction.commitAndContinueAsRead();
-
-        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
-            Handler handler = handlerIntegerEntry.getKey();
-            String realmPath = handlerIntegerEntry.getValue();
-
-            // Notify at once on thread doing the commit
-            if (handler.equals(this.handler)) {
-                sendNotifications();
-                continue;
-            }
-
-            // For all other threads, use the Handler
-            if (
-                    realmPath.equals(canonicalPath)              // It's the right realm
-                    && !handler.hasMessages(REALM_CHANGED)       // The right message
-                    && handler.getLooper().getThread().isAlive() // The receiving thread is alive
-            ) {
-                handler.sendEmptyMessage(REALM_CHANGED);
-            }
-        }
-    }
-
-    /**
-     * Revert all writes (created, updated, or deleted objects) made in the current write
-     * transaction and end the transaction.
-     * <br>
-     * The realm reverts back to read-only.
-     * <br>
-     * Calling this when not in a write transaction will throw an exception.
-     *
-     * @throws java.lang.IllegalStateException    If the write transaction is an invalid state,
-    *                                             not in a write transaction or incorrect thread.
-    */
-     public void cancelTransaction() {
-         checkIfValid();
-         transaction.rollbackAndContinueAsRead();
-     }
-
-    /**
-     * Executes a given transaction on the Realm. {@link #beginTransaction()} and
-     * {@link #commitTransaction()} will be called automatically. If any exception is thrown
-     * during the transaction {@link #cancelTransaction()} will be called instead of {@link #commitTransaction()}.
-     *
-     * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @throws RealmException if any error happened during the transaction.
-     */
-    public void executeTransaction(Transaction transaction) {
-        if (transaction == null)
-            return;
-        beginTransaction();
-        try {
-            transaction.execute(this);
-            commitTransaction();
-        } catch (RuntimeException e) {
-            cancelTransaction();
-            throw new RealmException("Error during transaction.", e);
-        } catch (Error e) {
-            cancelTransaction();
-            throw e;
-        }
-    }
-
-    /**
-     * Remove all objects of the specified class.
-     *
-     * @param clazz The class which objects should be removed
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public void clear(Class<? extends RealmObject> clazz) {
-        getTable(clazz).clear();
-    }
-
-    // Returns the Handler for this Realm on the calling thread
-    Handler getHandler() {
-        for (Map.Entry<Handler, String> entry : handlers.entrySet()) {
-            if (entry.getValue().equals(canonicalPath)) {
-                return entry.getKey();
-            }
-        }
-        return null;
-    }
-
-    // package protected so unit tests can access it
-    long getVersion() {
-        if (!transaction.hasTable("metadata")) {
-            return UNVERSIONED;
-        }
-        Table metadataTable = transaction.getTable("metadata");
-        return metadataTable.getLong(0, 0);
-    }
-
-    // package protected so unit tests can access it
-    void setVersion(long version) {
-        Table metadataTable = transaction.getTable("metadata");
-        if (metadataTable.getColumnCount() == 0) {
-            metadataTable.addColumn(ColumnType.INTEGER, "version");
-            metadataTable.addEmptyRow();
-        }
-        metadataTable.setLong(0, 0, version);
-    }
-
-    @SuppressWarnings("unchecked")
-    private <E extends RealmObject> Class<? extends RealmObject> getRealmClassFromObject(E object) {
-        if (object.realm != null) {
-            // This is already a proxy object, get superclass instead
-            // INVARIANT: We don't support subclasses yet so super class is always correct type
-            return (Class<? extends RealmObject>) object.getClass().getSuperclass();
-        } else {
-            return object.getClass();
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
-        return proxyMediator.copyOrUpdate(this, object, update, new HashMap<RealmObject, RealmObjectProxy>());
-    }
-
-    private <E extends RealmObject> void checkNotNullObject(E object) {
-        if (object == null) {
-            throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
-        }
-    }
-
-    private <E extends RealmObject> void checkHasPrimaryKey(E object) {
-        Class<? extends RealmObject> objectClass = object.getClass();
-        if (!getTable(objectClass).hasPrimaryKey()) {
-            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + objectClass.getSimpleName().toString());
-        }
-    }
-
-    private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
-        if (!getTable(clazz).hasPrimaryKey()) {
-            throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
-        }
-    }
-
-    @SuppressWarnings("UnusedDeclaration")
-    public static void migrateRealmAtPath(String realmPath, RealmMigration migration) {
-        migrateRealmAtPath(realmPath, null, migration, true);
-    }
-
-    public static void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration) {
-        migrateRealmAtPath(realmPath, key, migration, true);
-    }
-
-    public static void migrateRealmAtPath(String realmPath, RealmMigration migration, boolean autoRefresh) {
-        migrateRealmAtPath(realmPath, null, migration, autoRefresh);
-    }
-
-    public static synchronized void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration,
-                                            boolean autoUpdate) {
-        Realm realm = Realm.createAndValidate(realmPath, key, false, autoUpdate);
-        realm.beginTransaction();
-        realm.setVersion(migration.execute(realm, realm.getVersion()));
-        realm.commitTransaction();
-        realm.close();
-
-        realmsCache.remove();
-    }
-
-    /**
-     * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
-     * The Realm must be unused and closed before calling this method.
-     * WARNING: Your Realm must not be open (typically when your app launch).
-     *
-     * @param context an Android {@link android.content.Context}.
-     * @return false if a file could not be deleted. The failing file will be logged.
-     * @see io.realm.Realm#clear(Class)
-     *
-     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
-     */
-    public static boolean deleteRealmFile(Context context) {
-        return deleteRealmFile(context, DEFAULT_REALM_NAME);
-    }
-
-    /**
-     * Delete the Realm file from the filesystem for a custom named Realm.
-     * The Realm must be unused and closed before calling this method.
-     *
-     * @param context  an Android {@link android.content.Context}.
-     * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
-     * @return false if a file could not be deleted. The failing file will be logged.
-     *
-     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
-     */
-    public static boolean deleteRealmFile(Context context, String fileName) {
-        return deleteRealmFile(new File(context.getFilesDir(), fileName));
-    }
-
-    /**
-     * Delete the Realm file from the filesystem for a custom named Realm.
-     * The Realm must be unused and closed before calling this method.
-     *
-     * @param realmFile The reference to the Realm file.
-     * @return false if a file could not be deleted. The failing file will be logged.
-     *
-     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
-     */
-    public static synchronized boolean deleteRealmFile(File realmFile) {
-        boolean result = true;
-        File realmFolder = realmFile.getParentFile();
-        String fileName = realmFile.getName();
-
-        String id = getCanonicalPath(realmFile);
-        AtomicInteger counter = openRealms.get(id);
-        if (counter != null && counter.get() > 0) {
-            throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
-                    "Remember to close() all the instances of the Realm before deleting its file.");
-        }
-
-        List<File> filesToDelete = Arrays.asList(realmFile,
-                new File(realmFolder, fileName + ".lock"),
-                new File(realmFolder, fileName + ".lock_a"),
-                new File(realmFolder, fileName + ".lock_b"),
-                new File(realmFolder, fileName + ".log"));
-        for (File fileToDelete : filesToDelete) {
-            if (fileToDelete.exists()) {
-                boolean deleteResult = fileToDelete.delete();
-                if (!deleteResult) {
-                    result = false;
-                    RealmLog.w("Could not delete the file " + fileToDelete);
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Compact a Realm file. A Realm file usually contain free/unused space.
-     * This method removes this free space and the file size is thereby reduced.
-     * Objects within the Realm files are untouched.
-     * <p>
-     * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the Realm file.<br>
-     * The realm file is left untouched if any file operation fails.<br>
-     * Currently it is not possible to compact an encrypted Realm.<br>
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param fileName the name of the file to compact
-     * @param key Key for opening an encrypted Realm.
-     * @return true if successful, false if any file operation failed
-     *
-     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
-     */
-    public static synchronized boolean compactRealmFile(Context context, String fileName, byte[] key) {
-        if (key != null) {
-            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
-        }
-
-        File realmFile = new File(context.getFilesDir(), fileName);
-        String canonicalPath = getCanonicalPath(realmFile);
-        if (openRealms.get(canonicalPath).get() > 0) {
-            throw new IllegalStateException("Cannot compact an open Realm");
-        }
-        SharedGroup sharedGroup = null;
-        boolean result = false;
-        try {
-            sharedGroup = new SharedGroup(canonicalPath, false, key);
-            result = sharedGroup.compact();
-        } finally {
-            if (sharedGroup != null) {
-                sharedGroup.close();
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Compact a Realm file. A Realm file usually contain free/unused space.
-     * This method removes this free space and the file size is thereby reduced.
-     * Objects within the Realm files are untouched.
-     * <p>
-     * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the Realm file.<br>
-     * The Realm file is left untouched if any file operation fails.<br>
-     *
-     * @param context an Android {@link android.content.Context}
-     * @return true if successful, false if any file operation failed
-     *
-     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
-     */
-    public static boolean compactRealmFile(Context context) {
-        return compactRealmFile(context, DEFAULT_REALM_NAME, null);
-    }
-
-    /**
-     * Compact a Realm file. A Realm file usually contain free/unused space.
-     * This method removes this free space and the file size is thereby reduced.
-     * Objects within the Realm files are untouched.
-     * <p>
-     * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the Realm file.<br>
-     * The Realm file is left untouched if any file operation fails.<br>
-     *
-     * @param context an Android {@link android.content.Context}
-     * @param fileName the name of the file to compact
-     * @return true if successful, false if any file operation failed
-     *
-     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
-     */
-    public static synchronized boolean compactRealmFile(Context context, String fileName) {
-        return compactRealmFile(context, fileName, null);
-    }
-
-    /**
-     * Returns the canonical path to where this Realm is persisted on disk.
-     *
-     * @return The canonical path to the Realm file.
-     * @see File#getCanonicalPath()
-     */
-    public String getPath() {
-        return canonicalPath;
-    }
-
-    /**
-     * Override the standard behavior of all classes extended RealmObject being part of the schema.
-     * Use this method to define the schema as only the classes given here.
-     *
-     * This class must be called before calling {@link #getInstance(android.content.Context)}
-     *
-     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
-     *
-     */
-    @SafeVarargs
-    static void setSchema(Class<? extends RealmObject>... schemaClass) {
-        if (schemaClass != null) {
-            // Filter default schema
-            proxyMediator = new FilterableMediator(getDefaultMediator(), Arrays.asList(schemaClass));
-        } else if (proxyMediator instanceof FilterableMediator) {
-            // else reset filter if needed
-            proxyMediator = ((FilterableMediator) proxyMediator).getOriginalMediator();
-        }
-    }
-
-    static String getCanonicalPath(File realmFile) {
-        try {
-            return realmFile.getCanonicalPath();
-        } catch (IOException e) {
-            throw new RealmException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
-        }
-    }
-
-    /**
-     * Encapsulates a Realm transaction.
-     * <p>
-     * Using this class will automatically handle {@link #beginTransaction()} and {@link #commitTransaction()}
-     * If any exception is thrown during the transaction {@link #cancelTransaction()} will be called
-     * instead of {@link #commitTransaction()}.
-     */
-    public interface Transaction {
-        public void execute(Realm realm);
-    }
-}
diff --git a/realm/src/main/java/io/realm/RealmChangeListener.java b/realm/src/main/java/io/realm/RealmChangeListener.java
deleted file mode 100644
index a3487bdc83..0000000000
--- a/realm/src/main/java/io/realm/RealmChangeListener.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * Using RealmChangeListener, it is possible to be notified when a Realm instance has been updated.
- * <p>
- * Realm instances on a thread without an {@link android.os.Looper} (almost all background threads)
- * don't get updated automatically, but have to call {@link Realm#refresh()} manually. This will
- * in turn trigger the RealmChangeListener for that background thread.
- * <p>
- * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain
- * their new values when the {@link #onChange()} method is called. Normally this means that it
- * isn't necessary to query again for those objects, but just invalidate any UI elements that are
- * using them. If there is a chance that a object has been been deleted, it can be verified
- * by using {@link RealmObject#isValid()}.
- *
- * @see Realm#addChangeListener(RealmChangeListener)
- * @see Realm#removeAllChangeListeners()
- * @see Realm#removeChangeListener(RealmChangeListener)
- */
-public interface RealmChangeListener {
-
-    /**
-     * Called when a transaction is committed
-     */
-    public void onChange();
-
-}
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
deleted file mode 100644
index 26e6714a49..0000000000
--- a/realm/src/main/java/io/realm/RealmList.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import io.realm.exceptions.RealmException;
-import io.realm.internal.LinkView;
-
-/**
- * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
- * RealmList has two modes: A managed and non-managed mode. In managed mode all objects are persisted
- * inside a Realm, in non-managed mode it works as a normal ArrayList.
- * <p>
- * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the
- * content whenever the underlying Realm is updated, and can only be accessed using the getter
- * of a {@link io.realm.RealmObject}.
- * <p>
- * Non-managed RealmLists can be created by the user and can contain both managed and non-managed
- * RealmObjects. This is useful when dealing with JSON deserializers like GSON or other
- * frameworks that inject values into a class. Non-managed elements in this list can be added to a
- * Realm using the {@link Realm#copyToRealm(Iterable)} method.
- * <p>
- * @param <E> The class of objects in list.
- */
-
-public class RealmList<E extends RealmObject> extends AbstractList<E> {
-
-    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
-    private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
-    public static final String MANAGED_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmObjects already managed by Realm cannot be added to RealmList in non-managed mode.";
-
-    private final boolean managedMode;
-    private Class<E> clazz;
-    private LinkView view;
-    private Realm realm;
-    private List<E> nonManagedList;
-
-    /**
-     * Create a RealmList in non-managed mode, where the elements are not controlled by a Realm.
-     * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible
-     * to query the objects in this state.
-     * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)}  to properly persist it's elements in
-     * Realm.
-     */
-    public RealmList() {
-        managedMode = false;
-        nonManagedList = new ArrayList<E>();
-    }
-
-    /**
-     * Create a RealmList in non-managed mode with an initial list of elements.
-     * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not
-     * possible to query the objects in this state.
-     *
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements
-     * in Realm.
-     *
-     * @param objects Initial objects in the list.
-     */
-    public RealmList(E... objects) {
-        if (objects == null) {
-            throw new IllegalArgumentException("The objects argument cannot be null");
-        }
-        managedMode = false;
-        nonManagedList = new ArrayList<E>(objects.length);
-        Collections.addAll(nonManagedList, objects);
-    }
-
-    /**
-     * Creates a RealmList from a LinkView, so its elements are managed by Realm.
-     *
-     * @param clazz Type of elements in the Array
-     * @param view  Backing LinkView
-     * @param realm Reference to Realm containing the data
-     */
-    RealmList(Class<E> clazz, LinkView view, Realm realm) {
-        this.managedMode = true;
-        this.clazz = clazz;
-        this.view = view;
-        this.realm = realm;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void add(int location, E object) {
-        checkValidObject(object);
-        if (managedMode) {
-            view.insert(location, object.row.getIndex());
-        } else {
-            nonManagedList.add(location, object);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean add(E object) {
-        checkValidObject(object);
-        if (managedMode) {
-            view.add(object.row.getIndex());
-        } else {
-            nonManagedList.add(object);
-        }
-        return true;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E set(int location, E object) {
-        checkValidObject(object);
-        if (managedMode) {
-            if (object.row == null) {
-                throw new RealmException(ONLY_IN_MANAGED_MODE_MESSAGE);
-            }
-            view.set(location, object.row.getIndex());
-        } else {
-            nonManagedList.set(location, object);
-        }
-        return object;
-    }
-
-    /**
-     * Moves an object from one position to another, while maintaining a fixed sized list.
-     * RealmObjects will be shifted so no null values are introduced.
-     *
-     * @param oldPos Index of RealmObject to move.
-     * @param newPos Target position. If newPos &lt; oldPos the object at the location will be shifted
-     *               to the right. If oldPos &lt; newPos, indexes &gt; oldPos will be shifted once to the
-     *               left.
-     *
-     * @throws java.lang.IndexOutOfBoundsException if any position is outside [0, size()[.
-     */
-    public void move(int oldPos, int newPos) {
-        if (managedMode) {
-            view.move(oldPos, newPos);
-        } else {
-            checkIndex(oldPos);
-            checkIndex(newPos);
-            E object = nonManagedList.remove(oldPos);
-            if (newPos > oldPos) {
-                nonManagedList.add(newPos - 1, object);
-            } else {
-                nonManagedList.add(newPos, object);
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void clear() {
-        if (managedMode) {
-            view.clear();
-        } else {
-            nonManagedList.clear();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E remove(int location) {
-        if (managedMode) {
-            E removedItem = get(location);
-            view.remove(location);
-            return removedItem;
-        } else {
-            return nonManagedList.remove(location);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E get(int location) {
-        if (managedMode) {
-            return realm.get(clazz, view.getTargetRowIndex(location));
-        } else {
-            return nonManagedList.get(location);
-        }
-    }
-
-    /**
-     * Find the first object.
-     *
-     * @return The first object or {@code null} if the list is empty.
-     */
-    public E first() {
-        if (managedMode && !view.isEmpty()) {
-            return get(0);
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(0);
-        }
-        return null;
-    }
-
-    /**
-     * Find the last object.
-     *
-     * @return The last object or {@code null} if the list is empty.
-     */
-    public E last() {
-        if (managedMode && !view.isEmpty()) {
-            return get((int) view.size() - 1);
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(nonManagedList.size() - 1);
-        }
-        return null;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int size() {
-        if (managedMode) {
-            return ((Long)view.size()).intValue();
-        } else {
-            return nonManagedList.size();
-        }
-    }
-
-    /**
-     * Returns a RealmQuery, which can be used to query for specific objects of this class
-     *
-     * @return A RealmQuery object
-     * @see io.realm.RealmQuery
-     */
-    public RealmQuery<E> where() {
-        if (managedMode) {
-            return new RealmQuery<E>(this.realm, view, clazz);
-        } else {
-            throw new RealmException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
-    }
-
-    private void checkValidObject(E object) {
-        if (object == null) {
-            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
-        }
-    }
-
-    private void checkIndex(int location) {
-        int size = size();
-        if (location < 0 || location >= size) {
-            throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size);
-        }
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(managedMode ? clazz.getSimpleName() : getClass().getSimpleName());
-        sb.append("@[");
-        for (int i = 0; i < size(); i++) {
-            if (managedMode) {
-                sb.append(get(i).row.getIndex());
-            } else {
-                sb.append(System.identityHashCode(get(i)));
-            }
-            if (i < size() - 1) {
-                sb.append(',');
-            }
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-}
diff --git a/realm/src/main/java/io/realm/RealmMigration.java b/realm/src/main/java/io/realm/RealmMigration.java
deleted file mode 100644
index 5e1843acff..0000000000
--- a/realm/src/main/java/io/realm/RealmMigration.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * The RealmMigration class is used to describe the migration of one Realm schema to another.
- * The schema for a Realm is defined by all classes in a project that extend
- * {@link io.realm.RealmObject}, so any changes to these classes will require a migration.
- *
- * To support migrations from any previous version to the newest, the following pattern is
- * recommended when writing a migration:
- *
- * <pre>
- * public class CustomMigration implements RealmMigration {
- *   \@Override
- *   public long execute(Realm realm, long version) {
- *     if (version == 0) {
- *       // Migrate from v0 to v1
- *       version++;
- *     }
- *
- *     if (version == 0) {
- *       // Migrate from v0 to v1
- *       version++;
- *     }
- *
- *     return version;
- *   }
- * }
- * </pre>
- *
- * During development when model classes can change frequently, it is possible to use
- * {@link io.realm.Realm#deleteRealmFile(android.content.Context)}. This will delete the database
- * file and eliminate the need for any migrations.
- *
- * @see Realm#migrateRealmAtPath(String, byte[], RealmMigration)
- * @see Realm#migrateRealmAtPath(String, RealmMigration)
- */
-public interface RealmMigration {
-
-    /**
-     * Implement this method in your subclass to perform migration.
-     *
-     * @param realm The Realm on which to perform the migration.
-     * @param version The version of the Realm at the start of the migration.
-     * @return The version of the Realm after executing the migration.
-     */
-    public long execute(Realm realm, long version);
-}
-
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
deleted file mode 100644
index f65e78633a..0000000000
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import io.realm.annotations.RealmClass;
-import io.realm.internal.Row;
-
-/**
- * In Realm you define your model classes by sub-classing RealmObject and adding fields to be
- * persisted. You then create your objects within a Realm, and use your custom subclasses instead
- * of using the RealmObject class directly.
- * <p>
- * An annotation processor will create a proxy class for your RealmObject subclass. The getters and
- * setters should not contain any custom code of logic as they are overridden as part of the annotation
- * process.
- * <p>
- * A RealmObject is currently limited to the following:
- *
- * <ul>
- *   <li>Private fields.</li>
- *   <li>Getter and setters for these fields.</li>
- *   <li>Static methods.</li>
- * </ul>
- * <p>
- * The following field data types are supported (no boxed types):
- * <ul>
- *   <li>boolean</li>
- *   <li>short</li>
- *   <li>int</li>
- *   <li>long</li>
- *   <li>float</li>
- *   <li>double</li>
- *   <li>byte[]</li>
- *   <li>String</li>
- *   <li>Date</li>
- *   <li>Any RealmObject subclass</li>
- *   <li>RealmList</li>
- * </ul>
- * <p>
- * The types <code>short</code>, <code>int</code>, and <code>long</code> are mapped to <code>long</code>
- * when storing within a Realm.
- * <p>
- * Getter and setter names must have the name {@code getXXX} or {@code setXXX} if
- * the field name is {@code XXX}. Getters for fields of type boolean can be called {@code isXXX} as
- * well. Fields with a m-prefix must have getters and setters named setmXXX and getmXXX which is
- * the default behavior when Android Studio automatically generates the getters and setters.
- * <p>
- * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and
- * don't require either a getter or setter.
- * <p>
- * Realm will create indexes for fields annotated with {@link io.realm.annotations.Index}. This
- * will speedup queries but will have a negative impact on inserts and updates.
- * * <p>
- * A RealmObject cannot be passed between different threads.
- *
- * @see Realm#createObject(Class)
- * @see Realm#copyToRealm(RealmObject)
- */
-
-@RealmClass
-public abstract class RealmObject {
-
-    protected Row row;
-    protected Realm realm;
-
-    /**
-     * Removes the object from the Realm it is currently associated to.
-     * <p>
-     * After this method is called the object will be invalid and any operation (read or write)
-     * performed on it will fail with an IllegalStateException
-     */
-    public void removeFromRealm() {
-        if (row == null) {
-            throw new IllegalStateException("Object malformed: missing object in Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
-        }
-        if (realm == null) {
-            throw new IllegalStateException("Object malformed: missing Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
-        }
-        row.getTable().moveLastOver(row.getIndex());
-    }
-
-    /**
-     * Check if the RealmObject is still valid to use ie. the RealmObject hasn't been deleted nor
-     * has the {@link io.realm.Realm} been closed. It will always return false for stand alone
-     * objects.
-     *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a
-     * standalone object.
-     */
-    public boolean isValid() {
-        return row != null && row.isAttached();
-    }
-}
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
deleted file mode 100644
index df847f5e69..0000000000
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ /dev/null
@@ -1,1305 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import io.realm.internal.ColumnType;
-import io.realm.internal.LinkView;
-import io.realm.internal.Table;
-import io.realm.internal.TableQuery;
-import io.realm.internal.TableView;
-
-/**
- * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults}
- * using the Builder pattern. The query is executed using either {@link #findAll()} or
- * {@link #findFirst()}
- * <p>
- * The input to many of the query functions take a field name as String. Note that this is not
- * type safe. If a model class is refactored care has to be taken to not break any queries.
- * <p>
- * A {@link io.realm.Realm} is unordered, which means that there is no guarantee that querying a
- * Realm will return the objects in the order they where inserted. Use
- * {@link #findAllSorted(String)} and similar methods if a specific order is required.
- * <p>
- * A RealmQuery cannot be passed between different threads.
- *
- * @param <E> The class of the objects to be queried.
- * @see <a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder pattern</a>
- * @see Realm#where(Class)
- * @see RealmResults#where()
- */
-public class RealmQuery<E extends RealmObject> {
-
-    private Realm realm;
-    private Table table;
-    private LinkView view;
-    private TableQuery query;
-    private Map<String, Long> columns = new HashMap<String, Long>();
-    private Class<E> clazz;
-
-    private static final String LINK_NOT_SUPPORTED_METHOD = "'%s' is not supported for link queries";
-
-    public static final boolean CASE_SENSITIVE = true;
-    public static final boolean CASE_INSENSITIVE = false;
-
-    /**
-     * Creating a RealmQuery instance.
-     *
-     * @param realm  The realm to query within.
-     * @param clazz  The class to query.
-     * @throws java.lang.RuntimeException Any other error.
-     */
-    public RealmQuery(Realm realm, Class<E> clazz) {
-        this.realm = realm;
-        this.clazz = clazz;
-        this.table = realm.getTable(clazz);
-        this.query = table.where();
-        this.columns = realm.columnIndices.getClassFields(clazz);
-    }
-
-    /**
-     * Create a RealmQuery instance from a @{link io.realm.RealmResults}.
-     *
-     * @param realmList   The @{link io.realm.RealmResults} to query
-     * @param clazz       The class to query
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery(RealmResults realmList, Class<E> clazz) {
-        this.realm = realmList.getRealm();
-        this.clazz = clazz;
-        this.table = realm.getTable(clazz);
-        this.query = realmList.getTable().where();
-        this.columns = realm.columnIndices.getClassFields(clazz);
-    }
-
-    RealmQuery(Realm realm, LinkView view, Class<E> clazz) {
-        this.realm = realm;
-        this.clazz = clazz;
-        this.query = view.where();
-        this.view = view;
-        this.table = realm.getTable(clazz);
-        this.columns = realm.columnIndices.getClassFields(clazz);
-    }
-
-    private boolean containsDot(String s) {
-        return s.indexOf('.') != -1;
-    }
-
-    private String[] splitString(String s) {
-        int i, j, n;
-
-        // count the number of .
-        n = 0;
-        for (i = 0; i < s.length(); i++)
-            if (s.charAt(i) == '.')
-                n++;
-
-        // split at .
-        String[] arr = new String[n+1];
-        i = 0;
-        n = 0;
-        j = s.indexOf('.');
-        while (j != -1) {
-            arr[n] = s.substring(i, j);
-            i = j+1;
-            j = s.indexOf('.', i);
-            n++;
-        }
-        arr[n] = s.substring(s.lastIndexOf('.')+1);
-
-        return arr;
-    }
-
-    // TODO: consider another caching strategy so linked classes are included in the cache.
-    private long[] getColumnIndices(String fieldName, ColumnType fieldType) {
-        Table table = this.table;
-        if (containsDot(fieldName)) {
-            String[] names = splitString(fieldName); //fieldName.split("\\.");
-            long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length-1; i++) {
-                long index = table.getColumnIndex(names[i]);
-                if (index < 0) {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-                ColumnType type = table.getColumnType(index);
-                if (type == ColumnType.LINK || type == ColumnType.LINK_LIST) {
-                    table = table.getLinkTarget(index);
-                    columnIndices[i] = index;
-                } else {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-            }
-            columnIndices[names.length-1] = table.getColumnIndex(names[names.length-1]);
-            if (fieldType != table.getColumnType(columnIndices[names.length-1])) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length-1]));
-            }
-            return columnIndices;
-        } else {
-            if (columns.get(fieldName) == null) {
-                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
-            }
-
-            ColumnType tableColumnType = table.getColumnType(columns.get(fieldName));
-            if (fieldType != tableColumnType) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch. Was %s, expected %s.",
-                        fieldName, fieldType, tableColumnType
-                ));
-            }
-            return new long[] {columns.get(fieldName)};
-        }
-    }
-
-    /**
-     * Test if a field is null. Only works for relationships and RealmLists.
-     *
-     * @param fieldName - the field name
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
-     */
-    public RealmQuery<E> isNull(String fieldName) {
-        // Currently we only support querying top-level
-        if (containsDot(fieldName)) {
-            throw new IllegalArgumentException("Checking for null in nested objects is not supported.");
-        }
-
-        // checking that fieldName has the correct type is done in C++
-        this.query.isNull(columns.get(fieldName));
-        return this;
-    }
-
-    /**
-     * Test if a field is not null. Only works for relationships and RealmLists.
-     *
-     * @param fieldName - the field name
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
-     */
-    public RealmQuery<E> isNotNull(String fieldName) {
-        return this.beginGroup().not().isNull(fieldName).endGroup();
-    }
-
-    // Equal
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, String value) {
-        return this.equalTo(fieldName, value, CASE_SENSITIVE);
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName   The field to compare
-     * @param value       The value to compare with
-     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
-     *                      locale characters.
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-
-     */
-    public RealmQuery<E> equalTo(String fieldName, String value, boolean caseSensitive) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
-        this.query.equalTo(columnIndices, value, caseSensitive);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, int value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, long value) {
-        long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, boolean value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.BOOLEAN);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> equalTo(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.equalTo(columnIndices, value);
-        return this;
-    }
-
-    // Not Equal
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, String value) {
-        return this.notEqualTo(fieldName, value, RealmQuery.CASE_SENSITIVE);
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
-     *                      locale characters.
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, String value, boolean caseSensitive) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
-        if (columnIndices.length > 1 && !caseSensitive) {
-            throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
-        }
-        this.query.notEqualTo(columnIndices, value, caseSensitive);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, int value) {
-        long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.notEqualTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, long value) {
-        long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.notEqualTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.notEqualTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.notEqualTo(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, boolean value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.BOOLEAN);
-        this.query.equalTo(columnIndices, !value);
-        return this;
-    }
-
-    /**
-     * Not-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> notEqualTo(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.notEqualTo(columnIndices, value);
-        return this;
-    }
-
-    // Greater Than
-
-    /**
-     * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThan(String fieldName, int value) {
-        long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThan(String fieldName, long value) {
-        long[] columnIndices = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThan(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.greaterThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThan(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.greaterThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThan(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.greaterThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.greaterThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.greaterThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Greater-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.greaterThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    // Less Than
-
-    /**
-     * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThan(String fieldName, int value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.lessThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThan(String fieldName, long value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.lessThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThan(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.lessThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThan(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.lessThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThan(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.lessThan(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.lessThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.lessThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    /**
-     * Less-than-or-equal-to comparison
-     * @param fieldName  The field to compare
-     * @param value      The value to compare with
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.lessThanOrEqual(columnIndices, value);
-        return this;
-    }
-
-    // Between
-
-    /**
-     * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> between(String fieldName, int from, int to) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.between(columnIndices, from, to);
-        return this;
-    }
-
-    /**
-     * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> between(String fieldName, long from, long to) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.INTEGER);
-        this.query.between(columnIndices, from, to);
-        return this;
-    }
-
-    /**
-     * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> between(String fieldName, double from, double to) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DOUBLE);
-        this.query.between(columnIndices, from, to);
-        return this;
-    }
-
-    /**
-     * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> between(String fieldName, float from, float to) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.FLOAT);
-        this.query.between(columnIndices, from, to);
-        return this;
-    }
-
-    /**
-     * Between condition
-     * @param fieldName  The field to compare
-     * @param from       Lowest value (inclusive)
-     * @param to         Highest value (inclusive)
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> between(String fieldName, Date from, Date to) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.DATE);
-        this.query.between(columnIndices, from, to);
-        return this;
-    }
-
-
-    // Contains
-
-    /**
-     * Condition that value of field contains the specified substring
-     * @param fieldName  The field to compare
-     * @param value      The substring
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> contains(String fieldName, String value) {
-        return contains(fieldName, value, CASE_SENSITIVE);
-    }
-
-    /**
-     * Condition that value of field contains the specified substring
-     * @param fieldName  The field to compare
-     * @param value      The substring
-     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
-     *                      locale characters.
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> contains(String fieldName, String value, boolean caseSensitive) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
-        this.query.contains(columnIndices, value, caseSensitive);
-        return this;
-    }
-
-    /**
-     * Condition that the value of field begins with the specified string
-     * @param fieldName The field to compare
-     * @param value     The string
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> beginsWith(String fieldName, String value) {
-        return beginsWith(fieldName, value, CASE_SENSITIVE);
-    }
-
-    /**
-     * Condition that the value of field begins with the specified substring
-     * @param fieldName The field to compare
-     * @param value     The substring
-     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
-     *                      locale characters.
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> beginsWith(String fieldName, String value, boolean caseSensitive) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
-        this.query.beginsWith(columnIndices, value, caseSensitive);
-        return this;
-    }
-
-    /**
-     * Condition that the value of field ends with the specified string
-     * @param fieldName The field to compare
-     * @param value     The string
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> endsWith(String fieldName, String value) {
-        return endsWith(fieldName, value, CASE_SENSITIVE);
-    }
-
-    /**
-     * Condition that the value of field ends with the specified substring
-     * @param fieldName The field to compare
-     * @param value     The substring
-     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
-     *                      locale characters.
-     * @return The query object
-     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
-     * field type
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmQuery<E> endsWith(String fieldName, String value, boolean caseSensitive) {
-        long columnIndices[] = getColumnIndices(fieldName, ColumnType.STRING);
-        this.query.endsWith(columnIndices, value, caseSensitive);
-        return this;
-    }
-
-    // Grouping
-
-    /**
-     * Begin grouping of conditions ("left parenthesis"). A group must be closed with a
-     * call to <code>endGroup()</code>.
-     * @return The query object
-     * @see #endGroup()
-     */
-    public RealmQuery<E> beginGroup() {
-        this.query.group();
-        return this;
-    }
-
-    /**
-     * End grouping of conditions ("right parenthesis") which was opened by a call to
-     * <code>beginGroup()</code>.
-     * @return The query object
-     * @see #beginGroup()
-     */
-    public RealmQuery<E> endGroup() {
-        this.query.endGroup();
-        return this;
-    }
-
-    /**
-     * Logical-or two conditions
-     * @return The query object
-     */
-    public RealmQuery<E> or() {
-        this.query.or();
-        return this;
-    }
-
-    /**
-     * Negate condition.
-     * @return The query object
-     */
-    public RealmQuery<E> not() {
-        this.query.not();
-        return this;
-    }
-
-    // Aggregates
-
-    // Sum
-
-    /**
-     * Calculate the sum of a field
-     * @param fieldName The field name
-     * @return The sum
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public long sumInt(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.sumInt(columnIndex);
-    }
-
-    /**
-     * Calculate the sum of a field
-     * @param fieldName The field name
-     * @return The sum
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double sumDouble(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.sumDouble(columnIndex);
-    }
-
-    /**
-     * Calculate the sum of a field
-     * @param fieldName The field name
-     * @return The sum
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double sumFloat(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.sumFloat(columnIndex);
-    }
-
-    // Average
-
-    /**
-     * Calculate the average of a field
-     * @param fieldName The field name
-     * @return The average
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double averageInt(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.averageInt(columnIndex);
-    }
-
-    /**
-     * Calculate the average of a field
-     * @param fieldName The field name
-     * @return The average
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double averageDouble(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.averageDouble(columnIndex);
-    }
-
-    /**
-     * Calculate the average of a field
-     * @param fieldName The field name
-     * @return The average
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double averageFloat(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.averageFloat(columnIndex);
-    }
-
-    // Min
-
-    /**
-     * Find the minimum value of a field
-     * @param fieldName  The field name
-     * @return The minimum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public long minimumInt(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.minimumInt(columnIndex);
-    }
-
-    /**
-     * Find the minimum value of a field
-     * @param fieldName  The field name
-     * @return The minimum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double minimumDouble(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.minimumDouble(columnIndex);
-    }
-
-    /**
-     * Find the minimum value of a field
-     * @param fieldName  The field name
-     * @return The minimum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public float minimumFloat(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.minimumFloat(columnIndex);
-    }
-
-    /**
-     * Find the minimum value of a field
-     * @param fieldName  The field name
-     * @return The minimum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public Date minimumDate(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.minimumDate(columnIndex);
-    }
-
-    // Max
-
-    /**
-     * Find the maximum value of a field
-     * @param fieldName  The field name
-     * @return The maximum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public long maximumInt(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.maximumInt(columnIndex);
-    }
-
-    /**
-     * Find the maximum value of a field
-     * @param fieldName  The field name
-     * @return The maximum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public double maximumDouble(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.maximumDouble(columnIndex);
-    }
-
-    /**
-     * Find the maximum value of a field
-     * @param fieldName  The field name
-     * @return The maximum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public float maximumFloat(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.maximumFloat(columnIndex);
-    }
-
-    /**
-     * Find the maximum value of a field
-     * @param fieldName  The field name
-     * @return The maximum value
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public Date maximumDate(String fieldName) {
-        long columnIndex = columns.get(fieldName);
-        return this.query.maximumDate(columnIndex);
-    }
-
-    /**
-     * Count the number of objects that fulfill the query conditions.
-     *
-     * @return The number of matching objects.
-     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
-     */
-    public long count() {
-        return this.query.count();
-    }
-
-    // Execute
-
-    /**
-     * Find all objects that fulfill the query conditions.
-     *
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @see io.realm.RealmResults
-     * @throws java.lang.RuntimeException Any other error
-     */
-    public RealmResults<E> findAll() {
-        return new RealmResults<E>(realm, query.findAll(), clazz);
-    }
-
-    /**
-     * Find all objects that fulfill the query conditions and sorted by specific field name.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName the field name to sort by.
-     * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
-     *                      if <code>SORT_ORDER_DESCENDING</code>
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
-     */
-    public RealmResults<E> findAllSorted(String fieldName, boolean sortAscending) {
-        TableView tableView = query.findAll();
-        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
-        Long columnIndex = columns.get(fieldName);
-        if (columnIndex == null || columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-        tableView.sort(columnIndex, order);
-        return new RealmResults<E>(realm, tableView, clazz);
-    }
-
-
-    /**
-     * Find all objects that fulfill the query conditions and sorted by specific field name in
-     * ascending order.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName the field name to sort by.
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
-     */
-    public RealmResults<E> findAllSorted(String fieldName) {
-        return findAllSorted(fieldName, true);
-    }
-
-    /**
-     * Find all objects that fulfill the query conditions and sorted by specific field names.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldNames an array of field names to sort by.
-     * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
-     *                      if <code>SORT_ORDER_DESCENDING</code>.
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public RealmResults<E> findAllSorted(String fieldNames[], boolean sortAscending[]) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames cannot be 'null'.");
-        } else if (sortAscending == null) {
-            throw new IllegalArgumentException("sortAscending cannot be 'null'.");
-        } else if (fieldNames.length == 0) {
-            throw new IllegalArgumentException("At least one field name must be specified.");
-        } else if (fieldNames.length != sortAscending.length) {
-            throw new IllegalArgumentException(String.format("Number of field names (%d) and sort orders (%d) does not match.", fieldNames.length, sortAscending.length));
-        }
-
-        if (fieldNames.length == 1 && sortAscending.length == 1) {
-            return findAllSorted(fieldNames[0], sortAscending[0]);
-        } else {
-            TableView tableView = query.findAll();
-            List<Long> columnIndices = new ArrayList<Long>();
-            List<TableView.Order> orders = new ArrayList<TableView.Order>();
-            for (int i = 0; i < fieldNames.length; i++) {
-                String fieldName = fieldNames[i];
-                Long columnIndex = columns.get(fieldName);
-                if (columnIndex == null || columnIndex < 0) {
-                    throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-                }
-                columnIndices.add(columnIndex);
-            }
-            for (int i = 0; i < sortAscending.length; i++) {
-                orders.add(sortAscending[i] ? TableView.Order.ascending : TableView.Order.descending);
-            }
-            tableView.sort(columnIndices, orders);
-            return new RealmResults<E>(realm, tableView, clazz);
-        }
-    }
-
-    /**
-     * Find all objects that fulfill the query conditions and sorted by specific field names in
-     * ascending order.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName1 first field name
-     * @param sortAscending1 sort order for first field
-     * @param fieldName2 second field name
-     * @param sortAscending2 sort order for second field
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public RealmResults<E> findAllSorted(String fieldName1, boolean sortAscending1,
-                                   String fieldName2, boolean sortAscending2) {
-        return findAllSorted(new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1, sortAscending2});
-    }
-
-
-    /**
-     * Find all objects that fulfill the query conditions and sorted by specific field names in
-     * ascending order.
-     *
-     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
-     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
-     *
-     * @param fieldName1 first field name
-     * @param sortAscending1 sort order for first field
-     * @param fieldName2 second field name
-     * @param sortAscending2 sort order for second field
-     * @param fieldName3 third field name
-     * @param sortAscending3 sort order for third field
-     * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
-     * a list with zero objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public RealmResults<E> findAllSorted(String fieldName1, boolean sortAscending1,
-                                   String fieldName2, boolean sortAscending2,
-                                   String fieldName3, boolean sortAscending3) {
-        return findAllSorted(new String[] {fieldName1, fieldName2, fieldName3},
-                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
-    }
-
-    /**
-     * Find the first object that fulfills the query conditions.
-     *
-     * @return The object found or null if no object matches the query conditions.
-     * @see io.realm.RealmObject
-     * @throws java.lang.RuntimeException Any other error.
-     */
-    public E findFirst() {
-        long rowIndex = this.query.find();
-        if (rowIndex >= 0) {
-            return realm.get(clazz, (view != null) ? view.getTargetRowIndex(rowIndex) : rowIndex);
-        } else {
-            return null;
-        }
-    }
-}
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
deleted file mode 100644
index 6a9c49988e..0000000000
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ /dev/null
@@ -1,620 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.ConcurrentModificationException;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-
-import io.realm.exceptions.RealmException;
-import io.realm.internal.ColumnType;
-import io.realm.internal.TableOrView;
-import io.realm.internal.TableView;
-
-/**
- * This class holds all the matches of a {@link io.realm.RealmQuery} for a given Realm. The objects
- * are not copied from the Realm to the RealmResults list, but are just referenced from the
- * RealmResult instead. This saves memory and increases speed.
- * <p>
- * RealmResults are live views, which means that if it is on an {@link android.os.Looper} thread,
- * it will automatically update its query results after a transaction has been committed. If on a
- * non-looper thread, {@link Realm#refresh()} must be called to update the results.
- * <p>
- * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the
- * modified objects are persisted to the Realm file during the commit of the transaction.
- * <p>
- * A RealmResults object cannot be passed between different threads.
- * <p>
- * Notice that a RealmResults is never null not even in the case where it contains no objects. You
- * should always use the size() method to check if a RealmResults is empty or not.
- *
- * @param <E> The class of objects in this list
- * @see RealmQuery#findAll()
- * @see Realm#allObjects(Class)
- * @see io.realm.Realm#beginTransaction()
- */
-public class RealmResults<E extends RealmObject> extends AbstractList<E> {
-
-    private Class<E> classSpec;
-    private Realm realm;
-    private TableOrView table = null;
-
-    public static final boolean SORT_ORDER_ASCENDING = true;
-    public static final boolean SORT_ORDER_DESCENDING = false;
-
-    private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
-    private long currentTableViewVersion = -1;
-
-    RealmResults(Realm realm, Class<E> classSpec) {
-        this.realm = realm;
-        this.classSpec = classSpec;
-    }
-
-    RealmResults(Realm realm, TableOrView table, Class<E> classSpec) {
-        this(realm, classSpec);
-        this.table = table;
-    }
-
-    Realm getRealm() {
-        return realm;
-    }
-
-    TableOrView getTable() {
-        if (table == null) {
-            return realm.getTable(classSpec);
-        } else {
-            return table;
-        }
-    }
-
-    /**
-     * Returns a typed {@link io.realm.RealmQuery}, which can be used to query for specific
-     * objects of this type.
-     *
-     * @return A typed RealmQuery
-     * @see io.realm.RealmQuery
-     */
-    public RealmQuery<E> where() {
-        realm.checkIfValid();
-        return new RealmQuery<E>(this, classSpec);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E get(int rowIndex) {
-        E obj;
-        realm.checkIfValid();
-        TableOrView table = getTable();
-        if (table instanceof TableView) {
-            obj = realm.get(classSpec, ((TableView)table).getSourceRowIndex(rowIndex));
-        } else {
-            obj = realm.get(classSpec, rowIndex);
-        }
-
-        return obj;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int indexOf(Object o) {
-        throw new NoSuchMethodError("indexOf is not supported on RealmResults");
-    }
-
-    /**
-     * Get the first object from the list.
-     * @return The first object.
-     */
-    public E first() {
-        return get(0);
-    }
-
-    /**
-     * Get the last object from the list.
-     * @return The last object.
-     */
-    public E last() {
-        return get(size()-1);
-    }
-
-    /**
-     * Returns an iterator for the results of a query. Any change to Realm while iterating will
-     * cause this iterator to throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @return  an iterator on the elements of this list.
-     * @see     Iterator
-     */
-    @Override
-    public Iterator<E> iterator() {
-        return new RealmResultsIterator();
-    }
-
-    /**
-     * Returns a list iterator for the results of a query. Any change to Realm while iterating will
-     * cause the iterator to throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @return  a ListIterator on the elements of this list.
-     * @see     ListIterator
-     */
-    @Override
-    public ListIterator<E> listIterator() {
-        return new RealmResultsListIterator(0);
-    }
-
-    /**
-     * Returns a list iterator on the results of a query. Any change to Realm while iterating will
-     * cause the iterator to throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @param location  the index at which to start the iteration.
-     * @return          a ListIterator on the elements of this list.
-     * @throws          IndexOutOfBoundsException if {@code location < 0 || location > size()}
-     * @see             ListIterator
-     */
-    @Override
-    public ListIterator<E> listIterator(int location) {
-        return new RealmResultsListIterator(location);
-    }
-
-    // Sorting
-
-    // aux. method used by sort methods
-    private long getColumnIndex(String fieldName) {
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Sorting using child object properties is not supported: " + fieldName);
-        }
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
-        }
-        return columnIndex;
-    }
-
-    /**
-     * Sort (ascending) an existing {@link io.realm.RealmResults}.
-     * 
-     * @param fieldName  The field name to sort by. Only fields of type boolean, short, int, long,
-     *                   float, double, Date, and String are supported.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
-     */
-    public void sort(String fieldName) {
-        this.sort(fieldName, SORT_ORDER_ASCENDING);
-    }
-
-    /**
-     * Sort existing {@link io.realm.RealmResults}.
-     *
-     * @param fieldName      The field name to sort by. Only fields of type boolean, short, int,
-     *                       long, float, double, Date, and String are supported.
-     * @param sortAscending  The direction to sort by; if true ascending, otherwise descending
-     *                       You can use the constants SORT_ORDER_ASCENDING and SORT_ORDER_DESCENDING
-     *                       for readability.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
-     */
-    public void sort(String fieldName, boolean sortAscending) {
-        if (fieldName == null) {
-            throw new IllegalArgumentException("fieldName must be provided");
-        }
-        realm.checkIfValid();
-        TableOrView table = getTable();
-
-        if (table instanceof TableView) {
-            long columnIndex = getColumnIndex(fieldName);
-            TableView.Order TVOrder = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
-            ((TableView) table).sort(columnIndex, TVOrder);
-        } else {
-            throw new IllegalArgumentException("Only RealmResults can be sorted - please use allObject() to create a RealmResults.");
-        }
-    }
-
-    /**
-     * Sort existing {@link io.realm.RealmResults}.
-     *
-     * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int,
-     *                       long, float, double, Date, and String are supported.
-     * @param sortAscending The directions to sort by; if true ascending, otherwise descending
-     *                       You can use the constants SORT_ORDER_ASCENDING and SORT_ORDER_DESCENDING
-     *                       for readability.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public void sort(String fieldNames[], boolean sortAscending[]) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames must be provided.");
-        } else if (sortAscending == null) {
-            throw new IllegalArgumentException("sortAscending must be provided.");
-        }
-
-        if (fieldNames.length == 1 && sortAscending.length == 1) {
-            sort(fieldNames[0], sortAscending[0]);
-        } else {
-            realm.checkIfValid();
-            TableOrView table = getTable();
-            if (table instanceof TableView) {
-                List<TableView.Order> TVOrder = new ArrayList<TableView.Order>();
-                List<Long> columnIndices = new ArrayList<Long>();
-                for (int i = 0; i < fieldNames.length; i++) {
-                    String fieldName = fieldNames[i];
-                    long columnIndex = getColumnIndex(fieldName);
-                    columnIndices.add(columnIndex);
-                }
-                for (int i = 0; i < sortAscending.length; i++) {
-                    TVOrder.add(sortAscending[i] ? TableView.Order.ascending : TableView.Order.descending);
-                }
-                ((TableView) table).sort(columnIndices, TVOrder);
-            }
-        }
-    }
-
-
-    /**
-     * Sort existing {@link io.realm.RealmResults} using two fields.
-     *
-     * @param fieldName1 first field name.
-     * @param sortAscending1 sort order for first field.
-     * @param fieldName2 second field name.
-     * @param sortAscending2 sort order for second field.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public void sort(String fieldName1, boolean sortAscending1, String fieldName2, boolean sortAscending2) {
-        sort(new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1, sortAscending2});
-    }
-
-    /**
-     * Sort existing {@link io.realm.RealmResults} using three fields.
-     *
-     * @param fieldName1 first field name.
-     * @param sortAscending1 sort order for first field.
-     * @param fieldName2 second field name.
-     * @param sortAscending2 sort order for second field.
-     * @param fieldName3 third field name.
-     * @param sortAscending3 sort order for third field.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    public void sort(String fieldName1, boolean sortAscending1, String fieldName2, boolean sortAscending2, String fieldName3, boolean sortAscending3) {
-        sort(new String[] {fieldName1, fieldName2, fieldName3}, new boolean[] {sortAscending1, sortAscending2, sortAscending3});
-    }
-
-    // Aggregates
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int size() {
-        return ((Long)getTable().size()).intValue();
-    }
-
-    /**
-     * Find the minimum value of a field.
-     *
-     * @param fieldName   The field to look for a minimum on. Only int, float, and double
-     *                    are supported.
-     * @return            The minimum value.
-     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
-     */
-    public Number min(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.minimumLong(columnIndex);
-            case FLOAT:
-                return table.minimumFloat(columnIndex);
-            case DOUBLE:
-                return table.minimumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-    /**
-     * Find the minimum date.
-     *
-     * @param fieldName  The field to look for the minimum date. If fieldName is not of Date type,
-     *                   an exception is thrown.
-     * @return           The minimum date.
-     * @throws           java.lang.IllegalArgumentException if fieldName is not a Date field.
-     */
-    public Date minDate(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (table.getColumnType(columnIndex) == ColumnType.DATE) {
-            return table.minimumDate(columnIndex);
-        }
-        else {
-            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
-        }
-    }
-
-    /**
-     * Find the maximum value of a field.
-     *
-     * @param fieldName   The field to look for a maximum on. Only int, float, and double are supported.
-     * @return            The maximum value.
-     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
-     */
-    public Number max(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.maximumLong(columnIndex);
-            case FLOAT:
-                return table.maximumFloat(columnIndex);
-            case DOUBLE:
-                return table.maximumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-    /**
-     * Find the maximum date.
-     *
-     * @param fieldName  The field to look for the maximum date. If fieldName is not of Date type,
-     *                   an exception is thrown.
-     * @return           The maximum date.
-     * @throws           java.lang.IllegalArgumentException if fieldName is not a Date field.
-     */
-    public Date maxDate(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (table.getColumnType(columnIndex) == ColumnType.DATE) {
-            return table.maximumDate(columnIndex);
-        }
-        else {
-            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
-        }
-    }
-
-
-    /**
-     * Calculate the sum of a given field.
-     *
-     * @param fieldName   The field to sum. Only int, float, and double are supported.
-     * @return            The sum.
-     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
-     */
-
-    public Number sum(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.sumLong(columnIndex);
-            case FLOAT:
-                return table.sumFloat(columnIndex);
-            case DOUBLE:
-                return table.sumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-
-    /**
-     * Returns the average of a given field.
-     *
-     * @param fieldName  The field to calculate average on. Only properties of type int,
-     *                   float and double are supported.
-     * @return           The average for the given field amongst objects in an RealmList. This
-     *                   will be of type double for both float and double field.
-     * @throws           java.lang.IllegalArgumentException if field is not int, float or double.
-     */
-    public double average(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = table.getColumnIndex(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.averageLong(columnIndex);
-            case DOUBLE:
-                return table.averageDouble(columnIndex);
-            case FLOAT:
-                return table.averageFloat(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-
-    // Deleting
-
-    /**
-     * Removes an object at a given index. This also deletes the object from the underlying Realm.
-     *
-     * Using this method while iterating the list can result in a undefined behavior. Use
-     * {@link io.realm.RealmResults.RealmResultsIterator#remove()} instead.
-     *
-     * @param index      The array index identifying the object to be removed.
-     * @return           Always return null.
-     */
-    @Override
-    public E remove(int index) {
-        TableOrView table = getTable();
-        table.remove(index);
-        return null; // Returning the object doesn't make sense, since it could no longer access any data.
-    }
-
-    /**
-     * Removes and returns the last object in the list. This also deletes the object from the
-     * underlying Realm.
-     *
-     * Using this method while iterating the list can result in a undefined behavior. Use
-     * {@link io.realm.RealmResults.RealmResultsListIterator#removeLast()} instead.
-     */
-    public void removeLast() {
-        TableOrView table = getTable();
-        table.removeLast();
-    }
-
-    /**
-     * Removes all objects from the list. This also deletes the objects from the
-     * underlying Realm.
-     */
-    public void clear() {
-        TableOrView table = getTable();
-        table.clear();
-    }
-
-    // Adding objects
-
-    @Override
-    @Deprecated
-    public boolean add(E element) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    @Deprecated
-    public void add(int index, E element) {
-        throw new UnsupportedOperationException();
-    }
-//
-//    /**
-//     * Replaces an object at the given index with a new object.
-//     *
-//     * @param index       The array index of the object to be replaced.
-//     * @param element     An object.
-//     */
-//    public void replace(int index, E element) {
-//        throw new NoSuchMethodError();
-//    }
-
-    private void assertRealmIsStable() {
-        long version = table.sync();
-        if (currentTableViewVersion > -1 && version != currentTableViewVersion) {
-            throw new ConcurrentModificationException("No outside changes to a Realm is allowed while iterating a RealmResults. Use iterators methods instead.");
-        }
-
-        currentTableViewVersion = version;
-    }
-
-    // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
-    private class RealmResultsIterator implements Iterator<E> {
-
-        int pos = -1;
-        boolean removeUsed = false;
-
-        RealmResultsIterator() {
-            currentTableViewVersion = table.sync();
-        }
-
-        public boolean hasNext() {
-            assertRealmIsStable();
-            return pos + 1 < size();
-        }
-
-        public E next() {
-            assertRealmIsStable();
-            pos++;
-            removeUsed = false;
-            if (pos >= size()) {
-                throw new IndexOutOfBoundsException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
-            }
-            return get(pos);
-        }
-
-        /**
-         * Removes the RealmObject at the current position from both the list and the underlying Realm.
-         *
-         * WARNING: This method is currently disabled and will always throw an
-         * {@link io.realm.exceptions.RealmException}
-         */
-        public void remove() {
-            throw new RealmException("Removing is not supported.");
-    /*        assertRealmIsStable();
-            if (pos == -1) {
-                throw new IllegalStateException("Must call next() before calling remove()");
-            }
-            if (removeUsed) {
-                throw new IllegalStateException("Cannot call remove() twice. Must call next() in between");
-            }
-
-            RealmResults.this.remove(pos);
-            pos--;
-            removeUsed = true;
-            currentTableViewVersion = getTable().sync();
-     */   }
-    }
-
-    // Custom RealmResults list iterator. It ensures that we only iterate on a Realm that hasn't changed.
-    private class RealmResultsListIterator extends RealmResultsIterator implements ListIterator<E> {
-
-        RealmResultsListIterator(int start) {
-            if (start >= 0 && start <= size()) {
-                pos = start - 1;
-            } else {
-                throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, " + (size() - 1) + "]. Yours was " + start);
-            }
-        }
-
-        @Override
-        public void add(E object) {
-            throw new RealmException("Adding elements not supported. Use Realm.createObject() instead.");
-        }
-
-        @Override
-        public boolean hasPrevious() {
-            assertRealmIsStable();
-            return pos > 0;
-        }
-
-        @Override
-        public int nextIndex() {
-            assertRealmIsStable();
-            return pos + 1;
-        }
-
-        @Override
-        public E previous() {
-            assertRealmIsStable();
-            pos--;
-            if (pos < 0) {
-                throw new IndexOutOfBoundsException("Cannot access index less than zero. This was " + pos + ". Remember to check hasPrevious() before using previous().");
-            }
-            return get(pos);
-        }
-
-        @Override
-        public int previousIndex() {
-            assertRealmIsStable();
-            return pos;
-        }
-
-        @Override
-        public void set(E object) {
-            throw new RealmException("Replacing elements not supported.");
-        }
-
-
-        /**
-         * Removes the RealmObject at the current position from both the list and the underlying Realm.
-         *
-         * WARNING: This method is currently disabled and will always throw an
-         * {@link io.realm.exceptions.RealmException}
-         */
-        @Override
-        public void remove() { throw new RealmException("Removing elements not supported."); }
-    }
-}
diff --git a/realm/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/src/main/java/io/realm/exceptions/RealmIOException.java
deleted file mode 100644
index 4cb2833129..0000000000
--- a/realm/src/main/java/io/realm/exceptions/RealmIOException.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package io.realm.exceptions;
-
-/**
- * Class for reporting problems with Realm files.
- */
-public class RealmIOException extends RuntimeException {
-
-    public RealmIOException(Throwable cause) {
-        super(cause);
-    }
-
-    public RealmIOException() {
-    }
-
-    public RealmIOException(String message) {
-        super(message);
-    }
-
-    public RealmIOException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-}
diff --git a/realm/src/main/java/io/realm/internal/ColumnType.java b/realm/src/main/java/io/realm/internal/ColumnType.java
deleted file mode 100644
index 18891ba41a..0000000000
--- a/realm/src/main/java/io/realm/internal/ColumnType.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.nio.ByteBuffer;
-
-// Make sure numbers match with <realm/column_type.hpp>
-// FIXME: Add a unit test that verifies the correct correspondence.
-
-public enum ColumnType {
-    BOOLEAN(1),
-    INTEGER(0),
-    FLOAT(9),
-    DOUBLE(10),
-    STRING(2),
-    BINARY(4),
-    DATE(7),
-    TABLE(5),
-    MIXED(6),
-    LINK(12),
-    LINK_LIST(13);
-    // When adding above, remember to update size of largest number below
-
-    private final int nativeValue;
-
-    // Note that if this array is too small, an
-    // IndexOutOfBoundsException will be thrown during class loading.
-    private static ColumnType[] byNativeValue = new ColumnType[14];
-
-    static {
-        ColumnType[] columnTypes = values();
-        for (int i=0; i<columnTypes.length; ++i) {
-            int v = columnTypes[i].nativeValue;
-            byNativeValue[v] = columnTypes[i];
-        }
-    }
-
-    private ColumnType(int nativeValue)
-    {
-        this.nativeValue = nativeValue;
-    }
-
-    public int getValue() {
-        return nativeValue;
-    }
-
-    public boolean matchObject(Object obj) {
-        switch (this.nativeValue) {
-        case 0: return (obj instanceof Long || obj instanceof Integer || obj instanceof Short ||
-                obj instanceof Byte);
-        case 1: return (obj instanceof Boolean);
-        case 2: return (obj instanceof String);
-        case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
-        case 5: return (obj == null || obj instanceof Object[][]);
-        case 6: return (obj instanceof Mixed ||
-                obj instanceof Long || obj instanceof Integer ||
-                obj instanceof Short || obj instanceof Byte || obj instanceof Boolean ||
-                obj instanceof Float || obj instanceof Double ||
-                obj instanceof String ||
-                obj instanceof byte[] || obj instanceof ByteBuffer ||
-                obj == null || obj instanceof Object[][] ||
-                obj instanceof java.util.Date);
-        case 7: return (obj instanceof java.util.Date);
-        case 9: return (obj instanceof Float);
-        case 10: return (obj instanceof Double);
-        default: throw new RuntimeException(String.format("Invalid index (%d) in ColumnType.", this.nativeValue));
-        }
-    }
-
-    static ColumnType fromNativeValue(int value)
-    {
-        if (0 <= value && value < byNativeValue.length) {
-            ColumnType e = byNativeValue[value];
-            if (e != null)
-                return e;
-        }
-        throw new IllegalArgumentException("Invalid native column type");
-    }
-}
-
diff --git a/realm/src/main/java/io/realm/internal/LinkView.java b/realm/src/main/java/io/realm/internal/LinkView.java
deleted file mode 100644
index ee297a52e7..0000000000
--- a/realm/src/main/java/io/realm/internal/LinkView.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-/**
- * The LinkView class represent a core {@link ColumnType#LINK_LIST}.
- */
-public class LinkView {
-
-    private final Context context;
-    private final long nativeLinkViewPtr;
-    private final Table parent;
-    private final long columnIndexInParent;
-
-    public LinkView(Context context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
-        this.context = context;
-        this.parent = parent;
-        this.columnIndexInParent = columnIndexInParent;
-        this.nativeLinkViewPtr = nativeLinkViewPtr;
-    }
-
-    public Row get(long pos) {
-        long nativeRowPtr = nativeGetRow(nativeLinkViewPtr, pos);
-        return new Row(context, parent.getLinkTarget(columnIndexInParent), nativeRowPtr);
-    }
-
-    public long getTargetRowIndex(long pos) {
-        return nativeGetTargetRowIndex(nativeLinkViewPtr, pos);
-    }
-
-    public void add(long rowIndex) {
-        checkImmutable();
-        nativeAdd(nativeLinkViewPtr, rowIndex);
-    }
-
-    public void insert(long pos, long rowIndex) {
-        checkImmutable();
-        nativeInsert(nativeLinkViewPtr, pos, rowIndex);
-    }
-
-    public void set(long pos, long rowIndex) {
-        checkImmutable();
-        nativeSet(nativeLinkViewPtr, pos, rowIndex);
-    }
-
-    public void move(long oldPos, long newPos) {
-        checkImmutable();
-        nativeMove(nativeLinkViewPtr, oldPos, newPos);
-    }
-
-    public void remove(long pos) {
-        checkImmutable();
-        nativeRemove(nativeLinkViewPtr, pos);
-    }
-
-    public void clear() {
-        checkImmutable();
-        nativeClear(nativeLinkViewPtr);
-    }
-
-    public long size() {
-        return nativeSize(nativeLinkViewPtr);
-    }
-
-    public boolean isEmpty() {
-        return nativeIsEmpty(nativeLinkViewPtr);
-    }
-
-    public TableQuery where() {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        this.context.executeDelayedDisposal();
-        long nativeQueryPtr = nativeWhere(nativeLinkViewPtr);
-        try {
-            return new TableQuery(this.context, this.parent, nativeQueryPtr);
-        } catch (RuntimeException e) {
-            TableQuery.nativeClose(nativeQueryPtr);
-            throw e;
-        }
-    }
-
-    private void checkImmutable() {
-        if (parent.isImmutable()) {
-            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
-        }
-    }
-
-    protected static native void nativeClose(long nativeLinkViewPtr);
-    private native long nativeGetRow(long nativeLinkViewPtr, long pos);
-    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
-    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
-    private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
-    private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
-    private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
-    private native void nativeRemove(long nativeLinkViewPtr, long pos);
-    private native void nativeClear(long nativeLinkViewPtr);
-    private native long nativeSize(long nativeLinkViewPtr);
-    private native boolean nativeIsEmpty(long nativeLinkViewPtr);
-    protected native long nativeWhere(long nativeLinkViewPtr);
-}
diff --git a/realm/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/src/main/java/io/realm/internal/RealmProxyMediator.java
deleted file mode 100644
index 30ffc07e91..0000000000
--- a/realm/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.util.JsonReader;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.List;
-import java.util.Map;
-
-import io.realm.Realm;
-import io.realm.RealmObject;
-import io.realm.exceptions.RealmException;
-
-/**
- * Superclass for the RealmProxyMediator class'. This class contain all static methods introduced by the
- * annotation processor as part of the RealmProxy classes.
- *
- * Classes extending this class act as binders between the static methods inside each RealmProxy and the code
- * at runtime. We cannot rely on using reflection as the RealmProxies are generated by the annotation processor
- * before ProGuard is run. So after ProGuard has run there is a mismatch between the name of the RealmProxy and
- * the original RealmObject class.
- */
-public abstract class RealmProxyMediator {
-
-    /**
-     * Creates the backing table in Realm for the given model class.
-     *
-     * @param clazz         RealmObject model class to create backing table for.
-     * @param transaction   Read transaction for the Realm to create table in.
-     */
-    public abstract Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
-
-    /**
-     * Validate the backing table in Realm for the given model class.
-     *
-     * @param clazz         RealmObject model class to validate.
-     * @param transaction   Read transaction for the Realm to validate against.
-     */
-    public abstract void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
-
-    /**
-     * Returns a map of non-obfuscated object field names to their internal realm name.
-     *
-     * @param clazz  RealmObject model class reference.
-     * @return The simple name of an model class (before it has been obfuscated)
-     */
-    public abstract List<String> getFieldNames(Class<? extends RealmObject> clazz);
-
-    /**
-     * Returns name that Realm should use for all it's internal tables. This is normally the unobfuscated named of a
-     * class.
-     *
-     * @param clazz  RealmObject model class reference.
-     * @return The simple name of an model class (before it has been obfuscated)
-     *
-     * @throws java.lang.NullPointerException if null is given as argument.
-     */
-    public abstract String getTableName(Class<? extends RealmObject> clazz);
-
-    /**
-     * Creates a new instance of an RealmProxy for the given model class.
-     *
-     * @param clazz RealmObject to create RealmProxy for.
-     * @return Created RealmProxy object.
-     */
-    public abstract <E extends RealmObject> E newInstance(Class<E> clazz);
-
-    /**
-     * Returns the list of model classes that Realm supports in this application.
-     *
-     * @return List of class references to model classes. Empty list if no models are supported.
-     */
-    public abstract List<Class<? extends RealmObject>> getModelClasses();
-
-    /**
-     * Returns a map of the column indices for all Realm fields in the model class.
-     *
-     * @return Map from field name to column indices for all Realm fields in the model class.
-     */
-    public abstract  Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz);
-
-    /**
-     * Copy a non-manged RealmObject or a RealmObject from another Realm to this Realm. After being
-     * copied any changes to the original object will not be persisted.
-     *
-     * @param object Object to copy properties from.
-     * @param update True if object has a primary key and should try to update already existing data, false otherwise.
-     * @param cache Cache for mapping between standalone objects and their RealmProxy representation.
-     * @return Managed Realm object.
-     */
-    public abstract <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache);
-
-    /**
-     * Creates or updates a RealmObject using the provided JSON data.
-     *
-     * @param clazz     Type of RealmObject
-     * @param realm     Reference to Realm where to create the object.
-     * @param json      JSON data
-     * @param update    True if Realm should try to update a existing object. This requires that the model has a @PrimaryKey
-     * @return RealmObject that has been created or updated.
-     * @throws JSONException If the JSON mapping doesn't match the expected class.
-     */
-    public abstract <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
-
-    /**
-     * Creates new RealmObjects based on a JSON input stream.
-     *
-     * @param clazz     Type of RealmObject
-     * @param realm     Reference to Realm where to create the object.
-     * @param reader    Reference to the InputStream containg the JSON data.
-     * @return The created RealmObject
-     * @throws IOException if an error occurs with the inputstream.
-     */
-    public abstract <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
-
-    protected static void checkClass(Class<? extends RealmObject> clazz) {
-        if (clazz == null) {
-            throw new NullPointerException("A class extending RealmObject must be provided");
-        }
-    }
-
-    protected static RealmException getMissingProxyClassException(Class<? extends RealmObject> clazz) {
-        return new RealmException("Could not find the generated proxy class for " + clazz + ". Annotation processor may not have been executed.");
-    }
-}
diff --git a/realm/src/main/java/io/realm/internal/Row.java b/realm/src/main/java/io/realm/internal/Row.java
deleted file mode 100644
index badb6b05ee..0000000000
--- a/realm/src/main/java/io/realm/internal/Row.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.util.Date;
-
-public class Row {
-
-    private final Context context;
-    private final Table parent;
-    protected long nativePtr;
-
-    Row(Context context, Table parent, long nativePtr) {
-        this.context = context;
-        this.parent = parent;
-        this.nativePtr = nativePtr;
-    }
-
-    public long getColumnCount() {
-        return nativeGetColumnCount(nativePtr);
-    }
-
-    protected native long nativeGetColumnCount(long nativeTablePtr);
-
-    /**
-     * Returns the name of a column identified by columnIndex. Notice that the
-     * index is zero based.
-     *
-     * @param columnIndex the column index
-     * @return the name of the column
-     */
-    public String getColumnName(long columnIndex) {
-        return nativeGetColumnName(nativePtr, columnIndex);
-    }
-
-    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
-
-    /**
-     * Returns the 0-based index of a column based on the name.
-     *
-     * @param columnName column name
-     * @return the index, -1 if not found
-     */
-    public long getColumnIndex(String columnName) {
-        if (columnName == null) {
-            throw new IllegalArgumentException("Column name can not be null.");
-        }
-        return nativeGetColumnIndex(nativePtr, columnName);
-    }
-
-    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
-
-
-    /**
-     * Get the type of a column identified by the columnIdex.
-     *
-     * @param columnIndex index of the column.
-     * @return Type of the particular column.
-     */
-    public ColumnType getColumnType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
-    }
-
-    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
-
-    // Getters
-
-    public Table getTable() {
-        return parent;
-    }
-
-    public long getIndex() {
-        return nativeGetIndex(nativePtr);
-    }
-
-    protected native long nativeGetIndex(long nativeRowPtr);
-
-    public long getLong(long columnIndex) {
-        return nativeGetLong(nativePtr, columnIndex);
-    }
-
-    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
-
-    public boolean getBoolean(long columnIndex) {
-        return nativeGetBoolean(nativePtr, columnIndex);
-    }
-
-    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
-
-    public float getFloat(long columnIndex) {
-        return nativeGetFloat(nativePtr, columnIndex);
-    }
-
-    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
-
-    public double getDouble(long columnIndex) {
-        return nativeGetDouble(nativePtr, columnIndex);
-    }
-
-    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-
-    public Date getDate(long columnIndex) {
-        return new Date(nativeGetDateTime(nativePtr, columnIndex)*1000);
-    }
-
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
-
-
-    public String getString(long columnIndex) {
-        return nativeGetString(nativePtr, columnIndex);
-    }
-
-    protected native String nativeGetString(long nativePtr, long columnIndex);
-
-
-    public byte[] getBinaryByteArray(long columnIndex) {
-        return nativeGetByteArray(nativePtr, columnIndex);
-    }
-
-    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-
-
-    public Mixed getMixed(long columnIndex) {
-        return nativeGetMixed(nativePtr, columnIndex);
-    }
-
-    public ColumnType getMixedType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex));
-    }
-
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-
-    public long getLink(long columnIndex) {
-        return nativeGetLink(nativePtr, columnIndex);
-    }
-
-    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
-
-    public boolean isNullLink(long columnIndex) {
-        return nativeIsNullLink(nativePtr, columnIndex);
-    }
-
-    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
-
-    public LinkView getLinkList(long columnIndex) {
-        long nativeLinkViewPtr = nativeGetLinkView(nativePtr, columnIndex);
-        return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
-    }
-
-    private native long nativeGetLinkView(long nativePtr, long columnIndex);
-
-
-    // Setters
-
-    public void setLong(long columnIndex, long value) {
-        parent.checkImmutable();
-        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetLong(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
-
-    public void setBoolean(long columnIndex, boolean value) {
-        parent.checkImmutable();
-        nativeSetBoolean(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
-
-    public void setFloat(long columnIndex, float value) {
-        parent.checkImmutable();
-        nativeSetFloat(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
-
-    public void setDouble(long columnIndex, double value) {
-        parent.checkImmutable();
-        nativeSetDouble(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
-
-    public void setDate(long columnIndex, Date date) {
-        parent.checkImmutable();
-        if (date == null) {
-            throw new IllegalArgumentException("Null Date is not allowed.");
-        }
-        long timestamp = date.getTime() / 1000;
-        if (timestamp >= Integer.MAX_VALUE || timestamp <= Integer.MIN_VALUE) {
-            throw new IllegalArgumentException("Date/timestamp is outside valid range");
-        }
-        nativeSetDate(nativePtr, columnIndex, timestamp);
-    }
-
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
-
-    public void setString(long columnIndex, String value) {
-        parent.checkImmutable();
-        getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetString(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
-
-    public void setBinaryByteArray(long columnIndex, byte[] data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null array is not allowed");
-        }
-        nativeSetByteArray(nativePtr, columnIndex, data);
-    }
-
-    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
-
-
-    public void setMixed(long columnIndex, Mixed data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null data is not allowed");
-        }
-        nativeSetMixed(nativePtr, columnIndex, data);
-    }
-
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
-
-    public void setLink(long columnIndex, long value) {
-        parent.checkImmutable();
-        nativeSetLink(nativePtr, columnIndex, value);
-    }
-
-    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
-
-    public void nullifyLink(long columnIndex) {
-        parent.checkImmutable();
-        nativeNullifyLink(nativePtr, columnIndex);
-    }
-
-    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
-
-    protected static native void nativeClose(long nativeRowPtr);
-
-    /**
-     * Checks if the row is still valid.
-     * @return Returns true {@code true} if the row is still valid and attached to the underlying
-     * data. {@code false} otherwise.
-     */
-    public boolean isAttached() {
-        return nativePtr != 0 && nativeIsAttached(nativePtr);
-    }
-
-    protected native boolean nativeIsAttached(long nativeRowPtr);
-
-    @Override
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeRow(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
-        nativeClose(nativePtr);
-        nativePtr = 0;
-    }
-}
diff --git a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
deleted file mode 100644
index 176d4b2291..0000000000
--- a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*package io.realm.internal;
-
-public class SharedGroupWithReplication extends SharedGroup {
-
-    public SharedGroupWithReplication()
-    {
-        super("", true);
-    }
-
-    public SharedGroupWithReplication(String databaseFile)
-    {
-        super(databaseFile, true);
-    }
-
-    public static String getDefaultDatabaseFileName()
-    {
-        return nativeGetDefaultReplicationDatabaseFileName();
-    }
-} */
diff --git a/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java b/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
deleted file mode 100644
index 0008b9085e..0000000000
--- a/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package io.realm.internal.android;
-
-import io.realm.internal.log.RealmLog;
-
-/**
- * RealmLogger for Android debug builds. This logs everything as default.
- */
-public class DebugAndroidLogger extends AndroidLogger {
-
-    public DebugAndroidLogger() {
-        setMinimumLogLevel(RealmLog.WARN);
-    }
-}
diff --git a/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java b/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
deleted file mode 100644
index 9620df711a..0000000000
--- a/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package io.realm.internal.android;
-
-import io.realm.internal.log.RealmLog;
-
-/**
- * This is the RealmLogger used by Realm in Release builds. It only logs warnings and errors by
- * default.
- */
-public class ReleaseAndroidLogger extends AndroidLogger {
-
-    public ReleaseAndroidLogger() {
-        setMinimumLogLevel(RealmLog.VERBOSE);
-    }
-}
diff --git a/realm/src/main/java/io/realm/internal/log/Logger.java b/realm/src/main/java/io/realm/internal/log/Logger.java
deleted file mode 100644
index c48f6affaf..0000000000
--- a/realm/src/main/java/io/realm/internal/log/Logger.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package io.realm.internal.log;
-
-/**
- * Interface for Realm logger implementations.
- */
-public interface Logger {
-    public void v(String message);
-    public void v(String message, Throwable t);
-    public void d(String message);
-    public void d(String message, Throwable t);
-    public void i(String message);
-    public void i(String message, Throwable t);
-    public void w(String message);
-    public void w(String message, Throwable t);
-    public void e(String message);
-    public void e(String message, Throwable t);
-}
diff --git a/settings.gradle b/settings.gradle
index d0eb92858e..18ddb94045 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,25 +1 @@
-// Realm projects
-include 'realm'
-
-// Example projects
-include ':introExample',
-        ':gridViewExample',
-        ':encryptionExample',
-        ':migrationExample',
-        ':adapterExample',
-        ':threadExample',
-		':jsonExample'
-
-
-project(':introExample').projectDir = new File('examples/introExample')
-project(':gridViewExample').projectDir = new File('examples/gridViewExample')
-project(':encryptionExample').projectDir = new File('examples/encryptionExample')
-project(':migrationExample').projectDir = new File('examples/migrationExample')
-project(':adapterExample').projectDir = new File('examples/adapterExample')
-project(':threadExample').projectDir = new File('examples/threadExample')
-project(':jsonExample').projectDir = new File('examples/jsonExample')
-
-// Experimental projects
-include ':pathExperiment'
-
-project(':pathExperiment').projectDir = new File('experimental/pathExperiment')
+rootProject.name = 'realm-java'
diff --git a/test/concurrencyExample/build.gradle b/test/concurrencyExample/build.gradle
deleted file mode 100644
index 7d080b3f8b..0000000000
--- a/test/concurrencyExample/build.gradle
+++ /dev/null
@@ -1,46 +0,0 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
-apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
-    defaultConfig {
-        applicationId 'examples.realm.io.concurrencyExample'
-        minSdkVersion 15
-        targetSdkVersion 19
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            runProguard false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    productFlavors {
-    }
-}
-
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
-tasks.preBuild {
-    dependsOn buildApt
-}
-
-dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    compile 'com.google.code.gson:gson:2.3'
-    compile project(':realm')
-}
diff --git a/test/concurrencyExample/proguard-rules.pro b/test/concurrencyExample/proguard-rules.pro
deleted file mode 100644
index 200fdffd58..0000000000
--- a/test/concurrencyExample/proguard-rules.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the proguardFiles
-# directive in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/test/concurrencyExample/src/main/AndroidManifest.xml b/test/concurrencyExample/src/main/AndroidManifest.xml
deleted file mode 100644
index cbd2562cf0..0000000000
--- a/test/concurrencyExample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.examples.concurrency">
-
-    <application
-        android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name"
-        android:theme="@style/AppTheme">
-        <activity
-            android:name=".RealmExampleActivity"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-
-        <service
-            android:name=".BgSpawningService"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:enabled="true"
-            android:exported="false"
-            android:label="Realm Service" />
-
-        <service
-            android:name=".BgService"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:enabled="true"
-            android:exported="false"
-            android:label="Realm Service" />
-    </application>
-
-</manifest>
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java
deleted file mode 100644
index 0c2edeecf4..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.content.Context;
-import android.util.Log;
-
-import java.util.List;
-
-import io.realm.Realm;
-import io.realm.RealmQuery;
-import io.realm.examples.service.model.Person;
-
-public class BgReaderThread extends Thread implements KillableThread {
-
-    public static final String TAG = BgReaderThread.class.getName();
-
-    private Context context = null;
-    private Realm realm = null;
-
-    public BgReaderThread(Context context) {
-        this.context = context;
-    }
-
-    public void run() {
-        realm = Realm.getInstance(context);
-
-        while (running) {
-            try {
-                RealmQuery realmQuery = realm.where(Person.class);
-                List<Person> list = realmQuery.findAll();
-                Log.d(TAG, "First item: " + realmQuery.findFirst());
-            } catch (Exception e) {
-                e.printStackTrace();
-                terminate();
-            }
-        }
-    }
-
-    private boolean running = true;
-
-    @Override
-    public void terminate() {
-        running = false;
-    }
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java
deleted file mode 100644
index 38e75625d3..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.IntentService;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.util.Log;
-
-import io.realm.Realm;
-import io.realm.RealmChangeListener;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class BgService extends IntentService {
-
-    public static final String TAG = BgService.class.getName();
-
-    private Boolean serviceQuitting = false;
-
-    public static final String REALM_FILE_EXTRA = "RealmFileExtra";
-
-    private Realm realm = null;
-
-    public BgService() {
-        super(BgSpawningService.class.getName());
-    }
-
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        Log.d(TAG, "Starting intent...");
-
-        realm = Realm.getInstance(this);
-        realm.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                Log.d(TAG, "RECEIVED_NOTIFICATION: " + Thread.currentThread().toString());
-            }
-        });
-
-        while(!serviceQuitting) {
-            int iterCount = 0;
-            realm.beginTransaction();
-            while (iterCount < 20 && serviceQuitting == false) {
-                if ((iterCount % 1000) == 0) {
-                    Log.d(TAG, "WR_OPERATION#: " + iterCount + "," + Thread.currentThread().getName());
-                }
-
-                Person person = realm.createObject(Person.class);
-                person.setName("New person");
-                iterCount++;
-            }
-            realm.commitTransaction();
-        }
-
-        Log.d(TAG, "Service has quit");
-    }
-
-    @Override
-    public void onDestroy() {
-        this.serviceQuitting = true;
-    }
-
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java
deleted file mode 100644
index 3563305603..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-import android.util.Log;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-public class BgSpawningService extends Service {
-
-    public static final String TAG = BgSpawningService.class.getName();
-
-    private Boolean serviceQuitting = false;
-
-    public static final String REALM_FILE_EXTRA = "RealmFileExtra";
-
-    private File realmPath = null;
-
-    private List<KillableThread> allThreads = null;
-
-    BgWriterThread wT = null;
-    BgReaderThread rT = null;
-
-    public void onCreate() {
-        super.onCreate();
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        this.realmPath = (File)intent.getSerializableExtra(REALM_FILE_EXTRA);
-        try {
-            allThreads = new ArrayList<KillableThread>();
-            wT = new BgWriterThread(this);
-            allThreads.add(wT);
-            wT.start();
-            rT = new BgReaderThread(this);
-            allThreads.add(rT);
-            rT.start();
-        } catch (Exception e) {
-            e.printStackTrace();
-            quit();
-        }
-        return START_STICKY;
-    }
-
-    @Override
-    public void onDestroy() {
-        quit();
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    private void quit() {
-        this.serviceQuitting = true;
-        for (KillableThread t : allThreads) {
-            t.terminate();
-        }
-    }
-
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java
deleted file mode 100644
index 1060bb582e..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.content.Context;
-import android.util.Log;
-
-import io.realm.Realm;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class BgWriterThread extends Thread implements KillableThread {
-
-    public static final String TAG = BgWriterThread.class.getName();
-
-    private Realm   realm   = null;
-    private Context context = null;
-
-    public BgWriterThread(Context context) {
-        this.context = context;
-    }
-
-    public void run() {
-        realm = Realm.getInstance(context);
-        int iterCount = 0;
-
-        realm.beginTransaction();
-        while (iterCount < 1000000 && running == true) {
-            if ((iterCount % 1000) == 0) {
-                Log.d(TAG, "WR_OPERATION#: " + iterCount + "," + Thread.currentThread().getName());
-            }
-
-            Person person = realm.createObject(Person.class);
-            person.setName("New person");
-//            person.setDog(realm.createObject(Dog.class));
-            iterCount++;
-        }
-        realm.commitTransaction();
-    }
-
-    private boolean running = true;
-
-    @Override
-    public void terminate() {
-        running = false;
-    }
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
deleted file mode 100644
index d7b924935d..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.RadioGroup;
-import android.widget.TextView;
-
-import io.realm.Realm;
-import io.realm.RealmList;
-import io.realm.examples.service.model.Cat;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class RealmExampleActivity extends Activity implements View.OnClickListener {
-
-    public static final String TAG = RealmExampleActivity.class.getName();
-
-    private Realm realm = null;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_realm_example);
-
-        findViewById(R.id.add_record_button).setOnClickListener(this);
-
-        realm = Realm.getInstance(getFilesDir());
-        initDb();
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        start();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-
-        stop();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.options_menu, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int id = item.getItemId();
-        if (id == R.id.action_reload) {
-            restart();
-            return true;
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public void onClick(View v) {
-        String personName = ((TextView) findViewById(R.id.name)).getText().toString();
-        String personAge = ((TextView) findViewById(R.id.age)).getText().toString();
-        String petName = ((TextView) findViewById(R.id.pets_name)).getText().toString();
-
-        Integer parseAge = 0;
-        try {
-            parseAge = Integer.parseInt(personAge);
-        } catch (NumberFormatException e) {
-
-        }
-
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName(personName);
-        person.setAge(parseAge);
-
-//        int checkedId = ((RadioGroup) findViewById(R.id.petType)).getCheckedRadioButtonId();
-//        if (checkedId == R.id.hasCat) {
-//            Cat cat = realm.createObject(Cat.class);
-//            cat.setName(petName);
-//            RealmList<Cat> cats = person.getCats();
-//            cats.add(cat);
-//        } else if (checkedId == R.id.hasDog) {
-//            Dog dog = realm.createObject(Dog.class);
-//            dog.setName(petName);
-//            person.setDog(dog);
-//        }
-
-        realm.commitTransaction();
-
-    }
-
-    //This is just to create the tables in Realm so that subsequent R/W operations do not fail
-    private void initDb() {
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName("Human Being");
-        person.setAge(32);
-//        Dog dog = realm.createObject(Dog.class);
-//        dog.setName("Fido");
-        realm.commitTransaction();
-    }
-
-    private void start() {
-        Intent serviceIntent = new Intent(this, BgService.class);
-        serviceIntent.putExtra(BgService.REALM_FILE_EXTRA, getFilesDir());
-        Log.d(TAG, "Starting service...");
-        this.startService(serviceIntent);
-    }
-
-    private void stop() {
-        Intent serviceIntent = new Intent(this, BgService.class);
-        Log.d(TAG, "Stopping service...");
-        this.stopService(serviceIntent);
-    }
-
-    private void restart() {
-        stop();
-        start();
-    }
-}
diff --git a/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5b8..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047dfa4..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760f0..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 4df1894644..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml b/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml
deleted file mode 100644
index 8f998c487e..0000000000
--- a/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml
+++ /dev/null
@@ -1,106 +0,0 @@
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="#ff797979"
-    android:orientation="vertical"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-
-        <TextView
-            android:id="@+id/update_message"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_margin="25dp"
-            android:gravity="center"
-            android:text="In the background there is a loop creating records."
-            android:textSize="24sp" />
-
-        <View
-            android:layout_width="match_parent"
-            android:layout_height="1dp"
-            android:layout_margin="12dp"
-            android:background="#ffcfcfcf" />
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:background="#ff1144aa"
-            android:orientation="vertical"
-            android:padding="20dp">
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_margin="7dp"
-                android:gravity="center"
-                android:text="You can also create records manually..."
-                android:textSize="22sp" />
-
-            <TextView
-                android:id="@+id/message_timestamp"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:gravity="center_horizontal"
-                android:text="Create a Record:"
-                android:textColor="#ffafafaf"
-                android:textSize="22sp" />
-
-            <View
-                android:layout_width="match_parent"
-                android:layout_height="1dp"
-                android:layout_margin="12dp"
-                android:background="#ffcfcfcf" />
-
-            <EditText
-                android:id="@+id/name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Name" />
-
-            <EditText
-                android:id="@+id/age"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Age" />
-
-            <RadioGroup
-                android:id="@+id/petType"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-                <RadioButton
-                    android:id="@+id/hasCat"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Cat" />
-
-                <RadioButton
-                    android:id="@+id/hasDog"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Dog" />
-            </RadioGroup>
-
-            <EditText
-                android:id="@+id/pets_name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Pets Name" />
-
-            <Button
-                android:id="@+id/add_record_button"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:text="Create Record" />
-
-        </LinearLayout>
-    </LinearLayout>
-</ScrollView>
diff --git a/test/concurrencyExample/src/main/res/menu/options_menu.xml b/test/concurrencyExample/src/main/res/menu/options_menu.xml
deleted file mode 100644
index 14c91e5706..0000000000
--- a/test/concurrencyExample/src/main/res/menu/options_menu.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    tools:context=".RealmGridLayoutActivity">
-    <item
-        android:id="@+id/action_reload"
-        android:orderInCategory="100"
-        android:showAsAction="never"
-        android:title="@string/action_reset" />
-</menu>
diff --git a/test/concurrencyExample/src/main/res/values/strings.xml b/test/concurrencyExample/src/main/res/values/strings.xml
deleted file mode 100644
index 4bd17c1af8..0000000000
--- a/test/concurrencyExample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">Realm Example</string>
-    <string name="action_reset">Restart</string>
-
-</resources>
diff --git a/tools/deploy-release.sh b/tools/deploy-release.sh
deleted file mode 100644
index bef16dba26..0000000000
--- a/tools/deploy-release.sh
+++ /dev/null
@@ -1,207 +0,0 @@
-#!/bin/bash
-#
-# This script packages, tests and deploys a release of Realm-Android.
-# For manual steps, see Asana release template.
-#
-
-set -e
-
-if [ $# -ne 2 ] ; then
-    echo "Usage: sh ./deploy-release.sh <old-version> <version>"
-    echo "Version could eg be \"0.74.1\""
-    exit 1
-fi
-
-old_realm_version=$1
-new_realm_version=$2
-release_branch=ci-release-${new_realm_version}
-doc_release_branch=ci-android-release-${new_realm_version}
-tag=v${new_realm_version}
-
-# Checks if the repository has any outstanding changes
-function check_clean_repo () {
-	if [ -n "$(git status --porcelain)" ]; then
-	  echo "FAILURE: $1 repository has uncommitted changes. Please make sure they are stashed or commited before continuing"
-	  exit 1
-	fi
-}
-
-# Fast forward repository master to newest version or fails if it is not possible
-function update_master () {
-	git checkout master
-
-	LOCAL=$(git rev-parse @)
-	REMOTE=$(git rev-parse @{u})
-	BASE=$(git merge-base @ @{u})
-
-	if [ $LOCAL = $REMOTE ]; then
-	    echo "Up-to-date"
-	elif [ $LOCAL = $BASE ]; then
-	    echo "Need to pull"
-        git pull
-	else
-	    echo "Cannot continue automatically. Manually make sure that master is up-to-date. Then run script again."
-	fi
-}
-
-# Cleanup branches from a previous release of the same version that failed for some reason
-function cleanup_failed_release () {
-	set +e
-	git show-ref --verify --quiet refs/heads/$1
-	if [ $? -eq 0 ] ; then
-		git branch -D $1
-	fi
-
-	if [ $# -eq 2 ] ; then
-		git rev-parse ${tag} --
-		if [ $? -eq 0 ]; then
-			git tag -d ${tag}
-		fi
-	fi
-	set -e
-}
-
-echo ""
-echo "Veryfying that repositories are up to date."
-echo ""
-
-# Make sure we are in root folder
-script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
-cd "${script_dir}/.."
-
-# Prepare realm-java repositorty
-check_clean_repo "realm-java"
-update_master
-cleanup_failed_release ${release_branch} ${tag}
-
-# Prepare realm.io repository
-if [ ! -d "../realm.io" ]; then
-  echo "Could not find the realm.io project. It should be in the same folder as realm-java."
-  exit 1
-fi
-cd ../realm.io
-check_clean_repo "realm.io"
-update_master
-cleanup_failed_release ${doc_release_branch}
-cd -
-
-echo ""
-echo "Starting deploy of Realm v.${new_realm_version}"
-echo ""
-
-echo "Updating version numbers from ${old_realm_version} to ${new_realm_version}"
-echo ""
-
-# Create new release branch
-git checkout -b ${release_branch}
-
-# Update version numbers
-printf ${new_realm_version} > ./version.txt
-sed -i.bak "s/${old_realm_version}/${new_realm_version}/" ./realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
-rm ./realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java.bak
-
-for dist in ./distribution/Realm*/ ; do
-	sed -i.bak "s/io.realm:realm-android:${old_realm_version}/io.realm:realm-android:${new_realm_version}/" ${dist}/app/build.gradle
-	rm ${dist}/app/build.gradle.bak
-done
-
-# Update date in changelog.txt
-sed -i.bak "s/^${new_realm_version}.*$/${new_realm_version} ($(date +'%d %b %Y'))/g" ./changelog.txt
-rm ./changelog.txt.bak
-
-# Test example projects
-result_code=$(sh ./tools/monkey-examples.sh)
-if [ "${result_code}" != "0" ] ; then
-	echo "Aborting release"
-	exit 1
-fi
-
-# Upgrading version number complete, check into release branch and push to GitHub
-git add .
-git commit -m "Updated version number to ${new_realm_version}"
-git tag -a ${tag} -m "Tag release v${new_realm_version}"
-git push origin ${release_branch}:${release_branch}
-git push origin ${tag}
-
-echo ""
-echo "Release branch has been pushed to GitHub. Make a manual pullrequest + merge."
-echo ""
-
-# Prepare distribution zip file
-sh ./build-distribution.sh
-dist_foldername=realm-java-${new_realm_version}
-dist_filename=realm-java-${new_realm_version}.zip
-cp -R ./distribution ./build/${dist_foldername}
-cd ./build
-zip -r ${dist_filename} ./${dist_foldername}
-cd -
-
-echo ""
-echo "Distribution zip file ready in realm-java/build/${dist_filename}"
-echo ""
-
-
-# Upload to binTray and release
-./gradlew realm:bintrayUpload
-
-echo ""
-echo "Artifacts uploaded to BinTray. Remember to manually release them."
-echo ""
-
-
-# Test distribution projects
-result_code=$(sh ./tools/monkey-distribution.sh)
-if [ "${result_code}" != "0" ] ; then
-	echo "Aborting release"
-	exit 1
-fi
-
-# Create new documentation
-# This assumes that realm-java and realm-io are located in the same folder
-echo ""
-echo "Creating JavaDoc for ${new_realm_version}"
-echo ""
-./gradlew clean realm:generateReleaseJavadoc
-
-echo ""
-echo "Preparing new version of the homepage docs"
-echo ""
-
-cd ../realm.io
-
-# Create release branch
-git checkout -b ${doc_release_branch}
-
-# Update documentation with new version
-cp ./docs/java/${old_realm_version}/index.md ./docs/java/${new_realm_version}/index.md
-sed -i.bak "s/${old_realm_version}/${new_realm_version}/g" ./docs/java/${new_realm_version}/index.md
-rm ./docs/java/${new_realm_version}/index.md.bak
-
-# Copy JavaDoc into place
-cp -R ../realm-java/realm/build/docs/javadoc/ ./docs/java/${new_realm_version}/api/
-
-# Rewire redirects in _config.yml
-old_doc_redirect="java: /docs/java/${old_realm_version}/"
-new_doc_redirect="java: /docs/java/${new_realm_version}/"
-old_dist_redirect="java: http://static.realm.io/downloads/java/realm-java-${old_realm_version}.zip"
-new_dist_redirect="java: http://static.realm.io/downloads/java/realm-java-${new_realm_version}.zip"
-
-sed -i.bak "s?${old_doc_redirect}?${new_doc_redirect}?" ./_config.yml
-rm ./_config.yml.bak
-sed -i.bak "s?${old_dist_redirect}?${new_dist_redirect}?" ./_config.yml
-rm ./_config.yml.bak
-
-# Add new documentation to GitHub
-git add .
-git commit -m "Added documentation for Realm-Java v${new_realm_version}"
-git push origin ${doc_release_branch}:${doc_release_branch}
-
-echo ""
-echo "Documentation has been pushed to GitHub. Make a manual pull request and merge."
-echo ""
-
-read -p "Deploy distribution file to S3 and update links pr. release template, then press [Enter] key to continue..."
-# TODO Upload distribution files to static.realm.io
-# TODO Rewire links on static.realm.io
-
-echo "Realm ${new_realm_version} has been deployed. Grab a beer!"
\ No newline at end of file
diff --git a/tools/deploy-to-bintray.sh b/tools/deploy-to-bintray.sh
deleted file mode 100644
index 63851c903f..0000000000
--- a/tools/deploy-to-bintray.sh
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/bash
-
-set -e
-
-# Make sure we are in root folder
-script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
-cd "${script_dir}/.."
-
-if [[ $# -ne 1 ]]; then
-    echo "Usage: sh ./deploy-to-bintray.sh <version>"
-    echo "Version could eg be \"0.74.1\""
-    exit 1
-fi
-
-version="$1"
-
-if ! [[ $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
-	echo "The provided version is not in a valid format. eg 0.74.1"
-	exit 1
-fi
-
-version_file_contents=$(<version.txt)
-if [[ $version_file_contents != $version ]]; then
-	echo "The provided version argument does not match the contents of the version.txt file"
-	exit 1
-fi
-
-length=${#version}
-beginning=$(head -c ${length} changelog.txt)
-if [[ $beginning != $version ]]; then
-	echo "The provided version argument does not match the beginning of the changelog.txt file"
-	exit 1
-fi
-
-version_checker_file="realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java"
-
-if ! grep -q "$version" "$version_checker_file"; then
-	echo "The version checker file does not contain the provided version"
-fi
-
-./gradlew realm:bintrayUpload
\ No newline at end of file
diff --git a/tools/monkey-distribution.sh b/tools/monkey-distribution.sh
deleted file mode 100644
index 03e864530c..0000000000
--- a/tools/monkey-distribution.sh
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/bin/bash
-#
-# Runs Android monkey tool on all distribution projects. Using this script before using
-# build-distribution.sh will fail.
-#
-# Note: adb shell always return exit code 0: https://code.google.com/p/android/issues/detail?id=3254
-# Solution for now: Write exit code to file and read it from there
-#
-
-# Make sure we are in realm-java root dir
-script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
-cd "${script_dir}/.."
-
-TEST_EVENTS=2000;
-
-echo ""
-echo "Testing distribution examples"
-echo ""
-for dist in distribution/Realm*/ ; do
-
-    applicationId=$(grep applicationId "${dist}app/build.gradle" | cut -d \" -f 2 | cut -d \' -f 2)
-    project=$(basename ${dist})
-
-    echo "Building ${dist}"
-    adb uninstall ${applicationId} > /dev/null
-    cd ${dist}
-    ./gradlew clean installDebug
-    cd -
-
-    echo "Letting monkey loose in $dist"
-    adb shell "monkey -p ${applicationId} -v ${TEST_EVENTS} ; echo \"\$?\\c\" > /data/local/tmp/${applicationId}.exitcode"
-    rc=$(adb shell cat /data/local/tmp/${applicationId}.exitcode)
-    echo ""
-    if [ "${rc}" != "0" ] ; then
-        echo ""
-        echo "Monkey found an error, stopping tests."
-        echo "Remember to call build-distribution.sh before running this test."
-        echo "Reproduce: adb shell monkey -s <seed> -p ${applicationId} -v ${TEST_EVENTS}"
-        echo "Exit code: ${rc}"
-        exit 1
-    fi
-done
-
-echo ""
-echo "Distribution monkeys are happy"
-echo ""
\ No newline at end of file
diff --git a/tools/templates/RealmAdapterExample/build.gradle b/tools/templates/RealmAdapterExample/build.gradle
deleted file mode 100644
index c637978dfd..0000000000
--- a/tools/templates/RealmAdapterExample/build.gradle
+++ /dev/null
@@ -1,30 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmadapterexample"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/tools/templates/RealmEncryptionExample/build.gradle b/tools/templates/RealmEncryptionExample/build.gradle
deleted file mode 100644
index ab55aaca1a..0000000000
--- a/tools/templates/RealmEncryptionExample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmencryptionexample"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/tools/templates/RealmGridViewExample/build.gradle b/tools/templates/RealmGridViewExample/build.gradle
deleted file mode 100644
index 2b266e5a71..0000000000
--- a/tools/templates/RealmGridViewExample/build.gradle
+++ /dev/null
@@ -1,30 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmgridview"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-    compile 'com.google.code.gson:gson:2.3'
-}
diff --git a/tools/templates/RealmIntroExample/build.gradle b/tools/templates/RealmIntroExample/build.gradle
deleted file mode 100644
index bd68711c88..0000000000
--- a/tools/templates/RealmIntroExample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmintroexample"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/tools/templates/RealmJsonExample/build.gradle b/tools/templates/RealmJsonExample/build.gradle
deleted file mode 100644
index 857427970f..0000000000
--- a/tools/templates/RealmJsonExample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.json"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/tools/templates/RealmMigrationExample/build.gradle b/tools/templates/RealmMigrationExample/build.gradle
deleted file mode 100644
index b53ad5982b..0000000000
--- a/tools/templates/RealmMigrationExample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 20
-    buildToolsVersion "20.0.0"
-
-    defaultConfig {
-        applicationId "io.realm.examples.realmmigrationexample"
-        minSdkVersion 14
-        targetSdkVersion 20
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/tools/templates/RealmThreadExample/build.gradle b/tools/templates/RealmThreadExample/build.gradle
deleted file mode 100644
index 082031b0e3..0000000000
--- a/tools/templates/RealmThreadExample/build.gradle
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-apply plugin: 'android-sdk-manager'
-apply plugin: 'com.android.application'
-apply plugin: 'android-command'
-
-android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.1"
-
-    defaultConfig {
-        applicationId "io.realm.examples.threads"
-        minSdkVersion 15
-        targetSdkVersion 21
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    command {
-        events 2000
-    }
-}
-
-dependencies {
-    compile 'com.android.support:appcompat-v7:21.0.+'
-    compile 'io.realm:realm-android:@version@'
-}
diff --git a/version.txt b/version.txt
index 4583081037..91ef265118 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.80.3
\ No newline at end of file
+0.89.0-SNAPSHOT
