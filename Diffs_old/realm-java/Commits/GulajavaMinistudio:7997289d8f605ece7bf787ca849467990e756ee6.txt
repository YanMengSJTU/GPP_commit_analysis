diff --git a/CHANGELOG.md b/CHANGELOG.md
index 894ba9713a..abbd226473 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 5.?.? (2018-mm-dd)
+## 5.?.? (2018-MM-DD)
 
 ### Enhancements
 * None
@@ -15,6 +15,26 @@
 * None
 
 
+## 5.8.0 (YYYY-MM-DD)
+
+### Enhancements
+* [ObjectServer] Added Subscription class available to Query-based Realms. This exposes a Subscription more directly. This class is in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+* [ObjectServer] Added `Realm.getSubscriptions()`, `Realm.getSubscriptions(String pattern)` and `Realm.getSubscription` to make it easier to find existing subscriptions. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+* [ObjectServer] Added `RealmQuery.subscribe()` and `RealmQuery.subscribe(String name)` to subscribe immediately inside a transaction. These API's are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+* [ObjectServer] Added support for subscribing directly inside `SyncConfiguration.initialData()`. This can be coupled with `SyncConfiguration.waitForInitialRemoteData()` in order to block a Realm from opening until the initial subscriptions are ready and have downloaded data. This API are in beta. [#6231](https://github.com/realm/realm-java/pull/6231).
+
+### Fixed
+* ?? (Issue [#??](https://github.com/realm/realm-java/issues/??), since ??).
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* None
+
+
 ## 5.7.1 (2018-10-22)
 
 ### Enhancements
@@ -29,7 +49,7 @@
 * APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
 
 ### Internal
-* None
+* Updated to Object Store commit: 362b886628b3aefc5b7a0bc32293d794dc1d4ad5
 
 
 ## 5.7.0 (2018-09-24)
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index eb4b1c96ff..5a5d451546 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -39,5 +39,8 @@
     <Match>
         <Class name="io.realm.io_realm_sync_permissions_PermissionUserRealmProxy"/>
     </Match>
+    <Match>
+        <Class name="io.realm.io_realm_sync_SubscriptionRealmProxy"/>
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 573c1e21d7..6dba5227a9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -695,19 +695,27 @@ public void onSuccess(DynamicRealm realm) {
     @Test
     @RunTestInLooperThread
     public void getInstanceAsync_nullConfigShouldThrow() {
-        thrown.expect(IllegalArgumentException.class);
-        DynamicRealm.getInstanceAsync(null, new DynamicRealm.Callback() {
-            @Override
-            public void onSuccess(DynamicRealm realm) {
-                fail();
-            }
-        });
+        try {
+            //noinspection ConstantConditions
+            DynamicRealm.getInstanceAsync(null, new DynamicRealm.Callback() {
+                @Override
+                public void onSuccess(DynamicRealm realm) {
+                    fail();
+                }
+            });
+        } catch (IllegalArgumentException ignored) {
+        }
+        looperThread.testComplete();
     }
 
     @Test
     @RunTestInLooperThread
     public void getInstanceAsync_nullCallbackShouldThrow() {
-        thrown.expect(IllegalArgumentException.class);
-        DynamicRealm.getInstanceAsync(defaultConfig, null);
+        try {
+            //noinspection ConstantConditions
+            DynamicRealm.getInstanceAsync(defaultConfig, null);
+        } catch (IllegalArgumentException ignored) {
+        }
+        looperThread.testComplete();
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index 9d881dd773..0280be4916 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -475,17 +475,18 @@ public void execute(Realm realm) {
         });
 
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
-        try {
-            final DynamicRealmObject targetAsync = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
-                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirstAsync();
-            // precondition
-            assertFalse(targetAsync.isLoaded());
+        looperThread.closeAfterTest(dynamicRealm);
+        final DynamicRealmObject targetAsync = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirstAsync();
+        // precondition
+        assertFalse(targetAsync.isLoaded());
 
-            thrown.expect(IllegalStateException.class);
+        try {
             targetAsync.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
-        } finally {
-            dynamicRealm.close();
+            fail();
+        } catch (IllegalStateException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
@@ -505,25 +506,26 @@ public void execute(Realm realm) {
         });
 
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
-        try {
-            final DynamicRealmObject target = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
-                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
+        looperThread.closeAfterTest(dynamicRealm);
+        final DynamicRealmObject target = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
 
-            dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
-                @Override
-                public void execute(DynamicRealm realm) {
-                    target.deleteFromRealm();
-                }
-            });
+        dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                target.deleteFromRealm();
+            }
+        });
 
-            // precondition
-            assertFalse(target.isValid());
+        // precondition
+        assertFalse(target.isValid());
 
-            thrown.expect(IllegalStateException.class);
+        try {
             target.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
-        } finally {
-            dynamicRealm.close();
+            fail();
+        } catch (IllegalStateException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index ef0e68ffbc..2b6b8c5019 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -434,10 +434,13 @@ public void execute(Realm realm) {
         // precondition
         assertFalse(targetAsync.isLoaded());
 
-        thrown.expect(IllegalStateException.class);
-        //noinspection ResultOfMethodCallIgnored
-        targetAsync.getParents();
-        fail();
+        try {
+            //noinspection ResultOfMethodCallIgnored
+            targetAsync.getParents();
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+        looperThread.testComplete();
     }
 
     @Test
@@ -471,10 +474,13 @@ public void execute(Realm realm) {
         // precondition
         assertFalse(target.isValid());
 
-        thrown.expect(IllegalStateException.class);
-        //noinspection ResultOfMethodCallIgnored
-        target.getParents();
-        fail();
+        try {
+            //noinspection ResultOfMethodCallIgnored
+            target.getParents();
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+        looperThread.testComplete();
     }
 
     @Test
@@ -509,10 +515,13 @@ public void execute(Realm realm) {
         // precondition
         assertFalse(target.isValid());
 
-        thrown.expect(IllegalStateException.class);
-        //noinspection ResultOfMethodCallIgnored
-        target.getParents();
-        fail();
+        try {
+            //noinspection ResultOfMethodCallIgnored
+            target.getParents();
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+        looperThread.testComplete();
     }
 
     /**
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 09a982160e..bc0c9a3a10 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -462,7 +462,6 @@ public void onSuccess() {
             public void run() {
                 // Manually call refresh, so the did_change will be triggered.
                 foregroundRealm.sharedRealm.refresh();
-                foregroundRealm.setAutoRefresh(true);
             }
         });
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 8ab30fc5a1..453cadea35 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -4322,6 +4322,7 @@ public void onSuccess(Realm realm) {
                 fail();
             }
         });
+        looperThread.testComplete();
     }
 
     @Test
@@ -4329,6 +4330,7 @@ public void onSuccess(Realm realm) {
     public void getInstanceAsync_nullCallbackShouldThrow() {
         thrown.expect(IllegalArgumentException.class);
         Realm.getInstanceAsync(realmConfig, null);
+        looperThread.testComplete();
     }
 
     // Verify that the logic for waiting for the users file dir to be come available isn't totally broken
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
index cc70851ced..f0945fbdc6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
@@ -43,7 +43,8 @@
  * - @Before()
  * - @RunTestInLooperThread/@Test
  * - @After : This is called when exiting the test method. Warning: Looper test is still running.
- * - looperThread.runAfterTest(Runnable) : This is called when the LooperTest either succeed or fails.
+ * - looperThread.runAfterTest(Runnable) : This is called when `testComplete()` is called. This can
+ *   be both before and after `@After` has run.
  */
 
 @RunWith(AndroidJUnit4.class)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index 0e3d29d2df..37fd95afd7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -57,15 +57,10 @@
 
     @Rule
     public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
     @Rule
-    public final RunInLooperThread looperThread = new RunInLooperThread() {
-        @Override
-        public void looperTearDown() {
-            if (subscription != null && !subscription.isDisposed()) {
-                subscription.dispose();
-            }
-        }
-    };
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
@@ -76,6 +71,11 @@ public void looperTearDown() {
     public void setUp() throws Exception {
         // For non-LooperThread tests.
         realm = Realm.getInstance(configFactory.createConfiguration());
+        looperThread.runAfterTest(() -> {
+            if (subscription != null && !subscription.isDisposed()) {
+                subscription.dispose();
+            }
+        });
     }
 
     @After
@@ -936,30 +936,16 @@ public void realmResults_gcStressTest() {
         realm.commitTransaction();
 
         for (int i = 0; i < TEST_SIZE; i++) {
-            // Doesn't keep a reference to the Observable.
             realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asFlowable()
-                    .filter(new Predicate<RealmResults<AllTypes>>() {
-                        @Override
-                        public boolean test(RealmResults<AllTypes> results) throws Exception {
-                            return results.isLoaded();
-                        }
-                    })
+                    .filter(results -> results.isLoaded())
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Consumer<RealmResults<AllTypes>>() {
-                        @Override
-                        public void accept(RealmResults<AllTypes> allTypes) throws Exception {
-                            // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
-                            Runtime.getRuntime().gc();
-                            if (innerCounter.incrementAndGet() == TEST_SIZE) {
-                                looperThread.testComplete();
-                            }
-                        }
-                    }, new Consumer<Throwable>() {
-                        @Override
-                        public void accept(Throwable throwable) throws Exception {
-                            fail(throwable.toString());
+                    .subscribe(allTypes -> {
+                        // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
+                        Runtime.getRuntime().gc();
+                        if (innerCounter.incrementAndGet() == TEST_SIZE) {
+                            looperThread.testComplete();
                         }
-                    });
+                    }, throwable -> fail(throwable.toString()));
         }
     }
 
@@ -972,6 +958,7 @@ public void dynamicRealmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
         final DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(realm);
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -995,7 +982,6 @@ public void accept(RealmResults<DynamicRealmObject> dynamicRealmObjects) throws
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
-                                realm.close();
                                 looperThread.testComplete();
                             }
                         }
@@ -1061,6 +1047,7 @@ public void dynamicRealmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
         final DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(realm);
 
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -1084,7 +1071,6 @@ public void accept(DynamicRealmObject dynamicRealmObject) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
-                                realm.close();
                                 looperThread.testComplete();
                             }
                         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index 86f42ff0fc..9c5cfcf4eb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -100,8 +100,8 @@ public void addChangeListener_byLocalChanges() {
             public void onChange(OsSharedRealm sharedRealm) {
                 // Transaction has been committed in core, but commitTransaction hasn't returned in java.
                 assertFalse(commitReturns.get());
-                looperThread.testComplete();
                 sharedRealm.close();
+                looperThread.testComplete();
             }
         });
         sharedRealm.beginTransaction();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 82be4408c3..101423ac7b 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -95,6 +95,8 @@ public void tearDown() {
             userStore.remove(syncUser.getIdentity(), syncUser.getAuthenticationUrl().toString());
         }
         SyncManager.reset();
+        BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        Realm.init(InstrumentationRegistry.getTargetContext());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java
new file mode 100644
index 0000000000..53ff16cdc3
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmQueryTests.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.rule.RunInLooperThread;
+import io.realm.sync.Subscription;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Testing sync specific methods on {@link RealmQuery}.
+ */
+@RunWith(AndroidJUnit4.class)
+public class SyncedRealmQueryTests {
+
+    @Rule
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+
+    @After
+    public void tearDown() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
+        if (dynamicRealm != null && !dynamicRealm.isClosed()) {
+            dynamicRealm.close();
+        }
+        for (SyncUser user : SyncUser.all().values()) {
+            user.logOut();
+        }
+    }
+
+    private Realm getPartialRealm() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/partialSync")
+                .build();
+        realm = Realm.getInstance(config);
+        return realm;
+    }
+
+    private Realm getFullySyncRealm() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/fullSync")
+                .fullSynchronization()
+                .build();
+        realm = Realm.getInstance(config);
+        return realm;
+    }
+
+    @Test
+    public void subscribe() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Subscription sub = query.subscribe();
+        assertTrue(sub.getName().startsWith("[AllTypes] "));
+        assertEquals(Subscription.State.PENDING, sub.getState());
+        assertEquals("", sub.getErrorMessage());
+        assertEquals(query.getDescription(), sub.getQueryDescription());
+        assertEquals("AllTypes", sub.getQueryClassName());
+    }
+
+    @Test
+    public void subscribe_withName() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "foo");
+        Subscription sub = query.subscribe("sub");
+        assertEquals("sub", sub.getName());
+        assertEquals(Subscription.State.PENDING, sub.getState());
+        assertEquals("", sub.getErrorMessage());
+        assertEquals(query.getDescription(), sub.getQueryDescription());
+        assertEquals("AllTypes", sub.getQueryClassName());
+    }
+
+    @Test
+    public void subscribe_throwIfNameIsAlreadyUsed() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        realm.where(Dog.class).subscribe("foo");
+        try {
+            realm.where(AllTypes.class).subscribe("foo");
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribe_throwOnDynamicRealm() {
+        getPartialRealm().close(); // Build schema
+        dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dynamicRealm.beginTransaction();
+        RealmQuery<DynamicRealmObject> query = dynamicRealm.where(AllTypes.CLASS_NAME);
+        try {
+            query.subscribe("sub");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribe_throwIfOutsideWriteTransaction() {
+        realm = getPartialRealm();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        try {
+            query.subscribe("sub");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribe_throwIfBasedOnList() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class).getColumnRealmList().add(new Dog("fido"));
+        RealmQuery<Dog> query = realm.where(AllTypes.class).findFirst().getColumnRealmList().where();
+        try {
+            query.subscribe("sub");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribe_throwIfNonPartialRealm() {
+        realm = getFullySyncRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        try {
+            query.subscribe("sub");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
+    @Test
+    public void subscribe_throwIfRealmClosed() {
+        realm = getPartialRealm();
+        realm.beginTransaction();
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+        realm.close();
+        try {
+            query.subscribe("sub");
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
index d1f1f9e5a7..77954d7691 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmTests.java
@@ -32,8 +32,11 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.sync.Subscription;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -253,4 +256,57 @@ public boolean shouldCompact(long totalBytes, long usedBytes) {
         assertTrue(originalSize > compactedSize);
     }
 
+    @Test
+    public void getSubscriptions() {
+        realm = getPartialRealm();
+        RealmResults<Subscription> subscriptions = realm.getSubscriptions();
+        assertEquals(0, subscriptions.size());
+
+        realm.executeTransaction(r -> {
+            r.where(AllTypes.class).subscribe("sub1");
+        });
+
+        assertEquals(1, subscriptions.size());
+        assertEquals("sub1", subscriptions.first().getName());
+    }
+
+    @Test
+    public void getSubscriptions_withPattern() {
+        realm = getPartialRealm();
+        assertEquals(0, realm.getSubscriptions("sub?").size());
+
+        realm.executeTransaction(r -> {
+            r.where(AllTypes.class).subscribe("sub1");
+            r.where(AllTypes.class).subscribe("sub2");
+        });
+
+        assertEquals(0, realm.getSubscriptions("sub").size());
+        assertEquals(2, realm.getSubscriptions("sub?").size());
+        assertEquals(2, realm.getSubscriptions("s*").size());
+    }
+
+    @Test
+    public void getSubscriptions_withPattern_throwsIfNullPattern() {
+        realm = getPartialRealm();
+        try {
+            //noinspection ConstantConditions
+            realm.getSubscriptions(null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void getSubscription() {
+        realm = getPartialRealm();
+        assertNull(realm.getSubscription("sub"));
+
+        realm.executeTransaction(r -> {
+            r.where(AllTypes.class).subscribe("sub");
+        });
+
+        Subscription sub = realm.getSubscription("sub");
+        assertNotNull(sub);
+        assertEquals("sub", sub.getName());
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 5430185427..5672cdb318 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -56,6 +56,7 @@ endif()
 string(TOLOWER ${CMAKE_BUILD_TYPE} build_type_FOLDER)
 set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/${REALM_FLAVOR}/${build_type_FOLDER}/)
 set(classes_LIST
+    io.realm.RealmQuery
     io.realm.internal.Table io.realm.internal.CheckedRow
     io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.OsSharedRealm io.realm.internal.TestUtil
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
new file mode 100644
index 0000000000..03c66b6b49
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_RealmQuery.h"
+
+#include <results.hpp>
+#include <shared_realm.hpp>
+#if REALM_ENABLE_SYNC
+#include <sync/partial_sync.hpp>
+#endif
+
+#include "util.hpp"
+
+
+using namespace realm;
+
+JNIEXPORT jstring JNICALL Java_io_realm_RealmQuery_nativeSerializeQuery(JNIEnv* env, jclass, jlong table_query_ptr, jlong descriptor_ptr)
+{
+    TR_ENTER()
+    try {
+        auto query = reinterpret_cast<Query*>(table_query_ptr);
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        std::string serialized_query = query->get_description() + " " + descriptor->get_description(query->get_table());
+        return to_jstring(env, serialized_query);
+    }
+    CATCH_STD()
+    return to_jstring(env, "");
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_RealmQuery_nativeSubscribe(JNIEnv* env, jclass, jlong shared_realm_ptr, jstring j_name, jlong table_query_ptr, jlong descriptor_ptr)
+{
+    TR_ENTER()
+    try {
+        auto realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+        auto name = util::Optional<std::string>(JStringAccessor(env, j_name));
+        auto query = reinterpret_cast<Query*>(table_query_ptr);
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        Results r(realm, *query, *descriptor);
+#if REALM_ENABLE_SYNC
+        RowExpr row = partial_sync::subscribe_blocking(r, name);
+        return to_jlong_or_not_found(row.get_index());
+#endif
+    }
+    CATCH_STD()
+    return realm::npos;
+}
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 7e19c51af7..1f91c82eb3 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 7e19c51af72c3343b453b8a13c82dfda148e4bbc
+Subproject commit 1f91c82eb34cf4eaa2900794a9268390876f19f1
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index bc44a9303c..23371bb901 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -30,9 +30,14 @@
 #include "results.hpp"
 #include "list.hpp"
 #include "java_exception_def.hpp"
+#if REALM_ENABLE_SYNC
+#include "sync/partial_sync.hpp"
+#endif
 
 #include "jni_util/java_exception_thrower.hpp"
 
+
+
 using namespace std;
 using namespace realm;
 using namespace realm::util;
@@ -120,6 +125,14 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         }
         ThrowException(env, kind, e.what());
     }
+#if REALM_ENABLE_SYNC
+    catch (partial_sync::InvalidRealmStateException& e) {
+        ThrowException(env, IllegalState, e.what());
+    }
+    catch (partial_sync::ExistingSubscriptionException& e) {
+        ThrowException(env, IllegalArgument, e.what());
+    }
+#endif
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
     }
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 83b0bd14bd..67f6caf905 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -121,7 +121,8 @@ public void onSchemaChanged() {
             initializationCallback = new OsSharedRealm.InitializationCallback() {
                 @Override
                 public void onInit(OsSharedRealm sharedRealm) {
-                    initialDataTransaction.execute(Realm.createInstance(sharedRealm));
+                    Realm instance = Realm.createInstance(sharedRealm);
+                    initialDataTransaction.execute(instance);
                 }
             };
         }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index f1d21efeaf..8a4b8b2ff3 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -72,6 +72,7 @@
 import io.realm.internal.annotations.ObjectServer;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
+import io.realm.sync.Subscription;
 import io.realm.sync.permissions.ClassPermissions;
 import io.realm.sync.permissions.ClassPrivileges;
 import io.realm.sync.permissions.RealmPermissions;
@@ -1866,6 +1867,47 @@ public ClassPermissions getPermissions(Class<? extends RealmModel> clazz) {
                 .findFirst();
     }
 
+    /**
+     * Returns a list of all known subscriptions, regardless of their status.
+     *
+     * @return a list of all known subscriptions.
+     */
+    @Beta
+    @ObjectServer
+    public RealmResults<Subscription> getSubscriptions() {
+        return where(Subscription.class).findAll();
+    }
+
+    /**
+     * Returns a list of all subscriptions that match a given pattern. {@code *} can be used to
+     * indicate any number of unknown characters and {@code ?} represents a single unknown character.
+     *
+     * @param pattern which subscriptions to find.
+     * @return list of subscriptions that match the pattern.
+     * @throws IllegalArgumentException if an empty or {@code null} pattern is provided.
+     */
+    @Beta
+    @ObjectServer
+    public RealmResults<Subscription> getSubscriptions(String pattern) {
+        if (Util.isEmptyString(pattern)) {
+            throw new IllegalArgumentException("Non-empty 'pattern' required");
+        }
+        return where(Subscription.class).like("name", pattern).findAll();
+    }
+
+    /**
+     * Returns the first subscription that matches the given name.
+     *
+     * @param name the name of the subscription to find.
+     * @return returns the subscription that matches the name or {@code null} if no subscription matches the name.
+     */
+    @Beta
+    @ObjectServer
+    @Nullable
+    public Subscription getSubscription(String name) {
+        return where(Subscription.class).equalTo("name", name).findFirst();
+    }
+
     Table getTable(Class<? extends RealmModel> clazz) {
         return schema.getTable(clazz);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 3dac06e938..4434c7d9d1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -15,6 +15,8 @@
  */
 package io.realm;
 
+import android.os.SystemClock;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -286,35 +288,32 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
             Class<E> realmClass) {
 
         RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+        boolean firstRealmInstanceInProcess = (getTotalGlobalRefCount() == 0);
+        boolean realmFileIsBeingCreated = !configuration.realmExists();
 
-        if (getTotalGlobalRefCount() == 0) {
+        if (firstRealmInstanceInProcess) {
             copyAssetFileIfNeeded(configuration);
-            boolean fileExists = configuration.realmExists();
-
             OsSharedRealm sharedRealm = null;
             try {
                 if (configuration.isSyncConfiguration()) {
                     // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
                     // before proceeding. We need to open the Realm instance first to start any potential underlying
-                    // SyncSession so this will work. TODO: This needs to be decoupled.
-                    if (!fileExists) {
+                    // SyncSession so this will work.
+                    if (realmFileIsBeingCreated) {
                         sharedRealm = OsSharedRealm.getInstance(configuration);
                         try {
-                            ObjectServerFacade.getSyncFacadeIfPossible().downloadRemoteChanges(configuration);
+                            ObjectServerFacade.getSyncFacadeIfPossible().downloadInitialRemoteChanges(configuration);
                         } catch (Throwable t) {
                             // If an error happened while downloading initial data, we need to reset the file so we can
                             // download it again on the next attempt.
                             sharedRealm.close();
                             sharedRealm = null;
-                            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
-                            //        closed for now.
-                            // https://github.com/realm/realm-java/issues/5416
-                            BaseRealm.deleteRealm(configuration);
+                            deleteRealmFileOnDisk(configuration);
                             throw t;
                         }
                     }
                 } else {
-                    if (fileExists) {
+                    if (!realmFileIsBeingCreated) {
                         // Primary key problem only exists before we release sync.
                         sharedRealm = OsSharedRealm.getInstance(configuration);
                         Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
@@ -326,7 +325,7 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
                 }
             }
 
-            // We are holding the lock, and we can set the invalidated configuration since there is no global ref to it.
+            // We are holding the lock, and we can set the valid configuration since there is no global ref to it.
             this.configuration = configuration;
         } else {
             // Throws exception if validation failed.
@@ -340,6 +339,13 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
                 realm = Realm.createInstance(this);
+
+                // If `waitForInitialRemoteData` data is set, we also want to ensure that all subscriptions
+                // are fully ACTIVE before proceeding. Most of the Realm is initialized during a write
+                // transaction. So we cannot download subscription data until all other initializers have run.
+                // At this point we also have access to all normal APIs as the schema is fully initialized.
+                synchronizeInitialSubscriptionsIfNeeded((Realm) realm, realmFileIsBeingCreated);
+
             } else if (realmClass == DynamicRealm.class) {
                 realm = DynamicRealm.createInstance(this);
             } else {
@@ -361,6 +367,57 @@ private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
         return (E) refAndCount.localRealm.get();
     }
 
+    /**
+     * Synchronize all initial subscriptions to disk (if needed).
+     *
+     * If activating the subscriptions fails for a new Realm file, the file will be deleted so a new
+     * attempt can be done later. Old Realm files will be left alone.
+     *
+     * This method is not threadsafe. Synchronization should happen outside it.
+     *
+     * @param realm Realm instance to synchronize instances for. It is safe to close this Realm if an exception is thrown.
+     * @param  {@code true} if the file existed on disk before trying to open the Realm.
+     */
+    private static void synchronizeInitialSubscriptionsIfNeeded(Realm realm, boolean realmFileIsBeingCreated) {
+        if (realmFileIsBeingCreated) {
+            try {
+                ObjectServerFacade.getSyncFacadeIfPossible().downloadInitialSubscriptions(realm);
+            } catch (Throwable t) {
+                realm.close();
+                deleteRealmFileOnDisk(realm.getConfiguration());
+            }
+        }
+    }
+
+    /**
+     * Attempts to delete the underlying Realm. Any errors happening here will just be
+     * outputted to logcat instead of thrown as this method is only called from other exception
+     * handlers which have more important exceptions to show to the user.
+     *
+     * This method is not threadsafe. Synchronization should happen outside it.
+     */
+    private static void deleteRealmFileOnDisk(RealmConfiguration configuration) {
+        // FIXME: We don't have a way to ensure that the Realm instance on client thread has been closed for now.
+        // https://github.com/realm/realm-java/issues/5416
+        int attempts = 5;
+        boolean success = false;
+        while (attempts > 0 && !success) {
+            try {
+                success = BaseRealm.deleteRealm(configuration);
+            } catch (IllegalStateException e) {
+                attempts--;
+                RealmLog.warn("Sync server still holds a reference to the Realm. It cannot be deleted. Retrying " + attempts + " more times");
+                if (attempts > 0) {
+                    SystemClock.sleep(15);
+                }
+            }
+        }
+
+        if (!success) {
+            RealmLog.error("Failed to delete the underlying Realm file: " + configuration.getPath());
+        }
+    }
+
     /**
      * Releases a given {@link Realm} or {@link DynamicRealm} from cache. The instance will be closed by this method
      * if there is no more local reference to this Realm instance in current Thread.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index d1e51d662d..55dff041d2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -17,16 +17,23 @@
 package io.realm;
 
 
+import android.text.TextUtils;
+
 import java.util.Collections;
 import java.util.Date;
 import java.util.Locale;
 
 import javax.annotation.Nullable;
 
+import io.realm.annotations.Beta;
 import io.realm.annotations.Required;
+import io.realm.internal.CheckedRow;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.OsList;
 import io.realm.internal.OsResults;
 import io.realm.internal.PendingRow;
+import io.realm.internal.UncheckedRow;
+import io.realm.internal.annotations.ObjectServer;
 import io.realm.internal.core.QueryDescriptor;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -37,6 +44,7 @@
 import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.fields.FieldDescriptor;
 import io.realm.internal.sync.SubscriptionAction;
+import io.realm.sync.Subscription;
 
 
 /**
@@ -2007,6 +2015,63 @@ public Realm getRealm() {
         return (Realm) realm;
     }
 
+    /**
+     * Creates an anonymous subscription from this query or returns the existing Subscription if
+     * one already existed.
+     *
+     * @return the subscription representing this query.
+     * @throws IllegalStateException if this method is not called inside a write transaction or if
+     * the query is on a {@link DynamicRealm}
+     */
+    @ObjectServer
+    @Beta
+    public Subscription subscribe() {
+        StringBuilder sb = new StringBuilder("[");
+        sb.append((table != null) ? table.getClassName() : "");
+        sb.append("] ");
+        sb.append(nativeSerializeQuery(query.getNativePtr(), queryDescriptors.getNativePtr()));
+        String name = sb.toString();
+        return subscribe(name);
+    }
+
+    /**
+     * Creates an anonymous subscription from this query or returns the existing Subscription if
+     * one already existed.
+     *
+     * @return the name of the query.
+     * @return the subscription representing this query.
+     * @throws IllegalStateException if this method is not called inside a write transaction, if
+     * the query is on a {@link DynamicRealm} or a {@link RealmList}.
+     * @throws IllegalArgumentException if a subscription for a different query with the same name
+     * already exists.
+     */
+    @ObjectServer
+    @Beta
+    public Subscription subscribe(String name) {
+        realm.checkIfValid();
+        if (realm instanceof DynamicRealm) {
+            throw new IllegalStateException("'subscribe' is not supported for queries on Dynamic Realms.");
+        }
+        if (osList != null) {
+            throw new IllegalStateException("Cannot create subscriptions for queries based on a 'RealmList. Subscribe to the object holding the list instead.'");
+        }
+        if (TextUtils.isEmpty(name)) {
+            throw new IllegalArgumentException("Non-empty 'name' required.");
+        }
+        long rowIndex = nativeSubscribe(realm.getSharedRealm().getNativePtr(), name, query.getNativePtr(), queryDescriptors.getNativePtr());
+        CheckedRow row = ((Realm) realm).getTable(Subscription.class).getCheckedRow(rowIndex);
+        return realm.get(Subscription.class, null, row);
+    }
+
+    /**
+     * Returns a textual description of this query.
+     *
+     * @return the textual description of the query.
+     */
+    public String getDescription() {
+        return nativeSerializeQuery(query.getNativePtr(), queryDescriptors.getNativePtr());
+    }
+
     private boolean isDynamicQuery() {
         return className != null;
     }
@@ -2125,4 +2190,8 @@ private long getSourceRowIndexForFirstObject() {
     private SchemaConnector getSchemaConnector() {
         return new SchemaConnector(realm.getSchema());
     }
+
+    private static native String nativeSerializeQuery(long tableQueryPtr, long descriptorPtr);
+    private static native long nativeSubscribe(long sharedRealmPtr, String name, long tableQueryPtr, long descriptorPtr);
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 4b6aaf46eb..d2562ab97a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -20,6 +20,7 @@
 
 import java.lang.reflect.InvocationTargetException;
 
+import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmException;
 
@@ -98,13 +99,14 @@ public String getSyncServerCertificateFilePath(RealmConfiguration config) {
     }
 
     /**
-     * Block until all latest changes have been downloaded from the server.
+     * Block until all latest changes have been downloaded from the server. This should only
+     * be called the first time a Realm file is created.
      *
      * @throws {@code DownloadingRealmInterruptedException} if the thread was interrupted while blocked waiting for
      * this to complete.
      */
     @SuppressWarnings("JavaDoc")
-    public void downloadRemoteChanges(RealmConfiguration config) {
+    public void downloadInitialRemoteChanges(RealmConfiguration config) {
         // Do nothing
     }
 
@@ -123,4 +125,14 @@ public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder build
         // Do nothing
     }
 
+    /**
+     * If the Realm is a Query-based Realm, ensure that all subscriptions are ACTIVE before
+     * proceeding. This should only be called when opening a Realm for the first time.
+     *
+     * @throws {@code DownloadingRealmInterruptedException} if the thread was interrupted while blocked waiting for
+     * this to complete.
+     */
+    public void downloadInitialSubscriptions(Realm realm) {
+        // Do nothing
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/sync/Subscription.java b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
new file mode 100644
index 0000000000..15429b0eb8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/sync/Subscription.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.sync;
+
+import io.realm.RealmObject;
+import io.realm.RealmQuery;
+import io.realm.annotations.Beta;
+import io.realm.annotations.Index;
+import io.realm.annotations.RealmClass;
+import io.realm.annotations.RealmField;
+import io.realm.annotations.Required;
+import io.realm.internal.annotations.ObjectServer;
+
+/**
+ * Subscriptions represents the data from the server that a device is interested in when using
+ * Query-based Realms.
+ * <p>
+ * They are created automatically when using {@link RealmQuery#findAllAsync()} or {@link RealmQuery#findAllAsync(String)}
+ * on those Realms, but can also be created manually using {@link RealmQuery#subscribe()} and {@link RealmQuery#subscribe(String)}.
+ * <p>
+ * As long as any subscription exist that include an object, that object will be present on the
+ * device. If an object is not covered by an active subscription it will be removed from the device,
+ * but not the server.
+ * <p>
+ * Subscriptions are Realm objects, so deleting them e.g. by calling {@link RealmObject#deleteFromRealm()},
+ * is the same as calling {@link #unsubscribe()}.
+ * <p>
+ * <b>Warning:</b> Instances of this class should never be created directly through
+ * {@link io.realm.Realm#createObject(Class)} but only by using {@link RealmQuery#subscribe()} or
+ * {@link RealmQuery#subscribe(String)}.
+ */
+@ObjectServer
+@RealmClass(name = "__ResultSets")
+@Beta
+public class Subscription extends RealmObject {
+
+    /**
+     * The different states a Subscription can be in.
+     */
+    public enum State {
+        /**
+         * An error occurred while creating or processing the subscription.
+         * See {@link #getErrorMessage()} for details on what went wrong.
+         */
+        ERROR((byte) -1),
+
+        /**
+         * The subscription has been created, but has not yet been processed by the sync
+         * server.
+         */
+        PENDING((byte) 0),
+
+        /**
+         * The subscription has been processed by the Realm Object Server and data is being synced
+         * to the device.
+         */
+        ACTIVE((byte) 1),
+
+        /**
+         * The subscription has been removed. Data is no longer being synchronized from the Realm
+         * Object Server, and the objects covered by this subscription might be deleted from the
+         * device if no other subscriptions include them.
+         */
+        INVALIDATED(null);
+
+
+        private final Byte nativeValue;
+
+        State(Byte nativeValue) {
+            this.nativeValue = nativeValue;
+        }
+
+        /**
+         * Returns the native value representing this state.
+         *
+         * @return the native value representing this state.
+         */
+        public Byte getValue() {
+            return nativeValue;
+        }
+    }
+
+    public Subscription() {
+        // Required by Realm.
+    }
+
+    /**
+     * Creates a unmanaged named subscription from a {@link RealmQuery}.
+     * This will not take effect until it has been added to the Realm.
+     *
+     * @param name name of the query.
+     * @param query the query to turn into a subscription.
+     */
+    public Subscription(String name, RealmQuery<?> query) {
+        this.name = name;
+        this.query = query.getDescription();
+        this.status = 0;
+        this.errorMessage = "";
+        this.matchesProperty = "";
+    }
+
+    @Index
+    @Required
+    private String name;
+
+    /**
+     * The underlying representation of the State
+     */
+    private byte status;
+
+    @Required
+    @RealmField("error_message")
+    private String errorMessage;
+
+    @Required
+    @RealmField("matches_property")
+    private String matchesProperty;
+
+    @Required
+    private String query;
+
+    @RealmField("query_parse_counter")
+    private int queryParseCounter;
+
+    /**
+     * Returns the name of the subscription.
+     *
+     * @return the name of the subscription.
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns a textual description of the query that created this subscription.
+     *
+     * @return a textual description of the query.
+     */
+    public String getQueryDescription() {
+        return query;
+    }
+
+    /**
+     * Returns the internal name of the Class being queried.
+     *
+     * @return the internal name of the of the class being queried.
+     */
+    public String getQueryClassName() {
+        // Strip the __matches suffix to end up with the class being queried.
+        String classQueried = matchesProperty;
+        return classQueried.substring(0, classQueried.length() - "_matches".length());
+    }
+
+    /**
+     * Returns the state of the subscription
+     *
+     * @return the state of the subscription.
+     * @see State
+     */
+    public State getState () {
+        if (!RealmObject.isValid(this)) {
+            return State.INVALIDATED;
+        } else {
+            switch (status) {
+                case -1:
+                    return State.ERROR;
+                case 0:
+                    return State.PENDING;
+                case 1:
+                    return State.ACTIVE;
+                default:
+                    throw new IllegalArgumentException("Unknown subscription state value: " + status);
+            }
+        }
+    }
+
+    /**
+     * Returns the error message if {@link #getState()} returned {@link State#ERROR}, otherwise
+     * the empty string is returned.
+     *
+     * @return the error string if the subscription encountered an error.
+     */
+    public String getErrorMessage() {
+        return errorMessage;
+    }
+
+    /**
+     * Cancels the subscription. After this, if the objects covered by the subscription are not
+     * part of any other subscription, they will be removed locally from the device (but not on the
+     * server).
+     * <p>
+     * The effect of unsubscribing is not immediate. The local Realm must coordinate with the Realm
+     * Object Server before it can happen. When it happens, any objects removed will trigger a standard
+     * change notification, and from the perspective of the device it will look like they where
+     * deleted.
+     * <p>
+     * Calling this method is the equivalent of calling {@link RealmObject#deleteFromRealm()}.
+     *
+     * @throws IllegalStateException if the Realm is not in a write transaction.
+     */
+    public void unsubscribe() {
+        RealmObject.deleteFromRealm(this);
+    }
+
+    @Override
+    public String toString() {
+        return "Subscription{" +
+                "name='" + name + '\'' +
+                ", status=" + getState().toString() +
+                ", errorMessage='" + errorMessage + '\'' +
+                ", className='" + getQueryClassName() + '\'' +
+                ", query='" + query + '\'' +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 93ac40bbfb..2c1b4c560a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.os.SystemClock;
+
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -44,6 +46,7 @@
 import javax.net.ssl.X509TrustManager;
 
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.exceptions.RealmError;
 import io.realm.internal.Keep;
 import io.realm.internal.Util;
 import io.realm.internal.network.AuthenticationServer;
@@ -446,7 +449,7 @@ private static synchronized void removeSession(SyncConfiguration syncConfigurati
     }
 
     /**
-     * Retruns the all valid sessions belonging to the user.
+     * Returns the all valid sessions belonging to the user.
      *
      * @param syncUser the user to use.
      * @return the all valid sessions belonging to the user.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
index 0460d297d5..a7326edbab 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
@@ -28,4 +28,7 @@ public DownloadingRealmInterruptedException(SyncConfiguration syncConfig, Throwa
         super("Realm was interrupted while downloading the latest changes from the server: " + syncConfig.getPath(),
                 exception);
     }
+    public DownloadingRealmInterruptedException(SyncConfiguration syncConfig, String message) {
+        super("Realm was interrupted while downloading the latest changes from the server: " + syncConfig.getPath() + "\n" + message);
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index c1c05f31c9..0de162bcc1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -23,9 +23,12 @@
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.util.Arrays;
 import java.util.Map;
 
+import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
@@ -34,6 +37,7 @@
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.sync.permissions.ObjectPermissionsModule;
+import io.realm.sync.Subscription;
 
 @SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
 @Keep
@@ -173,12 +177,19 @@ private void invokeRemoveSession(SyncConfiguration syncConfig) {
     }
 
     @Override
-    public void downloadRemoteChanges(RealmConfiguration config) {
+    public void downloadInitialRemoteChanges(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
             SyncConfiguration syncConfig = (SyncConfiguration) config;
             if (syncConfig.shouldWaitForInitialRemoteData()) {
                 SyncSession session = SyncManager.getSession(syncConfig);
                 try {
+                    if (!syncConfig.isFullySynchronizedRealm()) {
+                        // For Query-based Realms we want to upload all our local changes
+                        // first since those might include subscriptions the server needs to process.
+                        // This means that once `downloadAllServerChanges` completes all
+                        // initial subscriptions will also have been downloaded.
+                        session.uploadAllLocalChanges();
+                    }
                     session.downloadAllServerChanges();
                 } catch (InterruptedException e) {
                     throw new DownloadingRealmInterruptedException(syncConfig, e);
@@ -206,4 +217,40 @@ public boolean isPartialRealm(RealmConfiguration configuration) {
     public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder builder) {
         builder.addModule(new ObjectPermissionsModule());
     }
+
+    @Override
+    public void downloadInitialSubscriptions(Realm realm) {
+        if (isPartialRealm(realm.getConfiguration())) {
+            SyncConfiguration syncConfig = (SyncConfiguration) realm.getConfiguration();
+            if (syncConfig.shouldWaitForInitialRemoteData()) {
+                RealmResults<Subscription> pendingSubscriptions = realm.where(Subscription.class)
+                        .equalTo("status", Subscription.State.PENDING.getValue())
+                        .findAll();
+                SyncSession session = SyncManager.getSession(syncConfig);
+
+                // Continue once all subscriptions are either ACTIVE or ERROR'ed.
+                while (!pendingSubscriptions.isEmpty()) {
+                    try {
+                        session.uploadAllLocalChanges(); // Uploads subscriptions (if any)
+                        session.downloadAllServerChanges(); // Download subscriptions (if any)
+                    } catch (InterruptedException e) {
+                        throw new DownloadingRealmInterruptedException(syncConfig, e);
+                    }
+                    realm.refresh();
+                }
+
+                // If some of the subscriptions failed to become ACTIVE, report them and cancel opening
+                // the Realm. Note, this should only happen if the client is contacting an older
+                // version of the server which are lacking query support for features available
+                // in the client SDK.
+                RealmResults<Subscription> failedSubscriptions = realm.where(Subscription.class)
+                        .equalTo("status", Subscription.State.ERROR.getValue())
+                        .findAll();
+                if (!failedSubscriptions.isEmpty()) {
+                    String errorMessage = "Some initial subscriptions encountered errors:" + Arrays.toString(failedSubscriptions.toArray());
+                    throw new DownloadingRealmInterruptedException(syncConfig, errorMessage);
+                }
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java
index e1f6f27af3..0dc7279bdb 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/sync/permissions/ObjectPermissionsModule.java
@@ -1,18 +1,23 @@
 package io.realm.internal.sync.permissions;
 
 import io.realm.annotations.RealmModule;
+import io.realm.sync.Subscription;
 import io.realm.sync.permissions.ClassPermissions;
 import io.realm.sync.permissions.Permission;
 import io.realm.sync.permissions.RealmPermissions;
 import io.realm.sync.permissions.PermissionUser;
 import io.realm.sync.permissions.Role;
 
+/**
+ * Realm model classses that are always part of Query-based Realms
+ */
 @RealmModule(library = true, classes = {
         ClassPermissions.class,
         Permission.class,
         RealmPermissions.class,
         Role.class,
-        PermissionUser.class
+        PermissionUser.class,
+        Subscription.class
 })
 public class ObjectPermissionsModule {
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
index 7578de0cf1..36f9622f07 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
@@ -22,7 +22,7 @@ public void setupTest() throws IOException {
     }
 
     @After
-    public void teardownTest() {
+    public void teardownTest() throws IOException {
         if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
             // Non-looper tests can reset here
             SyncTestUtils.restoreEnvironmentAfterTest();
@@ -32,7 +32,11 @@ public void teardownTest() {
             looperThread.runAfterTest(new Runnable() {
                 @Override
                 public void run() {
-                    SyncTestUtils.restoreEnvironmentAfterTest();
+                    try {
+                        SyncTestUtils.restoreEnvironmentAfterTest();
+                    } catch (IOException e) {
+                        throw new RuntimeException(e);
+                    }
                     stopSyncServer();
                 }
             });
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
index aea2b68327..e2ed36db87 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
@@ -48,7 +48,7 @@ public void setupTest() throws IOException {
     }
 
     @After
-    public void teardownTest() {
+    public void teardownTest() throws IOException {
         if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
             // Non-looper tests can reset here
             SyncTestUtils.restoreEnvironmentAfterTest();
@@ -57,7 +57,11 @@ public void teardownTest() {
             looperThread.runAfterTest(new Runnable() {
                 @Override
                 public void run() {
-                    SyncTestUtils.restoreEnvironmentAfterTest();
+                    try {
+                        SyncTestUtils.restoreEnvironmentAfterTest();
+                    } catch (IOException e) {
+                        throw new RuntimeException(e);
+                    }
                 }
             });
         }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 0f47cbd7d1..6300954d20 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -43,30 +43,41 @@
         void onReady(SyncSession session);
     }
 
-    private SyncSession getSession() {
-        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncConfiguration syncConfiguration = configFactory
-                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
-                .build();
-        looperThread.closeAfterTest(Realm.getInstance(syncConfiguration));
-        return SyncManager.getSession(syncConfiguration);
+    private void getSession(SessionCallback callback) {
+        // Work-around for a race conditions happening when shutting down a Looper test and
+        // Resetting the SyncManager
+        // The problem is the `@After` block which runs as soon as the test method has completed.
+        // For integration tests this will attempt to reset the SyncManager which will fail
+        // if Realms are still open as they hold a reference to a session object.
+        // By moving this into a Looper callback we ensure that a looper test can shutdown as
+        // intended.
+        // Generally it seems that using calling `RunInLooperThread.testComplete()` in a synchronous
+        looperThread.postRunnable((Runnable) () -> {
+            SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+            SyncConfiguration syncConfiguration = configFactory
+                    .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                    .build();
+            looperThread.closeAfterTest(Realm.getInstance(syncConfiguration));
+            callback.onReady(SyncManager.getSession(syncConfiguration));
+        });
     }
 
     private void getActiveSession(SessionCallback callback) {
-        SyncSession session = getSession();
-        if (session.isConnected()) {
-            callback.onReady(session);
-        } else {
-            session.addConnectionChangeListener(new ConnectionListener() {
-                @Override
-                public void onChange(ConnectionState oldState, ConnectionState newState) {
-                    if (newState == ConnectionState.CONNECTED) {
-                        session.removeConnectionChangeListener(this);
-                        callback.onReady(session);
+        getSession(session -> {
+            if (session.isConnected()) {
+                callback.onReady(session);
+            } else {
+                session.addConnectionChangeListener(new ConnectionListener() {
+                    @Override
+                    public void onChange(ConnectionState oldState, ConnectionState newState) {
+                        if (newState == ConnectionState.CONNECTED) {
+                            session.removeConnectionChangeListener(this);
+                            callback.onReady(session);
+                        }
                     }
-                }
-            });
-        }
+                });
+            }
+        });
     }
 
     @Test(timeout=3000)
@@ -323,9 +334,13 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
                         if (stringOnlies.size() == 2) {
                             Assert.assertEquals("1", stringOnlies.get(0).getChars());
                             Assert.assertEquals("2", stringOnlies.get(1).getChars());
-                            adminRealm.close();
-                            testCompleted.countDown();
-                            handlerThread.quit();
+                            handler.post(() -> {
+                                // Closing a Realm from inside a listener doesn't seem to remove the
+                                // active session reference in Object Store
+                                adminRealm.close();
+                                testCompleted.countDown();
+                                handlerThread.quit();
+                            });
                         }
                     }
                 };
@@ -340,7 +355,7 @@ public void onChange(RealmResults<StringOnly> stringOnlies) {
             }
         });
 
-        TestHelper.awaitOrFail(testCompleted, 60);
+        TestHelper.awaitOrFail(testCompleted);
         realm.close();
     }
 
@@ -543,13 +558,15 @@ public void run() {
     @Test
     @RunTestInLooperThread
     public void registerConnectionListener() {
-        SyncSession session = getSession();
-        session.addConnectionChangeListener((oldState, newState) -> {
-            if (newState == ConnectionState.DISCONNECTED) {
-                looperThread.testComplete();
-            }
+        getSession(session -> {
+            session.addConnectionChangeListener((oldState, newState) -> {
+                if (newState == ConnectionState.DISCONNECTED) {
+                    // Closing a Realm inside a connection listener doesn't work: https://github.com/realm/realm-java/issues/6249
+                    looperThread.postRunnable(() -> looperThread.testComplete());
+                }
+            });
+            session.stop();
         });
-        session.stop();
     }
 
     @Test
@@ -617,11 +634,12 @@ public void start_multipleTimes() {
     @Test
     @RunTestInLooperThread
     public void stop_multipleTimes() {
-        SyncSession session = getSession();
-        session.stop();
-        assertEquals(SyncSession.State.INACTIVE, session.getState());
-        session.stop();
-        assertEquals(SyncSession.State.INACTIVE, session.getState());
-        looperThread.testComplete();
+        getSession(session -> {
+            session.stop();
+            assertEquals(SyncSession.State.INACTIVE, session.getState());
+            session.stop();
+            assertEquals(SyncSession.State.INACTIVE, session.getState());
+            looperThread.testComplete();
+        });
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index 551c872067..8f0e0f604d 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -28,6 +28,7 @@
 import java.io.File;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
@@ -36,6 +37,7 @@
 import io.realm.internal.OsRealmConfig;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
+import io.realm.log.RealmLogger;
 import io.realm.objectserver.utils.Constants;
 import io.realm.rule.RunTestInLooperThread;
 
@@ -76,8 +78,7 @@ public void loginLogoutResumeSyncing() throws InterruptedException {
             assertTrue(Realm.deleteRealm(config));
         } catch (IllegalStateException e) {
             // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
-            //        closed for now.
-            // https://github.com/realm/realm-java/issues/5416
+            // closed for now https://github.com/realm/realm-java/issues/5416
             if (e.getMessage().contains("It's not allowed to delete the file")) {
                 // retry after 1 second
                 SystemClock.sleep(1000);
@@ -372,13 +373,19 @@ public void javaRequestCustomHeaders_specificHost() {
     private void runJavaRequestCustomHeadersTest() {
         SyncCredentials credentials = SyncCredentials.nickname("test", false);
 
+        AtomicBoolean headerSet = new AtomicBoolean(false);
         RealmLog.setLevel(LogLevel.ALL);
-        RealmLog.add((level, tag, throwable, message) -> {
+        RealmLogger logger = (level, tag, throwable, message) -> {
             if (level == LogLevel.TRACE
                     && message.contains("Foo: bar")
                     && message.contains("RealmAuth: ")) {
-                looperThread.testComplete();
-            }});
+                headerSet.set(true);
+            }
+        };
+        looperThread.runAfterTest(() -> {
+            RealmLog.remove(logger);
+        });
+        RealmLog.add(logger);
 
         SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         try {
@@ -388,6 +395,9 @@ private void runJavaRequestCustomHeadersTest() {
                 throw e;
             }
         }
+
+        assertTrue(headerSet.get());
+        looperThread.testComplete();
     }
 
     // Test that auth header renaming, custom headers and url prefix are all propagated correctly
@@ -427,15 +437,20 @@ public void onError(SyncSession session, ObjectServerError error) {
                 })
                 .build();
 
+        AtomicBoolean headersSet = new AtomicBoolean(false);
         RealmLog.setLevel(LogLevel.ALL);
-        RealmLog.add((level, tag, throwable, message) -> {
+        RealmLogger logger = (level, tag, throwable, message) -> {
             if (tag.equals("REALM_SYNC")
                     && message.contains("GET /foo/%2Fdefault%2F__partial%")
                     && message.contains("TestAuth: Realm-Access-Token version=1")
                     && message.contains("Test: test")) {
                 looperThread.testComplete();
             }
+        };
+        looperThread.runAfterTest(() -> {
+            RealmLog.remove(logger);
         });
+        RealmLog.add(logger);
         Realm realm = Realm.getInstance(config);
         looperThread.closeAfterTest(realm);
     }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index 6dda502edc..24619366d1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -128,7 +128,7 @@ public void onSuccess(SyncUser user) {
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
-                looperThread.addTestRealm(realm);
+                looperThread.closeAfterTest(realm);
                 assertTrue(config.getUser().isValid());
                 looperThread.testComplete();
             }
@@ -153,7 +153,7 @@ public void onSuccess(SyncUser user) {
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
-                looperThread.addTestRealm(realm);
+                looperThread.closeAfterTest(realm);
                 assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
                 assertTrue(config.getUser().isValid());
                 looperThread.testComplete();
@@ -179,7 +179,7 @@ public void onSuccess(SyncUser user) {
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
-                looperThread.addTestRealm(realm);
+                looperThread.closeAfterTest(realm);
                 assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
                 assertTrue(config.getUser().isValid());
                 looperThread.testComplete();
@@ -205,7 +205,7 @@ public void onSuccess(SyncUser user) {
                         .build();
 
                 final Realm realm = Realm.getInstance(config);
-                looperThread.addTestRealm(realm);
+                looperThread.closeAfterTest(realm);
                 assertFalse(Util.isEmptyString(config.getUser().getIdentity()));
                 assertTrue(config.getUser().isValid());
                 looperThread.testComplete();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
index a8ad9278e7..621b7a70cb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
@@ -21,7 +21,6 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
-import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.model.PartialSyncModule;
 import io.realm.objectserver.model.PartialSyncObjectA;
@@ -29,9 +28,11 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.sync.Subscription;
 
 import static org.hamcrest.number.OrderingComparison.greaterThan;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -302,9 +303,7 @@ public void clearTable() {
 
     @Test
     @RunTestInLooperThread
-    @Ignore("FIXME: We need to use ROS 3.10+ to support limit, but cannot upgrade before https://github.com/realm/realm-js/issues/1971 is fixed")
     public void downloadLimitedData() throws InterruptedException {
-        RealmLog.setLevel(LogLevel.TRACE);
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
         createServerData(user, Constants.SYNC_SERVER_URL);
         Realm realm = getPartialRealm(user);
@@ -336,6 +335,106 @@ public void downloadLimitedData() throws InterruptedException {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void initialDataAndWaitForRemoteInitialData() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+
+        // Create partial Realm that will wait for the subscriptions
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("partialSync")
+                .initialData(r -> {
+                    r.where(PartialSyncObjectA.class).greaterThan("number", 5).subscribe("my-sub");
+                })
+                .waitForInitialRemoteData()
+                .modules(new PartialSyncModule())
+                .build();
+        Realm realm = Realm.getInstance(partialSyncConfig);
+        looperThread.closeAfterTest(realm);
+
+        // Check the state of subscriptions. Sync automatically creates subscriptions for fine-grained permission classes.
+        assertEquals(6, realm.getSubscriptions().size());
+        assertTrue(realm.getSubscriptions().where().equalTo("status", 0).findAll().isEmpty());
+        Subscription sub = realm.getSubscription("my-sub");
+        assertEquals(Subscription.State.ACTIVE, sub.getState());
+
+        // Check that data is downloaded
+        assertFalse(realm.isEmpty());
+        assertEquals(4, realm.where(PartialSyncObjectA.class).findAll().size());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void unsubscribe_synchronous() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+
+        // Create partial Realm that will wait for the subscriptions
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("partialSync")
+                .initialData(r -> {
+                    r.where(PartialSyncObjectA.class).greaterThan("number", 5).subscribe("my-sub");
+                })
+                .waitForInitialRemoteData()
+                .addModule(new PartialSyncModule())
+                .build();
+        Realm realm = Realm.getInstance(partialSyncConfig);
+        looperThread.closeAfterTest(realm);
+
+        realm.executeTransaction(r -> {
+            Subscription sub = r.getSubscription("my-sub");
+            assertEquals(Subscription.State.ACTIVE, sub.getState());
+            sub.unsubscribe();
+            assertEquals(Subscription.State.INVALIDATED, sub.getState());
+        });
+
+        // Objects should eventually disappear from the device
+        RealmResults<PartialSyncObjectA> results = realm.where(PartialSyncObjectA.class).findAll();
+        results.addChangeListener((objects, changeSet) -> {
+            if (objects.isEmpty()) {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    public void deletingSubscriptionObjectUnsubscribes() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+
+        // Create partial Realm that will wait for the subscriptions
+        final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("partialSync")
+                .initialData(r -> {
+                    r.where(PartialSyncObjectA.class).greaterThan("number", 5).subscribe("my-sub");
+                })
+                .waitForInitialRemoteData()
+                .addModule(new PartialSyncModule())
+                .build();
+        Realm realm = Realm.getInstance(partialSyncConfig);
+        looperThread.closeAfterTest(realm);
+
+        realm.executeTransaction(r -> {
+            Subscription sub = r.getSubscription("my-sub");
+            assertEquals(Subscription.State.ACTIVE, sub.getState());
+            sub.deleteFromRealm(); // Equivalent of calling `sub.unsubscribe()`.
+            assertEquals(Subscription.State.INVALIDATED, sub.getState());
+        });
+
+        // Objects should eventually disappear from the device
+        RealmResults<PartialSyncObjectA> results = realm.where(PartialSyncObjectA.class).findAll();
+        results.addChangeListener((objects, changeSet) -> {
+            if (objects.isEmpty()) {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+
     private Realm getPartialRealm(SyncUser user) {
         final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                 .name("partialSync")
diff --git a/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java b/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
index b11a8ebea1..e7243d27f7 100644
--- a/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
+++ b/realm/realm-library/src/syncTestUtils/java/io/realm/SyncTestUtils.java
@@ -60,20 +60,7 @@
         }
     }
 
-    public static void prepareEnvironmentForTest() throws IOException {
-        deleteRosFiles();
-        if (BaseRealm.applicationContext != null) {
-            // Realm was already initialized. Reset all internal state
-            // in order to be able fully re-initialize.
-
-            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
-            // causing the SyncUser to remain in memory.
-            // They're actually not persisted into disk.
-            // move this call to 'tearDown' to clean in-memory & on-disk users
-            // once https://github.com/realm/realm-object-store/issues/207 is resolved
-            SyncManager.reset();
-            BaseRealm.applicationContext = null; // Required for Realm.init() to work
-        }
+    public static void prepareEnvironmentForTest(){
         Realm.init(InstrumentationRegistry.getTargetContext());
         originalLogLevel = RealmLog.getLevel();
         RealmLog.setLevel(LogLevel.DEBUG);
@@ -82,12 +69,27 @@ public static void prepareEnvironmentForTest() throws IOException {
     /**
      * Tries to restore the environment as best as possible after a test.
      */
-    public static void restoreEnvironmentAfterTest() {
+    public static void restoreEnvironmentAfterTest() throws IOException {
         // Block until all users are logged out
         UserFactory.logoutAllUsers();
 
         // Reset log level
         RealmLog.setLevel(originalLogLevel);
+
+        if (BaseRealm.applicationContext != null) {
+            // Realm was already initialized. Reset all internal state
+            // in order to be able fully re-initialize.
+
+            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
+            // causing the SyncUser to remain in memory.
+            // They're actually not persisted into disk.
+            // move this call to 'tearDown' to clean in-memory & on-disk users
+            // once https://github.com/realm/realm-object-store/issues/207 is resolved
+            SyncManager.reset();
+            BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        }
+        deleteRosFiles();
+        Realm.init(InstrumentationRegistry.getTargetContext());
     }
 
     // Cleanup filesystem to make sure nothing lives for the next test.
diff --git a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
index a9db3a9934..2d8a6a5096 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
@@ -944,7 +944,6 @@ public static void awaitOrFail(CountDownLatch latch, int numberOfSeconds) {
     }
 
     public interface LooperTest {
-        CountDownLatch getRealmClosedSignal();
         Looper getLooper();
         Throwable getAssertionError();
     }
@@ -967,8 +966,6 @@ public static void exitOrThrow(ExecutorService executorService, CountDownLatch t
                 looper.quit();
             }
 
-            // Waits for the finally block to execute and closes the Realm.
-            TestHelper.awaitOrFail(test.getRealmClosedSignal());
             // Closes the executor.
             // This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish().
             executorService.shutdownNow();
diff --git a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
index baef25a0f1..c9837cb1fc 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
@@ -55,7 +55,7 @@
  * the open Realms).
  */
 public class RunInLooperThread extends TestRealmConfigurationFactory {
-    private static final long WAIT_TIMEOUT_MS = 60 * 1000;
+    private static final long WAIT_TIMEOUT_MS = 20 * 1000;
 
     // lock protecting objects shared with the test thread
     private final Object lock = new Object();
@@ -96,6 +96,9 @@
     // Access guarded by 'lock'
     private List<Runnable> runAfterTestIsComplete = new ArrayList<>();
 
+    // Used to indicate that a test is being marked as complete, but teardown hasn't fully finished yet.
+    private boolean testCompletedButNotFullyTornDown;
+
     /**
      * Get the configuration for the test realm.
      * <p>
@@ -219,11 +222,33 @@ public void postRunnableDelayed(Runnable runnable, long delayMillis) {
     /**
      * Signal that the test has completed.
      * <p>
-     * Used on both the main and test threads.
-     * Valid after {@code before}.
+     * Can be used on both the main and test threads.
      */
     public void testComplete() {
-        signalTestCompleted.countDown();
+        // Close all resources and run any after test tasks
+        // Post as runnable to ensure that this code runs on the correct thread.
+        postRunnable(() -> {
+            closeTestResources();
+        });
+    }
+
+    /**
+     * Internal logic for shutting down a test.
+     */
+    private void closeTestResources() {
+        testCompletedButNotFullyTornDown = true;
+        try {
+            closeResources();
+            closeRealms();
+            for (Runnable task : runAfterTestIsComplete) {
+                task.run();
+            }
+        } catch (Throwable t) {
+            throw new AssertionError("Failed to close test resources correctly", t);
+        } finally {
+            testCompletedButNotFullyTornDown = false;
+            signalTestCompleted.countDown();
+        }
     }
 
     /**
@@ -231,7 +256,8 @@ public void testComplete() {
      *
      * @param latches additional latches to wait on, before setting the test completed flag.
      */
-    public void testComplete(CountDownLatch... latches) {
+    public void
+    testComplete(CountDownLatch... latches) {
         for (CountDownLatch latch : latches) {
             TestHelper.awaitOrFail(latch);
         }
@@ -245,8 +271,8 @@ private Handler getBackgroundHandler() {
             while (backgroundHandler == null) {
                 try {
                     lock.wait(WAIT_TIMEOUT_MS);
-                } catch (InterruptedException ignore) {
-                    break;
+                } catch (InterruptedException e) {
+                    throw new AssertionError("Could not acquire the test handler.", e);
                 }
             }
             return this.backgroundHandler;
@@ -315,6 +341,8 @@ public Statement apply(Statement base, Description description) {
      * This will run on the same thread as the looper test.
      */
     public void looperTearDown() {
+        // Do nothing
+        // Override in test classes if needed.
     }
 
     private void initRealm() {
@@ -349,11 +377,12 @@ private void closeResources() throws IOException {
 
     /**
      * Checks if the current test is considered completed or not.
+     *
      * It is completed if either {@link #testComplete()} was called or an uncaught exception was thrown.
      */
     public boolean isTestComplete() {
         synchronized (lock) {
-            return signalTestCompleted.getCount() == 0;
+            return signalTestCompleted.getCount() <= 0 || testCompletedButNotFullyTornDown;
         }
     }
 
@@ -461,11 +490,11 @@ public void printStackTrace(PrintStream out) {
             this.base = base;
         }
 
-        @Override
-        public CountDownLatch getRealmClosedSignal() {
-            return signalClosedRealm;
-        }
-
+//        @Override
+//        public CountDownLatch getRealmClosedSignal() {
+//            return signalClosedRealm;
+//        }
+//
         @Override
         public synchronized Looper getLooper() {
             return looper;
@@ -499,20 +528,13 @@ public void run() {
             } catch (Throwable t) {
                 setAssertionError(t);
                 setUnitTestFailed();
-            } finally {
+
+                // If an exception occurred, `looperThread.testComplete()` was probably no called.
+                // Rerun it here, but ignore any failures as the first failure is more important.
                 try {
-                    looperTearDown();
-                    closeResources();
-                    for (Runnable task : runAfterTestIsComplete) {
-                        task.run();
-                    }
-                } catch (Throwable t) {
-                    setAssertionError(t);
-                    setUnitTestFailed();
+                    closeTestResources();
+                } catch (Throwable ignore) {
                 }
-                testComplete();
-                closeRealms();
-                signalClosedRealm.countDown();
             }
         }
     }
