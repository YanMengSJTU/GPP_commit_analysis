diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4b0c80c1ff..b2d8cfe396 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -5,11 +5,18 @@
 ## Enhancements
 
 * All Realm annotations are now kept at runtime, allowing runtime tools access to them (#5344).
+* Speedup schema initialization when a Realm file is first accessed (#5391).
 
 ## Bug Fixes
 
+* Assigning a managed object's own list to itself would accidentally clear it (#5395).
+* Don't try to acquire `ApplicationContext` if not available in `Realm.init(Context)` (#5389).
+
 ## Internal
 
+* Upgraded to Realm Sync 2.0.0.
+* Upgraded to Realm Core 4.0.2.
+
 ## Credits
 
 
diff --git a/Dockerfile b/Dockerfile
index f1a65fe040..e2c50e9865 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -49,10 +49,13 @@ RUN cd /opt && \
 RUN mkdir "${ANDROID_HOME}/licenses" && \
     echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" > "${ANDROID_HOME}/licenses/android-sdk-license"
 RUN sdkmanager --update
+# Accept all licenses
+RUN yes y | sdkmanager --licenses
 RUN sdkmanager 'platform-tools'
 RUN sdkmanager 'build-tools;26.0.2'
 RUN sdkmanager 'extras;android;m2repository'
 RUN sdkmanager 'platforms;android-26'
+RUN sdkmanager 'cmake;3.6.4111459'
 
 # Install the NDK
 RUN mkdir /opt/android-ndk-tmp && \
@@ -64,13 +67,5 @@ RUN mkdir /opt/android-ndk-tmp && \
     rm -rf /opt/android-ndk-tmp && \
     chmod -R a+rX /opt/android-ndk
 
-# Install cmake
-RUN mkdir /opt/cmake-tmp && \
-    cd /opt/cmake-tmp && \
-    wget -q https://dl.google.com/android/repository/cmake-3.6.3155560-linux-x86_64.zip -O cmake-linux.zip && \
-    mkdir -p ${ANDROID_HOME}/cmake/3.6.3155560 && \
-    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake/3.6.3155560 && \
-    rm -rf /opt/cmake-tmp
-
 # Make the SDK universally writable
 RUN chmod -R a+rwX ${ANDROID_HOME}
diff --git a/dependencies.list b/dependencies.list
index 3a595eb7d2..9f4ab3db86 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,8 +1,8 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=2.0.0-rc27
-REALM_SYNC_SHA256=3a558b10ecab3e8dbf6cbceae7fe40af38ad8d8467ddd1fe036ce92c1e7810f4
+REALM_SYNC_VERSION=2.0.0
+REALM_SYNC_SHA256=2d3661cdb94d6509b4a43d6daab17c9223fbb1e6608e317205bd61b4ef1b9516
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=2.0.0-alpha.46
+REALM_OBJECT_SERVER_DE_VERSION=2.0.0-rc.4
diff --git a/examples/build.gradle b/examples/build.gradle
index c0d569277d..f2c813c27f 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -23,7 +23,7 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
+            classpath 'com.android.tools.build:gradle:3.0.0-beta7'
             classpath 'com.novoda:gradle-android-command-plugin:1.7.1'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index b938b9891b..d457a1a990 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index 6e5f7d4d82..c583957d2b 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:18:52 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/examples/newsreaderExample/gradle.properties b/examples/newsreaderExample/gradle.properties
new file mode 100644
index 0000000000..31590309be
--- /dev/null
+++ b/examples/newsreaderExample/gradle.properties
@@ -0,0 +1 @@
+android.enableD8=true
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index 1997dcaafe..d457a1a990 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 5b4d3bae5d..c583957d2b 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:18:55 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/gradle.properties b/gradle.properties
index 00ce074090..a409f36833 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1 +1,2 @@
 org.gradle.jvmargs=-XX:MaxPermSize=512m
+org.gradle.caching=true
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 555beb482c..d457a1a990 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 55e3e0344d..c583957d2b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:18:56 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/gradlew b/gradlew
index 4f0d4910d0..cccdd3d517 100755
--- a/gradlew
+++ b/gradlew
@@ -160,9 +160,6 @@ save () {
     echo " "
 }
 APP_ARGS=$(save "$@")
-# Realm's work-around for a bug in Gradle 4.1 https://github.com/gradle/gradle/issues/2673
-APP_ARGS="${APP_ARGS} '--console=plain' \\
- "
 
 # Collect all arguments for the java command, following the shell quoting and substitution rules
 eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index 556f8ae9f4..8b58216363 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
+        classpath 'com.android.tools.build:gradle:3.0.0-beta7'
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
     }
 }
diff --git a/library-benchmarks/gradle.properties b/library-benchmarks/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/library-benchmarks/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar
index 55420b622f..d457a1a990 100644
Binary files a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar and b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
index db87399dd3..c583957d2b 100644
--- a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
+++ b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:18:59 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index fcb4ed4337..d457a1a990 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 79d8ff7b73..c583957d2b 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:19:02 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 47c7f9ed18..d457a1a990 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index 4381dc5c6a..c583957d2b 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:19:04 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm.properties b/realm.properties
index 3d842610f2..b36f4827a1 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=4.1
+gradleVersion=4.2.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index cb16b05480..3c49834f42 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -9,7 +9,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-alpha4'
+        classpath 'com.android.tools.build:gradle:3.0.0-beta7'
         classpath 'de.undercouch:gradle-download-task:3.2.0'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.7.1'
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index 15c7b608fb..d457a1a990 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index c3448f25a5..c583957d2b 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Tue Aug 08 09:19:01 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index e1ea070565..71bb69b86e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -244,7 +244,7 @@ private void emitClassFields(JavaWriter writer) throws IOException {
 
         writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true)
-            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
+            .emitStatement("List<String> fieldNames = new ArrayList<String>(%s)", metadata.getFields().size());
             for (VariableElement field : metadata.getFields()) {
                 writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
             }
@@ -477,12 +477,7 @@ public void emit(JavaWriter writer) throws IOException {
                         .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
                         .emitStatement("return")
                         .endControlFlow();
-                writer.beginControlFlow("if (!RealmObject.isValid(value))")
-                        .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-                        .endControlFlow();
-                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                        .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-                        .endControlFlow();
+                writer.emitStatement("proxyState.checkValidObject(value)");
                 writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
                         fieldIndexVariableReference(field));
                 writer.emitStatement("return");
@@ -493,12 +488,7 @@ public void emit(JavaWriter writer) throws IOException {
                 .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                 .emitStatement("return")
                 .endControlFlow()
-                .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
-                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-                .endControlFlow()
-                .beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-                .endControlFlow()
+                .emitStatement("proxyState.checkValidObject(value)")
                 .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
                 .endMethod();
     }
@@ -572,37 +562,52 @@ public void emit(JavaWriter writer) throws IOException {
                 // LinkView currently does not support default value feature. Just fallback to normal code.
             }
         });
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-                if (Utils.isRealmModelList(field)) {
-                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
-                            fieldIndexVariableReference(field));
-                } else {
-                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
-                            fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
-                }
-                writer.emitStatement("osList.removeAll()")
-                .beginControlFlow("if (value == null)")
-                .emitStatement("return")
-                .endControlFlow();
 
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+        if (Utils.isRealmModelList(field)) {
+            writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
+                    fieldIndexVariableReference(field));
+        } else {
+            writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
+                    fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
+        }
         if (forRealmModel) {
-            writer.beginControlFlow("for (RealmModel linkedObject : value)")
-                    .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
+            // Model lists.
+            writer
+                .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                .beginControlFlow("if (value != null && value.size() == osList.size())")
+                    .emitStatement("int objects = value.size()")
+                    .beginControlFlow("for (int i = 0; i < objects; i++)")
+                        .emitStatement("%s linkedObject = value.get(i)", genericType)
+                        .emitStatement("proxyState.checkValidObject(linkedObject)")
+                        .emitStatement("osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
                     .endControlFlow()
-                    .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
+                .nextControlFlow("else")
+                    .emitStatement("osList.removeAll()")
+                    .beginControlFlow("if (value == null)")
+                        .emitStatement("return")
                     .endControlFlow()
-                    .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-                    .endControlFlow();
+                    .emitStatement("int objects = value.size()")
+                    .beginControlFlow("for (int i = 0; i < objects; i++)")
+                        .emitStatement("%s linkedObject = value.get(i)", genericType)
+                        .emitStatement("proxyState.checkValidObject(linkedObject)")
+                        .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
+                    .endControlFlow()
+                .endControlFlow();
         } else {
-            writer.beginControlFlow("for (%1$s item : value)", genericType)
+            // Value lists
+            writer
+                .emitStatement("osList.removeAll()")
+                .beginControlFlow("if (value == null)")
+                    .emitStatement("return")
+                .endControlFlow()
+                .beginControlFlow("for (%1$s item : value)", genericType)
                     .beginControlFlow("if (item == null)")
-                    .emitStatement(metadata.isElementNullable(field) ? "osList.addNull()" : "throw new IllegalArgumentException(\"Storing 'null' into " + fieldName + "' is not allowed by the schema.\")")
+                        .emitStatement(metadata.isElementNullable(field) ? "osList.addNull()" : "throw new IllegalArgumentException(\"Storing 'null' into " + fieldName + "' is not allowed by the schema.\")")
                     .nextControlFlow("else")
-                    .emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
+                        .emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
                     .endControlFlow()
-                    .endControlFlow();
+                .endControlFlow();
         }
         writer.endMethod();
 
@@ -723,8 +728,14 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                 "createExpectedObjectSchemaInfo", // Method name
                 EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers
 
+        // Guess capacity for Arrays used by OsObjectSchemaInfo.
+        // Used to prevent array resizing at runtime
+        int persistedFields = metadata.getFields().size();
+        int computedFields = metadata.getBacklinkFields().size();
+
         writer.emitStatement(
-                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\")", this.simpleClassName);
+                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
+                this.simpleClassName, persistedFields, computedFields);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
@@ -1287,21 +1298,33 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
             } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                        .emitEmptyLine()
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitEmptyLine()
+                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objects = %1$sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objects; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
+                    .endControlFlow()
+                    .nextControlFlow("else")
                         .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                        .endControlFlow()
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
+                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
                         .endControlFlow()
-                        .emitEmptyLine();
+                    .endControlFlow()
+                    .emitEmptyLine();
 
             } else if (Utils.isRealmValueList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1390,21 +1413,33 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
             } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                        .emitEmptyLine()
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitEmptyLine()
+                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objectCount = %1$sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objectCount; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
+                    .nextControlFlow("else")
                         .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                        .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                        .endControlFlow()
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
+                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
                         .endControlFlow()
-                        .emitEmptyLine();
+                    .endControlFlow()
+                    .emitEmptyLine();
 
             } else if (Utils.isRealmValueList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
@@ -1714,23 +1749,34 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
-                        .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()",
-                                genericType, fieldName, getter)
+                    .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
+                    .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()", genericType, fieldName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sRealmList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objects = %sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objects; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
+                            .beginControlFlow("if (cache%s != null)", fieldName)
+                                .emitStatement("%1$sRealmList.set(i, cache%1$s)", fieldName)
+                            .nextControlFlow("else")
+                                .emitStatement("%1$sRealmList.set(i, %2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                        .endControlFlow()
+                    .nextControlFlow("else")
                         .emitStatement("%sRealmList.clear()", fieldName)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                        .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
-                        .beginControlFlow("if (cache%s != null)", fieldName)
-                        .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
-                        .nextControlFlow("else")
-                        .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))",
-                                fieldName, Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
+                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
+                                .beginControlFlow("if (cache%s != null)", fieldName)
+                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
+                                .nextControlFlow("else")
+                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
+                            .endControlFlow()
                         .endControlFlow()
-                        .endControlFlow();
-
+                    .endControlFlow();
             } else if (Utils.isRealmValueList(field)) {
                 writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
             } else if (Utils.isMutableRealmInteger(field)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index af3fc09c2c..bd4476fc9f 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -119,7 +119,7 @@ public void generate() throws IOException {
     private void emitFields(JavaWriter writer) throws IOException {
         writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
-        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>()");
+        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(%s)", qualifiedModelClasses.size());
         for (String clazz : qualifiedModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
@@ -137,7 +137,7 @@ private void emitGetExpectedObjectSchemaInfoMap(JavaWriter writer) throws IOExce
 
         writer.emitStatement(
                 "Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = " +
-                        "new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>()");
+                        "new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(%s)", qualifiedProxyClasses.size());
         for (int i = 0; i < qualifiedProxyClasses.size(); i++) {
             writer.emitStatement("infoMap.put(%s.class, %s.getExpectedObjectSchemaInfo())",
                     qualifiedModelClasses.get(i), qualifiedProxyClasses.get(i));
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 72a21aa73c..0a20dd36a9 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -124,7 +124,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(20);
         fieldNames.add("columnString");
         fieldNames.add("columnLong");
         fieldNames.add("columnFloat");
@@ -380,12 +380,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
                 row.nullifyLink(columnInfo.columnObjectIndex);
                 return;
             }
-            if (!RealmObject.isValid(value)) {
-                throw new IllegalArgumentException("'value' is not a valid managed object.");
-            }
-            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("'value' belongs to a different Realm.");
-            }
+            proxyState.checkValidObject(value);
             row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
             return;
         }
@@ -395,12 +390,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
-            throw new IllegalArgumentException("'value' is not a valid managed object.");
-        }
-        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-            throw new IllegalArgumentException("'value' belongs to a different Realm.");
-        }
+        proxyState.checkValidObject(value);
         proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
@@ -443,18 +433,25 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
 
         proxyState.getRealm$realm().checkIfValid();
         OsList osList = proxyState.getRow$realm().getModelList(columnInfo.columnRealmListIndex);
-        osList.removeAll();
-        if (value == null) {
-            return;
-        }
-        for (RealmModel linkedObject : value) {
-            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
-                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
+        // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+        if (value != null && value.size() == osList.size()) {
+            int objects = value.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes linkedObject = value.get(i);
+                proxyState.checkValidObject(linkedObject);
+                osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
+            }
+        } else {
+            osList.removeAll();
+            if (value == null) {
+                return;
             }
-            if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
+            int objects = value.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes linkedObject = value.get(i);
+                proxyState.checkValidObject(linkedObject);
+                osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
             }
-            osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
         }
     }
 
@@ -860,7 +857,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
-        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes");
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes", 20, 1);
         builder.addPersistedProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
         builder.addPersistedProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addPersistedProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
@@ -1045,16 +1042,16 @@ public static String getTableName() {
                 }
             }
         }
-        // TODO implement logic for value listcolumnStringList.
-        // TODO implement logic for value listcolumnBinaryList.
-        // TODO implement logic for value listcolumnBooleanList.
-        // TODO implement logic for value listcolumnLongList.
-        // TODO implement logic for value listcolumnIntegerList.
-        // TODO implement logic for value listcolumnShortList.
-        // TODO implement logic for value listcolumnByteList.
-        // TODO implement logic for value listcolumnDoubleList.
-        // TODO implement logic for value listcolumnFloatList.
-        // TODO implement logic for value listcolumnDateList.
+        // TODO implement logic for value list columnStringList.
+        // TODO implement logic for value list columnBinaryList.
+        // TODO implement logic for value list columnBooleanList.
+        // TODO implement logic for value list columnLongList.
+        // TODO implement logic for value list columnIntegerList.
+        // TODO implement logic for value list columnShortList.
+        // TODO implement logic for value list columnByteList.
+        // TODO implement logic for value list columnDoubleList.
+        // TODO implement logic for value list columnFloatList.
+        // TODO implement logic for value list columnDateList.
         return obj;
     }
 
@@ -1714,15 +1711,28 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
         }
 
         OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
-        columnRealmListOsList.removeAll();
         RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
-        if (columnRealmListList != null) {
-            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+        if (columnRealmListList != null && columnRealmListList.size() == columnRealmListOsList.size()) {
+            // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+            int objects = columnRealmListList.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                 Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                 if (cacheItemIndexcolumnRealmList == null) {
                     cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                 }
-                columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                columnRealmListOsList.setRow(i, cacheItemIndexcolumnRealmList);
+            }
+        } else {
+            columnRealmListOsList.removeAll();
+            if (columnRealmListList != null) {
+                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                    if (cacheItemIndexcolumnRealmList == null) {
+                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
+                    }
+                    columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                }
             }
         }
 
@@ -1930,15 +1940,28 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             }
 
             OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
-            columnRealmListOsList.removeAll();
             RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
-            if (columnRealmListList != null) {
-                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+            if (columnRealmListList != null && columnRealmListList.size() == columnRealmListOsList.size()) {
+                // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+                int objectCount = columnRealmListList.size();
+                for (int i = 0; i < objectCount; i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                     Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                     if (cacheItemIndexcolumnRealmList == null) {
                         cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                     }
-                    columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                    columnRealmListOsList.setRow(i, cacheItemIndexcolumnRealmList);
+                }
+            } else {
+                columnRealmListOsList.removeAll();
+                if (columnRealmListList != null) {
+                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                        if (cacheItemIndexcolumnRealmList == null) {
+                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
+                        }
+                        columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                    }
                 }
             }
 
@@ -2187,15 +2210,29 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         }
         RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
         RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
-        columnRealmListRealmList.clear();
-        if (columnRealmListList != null) {
-            for (int i = 0; i < columnRealmListList.size(); i++) {
+        if (columnRealmListList != null && columnRealmListList.size() == columnRealmListRealmList.size()) {
+            // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+            int objects = columnRealmListList.size();
+            for (int i = 0; i < objects; i++) {
                 some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                 some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                 if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
+                    columnRealmListRealmList.set(i, cachecolumnRealmList);
                 } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                    columnRealmListRealmList.set(i, AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                }
+            }
+        } else {
+            columnRealmListRealmList.clear();
+            if (columnRealmListList != null) {
+                for (int i = 0; i < columnRealmListList.size(); i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
+                    if (cachecolumnRealmList != null) {
+                        columnRealmListRealmList.add(cachecolumnRealmList);
+                    } else {
+                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                    }
                 }
             }
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index ccf71948d8..fa4b8282c7 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -74,7 +74,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(4);
         fieldNames.add("done");
         fieldNames.add("isReady");
         fieldNames.add("mCompleted");
@@ -192,7 +192,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
-        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Booleans");
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Booleans", 4, 0);
         builder.addPersistedProperty("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addPersistedProperty("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addPersistedProperty("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
@@ -221,6 +221,7 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Booleans obj = realm.createObjectInternal(some.test.Booleans.class, true, excludeFields);
+
         final BooleansRealmProxyInterface objProxy = (BooleansRealmProxyInterface) obj;
         if (json.has("done")) {
             if (json.isNull("done")) {
@@ -439,6 +440,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         unmanagedCopy.realmSet$isReady(realmSource.realmGet$isReady());
         unmanagedCopy.realmSet$mCompleted(realmSource.realmGet$mCompleted());
         unmanagedCopy.realmSet$anotherBoolean(realmSource.realmGet$anotherBoolean());
+
         return unmanagedObject;
     }
 
@@ -504,5 +506,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 43544b3e1e..020e091216 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -185,7 +185,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(41);
         fieldNames.add("fieldStringNotNull");
         fieldNames.add("fieldStringNull");
         fieldNames.add("fieldBooleanNotNull");
@@ -902,12 +902,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
                 row.nullifyLink(columnInfo.fieldObjectNullIndex);
                 return;
             }
-            if (!RealmObject.isValid(value)) {
-                throw new IllegalArgumentException("'value' is not a valid managed object.");
-            }
-            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("'value' belongs to a different Realm.");
-            }
+            proxyState.checkValidObject(value);
             row.getTable().setLink(columnInfo.fieldObjectNullIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
             return;
         }
@@ -917,12 +912,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
-            throw new IllegalArgumentException("'value' is not a valid managed object.");
-        }
-        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-            throw new IllegalArgumentException("'value' belongs to a different Realm.");
-        }
+        proxyState.checkValidObject(value);
         proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
@@ -1707,7 +1697,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
-        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NullTypes");
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NullTypes", 41, 0);
         builder.addPersistedProperty("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addPersistedProperty("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
         builder.addPersistedProperty("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
@@ -1996,26 +1986,26 @@ public static String getTableName() {
                 objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
             }
         }
-        // TODO implement logic for value listfieldStringListNotNull.
-        // TODO implement logic for value listfieldStringListNull.
-        // TODO implement logic for value listfieldBinaryListNotNull.
-        // TODO implement logic for value listfieldBinaryListNull.
-        // TODO implement logic for value listfieldBooleanListNotNull.
-        // TODO implement logic for value listfieldBooleanListNull.
-        // TODO implement logic for value listfieldLongListNotNull.
-        // TODO implement logic for value listfieldLongListNull.
-        // TODO implement logic for value listfieldIntegerListNotNull.
-        // TODO implement logic for value listfieldIntegerListNull.
-        // TODO implement logic for value listfieldShortListNotNull.
-        // TODO implement logic for value listfieldShortListNull.
-        // TODO implement logic for value listfieldByteListNotNull.
-        // TODO implement logic for value listfieldByteListNull.
-        // TODO implement logic for value listfieldDoubleListNotNull.
-        // TODO implement logic for value listfieldDoubleListNull.
-        // TODO implement logic for value listfieldFloatListNotNull.
-        // TODO implement logic for value listfieldFloatListNull.
-        // TODO implement logic for value listfieldDateListNotNull.
-        // TODO implement logic for value listfieldDateListNull.
+        // TODO implement logic for value list fieldStringListNotNull.
+        // TODO implement logic for value list fieldStringListNull.
+        // TODO implement logic for value list fieldBinaryListNotNull.
+        // TODO implement logic for value list fieldBinaryListNull.
+        // TODO implement logic for value list fieldBooleanListNotNull.
+        // TODO implement logic for value list fieldBooleanListNull.
+        // TODO implement logic for value list fieldLongListNotNull.
+        // TODO implement logic for value list fieldLongListNull.
+        // TODO implement logic for value list fieldIntegerListNotNull.
+        // TODO implement logic for value list fieldIntegerListNull.
+        // TODO implement logic for value list fieldShortListNotNull.
+        // TODO implement logic for value list fieldShortListNull.
+        // TODO implement logic for value list fieldByteListNotNull.
+        // TODO implement logic for value list fieldByteListNull.
+        // TODO implement logic for value list fieldDoubleListNotNull.
+        // TODO implement logic for value list fieldDoubleListNull.
+        // TODO implement logic for value list fieldFloatListNotNull.
+        // TODO implement logic for value list fieldFloatListNull.
+        // TODO implement logic for value list fieldDateListNotNull.
+        // TODO implement logic for value list fieldDateListNull.
         return obj;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index a38f5851e4..72344ed633 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -27,7 +27,7 @@
 
     private static final Set<Class<? extends RealmModel>> MODEL_CLASSES;
     static {
-        Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>();
+        Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(1);
         modelClasses.add(some.test.AllTypes.class);
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
@@ -35,7 +35,7 @@
     @Override
     public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
         Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
-                    new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+                    new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(1);
         infoMap.put(some.test.AllTypes.class, io.realm.AllTypesRealmProxy.getExpectedObjectSchemaInfo());
         return infoMap;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 46f59410df..9266f2c253 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -68,7 +68,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(2);
         fieldNames.add("name");
         fieldNames.add("age");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
@@ -148,7 +148,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
     }
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
-        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Simple");
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Simple", 2, 0);
         builder.addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
         builder.addPersistedProperty("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         return builder.build();
@@ -175,6 +175,7 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Simple obj = realm.createObjectInternal(some.test.Simple.class, true, excludeFields);
+
         final SimpleRealmProxyInterface objProxy = (SimpleRealmProxyInterface) obj;
         if (json.has("name")) {
             if (json.isNull("name")) {
@@ -369,6 +370,7 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         SimpleRealmProxyInterface realmSource = (SimpleRealmProxyInterface) realmObject;
         unmanagedCopy.realmSet$name(realmSource.realmGet$name());
         unmanagedCopy.realmSet$age(realmSource.realmGet$age());
+
         return unmanagedObject;
     }
 
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index bf4ad83f42..7b9265a049 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -158,6 +158,14 @@ project.afterEvaluate {
     tasks.withType(JavaCompile) {
         options.compilerArgs << '-Werror'
     }
+
+    tasks.all { task ->
+        android.productFlavors.all { flavor ->
+            if (task.name == "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal") {
+                task.dependsOn "assemble${flavor.name.capitalize()}"
+            }
+        }
+    }
 }
 
 // enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/08/kotlin-1-1-4-is-out/
@@ -558,6 +566,17 @@ project.afterEvaluate {
         if (project.hasProperty('buildTargetABIs') && project.getProperty('buildTargetABIs').trim().isEmpty()) {
             variant.externalNativeBuildTasks[0].enabled = false
         }
+
+        // all Java files must be compiled before native build
+        android.libraryVariants.all { anotherVariant ->
+            if (variant.flavorName == anotherVariant.flavorName) {
+                variant.externalNativeBuildTasks[0].dependsOn("compile${anotherVariant.name.capitalize()}JavaWithJavac")
+            }
+        }
+        // as of android gradle plugin 3.0.0-alpha5, generateJsonModel* triggers native build. Java files must be compiled before them.
+        android.buildTypes.all { buildType ->
+            tasks["generateJsonModel${variant.name.capitalize()}"].dependsOn "compile${variant.flavorName.capitalize()}${buildType.name.capitalize()}JavaWithJavac"
+        }
     }
 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index e8c659fdaf..42ece9c78d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -912,6 +912,27 @@ public void insertOrUpdate_shouldNotClearRealmList() {
         assertEquals(1, allTypes.getColumnRealmList().size());
     }
 
+    @Test
+    public void insertOrUpdate_ownList() {
+        realm.beginTransaction();
+        AllJavaTypes managedObj = realm.createObject(AllJavaTypes.class, 1);
+        managedObj.getFieldList().add(managedObj);
+        AllJavaTypes unmanagedObj = realm.copyFromRealm(managedObj);
+        unmanagedObj.setFieldList(managedObj.getFieldList());
+
+        // Check single object insert
+        realm.insertOrUpdate(unmanagedObj);
+        managedObj = realm.where(AllJavaTypes.class).findFirst();
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
+
+        // Check collection insert
+        realm.insertOrUpdate(Arrays.asList(unmanagedObj));
+        managedObj = realm.where(AllJavaTypes.class).findFirst();
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
+    }
+
     @Test
     public void insert_collectionOfManagedObjects() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index 0561dd58ed..d690a3fb44 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -593,11 +593,11 @@ public void migration_backlinkedSourceFieldDoesntExist() throws ClassNotFoundExc
 
         // Mock the schema info so the only difference compared with the original schema is that the LinkingObject field
         // points to BacklinksSource.childNotExist.
-        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget")
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget", 1, 1)
                 .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
                 .addComputedLinkProperty("parents", "BacklinksSource", "childNotExist" /*"child" is the original value*/)
                 .build();
-        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource")
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource", 2, 0)
                 .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
                 .addPersistedLinkProperty("child", RealmFieldType.OBJECT, "BacklinksTarget")
                 .build();
@@ -636,11 +636,11 @@ public void migration_backlinkedSourceFieldWrongType() {
 
         // Mock the schema info so the only difference compared with the original schema is that BacklinksSource.child
         // type is changed to BacklinksSource from BacklinksTarget.
-        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget")
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget", 1, 1)
                 .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
                 .addComputedLinkProperty("parents", "BacklinksSource", "child")
                 .build();
-        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource")
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource", 2, 0)
                 .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
                 .addPersistedLinkProperty("child", RealmFieldType.OBJECT,
                         "BacklinksSource"/*"BacklinksTarget" is the original value*/)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index be4bc94e1f..667336ce69 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -908,6 +908,37 @@ public void run() {
         thread.join();
     }
 
+    @Test
+    public void setter_list_ownList() {
+        // Create initial list
+        realm.beginTransaction();
+        RealmList<AllJavaTypes> allTypesRealmModels = new RealmList<>();
+        for (int i = 0; i < 2; i++) {
+            allTypesRealmModels.add(new AllJavaTypes(i));
+        }
+        AllJavaTypes model = new AllJavaTypes(2);
+        model.setFieldList(allTypesRealmModels);
+        model = realm.copyToRealm(model);
+        realm.commitTransaction();
+        assertEquals(2, model.getFieldList().size());
+
+        // Check that setting own list does not clear it by accident.
+        realm.beginTransaction();
+        model.setFieldList(model.getFieldList());
+        realm.commitTransaction();
+        assertEquals(2, model.getFieldList().size());
+
+        // Check that a unmanaged list throws the correct exception
+        realm.beginTransaction();
+        RealmList<AllJavaTypes> unmanagedList = new RealmList<>();
+        unmanagedList.addAll(realm.copyFromRealm(model.getFieldList()));
+        try {
+            model.setFieldList(unmanagedList);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
     @Test
     public void classNameConflictsWithFrameworkClass() {
         // The model class' name (Thread) clashed with a common Java class.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 37d51b8bcd..463d43a410 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -1810,6 +1810,19 @@ public void execute(Realm realm) {
         assertEquals(new Date(3L), obj.getColumnDateList().get(1));
     }
 
+    @Test
+    public void copyToRealmOrUpdate_overrideOwnList() {
+        realm.beginTransaction();
+        AllJavaTypes managedObj = realm.createObject(AllJavaTypes.class, 1);
+        managedObj.getFieldList().add(managedObj);
+        AllJavaTypes unmanagedObj = realm.copyFromRealm(managedObj);
+        unmanagedObj.setFieldList(managedObj.getFieldList());
+
+        managedObj = realm.copyToRealmOrUpdate(unmanagedObj);
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
+    }
+
     @Test
     public void copyToRealmOrUpdate_cyclicObject() {
         CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
index 2b266233ce..b5ff28356a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
@@ -51,7 +51,7 @@
 
     @Before
     public void setUp() {
-        OsObjectSchemaInfo objectSchemaInfo = new OsObjectSchemaInfo.Builder("TestModel")
+        OsObjectSchemaInfo objectSchemaInfo = new OsObjectSchemaInfo.Builder("TestModel",14, 0)
                 .addPersistedValueListProperty("longList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED)
                 .addPersistedValueListProperty("doubleList", RealmFieldType.DOUBLE_LIST,  !Property.REQUIRED)
                 .addPersistedValueListProperty("floatList", RealmFieldType.FLOAT_LIST, !Property.REQUIRED)
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index b2759133f5..f4dc71ac09 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -21,13 +21,10 @@
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.atomic.AtomicReference;
-
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -196,56 +193,6 @@ public void onError(SyncSession session, ObjectServerError error) {
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
 
-    // Check that if we manually trigger a Client Reset, then it should be possible to start
-    // downloading the Realm immediately after.
-    @Test
-    @RunTestInLooperThread
-    @Ignore("https://github.com/realm/realm-java/issues/5143")
-    public void clientReset_manualTriggerAllowSessionToRestart() {
-        SyncUser user = createTestUser();
-        String url = "realm://objectserver.realm.io/~/myrealm";
-        final AtomicReference<SyncConfiguration> configRef = new AtomicReference<>(null);
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
-                .errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
-
-                        // Execute Client Reset
-                        looperThread.closeTestRealms();
-                        handler.executeClientReset();
-
-                        // Try to re-open Realm and download it again
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                // Validate that files have been moved
-                                assertFalse(handler.getOriginalFile().exists());
-                                assertTrue(handler.getBackupFile().exists());
-
-                                SyncConfiguration config = configRef.get();
-                                Realm instance = Realm.getInstance(config);
-                                looperThread.addTestRealm(instance);
-                                try {
-                                    SyncManager.getSession(config).downloadAllServerChanges();
-                                    looperThread.testComplete();
-                                } catch (InterruptedException e) {
-                                    fail(e.toString());
-                                }
-                            }
-                        });
-                    }
-                })
-                .build();
-        configRef.set(config);
-
-        Realm realm = Realm.getInstance(config);
-        looperThread.addTestRealm(realm);
-
-        // Trigger error
-        SyncManager.simulateClientReset(SyncManager.getSession(config));
-    }
-
     // Check that we can use the backup SyncConfiguration to open the Realm.
     @Test
     @RunTestInLooperThread
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index c87639c9c6..b12d014bea 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -149,7 +149,7 @@ public void breakingSchemaChange_throws() {
                 .build();
 
         // Setup initial Realm schema (with a different primary key)
-        OsObjectSchemaInfo expectedObjectSchema = new OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME)
+        OsObjectSchemaInfo expectedObjectSchema = new OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)
                 .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)
                 .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)
                 .build();
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
index 4b864a0b6f..b291ea3c28 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -16,11 +16,14 @@
 
 #include "io_realm_internal_OsObjectSchemaInfo.h"
 
+#include <realm/util/assert.hpp>
+
 #include <object_schema.hpp>
 #include <property.hpp>
 
-#include "jni_util/java_exception_thrower.hpp"
+#include "java_accessor.hpp"
 #include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 #include "util.hpp"
 
 using namespace realm;
@@ -53,24 +56,33 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetFinal
     return reinterpret_cast<jlong>(&finalize_object_schema);
 }
 
-
-JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperty(JNIEnv* env, jclass,
-                                                                                   jlong native_ptr,
-                                                                                   jlong property_ptr,
-                                                                                   jboolean is_computed)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperties(JNIEnv* env, jclass,
+                                                                                     jlong native_ptr,
+                                                                                     jlongArray j_persisted_properties,
+                                                                                     jlongArray j_computed_properties)
 {
     TR_ENTER_PTR(native_ptr)
     try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
-        Property* property = reinterpret_cast<Property*>(property_ptr);
-        if (is_computed) {
-            object_schema->computed_properties.push_back(*property);
-        }
-        else {
-            object_schema->persisted_properties.push_back(*property);
-            if (property->is_primary) {
-                object_schema->primary_key = property->name;
+        ObjectSchema& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        JLongArrayAccessor persisted_properties(env, j_persisted_properties);
+        for (jsize i = 0; i < persisted_properties.size(); ++i)
+        {
+            Property* prop = reinterpret_cast<Property*>(persisted_properties[i]);
+            REALM_ASSERT_DEBUG(prop != nullptr);
+            if (prop->is_primary) {
+                object_schema.primary_key = prop->name;
             }
+            object_schema.persisted_properties.emplace_back(std::move(*prop));
+            delete prop;
+        }
+
+        JLongArrayAccessor computed_properties(env, j_computed_properties);
+        for (jsize i = 0; i < computed_properties.size(); ++i)
+        {
+            Property* prop = reinterpret_cast<Property*>(computed_properties[i]);
+            REALM_ASSERT_DEBUG(prop != nullptr);
+            object_schema.computed_properties.emplace_back(std::move(*prop));
+            delete prop;
         }
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 0d0615caaf..8a387856db 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 0d0615caaf0df6dbccca3f86a05303892c3a7a2e
+Subproject commit 8a387856db0beb6a95e385546d1752188aff14a6
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index a47679b12b..7ebdce93e2 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -22,6 +22,7 @@
 
 import io.realm.internal.ObserverPairList;
 import io.realm.internal.PendingRow;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.OsObject;
 import io.realm.internal.UncheckedRow;
@@ -200,4 +201,19 @@ public void onQueryFinished(Row row) {
             registerToObjectNotifier();
         }
     }
+
+    /**
+     * Check that object is a valid and managed object by this Realm.
+     * Used by proxy classes to verify input.
+     *
+     * @param value model object
+     */
+    public void checkValidObject(RealmModel value) {
+        if (!RealmObject.isValid(value) || !RealmObject.isManaged(value)) {
+            throw new IllegalArgumentException("'value' is not a valid managed object.");
+        }
+        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != getRealm$realm()) {
+            throw new IllegalArgumentException("'value' belongs to a different Realm.");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index b5416f96e4..65681c1767 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -246,7 +246,11 @@ public static synchronized void init(Context context) {
             RealmCore.loadLibrary(context);
             setDefaultConfiguration(new RealmConfiguration.Builder(context).build());
             ObjectServerFacade.getSyncFacadeIfPossible().init(context);
-            BaseRealm.applicationContext = context.getApplicationContext();
+            if (context.getApplicationContext() != null) {
+                BaseRealm.applicationContext = context.getApplicationContext();
+            } else {
+                BaseRealm.applicationContext = context;
+            }
             SharedRealm.initialize(new File(context.getFilesDir(), ".realm.temp"));
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
index 5b25bc1d43..dc23ee4f0f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -16,9 +16,6 @@
 package io.realm.internal;
 
 
-import java.util.ArrayList;
-import java.util.List;
-
 import javax.annotation.Nullable;
 
 import io.realm.RealmFieldType;
@@ -31,9 +28,11 @@
 public class OsObjectSchemaInfo implements NativeObject {
 
     public static class Builder {
-        private String className;
-        private List<Property> persistedPropertyList = new ArrayList<Property>();
-        private List<Property> computedPropertyList = new ArrayList<Property>();
+        private final String className;
+        private final long[] persistedPropertyPtrArray;
+        private int persistedPropertyPtrCurPos = 0;
+        private final long[] computedPropertyPtrArray;
+        private int computedPropertyPtrCurPos = 0;
 
         /**
          * Creates an empty builder for {@code OsObjectSchemaInfo}. This constructor is intended to be used by
@@ -41,8 +40,10 @@
          *
          * @param className name of the class
          */
-        public Builder(String className) {
+        public Builder(String className, int persistedPropertyCapacity, int computedPropertyCapacity) {
             this.className = className;
+            this.persistedPropertyPtrArray = new long[persistedPropertyCapacity];
+            this.computedPropertyPtrArray = new long[computedPropertyCapacity];
         }
 
         /**
@@ -57,8 +58,10 @@ public Builder(String className) {
          */
         public Builder addPersistedProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
                 boolean isRequired) {
-            final Property property = new Property(name, type, isPrimaryKey, isIndexed, isRequired);
-            persistedPropertyList.add(property);
+            long propertyPtr = Property.nativeCreatePersistedProperty(name,
+                    Property.convertFromRealmFieldType(type, isRequired), isPrimaryKey, isIndexed);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
             return this;
         }
 
@@ -71,8 +74,10 @@ public Builder addPersistedProperty(String name, RealmFieldType type, boolean is
          * @return this {@code OsObjectSchemaInfo}.
          */
         public Builder addPersistedValueListProperty(String name, RealmFieldType type, boolean isRequired) {
-            final Property property = new Property(name, type, !Property.PRIMARY_KEY, !Property.INDEXED, isRequired);
-            persistedPropertyList.add(property);
+            long propertyPtr = Property.nativeCreatePersistedProperty(name,
+                    Property.convertFromRealmFieldType(type, isRequired), !Property.PRIMARY_KEY, !Property.INDEXED);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
             return this;
         }
 
@@ -86,8 +91,10 @@ public Builder addPersistedValueListProperty(String name, RealmFieldType type, b
          * @return this {@code OsObjectSchemaInfo.Builder}.
          */
         public Builder addPersistedLinkProperty(String name, RealmFieldType type, String linkedClassName) {
-            final Property property = new Property(name, type, linkedClassName);
-            persistedPropertyList.add(property);
+            long propertyPtr = Property.nativeCreatePersistedLinkProperty(name,
+                    Property.convertFromRealmFieldType(type, false), linkedClassName);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
             return this;
         }
 
@@ -102,20 +109,26 @@ public Builder addPersistedLinkProperty(String name, RealmFieldType type, String
          * @return this {@code OsObjectSchemaInfo.Builder}.
          */
         public Builder addComputedLinkProperty(String name, String targetClassname, String targetFieldName) {
-            final Property property = new Property(name, targetClassname, targetFieldName);
-            computedPropertyList.add(property);
+            long propertyPtr = Property.nativeCreateComputedLinkProperty(name, targetClassname, targetFieldName);
+            computedPropertyPtrArray[computedPropertyPtrCurPos] = propertyPtr;
+            computedPropertyPtrCurPos++;
             return this;
         }
 
+        /**
+         * Creates {@link OsObjectSchemaInfo} object from this builder. After calling, this {@code Builder} becomes
+         * invalid. All the property pointers will be freed.
+         *
+         * @return a newly created {@link OsObjectSchemaInfo}.
+         */
         public OsObjectSchemaInfo build() {
-            OsObjectSchemaInfo info = new OsObjectSchemaInfo(className);
-            for (Property property : persistedPropertyList) {
-                nativeAddProperty(info.nativePtr, property.getNativePtr(), false);
-            }
-            for (Property property : computedPropertyList) {
-                nativeAddProperty(info.nativePtr, property.getNativePtr(), true);
+            if (persistedPropertyPtrCurPos == -1 || computedPropertyPtrCurPos == -1) {
+                throw new IllegalStateException("'OsObjectSchemaInfo.build()' has been called before on this object.");
             }
-
+            OsObjectSchemaInfo info = new OsObjectSchemaInfo(className);
+            nativeAddProperties(info.nativePtr, persistedPropertyPtrArray, computedPropertyPtrArray);
+            persistedPropertyPtrCurPos = -1;
+            computedPropertyPtrCurPos = -1;
             return info;
         }
     }
@@ -186,7 +199,8 @@ public long getNativeFinalizerPtr() {
 
     private static native long nativeGetFinalizerPtr();
 
-    private static native void nativeAddProperty(long nativePtr, long nativePropertyPtr, boolean isComputed);
+    // Add properties to the ObjectSchema and delete property pointers.
+    private static native void nativeAddProperties(long nativePtr, long[] persistedPropPtrs, long[] computedPropPtrs);
 
     private static native String nativeGetClassName(long nativePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Property.java b/realm/realm-library/src/main/java/io/realm/internal/Property.java
index 03a1026223..0bcff85f24 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Property.java
@@ -67,24 +67,12 @@
     private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
-    Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
-        this(nativeCreatePersistedProperty(name, convertFromRealmFieldType(type, isRequired), isPrimary, isIndexed));
-    }
-
-    Property(String name, RealmFieldType type, String linkedClassName) {
-        this(nativeCreatePersistedLinkProperty(name, convertFromRealmFieldType(type, false), linkedClassName));
-    }
-
-    Property(String name, String sourceClassName, String sourceFieldName) {
-        this(nativeCreateComputedLinkProperty(name, sourceClassName, sourceFieldName));
-    }
-
     Property(long nativePtr) {
         this.nativePtr = nativePtr;
         NativeContext.dummyContext.addReference(this);
     }
 
-    private static int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequired) {
+    static int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequired) {
         int type;
         switch (fieldType) {
             case OBJECT:
@@ -217,12 +205,14 @@ public long getNativeFinalizerPtr() {
 
     private static native long nativeGetFinalizerPtr();
 
-    private static native long nativeCreatePersistedProperty(
+    // nativeCreateXxxProperty will be called by OsObjectSchemaInfo directly to avoid creating temporary Property
+    // objects.
+    static native long nativeCreatePersistedProperty(
             String name, int type, boolean isPrimary, boolean isIndexed);
 
-    private static native long nativeCreatePersistedLinkProperty(String name, int type, String linkedToName);
+    static native long nativeCreatePersistedLinkProperty(String name, int type, String linkedToName);
 
-    private static native long nativeCreateComputedLinkProperty(
+    static native long nativeCreateComputedLinkProperty(
             String name, String sourceClassName, String sourceFieldName);
 
     private static native int nativeGetType(long nativePtr);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index f2fb6af2c6..21399cc133 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -14,6 +14,7 @@
 import java.util.Arrays;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
@@ -21,6 +22,7 @@
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
@@ -445,4 +447,54 @@ public void run() {
         realm.close();
     }
 
+    // Check that if we manually trigger a Client Reset, then it should be possible to start
+    // downloading the Realm immediately after.
+    @Test
+    @RunTestInLooperThread
+    public void clientReset_manualTriggerAllowSessionToRestart() {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final AtomicReference<SyncConfiguration> configRef = new AtomicReference<>(null);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM).directory(looperThread.getRoot())
+
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Try to re-open Realm and download it again
+                        looperThread.postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                // Validate that files have been moved
+                                assertFalse(handler.getOriginalFile().exists());
+                                assertTrue(handler.getBackupFile().exists());
+
+                                SyncConfiguration config = configRef.get();
+                                Realm instance = Realm.getInstance(config);
+                                looperThread.addTestRealm(instance);
+                                try {
+                                    SyncManager.getSession(config).downloadAllServerChanges();
+                                    looperThread.testComplete();
+                                } catch (InterruptedException e) {
+                                    fail(e.toString());
+                                }
+                            }
+                        });
+                    }
+                })
+                .build();
+        configRef.set(config);
+
+        Realm realm = Realm.getInstance(config);
+        looperThread.addTestRealm(realm);
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
 }
diff --git a/tools/update_gradle_wrapper.sh b/tools/update_gradle_wrapper.sh
index b20f7006b1..224817cf23 100755
--- a/tools/update_gradle_wrapper.sh
+++ b/tools/update_gradle_wrapper.sh
@@ -10,8 +10,6 @@ HERE=`pwd`
 
 cd "$(dirname $0)/.."
 
-pushd .
-
 for i in $(find $(pwd) -type f -name gradlew); do
     cd $(dirname $i)
     pwd
@@ -19,13 +17,5 @@ for i in $(find $(pwd) -type f -name gradlew); do
     sed -E -i '' s/-bin\\.zip\$/-all.zip/ gradle/wrapper/gradle-wrapper.properties
 done
 
-popd
-
-sed -i '' '/^APP_ARGS=/a\
-# Realm'"'"'s work-around for a bug in Gradle 4.1 https://github.com/gradle/gradle/issues/2673\
-APP_ARGS="\${APP_ARGS} '"'"'--console=plain'"'"' \\\\\
-\ "\
-' gradlew
-
 cd $HERE
 
