diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index 287910c0e6..dfd0d86713 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -1,4 +1,5 @@
 buildscript {
+    ext.kotlin_version = '1.3.31'
     def properties = new Properties()
     properties.load(new FileInputStream("${rootDir}/../dependencies.list"))
 
@@ -10,6 +11,7 @@ buildscript {
     dependencies {
         classpath "com.android.tools.build:gradle:${properties.get("GRADLE_BUILD_TOOLS")}"
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
@@ -22,18 +24,21 @@ allprojects {
 }
 
 apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android-extensions'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-kapt'
 apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 27
+    compileSdkVersion 28
     buildToolsVersion "${project.ext.get("ANDROID_BUILD_TOOLS")}"
 
     defaultConfig {
         minSdkVersion 15
-        targetSdkVersion 27
+        targetSdkVersion 28
         versionCode 1
         versionName "1.0"
-        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        testInstrumentationRunner "androidx.benchmark.AndroidBenchmarkRunner"
     }
 
     buildTypes {
@@ -52,10 +57,8 @@ repositories {
 }
 
 dependencies {
-    androidTestImplementation 'com.android.support.test:runner:1.0.1'
-    androidTestImplementation 'com.android.support.test:rules:1.0.1'
-    androidTestImplementation 'junit:junit:4.12'
-    androidTestImplementation 'dk.ilios:spanner:0.6.0'
-    androidTestImplementation 'com.opencsv:opencsv:3.4'
+    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
+    androidTestImplementation "androidx.benchmark:benchmark:1.0.0-alpha01"
     androidTestImplementation 'junit:junit:4.12'
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
 }
diff --git a/library-benchmarks/src/androidTest/AndroidManifest.xml b/library-benchmarks/src/androidTest/AndroidManifest.xml
new file mode 100644
index 0000000000..e22ad7e7eb
--- /dev/null
+++ b/library-benchmarks/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="io.realm.benchmarks">
+
+    <application
+        android:debuggable="false"
+        tools:ignore="HardcodedDebugMode"
+        tools:replace="android:debuggable"/>
+
+</manifest>
+
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
deleted file mode 100644
index 16efd9642e..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.java
+++ /dev/null
@@ -1,123 +0,0 @@
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmList;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-import io.realm.benchmarks.entities.AllTypesPrimaryKey;
-
-
-@RunWith(SpannerRunner.class)
-public class CopyToRealmBenchmarks {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private static final int COLLECTION_SIZE = 100;
-    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
-    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
-    private ArrayList<AllTypesPrimaryKey> complextTestObjects;
-    private ArrayList<AllTypes> simpleTestObjects;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-
-        // Create test data
-        complextTestObjects = new ArrayList<>();
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-            obj.setColumnString("obj" + i);
-            obj.setColumnLong(i);
-            obj.setColumnFloat(1.23F);
-            obj.setColumnDouble(1.234);
-            obj.setColumnBoolean(true);
-            obj.setColumnDate(new Date(1000));
-            obj.setColumnBinary(new byte[] {1,2,3});
-            obj.setColumnRealmObject(obj);
-            obj.setColumnRealmList(new RealmList<>(obj, obj, obj));
-            obj.setColumnBooleanList(new RealmList<>(true, false, true));
-            obj.setColumnStringList(new RealmList<>("foo", "bar", "baz"));
-            obj.setColumnBinaryList(new RealmList<>(new byte[]{0,1,2},new byte[]{2,3,4},new byte[]{4,5,6}));
-            obj.setColumnByteList(new RealmList<>((byte)1,(byte)2,(byte)3));
-            obj.setColumnShortList(new RealmList<>((short)1,(short)2,(short)3));
-            obj.setColumnIntegerList(new RealmList<>(1,2,3));
-            obj.setColumnLongList(new RealmList<>(1L,2L,3L));
-            obj.setColumnFloatList(new RealmList<>(1.1F, 1.2F, 1.3F));
-            obj.setColumnDoubleList(new RealmList<>(1.111, 1.222, 1.333));
-            obj.setColumnDateList(new RealmList<>(new Date(1000), new Date(2000), new Date(3000)));
-            complextTestObjects.add(obj);
-        }
-
-        simpleTestObjects = new ArrayList<>();
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            AllTypes obj = new AllTypes();
-            obj.setColumnString("obj" + i);
-            obj.setColumnLong(i);
-            obj.setColumnFloat(1.23F);
-            obj.setColumnDouble(1.234);
-            obj.setColumnBoolean(true);
-            obj.setColumnDate(new Date(1000));
-            obj.setColumnBinary(new byte[] {1,2,3});
-            simpleTestObjects.add(obj);
-        }
-
-        // Setup Realm before test
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.cancelTransaction();
-        realm.close();
-    }
-
-    @Benchmark
-    public void copyToRealm_complexObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealmOrUpdate(complextTestObjects);
-        }
-    }
-
-    @Benchmark
-    public void copyToRealm_simpleObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealm(simpleTestObjects);
-        }
-    }
-
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.kt
new file mode 100644
index 0000000000..9f884e76ca
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmBenchmarks.kt
@@ -0,0 +1,114 @@
+/* Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.platform.app.InstrumentationRegistry
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.RealmList
+import io.realm.benchmarks.entities.AllTypes
+import io.realm.benchmarks.entities.AllTypesPrimaryKey
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.util.*
+
+
+@RunWith(AndroidJUnit4::class)
+class CopyToRealmBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private val COLLECTION_SIZE = 100
+    private lateinit var realm: Realm
+    private val noPkObjects = ArrayList<AllTypes>(COLLECTION_SIZE)
+    private val pkObjects = ArrayList<AllTypesPrimaryKey>(COLLECTION_SIZE)
+    private lateinit var complextTestObjects: ArrayList<AllTypesPrimaryKey>
+    private lateinit var simpleTestObjects: ArrayList<AllTypes>
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+
+        // Create test data
+        complextTestObjects = ArrayList()
+        for (i in 0 until COLLECTION_SIZE) {
+            val obj = AllTypesPrimaryKey()
+            obj.columnString = "obj$i"
+            obj.columnLong = i.toLong()
+            obj.columnFloat = 1.23f
+            obj.columnDouble = 1.234
+            obj.isColumnBoolean = true
+            obj.columnDate = Date(1000)
+            obj.columnBinary = byteArrayOf(1, 2, 3)
+            obj.columnRealmObject = obj
+            obj.columnRealmList = RealmList(obj, obj, obj)
+            obj.columnBooleanList = RealmList(true, false, true)
+            obj.columnStringList = RealmList("foo", "bar", "baz")
+            obj.columnBinaryList = RealmList(byteArrayOf(0, 1, 2), byteArrayOf(2, 3, 4), byteArrayOf(4, 5, 6))
+            obj.columnByteList = RealmList(1.toByte(), 2.toByte(), 3.toByte())
+            obj.columnShortList = RealmList(1.toShort(), 2.toShort(), 3.toShort())
+            obj.columnIntegerList = RealmList(1, 2, 3)
+            obj.columnLongList = RealmList(1L, 2L, 3L)
+            obj.columnFloatList = RealmList(1.1f, 1.2f, 1.3f)
+            obj.columnDoubleList = RealmList(1.111, 1.222, 1.333)
+            obj.columnDateList = RealmList(Date(1000), Date(2000), Date(3000))
+            complextTestObjects.add(obj)
+        }
+
+        simpleTestObjects = ArrayList()
+        for (i in 0 until COLLECTION_SIZE) {
+            val obj = AllTypes()
+            obj.columnString = "obj$i"
+            obj.columnLong = i.toLong()
+            obj.columnFloat = 1.23f
+            obj.columnDouble = 1.234
+            obj.isColumnBoolean = true
+            obj.columnDate = Date(1000)
+            obj.columnBinary = byteArrayOf(1, 2, 3)
+            simpleTestObjects.add(obj)
+        }
+
+        // Setup Realm before test
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+    }
+
+    @After
+    fun after() {
+        realm.cancelTransaction()
+        realm.close()
+    }
+
+    @Test
+    fun copyToRealm_complexObjects() = benchmarkRule.measureRepeated {
+        realm.copyToRealmOrUpdate(complextTestObjects)
+    }
+
+    @Test
+    fun copyToRealm_simpleObjects() = benchmarkRule.measureRepeated {
+        realm.copyToRealm(simpleTestObjects)
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
deleted file mode 100644
index 8490a274a9..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.java
+++ /dev/null
@@ -1,143 +0,0 @@
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.ImportFlag;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmList;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-import io.realm.benchmarks.entities.AllTypesPrimaryKey;
-
-
-@RunWith(SpannerRunner.class)
-public class CopyToRealmOrUpdateBenchmarks {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private static final int COLLECTION_SIZE = 100;
-    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
-    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
-    private ArrayList<AllTypesPrimaryKey> complextTestObjects;
-    private ArrayList<AllTypes> simpleTestObjects;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-
-        // Setup Realm before test
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-
-        // Create test data
-        complextTestObjects = new ArrayList<>();
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
-            obj.setColumnString("obj" + i);
-            obj.setColumnLong(i);
-            obj.setColumnFloat(1.23F);
-            obj.setColumnDouble(1.234);
-            obj.setColumnBoolean(true);
-            obj.setColumnDate(new Date(1000));
-            obj.setColumnBinary(new byte[] {1,2,3});
-            obj.setColumnRealmObject(obj);
-            obj.setColumnRealmList(new RealmList<>(obj, obj, obj));
-            obj.setColumnBooleanList(new RealmList<>(true, false, true));
-            obj.setColumnStringList(new RealmList<>("foo", "bar", "baz"));
-            obj.setColumnBinaryList(new RealmList<>(new byte[]{0,1,2},new byte[]{2,3,4},new byte[]{4,5,6}));
-            obj.setColumnByteList(new RealmList<>((byte)1,(byte)2,(byte)3));
-            obj.setColumnShortList(new RealmList<>((short)1,(short)2,(short)3));
-            obj.setColumnIntegerList(new RealmList<>(1,2,3));
-            obj.setColumnLongList(new RealmList<>(1L,2L,3L));
-            obj.setColumnFloatList(new RealmList<>(1.1F, 1.2F, 1.3F));
-            obj.setColumnDoubleList(new RealmList<>(1.111, 1.222, 1.333));
-            obj.setColumnDateList(new RealmList<>(new Date(1000), new Date(2000), new Date(3000)));
-            complextTestObjects.add(obj);
-        }
-
-        simpleTestObjects = new ArrayList<>();
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            AllTypes obj = new AllTypes();
-            obj.setColumnString("obj" + i);
-            obj.setColumnLong(i);
-            obj.setColumnFloat(1.23F);
-            obj.setColumnDouble(1.234);
-            obj.setColumnBoolean(true);
-            obj.setColumnDate(new Date(1000));
-            obj.setColumnBinary(new byte[] {1,2,3});
-            simpleTestObjects.add(obj);
-        }
-
-        realm.copyToRealmOrUpdate(complextTestObjects);
-        realm.copyToRealmOrUpdate(simpleTestObjects);
-        realm.commitTransaction();
-        realm.beginTransaction();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.cancelTransaction();
-        realm.close();
-    }
-
-    @Benchmark
-    public void copyToRealmOrDiffedUpdate_complexObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealmOrUpdate(complextTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
-        }
-    }
-
-    @Benchmark
-    public void copyToRealmOrFullUpdate_complexObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealmOrUpdate(complextTestObjects);
-        }
-    }
-
-    @Benchmark
-    public void copyToRealmOrDiffedUpdate_simpleObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealm(simpleTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET);
-        }
-    }
-
-    @Benchmark
-    public void copyToRealmOrFullUpdate_simpleObjects(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.copyToRealm(simpleTestObjects);
-        }
-    }
-
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.kt
new file mode 100644
index 0000000000..912c9266bb
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/CopyToRealmOrUpdateBenchmarks.kt
@@ -0,0 +1,138 @@
+/* Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.ImportFlag
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.RealmList
+import io.realm.benchmarks.entities.AllTypes
+import io.realm.benchmarks.entities.AllTypesPrimaryKey
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.util.*
+
+
+@RunWith(AndroidJUnit4::class)
+class CopyToRealmOrUpdateBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private val COLLECTION_SIZE = 100
+    private lateinit var realm: Realm
+    private val noPkObjects = ArrayList<AllTypes>(COLLECTION_SIZE)
+    private val pkObjects = ArrayList<AllTypesPrimaryKey>(COLLECTION_SIZE)
+    private var complextTestObjects: ArrayList<AllTypesPrimaryKey>? = null
+    private var simpleTestObjects: ArrayList<AllTypes>? = null
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+
+        // Setup Realm before test
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+
+        // Create test data
+        complextTestObjects = ArrayList()
+        for (i in 0 until COLLECTION_SIZE) {
+            val obj = AllTypesPrimaryKey()
+            obj.columnString = "obj$i"
+            obj.columnLong = i.toLong()
+            obj.columnFloat = 1.23f
+            obj.columnDouble = 1.234
+            obj.isColumnBoolean = true
+            obj.columnDate = Date(1000)
+            obj.columnBinary = byteArrayOf(1, 2, 3)
+            obj.columnRealmObject = obj
+            obj.columnRealmList = RealmList(obj, obj, obj)
+            obj.columnBooleanList = RealmList(true, false, true)
+            obj.columnStringList = RealmList("foo", "bar", "baz")
+            obj.columnBinaryList = RealmList(byteArrayOf(0, 1, 2), byteArrayOf(2, 3, 4), byteArrayOf(4, 5, 6))
+            obj.columnByteList = RealmList(1.toByte(), 2.toByte(), 3.toByte())
+            obj.columnShortList = RealmList(1.toShort(), 2.toShort(), 3.toShort())
+            obj.columnIntegerList = RealmList(1, 2, 3)
+            obj.columnLongList = RealmList(1L, 2L, 3L)
+            obj.columnFloatList = RealmList(1.1f, 1.2f, 1.3f)
+            obj.columnDoubleList = RealmList(1.111, 1.222, 1.333)
+            obj.columnDateList = RealmList(Date(1000), Date(2000), Date(3000))
+            complextTestObjects!!.add(obj)
+        }
+
+        simpleTestObjects = ArrayList()
+        for (i in 0 until COLLECTION_SIZE) {
+            val obj = AllTypes()
+            obj.columnString = "obj$i"
+            obj.columnLong = i.toLong()
+            obj.columnFloat = 1.23f
+            obj.columnDouble = 1.234
+            obj.isColumnBoolean = true
+            obj.columnDate = Date(1000)
+            obj.columnBinary = byteArrayOf(1, 2, 3)
+            simpleTestObjects!!.add(obj)
+        }
+
+        realm.copyToRealmOrUpdate(complextTestObjects)
+        realm.copyToRealmOrUpdate(simpleTestObjects)
+        realm.commitTransaction()
+        realm.beginTransaction()
+    }
+
+    @After
+    fun after() {
+        realm.cancelTransaction()
+        realm.close()
+    }
+
+    @Test
+    fun copyToRealmOrDiffedUpdate_complexObjects() {
+        benchmarkRule.measureRepeated {
+            realm.copyToRealmOrUpdate(complextTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET)
+        }
+    }
+
+    @Test
+    fun copyToRealmOrFullUpdate_complexObjects() {
+        benchmarkRule.measureRepeated {
+            realm.copyToRealmOrUpdate(complextTestObjects)
+        }
+    }
+
+    @Test
+    fun copyToRealmOrDiffedUpdate_simpleObjects() {
+        benchmarkRule.measureRepeated {
+            realm.copyToRealm(simpleTestObjects, ImportFlag.CHECK_SAME_VALUES_BEFORE_SET)
+        }
+    }
+
+    @Test
+    fun copyToRealmOrFullUpdate_simpleObjects() {
+        benchmarkRule.measureRepeated {
+            realm.copyToRealm(simpleTestObjects)
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java
deleted file mode 100644
index 3365dabc55..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmQuery;
-import io.realm.RealmResults;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmAllocBenchmarks {
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class).getColumnRealmList().add(realm.createObject(AllTypes.class));
-        realm.commitTransaction();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.close();
-    }
-
-    @Benchmark
-    public void createObjects(long reps) {
-        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        for (long i = 0; i < reps; i++) {
-            results.first();
-        }
-    }
-
-    @Benchmark
-    public void createQueries(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.where(AllTypes.class);
-        }
-    }
-    @Benchmark
-    public void createRealmResults(long reps) {
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
-        for (long i = 0; i < reps; i++) {
-            query.findAll();
-        }
-    }
-
-    @Benchmark
-    public void createRealmLists(long reps) {
-        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-        for (long i = 0; i < reps; i++) {
-            //noinspection ConstantConditions
-            allTypes.getColumnRealmList();
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.kt
new file mode 100644
index 0000000000..cd69171559
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.kt
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmAllocBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+        realm.createObject(AllTypes::class.java).columnRealmList.add(realm.createObject(AllTypes::class.java))
+        realm.commitTransaction()
+    }
+
+    @After
+    fun after() {
+        realm.close()
+    }
+
+    @Test
+    fun createObjects() {
+        val results = realm.where(AllTypes::class.java).findAll()
+        benchmarkRule.measureRepeated {
+            results.first()
+        }
+    }
+
+    @Test
+    fun createQueries() {
+        benchmarkRule.measureRepeated {
+            realm.where(AllTypes::class.java)
+        }
+    }
+
+    @Test
+    fun createRealmResults() {
+        val query = realm.where(AllTypes::class.java)
+        benchmarkRule.measureRepeated {
+            query.findAll()
+        }
+    }
+
+    @Test
+    fun createRealmLists() {
+        val allTypes = realm.where(AllTypes::class.java).findFirst()!!
+        benchmarkRule.measureRepeated {
+            allTypes.columnRealmList
+        }
+    }
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java
deleted file mode 100644
index a05d2676e8..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmBenchmarks {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private AllTypes readObject;
-    private RealmConfiguration coldConfig;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        coldConfig = new RealmConfiguration.Builder().name("cold").build();
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(coldConfig);
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                readObject = realm.createObject(AllTypes.class);
-                readObject.setColumnString("Foo");
-                readObject.setColumnLong(42);
-                readObject.setColumnDouble(1.234D);
-            }
-        });
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.close();
-    }
-
-    @Benchmark
-    public void coldCreateAndClose(long reps) {
-        for (long i = 0; i < reps; i++) {
-            Realm realm = Realm.getInstance(coldConfig);
-            realm.close();
-        }
-    }
-
-    @Benchmark
-    public void emptyTransaction(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.beginTransaction();
-            realm.commitTransaction();
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.kt
new file mode 100644
index 0000000000..ec7862954f
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.kt
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.platform.app.InstrumentationRegistry
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@RunWith(AndroidJUnit4::class)
+class RealmBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private lateinit var realm: Realm
+    private lateinit var readObject: AllTypes
+    private lateinit var coldConfig: RealmConfiguration
+
+    @Before
+    fun setUp() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        coldConfig = RealmConfiguration.Builder().name("cold").build()
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(coldConfig)
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.executeTransaction { realm ->
+            readObject = realm.createObject(AllTypes::class.java)
+            readObject.columnString = "Foo"
+            readObject.columnLong = 42
+            readObject.columnDouble = 1.234
+        }
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun coldCreateAndClose() {
+        benchmarkRule.measureRepeated {
+            val realm = Realm.getInstance(coldConfig)
+            realm.close()
+        }
+    }
+
+    @Test
+    fun emptyTransaction() {
+        benchmarkRule.measureRepeated {
+            realm.beginTransaction()
+            realm.commitTransaction()
+        }
+    }
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java
deleted file mode 100644
index b8151e9e95..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-import io.realm.benchmarks.entities.AllTypesPrimaryKey;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmInsertBenchmark {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private static final int COLLECTION_SIZE = 100;
-    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
-    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            noPkObjects.add(new AllTypes());
-        }
-
-        for (int i = 0; i < COLLECTION_SIZE; i++) {
-            AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
-            allTypesPrimaryKey.setColumnLong(i);
-            pkObjects.add(allTypesPrimaryKey);
-        }
-
-        realm.beginTransaction();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.cancelTransaction();
-        realm.close();
-    }
-
-    @Benchmark
-    public void insertNoPrimaryKey(long reps) {
-        AllTypes allTypes = new AllTypes();
-        for (long i = 0; i < reps; i++) {
-            realm.insert(allTypes);
-        }
-    }
-
-    @Benchmark
-    public void insertNoPrimaryKeyList(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.insert(noPkObjects);
-        }
-    }
-
-    @Benchmark
-    public void insertWithPrimaryKey(long reps) {
-        AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
-        for (long i = 0; i < reps; i++) {
-            allTypesPrimaryKey.setColumnLong(i);
-            realm.insertOrUpdate(allTypesPrimaryKey);
-        }
-    }
-
-    @Benchmark
-    public void insertOrUpdateWithPrimaryKeyList(long reps) {
-        for (long i = 0; i < reps; i++) {
-            realm.insertOrUpdate(pkObjects);
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.kt
new file mode 100644
index 0000000000..dc22dd4e1c
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.benchmarks.entities.AllTypes
+import io.realm.benchmarks.entities.AllTypesPrimaryKey
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.util.*
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmInsertBenchmark {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private val COLLECTION_SIZE = 100
+    private lateinit var realm: Realm
+    private val noPkObjects = ArrayList<AllTypes>(COLLECTION_SIZE)
+    private val pkObjects = ArrayList<AllTypesPrimaryKey>(COLLECTION_SIZE)
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+
+        for (i in 0 until COLLECTION_SIZE) {
+            noPkObjects.add(AllTypes())
+        }
+
+        for (i in 0 until COLLECTION_SIZE) {
+            val allTypesPrimaryKey = AllTypesPrimaryKey()
+            allTypesPrimaryKey.columnLong = i.toLong()
+            pkObjects.add(allTypesPrimaryKey)
+        }
+
+        realm.beginTransaction()
+    }
+
+    @After
+    fun after() {
+        realm.cancelTransaction()
+        realm.close()
+    }
+
+    @Test
+    fun insertNoPrimaryKey() {
+        val allTypes = AllTypes()
+        benchmarkRule.measureRepeated {
+            realm.insert(allTypes)
+        }
+    }
+
+    @Test
+    fun insertNoPrimaryKeyList() {
+        benchmarkRule.measureRepeated {
+            realm.insert(noPkObjects)
+        }
+    }
+
+    @Test
+    fun insertWithPrimaryKey() {
+        val allTypesPrimaryKey = AllTypesPrimaryKey()
+        var i: Long = 0
+        benchmarkRule.measureRepeated {
+            allTypesPrimaryKey.columnLong = (i++)
+            realm.insertOrUpdate(allTypesPrimaryKey)
+        }
+    }
+
+    @Test
+    fun insertOrUpdateWithPrimaryKeyList() {
+        benchmarkRule.measureRepeated {
+            realm.insertOrUpdate(pkObjects)
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
deleted file mode 100644
index 974fe33815..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmObjectReadBenchmarks {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private AllTypes readObject;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                readObject = realm.createObject(AllTypes.class);
-                readObject.setColumnString("Foo");
-                readObject.setColumnLong(42);
-                readObject.setColumnDouble(1.234D);
-            }
-        });
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.close();
-    }
-
-    @Benchmark
-    public void readString(long reps) {
-        for (long i = 0; i < reps; i++) {
-            String value = readObject.getColumnString();
-        }
-    }
-
-    @Benchmark
-    public void readLong(long reps) {
-        for (long i = 0; i < reps; i++) {
-            long value = readObject.getColumnLong();
-        }
-    }
-
-    @Benchmark
-    public void readDouble(long reps) {
-        for (long i = 0; i < reps; i++) {
-            double value = readObject.getColumnDouble();
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.kt
new file mode 100644
index 0000000000..42642f4d91
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+
+import org.junit.runner.RunWith
+
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmObjectReadBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private lateinit var realm: Realm
+    private lateinit var readObject: AllTypes
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.executeTransaction { realm ->
+            readObject = realm.createObject(AllTypes::class.java)
+            readObject.columnString = "Foo"
+            readObject.columnLong = 42
+            readObject.columnDouble = 1.234
+        }
+    }
+
+    @After
+    fun after() {
+        realm.close()
+    }
+
+    @Test
+    fun readString() {
+        benchmarkRule.measureRepeated {
+            val value = readObject.columnString
+        }
+    }
+
+    @Test
+    fun readLong() {
+        benchmarkRule.measureRepeated {
+            val value = readObject.columnLong
+        }
+    }
+
+    @Test
+    fun readDouble() {
+        benchmarkRule.measureRepeated {
+            val value = readObject.columnDouble
+        }
+    }
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
deleted file mode 100644
index 3cf64b0d3b..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmObjectWriteBenchmarks {
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private AllTypes writeObject;
-
-    @BeforeExperiment
-    public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-        writeObject = realm.createObject(AllTypes.class);
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.cancelTransaction();
-        realm.close();
-    }
-
-    @Benchmark
-    public void writeShortString(long reps) {
-        for (long i = 0; i < reps; i++) {
-            writeObject.setColumnString("Foo");
-        }
-    }
-
-    @Benchmark
-    public void writeMediumString(long reps) {
-        for (long i = 0; i < reps; i++) {
-            writeObject.setColumnString("ABCDEFHIJKLMNOPQ");
-        }
-    }
-
-    @Benchmark
-    public void writeLongString(long reps) {
-        for (long i = 0; i < reps; i++) {
-            writeObject.setColumnString("ABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQ");
-        }
-    }
-
-    @Benchmark
-    public void writeLong(long reps) {
-        for (long i = 0; i < reps; i++) {
-            writeObject.setColumnLong(42);
-        }
-    }
-
-    @Benchmark
-    public void writeDouble(long reps) {
-        for (long i = 0; i < reps; i++) {
-            writeObject.setColumnDouble(1.234D);
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.kt
new file mode 100644
index 0000000000..d09efc10bf
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmObjectWriteBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private lateinit var realm: Realm
+    private lateinit var writeObject: AllTypes
+
+    @Before
+    fun before() {
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+        writeObject = realm.createObject(AllTypes::class.java)
+    }
+
+    @After
+    fun after() {
+        realm.cancelTransaction()
+        realm.close()
+    }
+
+    @Test
+    fun writeShortString() {
+        benchmarkRule.measureRepeated {
+            writeObject.columnString = "Foo"
+        }
+    }
+
+    @Test
+    fun writeMediumString() {
+        benchmarkRule.measureRepeated {
+            writeObject.columnString = "ABCDEFHIJKLMNOPQ"
+        }
+    }
+
+    @Test
+    fun writeLongString() {
+        benchmarkRule.measureRepeated {
+            writeObject.columnString = "ABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQABCDEFHIJKLMNOPQ"
+        }
+    }
+
+    @Test
+    fun writeLong() {
+        benchmarkRule.measureRepeated {
+            writeObject.columnLong = 42
+        }
+    }
+
+    @Test
+    fun writeDouble() {
+        benchmarkRule.measureRepeated {
+            writeObject.columnDouble = 1.234
+        }
+    }
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
deleted file mode 100644
index ef9b9160e0..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmResults;
-import io.realm.Sort;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmQueryBenchmarks {
-
-    private static final int DATA_SIZE = 1000;
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-
-    @BeforeExperiment
-    public void before() {
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-        for (int i = 0; i < DATA_SIZE; i++) {
-            AllTypes obj = realm.createObject(AllTypes.class);
-            obj.setColumnLong(i);
-            obj.setColumnBoolean(i % 2 == 0);
-            obj.setColumnString("Foo " + i);
-            obj.setColumnDouble(i + 1.234D);
-        }
-        realm.commitTransaction();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.close();
-    }
-
-    @Benchmark
-    public void containsQuery(long reps) {
-        for (long i = 0; i < reps; i++) {
-            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, "Foo 1").findAll();
-        }
-    }
-
-    @Benchmark
-    public void count(long reps) {
-        for (long i = 0; i < reps; i++) {
-            long size = realm.where(AllTypes.class).count();
-        }
-    }
-
-    @Benchmark
-    public void findAll(long reps) {
-        for (long i = 0; i < reps; i++) {
-            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        }
-    }
-
-    @Benchmark
-    public void findAllSortedOneField(long reps) {
-        for (long i = 0; i < reps; i++) {
-            RealmResults<AllTypes> results = realm.where(AllTypes.class).sort(AllTypes.FIELD_STRING, Sort.ASCENDING).findAll();
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.kt
new file mode 100644
index 0000000000..cc5da680d4
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.Sort
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmQueryBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private val DATA_SIZE = 1000
+    private lateinit var realm: Realm
+
+    @Before
+    fun before() {
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+        for (i in 0 until DATA_SIZE) {
+            val obj = realm.createObject(AllTypes::class.java)
+            obj.columnLong = i.toLong()
+            obj.isColumnBoolean = i % 2 == 0
+            obj.columnString = "Foo $i"
+            obj.columnDouble = i + 1.234
+        }
+        realm.commitTransaction()
+    }
+
+    @After
+    fun after() {
+        realm.close()
+    }
+
+    @Test
+    fun containsQuery() {
+        benchmarkRule.measureRepeated {
+            val realmResults = realm.where(AllTypes::class.java).contains(AllTypes.FIELD_STRING, "Foo 1").findAll()
+        }
+    }
+
+    @Test
+    fun count() {
+        benchmarkRule.measureRepeated {
+            val size = realm.where(AllTypes::class.java).count()
+        }
+    }
+
+    @Test
+    fun findAll() {
+        benchmarkRule.measureRepeated {
+            val results = realm.where(AllTypes::class.java).findAll()
+        }
+    }
+
+    @Test
+    fun findAllSortedOneField() {
+        benchmarkRule.measureRepeated {
+            val results = realm.where(AllTypes::class.java).sort(AllTypes.FIELD_STRING, Sort.ASCENDING).findAll()
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java
deleted file mode 100644
index e33aeed563..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.runner.RunWith;
-
-import dk.ilios.spanner.AfterExperiment;
-import dk.ilios.spanner.BeforeExperiment;
-import dk.ilios.spanner.Benchmark;
-import dk.ilios.spanner.BenchmarkConfiguration;
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.junit.SpannerRunner;
-import io.realm.Realm;
-import io.realm.RealmConfiguration;
-import io.realm.RealmResults;
-import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.benchmarks.entities.AllTypes;
-
-
-@RunWith(SpannerRunner.class)
-public class RealmResultsBenchmarks {
-
-    private static final int DATA_SIZE = 1000;
-
-    @BenchmarkConfiguration
-    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
-
-    private Realm realm;
-    private RealmResults<AllTypes> results;
-
-    @BeforeExperiment
-    public void before() {
-        Realm.init(InstrumentationRegistry.getTargetContext());
-        RealmConfiguration config = new RealmConfiguration.Builder().build();
-        Realm.deleteRealm(config);
-        realm = Realm.getInstance(config);
-        realm.beginTransaction();
-        for (int i = 0; i < DATA_SIZE; i++) {
-            AllTypes obj = realm.createObject(AllTypes.class);
-            obj.setColumnLong(i);
-            obj.setColumnBoolean(i % 2 == 0);
-            obj.setColumnString("Foo " + i);
-            obj.setColumnDouble(i + 1.234D);
-        }
-        realm.commitTransaction();
-        results = realm.where(AllTypes.class).findAll();
-    }
-
-    @AfterExperiment
-    public void after() {
-        realm.close();
-    }
-
-    @Benchmark
-    public void get(long reps) {
-        for (long i = 0; i < reps; i++) {
-            AllTypes item = results.get(0);
-        }
-    }
-
-    @Benchmark
-    public void size(long reps) {
-        for (long i = 0; i < reps; i++) {
-            long size = results.size();
-        }
-    }
-
-    @Benchmark
-    public void min(long reps) {
-        for (long i = 0; i < reps; i++) {
-            Number min = results.min(AllTypes.FIELD_LONG);
-        }
-    }
-
-    @Benchmark
-    public void max(long reps) {
-        for (long i = 0; i < reps; i++) {
-            Number max = results.max(AllTypes.FIELD_LONG);
-        }
-    }
-
-    @Benchmark
-    public void average(long reps) {
-        for (long i = 0; i < reps; i++) {
-            Number average = results.average(AllTypes.FIELD_LONG);
-        }
-    }
-
-    @Benchmark
-    public void sum(long reps) {
-        for (long i = 0; i < reps; i++) {
-            Number sum = results.sum(AllTypes.FIELD_LONG);
-        }
-    }
-
-    @Benchmark
-    public void sort(long reps) {
-        for (long i = 0; i < reps; i++) {
-            RealmResults<AllTypes> sorted = results.sort(AllTypes.FIELD_STRING);
-        }
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.kt b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.kt
new file mode 100644
index 0000000000..0b5f293bbb
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.kt
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks
+
+import androidx.benchmark.BenchmarkRule
+import androidx.benchmark.measureRepeated
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import io.realm.Realm
+import io.realm.RealmConfiguration
+import io.realm.RealmResults
+import io.realm.benchmarks.entities.AllTypes
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+
+@RunWith(AndroidJUnit4::class)
+class RealmResultsBenchmarks {
+
+    @get:Rule
+    val benchmarkRule = BenchmarkRule()
+
+    private val DATA_SIZE = 1000
+    private lateinit var realm: Realm
+    private lateinit var results: RealmResults<AllTypes>
+
+    @Before
+    fun before() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().targetContext)
+        val config = RealmConfiguration.Builder().build()
+        Realm.deleteRealm(config)
+        realm = Realm.getInstance(config)
+        realm.beginTransaction()
+        for (i in 0 until DATA_SIZE) {
+            val obj = realm.createObject(AllTypes::class.java)
+            obj.columnLong = i.toLong()
+            obj.isColumnBoolean = i % 2 == 0
+            obj.columnString = "Foo $i"
+            obj.columnDouble = i + 1.234
+        }
+        realm.commitTransaction()
+        results = realm.where(AllTypes::class.java).findAll()
+    }
+
+    @After
+    fun after() {
+        realm.close()
+    }
+
+    @Test
+    fun get() {
+        benchmarkRule.measureRepeated {
+            val item = results[0]
+        }
+    }
+
+    @Test
+    fun size() {
+        benchmarkRule.measureRepeated {
+            val size = results.size.toLong()
+        }
+    }
+
+    @Test
+    fun min() {
+        benchmarkRule.measureRepeated {
+            val min = results.min(AllTypes.FIELD_LONG)
+        }
+    }
+
+    @Test
+    fun max() {
+        benchmarkRule.measureRepeated {
+            val max = results.max(AllTypes.FIELD_LONG)
+        }
+    }
+
+    @Test
+    fun average() {
+        benchmarkRule.measureRepeated {
+            val average = results.average(AllTypes.FIELD_LONG)
+        }
+    }
+
+    @Test
+    fun sum() {
+        benchmarkRule.measureRepeated {
+            val sum = results.sum(AllTypes.FIELD_LONG)
+        }
+    }
+
+    @Test
+    fun sort() {
+        benchmarkRule.measureRepeated {
+            val sorted = results.sort(AllTypes.FIELD_STRING)
+        }
+    }
+
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/BenchmarkConfig.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/BenchmarkConfig.java
deleted file mode 100644
index 5515532e22..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/BenchmarkConfig.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks.config;
-
-import android.os.Environment;
-
-import java.io.File;
-import java.util.concurrent.TimeUnit;
-
-import dk.ilios.spanner.SpannerConfig;
-import dk.ilios.spanner.config.RuntimeInstrumentConfig;
-import dk.ilios.spanner.output.ResultProcessor;
-
-/**
- * Static helper class for creating benchmark configurations
- * */
-public class BenchmarkConfig {
-
-    public static SpannerConfig getConfiguration(String className) {
-        // Document directory is located at: /sdcard/realm-benchmarks
-        // Benchmarks results should be saved in <documentFolder>/results/<className>.json
-        // Baseline data should be found in <documentFolder>/baselines/<className>.json
-        // Custom CSV files should be found in <documentFolder>/csv/<className>.csv
-        File externalDocuments = new File(Environment.getExternalStorageDirectory(), "realm-benchmarks");
-        if (!externalDocuments.exists() && !externalDocuments.mkdir()) {
-            throw new RuntimeException("Could not create benchmark directory: " + externalDocuments);
-        }
-        File resultsDir = new File(externalDocuments, "results");
-        File baselineDir = new File(externalDocuments, "baselines");
-        File baselineFile = new File(baselineDir, className + ".json");
-        File csvDir = new File(externalDocuments, "csv");
-        csvDir.mkdir();
-        File csvFile = new File(csvDir, className + ".csv");
-        ResultProcessor csvResultProcessor = new CSVResultProcessor(csvFile);
-
-        // General configuration for running benchmarks.
-        // Always saves result files. CI will determine if it wants to store them.
-        SpannerConfig.Builder builder = new SpannerConfig.Builder()
-                .saveResults(resultsDir, className + ".json")
-                .trialsPrExperiment(1)
-                .maxBenchmarkThreads(1)
-                .addInstrument(new RuntimeInstrumentConfig.Builder()
-                                .gcBeforeEachMeasurement(true)
-                                .warmupTime(0, TimeUnit.SECONDS)
-                                .timingInterval(500, TimeUnit.MILLISECONDS)
-                                .measurements(9)
-                                .build()
-                )
-                .addResultProcessor(csvResultProcessor);
-
-        // Only uses baseline file if it exists.
-        if (baselineFile.exists()) {
-            builder.useBaseline(baselineFile);
-            // Tests that 25. , 50. and 75. percentile doesn't change by more than 15%.
-            builder.percentileFailureLimit(25f, 0.15f);
-            builder.percentileFailureLimit(50f, 0.15f);
-            builder.percentileFailureLimit(75f, 0.15f);
-        }
-
-        return builder.build();
-    }
-}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java
deleted file mode 100644
index d241934afa..0000000000
--- a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.benchmarks.config;
-
-import com.google.common.io.Files;
-import com.opencsv.CSVWriter;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.text.DecimalFormat;
-
-import dk.ilios.spanner.model.Trial;
-import dk.ilios.spanner.output.ResultProcessor;
-
-/**
- * Converts the result of a benchmark to CSV for easier processing by other data/graph programs.
- *
- * Output is the following.
- * methodname, trialNumber, params, measurements, min, max, average, 25pct, 50pct, 75pct.
- */
-public class CSVResultProcessor implements ResultProcessor {
-
-    private  static final boolean APPLY_QUOTES = true;
-    private static final DecimalFormat decimalFormater = new DecimalFormat("#.00");
-
-    private final File resultFile;
-    private final File workFile;
-    private final CSVWriter writer;
-
-    public CSVResultProcessor(File resultFile) {
-        this.resultFile = resultFile;
-        this.workFile = new File(resultFile.getPath() + ".tmp");
-        try {
-            writer = new CSVWriter(Files.newWriter(resultFile, Charset.forName("UTF-8")));
-            addLabels();
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private void addLabels() {
-        String[] labels = new String[] {
-                "Method name",
-                "Trial",
-                "Measurements",
-                "Min.",
-                "Max.",
-                "Mean",
-                "25pct.",
-                "50pct.",
-                "75pct.",
-        };
-
-        writer.writeNext(labels, APPLY_QUOTES);
-    }
-
-    @Override
-    public void processTrial(Trial trial) {
-        String methodName = trial.experiment().instrumentation().benchmarkMethod().getName();
-        int trialNo = trial.getTrialNumber();
-        int measurements = trial.measurements().size();
-        double min = trial.getMin();
-        double max = trial.getMax();
-        double mean = trial.getMean();
-        double percentile25 = trial.getPercentile(25);
-        double percentile50 = trial.getMedian();
-        double percentile75 = trial.getPercentile(75);
-
-        String[] resultLine = new String[] {
-                methodName,
-                Integer.toString(trialNo),
-                Integer.toString(measurements),
-                decimalFormater.format(min),
-                decimalFormater.format(max),
-                decimalFormater.format(mean),
-                decimalFormater.format(percentile25),
-                decimalFormater.format(percentile50),
-                decimalFormater.format(percentile75)
-        };
-
-        writer.writeNext(resultLine);
-    }
-
-    @Override
-    public void close() throws IOException {
-        writer.close();
-        if (workFile.exists()) {
-            Files.move(workFile, resultFile);
-        }
-    }
-}
diff --git a/library-benchmarks/src/main/AndroidManifest.xml b/library-benchmarks/src/main/AndroidManifest.xml
index f05a423d71..3c99ebf72b 100644
--- a/library-benchmarks/src/main/AndroidManifest.xml
+++ b/library-benchmarks/src/main/AndroidManifest.xml
@@ -1,13 +1,12 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="io.realm.benchmarks">
-
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
-    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    xmlns:tools="http://schemas.android.com/tools"
+    package="io.realm.benchmarks">
 
     <application
-        android:allowBackup="true"
-        android:label="@string/app_name"
-        android:supportsRtl="true">
-    </application>
-
+        tools:ignore="HardcodedDebugMode"
+        tools:replace="android:debuggable"
+        android:debuggable="false"
+        android:label="@string/app_name" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 </manifest>
diff --git a/realm/build.gradle b/realm/build.gradle
index 8f591b39bb..31076940cb 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,7 +1,7 @@
 buildscript {
     def projectDependencies = new Properties()
     projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
-    ext.kotlin_version = '1.3.21'
+    ext.kotlin_version = '1.3.31'
     ext.dokka_version = '0.9.17'
     repositories {
         mavenLocal()
@@ -45,3 +45,4 @@ allprojects {
         jcenter()
     }
 }
+
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 50de49ce65..ae79c01a89 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -1,4 +1,4 @@
-apply plugin: 'java'
+apply plugin: 'kotlin'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
@@ -16,6 +16,7 @@ dependencies {
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
     testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-27/android.jar"))
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
 }
 
 // for Ant filter
@@ -37,7 +38,7 @@ sourceSets {
     }
 }
 
-compileJava.dependsOn generateVersionClass
+compileKotlin.dependsOn generateVersionClass
 compileTestJava.dependsOn ':realm-library:assembleBaseRelease'
 
 task ojoUpload() {
@@ -136,3 +137,16 @@ artifactory {
         }
     }
 }
+
+compileKotlin {
+    kotlinOptions {
+        jvmTarget = "1.8"
+        freeCompilerArgs += ["-XXLanguage:+InlineClasses"]
+    }
+}
+
+compileTestKotlin {
+    kotlinOptions {
+        jvmTarget = "1.8"
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
deleted file mode 100644
index e158871457..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.Locale;
-
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-
-import io.realm.annotations.LinkingObjects;
-import io.realm.annotations.Required;
-
-
-/**
- * A <b>Backlink</b> is an implicit backwards reference.  If field <code>sourceField</code> in instance <code>I</code>
- * of type <code>SourceClass</code> holds a reference to instance <code>J</code> of type <code>TargetClass</code>,
- * then a "backlink" is the automatically created reference from <code>J</code> to <code>I</code>.
- * Backlinks are automatically created and destroyed when the forward references to which they correspond are
- * created and destroyed.  This can dramatically reduce the complexity of client code.
- * <p>
- * To expose backlinks for use, create a declaration as follows:
- * <code>
- * class TargetClass {
- * // ...
- * {@literal @}LinkingObjects("sourceField")
- * final RealmResults&lt;SourceClass&gt; targetField = null;
- * }
- * </code>.
- * <p>
- * The targetField, the field annotated with the {@literal @}LinkingObjects annotation must be final.
- * Its type must be <code>RealmResults</code> whose generic argument is the <code>SourceClass</code>,
- * the class with the <code>sourceField</code> that will hold the forward reference to an instance of
- * <code>TargetClass</code>
- * <p>
- * The <code>sourceField</code> must be either of type <code>TargetClass</code>
- * or <code>RealmList&lt;TargetClass&gt;</code>
- * <p>
- * In the code link direction is from the perspective of the link, not the backlink: the source is the
- * instance to which the backlink points, the target is the instance holding the pointer.
- * This is consistent with the use of terms in the Realm Core.
- * <p>
- * As should be obvious, from the declaration, backlinks are useful only on managed objects.
- * An unmanaged Model object will have, as the value of its backlink field, the value with which
- * the field is initialized (typically null).
- */
-final class Backlink {
-    private final VariableElement backlinkField;
-
-    /**
-     * The fully-qualified name of the class containing the <code>targetField</code>,
-     * which is the field annotated with the {@literal @}LinkingObjects annotation.
-     */
-    private final String targetClass;
-
-    /**
-     * The name of the backlink field, in <code>targetClass</code>.
-     * A <code>RealmResults&lt;&gt;</code> field annotated with a {@literal @}LinkingObjects annotation.
-     */
-    private final String targetField;
-
-    /**
-     * The fully-qualified name of the class to which the backlinks, from <code>targetField</code>,
-     * point.
-     */
-    private final String sourceClass;
-
-    /**
-     * The name of the field, in <code>SourceClass</code> that has a normal link to <code>targetClass</code>.
-     * Making this field, in an instance I of <code>SourceClass</code>,
-     * a reference to an instance J of <code>TargetClass</code>
-     * will cause the <code>targetField</code> of J to contain a backlink to I.
-     */
-    private final String sourceField;
-
-
-    public Backlink(ClassMetaData clazz, VariableElement backlinkField) {
-        if ((null == clazz) || (null == backlinkField)) {
-            throw new NullPointerException(String.format(Locale.US, "null parameter: %s, %s", clazz, backlinkField));
-        }
-
-        this.backlinkField = backlinkField;
-        this.targetClass = clazz.getFullyQualifiedClassName();
-        this.targetField = backlinkField.getSimpleName().toString();
-        this.sourceClass = Utils.getRealmResultsType(backlinkField);
-        this.sourceField = backlinkField.getAnnotation(LinkingObjects.class).value();
-    }
-
-    public String getTargetClass() {
-        return targetClass;
-    }
-
-    public String getTargetField() {
-        return targetField;
-    }
-
-    public String getSourceClass() {
-        return sourceClass;
-    }
-
-    public String getSourceField() {
-        return sourceField;
-    }
-
-    public String getTargetFieldType() {
-        return backlinkField.asType().toString();
-    }
-
-    /**
-     * Validate the source side of the backlink.
-     *
-     * @return true if the backlink source looks good.
-     */
-    public boolean validateSource() {
-        // A @LinkingObjects cannot be @Required
-        if (backlinkField.getAnnotation(Required.class) != null) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "The @LinkingObjects field \"%s.%s\" cannot be @Required.",
-                    targetClass,
-                    targetField));
-            return false;
-        }
-
-        // The annotation must have an argument, identifying the linked field
-        if ((sourceField == null) || sourceField.equals("")) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "The @LinkingObjects annotation for the field \"%s.%s\" must have a parameter identifying the link target.",
-                    targetClass,
-                    targetField));
-            return false;
-        }
-
-        // Using link syntax to try to reference a linked field is not possible.
-        if (sourceField.contains(".")) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "The parameter to the @LinkingObjects annotation for the field \"%s.%s\" contains a '.'.  The use of '.' to specify fields in referenced classes is not supported.",
-                    targetClass,
-                    targetField));
-            return false;
-        }
-
-        // The annotated element must be a RealmResult
-        if (!Utils.isRealmResults(backlinkField)) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "The field \"%s.%s\" is a \"%s\". Fields annotated with @LinkingObjects must be RealmResults.",
-                    targetClass,
-                    targetField,
-                    backlinkField.asType()));
-            return false;
-        }
-
-        if (sourceClass == null) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "\"The field \"%s.%s\", annotated with @LinkingObjects, must specify a generic type.",
-                    targetClass,
-                    targetField));
-            return false;
-        }
-
-        // A @LinkingObjects field must be final
-        if (!backlinkField.getModifiers().contains(Modifier.FINAL)) {
-            Utils.error(String.format(
-                    Locale.US,
-                    "A @LinkingObjects field \"%s.%s\" must be final.",
-                    targetClass,
-                    targetField));
-            return false;
-        }
-
-        return true;
-    }
-
-    public boolean validateTarget(ClassMetaData clazz) {
-        VariableElement field = clazz.getDeclaredField(sourceField);
-
-        if (field == null) {
-            Utils.error(String.format(Locale.US,
-                    "Field \"%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", does not exist in class \"%s\".",
-                    sourceField,
-                    targetClass,
-                    targetField,
-                    sourceClass));
-            return false;
-        }
-
-        String fieldType = field.asType().toString();
-        if (!(targetClass.equals(fieldType) || targetClass.equals(Utils.getRealmListType(field)))) {
-            Utils.error(String.format(Locale.US,
-                    "Field \"%s.%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", has type \"%s\" instead of \"%3$s\".",
-                    sourceClass,
-                    sourceField,
-                    targetClass,
-                    targetField,
-                    fieldType));
-            return false;
-        }
-
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        return "Backlink{" + sourceClass + "." + sourceField + " ==> " + targetClass + "." + targetField + "}";
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (null == o) { return false; }
-        if (this == o) { return true; }
-
-        if (!(o instanceof Backlink)) { return false; }
-        Backlink backlink = (Backlink) o;
-
-        return targetClass.equals(backlink.targetClass)
-                && targetField.equals(backlink.targetField)
-                && sourceClass.equals(backlink.sourceClass)
-                && sourceField.equals(backlink.sourceField);
-    }
-
-    @Override
-    public int hashCode() {
-        int result = targetClass.hashCode();
-        result = 31 * result + targetField.hashCode();
-        result = 31 * result + sourceClass.hashCode();
-        result = 31 * result + sourceField.hashCode();
-        return result;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt
new file mode 100644
index 0000000000..862db60de5
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.kt
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import java.util.Locale
+
+import javax.lang.model.element.Modifier
+import javax.lang.model.element.VariableElement
+
+import io.realm.annotations.LinkingObjects
+import io.realm.annotations.Required
+
+/**
+ * A **Backlink** is an implicit backwards reference.  If field `sourceField` in instance `I`
+ * of type `SourceClass` holds a reference to instance `J` of type `TargetClass`,
+ * then a "backlink" is the automatically created reference from `J` to `I`.
+ *
+ * Backlinks are automatically created and destroyed when the forward references to which they
+ * correspond are created and destroyed.  This can dramatically reduce the complexity of client
+ * code.
+ *
+ * To expose backlinks for use, create a declaration as follows:
+ *
+ * ```
+ * class TargetClass {
+ *   // ...
+ *   @LinkingObjects("sourceField")
+ *   final RealmResults<SourceClass> targetField = null;
+ * }
+ *```
+ *
+ * The `targetField`, the field annotated with the @LinkingObjects annotation must be final.
+ * Its type must be `RealmResults` whose generic argument is the `SourceClass`, the class with the
+ * `sourceField` that will hold the forward reference to an instance of `TargetClass`
+ *
+ * The `sourceField` must be either of type `TargetClass`  or `RealmList<TargetClass>`
+ *
+ * In the code link direction is from the perspective of the link, not the backlink: the source is
+ * the instance to which the backlink points, the target is the instance holding the pointer.
+ * This is consistent with the use of terms in the Realm Core.
+ *
+ * As should be obvious, from the declaration, backlinks are useful only on managed objects.
+ * An unmanaged Model object will have, as the value of its backlink field, the value with which
+ * the field is initialized (typically null).
+ */
+class Backlink(clazz: ClassMetaData, private val backlinkField: VariableElement) {
+
+    /**
+     * The fully-qualified name of the class containing the `targetField`, which is the field
+     * annotated with the @LinkingObjects annotation.
+     */
+    val targetClass: QualifiedClassName = clazz.qualifiedClassName
+
+    /**
+     * The name of the backlink field, in `targetClass`.
+     * A `RealmResults<>` field annotated with a @LinkingObjects annotation.
+     */
+    val targetField: String = backlinkField.simpleName.toString()
+
+    /**
+     * The fully-qualified name of the class to which the backlinks, from `targetField`, point.
+     */
+    val sourceClass: QualifiedClassName? = Utils.getRealmResultsType(backlinkField)
+
+    /**
+     * The name of the field, in `SourceClass` that has a normal link to `targetClass`.
+     * Making this field, in an instance I of `SourceClass`, a reference to an instance J of
+     * `TargetClass` will cause the `targetField` of J to contain a backlink to I.
+     */
+    val sourceField: String? = backlinkField.getAnnotation(LinkingObjects::class.java)?.value
+
+    val targetFieldType: String
+        get() = backlinkField.asType().toString()
+
+    /**
+     * Validate the source side of the backlink.
+     *
+     * @return true if the backlink source looks good.
+     */
+    fun validateSource(): Boolean {
+        // A @LinkingObjects cannot be @Required
+        if (backlinkField.getAnnotation(Required::class.java) != null) {
+            Utils.error(String.format(
+                    Locale.US,
+                    "The @LinkingObjects field \"%s.%s\" cannot be @Required.",
+                    targetClass,
+                    targetField))
+            return false
+        }
+
+        // The annotation must have an argument, identifying the linked field
+        if (sourceField == null || sourceField == "") {
+            Utils.error(String.format(
+                    Locale.US,
+                    "The @LinkingObjects annotation for the field \"%s.%s\" must have a parameter identifying the link target.",
+                    targetClass,
+                    targetField))
+            return false
+        }
+
+        // Using link syntax to try to reference a linked field is not possible.
+        if (sourceField.contains(".")) {
+            Utils.error(String.format(
+                    Locale.US,
+                    "The parameter to the @LinkingObjects annotation for the field \"%s.%s\" contains a '.'.  The use of '.' to specify fields in referenced classes is not supported.",
+                    targetClass,
+                    targetField))
+            return false
+        }
+
+        // The annotated element must be a RealmResult
+        if (!Utils.isRealmResults(backlinkField)) {
+            Utils.error(String.format(
+                    Locale.US,
+                    "The field \"%s.%s\" is a \"%s\". Fields annotated with @LinkingObjects must be RealmResults.",
+                    targetClass,
+                    targetField,
+                    backlinkField.asType()))
+            return false
+        }
+
+        if (sourceClass == null) {
+            Utils.error(String.format(
+                    Locale.US,
+                    "\"The field \"%s.%s\", annotated with @LinkingObjects, must specify a generic type.",
+                    targetClass,
+                    targetField))
+            return false
+        }
+
+        // A @LinkingObjects field must be final
+        if (!backlinkField.modifiers.contains(Modifier.FINAL)) {
+            Utils.error(String.format(
+                    Locale.US,
+                    "A @LinkingObjects field \"%s.%s\" must be final.",
+                    targetClass,
+                    targetField))
+            return false
+        }
+
+        return true
+    }
+
+    fun validateTarget(clazz: ClassMetaData): Boolean {
+        val field = clazz.getDeclaredField(sourceField)
+
+        if (field == null) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", does not exist in class \"%s\".",
+                    sourceField,
+                    targetClass,
+                    targetField,
+                    sourceClass))
+            return false
+        }
+
+        val fieldType = QualifiedClassName(field.asType().toString())
+        if (!(targetClass == fieldType || targetClass == Utils.getRealmListType(field))) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s.%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", has type \"%s\" instead of \"%3\$s\".",
+                    sourceClass,
+                    sourceField,
+                    targetClass,
+                    targetField,
+                    fieldType))
+            return false
+        }
+
+        return true
+    }
+
+    override fun toString(): String {
+        return "Backlink{$sourceClass.$sourceField ==> $targetClass.$targetField}"
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (javaClass != other?.javaClass) return false
+
+        other as Backlink
+
+        if (backlinkField != other.backlinkField) return false
+        if (targetClass != other.targetClass) return false
+        if (targetField != other.targetField) return false
+        if (sourceClass != other.sourceClass) return false
+        if (sourceField != other.sourceField) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        var result = backlinkField.hashCode()
+        result = 31 * result + targetClass.hashCode()
+        result = 31 * result + targetField.hashCode()
+        result = 31 * result + (sourceClass?.hashCode() ?: 0)
+        result = 31 * result + sourceField.hashCode()
+        return result
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java
deleted file mode 100644
index 095314f1b9..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Wrapper around all Realm model classes metadata found during processing. It also
- * allows easy lookup for specific class data.
- */
-public class ClassCollection {
-
-    // These three collections should always stay in sync
-    private Map<String, ClassMetaData> qualifiedNameClassMap = new LinkedHashMap<>();
-    private Set<ClassMetaData> classSet = new LinkedHashSet<>();
-
-    public void addClass(ClassMetaData metadata) {
-        classSet.add(metadata);
-        qualifiedNameClassMap.put(metadata.getFullyQualifiedClassName(), metadata);
-    }
-
-    public Set<ClassMetaData> getClasses() {
-        return Collections.unmodifiableSet(classSet);
-    }
-
-    public ClassMetaData getClassFromQualifiedName(String qualifiedJavaClassName) {
-        ClassMetaData data = qualifiedNameClassMap.get(qualifiedJavaClassName);
-        if (data == null) {
-            throw new IllegalArgumentException("Class " + qualifiedJavaClassName + " was not found");
-        }
-        return data;
-    }
-
-    public int size() {
-        return classSet.size();
-    }
-
-    public boolean containsQualifiedClass(String qualifiedClassName) {
-        return qualifiedNameClassMap.containsKey(qualifiedClassName);
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.kt
new file mode 100644
index 0000000000..14faeab559
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassCollection.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor
+
+import java.util.LinkedHashMap
+import java.util.LinkedHashSet
+
+/**
+ * Wrapper around all Realm model classes metadata found during processing. It also allows easy
+ * lookup for specific class data.
+ */
+class ClassCollection {
+
+    // These three collections should always stay in sync
+    private val qualifiedNameClassMap = LinkedHashMap<QualifiedClassName, ClassMetaData>()
+    private val classSet = LinkedHashSet<ClassMetaData>()
+    val classes: Set<ClassMetaData>
+        get() = classSet.toSet()
+
+    fun addClass(metadata: ClassMetaData) {
+        classSet.add(metadata)
+        qualifiedNameClassMap[metadata.qualifiedClassName] = metadata
+    }
+
+    fun getClassFromQualifiedName(className: QualifiedClassName): ClassMetaData {
+        return qualifiedNameClassMap[className]
+                ?: throw IllegalArgumentException("Class $className was not found")
+    }
+
+    fun size(): Int {
+        return classSet.size
+    }
+
+    fun containsQualifiedClass(qualifiedClassName: QualifiedClassName?): Boolean {
+        return qualifiedNameClassMap.containsKey(qualifiedClassName)
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
deleted file mode 100644
index 5f8d53ab60..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ /dev/null
@@ -1,797 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-import io.realm.annotations.Ignore;
-import io.realm.annotations.Index;
-import io.realm.annotations.LinkingObjects;
-import io.realm.annotations.PrimaryKey;
-import io.realm.annotations.RealmClass;
-import io.realm.annotations.RealmField;
-import io.realm.annotations.RealmNamingPolicy;
-import io.realm.annotations.Required;
-import io.realm.processor.nameconverter.NameConverter;
-
-
-/**
- * Utility class for holding metadata for RealmProxy classes.
- */
-public class ClassMetaData {
-    private static final String OPTION_IGNORE_KOTLIN_NULLABILITY = "realm.ignoreKotlinNullability";
-    private static final int MAX_CLASSNAME_LENGTH = 57;
-
-    private final TypeElement classType; // Reference to model class.
-    private final String javaClassName; // Model class simple name as defined in Java.
-    private final List<RealmFieldElement> fields = new ArrayList<>(); // List of all fields in the class except those @Ignored.
-    private final List<RealmFieldElement> indexedFields = new ArrayList<>(); // list of all fields marked @Index.
-    private final List<RealmFieldElement> objectReferenceFields = new ArrayList<>(); // List of all fields that reference a Realm Object either directly or in a List
-    private final List<RealmFieldElement> basicTypeFields = new ArrayList<>(); // List of all fields that reference basic types, i.e. no references to other Realm Objects
-    private final Set<Backlink> backlinks = new LinkedHashSet<>();
-    private final Set<RealmFieldElement> nullableFields = new LinkedHashSet<>(); // Set of fields which can be nullable
-    private final Set<RealmFieldElement> nullableValueListFields = new LinkedHashSet<>(); // Set of fields whose elements can be nullable
-
-    private String packageName; // package name for model class.
-    private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
-    private VariableElement primaryKey; // Reference to field used as primary key, if any.
-    private boolean containsToString;
-    private boolean containsEquals;
-    private boolean containsHashCode;
-    private String internalClassName;
-
-    private final List<TypeMirror> validPrimaryKeyTypes;
-    private final List<TypeMirror> validListValueTypes;
-    private final Types typeUtils;
-    private final Elements elements;
-    private NameConverter defaultFieldNameFormatter;
-
-    private final boolean ignoreKotlinNullability;
-
-    public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeElement clazz) {
-        this.classType = clazz;
-        this.javaClassName = clazz.getSimpleName().toString();
-        typeUtils = env.getTypeUtils();
-        elements = env.getElementUtils();
-
-
-        validPrimaryKeyTypes = Arrays.asList(
-                typeMirrors.STRING_MIRROR,
-                typeMirrors.PRIMITIVE_LONG_MIRROR,
-                typeMirrors.PRIMITIVE_INT_MIRROR,
-                typeMirrors.PRIMITIVE_SHORT_MIRROR,
-                typeMirrors.PRIMITIVE_BYTE_MIRROR
-        );
-
-        validListValueTypes = Arrays.asList(
-                typeMirrors.STRING_MIRROR,
-                typeMirrors.BINARY_MIRROR,
-                typeMirrors.BOOLEAN_MIRROR,
-                typeMirrors.LONG_MIRROR,
-                typeMirrors.INTEGER_MIRROR,
-                typeMirrors.SHORT_MIRROR,
-                typeMirrors.BYTE_MIRROR,
-                typeMirrors.DOUBLE_MIRROR,
-                typeMirrors.FLOAT_MIRROR,
-                typeMirrors.DATE_MIRROR
-        );
-
-        for (Element element : classType.getEnclosedElements()) {
-            if (element instanceof ExecutableElement) {
-                Name name = element.getSimpleName();
-                if (name.contentEquals("toString")) {
-                    this.containsToString = true;
-                } else if (name.contentEquals("equals")) {
-                    this.containsEquals = true;
-                } else if (name.contentEquals("hashCode")) {
-                    this.containsHashCode = true;
-                }
-            }
-        }
-
-        ignoreKotlinNullability = Boolean.valueOf(
-                env.getOptions().getOrDefault(OPTION_IGNORE_KOTLIN_NULLABILITY, "false"));
-    }
-
-    @Override
-    public String toString() {
-        return "class " + getFullyQualifiedClassName();
-    }
-
-    public String getSimpleJavaClassName() {
-        return javaClassName;
-    }
-
-    /**
-     * Returns the name that Realm Core uses when saving data from this Java class.
-     */
-    public String getInternalClassName() {
-        return internalClassName;
-    }
-
-    /**
-     * Returns the internal field name that matches the one in the Java model class.
-     */
-    public String getInternalFieldName(String javaFieldName) {
-        for (RealmFieldElement field : fields) {
-            if (field.getJavaName().equals(javaFieldName)) {
-                return field.getInternalFieldName();
-            }
-        }
-        throw new IllegalArgumentException("Could not find fieldname: " + javaFieldName);
-    }
-
-    public String getPackageName() {
-        return packageName;
-    }
-
-    public String getFullyQualifiedClassName() {
-        return packageName + "." + javaClassName;
-    }
-
-    /**
-     * Returns all persistable fields in this model class
-     */
-    public List<RealmFieldElement> getFields() {
-        return Collections.unmodifiableList(fields);
-    }
-
-    /**
-     * Returns all persistable fields that reference other Realm objects.
-     */
-    public List<RealmFieldElement> getObjectReferenceFields() {
-        return Collections.unmodifiableList(objectReferenceFields);
-    }
-
-    /**
-     * Returns all persistable fields that contain a basic type, this include lists of primitives.
-     */
-    public List<RealmFieldElement> getBasicTypeFields() {
-        return Collections.unmodifiableList(basicTypeFields);
-    }
-
-    public Set<Backlink> getBacklinkFields() {
-        return Collections.unmodifiableSet(backlinks);
-    }
-
-    public String getInternalGetter(String fieldName) {
-        return "realmGet$" + fieldName;
-    }
-
-    public String getInternalSetter(String fieldName) {
-        return "realmSet$" + fieldName;
-    }
-
-    public List<RealmFieldElement> getIndexedFields() {
-        return Collections.unmodifiableList(indexedFields);
-    }
-
-    public boolean hasPrimaryKey() {
-        return primaryKey != null;
-    }
-
-    public VariableElement getPrimaryKey() {
-        return primaryKey;
-    }
-
-    public String getPrimaryKeyGetter() {
-        return getInternalGetter(primaryKey.getSimpleName().toString());
-    }
-
-    public boolean containsToString() {
-        return containsToString;
-    }
-
-    public boolean containsEquals() {
-        return containsEquals;
-    }
-
-    public boolean containsHashCode() {
-        return containsHashCode;
-    }
-
-    /**
-     * Checks if a VariableElement is nullable.
-     *
-     * @return {@code true} if a VariableElement is nullable type, {@code false} otherwise.
-     */
-    public boolean isNullable(VariableElement variableElement) {
-        return nullableFields.contains(variableElement);
-    }
-
-    /**
-     * Checks if the element of {@code RealmList} designated by {@code realmListVariableElement} is nullable.
-     *
-     * @return {@code true} if the element is nullable type, {@code false} otherwise.
-     */
-    public boolean isElementNullable(VariableElement realmListVariableElement) {
-        return nullableValueListFields.contains(realmListVariableElement);
-    }
-
-    /**
-     * Checks if a VariableElement is indexed.
-     *
-     * @param variableElement the element/field
-     * @return {@code true} if a VariableElement is indexed, {@code false} otherwise.
-     */
-    public boolean isIndexed(VariableElement variableElement) {
-        return indexedFields.contains(variableElement);
-    }
-
-    /**
-     * Checks if a VariableElement is a primary key.
-     *
-     * @param variableElement the element/field
-     * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
-     */
-    public boolean isPrimaryKey(VariableElement variableElement) {
-        return primaryKey != null && primaryKey.equals(variableElement);
-    }
-
-    /**
-     * Returns {@code true} if the class is considered to be a valid RealmObject class.
-     * RealmObject and Proxy classes also have the @RealmClass annotation but are not considered valid
-     * RealmObject classes.
-     */
-    public boolean isModelClass() {
-        String type = classType.toString();
-        return !type.equals("io.realm.DynamicRealmObject") && !type.endsWith(".RealmObject") && !type.endsWith("RealmProxy");
-    }
-
-    /**
-     * Find the named field in this classes list of fields.
-     * This method is called only during backlink checking,
-     * so creating a map, even lazily, doesn't seem like a worthwhile optimization.
-     * If it gets used more widely, that decision should be revisited.
-     *
-     * @param fieldName The name of the sought field
-     * @return the named field's VariableElement, or null if not found
-     */
-    public VariableElement getDeclaredField(String fieldName) {
-        if (fieldName == null) { return null; }
-        for (VariableElement field : fields) {
-            if (field.getSimpleName().toString().equals(fieldName)) {
-                return field;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Builds the meta data structures for this class. Any errors or messages will be
-     * posted on the provided Messager.
-     *
-     * @param moduleMetaData pre-processed module meta data.
-     * @return True if meta data was correctly created and processing can continue, false otherwise.
-     */
-    public boolean generate(ModuleMetaData moduleMetaData) {
-        // Get the package of the class
-        Element enclosingElement = classType.getEnclosingElement();
-        if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
-            Utils.error("The RealmClass annotation does not support nested classes.", classType);
-            return false;
-        }
-
-        // Check if the @RealmClass is considered valid with respect to the type hierarchy
-        TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
-        if (!parentElement.toString().equals("java.lang.Object") && !parentElement.toString().equals("io.realm.RealmObject")) {
-            Utils.error("Valid model classes must either extend RealmObject or implement RealmModel.", classType);
-            return false;
-        }
-
-        PackageElement packageElement = (PackageElement) enclosingElement;
-        packageName = packageElement.getQualifiedName().toString();
-
-        // Determine naming rules for this class
-        String qualifiedClassName = packageName + "." + javaClassName;
-        NameConverter moduleClassNameFormatter = moduleMetaData.getClassNameFormatter(qualifiedClassName);
-        defaultFieldNameFormatter = moduleMetaData.getFieldNameFormatter(qualifiedClassName);
-
-        RealmClass realmClassAnnotation = classType.getAnnotation(RealmClass.class);
-        // If name has been specifically set, it should override any module policy.
-        if (!realmClassAnnotation.name().isEmpty()) {
-            internalClassName = realmClassAnnotation.name();
-        } else if (!realmClassAnnotation.value().isEmpty()) {
-            internalClassName = realmClassAnnotation.value();
-        } else {
-            internalClassName = moduleClassNameFormatter.convert(javaClassName);
-        }
-        if (internalClassName.length() > MAX_CLASSNAME_LENGTH) {
-            Utils.error(String.format(Locale.US, "Internal class name is too long. Class '%s' " +
-                    "is converted to '%s', which is longer than the maximum allowed of %d characters",
-                    javaClassName, internalClassName, 57));
-            return false;
-        }
-
-        // If field name policy has been explicitly set, override the module field name policy
-        if (realmClassAnnotation.fieldNamingPolicy() != RealmNamingPolicy.NO_POLICY) {
-            defaultFieldNameFormatter = Utils.getNameFormatter(realmClassAnnotation.fieldNamingPolicy());
-        }
-
-        // Categorize and check the rest of the file
-        if (!categorizeClassElements()) { return false; }
-        if (!checkCollectionTypes()) { return false; }
-        if (!checkReferenceTypes()) { return false; }
-        if (!checkDefaultConstructor()) { return false; }
-        if (!checkForFinalFields()) { return false; }
-        if (!checkForVolatileFields()) { return false; }
-
-        return true; // Meta data was successfully generated
-    }
-
-    // Iterate through all class elements and add them to the appropriate internal data structures.
-    // Returns true if all elements could be categorized and false otherwise.
-    private boolean categorizeClassElements() {
-        for (Element element : classType.getEnclosedElements()) {
-            ElementKind elementKind = element.getKind();
-            switch (elementKind) {
-                case CONSTRUCTOR:
-                    if (Utils.isDefaultConstructor(element)) { hasDefaultConstructor = true; }
-                    break;
-
-                case FIELD:
-                    if (!categorizeField(element)) { return false; }
-                    break;
-
-                default:
-            }
-        }
-
-        if (fields.size() == 0) {
-            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", javaClassName));
-        }
-
-        return true;
-    }
-
-    private boolean checkCollectionTypes() {
-        for (VariableElement field : fields) {
-            if (Utils.isRealmList(field)) {
-                if (!checkRealmListType(field)) {
-                    return false;
-                }
-            } else if (Utils.isRealmResults(field)) {
-                if (!checkRealmResultsType(field)) {
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    private boolean checkRealmListType(VariableElement field) {
-        // Check for missing generic (default back to Object)
-        if (Utils.getGenericTypeQualifiedName(field) == null) {
-            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
-            return false;
-        }
-
-        // Check that the referenced type is a concrete class and not an interface
-        TypeMirror fieldType = field.asType();
-        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
-        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class of interface*/) {
-            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
-            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                Utils.error(
-                        getFieldErrorSuffix(field) + "Only concrete Realm classes are allowed in RealmLists. "
-                                + "Neither interfaces nor abstract classes are allowed.",
-                        field);
-                return false;
-            }
-        }
-
-        // Check if the actual value class is acceptable
-        if (!containsType(validListValueTypes, elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
-            final StringBuilder messageBuilder = new StringBuilder(
-                    getFieldErrorSuffix(field) + "Element type of RealmList must be a class implementing 'RealmModel' or one of ");
-            final String separator = ", ";
-            for (TypeMirror type : validListValueTypes) {
-                messageBuilder.append('\'').append(type.toString()).append('\'').append(separator);
-            }
-            messageBuilder.setLength(messageBuilder.length() - separator.length());
-            messageBuilder.append('.');
-            Utils.error(messageBuilder.toString(), field);
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean checkRealmResultsType(VariableElement field) {
-        // Only classes implementing RealmModel are allowed since RealmResults field is used only for backlinks.
-
-        // Check for missing generic (default back to Object)
-        if (Utils.getGenericTypeQualifiedName(field) == null) {
-            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
-            return false;
-        }
-
-        TypeMirror fieldType = field.asType();
-        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
-        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class or interface*/) {
-            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
-            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                Utils.error(
-                        "Only concrete Realm classes are allowed in RealmResults. "
-                                + "Neither interfaces nor abstract classes are allowed.",
-                        field);
-                return false;
-            }
-        }
-
-        // Check if the actual value class is acceptable
-        if (!Utils.isRealmModel(elementTypeMirror)) {
-            Utils.error(getFieldErrorSuffix(field) + "Element type of RealmResults must be a class implementing 'RealmModel'.", field);
-            return false;
-        }
-
-        return true;
-    }
-
-    private String getFieldErrorSuffix(VariableElement field) {
-        return javaClassName + "." + field.getSimpleName() + ": ";
-    }
-
-    private boolean checkReferenceTypes() {
-        for (VariableElement field : fields) {
-            if (Utils.isRealmModel(field)) {
-                // Check that the referenced type is a concrete class and not an interface
-                TypeElement typeElement = elements.getTypeElement(field.asType().toString());
-                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                    Utils.error(
-                            "Only concrete Realm classes can be referenced from model classes. "
-                                    + "Neither interfaces nor abstract classes are allowed.",
-                            field);
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    // Report if the default constructor is missing
-    private boolean checkDefaultConstructor() {
-        if (!hasDefaultConstructor) {
-            Utils.error(String.format(Locale.US,
-                    "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
-                    javaClassName));
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    private boolean checkForFinalFields() {
-        for (VariableElement field : fields) {
-            if (!field.getModifiers().contains(Modifier.FINAL)) {
-                continue;
-            }
-            if (Utils.isMutableRealmInteger(field)) {
-                continue;
-            }
-
-            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", javaClassName,
-                    field.getSimpleName().toString()));
-
-            return false;
-        }
-        return true;
-    }
-
-    private boolean checkForVolatileFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.VOLATILE)) {
-                Utils.error(String.format(Locale.US,
-                        "Class \"%s\" contains illegal volatile field \"%s\".",
-                        javaClassName,
-                        field.getSimpleName().toString()));
-                return false;
-            }
-        }
-        return true;
-    }
-
-    private boolean categorizeField(Element element) {
-        VariableElement fieldRef = (VariableElement) element;
-
-        // completely ignore any static fields
-        if (fieldRef.getModifiers().contains(Modifier.STATIC)) { return true; }
-
-        // Ignore fields marked with @Ignore or if they are transient
-        if (fieldRef.getAnnotation(Ignore.class) != null || fieldRef.getModifiers().contains(Modifier.TRANSIENT)) {
-            return true;
-        }
-
-        // Determine name for field
-        String internalFieldName = getInternalFieldName(fieldRef, defaultFieldNameFormatter);
-        RealmFieldElement field = new RealmFieldElement(fieldRef, internalFieldName);
-
-        if (field.getAnnotation(Index.class) != null) {
-            if (!categorizeIndexField(element, field)) { return false; }
-        }
-
-        // @Required annotation of RealmList field only affects its value type, not field itself.
-        if (Utils.isRealmList(field)) {
-            boolean hasRequiredAnnotation = hasRequiredAnnotation(field);
-            final List<? extends TypeMirror> listGenericType = ((DeclaredType) field.asType()).getTypeArguments();
-            boolean containsRealmModelClasses = (!listGenericType.isEmpty() && Utils.isRealmModel(listGenericType.get(0)));
-
-            // @Required not allowed if the list contains Realm model classes
-            if (hasRequiredAnnotation && containsRealmModelClasses) {
-                Utils.error("@Required not allowed on RealmList's that contain other Realm model classes.");
-                return false;
-            }
-
-            // @Required thus only makes sense for RealmLists with primitive types
-            // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
-            if (!hasRequiredAnnotation) {
-                if (!containsRealmModelClasses) {
-                    nullableValueListFields.add(field);
-                }
-            }
-        } else if (isRequiredField(field)) {
-            if (!checkBasicRequiredAnnotationUsage(element, field)) {
-                return false;
-            }
-        } else {
-            // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
-            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
-            // nullableFields.
-            // RealmList of models, RealmResults(backlinks) and primitive types are NOT nullable. @Required annotation is not supported.
-            if (!Utils.isPrimitiveType(field) && !Utils.isRealmResults(field)) {
-                nullableFields.add(field);
-            }
-        }
-
-        if (field.getAnnotation(PrimaryKey.class) != null) {
-            if (!categorizePrimaryKeyField(field)) { return false; }
-        }
-
-        // @LinkingObjects cannot be @PrimaryKey or @Index.
-        if (field.getAnnotation(LinkingObjects.class) != null) {
-            // Do not add backlinks to fields list.
-            return categorizeBacklinkField(field);
-        }
-
-        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
-        if (Utils.isMutableRealmInteger(field)) {
-            if (!categorizeMutableRealmIntegerField(field)) { return false; }
-        }
-
-        // Standard field that appears to be valid (more fine grained checks might fail later).
-        fields.add(field);
-        if (Utils.isRealmModel(field) || Utils.isRealmModelList(field)) {
-            objectReferenceFields.add(field);
-        } else {
-            basicTypeFields.add(field);
-        }
-
-        return true;
-    }
-
-    private String getInternalFieldName(VariableElement field, NameConverter defaultConverter) {
-        RealmField nameAnnotation = field.getAnnotation(RealmField.class);
-        if (nameAnnotation != null) {
-            if (!nameAnnotation.name().isEmpty()) {
-                return nameAnnotation.name();
-            }
-            if (!nameAnnotation.value().isEmpty()) {
-                return nameAnnotation.value();
-            }
-            Utils.note(String.format("Empty internal name defined on @RealmField. " +
-                    "Falling back to named used by Java model class: %s", field.getSimpleName()), field);
-            return field.getSimpleName().toString();
-        } else {
-            return defaultConverter.convert(field.getSimpleName().toString());
-        }
-    }
-
-    /**
-     * This method only checks if the field has {@code @Required} annotation.
-     * In most cases, you should use {@link #isRequiredField(VariableElement)} to take into account
-     * Kotlin's annotation as well.
-     *
-     * @param field target field.
-     * @return {@code true} if the field has {@code @Required} annotation, {@code false} otherwise.
-     * @see #isRequiredField(VariableElement)
-     */
-    private boolean hasRequiredAnnotation(VariableElement field) {
-        return field.getAnnotation(Required.class) != null;
-    }
-
-    /**
-     * Checks if the field is annotated as required.
-     * @param field target field.
-     * @return {@code true} if the field is annotated as required, {@code false} otherwise.
-     */
-    private boolean isRequiredField(VariableElement field) {
-        if (hasRequiredAnnotation(field)) {
-            return true;
-        }
-
-        if (ignoreKotlinNullability) {
-            return false;
-        }
-
-        // Kotlin uses the `org.jetbrains.annotations.NotNull` annotation to mark non-null fields.
-        // In order to fully support the Kotlin type system we interpret `@NotNull` as an alias
-        // for `@Required`
-        for (AnnotationMirror annotation : field.getAnnotationMirrors()) {
-            if (annotation.getAnnotationType().toString().equals("org.jetbrains.annotations.NotNull")) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    // The field has the @Index annotation. It's only valid for column types:
-    // STRING, DATE, INTEGER, BOOLEAN, and RealmMutableInteger
-    private boolean categorizeIndexField(Element element, RealmFieldElement fieldElement) {
-        boolean indexable = false;
-
-        if (Utils.isMutableRealmInteger(fieldElement)) {
-            indexable = true;
-        } else {
-            Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldElement.asType().toString());
-            if (realmType != null) {
-                switch (realmType) {
-                    case STRING:
-                    case DATE:
-                    case INTEGER:
-                    case BOOLEAN:
-                        indexable = true;
-                }
-            }
-        }
-
-        if (indexable) {
-            indexedFields.add(fieldElement);
-            return true;
-        }
-
-        Utils.error(String.format(Locale.US, "Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
-        return false;
-    }
-
-    // The field has the @Required annotation
-    // Returns `true` if the field could be correctly validated, `false` if an error was reported.
-    private boolean checkBasicRequiredAnnotationUsage(Element element, VariableElement variableElement) {
-        if (Utils.isPrimitiveType(variableElement)) {
-            Utils.error(String.format(Locale.US,
-                    "@Required or @NotNull annotation is unnecessary for primitive field \"%s\".", element));
-            return false;
-        }
-
-        if (Utils.isRealmModel(variableElement)) {
-            Utils.error(String.format(Locale.US,
-                    "Field \"%s\" with type \"%s\" cannot be @Required or @NotNull.", element, element.asType()));
-            return false;
-        }
-
-        // Should never get here - user should remove @Required
-        if (nullableFields.contains(variableElement)) {
-            Utils.error(String.format(Locale.US,
-                    "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
-                    element,
-                    element.asType()));
-
-            return false;
-        }
-
-        return true;
-    }
-
-    // The field has the @PrimaryKey annotation. It is only valid for
-    // String, short, int, long and must only be present one time
-    private boolean categorizePrimaryKeyField(RealmFieldElement fieldElement) {
-        if (primaryKey != null) {
-            Utils.error(String.format(Locale.US,
-                    "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
-                    primaryKey.getSimpleName().toString(),
-                    fieldElement.getSimpleName().toString()));
-            return false;
-        }
-
-        TypeMirror fieldType = fieldElement.asType();
-        if (!isValidPrimaryKeyType(fieldType)) {
-            Utils.error(String.format(Locale.US,
-                    "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
-                    fieldElement.getSimpleName().toString(),
-                    fieldType));
-            return false;
-        }
-
-        primaryKey = fieldElement;
-
-        // Also add as index. All types of primary key can be indexed.
-        if (!indexedFields.contains(fieldElement)) {
-            indexedFields.add(fieldElement);
-        }
-
-        return true;
-    }
-
-    private boolean categorizeBacklinkField(VariableElement variableElement) {
-        Backlink backlink = new Backlink(this, variableElement);
-        if (!backlink.validateSource()) { return false; }
-
-        backlinks.add(backlink);
-
-        return true;
-    }
-
-    private boolean categorizeMutableRealmIntegerField(VariableElement field) {
-        if (field.getModifiers().contains(Modifier.FINAL)) {
-            return true;
-        }
-
-        Utils.error(String.format(Locale.US,
-                "Field \"%s\", a MutableRealmInteger, must be final.",
-                field.getSimpleName().toString()));
-        return false;
-    }
-
-    private boolean isValidPrimaryKeyType(TypeMirror type) {
-        for (TypeMirror validType : validPrimaryKeyTypes) {
-            if (typeUtils.isAssignable(type, validType)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean containsType(List<TypeMirror> listOfTypes, TypeMirror type) {
-        for (int i = 0; i < listOfTypes.size(); i++) {
-            // Comparing TypeMirror's using `equals()` breaks when using incremental annotation processing.
-            if (typeUtils.isSameType(listOfTypes.get(i), type)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public Element getClassElement() {
-        return classType;
-    }
-
-}
-
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.kt
new file mode 100644
index 0000000000..ff8c33d6a0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.kt
@@ -0,0 +1,775 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Collections
+import java.util.LinkedHashSet
+import java.util.Locale
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.Modifier
+import javax.lang.model.element.PackageElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.DeclaredType
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+import javax.lang.model.util.Elements
+import javax.lang.model.util.Types
+
+import io.realm.annotations.Ignore
+import io.realm.annotations.Index
+import io.realm.annotations.LinkingObjects
+import io.realm.annotations.PrimaryKey
+import io.realm.annotations.RealmClass
+import io.realm.annotations.RealmField
+import io.realm.annotations.RealmNamingPolicy
+import io.realm.annotations.Required
+import io.realm.processor.nameconverter.NameConverter
+
+/**
+ * Utility class for holding metadata for RealmProxy classes.
+ */
+class ClassMetaData(env: ProcessingEnvironment, typeMirrors: TypeMirrors, private val classType: TypeElement /* Reference to model class. */) {
+
+    val simpleJavaClassName = SimpleClassName(classType.simpleName) // Model class simple name as defined in Java.
+    val fields = ArrayList<RealmFieldElement>() // List of all fields in the class except those @Ignored.
+    private val indexedFields = ArrayList<RealmFieldElement>() // list of all fields marked @Index.
+    private val _objectReferenceFields = ArrayList<RealmFieldElement>() // List of all fields that reference a Realm Object either directly or in a List
+    private val basicTypeFields = ArrayList<RealmFieldElement>() // List of all fields that reference basic types, i.e. no references to other Realm Objects
+    private val backlinks = LinkedHashSet<Backlink>()
+    private val nullableFields = LinkedHashSet<RealmFieldElement>() // Set of fields which can be nullable
+    private val nullableValueListFields = LinkedHashSet<RealmFieldElement>() // Set of fields whose elements can be nullable
+
+    // package name for model class.
+    private lateinit var packageName: String
+
+    // True if model has a public no-arg constructor.
+    private var hasDefaultConstructor: Boolean = false
+
+    // Reference to field used as primary key
+    var primaryKey: VariableElement? = null
+        private set
+
+    private var containsToString: Boolean = false
+    private var containsEquals: Boolean = false
+    private var containsHashCode: Boolean = false
+
+    // Returns the name that Realm Core uses when saving data from this Java class.
+    lateinit var internalClassName: String
+        private set
+
+    private val validPrimaryKeyTypes: List<TypeMirror> = Arrays.asList(
+            typeMirrors.STRING_MIRROR,
+            typeMirrors.PRIMITIVE_LONG_MIRROR,
+            typeMirrors.PRIMITIVE_INT_MIRROR,
+            typeMirrors.PRIMITIVE_SHORT_MIRROR,
+            typeMirrors.PRIMITIVE_BYTE_MIRROR
+    )
+    private val validListValueTypes: List<TypeMirror> = Arrays.asList(
+            typeMirrors.STRING_MIRROR,
+            typeMirrors.BINARY_MIRROR,
+            typeMirrors.BOOLEAN_MIRROR,
+            typeMirrors.LONG_MIRROR,
+            typeMirrors.INTEGER_MIRROR,
+            typeMirrors.SHORT_MIRROR,
+            typeMirrors.BYTE_MIRROR,
+            typeMirrors.DOUBLE_MIRROR,
+            typeMirrors.FLOAT_MIRROR,
+            typeMirrors.DATE_MIRROR
+    )
+    private val typeUtils: Types = env.typeUtils
+    private val elements: Elements = env.elementUtils
+    private lateinit var defaultFieldNameFormatter: NameConverter
+
+    private val ignoreKotlinNullability: Boolean
+
+    val qualifiedClassName: QualifiedClassName
+        get() = QualifiedClassName("$packageName.$simpleJavaClassName")
+
+    val backlinkFields: Set<Backlink>
+        get() = backlinks.toSet()
+
+    val primaryKeyGetter: String
+        get() = getInternalGetter(primaryKey!!.simpleName.toString())
+
+    /**
+     * Returns `true if the class is considered to be a valid RealmObject class.
+     * RealmObject and Proxy classes also have the @RealmClass annotation but are not considered valid
+     * RealmObject classes.
+     */
+    val isModelClass: Boolean
+        get() {
+            val type = classType.toString()
+            return type != "io.realm.DynamicRealmObject" && !type.endsWith(".RealmObject") && !type.endsWith("RealmProxy")
+        }
+
+    val classElement: Element
+        get() = classType
+
+    init {
+
+
+        for (element in classType.enclosedElements) {
+            if (element is ExecutableElement) {
+                val name = element.getSimpleName()
+                when {
+                    name.contentEquals("toString") -> this.containsToString = true
+                    name.contentEquals("equals") -> this.containsEquals = true
+                    name.contentEquals("hashCode") -> this.containsHashCode = true
+                }
+            }
+        }
+
+        ignoreKotlinNullability = java.lang.Boolean.valueOf(
+                (env.options as MutableMap<String, String>).getOrDefault(OPTION_IGNORE_KOTLIN_NULLABILITY, "false"))
+    }
+
+    override fun toString(): String {
+        return "class $qualifiedClassName"
+    }
+
+    /**
+     * Returns the internal field name that matches the one in the Java model class.
+     */
+    fun getInternalFieldName(javaFieldName: String): String {
+        for (field in fields) {
+            if (field.javaName == javaFieldName) {
+                return field.internalFieldName
+            }
+        }
+        throw IllegalArgumentException("Could not find fieldname: $javaFieldName")
+    }
+
+    /**
+     * Returns all persistable fields that reference other Realm objects.
+     */
+    val objectReferenceFields: List<RealmFieldElement>
+        get() = _objectReferenceFields.toList()
+
+    /**
+     * Returns all persistable fields that contain a basic type, this include lists of primitives.
+     */
+    fun getBasicTypeFields(): List<RealmFieldElement> {
+        return Collections.unmodifiableList(basicTypeFields)
+    }
+
+    fun getInternalGetter(fieldName: String): String {
+        return "realmGet$$fieldName"
+    }
+
+    fun getInternalSetter(fieldName: String): String {
+        return "realmSet$$fieldName"
+    }
+
+    fun hasPrimaryKey(): Boolean {
+        return primaryKey != null
+    }
+
+    fun containsToString(): Boolean {
+        return containsToString
+    }
+
+    fun containsEquals(): Boolean {
+        return containsEquals
+    }
+
+    fun containsHashCode(): Boolean {
+        return containsHashCode
+    }
+
+    /**
+     * Checks if a VariableElement is nullable.
+     *
+     * @return `true` if a VariableElement is nullable type, `false` otherwise.
+     */
+    fun isNullable(variableElement: VariableElement): Boolean {
+        return nullableFields.contains(variableElement)
+    }
+
+    /**
+     * Checks if the element of `RealmList` designated by `realmListVariableElement` is nullable.
+     *
+     * @return `true` if the element is nullable type, `false` otherwise.
+     */
+    fun isElementNullable(realmListVariableElement: VariableElement): Boolean {
+        return nullableValueListFields.contains(realmListVariableElement)
+    }
+
+    /**
+     * Checks if a VariableElement is indexed.
+     *
+     * @param variableElement the element/field
+     * @return `true` if a VariableElement is indexed, `false` otherwise.
+     */
+    fun isIndexed(variableElement: VariableElement): Boolean {
+        return indexedFields.contains(variableElement)
+    }
+
+    /**
+     * Checks if a VariableElement is a primary key.
+     *
+     * @param variableElement the element/field
+     * @return `true` if a VariableElement is primary key, `false` otherwise.
+     */
+    fun isPrimaryKey(variableElement: VariableElement): Boolean {
+        return primaryKey != null && primaryKey == variableElement
+    }
+
+    /**
+     * Find the named field in this classes list of fields.
+     * This method is called only during backlink checking,
+     * so creating a map, even lazily, doesn't seem like a worthwhile optimization.
+     * If it gets used more widely, that decision should be revisited.
+     *
+     * @param fieldName The name of the sought field
+     * @return the named field's VariableElement, or null if not found
+     */
+    fun getDeclaredField(fieldName: String?): VariableElement? {
+        if (fieldName == null) {
+            return null
+        }
+        for (field in fields) {
+            if (field.simpleName.toString() == fieldName) {
+                return field
+            }
+        }
+        return null
+    }
+
+    /**
+     * Builds the meta data structures for this class. Any errors or messages will be
+     * posted on the provided Messager.
+     *
+     * @param moduleMetaData pre-processed module meta data.
+     * @return True if meta data was correctly created and processing can continue, false otherwise.
+     */
+    fun generate(moduleMetaData: ModuleMetaData): Boolean {
+        // Get the package of the class
+        val enclosingElement = classType.enclosingElement
+        if (enclosingElement.kind != ElementKind.PACKAGE) {
+            Utils.error("The RealmClass annotation does not support nested classes.", classType)
+            return false
+        }
+
+        // Check if the @RealmClass is considered valid with respect to the type hierarchy
+        val parentElement = Utils.getSuperClass(classType) as TypeElement
+        if (parentElement.toString() != "java.lang.Object" && parentElement.toString() != "io.realm.RealmObject") {
+            Utils.error("Valid model classes must either extend RealmObject or implement RealmModel.", classType)
+            return false
+        }
+
+        val packageElement = enclosingElement as PackageElement
+        packageName = packageElement.qualifiedName.toString()
+
+        // Determine naming rules for this class
+        val qualifiedClassName = QualifiedClassName("$packageName.$simpleJavaClassName")
+        val moduleClassNameFormatter = moduleMetaData.getClassNameFormatter(qualifiedClassName)
+        defaultFieldNameFormatter = moduleMetaData.getFieldNameFormatter(qualifiedClassName)
+
+        val realmClassAnnotation = classType.getAnnotation(RealmClass::class.java)
+        // If name has been specifically set, it should override any module policy.
+        internalClassName = when {
+            realmClassAnnotation.name.isNotEmpty() -> realmClassAnnotation.name
+            realmClassAnnotation.value.isNotEmpty() -> realmClassAnnotation.value
+            else -> moduleClassNameFormatter.convert(simpleJavaClassName.toString())
+        }
+        if (internalClassName.length > MAX_CLASSNAME_LENGTH) {
+            Utils.error(String.format(Locale.US, "Internal class name is too long. Class '%s' " + "is converted to '%s', which is longer than the maximum allowed of %d characters",
+                    simpleJavaClassName, internalClassName, MAX_CLASSNAME_LENGTH))
+            return false
+        }
+
+        // If field name policy has been explicitly set, override the module field name policy
+        if (realmClassAnnotation.fieldNamingPolicy != RealmNamingPolicy.NO_POLICY) {
+            defaultFieldNameFormatter = Utils.getNameFormatter(realmClassAnnotation.fieldNamingPolicy)
+        }
+
+        // Categorize and check the rest of the file
+        if (!categorizeClassElements()) {
+            return false
+        }
+        if (!checkCollectionTypes()) {
+            return false
+        }
+        if (!checkReferenceTypes()) {
+            return false
+        }
+        if (!checkDefaultConstructor()) {
+            return false
+        }
+        if (!checkForFinalFields()) {
+            return false
+        }
+        if (!checkForVolatileFields()) {
+            return false
+        }
+
+        // Meta data was successfully generated
+        return true
+    }
+
+    // Iterate through all class elements and add them to the appropriate internal data structures.
+    // Returns true if all elements could be categorized and false otherwise.
+    private fun categorizeClassElements(): Boolean {
+        for (element in classType.enclosedElements) {
+            when (element.kind) {
+                ElementKind.CONSTRUCTOR -> if (Utils.isDefaultConstructor(element)) {
+                    hasDefaultConstructor = true
+                }
+
+                ElementKind.FIELD -> if (!categorizeField(element)) {
+                    return false
+                }
+                else -> {
+                    /* Ignore */
+                }
+            }
+        }
+
+        if (fields.isEmpty()) {
+            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", simpleJavaClassName))
+        }
+
+        return true
+    }
+
+    private fun checkCollectionTypes(): Boolean {
+        for (field in fields) {
+            if (Utils.isRealmList(field)) {
+                if (!checkRealmListType(field)) {
+                    return false
+                }
+            } else if (Utils.isRealmResults(field)) {
+                if (!checkRealmResultsType(field)) {
+                    return false
+                }
+            }
+        }
+
+        return true
+    }
+
+    private fun checkRealmListType(field: VariableElement): Boolean {
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field)
+            return false
+        }
+
+        // Check that the referenced type is a concrete class and not an interface
+        val fieldType = field.asType()
+        val elementTypeMirror = (fieldType as DeclaredType).typeArguments[0]
+        if (elementTypeMirror.kind == TypeKind.DECLARED /* class of interface*/) {
+            val elementTypeElement = (elementTypeMirror as DeclaredType).asElement() as TypeElement
+            if (elementTypeElement.superclass.kind == TypeKind.NONE) {
+                Utils.error(
+                        getFieldErrorSuffix(field) + "Only concrete Realm classes are allowed in RealmLists. "
+                                + "Neither interfaces nor abstract classes are allowed.",
+                        field)
+                return false
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!containsType(validListValueTypes, elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
+            val messageBuilder = StringBuilder(
+                    getFieldErrorSuffix(field) + "Element type of RealmList must be a class implementing 'RealmModel' or one of ")
+            val separator = ", "
+            for (type in validListValueTypes) {
+                messageBuilder.append('\'').append(type.toString()).append('\'').append(separator)
+            }
+            messageBuilder.setLength(messageBuilder.length - separator.length)
+            messageBuilder.append('.')
+            Utils.error(messageBuilder.toString(), field)
+            return false
+        }
+
+        return true
+    }
+
+    private fun checkRealmResultsType(field: VariableElement): Boolean {
+        // Only classes implementing RealmModel are allowed since RealmResults field is used only for backlinks.
+
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field)
+            return false
+        }
+
+        val fieldType = field.asType()
+        val elementTypeMirror = (fieldType as DeclaredType).typeArguments[0]
+        if (elementTypeMirror.kind == TypeKind.DECLARED /* class or interface*/) {
+            val elementTypeElement = (elementTypeMirror as DeclaredType).asElement() as TypeElement
+            if (elementTypeElement.superclass.kind == TypeKind.NONE) {
+                Utils.error(
+                        ("Only concrete Realm classes are allowed in RealmResults. " + "Neither interfaces nor abstract classes are allowed."),
+                        field)
+                return false
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!Utils.isRealmModel(elementTypeMirror)) {
+            Utils.error(getFieldErrorSuffix(field) + "Element type of RealmResults must be a class implementing 'RealmModel'.", field)
+            return false
+        }
+
+        return true
+    }
+
+    private fun getFieldErrorSuffix(field: VariableElement): String {
+        return "$simpleJavaClassName.${field.simpleName}: "
+    }
+
+    private fun checkReferenceTypes(): Boolean {
+        for (field in fields) {
+            if (Utils.isRealmModel(field)) {
+                // Check that the referenced type is a concrete class and not an interface
+                val typeElement = elements.getTypeElement(field.asType().toString())
+                if (typeElement.superclass.kind == TypeKind.NONE) {
+                    Utils.error(
+                            ("Only concrete Realm classes can be referenced from model classes. " + "Neither interfaces nor abstract classes are allowed."),
+                            field)
+                    return false
+                }
+            }
+        }
+
+        return true
+    }
+
+    // Report if the default constructor is missing
+    private fun checkDefaultConstructor(): Boolean {
+        return if (!hasDefaultConstructor) {
+            Utils.error(String.format(Locale.US,
+                    "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
+                    simpleJavaClassName))
+            false
+        } else {
+            true
+        }
+    }
+
+    private fun checkForFinalFields(): Boolean {
+        for (field in fields) {
+            if (!field.modifiers.contains(Modifier.FINAL)) {
+                continue
+            }
+            if (Utils.isMutableRealmInteger(field)) {
+                continue
+            }
+
+            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", simpleJavaClassName,
+                    field.simpleName.toString()))
+
+            return false
+        }
+        return true
+    }
+
+    private fun checkForVolatileFields(): Boolean {
+        for (field in fields) {
+            if (field.modifiers.contains(Modifier.VOLATILE)) {
+                Utils.error(String.format(Locale.US,
+                        "Class \"%s\" contains illegal volatile field \"%s\".",
+                        simpleJavaClassName,
+                        field.simpleName.toString()))
+                return false
+            }
+        }
+        return true
+    }
+
+    private fun categorizeField(element: Element): Boolean {
+        val fieldRef = element as VariableElement
+
+        // completely ignore any static fields
+        if (fieldRef.modifiers.contains(Modifier.STATIC)) {
+            return true
+        }
+
+        // Ignore fields marked with @Ignore or if they are transient
+        if (fieldRef.getAnnotation(Ignore::class.java) != null || fieldRef.modifiers.contains(Modifier.TRANSIENT)) {
+            return true
+        }
+
+        // Determine name for field
+        val internalFieldName = getInternalFieldName(fieldRef, defaultFieldNameFormatter)
+        val field = RealmFieldElement(fieldRef, internalFieldName)
+
+        if (field.getAnnotation(Index::class.java) != null) {
+            if (!categorizeIndexField(element, field)) {
+                return false
+            }
+        }
+
+        // @Required annotation of RealmList field only affects its value type, not field itself.
+        if (Utils.isRealmList(field)) {
+            val hasRequiredAnnotation = hasRequiredAnnotation(field)
+            val listGenericType = (field.asType() as DeclaredType).typeArguments
+            val containsRealmModelClasses = (listGenericType.isNotEmpty() && Utils.isRealmModel(listGenericType[0]))
+
+            // @Required not allowed if the list contains Realm model classes
+            if (hasRequiredAnnotation && containsRealmModelClasses) {
+                Utils.error("@Required not allowed on RealmList's that contain other Realm model classes.")
+                return false
+            }
+
+            // @Required thus only makes sense for RealmLists with primitive types
+            // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
+            if (!hasRequiredAnnotation) {
+                if (!containsRealmModelClasses) {
+                    nullableValueListFields.add(field)
+                }
+            }
+        } else if (isRequiredField(field)) {
+            if (!checkBasicRequiredAnnotationUsage(element, field)) {
+                return false
+            }
+        } else {
+            // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
+            // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
+            // nullableFields.
+            // RealmList of models, RealmResults(backlinks) and primitive types are NOT nullable. @Required annotation is not supported.
+            if (!Utils.isPrimitiveType(field) && !Utils.isRealmResults(field)) {
+                nullableFields.add(field)
+            }
+        }
+
+        if (field.getAnnotation(PrimaryKey::class.java) != null) {
+            if (!categorizePrimaryKeyField(field)) {
+                return false
+            }
+        }
+
+        // @LinkingObjects cannot be @PrimaryKey or @Index.
+        if (field.getAnnotation(LinkingObjects::class.java) != null) {
+            // Do not add backlinks to fields list.
+            return categorizeBacklinkField(field)
+        }
+
+        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
+        if (Utils.isMutableRealmInteger(field)) {
+            if (!categorizeMutableRealmIntegerField(field)) {
+                return false
+            }
+        }
+
+        // Standard field that appears to be valid (more fine grained checks might fail later).
+        fields.add(field)
+        if (Utils.isRealmModel(field) || Utils.isRealmModelList(field)) {
+            _objectReferenceFields.add(field)
+        } else {
+            basicTypeFields.add(field)
+        }
+
+        return true
+    }
+
+    private fun getInternalFieldName(field: VariableElement, defaultConverter: NameConverter): String {
+        val nameAnnotation: RealmField? = field.getAnnotation(RealmField::class.java)
+        if (nameAnnotation != null) {
+            if (nameAnnotation.name.isNotEmpty()) {
+                return nameAnnotation.name
+            }
+            if (nameAnnotation.value.isNotEmpty()) {
+                return nameAnnotation.value
+            }
+            Utils.note(String.format(("Empty internal name defined on @RealmField. " + "Falling back to named used by Java model class: %s"), field.simpleName), field)
+            return field.simpleName.toString()
+        } else {
+            return defaultConverter.convert(field.simpleName.toString())
+        }
+    }
+
+    /**
+     * This method only checks if the field has `@Required` annotation.
+     * In most cases, you should use [.isRequiredField] to take into account
+     * Kotlin's annotation as well.
+     *
+     * @param field target field.
+     * @return `true` if the field has `@Required` annotation, `false` otherwise.
+     * @see .isRequiredField
+     */
+    private fun hasRequiredAnnotation(field: VariableElement): Boolean {
+        return field.getAnnotation(Required::class.java) != null
+    }
+
+    /**
+     * Checks if the field is annotated as required.
+     * @param field target field.
+     * @return `true` if the field is annotated as required, `false` otherwise.
+     */
+    private fun isRequiredField(field: VariableElement): Boolean {
+        if (hasRequiredAnnotation(field)) {
+            return true
+        }
+
+        if (ignoreKotlinNullability) {
+            return false
+        }
+
+        // Kotlin uses the `org.jetbrains.annotations.NotNull` annotation to mark non-null fields.
+        // In order to fully support the Kotlin type system we interpret `@NotNull` as an alias
+        // for `@Required`
+        for (annotation in field.annotationMirrors) {
+            if (annotation.annotationType.toString() == "org.jetbrains.annotations.NotNull") {
+                return true
+            }
+        }
+
+        return false
+    }
+
+    // The field has the @Index annotation. It's only valid for column types:
+    // STRING, DATE, INTEGER, BOOLEAN, and RealmMutableInteger
+    private fun categorizeIndexField(element: Element, fieldElement: RealmFieldElement): Boolean {
+        var indexable = false
+
+        if (Utils.isMutableRealmInteger(fieldElement)) {
+            indexable = true
+        } else {
+            when (Constants.JAVA_TO_REALM_TYPES[fieldElement.asType().toString()]) {
+                Constants.RealmFieldType.STRING,
+                Constants.RealmFieldType.DATE,
+                Constants.RealmFieldType.INTEGER,
+                Constants.RealmFieldType.BOOLEAN -> { indexable = true }
+                else -> { /* Ignore */ }
+            }
+        }
+
+        if (indexable) {
+            indexedFields.add(fieldElement)
+            return true
+        }
+
+        Utils.error(String.format(Locale.US, "Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()))
+        return false
+    }
+
+    // The field has the @Required annotation
+    // Returns `true` if the field could be correctly validated, `false` if an error was reported.
+    private fun checkBasicRequiredAnnotationUsage(element: Element, variableElement: VariableElement): Boolean {
+        if (Utils.isPrimitiveType(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "@Required or @NotNull annotation is unnecessary for primitive field \"%s\".", element))
+            return false
+        }
+
+        if (Utils.isRealmModel(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" cannot be @Required or @NotNull.", element, element.asType()))
+            return false
+        }
+
+        // Should never get here - user should remove @Required
+        if (nullableFields.contains(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
+                    element,
+                    element.asType()))
+
+            return false
+        }
+
+        return true
+    }
+
+    // The field has the @PrimaryKey annotation. It is only valid for
+    // String, short, int, long and must only be present one time
+    private fun categorizePrimaryKeyField(fieldElement: RealmFieldElement): Boolean {
+        if (primaryKey != null) {
+            Utils.error(String.format(Locale.US,
+                    "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
+                    primaryKey!!.simpleName.toString(),
+                    fieldElement.simpleName.toString()))
+            return false
+        }
+
+        val fieldType = fieldElement.asType()
+        if (!isValidPrimaryKeyType(fieldType)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
+                    fieldElement.simpleName.toString(),
+                    fieldType))
+            return false
+        }
+
+        primaryKey = fieldElement
+
+        // Also add as index. All types of primary key can be indexed.
+        if (!indexedFields.contains(fieldElement)) {
+            indexedFields.add(fieldElement)
+        }
+
+        return true
+    }
+
+    private fun categorizeBacklinkField(variableElement: VariableElement): Boolean {
+        val backlink = Backlink(this, variableElement)
+        if (!backlink.validateSource()) {
+            return false
+        }
+
+        backlinks.add(backlink)
+
+        return true
+    }
+
+    private fun categorizeMutableRealmIntegerField(field: VariableElement): Boolean {
+        if (field.modifiers.contains(Modifier.FINAL)) {
+            return true
+        }
+
+        Utils.error(String.format(Locale.US,
+                "Field \"%s\", a MutableRealmInteger, must be final.",
+                field.simpleName.toString()))
+        return false
+    }
+
+    private fun isValidPrimaryKeyType(type: TypeMirror): Boolean {
+        for (validType in validPrimaryKeyTypes) {
+            if (typeUtils.isAssignable(type, validType)) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private fun containsType(listOfTypes: List<TypeMirror>, type: TypeMirror): Boolean {
+        for (i in listOfTypes.indices) {
+            // Comparing TypeMirror's using `equals()` breaks when using incremental annotation processing.
+            if (typeUtils.isSameType(listOfTypes[i], type)) {
+                return true
+            }
+        }
+        return false
+    }
+
+    companion object {
+        private val OPTION_IGNORE_KOTLIN_NULLABILITY = "realm.ignoreKotlinNullability"
+        private val MAX_CLASSNAME_LENGTH = 57
+    }
+
+}
+
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
deleted file mode 100644
index 0c6d09306c..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-
-public class Constants {
-    public static final String REALM_PACKAGE_NAME = "io.realm";
-    public static final String PROXY_SUFFIX = "RealmProxy";
-    public static final String INTERFACE_SUFFIX = "RealmProxyInterface";
-    public static final String INDENT = "    ";
-    public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
-    static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
-            "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")";
-    static final String STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON =
-            "throw new IllegalArgumentException(\"JSON object doesn't have the primary key field '%s'.\")";
-    static final String STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED =
-            "throw new io.realm.exceptions.RealmException(\"Primary key field '%s' cannot be changed after object" +
-                    " was created.\")";
-    static final String STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD =
-            "throw new io.realm.exceptions.RealmException(\"\\\"%s\\\" field \\\"%s\\\" cannot be loaded from json\")";
-
-
-    /**
-     * Realm types and their corresponding Java types
-     */
-    public enum RealmFieldType {
-        NOTYPE(null, "Void"),
-        INTEGER("INTEGER", "Long"),
-        FLOAT("FLOAT", "Float"),
-        DOUBLE("DOUBLE", "Double"),
-        BOOLEAN("BOOLEAN", "Boolean"),
-        STRING("STRING", "String"),
-        DATE("DATE", "Date"),
-        BINARY("BINARY", "BinaryByteArray"),
-        REALM_INTEGER("INTEGER", "Long"),
-        OBJECT("OBJECT", "Object"),
-        LIST("LIST", "List"),
-
-        BACKLINK("LINKING_OBJECTS", null),
-
-        INTEGER_LIST("INTEGER_LIST", "List"),
-        BOOLEAN_LIST("BOOLEAN_LIST", "List"),
-        STRING_LIST("STRING_LIST", "List"),
-        BINARY_LIST("BINARY_LIST", "List"),
-        DATE_LIST("DATE_LIST", "List"),
-        FLOAT_LIST("FLOAT_LIST", "List"),
-        DOUBLE_LIST("DOUBLE_LIST", "List");
-
-        private final String realmType;
-        private final String javaType;
-
-        /**
-         * @param realmType The simple name of the Enum type used in the Java bindings, to represent this type.
-         * @param javaType The simple name of the Java type needed to store this Realm Type
-         */
-        RealmFieldType(String realmType, String javaType) {
-            this.realmType = "RealmFieldType." + realmType;
-            this.javaType = javaType;
-        }
-
-        /**
-         * Get the name of the enum, used in the Java bindings, used to represent the corresponding type.
-         * @return the name of the enum used to represent this Realm Type
-         */
-        public String getRealmType() {
-            return realmType;
-        }
-
-        /**
-         * Get the name of the Java type needed to store this Realm Type
-         * @return the simple name for the corresponding Java type
-         */
-        public String getJavaType() {
-            return javaType;
-        }
-    }
-
-
-    static final Map<String, RealmFieldType> JAVA_TO_REALM_TYPES;
-
-    static {
-        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
-        m.put("byte", RealmFieldType.INTEGER);
-        m.put("short", RealmFieldType.INTEGER);
-        m.put("int", RealmFieldType.INTEGER);
-        m.put("long", RealmFieldType.INTEGER);
-        m.put("float", RealmFieldType.FLOAT);
-        m.put("double", RealmFieldType.DOUBLE);
-        m.put("boolean", RealmFieldType.BOOLEAN);
-        m.put("java.lang.Byte", RealmFieldType.INTEGER);
-        m.put("java.lang.Short", RealmFieldType.INTEGER);
-        m.put("java.lang.Integer", RealmFieldType.INTEGER);
-        m.put("java.lang.Long", RealmFieldType.INTEGER);
-        m.put("java.lang.Float", RealmFieldType.FLOAT);
-        m.put("java.lang.Double", RealmFieldType.DOUBLE);
-        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN);
-        m.put("java.lang.String", RealmFieldType.STRING);
-        m.put("java.util.Date", RealmFieldType.DATE);
-        m.put("byte[]", RealmFieldType.BINARY);
-        // TODO: add support for char and Char
-        JAVA_TO_REALM_TYPES = Collections.unmodifiableMap(m);
-    }
-
-
-    static final Map<String, RealmFieldType> LIST_ELEMENT_TYPE_TO_REALM_TYPES;
-
-    static {
-        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
-        m.put("java.lang.Byte", RealmFieldType.INTEGER_LIST);
-        m.put("java.lang.Short", RealmFieldType.INTEGER_LIST);
-        m.put("java.lang.Integer", RealmFieldType.INTEGER_LIST);
-        m.put("java.lang.Long", RealmFieldType.INTEGER_LIST);
-        m.put("java.lang.Float", RealmFieldType.FLOAT_LIST);
-        m.put("java.lang.Double", RealmFieldType.DOUBLE_LIST);
-        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN_LIST);
-        m.put("java.lang.String", RealmFieldType.STRING_LIST);
-        m.put("java.util.Date", RealmFieldType.DATE_LIST);
-        m.put("byte[]", RealmFieldType.BINARY_LIST);
-        LIST_ELEMENT_TYPE_TO_REALM_TYPES = Collections.unmodifiableMap(m);
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.kt
new file mode 100644
index 0000000000..053a4de5ef
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.kt
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+object Constants {
+
+    const val REALM_PACKAGE_NAME = "io.realm"
+    const val PROXY_SUFFIX = "RealmProxy"
+    const val INTERFACE_SUFFIX = "RealmProxyInterface"
+    const val INDENT = "    "
+    const val DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule"
+    const val STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
+            "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")"
+    const val STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON =
+            "throw new IllegalArgumentException(\"JSON object doesn't have the primary key field '%s'.\")"
+    const val STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED =
+            "throw new io.realm.exceptions.RealmException(\"Primary key field '%s' cannot be changed after object was created.\")"
+    const val STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD
+            = "throw new io.realm.exceptions.RealmException(\"\\\"%s\\\" field \\\"%s\\\" cannot be loaded from json\")"
+    val JAVA_TO_REALM_TYPES = hashMapOf<String, RealmFieldType>()
+    val LIST_ELEMENT_TYPE_TO_REALM_TYPES = hashMapOf<String, RealmFieldType>()
+
+    /**
+     * Realm types and their corresponding Java types.
+     *
+     * @param realmType The simple name of the Enum type used in the Java bindings, to represent this type.
+     * @param javaType The simple name of the Java type needed to store this Realm Type
+     */
+    enum class RealmFieldType(realmType: String?, val javaType: String?) {
+        NOTYPE(null, "Void"),
+        INTEGER("INTEGER", "Long"),
+        FLOAT("FLOAT", "Float"),
+        DOUBLE("DOUBLE", "Double"),
+        BOOLEAN("BOOLEAN", "Boolean"),
+        STRING("STRING", "String"),
+        DATE("DATE", "Date"),
+        BINARY("BINARY", "BinaryByteArray"),
+        REALM_INTEGER("INTEGER", "Long"),
+        OBJECT("OBJECT", "Object"),
+        LIST("LIST", "List"),
+
+        BACKLINK("LINKING_OBJECTS", null),
+
+        INTEGER_LIST("INTEGER_LIST", "List"),
+        BOOLEAN_LIST("BOOLEAN_LIST", "List"),
+        STRING_LIST("STRING_LIST", "List"),
+        BINARY_LIST("BINARY_LIST", "List"),
+        DATE_LIST("DATE_LIST", "List"),
+        FLOAT_LIST("FLOAT_LIST", "List"),
+        DOUBLE_LIST("DOUBLE_LIST", "List");
+
+        /**
+         * The name of the enum, used in the Java bindings, used to represent the corresponding type.
+         */
+        val realmType: String = "RealmFieldType.$realmType"
+    }
+
+    init {
+        JAVA_TO_REALM_TYPES["byte"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["short"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["int"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["long"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["float"] = RealmFieldType.FLOAT
+        JAVA_TO_REALM_TYPES["double"] = RealmFieldType.DOUBLE
+        JAVA_TO_REALM_TYPES["boolean"] = RealmFieldType.BOOLEAN
+        JAVA_TO_REALM_TYPES["java.lang.Byte"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["java.lang.Short"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["java.lang.Integer"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["java.lang.Long"] = RealmFieldType.INTEGER
+        JAVA_TO_REALM_TYPES["java.lang.Float"] = RealmFieldType.FLOAT
+        JAVA_TO_REALM_TYPES["java.lang.Double"] = RealmFieldType.DOUBLE
+        JAVA_TO_REALM_TYPES["java.lang.Boolean"] = RealmFieldType.BOOLEAN
+        JAVA_TO_REALM_TYPES["java.lang.String"] = RealmFieldType.STRING
+        JAVA_TO_REALM_TYPES["java.util.Date"] = RealmFieldType.DATE
+        JAVA_TO_REALM_TYPES["byte[]"] = RealmFieldType.BINARY
+        // TODO: add support for char and Char
+
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Byte"] = RealmFieldType.INTEGER_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Short"] = RealmFieldType.INTEGER_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Integer"] = RealmFieldType.INTEGER_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Long"] = RealmFieldType.INTEGER_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Float"] = RealmFieldType.FLOAT_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Double"] = RealmFieldType.DOUBLE_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.Boolean"] = RealmFieldType.BOOLEAN_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.lang.String"] = RealmFieldType.STRING_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["java.util.Date"] = RealmFieldType.DATE_LIST
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES["byte[]"] = RealmFieldType.BINARY_LIST
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
deleted file mode 100644
index 948f662225..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Locale;
-import java.util.Map;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.tools.JavaFileObject;
-
-import io.realm.annotations.RealmModule;
-
-
-/**
- * This class is responsible for creating the DefaultRealmModule that contains all known
- * {@link io.realm.annotations.RealmClass}' known at compile time.
- */
-public class DefaultModuleGenerator {
-
-    private final ProcessingEnvironment env;
-
-    public DefaultModuleGenerator(ProcessingEnvironment env) {
-        this.env = env;
-    }
-
-    public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
-        JavaFileObject sourceFile = env.getFiler().createSourceFile(qualifiedGeneratedClassName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-        writer.setIndent("    ");
-
-        writer.emitPackage(Constants.REALM_PACKAGE_NAME);
-        writer.emitEmptyLine();
-
-        Map<String, Boolean> attributes = new LinkedHashMap<>();
-        attributes.put("allClasses", Boolean.TRUE);
-        writer.emitAnnotation(RealmModule.class, attributes);
-        writer.beginType(
-                qualifiedGeneratedClassName,        // full qualified name of the item to generate
-                "class",                            // the type of the item
-                Collections.<Modifier>emptySet(),   // modifiers to apply
-                null);                              // class to extend
-        writer.emitEmptyLine();
-
-        writer.endType();
-        writer.close();
-    }
-}
-
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.kt
new file mode 100644
index 0000000000..488890f2de
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import com.squareup.javawriter.JavaWriter
+
+import java.io.BufferedWriter
+import java.io.IOException
+import java.util.LinkedHashMap
+import java.util.Locale
+
+import javax.annotation.processing.ProcessingEnvironment
+
+import io.realm.annotations.RealmModule
+
+/**
+ * This class is responsible for creating the DefaultRealmModule that contains all known
+ * [io.realm.annotations.RealmClass]' known at compile time.
+ */
+class DefaultModuleGenerator(private val env: ProcessingEnvironment) {
+
+    @Throws(IOException::class)
+    fun generate() {
+        val qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME)
+        val sourceFile = env.filer.createSourceFile(qualifiedGeneratedClassName)
+        val writer = JavaWriter(BufferedWriter(sourceFile.openWriter()))
+
+        /**
+         * Defines the [io.realm.annotations.RealmModule.allClasses] attribute
+         */
+        val attributes = LinkedHashMap<String, Boolean>()
+        attributes["allClasses"] = java.lang.Boolean.TRUE
+
+        // Build minimal class with the required `@RealmModule` annotation for including all
+        // known Realm model classes in this compilation unit.
+        writer.apply {
+            indent = Constants.INDENT
+            emitPackage(Constants.REALM_PACKAGE_NAME)
+            emitEmptyLine()
+            emitAnnotation(RealmModule::class.java, attributes)
+            beginType(
+                    qualifiedGeneratedClassName, // full qualified name of the item to generate
+                    "class",               // the type of the item
+                    emptySet(),                 // modifiers to apply
+                    null)           // class to extend
+            emitEmptyLine()
+            endType()
+            close()
+        }
+
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
deleted file mode 100644
index c713790379..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
+++ /dev/null
@@ -1,482 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-
-import io.realm.annotations.RealmModule;
-import io.realm.annotations.RealmNamingPolicy;
-import io.realm.processor.nameconverter.NameConverter;
-
-
-/**
- * Utility class for holding metadata for the Realm modules.
- * <p>
- * Modules are inherently difficult to process because a model class can be part of multiple modules
- * that contain information required by the model class (e.g. class/field naming policies). At the
- * same time, the module will need the data from processed model classes to fully complete its
- * analysis (e.g. to ensure that only valid Realm model classes are added to the module).
- * <p>
- * For this reason, processing modules are separated into 3 steps:
- * <ol>
- *  <li>
- *      Pre-processing. Done by calling {@link #preProcess(Set)}, which will do an initial parse
- *      of the modules and build up all information it can before processing any model classes.
- *  </li>
- *  <li>
- *      Process model classes. See {@link ClassMetaData#generate(ModuleMetaData)}.
- *  </li>
- *  <li>
- *      Post-processing. Done by calling {@link #postProcess(ClassCollection)}. All modules can now
- *      be fully verified, and all metadata required to output module files can be generated.
- *  </li>
- * </ol>
- */
-public class ModuleMetaData {
-
-    // Pre-processing
-    // <FullyQualifiedModuleClassName, X>
-    private Set<String> globalModules = new LinkedHashSet<>(); // All modules with `allClasses = true` set
-    private Map<String, Set<String>> specificClassesModules = new LinkedHashMap<>(); // Modules with classes specifically named
-    private Map<String, RealmNamingPolicy> classNamingPolicy = new LinkedHashMap<>();
-    private Map<String, RealmNamingPolicy> fieldNamingPolicy = new LinkedHashMap<>();
-    private Map<String, RealmModule> moduleAnnotations = new HashMap<>();
-
-    // Post-processing
-    // <FullyQualifiedModuleClassName, X>
-    private Map<String, Set<ClassMetaData>> modules = new LinkedHashMap<>();
-    private Map<String, Set<ClassMetaData>> libraryModules = new LinkedHashMap<>();
-
-    private boolean shouldCreateDefaultModule;
-
-    /**
-     * Builds all meta data structures that can be calculated before processing any model classes.
-     * Any errors or messages will be posted on the provided Messager.
-     *
-     * @return True if meta data was correctly created and processing of model classes can continue, false otherwise.
-     */
-    public boolean preProcess(Set<? extends Element> moduleClasses) {
-
-        // Tracks all module settings with `allClasses` enabled
-        Set<ModulePolicyInfo> globalModuleInfo = new HashSet<>();
-
-        // Tracks which modules a class was mentioned in by name using `classes = { ... }`
-        // <Qualified
-        Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo = new HashMap<>();
-
-        // Check that modules are setup correctly
-        for (Element classElement : moduleClasses) {
-            String classSimpleName = classElement.getSimpleName().toString();
-
-            // Check that the annotation is only applied to a class
-            if (!classElement.getKind().equals(ElementKind.CLASS)) {
-                Utils.error("The RealmModule annotation can only be applied to classes", classElement);
-                return false;
-            }
-
-            // Check that allClasses and classes are not set at the same time
-            RealmModule moduleAnnotation = classElement.getAnnotation(RealmModule.class);
-            Utils.note("Processing module " + classSimpleName);
-            if (moduleAnnotation.allClasses() && hasCustomClassList(classElement)) {
-                Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in " + classSimpleName);
-                return false;
-            }
-
-            // Validate that naming policies are correctly configured.
-            if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, (TypeElement) classElement, moduleAnnotation)) {
-                return false;
-            }
-
-            moduleAnnotations.put(((TypeElement) classElement).getQualifiedName().toString(), moduleAnnotation);
-        }
-
-        return true;
-    }
-
-    /**
-     * Validates that the class/field naming policy for this module is correct.
-     *
-     * @param globalModuleInfo list of all modules with `allClasses` set
-     * @param classSpecificModuleInfo map of explicit classes and which modules they are explicitly mentioned in.
-     * @param classElement class element currently being validated
-     * @param moduleAnnotation annotation on this class.
-     * @return {@code true} if everything checks out, {@code false} if an error was found and reported.
-     */
-    private boolean validateNamingPolicies(Set<ModulePolicyInfo> globalModuleInfo, Map<String, List<ModulePolicyInfo>> classSpecificModuleInfo, TypeElement classElement, RealmModule moduleAnnotation) {
-        RealmNamingPolicy classNamePolicy = moduleAnnotation.classNamingPolicy();
-        RealmNamingPolicy fieldNamePolicy = moduleAnnotation.fieldNamingPolicy();
-        String qualifiedModuleClassName = classElement.getQualifiedName().toString();
-        ModulePolicyInfo moduleInfo = new ModulePolicyInfo(qualifiedModuleClassName, classNamePolicy, fieldNamePolicy);
-
-        // The difference between `allClasses` and a list of classes is a bit tricky at this stage
-        // as we haven't processed the full list of classes yet. We therefore need to treat
-        // each case specifically :(
-        // We do not compare against the default module as it is always configured correctly
-        // with NO_POLICY, meaning it will not trigger any errors.
-        if (moduleAnnotation.allClasses()) {
-            // Check for conflicts with all other modules with `allClasses` set.
-            for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
-                if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
-                    return false;
-                }
-            }
-
-            // Check for conflicts with specifically named classes. This can happen if another
-            // module is listing specific classes with another policy.
-            for (Map.Entry<String, List<ModulePolicyInfo>> classPolicyInfo : classSpecificModuleInfo.entrySet()) {
-                for (ModulePolicyInfo otherModuleInfo : classPolicyInfo.getValue()) {
-                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
-                        return false;
-                    }
-                }
-            }
-
-            // Everything checks out. Add moduleInfo so we can track it for the next module.
-            globalModuleInfo.add(moduleInfo);
-            globalModules.add(qualifiedModuleClassName);
-
-        } else {
-            // We need to verify each class in the modules class list
-            Set<String> classNames = getClassListFromModule(classElement);
-            for (String qualifiedClassName : classNames) {
-
-                // Check that no other module with `allClasses` conflict with this specific
-                // class configuration
-                for (ModulePolicyInfo otherModuleInfo : globalModuleInfo) {
-                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
-                        return false;
-                    }
-                }
-
-                // Check that this specific class isn't conflicting with another module
-                // specifically mentioning it using `classes = { ... }`
-                List<ModulePolicyInfo> otherModules = classSpecificModuleInfo.get(qualifiedClassName);
-                if (otherModules != null) {
-                    for (ModulePolicyInfo otherModuleInfo : otherModules) {
-                        if (checkAndReportPolicyConflict(qualifiedClassName, moduleInfo, otherModuleInfo)) {
-                            return false;
-                        }
-                    }
-                }
-
-                // Keep track of the specific class for other module checks. We only
-                // need to track the latest module seen as previous errors would have been
-                // caught in a previous iteration of the loop.
-                if (!classSpecificModuleInfo.containsKey(qualifiedClassName)) {
-                    classSpecificModuleInfo.put(qualifiedClassName, new ArrayList<>());
-                }
-                classSpecificModuleInfo.get(qualifiedClassName).add(moduleInfo);
-            }
-            specificClassesModules.put(qualifiedModuleClassName, classNames);
-        }
-
-        classNamingPolicy.put(qualifiedModuleClassName, classNamePolicy);
-        fieldNamingPolicy.put(qualifiedModuleClassName, fieldNamePolicy);
-        return true;
-    }
-
-    /**
-     * All model classes have now been processed and the final validation of modules can occur.
-     * Any errors or messages will be posted on the provided Messager.
-     *
-     * @param modelClasses all Realm model classes found by the annotation processor.
-     * @return {@code true} if the module is valid, {@code false} otherwise.
-     */
-    public boolean postProcess(ClassCollection modelClasses) {
-
-        // Process all global modules
-        for (String qualifiedModuleClassName : globalModules) {
-            Set<ClassMetaData> classData = new LinkedHashSet<>();
-            classData.addAll(modelClasses.getClasses());
-            defineModule(qualifiedModuleClassName, classData);
-        }
-
-        // Process all modules with specific classes
-        for (Map.Entry<String, Set<String>> module : specificClassesModules.entrySet()) {
-            String qualifiedModuleClassName = module.getKey();
-            Set<ClassMetaData> classData = new LinkedHashSet<>();
-            for (String qualifiedModelClassName : module.getValue()) {
-                if (!modelClasses.containsQualifiedClass(qualifiedModelClassName)) {
-                    Utils.error(Utils.stripPackage(qualifiedModelClassName) + " could not be added to the module. " +
-                            "Only classes extending RealmObject or implementing RealmModel, which are part of this project, can be added.");
-                    return false;
-
-                }
-                classData.add(modelClasses.getClassFromQualifiedName(qualifiedModelClassName));
-            }
-            defineModule(qualifiedModuleClassName, classData);
-        }
-
-        // Check that app and library modules are not mixed
-        if (modules.size() > 0 && libraryModules.size() > 0) {
-            StringBuilder sb = new StringBuilder();
-            sb.append("Normal modules and library modules cannot be mixed in the same project.");
-            sb.append('\n');
-            sb.append("Normal module(s):\n");
-            for (String module : modules.keySet()) {
-                sb.append("  ");
-                sb.append(module);
-                sb.append('\n');
-            }
-            sb.append("Library module(s):\n");
-            for (String module : libraryModules.keySet()) {
-                sb.append("  ");
-                sb.append(module);
-                sb.append('\n');
-            }
-            Utils.error(sb.toString());
-            return false;
-        }
-
-        // Create default Realm module if needed.
-        // Note: Kotlin will trigger the annotation processor even if no Realm annotations are used.
-        // The DefaultRealmModule should not be created in this case either.
-        if (libraryModules.size() == 0 && modelClasses.size() > 0) {
-            shouldCreateDefaultModule = true;
-            String defaultModuleName = Constants.REALM_PACKAGE_NAME + "." + Constants.DEFAULT_MODULE_CLASS_NAME;
-            modules.put(defaultModuleName, modelClasses.getClasses());
-        }
-
-        return true;
-    }
-
-    private void defineModule(String qualifiedModuleClassName, Set<ClassMetaData> classData) {
-        if (!classData.isEmpty()) {
-            if (moduleAnnotations.get(qualifiedModuleClassName).library()) {
-                libraryModules.put(qualifiedModuleClassName, classData);
-            } else {
-                modules.put(qualifiedModuleClassName, classData);
-            }
-        }
-    }
-
-    // Checks if two modules have policy conflicts. Returns true if a conflict was found and reported.
-    private boolean checkAndReportPolicyConflict(ModulePolicyInfo moduleInfo, ModulePolicyInfo otherModuleInfo) {
-        return checkAndReportPolicyConflict(null, moduleInfo, otherModuleInfo);
-    }
-
-    /**
-     * Check for name policy conflicts and report the error if found.
-     *
-     * @param className optional class name if a specific class is being checked.
-     * @param moduleInfo current module.
-     * @param otherModuleInfo already processed module.
-     * @return {@code true} if any errors was reported, {@code false} otherwise.
-     */
-    private boolean checkAndReportPolicyConflict(String className, ModulePolicyInfo moduleInfo, ModulePolicyInfo otherModuleInfo) {
-        boolean foundErrors = false;
-
-        // Check class naming policy
-        RealmNamingPolicy classPolicy = moduleInfo.classNamePolicy;
-        RealmNamingPolicy otherClassPolicy = otherModuleInfo.classNamePolicy;
-        if (classPolicy != RealmNamingPolicy.NO_POLICY
-                && otherClassPolicy != RealmNamingPolicy.NO_POLICY
-                && classPolicy != otherClassPolicy) {
-            Utils.error(String.format("The modules %s and %s disagree on the class naming policy%s: %s vs. %s. " +
-                            "They same policy must be used.",
-                    moduleInfo.qualifiedModuleClassName,
-                    otherModuleInfo.qualifiedModuleClassName,
-                    (className != null) ? " for " + className : "",
-                    classPolicy,
-                    otherClassPolicy));
-            foundErrors = true;
-        }
-
-        // Check field naming policy
-        RealmNamingPolicy fieldPolicy = moduleInfo.fieldNamePolicy;
-        RealmNamingPolicy otherFieldPolicy = otherModuleInfo.fieldNamePolicy;
-        if (fieldPolicy != RealmNamingPolicy.NO_POLICY
-                && otherFieldPolicy != RealmNamingPolicy.NO_POLICY
-                && fieldPolicy != otherFieldPolicy) {
-            Utils.error(String.format("The modules %s and %s disagree on the field naming policy%s: %s vs. %s. " +
-                            "They same policy should be used.",
-                    moduleInfo.qualifiedModuleClassName,
-                    otherModuleInfo.qualifiedModuleClassName,
-                    (className != null) ? " for " + className : "",
-                    fieldPolicy,
-                    otherFieldPolicy));
-            foundErrors = true;
-        }
-
-        return foundErrors;
-    }
-
-    // Detour needed to access the class elements in the array
-    // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
-    @SuppressWarnings("unchecked")
-    private Set<String> getClassListFromModule(Element classElement) {
-        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
-        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
-        Set<String> classes = new HashSet<String>();
-        List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
-        for (AnnotationValue classMirror : moduleClasses) {
-            String fullyQualifiedClassName = classMirror.getValue().toString();
-            classes.add(fullyQualifiedClassName);
-        }
-        return classes;
-    }
-
-    // Work-around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
-    // https://community.oracle.com/thread/1184190
-    @SuppressWarnings("unchecked")
-    private boolean hasCustomClassList(Element classElement) {
-        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
-        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
-        if (annotationValue == null) {
-            return false;
-        } else {
-            List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
-            return moduleClasses.size() > 0;
-        }
-    }
-
-    private AnnotationMirror getAnnotationMirror(Element classElement) {
-        AnnotationMirror annotationMirror = null;
-        for (AnnotationMirror am : classElement.getAnnotationMirrors()) {
-            if (am.getAnnotationType().toString().equals(RealmModule.class.getCanonicalName())) {
-                annotationMirror = am;
-                break;
-            }
-        }
-        return annotationMirror;
-    }
-
-    private AnnotationValue getAnnotationValue(AnnotationMirror annotationMirror) {
-        if (annotationMirror == null) {
-            return null;
-        }
-        AnnotationValue annotationValue = null;
-        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
-            if (entry.getKey().getSimpleName().toString().equals("classes")) {
-                annotationValue = entry.getValue();
-                break;
-            }
-        }
-        return annotationValue;
-    }
-
-    /**
-     * Returns all module classes and the RealmObjects they know of.
-     */
-    public Map<String, Set<ClassMetaData>> getAllModules() {
-        Map<String, Set<ClassMetaData>> allModules = new LinkedHashMap<>();
-        allModules.putAll(modules);
-        allModules.putAll(libraryModules);
-        return allModules;
-    }
-
-    /**
-     * Returns {@code true} if the DefaultRealmModule.java file should be created.
-     */
-    public boolean shouldCreateDefaultModule() {
-        return shouldCreateDefaultModule;
-    }
-
-    /**
-     * Only available after {@link #preProcess(Set)} has run.
-     * Returns the module name policy the given name.
-     */
-    public NameConverter getClassNameFormatter(String qualifiedClassName) {
-        // We already validated that module definitions all agree on the same name policy
-        // so just find first match
-        if (!globalModules.isEmpty()) {
-            return Utils.getNameFormatter(classNamingPolicy.get(globalModules.iterator().next()));
-        }
-
-        // No global modules found, so find match in modules specifically listing the class.
-        // We already validated that all modules agree on the converter, so just find first match.
-        for (Map.Entry<String, Set<String>> moduleInfo : specificClassesModules.entrySet()) {
-            if (moduleInfo.getValue().contains(qualifiedClassName)) {
-                return Utils.getNameFormatter(classNamingPolicy.get(moduleInfo.getKey()));
-            }
-        }
-
-        // No policy was provided anywhere for this class
-        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY);
-    }
-
-
-    /**
-     * Only available after {@link #preProcess(Set)} has run.
-     *
-     * Returns the module name policy the field names.
-     *
-     * @param qualifiedClassName
-     */
-    public NameConverter getFieldNameFormatter(String qualifiedClassName) {
-        // We already validated that module definitions all agree on the same name policy
-        // so just find first match
-        if (!globalModules.isEmpty()) {
-            return Utils.getNameFormatter(fieldNamingPolicy.get(globalModules.iterator().next()));
-        }
-
-        for (Map.Entry<String, Set<String>> moduleInfo : specificClassesModules.entrySet()) {
-            if (moduleInfo.getValue().contains(qualifiedClassName)) {
-                return Utils.getNameFormatter(fieldNamingPolicy.get(moduleInfo.getKey()));
-            }
-        }
-
-        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY);
-    }
-
-    // Tuple helper class
-    private class ModulePolicyInfo {
-        public final String qualifiedModuleClassName;
-        public final RealmNamingPolicy classNamePolicy;
-        public final RealmNamingPolicy fieldNamePolicy;
-
-        public ModulePolicyInfo(String qualifiedModuleClassName, RealmNamingPolicy classNamePolicy, RealmNamingPolicy fieldNamePolicy) {
-            this.qualifiedModuleClassName = qualifiedModuleClassName;
-            this.classNamePolicy = classNamePolicy;
-            this.fieldNamePolicy = fieldNamePolicy;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            ModulePolicyInfo that = (ModulePolicyInfo) o;
-
-            if (!qualifiedModuleClassName.equals(that.qualifiedModuleClassName)) return false;
-            if (classNamePolicy != that.classNamePolicy) return false;
-            return fieldNamePolicy == that.fieldNamePolicy;
-        }
-
-        @Override
-        public int hashCode() {
-            int result = qualifiedModuleClassName.hashCode();
-            result = 31 * result + classNamePolicy.hashCode();
-            result = 31 * result + fieldNamePolicy.hashCode();
-            return result;
-        }
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.kt
new file mode 100644
index 0000000000..0795ad6ce6
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.kt
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import java.util.ArrayList
+import java.util.HashMap
+import java.util.HashSet
+import java.util.LinkedHashMap
+import java.util.LinkedHashSet
+
+import javax.lang.model.element.AnnotationMirror
+import javax.lang.model.element.AnnotationValue
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.TypeElement
+
+import io.realm.annotations.RealmModule
+import io.realm.annotations.RealmNamingPolicy
+import io.realm.processor.nameconverter.NameConverter
+
+/**
+ * Utility class for holding metadata for the Realm modules.
+ *
+ * Modules are inherently difficult to process because a model class can be part of multiple modules
+ * that contain information required by the model class (e.g. class/field naming policies). At the
+ * same time, the module will need the data from processed model classes to fully complete its
+ * analysis (e.g. to ensure that only valid Realm model classes are added to the module).
+ *
+ * For this reason, processing modules are separated into 3 steps:
+ *
+ * 1. Pre-processing. Done by calling [ModuleMetaData.preProcess], which will do an initial parse of the modules
+ *    and build up all information it can before processing any model classes.
+ *
+ * 2. Process model classes. See [ClassMetaData.generate].
+ *
+ * 3. Post-processing. Done by calling [ModuleMetaData.postProcess]. All modules can now be fully verified, and
+ *    all metadata required to output module files can be generated.
+ */
+class ModuleMetaData {
+
+    // Pre-processing
+    private val globalModules = LinkedHashSet<QualifiedClassName>() // All modules with `allClasses = true` set
+    private val specificClassesModules = LinkedHashMap<QualifiedClassName, Set<QualifiedClassName>>() // Modules with classes specifically named
+    private val classNamingPolicy = LinkedHashMap<QualifiedClassName, RealmNamingPolicy>()
+    private val fieldNamingPolicy = LinkedHashMap<QualifiedClassName, RealmNamingPolicy>()
+    private val moduleAnnotations = HashMap<QualifiedClassName, RealmModule>()
+
+    // Post-processing
+    private val modules = LinkedHashMap<QualifiedClassName, Set<ClassMetaData>>()
+    private val libraryModules = LinkedHashMap<QualifiedClassName, Set<ClassMetaData>>()
+
+    private var shouldCreateDefaultModule: Boolean = false
+
+    /**
+     * Returns all module classes and the RealmObjects they know of.
+     */
+    val allModules: Map<QualifiedClassName, Set<ClassMetaData>>
+        get() {
+            val allModules = LinkedHashMap<QualifiedClassName, Set<ClassMetaData>>()
+            allModules.putAll(modules)
+            allModules.putAll(libraryModules)
+            return allModules
+        }
+
+    /**
+     * Builds all meta data structures that can be calculated before processing any model classes.
+     * Any errors or messages will be posted on the provided Messager.
+     *
+     * @return True if meta data was correctly created and processing of model classes can continue, false otherwise.
+     */
+    fun preProcess(moduleClasses: Set<Element>): Boolean {
+
+        // Tracks all module settings with `allClasses` enabled
+        val globalModuleInfo = HashSet<ModulePolicyInfo>()
+
+        // Tracks which modules a class was mentioned in by name using `classes = { ... }`
+        // <Qualified
+        val classSpecificModuleInfo = HashMap<QualifiedClassName, MutableList<ModulePolicyInfo>>()
+
+        // Check that modules are setup correctly
+        for (classElement in moduleClasses) {
+            val classSimpleName = classElement.simpleName.toString()
+
+            // Check that the annotation is only applied to a class
+            if (classElement.kind != ElementKind.CLASS) {
+                Utils.error("The RealmModule annotation can only be applied to classes", classElement)
+                return false
+            }
+
+            // Check that allClasses and classes are not set at the same time
+            val moduleAnnotation = classElement.getAnnotation(RealmModule::class.java)
+            Utils.note("Processing module $classSimpleName")
+            if (moduleAnnotation.allClasses && hasCustomClassList(classElement)) {
+                Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in $classSimpleName")
+                return false
+            }
+
+            // Validate that naming policies are correctly configured.
+            if (!validateNamingPolicies(globalModuleInfo, classSpecificModuleInfo, classElement as TypeElement, moduleAnnotation)) {
+                return false
+            }
+
+            moduleAnnotations[QualifiedClassName(classElement.qualifiedName)] = moduleAnnotation
+        }
+
+        return true
+    }
+
+    /**
+     * Validates that the class/field naming policy for this module is correct.
+     *
+     * @param globalModuleInfo list of all modules with `allClasses` set
+     * @param classSpecificModuleInfo map of explicit classes and which modules they are explicitly mentioned in.
+     * @param classElement class element currently being validated
+     * @param moduleAnnotation annotation on this class.
+     * @return `true` if everything checks out, `false` if an error was found and reported.
+     */
+    private fun validateNamingPolicies(globalModuleInfo: MutableSet<ModulePolicyInfo>,
+                                       classSpecificModuleInfo: HashMap<QualifiedClassName, MutableList<ModulePolicyInfo>>,
+                                       classElement: TypeElement,
+                                       moduleAnnotation: RealmModule): Boolean {
+        val classNamePolicy = moduleAnnotation.classNamingPolicy
+        val fieldNamePolicy = moduleAnnotation.fieldNamingPolicy
+        val moduleClassName = QualifiedClassName(classElement.qualifiedName)
+        val moduleInfo = ModulePolicyInfo(moduleClassName, classNamePolicy, fieldNamePolicy)
+
+        // The difference between `allClasses` and a list of classes is a bit tricky at this stage
+        // as we haven't processed the full list of classes yet. We therefore need to treat
+        // each case specifically :(
+        // We do not compare against the default module as it is always configured correctly
+        // with NO_POLICY, meaning it will not trigger any errors.
+        if (moduleAnnotation.allClasses) {
+            // Check for conflicts with all other modules with `allClasses` set.
+            for (otherModuleInfo in globalModuleInfo) {
+                if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
+                    return false
+                }
+            }
+
+            // Check for conflicts with specifically named classes. This can happen if another
+            // module is listing specific classes with another policy.
+            for ((_, value) in classSpecificModuleInfo) {
+                for (otherModuleInfo in value) {
+                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
+                        return false
+                    }
+                }
+            }
+
+            // Everything checks out. Add moduleInfo so we can track it for the next module.
+            globalModuleInfo.add(moduleInfo)
+            globalModules.add(moduleClassName)
+
+        } else {
+            // We need to verify each class in the modules class list
+            val classNames = getClassListFromModule(classElement)
+            for (className in classNames) {
+
+                // Check that no other module with `allClasses` conflict with this specific
+                // class configuration
+                for (otherModuleInfo in globalModuleInfo) {
+                    if (checkAndReportPolicyConflict(moduleInfo, otherModuleInfo)) {
+                        return false
+                    }
+                }
+
+                // Check that this specific class isn't conflicting with another module
+                // specifically mentioning it using `classes = { ... }`
+                val otherModules= classSpecificModuleInfo[className]
+                if (otherModules != null) {
+                    for (otherModuleInfo in otherModules) {
+                        if (checkAndReportPolicyConflict(className, moduleInfo, otherModuleInfo)) {
+                            return false
+                        }
+                    }
+                }
+
+                // Keep track of the specific class for other module checks. We only
+                // need to track the latest module seen as previous errors would have been
+                // caught in a previous iteration of the loop.
+                if (!classSpecificModuleInfo.containsKey(className)) {
+                    classSpecificModuleInfo[className] = ArrayList()
+                }
+                classSpecificModuleInfo[className]!!.add(moduleInfo)
+            }
+            specificClassesModules[moduleClassName] = classNames
+        }
+
+        classNamingPolicy[moduleClassName] = classNamePolicy
+        fieldNamingPolicy[moduleClassName] = fieldNamePolicy
+        return true
+    }
+
+    /**
+     * All model classes have now been processed and the final validation of modules can occur.
+     * Any errors or messages will be posted on the provided Messager.
+     *
+     * @param modelClasses all Realm model classes found by the annotation processor.
+     * @return `true` if the module is valid, `false` otherwise.
+     */
+    fun postProcess(modelClasses: ClassCollection): Boolean {
+
+        // Process all global modules
+        for (qualifiedModuleClassName: QualifiedClassName in globalModules) {
+            val classData = LinkedHashSet<ClassMetaData>()
+            classData.addAll(modelClasses.classes)
+            defineModule(qualifiedModuleClassName, classData)
+        }
+
+        // Process all modules with specific classes
+        for ((qualifiedModuleClassName, value) in specificClassesModules) {
+            val classData = LinkedHashSet<ClassMetaData>()
+            for (modelClassName: QualifiedClassName in value) {
+                if (!modelClasses.containsQualifiedClass(modelClassName)) {
+                    Utils.error("${modelClassName.getSimpleName()} could not be added to the module. " +
+                            "Only classes extending RealmObject or implementing RealmModel, which are part of this project, can be added.")
+                    return false
+
+                }
+                classData.add(modelClasses.getClassFromQualifiedName(modelClassName))
+            }
+            defineModule(qualifiedModuleClassName, classData)
+        }
+
+        // Check that app and library modules are not mixed
+        if (modules.size > 0 && libraryModules.size > 0) {
+            val sb = StringBuilder()
+            sb.append("Normal modules and library modules cannot be mixed in the same project.")
+            sb.append('\n')
+            sb.append("Normal module(s):\n")
+            for (module in modules.keys) {
+                sb.append("  ")
+                sb.append(module)
+                sb.append('\n')
+            }
+            sb.append("Library module(s):\n")
+            for (module in libraryModules.keys) {
+                sb.append("  ")
+                sb.append(module)
+                sb.append('\n')
+            }
+            Utils.error(sb.toString())
+            return false
+        }
+
+        // Create default Realm module if needed.
+        // Note: Kotlin will trigger the annotation processor even if no Realm annotations are used.
+        // The DefaultRealmModule should not be created in this case either.
+        if (libraryModules.size == 0 && modelClasses.size() > 0) {
+            shouldCreateDefaultModule = true
+            val defaultModuleName = QualifiedClassName("${Constants.REALM_PACKAGE_NAME}.${Constants.DEFAULT_MODULE_CLASS_NAME}")
+            modules[defaultModuleName] = modelClasses.classes
+        }
+
+        return true
+    }
+
+    private fun defineModule(moduleClassName: QualifiedClassName, classData: Set<ClassMetaData>) {
+        if (classData.isNotEmpty()) {
+            if (moduleAnnotations[moduleClassName]!!.library) {
+                libraryModules[moduleClassName] = classData
+            } else {
+                modules[moduleClassName] = classData
+            }
+        }
+    }
+
+    // Checks if two modules have policy conflicts. Returns true if a conflict was found and reported.
+    private fun checkAndReportPolicyConflict(moduleInfo: ModulePolicyInfo, otherModuleInfo: ModulePolicyInfo): Boolean {
+        return checkAndReportPolicyConflict(null, moduleInfo, otherModuleInfo)
+    }
+
+    /**
+     * Check for name policy conflicts and report the error if found.
+     *
+     * @param className optional class name if a specific class is being checked.
+     * @param moduleInfo current module.
+     * @param otherModuleInfo already processed module.
+     * @return `true` if any errors was reported, `false` otherwise.
+     */
+    private fun checkAndReportPolicyConflict(className: QualifiedClassName?, moduleInfo: ModulePolicyInfo, otherModuleInfo: ModulePolicyInfo): Boolean {
+        var foundErrors = false
+
+        // Check class naming policy
+        val classPolicy = moduleInfo.classNamePolicy
+        val otherClassPolicy = otherModuleInfo.classNamePolicy
+        if (classPolicy != RealmNamingPolicy.NO_POLICY
+                && otherClassPolicy != RealmNamingPolicy.NO_POLICY
+                && classPolicy != otherClassPolicy) {
+            Utils.error(String.format("The modules %s and %s disagree on the class naming policy%s: %s vs. %s. " + "They same policy must be used.",
+                    moduleInfo.moduleClassName,
+                    otherModuleInfo.moduleClassName,
+                    if (className != null) " for $className" else "",
+                    classPolicy,
+                    otherClassPolicy))
+            foundErrors = true
+        }
+
+        // Check field naming policy
+        val fieldPolicy = moduleInfo.fieldNamePolicy
+        val otherFieldPolicy = otherModuleInfo.fieldNamePolicy
+        if (fieldPolicy != RealmNamingPolicy.NO_POLICY
+                && otherFieldPolicy != RealmNamingPolicy.NO_POLICY
+                && fieldPolicy != otherFieldPolicy) {
+            Utils.error(String.format("The modules %s and %s disagree on the field naming policy%s: %s vs. %s. " + "They same policy should be used.",
+                    moduleInfo.moduleClassName,
+                    otherModuleInfo.moduleClassName,
+                    if (className != null) " for $className" else "",
+                    fieldPolicy,
+                    otherFieldPolicy))
+            foundErrors = true
+        }
+
+        return foundErrors
+    }
+
+    // Detour needed to access the class elements in the array
+    // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
+    private fun getClassListFromModule(classElement: Element): Set<QualifiedClassName> {
+        val annotationMirror: AnnotationMirror? = getAnnotationMirror(classElement)
+        val annotationValue: AnnotationValue? = getAnnotationValue(annotationMirror)
+        val classes = HashSet<QualifiedClassName>()
+        val moduleClasses = annotationValue!!.value as List<*>
+        for (classMirror in moduleClasses) {
+            // FIXME: Something is fishy about this. Figure out how to get the proper types in Kotlin here
+            val className = QualifiedClassName(classMirror.toString().removeSuffix(".class"))
+            classes.add(className)
+        }
+        return classes
+    }
+
+    // Work-around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
+    // https://community.oracle.com/thread/1184190
+    private fun hasCustomClassList(classElement: Element): Boolean {
+        val annotationMirror: AnnotationMirror? = getAnnotationMirror(classElement)
+        val annotationValue: AnnotationValue? = getAnnotationValue(annotationMirror)
+        return if (annotationValue == null) {
+            false
+        } else {
+            val moduleClasses = annotationValue.value as List<*>
+            moduleClasses.isNotEmpty()
+        }
+    }
+
+    private fun getAnnotationMirror(classElement: Element): AnnotationMirror? {
+        var annotationMirror: AnnotationMirror? = null
+        for (am in classElement.annotationMirrors) {
+            if (am.annotationType.toString() == RealmModule::class.java.canonicalName) {
+                annotationMirror = am
+                break
+            }
+        }
+        return annotationMirror
+    }
+
+    private fun getAnnotationValue(annotationMirror: AnnotationMirror?): AnnotationValue? {
+        if (annotationMirror == null) {
+            return null
+        }
+        var annotationValue: AnnotationValue? = null
+        for ((key, value) in annotationMirror.elementValues) {
+            if (key.simpleName.toString() == "classes") {
+                annotationValue = value
+                break
+            }
+        }
+        return annotationValue
+    }
+
+    /**
+     * Returns `true` if the DefaultRealmModule.java file should be created.
+     */
+    fun shouldCreateDefaultModule(): Boolean {
+        return shouldCreateDefaultModule
+    }
+
+    /**
+     * Only available after [.preProcess] has run.
+     * Returns the module name policy the given name.
+     */
+    fun getClassNameFormatter(className: QualifiedClassName): NameConverter {
+        // We already validated that module definitions all agree on the same name policy
+        // so just find first match
+        if (globalModules.isNotEmpty()) {
+            return Utils.getNameFormatter(classNamingPolicy[globalModules.iterator().next()])
+        }
+
+        // No global modules found, so find match in modules specifically listing the class.
+        // We already validated that all modules agree on the converter, so just find first match.
+        for ((key, value) in specificClassesModules) {
+            if (value.contains(className)) {
+                return Utils.getNameFormatter(classNamingPolicy[key])
+            }
+        }
+
+        // No policy was provided anywhere for this class
+        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY)
+    }
+
+
+    /**
+     * Only available after [ModuleMetaData.preProcess] has run.
+     *
+     * Returns the module name policy the field names.
+     */
+    fun getFieldNameFormatter(className: QualifiedClassName): NameConverter {
+        // We already validated that module definitions all agree on the same name policy
+        // so just find first match
+        if (globalModules.isNotEmpty()) {
+            return Utils.getNameFormatter(fieldNamingPolicy[globalModules.iterator().next()])
+        }
+
+        for ((key, value) in specificClassesModules) {
+            if (value.contains(className)) {
+                return Utils.getNameFormatter(fieldNamingPolicy[key])
+            }
+        }
+
+        return Utils.getNameFormatter(RealmNamingPolicy.NO_POLICY)
+    }
+
+    // Tuple helper class
+    private data class ModulePolicyInfo(val moduleClassName: QualifiedClassName,
+                                        val classNamePolicy: RealmNamingPolicy,
+                                        val fieldNamePolicy: RealmNamingPolicy)
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java
deleted file mode 100644
index f4190e2c63..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.lang.model.element.VariableElement;
-
-/**
- * Helper class for creating the correct method calls to the OsObjectBuilder class.
- */
-public class OsObjectBuilderTypeHelper {
-
-    private static final Map<String, String> QUALIFIED_TYPE_TO_BUILDER;
-    private static final Map<String, String> QUALIFIED_LIST_TYPE_TO_BUILDER;
-
-    static {
-        // Map of qualified types to their OsObjectBuilder Type
-        Map<String, String> fieldTypes = new HashMap<>();
-        fieldTypes.put("byte", "Integer");
-        fieldTypes.put("short", "Integer");
-        fieldTypes.put("int", "Integer");
-        fieldTypes.put("long", "Integer");
-        fieldTypes.put("float", "Float");
-        fieldTypes.put("double", "Double");
-        fieldTypes.put("boolean", "Boolean");
-        fieldTypes.put("byte[]", "ByteArray");
-        fieldTypes.put("java.lang.Byte", "Integer");
-        fieldTypes.put("java.lang.Short", "Integer");
-        fieldTypes.put("java.lang.Integer", "Integer");
-        fieldTypes.put("java.lang.Long", "Integer");
-        fieldTypes.put("java.lang.Float", "Float");
-        fieldTypes.put("java.lang.Double", "Double");
-        fieldTypes.put("java.lang.Boolean", "Boolean");
-        fieldTypes.put("java.lang.String", "String");
-        fieldTypes.put("java.util.Date", "Date");
-        fieldTypes.put("io.realm.MutableRealmInteger", "MutableRealmInteger");
-        QUALIFIED_TYPE_TO_BUILDER = Collections.unmodifiableMap(fieldTypes);
-
-        // Map of qualified types to their OsObjectBuilder Type
-        Map<String, String> listTypes = new HashMap<>();
-        listTypes.put("byte[]", "ByteArrayList");
-        listTypes.put("java.lang.Byte", "ByteList");
-        listTypes.put("java.lang.Short", "ShortList");
-        listTypes.put("java.lang.Integer", "IntegerList");
-        listTypes.put("java.lang.Long", "LongList");
-        listTypes.put("java.lang.Float", "FloatList");
-        listTypes.put("java.lang.Double", "DoubleList");
-        listTypes.put("java.lang.Boolean", "BooleanList");
-        listTypes.put("java.lang.String", "StringList");
-        listTypes.put("java.util.Date", "DateList");
-        listTypes.put("io.realm.MutableRealmInteger", "MutableRealmIntegerList");
-        QUALIFIED_LIST_TYPE_TO_BUILDER = Collections.unmodifiableMap(listTypes);
-    }
-
-    /**
-     * Returns the method name used by the OsObjectBuilder for the given type, e.g. `addInteger`
-     * or `addIntegerList`.
-     */
-    public static String getOsObjectBuilderName(VariableElement field) {
-        if (Utils.isRealmModel(field)) {
-            return "addObject";
-        } else if (Utils.isRealmModelList(field)) {
-            return "addObjectList";
-        } else if (Utils.isRealmValueList(field)) {
-            return "add" + getListTypeName(Utils.getRealmListType(field));
-        } else if (Utils.isRealmResults(field)) {
-            throw new IllegalStateException("RealmResults are not supported by OsObjectBuilder: " + field);
-        } else {
-            return "add" + getBasicTypeName(Utils.getFieldTypeQualifiedName(field));
-        }
-    }
-
-    private static String getBasicTypeName(String qualifiedType) {
-        String type = QUALIFIED_TYPE_TO_BUILDER.get(qualifiedType);
-        if (type != null) {
-            return type;
-        }
-        throw new IllegalArgumentException("Unsupported type: " + qualifiedType);
-    }
-
-    private static String getListTypeName(String qualifiedType) {
-        String type = QUALIFIED_LIST_TYPE_TO_BUILDER.get(qualifiedType);
-        if (type != null) {
-            return type;
-        }
-        throw new IllegalArgumentException("Unsupported list type: " + qualifiedType);
-    }
-
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.kt
new file mode 100644
index 0000000000..6470087c91
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/OsObjectBuilderTypeHelper.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor
+
+import java.util.Collections
+import java.util.HashMap
+
+import javax.lang.model.element.VariableElement
+
+/**
+ * Helper class for creating the correct method calls to the OsObjectBuilder class.
+ */
+object OsObjectBuilderTypeHelper {
+
+    private val QUALIFIED_TYPE_TO_BUILDER: Map<QualifiedClassName, String>
+    private val QUALIFIED_LIST_TYPE_TO_BUILDER: Map<QualifiedClassName, String>
+
+    init {
+        // Map of qualified types to their OsObjectBuilder Type
+        val fieldTypes = HashMap<QualifiedClassName, String>()
+        fieldTypes[QualifiedClassName("byte")] = "Integer"
+        fieldTypes[QualifiedClassName("short")] = "Integer"
+        fieldTypes[QualifiedClassName("int")] = "Integer"
+        fieldTypes[QualifiedClassName("long")] = "Integer"
+        fieldTypes[QualifiedClassName("float")] = "Float"
+        fieldTypes[QualifiedClassName("double")] = "Double"
+        fieldTypes[QualifiedClassName("boolean")] = "Boolean"
+        fieldTypes[QualifiedClassName("byte[]")] = "ByteArray"
+        fieldTypes[QualifiedClassName("java.lang.Byte")] = "Integer"
+        fieldTypes[QualifiedClassName("java.lang.Short")] = "Integer"
+        fieldTypes[QualifiedClassName("java.lang.Integer")] = "Integer"
+        fieldTypes[QualifiedClassName("java.lang.Long")] = "Integer"
+        fieldTypes[QualifiedClassName("java.lang.Float")] = "Float"
+        fieldTypes[QualifiedClassName("java.lang.Double")] = "Double"
+        fieldTypes[QualifiedClassName("java.lang.Boolean")] = "Boolean"
+        fieldTypes[QualifiedClassName("java.lang.String")] = "String"
+        fieldTypes[QualifiedClassName("java.util.Date")] = "Date"
+        fieldTypes[QualifiedClassName("io.realm.MutableRealmInteger")] = "MutableRealmInteger"
+        QUALIFIED_TYPE_TO_BUILDER = Collections.unmodifiableMap(fieldTypes)
+
+        // Map of qualified types to their OsObjectBuilder Type
+        val listTypes = HashMap<QualifiedClassName, String>()
+        listTypes[QualifiedClassName("byte[]")] = "ByteArrayList"
+        listTypes[QualifiedClassName("java.lang.Byte")] = "ByteList"
+        listTypes[QualifiedClassName("java.lang.Short")] = "ShortList"
+        listTypes[QualifiedClassName("java.lang.Integer")] = "IntegerList"
+        listTypes[QualifiedClassName("java.lang.Long")] = "LongList"
+        listTypes[QualifiedClassName("java.lang.Float")] = "FloatList"
+        listTypes[QualifiedClassName("java.lang.Double")] = "DoubleList"
+        listTypes[QualifiedClassName("java.lang.Boolean")] = "BooleanList"
+        listTypes[QualifiedClassName("java.lang.String")] = "StringList"
+        listTypes[QualifiedClassName("java.util.Date")] = "DateList"
+        listTypes[QualifiedClassName("io.realm.MutableRealmInteger")] = "MutableRealmIntegerList"
+        QUALIFIED_LIST_TYPE_TO_BUILDER = Collections.unmodifiableMap(listTypes)
+    }
+
+    /**
+     * Returns the method name used by the OsObjectBuilder for the given type, e.g. `addInteger`
+     * or `addIntegerList`.
+     */
+    fun getOsObjectBuilderName(field: VariableElement): String {
+        return if (Utils.isRealmModel(field)) {
+            "addObject"
+        } else if (Utils.isRealmModelList(field)) {
+            "addObjectList"
+        } else if (Utils.isRealmValueList(field)) {
+            "add" + getListTypeName(Utils.getRealmListType(field))
+        } else if (Utils.isRealmResults(field)) {
+            throw IllegalStateException("RealmResults are not supported by OsObjectBuilder: $field")
+        } else {
+            "add" + getBasicTypeName(Utils.getFieldTypeQualifiedName(field))
+        }
+    }
+
+    private fun getBasicTypeName(qualifiedType: QualifiedClassName): String {
+        val type = QUALIFIED_TYPE_TO_BUILDER[qualifiedType]
+        if (type != null) {
+            return type
+        }
+        throw IllegalArgumentException("Unsupported type: $qualifiedType")
+    }
+
+    private fun getListTypeName(typeName: QualifiedClassName?): String {
+        val type = QUALIFIED_LIST_TYPE_TO_BUILDER[typeName]
+        if (type != null) {
+            return type
+        }
+        throw IllegalArgumentException("Unsupported list type: $type")
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java
deleted file mode 100644
index 578766bc81..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor;
-
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.Set;
-
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-/**
- * Wrapper for {@link javax.lang.model.element.VariableElement} that makes it possible to add
- * additional metadata.
- */
-public class RealmFieldElement implements VariableElement {
-
-    private final VariableElement fieldReference;
-    private final String internalFieldName; // Name used for this field internally in Realm.
-
-    public RealmFieldElement(VariableElement fieldReference, String internalFieldName) {
-        this.fieldReference = fieldReference;
-        this.internalFieldName = internalFieldName;
-    }
-
-    public VariableElement getFieldReference() {
-        return fieldReference;
-    }
-
-    /**
-     * Returns the name that Realm Core uses internally when saving data to this field.
-     * {@link #getSimpleName()} returns the name in the Java class.
-     */
-    public String getInternalFieldName() {
-        return internalFieldName;
-    }
-
-    public Set<Modifier> getModifiers() {
-        return fieldReference.getModifiers();
-    }
-
-    public TypeMirror asType() {
-        return fieldReference.asType();
-    }
-
-    @Override
-    public ElementKind getKind() {
-        return null;
-    }
-
-    @Override
-    public Object getConstantValue() {
-        return fieldReference.getConstantValue();
-    }
-
-    /**
-     * Returns the name for this field in the Java class.
-     * {@link #getInternalFieldName()} returns the name used by Realm Core for the same field.
-     */
-    @Override
-    public Name getSimpleName() {
-        return fieldReference.getSimpleName();
-    }
-
-    @Override
-    public Element getEnclosingElement() {
-        return fieldReference.getEnclosingElement();
-    }
-
-    @Override
-    public List<? extends Element> getEnclosedElements() {
-        return fieldReference.getEnclosedElements();
-    }
-
-    @Override
-    public List<? extends AnnotationMirror> getAnnotationMirrors() {
-        return fieldReference.getAnnotationMirrors();
-    }
-
-    @Override
-    public <A extends Annotation> A getAnnotation(Class<A> aClass) {
-        return fieldReference.getAnnotation(aClass);
-    }
-
-    @Override
-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> aClass) {
-        return fieldReference.getAnnotationsByType(aClass);
-    }
-
-    @Override
-    public <R, P> R accept(ElementVisitor<R, P> elementVisitor, P p) {
-        return fieldReference.accept(elementVisitor, p);
-    }
-
-    @Override
-    public String toString() {
-        // Mimics the behaviour of the standard implementation of VariableElement `toString()`
-        // Some methods in RealmProxyClassGenerator depended on this.
-        return getSimpleName().toString();
-    }
-
-    public String getJavaName() {
-        return getSimpleName().toString();
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.kt
new file mode 100644
index 0000000000..87ee7f7a32
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmFieldElement.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor
+
+import javax.lang.model.element.AnnotationMirror
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ElementVisitor
+import javax.lang.model.element.Modifier
+import javax.lang.model.element.Name
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.TypeMirror
+
+/**
+ * Wrapper for [javax.lang.model.element.VariableElement] that makes it possible to add
+ * additional metadata.
+ */
+class RealmFieldElement(val fieldReference: VariableElement,
+                        /**
+                         * Returns the name that Realm Core uses internally when saving data to this field.
+                         * [RealmFieldElement.getSimpleName] returns the name in the Java class.
+                         */
+                        val internalFieldName: String // Name used for this field internally in Realm.
+) : VariableElement {
+
+    val javaName: String
+        get() = simpleName.toString()
+
+    override fun getModifiers(): Set<Modifier> {
+        return fieldReference.modifiers
+    }
+
+    override fun asType(): TypeMirror {
+        return fieldReference.asType()
+    }
+
+    override fun getKind(): ElementKind? {
+        return null
+    }
+
+    override fun getConstantValue(): Any {
+        return fieldReference.constantValue
+    }
+
+    /**
+     * Returns the name for this field in the Java class.
+     * [RealmFieldElement.internalFieldName] returns the name used by Realm Core for the same field.
+     */
+    override fun getSimpleName(): Name {
+        return fieldReference.simpleName
+    }
+
+    override fun getEnclosingElement(): Element {
+        return fieldReference.enclosingElement
+    }
+
+    override fun getEnclosedElements(): List<Element> {
+        return fieldReference.enclosedElements
+    }
+
+    override fun getAnnotationMirrors(): List<AnnotationMirror> {
+        return fieldReference.annotationMirrors
+    }
+
+    override fun <A : Annotation> getAnnotation(aClass: Class<A>): A? {
+        return fieldReference.getAnnotation(aClass)
+    }
+
+    override fun <A : Annotation> getAnnotationsByType(aClass: Class<A>): Array<A> {
+        return fieldReference.getAnnotationsByType(aClass)
+    }
+
+    override fun <R, P> accept(elementVisitor: ElementVisitor<R, P>, p: P): R {
+        return fieldReference.accept(elementVisitor, p)
+    }
+
+    override fun toString(): String {
+        // Mimics the behaviour of the standard implementation of VariableElement `toString()`
+        // Some methods in RealmProxyClassGenerator depended on this.
+        return simpleName.toString()
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
deleted file mode 100644
index dcaa1fd63b..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-
-
-/**
- * Helper class for converting between Json types and data types in Java that are supported by Realm.
- */
-public class RealmJsonTypeHelper {
-    private static final Map<String, JsonToRealmFieldTypeConverter> JAVA_TO_JSON_TYPES;
-
-    static {
-        Map<String, JsonToRealmFieldTypeConverter> m = new HashMap<String, JsonToRealmFieldTypeConverter>();
-        m.put("byte", new SimpleTypeConverter("byte", "Int"));
-        m.put("short", new SimpleTypeConverter("short", "Int"));
-        m.put("int", new SimpleTypeConverter("int", "Int"));
-        m.put("long", new SimpleTypeConverter("long", "Long"));
-        m.put("float", new SimpleTypeConverter("float", "Double"));
-        m.put("double", new SimpleTypeConverter("double", "Double"));
-        m.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        m.put("byte[]", new ByteArrayTypeConverter());
-        m.put("java.lang.Byte", m.get("byte"));
-        m.put("java.lang.Short", m.get("short"));
-        m.put("java.lang.Integer", m.get("int"));
-        m.put("java.lang.Long", m.get("long"));
-        m.put("java.lang.Float", m.get("float"));
-        m.put("java.lang.Double", m.get("double"));
-        m.put("java.lang.Boolean", m.get("boolean"));
-        m.put("java.lang.String", new SimpleTypeConverter("String", "String"));
-        m.put("java.util.Date", new DateTypeConverter());
-        m.put("io.realm.MutableRealmInteger", new MutableRealmIntegerTypeConverter());
-        JAVA_TO_JSON_TYPES = Collections.unmodifiableMap(m);
-    }
-
-    // Static helper class
-    private RealmJsonTypeHelper() { }
-
-    // @formatter:off
-    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
-            throws IOException {
-        writer
-            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
-            .endControlFlow();
-    }
-    // @formatter:on
-
-    public static void emitCreateObjectWithPrimaryKeyValue(
-            String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String qualifiedFieldType, String fieldName, JavaWriter writer)
-            throws IOException {
-        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(
-                    qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
-        }
-    }
-
-    // @formatter:off
-    public static void emitFillRealmObjectWithJsonValue(
-            String varName, String setter, String fieldName, String qualifiedFieldType, String proxyClass, JavaWriter writer)
-            throws IOException {
-        writer
-            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("%s.%s(null)", varName, setter)
-                .nextControlFlow("else")
-                    .emitStatement(
-                        "%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
-                        qualifiedFieldType, fieldName, proxyClass, fieldName)
-                    .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
-                .endControlFlow()
-            .endControlFlow();
-    }
-    // @formatter:on
-
-    // @formatter:off
-    public static void emitFillRealmListWithJsonValue(
-            String varName, String getter, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
-            throws IOException {
-        writer
-            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("%s.%s(null)", varName, setter)
-                .nextControlFlow("else")
-                    .emitStatement("%s.%s().clear()", varName, getter)
-                    .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
-                    .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                        .emitStatement(
-                                "%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
-                                fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
-                        .emitStatement("%s.%s().add(item)", varName, getter)
-                    .endControlFlow()
-                .endControlFlow()
-            .endControlFlow();
-    }
-    // @formatter:on
-
-    public static void emitFillJavaTypeWithJsonValue(
-            String varName, String accessor, String fieldName, String qualifiedFieldType, JavaWriter writer)
-            throws IOException {
-        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitTypeConversion(varName, accessor, fieldName, qualifiedFieldType, writer);
-        }
-    }
-
-    // @formatter:off
-    public static void emitFillRealmObjectFromStream(
-            String varName, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
-            throws IOException {
-        writer
-            .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                .emitStatement("reader.skipValue()")
-                .emitStatement("%s.%s(null)", varName, setter)
-            .nextControlFlow("else")
-                .emitStatement(
-                        "%s %sObj = %s.createUsingJsonStream(realm, reader)",
-                        fieldTypeCanonicalName, fieldName, proxyClass)
-                .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
-            .endControlFlow();
-    }
-    // @formatter:on
-
-    // @formatter:off
-    public static void emitFillRealmListFromStream(
-            String varName, String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
-            throws IOException {
-        writer
-            .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                .emitStatement("reader.skipValue()")
-                .emitStatement("%s.%s(null)", varName, setter)
-            .nextControlFlow("else")
-                .emitStatement("%s.%s(new RealmList<%s>())", varName, setter, fieldTypeCanonicalName)
-                .emitStatement("reader.beginArray()")
-                .beginControlFlow("while (reader.hasNext())")
-                    .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
-                    .emitStatement("%s.%s().add(item)", varName, getter)
-                .endControlFlow()
-                .emitStatement("reader.endArray()")
-            .endControlFlow();
-    }
-    // @formatter:on
-
-    public static void emitFillJavaTypeFromStream(
-            String varName, ClassMetaData metaData, String accessor, String fieldName, String fieldType, JavaWriter writer)
-            throws IOException {
-        boolean isPrimaryKey = metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName);
-        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(fieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitStreamTypeConversion(varName, accessor, fieldName, fieldType, writer, isPrimaryKey);
-        }
-    }
-
-    private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
-        private final String castType;
-        private final String jsonType;
-
-        /**
-         * Creates a conversion between simple types which can be expressed as RealmObject.setFieldName((<castType>)
-         * json.get<jsonType>) or RealmObject.setFieldName((<castType>) reader.next<jsonType>
-         *
-         * @param castType Java type to cast to.
-         * @param jsonType JsonType to get data from.
-         */
-        private SimpleTypeConverter(String castType, String jsonType) {
-            this.castType = castType;
-            this.jsonType = jsonType;
-        }
-
-        @Override
-        public void emitTypeConversion(
-                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
-                throws IOException {
-            // Only throw exception for primitive types.
-            // For boxed types and String, exception will be thrown in the setter.
-            String statementSetNullOrThrow = Utils.isPrimitiveType(fieldType) ?
-                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format(Locale.US, "%s.%s(null)", varName, accessor);
-
-            // @formatter:off
-            writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement(statementSetNullOrThrow)
-                    .nextControlFlow("else")
-                        .emitStatement("%s.%s((%s) json.get%s(\"%s\"))", varName, accessor, castType, jsonType, fieldName)
-                    .endControlFlow()
-                .endControlFlow();
-            // @formatter:on
-        }
-
-        @Override
-        public void emitStreamTypeConversion(
-                String varName, String setter, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
-                throws IOException {
-            // Only throw exception for primitive types.
-            // For boxed types and String, exception will be thrown in the setter.
-            String statementSetNullOrThrow = (Utils.isPrimitiveType(fieldType)) ?
-                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
-                    String.format(Locale.US, "%s.%s(null)", varName, setter);
-
-            // @formatter:off
-            writer
-                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
-                    .emitStatement("%s.%s((%s) reader.next%s())", varName, setter, castType, jsonType)
-                .nextControlFlow("else")
-                    .emitStatement("reader.skipValue()")
-                    .emitStatement(statementSetNullOrThrow)
-                .endControlFlow();
-            // @formatter:on
-
-            if (isPrimaryKey) {
-                writer.emitStatement("jsonHasPrimaryKey = true");
-            }
-        }
-
-        // @formatter:off
-        @Override
-        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-            String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-            // No error checking is done here for valid primary key types.
-            // This should be done by the annotation processor.
-            writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, null, true, excludeFields)",
-                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
-                    .nextControlFlow("else")
-                        .emitStatement(
-                                "obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
-                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
-                    .endControlFlow()
-                .nextControlFlow("else")
-                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
-                .endControlFlow();
-        }
-        // @formatter:on
-    }
-
-    private static class ByteArrayTypeConverter implements JsonToRealmFieldTypeConverter {
-        // @formatter:off
-        @Override
-        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
-                throws IOException {
-            writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("%s.%s(null)", varName, accessor)
-                    .nextControlFlow("else")
-                        .emitStatement("%s.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", varName, accessor, fieldName)
-                    .endControlFlow()
-                .endControlFlow();
-        }
-        // @formatter:on
-
-        // @formatter:off
-        @Override
-        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
-                throws IOException {
-            writer
-                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
-                    .emitStatement("%s.%s(JsonUtils.stringToBytes(reader.nextString()))", varName, accessor)
-                .nextControlFlow("else")
-                    .emitStatement("reader.skipValue()")
-                    .emitStatement("%s.%s(null)", varName, accessor)
-                .endControlFlow();
-        }
-        // @formatter:on
-
-        @Override
-        public void emitGetObjectWithPrimaryKeyValue(
-                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
-                throws IOException {
-            throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
-        }
-    }
-
-    private static class DateTypeConverter implements JsonToRealmFieldTypeConverter {
-        // @formatter:off
-        @Override
-        public void emitTypeConversion(
-                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
-                throws IOException {
-            writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("%s.%s(null)", varName, accessor)
-                    .nextControlFlow("else")
-                        .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
-                        .beginControlFlow("if (timestamp instanceof String)")
-                            .emitStatement("%s.%s(JsonUtils.stringToDate((String) timestamp))", varName, accessor)
-                        .nextControlFlow("else")
-                            .emitStatement("%s.%s(new Date(json.getLong(\"%s\")))", varName, accessor, fieldName)
-                        .endControlFlow()
-                    .endControlFlow()
-                .endControlFlow();
-        }
-        // @formatter:on
-
-        // @formatter:off
-        @Override
-        public void emitStreamTypeConversion(
-                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
-                throws IOException {
-            writer
-                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                    .emitStatement("reader.skipValue()")
-                    .emitStatement("%s.%s(null)", varName, accessor)
-                .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
-                    .emitStatement("long timestamp = reader.nextLong()", fieldName)
-                    .beginControlFlow("if (timestamp > -1)")
-                        .emitStatement("%s.%s(new Date(timestamp))", varName, accessor)
-                    .endControlFlow()
-                .nextControlFlow("else")
-                    .emitStatement("%s.%s(JsonUtils.stringToDate(reader.nextString()))", varName, accessor)
-                .endControlFlow();
-        }
-        // @formatter:on
-
-        @Override
-        public void emitGetObjectWithPrimaryKeyValue(
-                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
-                throws IOException {
-            throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
-        }
-    }
-
-    private static class MutableRealmIntegerTypeConverter implements JsonToRealmFieldTypeConverter {
-        // @formatter:off
-        @Override
-        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
-                throws IOException {
-            writer
-                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                    .emitStatement("%1$s.%2$s().set((json.isNull(\"%3$s\")) ? null : json.getLong(\"%3$s\"))", varName, accessor, fieldName)
-                .endControlFlow();
-        }
-        // @formatter:on
-
-        // @formatter:off
-        @Override
-        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
-                throws IOException {
-            writer
-                .emitStatement("Long val = null")
-                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
-                    .emitStatement("val = reader.nextLong()")
-                .nextControlFlow("else")
-                    .emitStatement("reader.skipValue()")
-                .endControlFlow()
-                .emitStatement("%1$s.%2$s().set(val)", varName, accessor);
-        }
-        // @formatter:on
-
-        @Override
-        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
-                throws IOException {
-            throw new IllegalArgumentException("'MutableRealmInteger' is not allowed as a primary key value.");
-        }
-    }
-
-    private interface JsonToRealmFieldTypeConverter {
-        void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
-                throws IOException;
-
-        void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
-                throws IOException;
-
-        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
-                throws IOException;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.kt
new file mode 100644
index 0000000000..3bdebfa9a9
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.kt
@@ -0,0 +1,372 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import com.squareup.javawriter.JavaWriter
+
+import java.io.IOException
+import java.util.Collections
+import java.util.HashMap
+import java.util.Locale
+
+
+/**
+ * Helper class for converting between Json types and data types in Java that are supported by Realm.
+ */
+object RealmJsonTypeHelper {
+    private val JAVA_TO_JSON_TYPES: Map<QualifiedClassName, JsonToRealmFieldTypeConverter>
+
+    init {
+        val m = HashMap<QualifiedClassName, JsonToRealmFieldTypeConverter>()
+        m[QualifiedClassName("byte")] = SimpleTypeConverter("byte", "Int")
+        m[QualifiedClassName("short")] = SimpleTypeConverter("short", "Int")
+        m[QualifiedClassName("int")] = SimpleTypeConverter("int", "Int")
+        m[QualifiedClassName("long")] = SimpleTypeConverter("long", "Long")
+        m[QualifiedClassName("float")] = SimpleTypeConverter("float", "Double")
+        m[QualifiedClassName("double")] = SimpleTypeConverter("double", "Double")
+        m[QualifiedClassName("boolean")] = SimpleTypeConverter("boolean", "Boolean")
+        m[QualifiedClassName("byte[]")] = ByteArrayTypeConverter()
+        m[QualifiedClassName("java.lang.Byte")] = m[QualifiedClassName("byte")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Short")] = m[QualifiedClassName("short")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Integer")] = m[QualifiedClassName("int")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Long")] = m[QualifiedClassName("long")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Float")] = m[QualifiedClassName("float")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Double")] = m[QualifiedClassName("double")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.Boolean")] = m[QualifiedClassName("boolean")] as JsonToRealmFieldTypeConverter
+        m[QualifiedClassName("java.lang.String")] = SimpleTypeConverter("String", "String")
+        m[QualifiedClassName("java.util.Date")] = DateTypeConverter()
+        m[QualifiedClassName("io.realm.MutableRealmInteger")] = MutableRealmIntegerTypeConverter()
+        JAVA_TO_JSON_TYPES = Collections.unmodifiableMap(m)
+    }
+
+    @Throws(IOException::class)
+    fun emitIllegalJsonValueException(fieldType: String, fieldName: String, writer: JavaWriter) {
+        writer.apply {
+            beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
+            endControlFlow()
+        }
+    }
+
+    @Throws(IOException::class)
+    fun emitCreateObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName,
+                                            realmObjectProxyClass: QualifiedClassName,
+                                            fieldType: QualifiedClassName,
+                                            fieldName: String,
+                                            writer: JavaWriter) {
+        val typeEmitter = JAVA_TO_JSON_TYPES[fieldType]
+        typeEmitter?.emitGetObjectWithPrimaryKeyValue(realmObjectClass, realmObjectProxyClass, fieldName, writer)
+    }
+
+    @Throws(IOException::class)
+    fun emitFillRealmObjectWithJsonValue(varName: String,
+                                         setter: String,
+                                         fieldName: String,
+                                         qualifiedFieldType: QualifiedClassName,
+                                         proxyClass: SimpleClassName,
+                                         writer: JavaWriter) {
+        writer.apply {
+            beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                    emitStatement("%s.%s(null)", varName, setter)
+                nextControlFlow("else")
+                    emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)", qualifiedFieldType, fieldName, proxyClass, fieldName)
+                    emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
+                endControlFlow()
+            endControlFlow()
+        }
+    }
+
+    @Throws(IOException::class)
+    fun emitFillRealmListWithJsonValue(varName: String,
+                                       getter: String,
+                                       setter: String,
+                                       fieldName: String,
+                                       fieldTypeCanonicalName: String,
+                                       proxyClass: SimpleClassName,
+                                       writer: JavaWriter) {
+        writer.apply {
+            beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                    emitStatement("%s.%s(null)", varName, setter)
+                nextControlFlow("else")
+                    emitStatement("%s.%s().clear()", varName, getter)
+                    emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
+                    beginControlFlow("for (int i = 0; i < array.length(); i++)")
+                        emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)", fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
+                        emitStatement("%s.%s().add(item)", varName, getter)
+                    endControlFlow()
+                endControlFlow()
+            endControlFlow()
+        }
+    }
+
+    @Throws(IOException::class)
+    fun emitFillJavaTypeWithJsonValue(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter) {
+        val typeEmitter = JAVA_TO_JSON_TYPES[fieldType]
+        typeEmitter?.emitTypeConversion(varName, accessor, fieldName, fieldType, writer)
+    }
+
+    @Throws(IOException::class)
+    fun emitFillRealmObjectFromStream(varName: String,
+                                      setter: String,
+                                      fieldName: String,
+                                      fieldType: QualifiedClassName,
+                                      proxyClass: SimpleClassName,
+                                      writer: JavaWriter) {
+        writer.apply {
+            beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                emitStatement("reader.skipValue()")
+                emitStatement("%s.%s(null)", varName, setter)
+            nextControlFlow("else")
+                emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldType, fieldName, proxyClass)
+                emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
+            endControlFlow()
+        }
+    }
+
+    @Throws(IOException::class)
+    fun emitFillRealmListFromStream(varName: String,
+                                    getter: String,
+                                    setter: String,
+                                    fieldType: QualifiedClassName,
+                                    proxyClass: SimpleClassName,
+                                    writer: JavaWriter) {
+        writer.apply {
+            beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                emitStatement("reader.skipValue()")
+                emitStatement("%s.%s(null)", varName, setter)
+            nextControlFlow("else")
+                emitStatement("%s.%s(new RealmList<%s>())", varName, setter, fieldType)
+                emitStatement("reader.beginArray()")
+                beginControlFlow("while (reader.hasNext())")
+                    emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldType, proxyClass)
+                    emitStatement("%s.%s().add(item)", varName, getter)
+                endControlFlow()
+                emitStatement("reader.endArray()")
+            endControlFlow()
+        }
+    }
+
+    @Throws(IOException::class)
+    fun emitFillJavaTypeFromStream(varName: String,
+                                   metaData: ClassMetaData,
+                                   accessor: String,
+                                   fieldName: String,
+                                   fieldType: QualifiedClassName,
+                                   writer: JavaWriter) {
+        val isPrimaryKey = metaData.hasPrimaryKey() && metaData.primaryKey!!.simpleName.toString() == fieldName
+        val typeEmitter = JAVA_TO_JSON_TYPES[fieldType]
+        typeEmitter?.emitStreamTypeConversion(varName, accessor, fieldName, fieldType, writer, isPrimaryKey)
+    }
+
+    /**
+     * Creates a conversion between simple types which can be expressed as RealmObject.setFieldName((<castType>)
+     * json.get<jsonType>) or RealmObject.setFieldName((<castType>) reader.next<jsonType>
+     *
+     * @param castType Java type to cast to.
+     * @param jsonType JsonType to get data from.
+     */
+    private class SimpleTypeConverter(private val castType: String, private val jsonType: String) : JsonToRealmFieldTypeConverter {
+
+        @Throws(IOException::class)
+        override fun emitTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter) {
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
+            val statementSetNullOrThrow = if (Utils.isPrimitiveType(fieldType))
+                String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+            else
+                String.format(Locale.US, "%s.%s(null)", varName, accessor)
+
+            writer.apply {
+                beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        emitStatement(statementSetNullOrThrow)
+                    nextControlFlow("else")
+                        emitStatement("%s.%s((%s) json.get%s(\"%s\"))", varName, accessor, castType, jsonType, fieldName)
+                    endControlFlow()
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitStreamTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter, isPrimaryKey: Boolean) {
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
+            val statementSetNullOrThrow = if (Utils.isPrimitiveType(fieldType))
+                String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+            else
+                String.format(Locale.US, "%s.%s(null)", varName, accessor)
+
+            writer.apply {
+                beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    emitStatement("%s.%s((%s) reader.next%s())", varName, accessor, castType, jsonType)
+                nextControlFlow("else")
+                    emitStatement("reader.skipValue()")
+                    emitStatement(statementSetNullOrThrow)
+                endControlFlow()
+
+                if (isPrimaryKey) {
+                    emitStatement("jsonHasPrimaryKey = true")
+                }
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitGetObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName, realmObjectProxyClass: QualifiedClassName, fieldName: String, writer: JavaWriter) {
+            // No error checking is done here for valid primary key types.
+            // This should be done by the annotation processor.
+            writer.apply {
+                beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        emitStatement("obj = (%1\$s) realm.createObjectInternal(%2\$s.class, null, true, excludeFields)", realmObjectProxyClass, realmObjectClass)
+                    nextControlFlow("else")
+                        emitStatement("obj = (%1\$s) realm.createObjectInternal(%2\$s.class, json.get%3\$s(\"%4\$s\"), true, excludeFields)", realmObjectProxyClass, realmObjectClass, jsonType, fieldName)
+                    endControlFlow()
+                nextControlFlow("else")
+                    emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
+                endControlFlow()
+            }
+        }
+    }
+
+    private class ByteArrayTypeConverter : JsonToRealmFieldTypeConverter {
+        @Throws(IOException::class)
+        override fun emitTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter) {
+            writer.apply {
+                beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        emitStatement("%s.%s(null)", varName, accessor)
+                    nextControlFlow("else")
+                        emitStatement("%s.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", varName, accessor, fieldName)
+                    endControlFlow()
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitStreamTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter, isPrimaryKey: Boolean) {
+            writer.apply {
+                beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    emitStatement("%s.%s(JsonUtils.stringToBytes(reader.nextString()))", varName, accessor)
+                nextControlFlow("else")
+                    emitStatement("reader.skipValue()")
+                    emitStatement("%s.%s(null)", varName, accessor)
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitGetObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName, realmObjectProxyClass: QualifiedClassName, fieldName: String, writer: JavaWriter) {
+            throw IllegalArgumentException("'byte[]' is not allowed as a primary key value.")
+        }
+    }
+
+    private class DateTypeConverter : JsonToRealmFieldTypeConverter {
+        @Throws(IOException::class)
+        override fun emitTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter) {
+            writer.apply {
+                beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        emitStatement("%s.%s(null)", varName, accessor)
+                    nextControlFlow("else")
+                        emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
+                        beginControlFlow("if (timestamp instanceof String)")
+                            emitStatement("%s.%s(JsonUtils.stringToDate((String) timestamp))", varName, accessor)
+                        nextControlFlow("else")
+                            emitStatement("%s.%s(new Date(json.getLong(\"%s\")))", varName, accessor, fieldName)
+                        endControlFlow()
+                    endControlFlow()
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitStreamTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter, isPrimaryKey: Boolean) {
+            writer.apply {
+                beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                    emitStatement("reader.skipValue()")
+                    emitStatement("%s.%s(null)", varName, accessor)
+                nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
+                    emitStatement("long timestamp = reader.nextLong()", fieldName)
+                    beginControlFlow("if (timestamp > -1)")
+                        emitStatement("%s.%s(new Date(timestamp))", varName, accessor)
+                    endControlFlow()
+                nextControlFlow("else")
+                    emitStatement("%s.%s(JsonUtils.stringToDate(reader.nextString()))", varName, accessor)
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitGetObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName, realmObjectProxyClass: QualifiedClassName, fieldName: String, writer: JavaWriter) {
+            throw IllegalArgumentException("'Date' is not allowed as a primary key value.")
+        }
+    }
+
+    private class MutableRealmIntegerTypeConverter : JsonToRealmFieldTypeConverter {
+        @Throws(IOException::class)
+        override fun emitTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter) {
+            writer.apply {
+                beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    emitStatement("%1\$s.%2\$s().set((json.isNull(\"%3\$s\")) ? null : json.getLong(\"%3\$s\"))", varName, accessor, fieldName)
+                endControlFlow()
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitStreamTypeConversion(varName: String, accessor: String, fieldName: String, fieldType: QualifiedClassName, writer: JavaWriter, isPrimaryKey: Boolean) {
+            writer.apply {
+                emitStatement("Long val = null")
+                beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    emitStatement("val = reader.nextLong()")
+                nextControlFlow("else")
+                    emitStatement("reader.skipValue()")
+                endControlFlow()
+                emitStatement("%1\$s.%2\$s().set(val)", varName, accessor)
+            }
+        }
+
+        @Throws(IOException::class)
+        override fun emitGetObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName, realmObjectProxyClass: QualifiedClassName, fieldName: String, writer: JavaWriter) {
+            throw IllegalArgumentException("'MutableRealmInteger' is not allowed as a primary key value.")
+        }
+    }
+
+    private interface JsonToRealmFieldTypeConverter {
+        @Throws(IOException::class)
+        fun emitTypeConversion(varName: String,
+                               accessor: String,
+                               fieldName: String,
+                               fieldType: QualifiedClassName,
+                               writer: JavaWriter)
+
+        @Throws(IOException::class)
+        fun emitStreamTypeConversion(varName: String,
+                                     accessor: String,
+                                     fieldName: String,
+                                     fieldType: QualifiedClassName,
+                                     writer: JavaWriter,
+                                     isPrimaryKey: Boolean)
+
+        @Throws(IOException::class)
+        fun emitGetObjectWithPrimaryKeyValue(realmObjectClass: QualifiedClassName,
+                                             realmObjectProxyClass: QualifiedClassName,
+                                             fieldName: String,
+                                             writer: JavaWriter)
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
deleted file mode 100644
index 9edeea9902..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedOptions;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.TypeElement;
-
-import io.realm.annotations.RealmClass;
-import io.realm.annotations.RealmModule;
-
-
-/**
- * The RealmProcessor is responsible for creating the plumbing that connects the RealmObjects to a Realm. The process
- * for doing so is summarized below and then described in more detail.
- * <p>
- * <p>
- * <h1>DESIGN GOALS</h1>
- * <p>
- * The processor should support the following design goals:
- * <ul>
- * <li>Minimize reflection.</li>
- * <li>Realm code can be obfuscated as much as possible.</li>
- * <li>Library projects must be able to use Realm without interfering with app code.</li>
- * <li>App code must be able to use RealmObject classes provided by library code.</li>
- * <li>It should work for app developers out of the box (ie. put the burden on the library developer)</li>
- * </ul>
- * <p>
- * <h1>SUMMARY</h1>
- * <p>
- * <ol>
- * <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;className&gt;RealmProxy.java</li>
- * <li>Create a DefaultRealmModule containing all RealmObject classes (if needed).</li>
- * <li>Create a RealmProxyMediator class for all classes marked with {@code @RealmModule}. They are named {@code <moduleName>Mediator.java}</li>
- * </ol>
- * <p>
- * <h1>WHY</h1>
- * <p>
- * <ol>
- * <li>A RealmObjectProxy object is created for each class annotated with {@link io.realm.annotations.RealmClass}. This
- * proxy extends the original RealmObject class and rewires all field access to point to the native Realm memory instead of
- * Java memory. It also adds some static helper methods to the class.</li>
- * <li>The annotation processor is either in "library" mode or in "app" mode. This is defined by having a class
- * annotated with @RealmModule(library = true). It is not allowed to have both a class with library = true and
- * library = false in the same IntelliJ module and it will cause the annotation processor to throw an exception. If no
- * library modules are defined, we will create a DefaultRealmModule containing all known RealmObjects and with the
- * {@code @RealmModule} annotation. Realm automatically knows about this module, but it is still possible for users to create
- * their own modules with a subset of model classes.</li>
- * <li>For each class annotated with @RealmModule a matching Mediator class is created (including the default one). This
- * class has an interface that matches the static helper methods for the proxy classes. All access to these static
- * helper methods should be done through this Mediator.</li>
- * </ol>
- * <p>
- * This allows ProGuard to obfuscate all RealmObject and proxy classes as all access to the static methods now happens through
- * the Mediator, and the only requirement is now that only RealmModule and Mediator class names cannot be obfuscated.
- * <p>
- * <p>
- * <h1>CREATING A REALM</h1>
- * <p>
- * This means the workflow when instantiating a Realm on runtime is the following:
- * <p>
- * <ol>
- * <li>Open a Realm.</li>
- * <li>Assign one or more modules (that are allowed to overlap). If no module is assigned, the default module is used.</li>
- * <li>The Realm schema is now defined as all RealmObject classes known by these modules.</li>
- * <li>Each time a static helper method is needed, Realm can now delegate these method calls to the appropriate
- * Mediator which in turn will delegate the method call to the appropriate RealmObjectProxy class.</li>
- * </ol>
- * <p>
- * <h1>CREATING A MANAGED RealmObject</h1>
- * <p>
- * To allow to specify default values by model's constructor or direct field assignment,
- * the flow of creating the proxy object is a bit complicated. This section illustrates
- * how proxy object should be created.
- * <p>
- * <ol>
- * <li>Get the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by {@code BaseRealm.objectContext.get()} </li>
- * <li>Set the object context information to the {@code RealmObjectContext} those should be set to the creating proxy object.</li>
- * <li>Create proxy object ({@code new io.realm.FooRealmProxy()}).</li>
- * <li>Set the object context information to the created proxy when the first access of its accessors (or in its constructor if accessors are not used in the model's constructor).</li>
- * <li>Clear the object context information in the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by calling {@code
- * #clear()} method.</li>
- * </ol>
- * <p>
- * The reason of this complicated step is that we can't pass these context information
- * via the constructor of the proxy. It's because the constructor of the proxy is executed
- * <b>after</b> the constructor of the model class. The access to the fields in the model's
- * constructor happens before the assignment of the context information to the 'proxyState'.
- * This will cause the {@link NullPointerException} if getters/setter is accessed in the model's
- * constructor (see https://github.com/realm/realm-java/issues/2536 ).
- */
-@SupportedAnnotationTypes({
-        "io.realm.annotations.RealmClass",
-        "io.realm.annotations.RealmField",
-        "io.realm.annotations.Ignore",
-        "io.realm.annotations.Index",
-        "io.realm.annotations.PrimaryKey",
-        "io.realm.annotations.RealmModule",
-        "io.realm.annotations.Required"
-})
-@SupportedOptions(value = {"realm.suppressWarnings", "realm.ignoreKotlinNullability"})
-public class RealmProcessor extends AbstractProcessor {
-
-    // Don't consume annotations. This allows 3rd party annotation processors to run.
-    private static final boolean CONSUME_ANNOTATIONS = false;
-    private static final boolean ABORT = true; // Abort the annotation processor by consuming all annotations
-
-    private final ClassCollection classCollection = new ClassCollection(); // Metadata for all classes found
-    private ModuleMetaData moduleMetaData; // Metadata for all modules found
-
-    // List of backlinks
-    private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
-
-    private boolean hasProcessedModules = false;
-    private int round = -1;
-
-    @Override
-    public SourceVersion getSupportedSourceVersion() {
-        return SourceVersion.latestSupported();
-    }
-
-    @Override
-    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-        round++;
-
-        if (round == 0) {
-            RealmVersionChecker.getInstance(processingEnv).executeRealmVersionUpdate();
-        }
-
-        if (roundEnv.errorRaised()) { return ABORT; }
-
-        if (!hasProcessedModules) {
-            Utils.initialize(processingEnv);
-            TypeMirrors typeMirrors = new TypeMirrors(processingEnv);
-
-            // Build up internal metadata while validating as much as possible
-            if (!preProcessModules(roundEnv)) { return ABORT; }
-            if (!processClassAnnotations(roundEnv, typeMirrors)) { return ABORT; }
-            if (!postProcessModules()) { return ABORT; }
-            if (!validateBacklinks()) { return ABORT; }
-            hasProcessedModules = true;
-
-            // Create all files
-            if (!createProxyClassFiles(typeMirrors)) { return ABORT; }
-            if (!createModuleFiles(roundEnv)) { return ABORT; }
-        }
-
-        return CONSUME_ANNOTATIONS;
-    }
-
-    // Create all proxy classes
-    private boolean processClassAnnotations(RoundEnvironment roundEnv, TypeMirrors typeMirrors) {
-
-        for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
-
-            // The class must either extend RealmObject or implement RealmModel
-            if (!Utils.isImplementingMarkerInterface(classElement)) {
-                Utils.error("A RealmClass annotated object must implement RealmModel or derive from RealmObject.", classElement);
-                return false;
-            }
-
-            // Check the annotation was applied to a Class
-            if (!classElement.getKind().equals(ElementKind.CLASS)) {
-                Utils.error("The RealmClass annotation can only be applied to classes.", classElement);
-                return false;
-            }
-
-            ClassMetaData metadata = new ClassMetaData(processingEnv, typeMirrors, (TypeElement) classElement);
-            if (!metadata.isModelClass()) { continue; }
-
-            Utils.note("Processing class " + metadata.getSimpleJavaClassName());
-            if (!metadata.generate(moduleMetaData)) { return false; }
-
-            classCollection.addClass(metadata);
-            backlinksToValidate.addAll(metadata.getBacklinkFields());
-        }
-
-        return true;
-    }
-
-    // Returns true if modules were processed successfully, false otherwise
-    private boolean preProcessModules(RoundEnvironment roundEnv) {
-        moduleMetaData = new ModuleMetaData();
-        return moduleMetaData.preProcess(roundEnv.getElementsAnnotatedWith(RealmModule.class));
-    }
-
-    // Returns true of modules where successfully validated, false otherwise
-    private boolean postProcessModules() {
-        return moduleMetaData.postProcess(classCollection);
-    }
-
-    private boolean createModuleFiles(RoundEnvironment roundEnv) {
-        // Create default module if needed
-        if (moduleMetaData.shouldCreateDefaultModule()) {
-            if (!createDefaultModule()) {
-                return false;
-            }
-        }
-
-        // Create RealmProxyMediators for all Realm modules
-        for (Map.Entry<String, Set<ClassMetaData>> module : moduleMetaData.getAllModules().entrySet()) {
-            if (!createMediator(Utils.stripPackage(module.getKey()), module.getValue())) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private boolean createProxyClassFiles(TypeMirrors typeMirrors) {
-        for (ClassMetaData metadata : classCollection.getClasses()) {
-            RealmProxyInterfaceGenerator interfaceGenerator = new RealmProxyInterfaceGenerator(processingEnv, metadata);
-            try {
-                interfaceGenerator.generate();
-            } catch (IOException e) {
-                Utils.error(e.getMessage(), metadata.getClassElement());
-                return false;
-            }
-
-            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, typeMirrors, metadata, classCollection);
-            try {
-                sourceCodeGenerator.generate();
-            } catch (IOException | UnsupportedOperationException e) {
-                Utils.error(e.getMessage(), metadata.getClassElement());
-                return false;
-            }
-        }
-        return true;
-    }
-
-    private boolean createDefaultModule() {
-        Utils.note("Creating DefaultRealmModule");
-        DefaultModuleGenerator defaultModuleGenerator = new DefaultModuleGenerator(processingEnv);
-        try {
-            defaultModuleGenerator.generate();
-        } catch (IOException e) {
-            Utils.error(e.getMessage());
-            return false;
-        }
-
-        return true;
-    }
-
-    private boolean createMediator(String simpleModuleName, Set<ClassMetaData> moduleClasses) {
-        RealmProxyMediatorGenerator mediatorImplGenerator = new RealmProxyMediatorGenerator(processingEnv,
-                simpleModuleName, moduleClasses);
-        try {
-            mediatorImplGenerator.generate();
-        } catch (IOException e) {
-            Utils.error(e.getMessage());
-            return false;
-        }
-
-        return true;
-    }
-
-    // Because library classes are processed separately, there is no guarantee
-    // that this method can see all of the classes necessary to completely validate
-    // all of the backlinks.  If it can find the fully-qualified class, though,
-    // and prove that the class either does not contain the necessary field, or
-    // that it does contain the field, but the field is of the wrong type, it can
-    // catch the error at compile time.
-    // Give all failure messages before failing
-    private boolean validateBacklinks() {
-        boolean allValid = true;
-
-        for (Backlink backlink : backlinksToValidate) {
-            ClassMetaData clazz = classCollection.getClassFromQualifiedName(backlink.getSourceClass());
-
-            // If the class is not here it might be part of some other compilation unit.
-            if (clazz == null) { continue; }
-
-            // If the class is here, we can validate it.
-            if (!backlink.validateTarget(clazz) && allValid) { allValid = false; }
-        }
-
-        return allValid;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.kt
new file mode 100644
index 0000000000..47123ba632
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.kt
@@ -0,0 +1,339 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import java.io.IOException
+import java.util.HashSet
+
+import javax.annotation.processing.AbstractProcessor
+import javax.annotation.processing.RoundEnvironment
+import javax.annotation.processing.SupportedAnnotationTypes
+import javax.annotation.processing.SupportedOptions
+import javax.lang.model.SourceVersion
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.TypeElement
+
+import io.realm.annotations.RealmClass
+import io.realm.annotations.RealmModule
+import javax.lang.model.element.Name
+
+
+/**
+ * The RealmProcessor is responsible for creating the plumbing that connects the RealmObjects to a
+ * Realm. The process for doing so is summarized below and then described in more detail.
+ *
+ * <h1>DESIGN GOALS</h1>
+ *
+ * The processor should support the following design goals:
+ *
+ *  * Minimize reflection.
+ *  * Realm code can be obfuscated as much as possible.
+ *  * Library projects must be able to use Realm without interfering with app code.
+ *  * App code must be able to use RealmObject classes provided by library code.
+ *  * It should work for app developers out of the box (ie. put the burden on the library developer)
+ *
+ * <h1>SUMMARY</h1>
+ *
+ *  1. Create proxy classes for all classes marked with @RealmClass. They are named
+ *     `<className>RealmProxy.java`.
+ *  2. Create a DefaultRealmModule containing all RealmObject classes (if needed).
+ *  3. Create a RealmProxyMediator class for all classes marked with `@RealmModule`. They are named
+ *     `<moduleName>Mediator.java`
+ *
+ * <h1>WHY</h1>
+ *
+ *  1. A RealmObjectProxy object is created for each class annotated with
+ *     [io.realm.annotations.RealmClass]. This proxy extends the original RealmObject class and
+ *     rewires all field access to point to the native Realm memory instead of Java memory. It also
+ *     adds some static helper methods to the class.
+ *
+ *  2. The annotation processor is either in "library" mode or in "app" mode. This is defined by
+ *     having a class annotated with @RealmModule(library = true). It is not allowed to have both a
+ *     class with `library = true` and `library = false` in the same IntelliJ module and it will
+ *     cause the annotation processor to throw an exception. If no library modules are defined, we
+ *     will create a DefaultRealmModule containing all known RealmObjects and with the
+ *     `@RealmModule` annotation. Realm automatically knows about this module, but it is still
+ *     possible for users to create their own modules with a subset of model classes.
+ *
+ *  3. For each class annotated with @RealmModule a matching Mediator class is created (including
+ *     the default one). This class has an interface that matches the static helper methods for the
+ *     proxy classes. All access to these static helper methods should be done through this Mediator.
+ *
+ * This allows ProGuard to obfuscate all RealmObject and proxy classes as all access to the static
+ * methods now happens through the Mediator, and the only requirement is now that only RealmModule
+ * and Mediator class names cannot be obfuscated.
+ *
+ * <h1>CREATING A REALM</h1>
+ *
+ * This means the workflow when instantiating a Realm on runtime is the following:
+ *
+ *  1. Open a Realm.
+ *  2. Assign one or more modules (that are allowed to overlap). If no module is assigned, the
+ *     default module is used.
+ *  3. The Realm schema is now defined as all RealmObject classes known by these modules.
+ *  4. Each time a static helper method is needed, Realm can now delegate these method calls to the
+ *     appropriate Mediator which in turn will delegate the method call to the appropriate
+ *     RealmObjectProxy class.
+ *
+ * <h1>CREATING A MANAGED RealmObject</h1>
+ *
+ * To allow to specify default values by model's constructor or direct field assignment, the flow of
+ * creating the proxy object is a bit complicated. This section illustrates how proxy object should
+ * be created.
+ *
+ *  1. Get the thread local `io.realm.BaseRealm.RealmObjectContext` instance by
+ *     `BaseRealm.objectContext.get()`
+ *  2. Set the object context information to the `RealmObjectContext` those should be set to the
+ *     creating proxy object.
+ *  3. Create proxy object (`new io.realm.FooRealmProxy()`).
+ *  4. Set the object context information to the created proxy when the first access of its
+ *     accessors (or in its constructor if accessors are not used in the model's constructor).
+ *  5. Clear the object context information in the thread local
+ *     `io.realm.BaseRealm.RealmObjectContext` instance by calling `#clear()` method.
+ *
+ * The reason of this complicated step is that we can't pass these context information
+ * via the constructor of the proxy. It's because the constructor of the proxy is executed
+ * **after** the constructor of the model class. The access to the fields in the model's
+ * constructor happens before the assignment of the context information to the 'proxyState'.
+ * This will cause the [NullPointerException] if getters/setter is accessed in the model's
+ * constructor (see [Issue #2536](https://github.com/realm/realm-java/issues/2536)).
+ */
+
+inline class QualifiedClassName(val name: String) {
+    constructor(name: Name): this(name.toString())
+    fun getSimpleName(): SimpleClassName {
+        return SimpleClassName(Utils.stripPackage(name))
+    }
+    override fun toString(): String {
+        return name
+    }
+}
+inline class SimpleClassName(val name: String) {
+    constructor(name: Name): this(name.toString())
+    override fun toString(): String {
+        return name
+    }
+}
+
+@SupportedAnnotationTypes(
+        "io.realm.annotations.RealmClass",
+        "io.realm.annotations.RealmField",
+        "io.realm.annotations.Ignore",
+        "io.realm.annotations.Index",
+        "io.realm.annotations.PrimaryKey",
+        "io.realm.annotations.RealmModule",
+        "io.realm.annotations.Required")
+@SupportedOptions(value = ["realm.suppressWarnings", "realm.ignoreKotlinNullability"])
+class RealmProcessor : AbstractProcessor() {
+
+    // Don't consume annotations. This allows 3rd party annotation processors to run.
+    private val CONSUME_ANNOTATIONS = false
+    private val ABORT = true // Abort the annotation processor by consuming all annotations
+
+    private val classCollection = ClassCollection() // Metadata for all classes found
+    private lateinit var moduleMetaData: ModuleMetaData // Metadata for all modules found
+
+    // List of backlinks
+    private val backlinksToValidate = HashSet<Backlink>()
+
+    private var hasProcessedModules = false
+    private var round = -1
+
+    override fun getSupportedSourceVersion(): SourceVersion {
+        return SourceVersion.latestSupported()
+    }
+
+    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
+        round++
+
+        if (round == 0) {
+            RealmVersionChecker.getInstance(processingEnv).executeRealmVersionUpdate()
+        }
+
+        if (roundEnv.errorRaised()) {
+            return ABORT
+        }
+
+        if (!hasProcessedModules) {
+            Utils.initialize(processingEnv)
+            val typeMirrors = TypeMirrors(processingEnv)
+
+            // Build up internal metadata while validating as much as possible
+            if (!preProcessModules(roundEnv)) {
+                return ABORT
+            }
+            if (!processClassAnnotations(roundEnv, typeMirrors)) {
+                return ABORT
+            }
+            if (!postProcessModules()) {
+                return ABORT
+            }
+            if (!validateBacklinks()) {
+                return ABORT
+            }
+            hasProcessedModules = true
+
+            // Create all files
+            if (!createProxyClassFiles(typeMirrors)) {
+                return ABORT
+            }
+            if (!createModuleFiles()) {
+                return ABORT
+            }
+        }
+
+        return CONSUME_ANNOTATIONS
+    }
+
+    // Create all proxy classes
+    private fun processClassAnnotations(roundEnv: RoundEnvironment, typeMirrors: TypeMirrors): Boolean {
+
+        for (classElement in roundEnv.getElementsAnnotatedWith(RealmClass::class.java)) {
+
+            // The class must either extend RealmObject or implement RealmModel
+            if (!Utils.isImplementingMarkerInterface(classElement)) {
+                Utils.error("A RealmClass annotated object must implement RealmModel or derive from RealmObject.", classElement)
+                return false
+            }
+
+            // Check the annotation was applied to a Class
+            if (classElement.kind != ElementKind.CLASS) {
+                Utils.error("The RealmClass annotation can only be applied to classes.", classElement)
+                return false
+            }
+
+            val metadata = ClassMetaData(processingEnv, typeMirrors, classElement as TypeElement)
+            if (!metadata.isModelClass) {
+                continue
+            }
+
+            Utils.note("Processing class " + metadata.simpleJavaClassName)
+            if (!metadata.generate(moduleMetaData)) {
+                return false
+            }
+
+            classCollection.addClass(metadata)
+            backlinksToValidate.addAll(metadata.backlinkFields)
+        }
+
+        return true
+    }
+
+    // Returns true if modules were processed successfully, false otherwise
+    private fun preProcessModules(roundEnv: RoundEnvironment): Boolean {
+        moduleMetaData = ModuleMetaData()
+        return moduleMetaData.preProcess(roundEnv.getElementsAnnotatedWith(RealmModule::class.java))
+    }
+
+    // Returns true of modules where successfully validated, false otherwise
+    private fun postProcessModules(): Boolean {
+        return moduleMetaData.postProcess(classCollection)
+    }
+
+    private fun createModuleFiles(): Boolean {
+        // Create default module if needed
+        if (moduleMetaData.shouldCreateDefaultModule()) {
+            if (!createDefaultModule()) {
+                return false
+            }
+        }
+
+        // Create RealmProxyMediators for all Realm modules
+        for ((key, value) in moduleMetaData.allModules) {
+            if (!createMediator(key.getSimpleName(), value)) {
+                return false
+            }
+        }
+
+        return true
+    }
+
+    private fun createProxyClassFiles(typeMirrors: TypeMirrors): Boolean {
+        for (metadata in classCollection.classes) {
+            val interfaceGenerator = RealmProxyInterfaceGenerator(processingEnv, metadata)
+            try {
+                interfaceGenerator.generate()
+            } catch (e: IOException) {
+                Utils.error(e.message, metadata.classElement)
+                return false
+            }
+
+            val sourceCodeGenerator = RealmProxyClassGenerator(processingEnv, typeMirrors, metadata, classCollection)
+            try {
+                sourceCodeGenerator.generate()
+            } catch (e: IOException) {
+                Utils.error(e.message, metadata.classElement)
+                return false
+            } catch (e: UnsupportedOperationException) {
+                Utils.error(e.message, metadata.classElement)
+                return false
+            }
+
+        }
+        return true
+    }
+
+    private fun createDefaultModule(): Boolean {
+        Utils.note("Creating DefaultRealmModule")
+        val defaultModuleGenerator = DefaultModuleGenerator(processingEnv)
+        try {
+            defaultModuleGenerator.generate()
+        } catch (e: IOException) {
+            Utils.error(e.message)
+            return false
+        }
+
+        return true
+    }
+
+    private fun createMediator(moduleName: SimpleClassName, moduleClasses: Set<ClassMetaData>): Boolean {
+        val mediatorImplGenerator = RealmProxyMediatorGenerator(processingEnv, moduleName, moduleClasses)
+        try {
+            mediatorImplGenerator.generate()
+        } catch (e: IOException) {
+            Utils.error(e.message)
+            return false
+        }
+
+        return true
+    }
+
+    // Because library classes are processed separately, there is no guarantee that this method can
+    // see all of the classes necessary to completely validate all of the backlinks.  If it can find
+    // the fully-qualified class, though, and prove that the class either does not contain the
+    // necessary field, or that it does contain the field, but the field is of the wrong type, it
+    // can catch the error at compile time. Otherwise it is caught at runtime, when validating the
+    // schema.
+    private fun validateBacklinks(): Boolean {
+        var allValid = true
+
+        for (backlink in backlinksToValidate) {
+            // If the class is not here it might be part of some other compilation unit.
+            if (!classCollection.containsQualifiedClass(backlink.sourceClass)) {
+                continue
+            }
+            val clazz = classCollection.getClassFromQualifiedName(backlink.sourceClass!!)
+
+            // If the class is here, we can validate it.
+            if (!backlink.validateTarget(clazz) && allValid) {
+                allValid = false
+            }
+        }
+
+        return allValid
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
deleted file mode 100644
index 8e6304e741..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ /dev/null
@@ -1,2251 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Locale;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
-import javax.tools.JavaFileObject;
-
-
-public class RealmProxyClassGenerator {
-    private static final String OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings";
-    private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";
-
-    private static final List<String> IMPORTS;
-    static {
-        List<String> l = Arrays.asList(
-            "android.annotation.TargetApi",
-            "android.os.Build",
-            "android.util.JsonReader",
-            "android.util.JsonToken",
-            "io.realm.ImportFlag",
-            "io.realm.exceptions.RealmMigrationNeededException",
-            "io.realm.internal.ColumnInfo",
-            "io.realm.internal.OsList",
-            "io.realm.internal.OsObject",
-            "io.realm.internal.OsSchemaInfo",
-            "io.realm.internal.OsObjectSchemaInfo",
-            "io.realm.internal.Property",
-            "io.realm.internal.objectstore.OsObjectBuilder",
-            "io.realm.ProxyUtils",
-            "io.realm.internal.RealmObjectProxy",
-            "io.realm.internal.Row",
-            "io.realm.internal.Table",
-            "io.realm.internal.android.JsonUtils",
-            "io.realm.log.RealmLog",
-            "java.io.IOException",
-            "java.util.ArrayList",
-            "java.util.Collections",
-            "java.util.List",
-            "java.util.Iterator",
-            "java.util.Date",
-            "java.util.Map",
-            "java.util.HashMap",
-            "java.util.Set",
-            "org.json.JSONObject",
-            "org.json.JSONException",
-            "org.json.JSONArray");
-        IMPORTS = Collections.unmodifiableList(l);
-    }
-
-    private final ProcessingEnvironment processingEnvironment;
-    private final TypeMirrors typeMirrors;
-    private final ClassMetaData metadata;
-    private final ClassCollection classCollection;
-    private final String simpleJavaClassName;
-    private final String qualifiedJavaClassName;
-    private final String internalClassName;
-    private final String interfaceName;
-    private final String qualifiedGeneratedClassName;
-    private final boolean suppressWarnings;
-
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, TypeMirrors typeMirrors, ClassMetaData metadata, ClassCollection classes) {
-        this.processingEnvironment = processingEnvironment;
-        this.typeMirrors = typeMirrors;
-        this.metadata = metadata;
-        this.classCollection = classes;
-        this.simpleJavaClassName = metadata.getSimpleJavaClassName();
-        this.qualifiedJavaClassName = metadata.getFullyQualifiedClassName();
-        this.internalClassName = metadata.getInternalClassName();
-        this.interfaceName = Utils.getProxyInterfaceName(qualifiedJavaClassName);
-        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
-                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(qualifiedJavaClassName));
-
-        // See the configuration for the debug build type,
-        //  in the realm-library project, for an example of how to set this flag.
-        this.suppressWarnings = !"false".equalsIgnoreCase(processingEnvironment.getOptions().get(OPTION_SUPPRESS_WARNINGS));
-    }
-
-    public void generate() throws IOException, UnsupportedOperationException {
-        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-
-        // Set source code indent
-        writer.setIndent(Constants.INDENT);
-
-        writer.emitPackage(Constants.REALM_PACKAGE_NAME)
-                .emitEmptyLine();
-
-        List<String> imports = new ArrayList<String>(IMPORTS);
-        if (!metadata.getBacklinkFields().isEmpty()) {
-            imports.add("io.realm.internal.UncheckedRow");
-        }
-        writer.emitImports(imports)
-                .emitEmptyLine();
-
-        // Begin the class definition
-        if (suppressWarnings) {
-            writer.emitAnnotation("SuppressWarnings(\"all\")");
-        }
-        writer
-                .beginType(
-                qualifiedGeneratedClassName, // full qualified name of the item to generate
-                "class",                     // the type of the item
-                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                qualifiedJavaClassName,          // class to extend
-                "RealmObjectProxy",          // interfaces to implement
-                interfaceName)
-                .emitEmptyLine();
-
-        emitColumnInfoClass(writer);
-
-        emitClassFields(writer);
-
-        emitInstanceFields(writer);
-        emitConstructor(writer);
-
-        emitInjectContextMethod(writer);
-        emitPersistedFieldAccessors(writer);
-        emitBacklinkFieldAccessors(writer);
-        emitCreateExpectedObjectSchemaInfo(writer);
-        emitGetExpectedObjectSchemaInfo(writer);
-        emitCreateColumnInfoMethod(writer);
-        emitGetSimpleClassNameMethod(writer);
-        emitCreateOrUpdateUsingJsonObject(writer);
-        emitCreateUsingJsonStream(writer);
-        emitNewProxyInstance(writer);
-        emitCopyOrUpdateMethod(writer);
-        emitCopyMethod(writer);
-        emitInsertMethod(writer);
-        emitInsertListMethod(writer);
-        emitInsertOrUpdateMethod(writer);
-        emitInsertOrUpdateListMethod(writer);
-        emitCreateDetachedCopyMethod(writer);
-        emitUpdateMethod(writer);
-        emitToStringMethod(writer);
-        emitRealmObjectProxyImplementation(writer);
-        emitHashcodeMethod(writer);
-        emitEqualsMethod(writer);
-
-        // End the class definition
-        writer.endType();
-        writer.close();
-    }
-
-    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
-        writer.beginType(
-                columnInfoClassName(),                       // full qualified name of the item to generate
-                "class",                                     // the type of the item
-                EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
-                "ColumnInfo");                               // base class
-
-        // fields
-        writer.emitField("long", "maxColumnIndexValue"); // Must not end with Index as it otherwise could conflict regular fields.
-        for (VariableElement variableElement : metadata.getFields()) {
-            writer.emitField("long", columnIndexVarName(variableElement));
-        }
-        writer.emitEmptyLine();
-
-        // constructor #1
-        writer.beginConstructor(
-                EnumSet.noneOf(Modifier.class),
-                "OsSchemaInfo", "schemaInfo");
-        writer.emitStatement("super(%s)", metadata.getFields().size());
-        writer.emitStatement("OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"%1$s\")",
-                internalClassName);
-        for (RealmFieldElement field : metadata.getFields()) {
-            writer.emitStatement(
-                    "this.%1$sIndex = addColumnDetails(\"%1$s\", \"%2$s\", objectSchemaInfo)",
-                    field.getJavaName(),
-                    field.getInternalFieldName());
-        }
-        for (Backlink backlink : metadata.getBacklinkFields()) {
-            writer.emitStatement(
-                    "addBacklinkDetails(schemaInfo, \"%s\", \"%s\", \"%s\")",
-                    backlink.getTargetField(),
-                    classCollection.getClassFromQualifiedName(backlink.getSourceClass()).getInternalClassName(),
-                    backlink.getSourceField());
-        }
-        writer
-            .emitStatement("this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex()")
-            .endConstructor()
-            .emitEmptyLine();
-
-        // constructor #2
-        writer.beginConstructor(
-                EnumSet.noneOf(Modifier.class),
-                "ColumnInfo", "src", "boolean", "mutable");
-        writer.emitStatement("super(src, mutable)")
-                .emitStatement("copy(src, this)");
-        writer.endConstructor()
-                .emitEmptyLine();
-
-        // no-args copy method
-        writer.emitAnnotation("Override")
-                .beginMethod(
-                        "ColumnInfo",                                   // return type
-                        "copy",                                         // method name
-                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
-                        "boolean", "mutable");     // parameters
-        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
-        writer.endMethod()
-                .emitEmptyLine();
-
-        // copy method
-        writer.emitAnnotation("Override")
-                .beginMethod(
-                        "void",                                          // return type
-                        "copy",                                          // method name
-                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
-                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
-        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
-        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
-        for (VariableElement variableElement : metadata.getFields()) {
-            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
-        }
-        writer.emitStatement("dst.maxColumnIndexValue = src.maxColumnIndexValue");
-        writer.endMethod();
-
-        writer.endType();
-    }
-
-    //@formatter:off
-    private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitEmptyLine()
-                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
-                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitInstanceFields(JavaWriter writer) throws IOException {
-        writer.emitEmptyLine()
-                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
-                .emitField("ProxyState<" + qualifiedJavaClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
-
-        for (VariableElement variableElement : metadata.getFields()) {
-            if (Utils.isMutableRealmInteger(variableElement)) {
-                emitMutableRealmIntegerField(writer, variableElement);
-            } else if (Utils.isRealmList(variableElement)) {
-                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
-                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
-            }
-        }
-
-        for (Backlink backlink : metadata.getBacklinkFields()) {
-            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
-                    EnumSet.of(Modifier.PRIVATE));
-        }
-    }
-    //@formatter:on
-
-    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
-    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
-    // the MutableInteger that it owns, also becomes unreachable.
-    //@formatter:off
-    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
-        writer.emitField("MutableRealmInteger.Managed",
-                mutableRealmIntegerFieldName(variableElement),
-                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
-                String.format(
-                        "new MutableRealmInteger.Managed<%1$s>() {\n"
-                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
-                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
-                                + "}",
-                        qualifiedJavaClassName, columnIndexVarName(variableElement)));
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitConstructor(JavaWriter writer) throws IOException {
-        // FooRealmProxy(ColumnInfo)
-        writer.emitEmptyLine()
-                .beginConstructor(EnumSet.noneOf(Modifier.class))
-                .emitStatement("proxyState.setConstructionFinished()")
-                .endConstructor()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
-    private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOException {
-        for (final VariableElement field : metadata.getFields()) {
-            final String fieldName = field.getSimpleName().toString();
-            final String fieldTypeCanonicalName = field.asType().toString();
-
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
-            } else if (Utils.isRealmModel(field)) {
-                emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
-            } else if (Utils.isRealmList(field)) {
-                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName, elementTypeMirror);
-            } else {
-                throw new UnsupportedOperationException(String.format(Locale.US,
-                        "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
-            }
-
-            writer.emitEmptyLine();
-        }
-    }
-
-    /**
-     * Primitives and boxed types
-     */
-    private void emitPrimitiveType(
-            JavaWriter writer,
-            final VariableElement field,
-            final String fieldName,
-            String fieldTypeCanonicalName) throws IOException {
-
-        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();
-
-        // Getter
-        //@formatter:off
-        writer.emitAnnotation("Override");
-        writer.emitAnnotation("SuppressWarnings", "\"cast\"")
-                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("proxyState.getRealm$realm().checkIfValid()");
-
-        // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
-        if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
-            writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
-                    .emitStatement("return null")
-                    .endControlFlow();
-        }
-        //@formatter:on
-
-        // For Boxed types, this should be the corresponding primitive types. Others remain the same.
-        String castingBackType;
-        if (Utils.isBoxedType(fieldTypeCanonicalName)) {
-            Types typeUtils = processingEnvironment.getTypeUtils();
-            castingBackType = typeUtils.unboxedType(field.asType()).toString();
-        } else {
-            castingBackType = fieldTypeCanonicalName;
-        }
-        writer.emitStatement(
-                "return (%s) proxyState.getRow$realm().get%s(%s)",
-                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
-        writer.endMethod()
-                .emitEmptyLine();
-
-        // Setter
-        writer.emitAnnotation("Override");
-        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-            @Override
-            public void emit(JavaWriter writer) throws IOException {
-                // set value as default value
-                writer.emitStatement("final Row row = proxyState.getRow$realm()");
-
-                //@formatter:off
-                if (metadata.isNullable(field)) {
-                    writer.beginControlFlow("if (value == null)")
-                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
-                                    fieldIndexVariableReference(field))
-                            .emitStatement("return")
-                            .endControlFlow();
-                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                    writer.beginControlFlow("if (value == null)")
-                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                            .endControlFlow();
-                }
-                //@formatter:on
-
-                writer.emitStatement(
-                        "row.getTable().set%s(%s, row.getIndex(), value, true)",
-                        fieldJavaType, fieldIndexVariableReference(field));
-                writer.emitStatement("return");
-            }
-        });
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-        // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
-        // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
-        if (metadata.isPrimaryKey(field)) {
-            // Primary key is not allowed to be changed after object created.
-            writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
-        } else {
-            //@formatter:off
-            if (metadata.isNullable(field)) {
-                writer.beginControlFlow("if (value == null)")
-                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                        .endControlFlow();
-            } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                // Same reason, throw IAE earlier.
-                writer
-                        .beginControlFlow("if (value == null)")
-                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                        .endControlFlow();
-            }
-            //@formatter:on
-            writer.emitStatement(
-                    "proxyState.getRow$realm().set%s(%s, value)",
-                    fieldJavaType, fieldIndexVariableReference(field));
-        }
-        writer.endMethod();
-    }
-
-    //@formatter:off
-    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
-        writer.emitAnnotation("Override")
-            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
-            .endMethod();
-    }
-    //@formatter:on
-
-    /**
-     * Links
-     */
-    //@formatter:off
-    private void emitRealmModel(
-            JavaWriter writer,
-            final VariableElement field,
-            String fieldName,
-            String fieldTypeCanonicalName) throws IOException {
-
-        // Getter
-        writer.emitAnnotation("Override");
-        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
-                .emitStatement("return null")
-                .endControlFlow()
-                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
-                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
-                .endMethod()
-                .emitEmptyLine();
-
-        // Setter
-        writer.emitAnnotation("Override");
-        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-            @Override
-            public void emit(JavaWriter writer) throws IOException {
-                // check excludeFields
-                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                        field.getSimpleName().toString())
-                        .emitStatement("return")
-                        .endControlFlow();
-                writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
-                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
-                        .endControlFlow();
-
-                // set value as default value
-                writer.emitStatement("final Row row = proxyState.getRow$realm()");
-                writer.beginControlFlow("if (value == null)")
-                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
-                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                        .endControlFlow();
-                writer.emitStatement("proxyState.checkValidObject(value)");
-                writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
-                        fieldIndexVariableReference(field));
-                writer.emitStatement("return");
-            }
-        });
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-                .beginControlFlow("if (value == null)")
-                .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
-                .emitStatement("return")
-                .endControlFlow()
-                .emitStatement("proxyState.checkValidObject(value)")
-                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
-                .endMethod();
-    }
-    //@formatter:on
-
-    /**
-     * ModelList, ValueList
-     */
-    //@formatter:off
-    private void emitRealmList(
-            JavaWriter writer,
-            final VariableElement field,
-            String fieldName,
-            String fieldTypeCanonicalName,
-            final TypeMirror elementTypeMirror) throws IOException {
-        final String genericType = Utils.getGenericTypeQualifiedName(field);
-        final boolean forRealmModel = Utils.isRealmModel(elementTypeMirror);
-
-        // Getter
-        writer.emitAnnotation("Override");
-        writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-                .emitSingleLineComment("use the cached value if available")
-                .beginControlFlow("if (" + fieldName + "RealmList != null)")
-                .emitStatement("return " + fieldName + "RealmList")
-                .nextControlFlow("else");
-                if (Utils.isRealmModelList(field)) {
-                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
-                            fieldIndexVariableReference(field));
-                } else {
-                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
-                            fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
-                }
-                writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, osList, proxyState.getRealm$realm())",
-                        genericType, genericType)
-                .emitStatement("return " + fieldName + "RealmList")
-                .endControlFlow()
-                .endMethod()
-                .emitEmptyLine();
-
-        // Setter
-        writer.emitAnnotation("Override");
-        writer.beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-        emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
-            @Override
-            public void emit(JavaWriter writer) throws IOException {
-                // check excludeFields
-                writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                        field.getSimpleName().toString())
-                        .emitStatement("return")
-                        .endControlFlow();
-
-                if (!forRealmModel) {
-                    return;
-                }
-
-                writer.emitSingleLineComment("if the list contains unmanaged RealmObjects, convert them to managed.")
-                        .beginControlFlow("if (value != null && !value.isManaged())")
-                        .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
-                        .emitStatement("final RealmList<%1$s> original = value", genericType)
-                        .emitStatement("value = new RealmList<%1$s>()", genericType)
-                        .beginControlFlow("for (%1$s item : original)", genericType)
-                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
-                        .emitStatement("value.add(item)")
-                        .nextControlFlow("else")
-                        .emitStatement("value.add(realm.copyToRealm(item))")
-                        .endControlFlow()
-                        .endControlFlow()
-                        .endControlFlow();
-
-                // LinkView currently does not support default value feature. Just fallback to normal code.
-            }
-        });
-
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
-        if (Utils.isRealmModelList(field)) {
-            writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
-                    fieldIndexVariableReference(field));
-        } else {
-            writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
-                    fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
-        }
-        if (forRealmModel) {
-            // Model lists.
-            writer
-                .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
-                .beginControlFlow("if (value != null && value.size() == osList.size())")
-                    .emitStatement("int objects = value.size()")
-                    .beginControlFlow("for (int i = 0; i < objects; i++)")
-                        .emitStatement("%s linkedObject = value.get(i)", genericType)
-                        .emitStatement("proxyState.checkValidObject(linkedObject)")
-                        .emitStatement("osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-                    .endControlFlow()
-                .nextControlFlow("else")
-                    .emitStatement("osList.removeAll()")
-                    .beginControlFlow("if (value == null)")
-                        .emitStatement("return")
-                    .endControlFlow()
-                    .emitStatement("int objects = value.size()")
-                    .beginControlFlow("for (int i = 0; i < objects; i++)")
-                        .emitStatement("%s linkedObject = value.get(i)", genericType)
-                        .emitStatement("proxyState.checkValidObject(linkedObject)")
-                        .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-                    .endControlFlow()
-                .endControlFlow();
-        } else {
-            // Value lists
-            writer
-                .emitStatement("osList.removeAll()")
-                .beginControlFlow("if (value == null)")
-                    .emitStatement("return")
-                .endControlFlow()
-                .beginControlFlow("for (%1$s item : value)", genericType)
-                    .beginControlFlow("if (item == null)")
-                        .emitStatement(metadata.isElementNullable(field) ? "osList.addNull()" : "throw new IllegalArgumentException(\"Storing 'null' into " + fieldName + "' is not allowed by the schema.\")")
-                    .nextControlFlow("else")
-                        .emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
-                    .endControlFlow()
-                .endControlFlow();
-        }
-        writer.endMethod();
-
-    }
-    //@formatter:on
-
-    private String getStatementForAppendingValueToOsList(
-            @SuppressWarnings("SameParameterValue") String osListVariableName,
-            @SuppressWarnings("SameParameterValue") String valueVariableName,
-            TypeMirror elementTypeMirror) {
-
-        Types typeUtils = processingEnvironment.getTypeUtils();
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.STRING_MIRROR)) {
-            return osListVariableName + ".addString(" + valueVariableName + ")";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.LONG_MIRROR)
-                || typeUtils.isSameType(elementTypeMirror, typeMirrors.INTEGER_MIRROR)
-                || typeUtils.isSameType(elementTypeMirror, typeMirrors.SHORT_MIRROR)
-                || typeUtils.isSameType(elementTypeMirror, typeMirrors.BYTE_MIRROR)) {
-            return osListVariableName + ".addLong(" + valueVariableName + ".longValue())";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BINARY_MIRROR)) {
-            return osListVariableName + ".addBinary(" + valueVariableName + ")";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DATE_MIRROR)) {
-            return osListVariableName + ".addDate(" + valueVariableName + ")";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BOOLEAN_MIRROR)) {
-            return osListVariableName + ".addBoolean(" + valueVariableName + ")";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DOUBLE_MIRROR)) {
-            return osListVariableName + ".addDouble(" + valueVariableName + ".doubleValue())";
-        }
-        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.FLOAT_MIRROR)) {
-            return osListVariableName + ".addFloat(" + valueVariableName + ".floatValue())";
-        }
-        throw new RuntimeException("unexpected element type: " + elementTypeMirror.toString());
-    }
-
-    private interface CodeEmitter {
-        void emit(JavaWriter writer) throws IOException;
-    }
-
-    private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKey,
-            CodeEmitter defaultValueCodeEmitter) throws IOException {
-        writer.beginControlFlow("if (proxyState.isUnderConstruction())");
-        if (isPrimaryKey) {
-            writer.emitSingleLineComment("default value of the primary key is always ignored.")
-                    .emitStatement("return");
-        } else {
-            writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
-                    .emitStatement("return")
-                    .endControlFlow();
-            defaultValueCodeEmitter.emit(writer);
-        }
-        writer.endControlFlow()
-                .emitEmptyLine();
-    }
-
-    // Note that because of bytecode hackery, this method may run before the constructor!
-    // It may even run before fields have been initialized.
-    //@formatter:off
-    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "void", // Return type
-                "realm$injectObjectContext", // Method name
-                EnumSet.of(Modifier.PUBLIC) // Modifiers
-        ); // Argument type & argument name
-
-        writer.beginControlFlow("if (this.proxyState != null)")
-                .emitStatement("return")
-                .endControlFlow()
-                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
-                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
-                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedJavaClassName)
-                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
-                .emitStatement("proxyState.setRow$realm(context.getRow())")
-                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
-                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
-                .endMethod()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
-        for (Backlink backlink : metadata.getBacklinkFields()) {
-            String cacheFieldName = backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION;
-            String realmResultsType = "RealmResults<" + backlink.getSourceClass() + ">";
-
-            // Getter, no setter
-            writer.emitAnnotation("Override");
-            writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
-                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
-                    .emitStatement("realm.checkIfValid()")
-                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
-                    .beginControlFlow("if (" + cacheFieldName + " == null)")
-                    .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
-                            backlink.getSourceClass(), backlink.getSourceField())
-                    .endControlFlow()
-                    .emitStatement("return " + cacheFieldName)
-                    .endMethod()
-                    .emitEmptyLine();
-        }
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override")
-                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("return proxyState")
-                .endMethod()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
-    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "OsObjectSchemaInfo", // Return type
-                "createExpectedObjectSchemaInfo", // Method name
-                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers
-
-        // Guess capacity for Arrays used by OsObjectSchemaInfo.
-        // Used to prevent array resizing at runtime
-        int persistedFields = metadata.getFields().size();
-        int computedFields = metadata.getBacklinkFields().size();
-
-        writer.emitStatement(
-                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
-                internalClassName, persistedFields, computedFields);
-
-        // For each field generate corresponding table index constant
-        for (RealmFieldElement field : metadata.getFields()) {
-            String fieldName = field.getInternalFieldName();
-
-            Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
-            switch (fieldType) {
-                case NOTYPE: {
-                    // Perhaps this should fail quickly?
-                    break;
-                }
-                case OBJECT: {
-                    String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
-                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(fieldTypeQualifiedName, classCollection);
-                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, %s)",
-                            fieldName, internalClassName);
-                    break;
-                }
-                case LIST: {
-                    String genericTypeQualifiedName = Utils.getGenericTypeQualifiedName(field);
-                    String internalClassName = Utils.getReferencedTypeInternalClassNameStatement(genericTypeQualifiedName, classCollection);
-                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, %s)",
-                            fieldName, internalClassName);
-                    break;
-                }
-                case INTEGER_LIST:
-                case BOOLEAN_LIST:
-                case STRING_LIST:
-                case BINARY_LIST:
-                case DATE_LIST:
-                case FLOAT_LIST:
-                case DOUBLE_LIST:
-                    writer.emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)",
-                            fieldName, fieldType.getRealmType(), metadata.isElementNullable(field) ? "!Property.REQUIRED" : "Property.REQUIRED");
-                    break;
-
-                case BACKLINK:
-                    throw new IllegalArgumentException("LinkingObject field should not be added to metadata");
-
-                case INTEGER:
-                case FLOAT:
-                case DOUBLE:
-                case BOOLEAN:
-                case STRING:
-                case DATE:
-                case BINARY:
-                case REALM_INTEGER:
-                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
-                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
-                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
-                            fieldName,
-                            fieldType.getRealmType(),
-                            primaryKeyFlag,
-                            indexedFlag,
-                            nullableFlag);
-                    break;
-
-                default:
-                    throw new IllegalArgumentException("'fieldType' " + fieldName + " is not handled");
-            }
-        }
-        for (Backlink backlink: metadata.getBacklinkFields()) {
-            // Backlinks can only be created between classes in the current round of annotation processing
-            // as the forward link cannot be created unless you know the type already.
-            ClassMetaData sourceClass = classCollection.getClassFromQualifiedName(backlink.getSourceClass());
-            String targetField = backlink.getTargetField(); // Only in the model, so no internal name exists
-            String internalSourceField = sourceClass.getInternalFieldName(backlink.getSourceField());
-            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
-                    targetField, sourceClass.getInternalClassName(), internalSourceField);
-        }
-        writer.emitStatement("return builder.build()");
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
-    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "OsObjectSchemaInfo", // Return type
-                "getExpectedObjectSchemaInfo", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers
-
-        writer.emitStatement("return expectedObjectSchemaInfo");
-
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
-    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                columnInfoClassName(),        // Return type
-                "createColumnInfo",              // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "OsSchemaInfo", "schemaInfo"); // Argument type & argument name
-
-        // create an instance of ColumnInfo
-        writer.emitStatement("return new %1$s(schemaInfo)", columnInfoClassName());
-
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    //@formatter:off
-    private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("String", "getSimpleClassName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-                .emitStatement("return \"%s\"", internalClassName)
-                .endMethod()
-                .emitEmptyLine();
-
-        // Helper class for the annotation processor so it can access the internal class name
-        // without needing to load the parent class (which we cannot do as it transitively loads
-        // native code, which cannot be loaded on the JVM).
-        writer.beginType(
-                "ClassNameHelper",                       // full qualified name of the item to generate
-                "class",                                                  // the type of the item
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)); // modifiers to apply
-        writer.emitField("String", "INTERNAL_CLASS_NAME", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL), "\""+ internalClassName+"\"");
-        writer.endType();
-        writer.emitEmptyLine();
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitNewProxyInstance(JavaWriter writer) throws IOException {
-        writer
-            .beginMethod(qualifiedGeneratedClassName,
-            "newProxyInstance",
-            EnumSet.of(Modifier.PRIVATE, Modifier.STATIC),
-            "BaseRealm", "realm",
-            "Row", "row")
-                .emitSingleLineComment("Ignore default values to avoid creating uexpected objects from RealmModel/RealmList fields")
-                .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
-                .emitStatement("objectContext.set(realm, row, realm.getSchema().getColumnInfo(%s.class), false, Collections.<String>emptyList())", qualifiedJavaClassName)
-                .emitStatement("%1$s obj = new %1$s()", qualifiedGeneratedClassName)
-                .emitStatement("objectContext.clear()")
-                .emitStatement("return obj")
-            .endMethod()
-            .emitEmptyLine();
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                qualifiedJavaClassName, // Return type
-                "copyOrUpdate", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", // Argument type & argument name
-                columnInfoClassName(), "columnInfo",
-                qualifiedJavaClassName, "object",
-                "boolean", "update",
-                "Map<RealmModel,RealmObjectProxy>", "cache",
-                "Set<ImportFlag>", "flags"
-        );
-
-        writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
-                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
-                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
-                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
-                    .endControlFlow()
-
-                    // If object is already in the Realm there is nothing to update
-                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
-                        .emitStatement("return object")
-                    .endControlFlow()
-                .endControlFlow();
-
-
-        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
-
-        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
-                .beginControlFlow("if (cachedRealmObject != null)")
-                    .emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
-                .endControlFlow()
-                .emitEmptyLine();
-
-        if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("return copy(realm, columnInfo, object, update, cache, flags)");
-        } else {
-            writer
-                    .emitStatement("%s realmObject = null", qualifiedJavaClassName)
-                    .emitStatement("boolean canUpdate = update")
-                    .beginControlFlow("if (canUpdate)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
-                    .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
-
-            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-            VariableElement primaryKeyElement = metadata.getPrimaryKey();
-            if (metadata.isNullable(primaryKeyElement)) {
-                if (Utils.isString(primaryKeyElement)) {
-                    writer
-                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = Table.NO_MATCH")
-                            .beginControlFlow("if (value == null)")
-                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                            .nextControlFlow("else")
-                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
-                            .endControlFlow();
-                } else {
-                    writer
-                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = Table.NO_MATCH")
-                            .beginControlFlow("if (value == null)")
-                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                            .nextControlFlow("else")
-                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
-                            .endControlFlow();
-                }
-            } else {
-                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
-                        pkType, interfaceName, primaryKeyGetter);
-            }
-
-            writer
-                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
-                        .emitStatement("canUpdate = false")
-                    .nextControlFlow("else")
-                        .beginControlFlow("try")
-                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex), columnInfo, false, Collections.<String> emptyList())")
-                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
-                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
-                        .nextControlFlow("finally")
-                            .emitStatement("objectContext.clear()")
-                        .endControlFlow()
-                    .endControlFlow();
-
-            writer.endControlFlow();
-
-            writer
-                    .emitEmptyLine()
-                       .emitStatement("return (canUpdate) ? update(realm, columnInfo, realmObject, object, cache, flags) : copy(realm, columnInfo, object, update, cache, flags)");
-        }
-
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
-        if ("long".equals(fieldType)
-                || "int".equals(fieldType)
-                || "short".equals(fieldType)
-                || "byte".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
-
-        } else if ("java.lang.Long".equals(fieldType)
-                || "java.lang.Integer".equals(fieldType)
-                || "java.lang.Short".equals(fieldType)
-                || "java.lang.Byte".equals(fieldType)) {
-            writer
-                    .emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
-            writer
-                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("double".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
-
-        } else if ("java.lang.Double".equals(fieldType)) {
-            writer
-                    .emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("float".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
-
-        } else if ("java.lang.Float".equals(fieldType)) {
-            writer
-                    .emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("boolean".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
-
-        } else if ("java.lang.Boolean".equals(fieldType)) {
-            writer
-                    .emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("byte[]".equals(fieldType)) {
-            writer
-                    .emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-
-        } else if ("java.util.Date".equals(fieldType)) {
-            writer
-                    .emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-
-        } else if ("java.lang.String".equals(fieldType)) {
-            writer
-                    .emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
-                    .beginControlFlow("if (%s != null)", getter)
-                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-            if (isUpdate) {
-                writer.nextControlFlow("else")
-                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-            }
-            writer.endControlFlow();
-        } else {
-            throw new IllegalStateException("Unsupported type " + fieldType);
-        }
-    }
-    //@formatter:on
-
-    private void emitInsertMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "long", // Return type
-                "insert", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedJavaClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
-        );
-
-        // If object is already in the Realm there is nothing to update
-        writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
-                .endControlFlow();
-
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
-        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
-
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
-        }
-        addPrimaryKeyCheckIfNeeded(metadata, true, writer);
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldType = field.asType().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-
-            //@formatter:off
-            if (Utils.isRealmModel(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                        .beginControlFlow("if (cache%s == null)", fieldName)
-                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                fieldName,
-                                Utils.getProxyClassSimpleName(field),
-                                fieldName)
-                        .endControlFlow()
-                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
-                        .endControlFlow();
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                        .endControlFlow()
-                        .endControlFlow();
-            } else if (Utils.isRealmValueList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .beginControlFlow("if (%1$sItem == null)", fieldName)
-                        .emitStatement(fieldName + "OsList.addNull()")
-                        .nextControlFlow("else")
-                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
-                        .endControlFlow()
-                        .endControlFlow()
-                        .endControlFlow();
-            } else {
-                if (metadata.getPrimaryKey() != field) {
-                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
-                }
-            }
-            //@formatter:on
-        }
-
-        writer.emitStatement("return rowIndex");
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
-    private void emitInsertListMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "void", // Return type
-                "insert", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
-        );
-
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
-        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
-        }
-        writer.emitStatement("%s object = null", qualifiedJavaClassName);
-
-        writer.beginControlFlow("while (objects.hasNext())")
-                .emitStatement("object = (%s) objects.next()", qualifiedJavaClassName);
-        writer.beginControlFlow("if (cache.containsKey(object))")
-                .emitStatement("continue")
-                .endControlFlow();
-
-        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
-        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
-                .emitStatement("continue");
-        writer.endControlFlow();
-
-        addPrimaryKeyCheckIfNeeded(metadata, true, writer);
-
-        //@formatter:off
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldType = field.asType().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-
-            if (Utils.isRealmModel(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                        .beginControlFlow("if (cache%s == null)", fieldName)
-                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                fieldName,
-                                Utils.getProxyClassSimpleName(field),
-                                fieldName)
-                        .endControlFlow()
-                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
-                        .endControlFlow();
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                        .endControlFlow()
-                        .endControlFlow();
-
-            } else if (Utils.isRealmValueList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .beginControlFlow("if (%1$sItem == null)", fieldName)
-                        .emitStatement("%1$sOsList.addNull()", fieldName)
-                        .nextControlFlow("else")
-                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
-                        .endControlFlow()
-                        .endControlFlow()
-                        .endControlFlow();
-            } else {
-                if (metadata.getPrimaryKey() != field) {
-                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
-                }
-            }
-        }
-        //@formatter:on
-
-        writer.endControlFlow();
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "long", // Return type
-                "insertOrUpdate", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", qualifiedJavaClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
-        );
-
-        // If object is already in the Realm there is nothing to update
-        writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
-                .endControlFlow();
-
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
-        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
-
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
-        }
-        addPrimaryKeyCheckIfNeeded(metadata, false, writer);
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldType = field.asType().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-
-            //@formatter:off
-            if (Utils.isRealmModel(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                        .beginControlFlow("if (cache%s == null)", fieldName)
-                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                fieldName,
-                                Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
-                        .nextControlFlow("else")
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
-                        .endControlFlow();
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                    .emitEmptyLine()
-                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
-                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
-                        .emitStatement("int objects = %1$sList.size()", fieldName)
-                        .beginControlFlow("for (int i = 0; i < objects; i++)")
-                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                            .endControlFlow()
-                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
-                    .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
-                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
-                        .endControlFlow()
-                    .endControlFlow()
-                    .emitEmptyLine();
-
-            } else if (Utils.isRealmValueList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .beginControlFlow("if (%1$sItem == null)", fieldName)
-                        .emitStatement("%1$sOsList.addNull()", fieldName)
-                        .nextControlFlow("else")
-                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
-                        .endControlFlow()
-                        .endControlFlow()
-                        .endControlFlow()
-                        .emitEmptyLine();
-            } else {
-                if (metadata.getPrimaryKey() != field) {
-                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
-                }
-            }
-            //@formatter:on
-        }
-
-        writer.emitStatement("return rowIndex");
-
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
-    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "void", // Return type
-                "insertOrUpdate", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
-        );
-
-        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
-        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName);
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
-        }
-        writer.emitStatement("%s object = null", qualifiedJavaClassName);
-
-        writer.beginControlFlow("while (objects.hasNext())");
-        writer.emitStatement("object = (%s) objects.next()", qualifiedJavaClassName);
-        writer.beginControlFlow("if (cache.containsKey(object))")
-                .emitStatement("continue")
-                .endControlFlow();
-
-        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
-        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
-                .emitStatement("continue");
-        writer.endControlFlow();
-        addPrimaryKeyCheckIfNeeded(metadata, false, writer);
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldType = field.asType().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-
-            //@formatter:off
-            if (Utils.isRealmModel(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                        .beginControlFlow("if (cache%s == null)", fieldName)
-                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                fieldName,
-                                Utils.getProxyClassSimpleName(field))
-                        .endControlFlow()
-                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
-                        .nextControlFlow("else")
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
-                        .endControlFlow();
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                    .emitEmptyLine()
-                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
-                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
-                        .emitStatement("int objectCount = %1$sList.size()", fieldName)
-                        .beginControlFlow("for (int i = 0; i < objectCount; i++)")
-                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                            .endControlFlow()
-                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
-                        .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                                .endControlFlow()
-                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
-                        .endControlFlow()
-                    .endControlFlow()
-                    .emitEmptyLine();
-
-            } else if (Utils.isRealmValueList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
-                        .emitStatement("%1$sOsList.removeAll()", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                        .beginControlFlow("if (%1$sItem == null)", fieldName)
-                        .emitStatement("%1$sOsList.addNull()", fieldName)
-                        .nextControlFlow("else")
-                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList",
-                                fieldName + "Item", elementTypeMirror))
-                        .endControlFlow()
-                        .endControlFlow()
-                        .endControlFlow()
-                        .emitEmptyLine();
-            } else {
-                if (metadata.getPrimaryKey() != field) {
-                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
-                }
-            }
-            //@formatter:on
-        }
-        writer.endControlFlow();
-
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
-        if (metadata.hasPrimaryKey()) {
-            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-            VariableElement primaryKeyElement = metadata.getPrimaryKey();
-            if (metadata.isNullable(primaryKeyElement)) {
-                //@formatter:off
-                if (Utils.isString(primaryKeyElement)) {
-                    writer
-                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = Table.NO_MATCH")
-                            .beginControlFlow("if (primaryKeyValue == null)")
-                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                            .nextControlFlow("else")
-                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
-                            .endControlFlow();
-                } else {
-                    writer
-                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = Table.NO_MATCH")
-                            .beginControlFlow("if (primaryKeyValue == null)")
-                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                            .nextControlFlow("else")
-                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
-                            .endControlFlow();
-                }
-                //@formatter:on
-            } else {
-                writer.emitStatement("long rowIndex = Table.NO_MATCH");
-                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
-                writer.beginControlFlow("if (primaryKeyValue != null)");
-
-                if (Utils.isString(metadata.getPrimaryKey())) {
-                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
-                } else {
-                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
-                }
-                writer.endControlFlow();
-            }
-
-            writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
-            if (Utils.isString(metadata.getPrimaryKey())) {
-                writer.emitStatement(
-                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue)");
-            } else {
-                writer.emitStatement(
-                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, ((%s) object).%s())",
-                        interfaceName, primaryKeyGetter);
-            }
-
-            if (throwIfPrimaryKeyDuplicate) {
-                writer.nextControlFlow("else");
-                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
-            }
-
-            writer.endControlFlow();
-            writer.emitStatement("cache.put(object, rowIndex)");
-        } else {
-            writer.emitStatement("long rowIndex = OsObject.createRow(table)");
-            writer.emitStatement("cache.put(object, rowIndex)");
-        }
-    }
-
-    private void emitCopyMethod(JavaWriter writer) throws IOException {
-        writer
-            .beginMethod(
-            qualifiedJavaClassName, // Return type
-            "copy", // Method name
-            EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-            "Realm", "realm",
-                    columnInfoClassName(), "columnInfo",
-                    qualifiedJavaClassName, "newObject",
-                    "boolean", "update",
-                    "Map<RealmModel,RealmObjectProxy>", "cache",
-                    "Set<ImportFlag>", "flags"
-
-            ); // Argument type & argument name
-
-        writer
-            .emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)")
-            .beginControlFlow("if (cachedRealmObject != null)")
-                .emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
-            .endControlFlow()
-            .emitEmptyLine();
-
-        writer
-            .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
-            .emitEmptyLine()
-            .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
-            .emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)");
-
-        // Copy basic types
-        writer
-            .emitEmptyLine()
-            .emitSingleLineComment("Add all non-\"object reference\" fields");
-        for (RealmFieldElement field : metadata.getBasicTypeFields()) {
-            String fieldIndex = fieldIndexVariableReference(field);
-            String fieldName = field.getSimpleName().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-            writer.emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter);
-        }
-
-        // Create the underlying object
-        writer
-            .emitEmptyLine()
-            .emitSingleLineComment("Create the underlying object and cache it before setting any object/objectlist references")
-            .emitSingleLineComment("This will allow us to break any circular dependencies by using the object cache.")
-            .emitStatement("Row row = builder.createNewObject()")
-            .emitStatement("%s realmObjectCopy = newProxyInstance(realm, row)", qualifiedGeneratedClassName)
-            .emitStatement("cache.put(newObject, realmObjectCopy)");
-
-        // Copy all object references or lists-of-objects
-        writer.emitEmptyLine();
-        if (!metadata.getObjectReferenceFields().isEmpty()) {
-            writer.emitSingleLineComment("Finally add all fields that reference other Realm Objects, either directly or through a list");
-        }
-        for (RealmFieldElement field : metadata.getObjectReferenceFields()) {
-            String fieldType = field.asType().toString();
-            String fieldName = field.getSimpleName().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-            String setter = metadata.getInternalSetter(fieldName);
-
-            if (Utils.isRealmModel(field)) {
-                writer
-                    .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
-                    .beginControlFlow("if (%sObj == null)", fieldName)
-                        .emitStatement("realmObjectCopy.%s(null)", setter)
-                    .nextControlFlow("else")
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                        .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
-                        .nextControlFlow("else")
-                            .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, update, cache, flags))",
-                                setter, Utils.getProxyClassSimpleName(field),  columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
-                        .endControlFlow()
-                    // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                    .endControlFlow()
-                    .emitEmptyLine();
-
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                    .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
-                    .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
-                            genericType, fieldName, getter)
-                         // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
-                        .emitStatement("%sRealmList.clear()", fieldName)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                            .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
-                            .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
-                            .nextControlFlow("else")
-                                .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, (%3$s) realm.getSchema().getColumnInfo(%4$s.class), %1$sItem, update, cache, flags))",
-                                    fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
-                            .endControlFlow()
-                        .endControlFlow()
-                    .endControlFlow()
-                    .emitEmptyLine();
-            } else {
-                throw new IllegalStateException("Unsupported field: " + field);
-            }
-        }
-
-        writer
-            .emitStatement("return realmObjectCopy")
-            .endMethod()
-            .emitEmptyLine();
-    }
-
-    //@formatter:off
-    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                qualifiedJavaClassName, // Return type
-                "createDetachedCopy", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                qualifiedJavaClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
-        writer
-                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
-                .emitStatement("return null")
-                .endControlFlow()
-                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-                .emitStatement("%s unmanagedObject", qualifiedJavaClassName)
-                .beginControlFlow("if (cachedObject == null)")
-                .emitStatement("unmanagedObject = new %s()", qualifiedJavaClassName)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
-                .nextControlFlow("else")
-                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
-                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                .emitStatement("return (%s) cachedObject.object", qualifiedJavaClassName)
-                .endControlFlow()
-                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedJavaClassName)
-                .emitStatement("cachedObject.minDepth = currentDepth")
-                .endControlFlow();
-
-        // may cause an unused variable warning if the object contains only null lists
-        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
-            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String setter = metadata.getInternalSetter(fieldName);
-            String getter = metadata.getInternalGetter(fieldName);
-
-            if (Utils.isRealmModel(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitSingleLineComment("Deep copy of %s", fieldName)
-                        .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
-                                setter, Utils.getProxyClassSimpleName(field), getter);
-            } else if (Utils.isRealmModelList(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitSingleLineComment("Deep copy of %s", fieldName)
-                        .beginControlFlow("if (currentDepth == maxDepth)")
-                        .emitStatement("unmanagedCopy.%s(null)", setter)
-                        .nextControlFlow("else")
-                        .emitStatement("RealmList<%s> managed%sList = realmSource.%s()",
-                                Utils.getGenericTypeQualifiedName(field), fieldName, getter)
-                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
-                        .emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
-                        .emitStatement("int nextDepth = currentDepth + 1")
-                        .emitStatement("int size = managed%sList.size()", fieldName)
-                        .beginControlFlow("for (int i = 0; i < size; i++)")
-                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
-                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
-                        .emitStatement("unmanaged%sList.add(item)", fieldName)
-                        .endControlFlow()
-                        .endControlFlow();
-            } else if (Utils.isRealmValueList(field)) {
-                writer
-                        .emitEmptyLine()
-                        .emitStatement("unmanagedCopy.%1$s(new RealmList<%2$s>())", setter, Utils.getGenericTypeQualifiedName(field))
-                        .emitStatement("unmanagedCopy.%1$s().addAll(realmSource.%1$s())", getter);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
-                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
-            } else {
-                writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
-            }
-        }
-
-        writer.emitEmptyLine();
-        writer.emitStatement("return unmanagedObject");
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-    //@formatter:on
-
-    private void emitUpdateMethod(JavaWriter writer) throws IOException {
-        if (!metadata.hasPrimaryKey()) {
-            return;
-        }
-
-        writer.beginMethod(
-                qualifiedJavaClassName, // Return type
-                "update", // Method name
-                EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", // Argument type & argument name
-                columnInfoClassName(), "columnInfo",
-                qualifiedJavaClassName, "realmObject",
-                qualifiedJavaClassName, "newObject",
-                "Map<RealmModel, RealmObjectProxy>", "cache",
-                "Set<ImportFlag>", "flags"
-        );
-
-        writer
-                .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
-                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
-                .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
-                .emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)");
-
-
-        for (RealmFieldElement field : metadata.getFields()) {
-            String fieldType = field.asType().toString();
-            String fieldName = field.getSimpleName().toString();
-            String getter = metadata.getInternalGetter(fieldName);
-            String fieldIndex = fieldIndexVariableReference(field);
-
-            if (Utils.isRealmModel(field)) {
-                writer
-                    .emitEmptyLine()
-                    .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
-                    .beginControlFlow("if (%sObj == null)", fieldName)
-                        .emitStatement("builder.addNull(%s)", fieldIndexVariableReference(field))
-                    .nextControlFlow("else")
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                        .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("builder.addObject(%s, cache%s)", fieldIndex, fieldName)
-                        .nextControlFlow("else")
-                            .emitStatement("builder.addObject(%s, %s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, true, cache, flags))",
-                                    fieldIndex, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
-                        .endControlFlow()
-                    // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                    .endControlFlow();
-            } else if (Utils.isRealmModelList(field)) {
-                final String genericType = Utils.getGenericTypeQualifiedName(field);
-                writer
-                    .emitEmptyLine()
-                    .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
-                    .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sManagedCopy = new RealmList<%s>()", genericType, fieldName, genericType)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
-                            .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
-                            .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("%1$sManagedCopy.add(cache%1$s)", fieldName)
-                            .nextControlFlow("else")
-                                .emitStatement("%1$sManagedCopy.add(%2$s.copyOrUpdate(realm, (%3$s) realm.getSchema().getColumnInfo(%4$s.class), %1$sItem, true, cache, flags))",
-                                        fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
-                            .endControlFlow()
-                        .endControlFlow()
-                        .emitStatement("builder.addObjectList(%s, %sManagedCopy)", fieldIndex, fieldName)
-                    .nextControlFlow("else")
-                        .emitStatement("builder.addObjectList(%s, new RealmList<%s>())", fieldIndex, genericType)
-                    .endControlFlow();
-            } else {
-                writer
-                    .emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter);
-            }
-        }
-
-        writer
-            .emitEmptyLine()
-            .emitStatement("builder.updateExistingObject()")
-            .emitStatement("return realmObject");
-
-        writer
-            .endMethod()
-            .emitEmptyLine();
-    }
-
-    private void emitToStringMethod(JavaWriter writer) throws IOException {
-        if (metadata.containsToString()) {
-            return;
-        }
-        writer.emitAnnotation("Override");
-        writer.emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
-                .beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
-                .beginControlFlow("if (!RealmObject.isValid(this))")
-                .emitStatement("return \"Invalid object\"")
-                .endControlFlow();
-        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleJavaClassName);
-
-        Collection<RealmFieldElement> fields = metadata.getFields();
-        int i = fields.size() - 1;
-        for (VariableElement field : fields) {
-            String fieldName = field.getSimpleName().toString();
-
-            writer.emitStatement("stringBuilder.append(\"{%s:\")", fieldName);
-            if (Utils.isRealmModel(field)) {
-                String fieldTypeSimpleName = Utils.stripPackage(Utils.getFieldTypeQualifiedName(field));
-                writer.emitStatement(
-                        "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
-                        metadata.getInternalGetter(fieldName),
-                        fieldTypeSimpleName
-                );
-            } else if (Utils.isRealmList(field)) {
-                String genericTypeSimpleName = Utils.stripPackage(Utils.getGenericTypeQualifiedName(field));
-                writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
-                        genericTypeSimpleName,
-                        metadata.getInternalGetter(fieldName));
-            } else if (Utils.isMutableRealmInteger(field)) {
-                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
-            } else {
-                if (metadata.isNullable(field)) {
-                    writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
-                            metadata.getInternalGetter(fieldName),
-                            metadata.getInternalGetter(fieldName)
-                    );
-                } else {
-                    writer.emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName));
-                }
-            }
-            writer.emitStatement("stringBuilder.append(\"}\")");
-
-            if (i-- > 0) {
-                writer.emitStatement("stringBuilder.append(\",\")");
-            }
-        }
-
-        writer.emitStatement("stringBuilder.append(\"]\")");
-        writer.emitStatement("return stringBuilder.toString()");
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
-    /**
-     * Currently, the hash value emitted from this could suddenly change as an object's index might
-     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
-     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
-     */
-    //@formatter:off
-    private void emitHashcodeMethod(JavaWriter writer) throws IOException {
-        if (metadata.containsHashCode()) {
-            return;
-        }
-        writer.emitAnnotation("Override")
-                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
-                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
-                .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
-                .emitEmptyLine()
-                .emitStatement("int result = 17")
-                .emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
-                .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
-                .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
-                .emitStatement("return result")
-                .endMethod()
-                .emitEmptyLine();
-    }
-    //@formatter:on
-
-    //@formatter:off
-    private void emitEqualsMethod(JavaWriter writer) throws IOException {
-        if (metadata.containsEquals()) {
-            return;
-        }
-        String proxyClassName = Utils.getProxyClassName(qualifiedJavaClassName);
-        String otherObjectVarName = "a" + simpleJavaClassName;
-        writer.emitAnnotation("Override")
-                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
-                .emitStatement("if (this == o) return true")
-                .emitStatement("if (o == null || getClass() != o.getClass()) return false")
-                .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
-                .emitEmptyLine()
-                .emitStatement("String path = proxyState.getRealm$realm().getPath()")
-                .emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName)
-                .emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
-                .emitEmptyLine()
-                .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
-                .emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName)
-                .emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
-                .emitEmptyLine()
-                .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
-                .emitEmptyLine()
-                .emitStatement("return true")
-                .endMethod();
-    }
-    //@formatter:on
-
-    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
-        writer.beginMethod(
-                qualifiedJavaClassName,
-                "createOrUpdateUsingJsonObject",
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
-                Collections.singletonList("JSONException"));
-
-        final int modelOrListCount = countModelOrListFields(metadata.getFields());
-        if (modelOrListCount == 0) {
-            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
-        } else {
-            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
-                    modelOrListCount);
-        }
-
-        //@formatter:off
-        if (!metadata.hasPrimaryKey()) {
-            buildExcludeFieldsList(writer, metadata.getFields());
-            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
-                    qualifiedJavaClassName, qualifiedJavaClassName);
-        } else {
-            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-            writer
-                .emitStatement("%s obj = null", qualifiedJavaClassName)
-                .beginControlFlow("if (update)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
-                    .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
-                        columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
-                    .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()))
-                    .emitStatement("long rowIndex = Table.NO_MATCH");
-            if (metadata.isNullable(metadata.getPrimaryKey())) {
-                writer
-                    .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                        .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                    .nextControlFlow("else")
-                        .emitStatement(
-                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
-                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                    .endControlFlow();
-            } else {
-                writer
-                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                        .emitStatement(
-                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
-                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
-                    .endControlFlow();
-            }
-            writer
-                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
-                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
-                    .beginControlFlow("try")
-                        .emitStatement(
-                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
-                                qualifiedJavaClassName)
-                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
-                    .nextControlFlow("finally")
-                        .emitStatement("objectContext.clear()")
-                    .endControlFlow()
-                .endControlFlow()
-            .endControlFlow();
-
-            writer.beginControlFlow("if (obj == null)");
-            buildExcludeFieldsList(writer, metadata.getFields());
-            String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
-            String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
-                    qualifiedJavaClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
-            writer.endControlFlow();
-        }
-        //@formatter:on
-
-        writer
-                .emitEmptyLine()
-                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String qualifiedFieldType = field.asType().toString();
-            if (metadata.isPrimaryKey(field)) {
-                // Primary key has already been set when adding new row or finding the existing row.
-                continue;
-            }
-            if (Utils.isRealmModel(field)) {
-                RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
-                        "objProxy",
-                        metadata.getInternalSetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        Utils.getProxyClassSimpleName(field),
-                        writer
-                );
-
-            } else if (Utils.isRealmModelList(field)) {
-                RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
-                        "objProxy",
-                        metadata.getInternalGetter(fieldName),
-                        metadata.getInternalSetter(fieldName),
-                        fieldName,
-                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
-                        Utils.getProxyClassSimpleName(field),
-                        writer);
-
-            } else if (Utils.isRealmValueList(field)) {
-                writer.emitStatement("ProxyUtils.setRealmListWithJsonObject(objProxy.%1$s(), json, \"%2$s\")",
-                        metadata.getInternalGetter(fieldName), fieldName);
-            } else if (Utils.isMutableRealmInteger(field)) {
-                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
-                        "objProxy",
-                        metadata.getInternalGetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        writer);
-
-            } else {
-                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
-                        "objProxy",
-                        metadata.getInternalSetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        writer
-                );
-            }
-        }
-
-        writer.emitStatement("return obj");
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void buildExcludeFieldsList(JavaWriter writer, Collection<RealmFieldElement> fields) throws IOException {
-        for (VariableElement field : fields) {
-            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
-                final String fieldName = field.getSimpleName().toString();
-                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
-                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
-                        .endControlFlow();
-            }
-        }
-    }
-
-    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
-    // instead of createObject() to avoid parsing the stream twice.
-    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("SuppressWarnings", "\"cast\"");
-        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
-        writer.beginMethod(
-                qualifiedJavaClassName,
-                "createUsingJsonStream",
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
-                Collections.singletonList("IOException"));
-
-        if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("boolean jsonHasPrimaryKey = false");
-        }
-        writer.emitStatement("final %s obj = new %s()", qualifiedJavaClassName, qualifiedJavaClassName);
-        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
-        writer.emitStatement("reader.beginObject()");
-        writer.beginControlFlow("while (reader.hasNext())");
-        writer.emitStatement("String name = reader.nextName()");
-        writer.beginControlFlow("if (false)");
-        Collection<RealmFieldElement> fields = metadata.getFields();
-        for (VariableElement field : fields) {
-            String fieldName = field.getSimpleName().toString();
-            String qualifiedFieldType = field.asType().toString();
-            writer.nextControlFlow("else if (name.equals(\"%s\"))", fieldName);
-
-            if (Utils.isRealmModel(field)) {
-                RealmJsonTypeHelper.emitFillRealmObjectFromStream(
-                        "objProxy",
-                        metadata.getInternalSetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        Utils.getProxyClassSimpleName(field),
-                        writer
-                );
-
-            } else if (Utils.isRealmModelList(field)) {
-                RealmJsonTypeHelper.emitFillRealmListFromStream(
-                        "objProxy",
-                        metadata.getInternalGetter(fieldName),
-                        metadata.getInternalSetter(fieldName),
-                        ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
-                        Utils.getProxyClassSimpleName(field),
-                        writer);
-
-            } else if (Utils.isRealmValueList(field)) {
-                writer.emitStatement("objProxy.%1$s(ProxyUtils.createRealmListWithJsonStream(%2$s.class, reader))",
-                        metadata.getInternalSetter(fieldName),
-                        Utils.getRealmListType(field));
-            } else if (Utils.isMutableRealmInteger(field)) {
-                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
-                        "objProxy",
-                        metadata,
-                        metadata.getInternalGetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        writer
-                );
-            } else {
-                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
-                        "objProxy",
-                        metadata,
-                        metadata.getInternalSetter(fieldName),
-                        fieldName,
-                        qualifiedFieldType,
-                        writer
-                );
-            }
-        }
-
-        writer.nextControlFlow("else");
-        writer.emitStatement("reader.skipValue()");
-        writer.endControlFlow();
-
-        writer.endControlFlow();
-        writer.emitStatement("reader.endObject()");
-
-        if (metadata.hasPrimaryKey()) {
-            writer.beginControlFlow("if (!jsonHasPrimaryKey)")
-                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey())
-                    .endControlFlow();
-        }
-
-        writer.emitStatement("return realm.copyToRealm(obj)");
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private String columnInfoClassName() {
-        return simpleJavaClassName + "ColumnInfo";
-    }
-
-    /**
-     * Returns the name of the ColumnInfo class for the model class referenced in the field.
-     * I.e. for `com.test.Person`, it returns `Person.PersonColumnInfo`
-     */
-    private String columnInfoClassName(VariableElement field) {
-        String qualfiedModelClassName = Utils.getModelClassQualifiedName(field);
-        return Utils.getSimpleColumnInfoClassName(qualfiedModelClassName);
-    }
-
-    private String columnIndexVarName(VariableElement variableElement) {
-        return variableElement.getSimpleName().toString() + "Index";
-    }
-
-    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
-        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
-    }
-
-    private String fieldIndexVariableReference(VariableElement variableElement) {
-        return "columnInfo." + columnIndexVarName(variableElement);
-    }
-
-    private static int countModelOrListFields(Collection<RealmFieldElement> fields) {
-        int count = 0;
-        for (VariableElement f : fields) {
-            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
-                count++;
-            }
-        }
-        return count;
-    }
-
-    private Constants.RealmFieldType getRealmType(VariableElement field) {
-        String fieldTypeCanonicalName = field.asType().toString();
-        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
-        if (type != null) {
-            return type;
-        }
-        if (Utils.isMutableRealmInteger(field)) {
-            return Constants.RealmFieldType.REALM_INTEGER;
-        }
-        if (Utils.isRealmModel(field)) {
-            return Constants.RealmFieldType.OBJECT;
-        }
-        if (Utils.isRealmModelList(field)) {
-            return Constants.RealmFieldType.LIST;
-        }
-        if (Utils.isRealmValueList(field)) {
-            final Constants.RealmFieldType fieldType = Utils.getValueListFieldType(field);
-            if (fieldType == null) {
-                return Constants.RealmFieldType.NOTYPE;
-            }
-            return fieldType;
-        }
-        return Constants.RealmFieldType.NOTYPE;
-    }
-
-    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
-        Constants.RealmFieldType type = getRealmType(field);
-        if (type == Constants.RealmFieldType.NOTYPE) {
-            throw new IllegalStateException("Unsupported type " + field.asType().toString());
-        }
-        return type;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt
new file mode 100644
index 0000000000..985a6ec120
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.kt
@@ -0,0 +1,2012 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import com.squareup.javawriter.JavaWriter
+
+import java.io.BufferedWriter
+import java.io.IOException
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Collections
+import java.util.EnumSet
+import java.util.Locale
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Modifier
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.DeclaredType
+import javax.lang.model.type.TypeMirror
+
+import io.realm.processor.ext.beginMethod
+import io.realm.processor.ext.beginType
+
+/**
+ * This class is responsible for generating the Realm Proxy classes for each model class defined
+ * by the user. This is the main entrypoint for users interacting with Realm, but it is hidden
+ * from them as an implementation detail generated by the annotation processor.
+ *
+ * See [RealmProcessor] for a more detailed description on what files Realm creates internally and
+ * why.
+ *
+ * NOTE: This file will look strangely formatted to you. This is on purpose. The intent of the
+ * formatting it is to better represent the outputted code, not make _this_ code as readable as
+ * possible. This mean two things:
+ *
+ * 1. Attempt to keep code that emit a single line to one line here.
+ * 2. Attempt to indent the emit functions that would emulate the blocks created by the generated code.
+ */
+class RealmProxyClassGenerator(private val processingEnvironment: ProcessingEnvironment,
+                               private val typeMirrors: TypeMirrors,
+                               private val metadata: ClassMetaData,
+                               private val classCollection: ClassCollection) {
+
+    private val simpleJavaClassName: SimpleClassName = metadata.simpleJavaClassName
+    private val qualifiedJavaClassName: QualifiedClassName = metadata.qualifiedClassName
+    private val internalClassName: String = metadata.internalClassName
+    private val interfaceName: SimpleClassName = Utils.getProxyInterfaceName(qualifiedJavaClassName)
+    private val generatedClassName: QualifiedClassName = QualifiedClassName(String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(qualifiedJavaClassName)))
+    // See the configuration for the Android debug build type,
+    //  in the realm-library project, for an example of how to set this flag.
+    private val suppressWarnings: Boolean = !"false".equals(processingEnvironment.options[OPTION_SUPPRESS_WARNINGS], ignoreCase = true)
+
+    @Throws(IOException::class, UnsupportedOperationException::class)
+    fun generate() {
+        val sourceFile = processingEnvironment.filer.createSourceFile(generatedClassName.toString())
+
+        val imports = ArrayList(IMPORTS)
+        if (metadata.backlinkFields.isNotEmpty()) {
+            imports.add("io.realm.internal.UncheckedRow")
+        }
+
+        val writer = JavaWriter(BufferedWriter(sourceFile.openWriter()))
+        writer.apply {
+            indent = Constants.INDENT // Set source code indent
+            emitPackage(Constants.REALM_PACKAGE_NAME)
+            emitEmptyLine()
+            emitImports(imports)
+            emitEmptyLine()
+
+            // Begin the class definition
+            if (suppressWarnings) {
+                emitAnnotation("SuppressWarnings(\"all\")")
+            }
+            beginType(generatedClassName, "class", setOf(Modifier.PUBLIC), qualifiedJavaClassName, arrayOf("RealmObjectProxy", interfaceName.toString()))
+            emitEmptyLine()
+
+            // Emit class content
+            emitColumnInfoClass(writer)
+            emitClassFields(writer)
+            emitInstanceFields(writer)
+            emitConstructor(writer)
+            emitInjectContextMethod(writer)
+            emitPersistedFieldAccessors(writer)
+            emitBacklinkFieldAccessors(writer)
+            emitCreateExpectedObjectSchemaInfo(writer)
+            emitGetExpectedObjectSchemaInfo(writer)
+            emitCreateColumnInfoMethod(writer)
+            emitGetSimpleClassNameMethod(writer)
+            emitCreateOrUpdateUsingJsonObject(writer)
+            emitCreateUsingJsonStream(writer)
+            emitNewProxyInstance(writer)
+            emitCopyOrUpdateMethod(writer)
+            emitCopyMethod(writer)
+            emitInsertMethod(writer)
+            emitInsertListMethod(writer)
+            emitInsertOrUpdateMethod(writer)
+            emitInsertOrUpdateListMethod(writer)
+            emitCreateDetachedCopyMethod(writer)
+            emitUpdateMethod(writer)
+            emitToStringMethod(writer)
+            emitRealmObjectProxyImplementation(writer)
+            emitHashcodeMethod(writer)
+            emitEqualsMethod(writer)
+
+            // End the class definition
+            endType()
+            close()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitColumnInfoClass(writer: JavaWriter) {
+        writer.apply {
+            beginType(columnInfoClassName(), "class", EnumSet.of(Modifier.STATIC, Modifier.FINAL), "ColumnInfo")                               // base class
+
+            // fields
+            emitField("long", "maxColumnIndexValue") // Must not end with Index as it otherwise could conflict regular fields.
+            for (variableElement in metadata.fields) {
+                emitField("long", columnIndexVarName(variableElement))
+            }
+            emitEmptyLine()
+
+            // constructor #1
+            beginConstructor(EnumSet.noneOf(Modifier::class.java), "OsSchemaInfo", "schemaInfo")
+                emitStatement("super(%s)", metadata.fields.size)
+                emitStatement("OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"%1\$s\")", internalClassName)
+                for (field in metadata.fields) {
+                    emitStatement("this.%1\$sIndex = addColumnDetails(\"%1\$s\", \"%2\$s\", objectSchemaInfo)", field.javaName, field.internalFieldName)
+                }
+                for (backlink in metadata.backlinkFields) {
+                    emitStatement("addBacklinkDetails(schemaInfo, \"%s\", \"%s\", \"%s\")", backlink.targetField, classCollection.getClassFromQualifiedName(backlink.sourceClass!!).internalClassName, backlink.sourceField)
+                }
+                emitStatement("this.maxColumnIndexValue = objectSchemaInfo.getMaxColumnIndex()")
+            endConstructor()
+            emitEmptyLine()
+
+            // constructor #2
+            beginConstructor(EnumSet.noneOf(Modifier::class.java),"ColumnInfo", "src", "boolean", "mutable")
+                emitStatement("super(src, mutable)")
+                emitStatement("copy(src, this)")
+            endConstructor()
+            emitEmptyLine()
+
+            // no-args copy method
+            emitAnnotation("Override")
+            beginMethod("ColumnInfo", "copy", EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), "boolean", "mutable")
+                emitStatement("return new %s(this, mutable)", columnInfoClassName())
+            endMethod()
+            emitEmptyLine()
+
+            // copy method
+            emitAnnotation("Override")
+            beginMethod("void", "copy", EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst")
+                emitStatement("final %1\$s src = (%1\$s) rawSrc", columnInfoClassName())
+                emitStatement("final %1\$s dst = (%1\$s) rawDst", columnInfoClassName())
+                for (variableElement in metadata.fields) {
+                    emitStatement("dst.%1\$s = src.%1\$s", columnIndexVarName(variableElement))
+                }
+                emitStatement("dst.maxColumnIndexValue = src.maxColumnIndexValue")
+            endMethod()
+            endType()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitClassFields(writer: JavaWriter) {
+        writer.apply {
+            emitEmptyLine()
+            emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL),"createExpectedObjectSchemaInfo()")
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInstanceFields(writer: JavaWriter) {
+        writer.apply {
+            emitEmptyLine()
+            emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
+            emitField("ProxyState<$qualifiedJavaClassName>", "proxyState", EnumSet.of(Modifier.PRIVATE))
+
+            for (variableElement in metadata.fields) {
+                if (Utils.isMutableRealmInteger(variableElement)) {
+                    emitMutableRealmIntegerField(writer, variableElement)
+                } else if (Utils.isRealmList(variableElement)) {
+                    val genericType = Utils.getGenericTypeQualifiedName(variableElement)
+                    emitField("RealmList<$genericType>", variableElement.simpleName.toString() + "RealmList", EnumSet.of(Modifier.PRIVATE))
+                }
+            }
+
+            for (backlink in metadata.backlinkFields) {
+                emitField(backlink.targetFieldType, backlink.targetField + BACKLINKS_FIELD_EXTENSION, EnumSet.of(Modifier.PRIVATE))
+            }
+        }
+    }
+
+    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
+    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
+    // the MutableInteger that it owns, also becomes unreachable.
+    @Throws(IOException::class)
+    private fun emitMutableRealmIntegerField(writer: JavaWriter, variableElement: VariableElement) {
+        writer.apply {
+            emitField("MutableRealmInteger.Managed",
+                    mutableRealmIntegerFieldName(variableElement),
+                    EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
+                    String.format(
+                            "new MutableRealmInteger.Managed<%1\$s>() {\n"
+                                    + "    @Override protected ProxyState<%1\$s> getProxyState() { return proxyState; }\n"
+                                    + "    @Override protected long getColumnIndex() { return columnInfo.%2\$s; }\n"
+                                    + "}",
+                            qualifiedJavaClassName, columnIndexVarName(variableElement)))
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitConstructor(writer: JavaWriter) {
+        writer.apply {
+            emitEmptyLine()
+            beginConstructor(EnumSet.noneOf(Modifier::class.java))
+                emitStatement("proxyState.setConstructionFinished()")
+            endConstructor()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitPersistedFieldAccessors(writer: JavaWriter) {
+        for (field in metadata.fields) {
+            val fieldName = field.simpleName.toString()
+            val fieldTypeCanonicalName = field.asType().toString()
+            when {
+                Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName) -> emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName)
+                Utils.isMutableRealmInteger(field) -> emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName)
+                Utils.isRealmModel(field) -> emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName)
+                Utils.isRealmList(field) -> {
+                    val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+                    emitRealmList(writer, field, fieldName, fieldTypeCanonicalName, elementTypeMirror)
+                }
+                else -> throw UnsupportedOperationException(String.format(Locale.US, "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName))
+            }
+            writer.emitEmptyLine()
+        }
+    }
+
+    /**
+     * Emit Set/Get methods for Primitives and boxed types
+     */
+    @Throws(IOException::class)
+    private fun emitPrimitiveType(
+            writer: JavaWriter,
+            field: VariableElement,
+            fieldName: String,
+            fieldTypeCanonicalName: String) {
+
+        val fieldJavaType: String? = getRealmTypeChecked(field).javaType
+
+        writer.apply {
+            // Getter - Start
+            emitAnnotation("Override")
+            emitAnnotation("SuppressWarnings", "\"cast\"")
+            beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+
+                // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
+                if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
+                    beginControlFlow("if (proxyState.getRow\$realm().isNull(%s))", fieldIndexVariableReference(field))
+                        emitStatement("return null")
+                    endControlFlow()
+                }
+
+                // For Boxed types, this should be the corresponding primitive types. Others remain the same.
+                val castingBackType: String = if (Utils.isBoxedType(fieldTypeCanonicalName)) {
+                    val typeUtils = processingEnvironment.typeUtils
+                    typeUtils.unboxedType(field.asType()).toString()
+                } else {
+                    fieldTypeCanonicalName
+                }
+
+                emitStatement("return (%s) proxyState.getRow\$realm().get%s(%s)", castingBackType, fieldJavaType, fieldIndexVariableReference(field))
+            endMethod()
+            emitEmptyLine()
+            // Getter - End
+
+            // Setter - Start
+            emitAnnotation("Override")
+            beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value")
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field)) {
+                    // set value as default value
+                    emitStatement("final Row row = proxyState.getRow\$realm()")
+                    if (metadata.isNullable(field)) {
+                        beginControlFlow("if (value == null)")
+                            emitStatement("row.getTable().setNull(%s, row.getIndex(), true)", fieldIndexVariableReference(field))
+                            emitStatement("return")
+                        endControlFlow()
+                    } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                        beginControlFlow("if (value == null)")
+                            emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        endControlFlow()
+                    }
+                    emitStatement("row.getTable().set%s(%s, row.getIndex(), value, true)", fieldJavaType, fieldIndexVariableReference(field))
+                    emitStatement("return")
+                }
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+                // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
+                // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
+                if (metadata.isPrimaryKey(field)) {
+                    // Primary key is not allowed to be changed after object created.
+                    emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName)
+                } else {
+                    if (metadata.isNullable(field)) {
+                        beginControlFlow("if (value == null)")
+                            emitStatement("proxyState.getRow\$realm().setNull(%s)", fieldIndexVariableReference(field))
+                            emitStatement("return")
+                        endControlFlow()
+                    } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                        // Same reason, throw IAE earlier.
+                        beginControlFlow("if (value == null)")
+                            emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        endControlFlow()
+                    }
+                    emitStatement("proxyState.getRow\$realm().set%s(%s, value)", fieldJavaType, fieldIndexVariableReference(field))
+                }
+            endMethod()
+            // Setter - End
+        }
+    }
+
+    /**
+     * Emit Get method for mutable Realm Integer fields.
+     */
+    @Throws(IOException::class)
+    private fun emitMutableRealmInteger(writer: JavaWriter, field: VariableElement, fieldName: String, fieldTypeCanonicalName: String) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+                emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
+            endMethod()
+        }
+    }
+
+    /**
+     * Emit Set/Get methods for RealmModel fields.
+     */
+    @Throws(IOException::class)
+    private fun emitRealmModel(writer: JavaWriter,
+            field: VariableElement,
+            fieldName: String,
+            fieldTypeCanonicalName: String) {
+        writer.apply {
+            // Getter - Start
+            emitAnnotation("Override")
+            beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+                beginControlFlow("if (proxyState.getRow\$realm().isNullLink(%s))", fieldIndexVariableReference(field))
+                    emitStatement("return null")
+                endControlFlow()
+                emitStatement("return proxyState.getRealm\$realm().get(%s.class, proxyState.getRow\$realm().getLink(%s), false, Collections.<String>emptyList())", fieldTypeCanonicalName, fieldIndexVariableReference(field))
+            endMethod()
+            emitEmptyLine()
+            // Getter - End
+
+            // Setter - Start
+            emitAnnotation("Override")
+            beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value")
+                emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field)) {
+                    // check excludeFields
+                    beginControlFlow("if (proxyState.getExcludeFields\$realm().contains(\"%1\$s\"))", field.simpleName.toString())
+                        emitStatement("return")
+                    endControlFlow()
+                    beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
+                        emitStatement("value = ((Realm) proxyState.getRealm\$realm()).copyToRealm(value)")
+                    endControlFlow()
+
+                    // set value as default value
+                    emitStatement("final Row row = proxyState.getRow\$realm()")
+                    beginControlFlow("if (value == null)")
+                        emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                        emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                        emitStatement("return")
+                    endControlFlow()
+                    emitStatement("proxyState.checkValidObject(value)")
+                    emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet\$proxyState().getRow\$realm().getIndex(), true)", fieldIndexVariableReference(field))
+                    emitStatement("return")
+                }
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+                beginControlFlow("if (value == null)")
+                    emitStatement("proxyState.getRow\$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
+                    emitStatement("return")
+                endControlFlow()
+                emitStatement("proxyState.checkValidObject(value)")
+                emitStatement("proxyState.getRow\$realm().setLink(%s, ((RealmObjectProxy) value).realmGet\$proxyState().getRow\$realm().getIndex())", fieldIndexVariableReference(field))
+            endMethod()
+            // Setter - End
+        }
+    }
+
+    /**
+     * Emit Set/Get methods for Realm Model Lists and Lists of primitives.
+     */
+    @Throws(IOException::class)
+    private fun emitRealmList(
+            writer: JavaWriter,
+            field: VariableElement,
+            fieldName: String,
+            fieldTypeCanonicalName: String,
+            elementTypeMirror: TypeMirror?) {
+
+        val genericType: QualifiedClassName? = Utils.getGenericTypeQualifiedName(field)
+        val forRealmModel: Boolean = Utils.isRealmModel(elementTypeMirror)
+
+        writer.apply {
+            // Getter - Start
+            emitAnnotation("Override")
+            beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+                emitSingleLineComment("use the cached value if available")
+                beginControlFlow("if (${fieldName}RealmList != null)")
+                    emitStatement("return ${fieldName}RealmList")
+                nextControlFlow("else")
+                    if (Utils.isRealmModelList(field)) {
+                        emitStatement("OsList osList = proxyState.getRow\$realm().getModelList(%s)", fieldIndexVariableReference(field))
+                    } else {
+                        emitStatement("OsList osList = proxyState.getRow\$realm().getValueList(%1\$s, RealmFieldType.%2\$s)", fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name)
+                    }
+                    emitStatement("${fieldName}RealmList = new RealmList<%s>(%s.class, osList, proxyState.getRealm\$realm())", genericType, genericType)
+                    emitStatement("return ${fieldName}RealmList")
+                endControlFlow()
+            endMethod()
+            emitEmptyLine()
+            // Getter - End
+
+            // Setter - Start
+            emitAnnotation("Override")
+            beginMethod("void", metadata.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value")
+            emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field)) emitter@{
+                // check excludeFields
+                beginControlFlow("if (proxyState.getExcludeFields\$realm().contains(\"%1\$s\"))", field.simpleName.toString())
+                emitStatement("return")
+                endControlFlow()
+
+                if (!forRealmModel) {
+                    return@emitter
+                }
+
+                emitSingleLineComment("if the list contains unmanaged RealmObjects, convert them to managed.")
+                beginControlFlow("if (value != null && !value.isManaged())")
+                    emitStatement("final Realm realm = (Realm) proxyState.getRealm\$realm()")
+                    emitStatement("final RealmList<%1\$s> original = value", genericType)
+                    emitStatement("value = new RealmList<%1\$s>()", genericType)
+                    beginControlFlow("for (%1\$s item : original)", genericType)
+                        beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                            emitStatement("value.add(item)")
+                        nextControlFlow("else")
+                            emitStatement("value.add(realm.copyToRealm(item))")
+                        endControlFlow()
+                    endControlFlow()
+                endControlFlow()
+
+                // LinkView currently does not support default value feature. Just fallback to normal code.
+            }
+
+            emitStatement("proxyState.getRealm\$realm().checkIfValid()")
+            if (Utils.isRealmModelList(field)) {
+                emitStatement("OsList osList = proxyState.getRow\$realm().getModelList(%s)", fieldIndexVariableReference(field))
+            } else {
+                emitStatement("OsList osList = proxyState.getRow\$realm().getValueList(%1\$s, RealmFieldType.%2\$s)", fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name)
+            }
+            if (forRealmModel) {
+                // Model lists.
+                emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                    beginControlFlow("if (value != null && value.size() == osList.size())")
+                        emitStatement("int objects = value.size()")
+                        beginControlFlow("for (int i = 0; i < objects; i++)")
+                            emitStatement("%s linkedObject = value.get(i)", genericType)
+                            emitStatement("proxyState.checkValidObject(linkedObject)")
+                            emitStatement("osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet\$proxyState().getRow\$realm().getIndex())")
+                        endControlFlow()
+                        nextControlFlow("else")
+                            emitStatement("osList.removeAll()")
+                            beginControlFlow("if (value == null)")
+                                emitStatement("return")
+                            endControlFlow()
+                            emitStatement("int objects = value.size()")
+                            beginControlFlow("for (int i = 0; i < objects; i++)")
+                            emitStatement("%s linkedObject = value.get(i)", genericType)
+                            emitStatement("proxyState.checkValidObject(linkedObject)")
+                            emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet\$proxyState().getRow\$realm().getIndex())")
+                        endControlFlow()
+                    endControlFlow()
+            } else {
+                // Value lists
+                emitStatement("osList.removeAll()")
+                beginControlFlow("if (value == null)")
+                    emitStatement("return")
+                    endControlFlow()
+                    beginControlFlow("for (%1\$s item : value)", genericType)
+                        beginControlFlow("if (item == null)")
+                            emitStatement(if (metadata.isElementNullable(field)) "osList.addNull()" else "throw new IllegalArgumentException(\"Storing 'null' into $fieldName' is not allowed by the schema.\")")
+                        nextControlFlow("else")
+                            emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
+                        endControlFlow()
+                    endControlFlow()
+            }
+            endMethod()
+            // Setter - End
+        }
+    }
+
+    private fun getStatementForAppendingValueToOsList(
+            osListVariableName: String,
+            valueVariableName: String,
+            elementTypeMirror: TypeMirror?): String {
+
+        val typeUtils = processingEnvironment.typeUtils
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.STRING_MIRROR)) {
+            return "$osListVariableName.addString($valueVariableName)"
+        }
+        if ((typeUtils.isSameType(elementTypeMirror, typeMirrors.LONG_MIRROR)
+                        || typeUtils.isSameType(elementTypeMirror, typeMirrors.INTEGER_MIRROR)
+                        || typeUtils.isSameType(elementTypeMirror, typeMirrors.SHORT_MIRROR)
+                        || typeUtils.isSameType(elementTypeMirror, typeMirrors.BYTE_MIRROR))) {
+            return "$osListVariableName.addLong($valueVariableName.longValue())"
+        }
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BINARY_MIRROR)) {
+            return "$osListVariableName.addBinary($valueVariableName)"
+        }
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DATE_MIRROR)) {
+            return "$osListVariableName.addDate($valueVariableName)"
+        }
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BOOLEAN_MIRROR)) {
+            return "$osListVariableName.addBoolean($valueVariableName)"
+        }
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DOUBLE_MIRROR)) {
+            return "$osListVariableName.addDouble($valueVariableName.doubleValue())"
+        }
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.FLOAT_MIRROR)) {
+            return "$osListVariableName.addFloat($valueVariableName.floatValue())"
+        }
+        throw RuntimeException("unexpected element type: $elementTypeMirror")
+    }
+
+    @Throws(IOException::class)
+    private fun emitCodeForUnderConstruction(writer: JavaWriter, isPrimaryKey: Boolean, emitCode: () -> Unit) {
+        writer.apply {
+            beginControlFlow("if (proxyState.isUnderConstruction())")
+                if (isPrimaryKey) {
+                    emitSingleLineComment("default value of the primary key is always ignored.")
+                    emitStatement("return")
+                } else {
+                    beginControlFlow("if (!proxyState.getAcceptDefaultValue\$realm())")
+                        emitStatement("return")
+                    endControlFlow()
+                    emitCode()
+                }
+            endControlFlow()
+            emitEmptyLine()
+        }
+    }
+
+    // Note that because of bytecode hackery, this method may run before the constructor!
+    // It may even run before fields have been initialized.
+    @Throws(IOException::class)
+    private fun emitInjectContextMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("void","realm\$injectObjectContext", EnumSet.of(Modifier.PUBLIC))
+                beginControlFlow("if (this.proxyState != null)")
+                    emitStatement("return")
+                endControlFlow()
+                emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
+                emitStatement("this.columnInfo = (%1\$s) context.getColumnInfo()", columnInfoClassName())
+                emitStatement("this.proxyState = new ProxyState<%1\$s>(this)", qualifiedJavaClassName)
+                emitStatement("proxyState.setRealm\$realm(context.getRealm())")
+                emitStatement("proxyState.setRow\$realm(context.getRow())")
+                emitStatement("proxyState.setAcceptDefaultValue\$realm(context.getAcceptDefaultValue())")
+                emitStatement("proxyState.setExcludeFields\$realm(context.getExcludeFields())")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitBacklinkFieldAccessors(writer: JavaWriter) {
+        for (backlink in metadata.backlinkFields) {
+            val cacheFieldName = backlink.targetField + BACKLINKS_FIELD_EXTENSION
+            val realmResultsType = "RealmResults<" + backlink.sourceClass + ">"
+            // Getter, no setter
+            writer.apply {
+                emitAnnotation("Override")
+                beginMethod(realmResultsType, metadata.getInternalGetter(backlink.targetField), EnumSet.of(Modifier.PUBLIC))
+                    emitStatement("BaseRealm realm = proxyState.getRealm\$realm()")
+                    emitStatement("realm.checkIfValid()")
+                    emitStatement("proxyState.getRow\$realm().checkIfAttached()")
+                    beginControlFlow("if ($cacheFieldName == null)")
+                        emitStatement("$cacheFieldName = RealmResults.createBacklinkResults(realm, proxyState.getRow\$realm(), %s.class, \"%s\")", backlink.sourceClass, backlink.sourceField)
+                    endControlFlow()
+                    emitStatement("return $cacheFieldName")
+                endMethod()
+                emitEmptyLine()
+            }
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitRealmObjectProxyImplementation(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("ProxyState<?>", "realmGet\$proxyState", EnumSet.of(Modifier.PUBLIC))
+                emitStatement("return proxyState")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateExpectedObjectSchemaInfo(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("OsObjectSchemaInfo", "createExpectedObjectSchemaInfo", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC))
+                // Guess capacity for Arrays used by OsObjectSchemaInfo.
+                // Used to prevent array resizing at runtime
+                val persistedFields = metadata.fields.size
+                val computedFields = metadata.backlinkFields.size
+
+                emitStatement("OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)", internalClassName, persistedFields, computedFields)
+
+                // For each field generate corresponding table index constant
+                for (field in metadata.fields) {
+                    val fieldName = field.internalFieldName
+
+                    when (val fieldType = getRealmTypeChecked(field)) {
+                        Constants.RealmFieldType.NOTYPE -> {
+                            // Perhaps this should fail quickly?
+                        }
+                        Constants.RealmFieldType.OBJECT -> {
+                            val fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field)
+                            val internalClassName = Utils.getReferencedTypeInternalClassNameStatement(fieldTypeQualifiedName, classCollection)
+                            emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, %s)", fieldName, internalClassName)
+                        }
+                        Constants.RealmFieldType.LIST -> {
+                            val genericTypeQualifiedName = Utils.getGenericTypeQualifiedName(field)
+                            val internalClassName = Utils.getReferencedTypeInternalClassNameStatement(genericTypeQualifiedName, classCollection)
+                            emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, %s)", fieldName, internalClassName)
+                        }
+                        Constants.RealmFieldType.INTEGER_LIST,
+                        Constants.RealmFieldType.BOOLEAN_LIST,
+                        Constants.RealmFieldType.STRING_LIST,
+                        Constants.RealmFieldType.BINARY_LIST,
+                        Constants.RealmFieldType.DATE_LIST,
+                        Constants.RealmFieldType.FLOAT_LIST,
+                        Constants.RealmFieldType.DOUBLE_LIST -> {
+                            val requiredFlag = if (metadata.isElementNullable(field)) "!Property.REQUIRED" else "Property.REQUIRED"
+                            emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)", fieldName, fieldType.realmType, requiredFlag)
+                        }
+                        Constants.RealmFieldType.BACKLINK -> {
+                            throw IllegalArgumentException("LinkingObject field should not be added to metadata")
+                        }
+                        Constants.RealmFieldType.INTEGER,
+                        Constants.RealmFieldType.FLOAT,
+                        Constants.RealmFieldType.DOUBLE,
+                        Constants.RealmFieldType.BOOLEAN,
+                        Constants.RealmFieldType.STRING,
+                        Constants.RealmFieldType.DATE,
+                        Constants.RealmFieldType.BINARY,
+                        Constants.RealmFieldType.REALM_INTEGER -> {
+                            val nullableFlag = (if (metadata.isNullable(field)) "!" else "") + "Property.REQUIRED"
+                            val indexedFlag = (if (metadata.isIndexed(field)) "" else "!") + "Property.INDEXED"
+                            val primaryKeyFlag = (if (metadata.isPrimaryKey(field)) "" else "!") + "Property.PRIMARY_KEY"
+                            emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)", fieldName, fieldType.realmType, primaryKeyFlag, indexedFlag, nullableFlag)
+                        }
+                    }
+                }
+                for (backlink in metadata.backlinkFields) {
+                    // Backlinks can only be created between classes in the current round of annotation processing
+                    // as the forward link cannot be created unless you know the type already.
+                    val sourceClass = classCollection.getClassFromQualifiedName(backlink.sourceClass!!)
+                    val targetField = backlink.targetField // Only in the model, so no internal name exists
+                    val internalSourceField = sourceClass.getInternalFieldName(backlink.sourceField!!)
+                    emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")", targetField, sourceClass.internalClassName, internalSourceField)
+                }
+                emitStatement("return builder.build()")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitGetExpectedObjectSchemaInfo(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("OsObjectSchemaInfo", "getExpectedObjectSchemaInfo", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
+                emitStatement("return expectedObjectSchemaInfo")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateColumnInfoMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod(columnInfoClassName(), "createColumnInfo", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), "OsSchemaInfo", "schemaInfo")
+                emitStatement("return new %1\$s(schemaInfo)", columnInfoClassName())
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitGetSimpleClassNameMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("String", "getSimpleClassName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
+                emitStatement("return \"%s\"", internalClassName)
+            endMethod()
+            emitEmptyLine()
+
+            // Helper class for the annotation processor so it can access the internal class name
+            // without needing to load the parent class (which we cannot do as it transitively loads
+            // native code, which cannot be loaded on the JVM).
+            beginType("ClassNameHelper", "class", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL))
+                emitField("String", "INTERNAL_CLASS_NAME", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL), "\"$internalClassName\"")
+            endType()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitNewProxyInstance(writer: JavaWriter) {
+        writer.apply {
+            beginMethod(generatedClassName, "newProxyInstance", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC), "BaseRealm", "realm", "Row", "row")
+                emitSingleLineComment("Ignore default values to avoid creating unexpected objects from RealmModel/RealmList fields")
+                emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                emitStatement("objectContext.set(realm, row, realm.getSchema().getColumnInfo(%s.class), false, Collections.<String>emptyList())", qualifiedJavaClassName)
+                emitStatement("%1\$s obj = new %1\$s()", generatedClassName)
+                emitStatement("objectContext.clear()")
+                emitStatement("return obj")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCopyOrUpdateMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod(qualifiedJavaClassName,"copyOrUpdate", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
+                    "Realm", "realm",
+                    columnInfoClassName(), "columnInfo",
+                    qualifiedJavaClassName.toString(), "object",
+                    "boolean", "update",
+                    "Map<RealmModel,RealmObjectProxy>", "cache",
+                    "Set<ImportFlag>", "flags")
+
+                beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm() != null)")
+                    emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm()")
+                    beginControlFlow("if (otherRealm.threadId != realm.threadId)")
+                        emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
+                    endControlFlow()
+
+                    // If object is already in the Realm there is nothing to update
+                    beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
+                        emitStatement("return object")
+                    endControlFlow()
+                endControlFlow()
+                emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
+                beginControlFlow("if (cachedRealmObject != null)")
+                    emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
+                endControlFlow()
+                emitEmptyLine()
+
+                if (!metadata.hasPrimaryKey()) {
+                    emitStatement("return copy(realm, columnInfo, object, update, cache, flags)")
+                } else {
+                    emitStatement("%s realmObject = null", qualifiedJavaClassName)
+                    emitStatement("boolean canUpdate = update")
+                    beginControlFlow("if (canUpdate)")
+                        emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                        emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+
+                        val primaryKeyGetter = metadata.primaryKeyGetter
+                        val primaryKeyElement = metadata.primaryKey
+                        if (metadata.isNullable(primaryKeyElement!!)) {
+                            if (Utils.isString(primaryKeyElement)) {
+                                emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                                emitStatement("long rowIndex = Table.NO_MATCH")
+                                beginControlFlow("if (value == null)")
+                                    emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                                nextControlFlow("else")
+                                    emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                                endControlFlow()
+                            } else {
+                                emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                                emitStatement("long rowIndex = Table.NO_MATCH")
+                                beginControlFlow("if (value == null)")
+                                    emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                                nextControlFlow("else")
+                                    emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                                endControlFlow()
+                            }
+                        } else {
+                            val pkType = if (Utils.isString(metadata.primaryKey)) "String" else "Long"
+                            emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())", pkType, interfaceName, primaryKeyGetter)
+                        }
+
+                        beginControlFlow("if (rowIndex == Table.NO_MATCH)")
+                            emitStatement("canUpdate = false")
+                        nextControlFlow("else")
+                            beginControlFlow("try")
+                                emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex), columnInfo, false, Collections.<String> emptyList())")
+                                emitStatement("realmObject = new %s()", generatedClassName)
+                                emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                            nextControlFlow("finally")
+                                emitStatement("objectContext.clear()")
+                            endControlFlow()
+                        endControlFlow()
+                    endControlFlow()
+                    emitEmptyLine()
+                    emitStatement("return (canUpdate) ? update(realm, columnInfo, realmObject, object, cache, flags) : copy(realm, columnInfo, object, update, cache, flags)")
+                }
+
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+   
+    @Throws(IOException::class)
+    private fun setTableValues(writer: JavaWriter, fieldType: String, fieldName: String, interfaceName: SimpleClassName, getter: String, isUpdate: Boolean) {
+        writer.apply {
+            when(fieldType) {
+                "long",
+                "int",
+                "short",
+                "byte" -> {
+                    emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter)
+                }
+                "java.lang.Long",
+                "java.lang.Integer",
+                "java.lang.Short",
+                "java.lang.Byte" -> {
+                    emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "io.realm.MutableRealmInteger" -> {
+                    emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "double" -> {
+                    emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter)
+                }
+                "java.lang.Double" -> {
+                    emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "float" -> {
+                    emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter)
+                }
+                "java.lang.Float" -> {
+                    emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "boolean" -> {
+                    emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter)
+                }
+                "java.lang.Boolean" -> {
+                    emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "byte[]" -> {
+                    emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "java.util.Date" -> {
+                    emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                "java.lang.String" -> {
+                    emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    beginControlFlow("if (%s != null)", getter)
+                        emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter)
+                        if (isUpdate) {
+                            nextControlFlow("else")
+                                emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName)
+                        }
+                    endControlFlow()
+                }
+                else -> {
+                    throw IllegalStateException("Unsupported type $fieldType")
+                }
+            }
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("long","insert", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), "Realm", "realm", qualifiedJavaClassName.toString(), "object", "Map<RealmModel,Long>", "cache")
+
+            // If object is already in the Realm there is nothing to update
+            beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm() != null && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm().getPath().equals(realm.getPath()))")
+                emitStatement("return ((RealmObjectProxy) object).realmGet\$proxyState().getRow\$realm().getIndex()")
+            endControlFlow()
+
+            emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+            emitStatement("long tableNativePtr = table.getNativePtr()")
+            emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
+
+            if (metadata.hasPrimaryKey()) {
+                emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+            }
+            addPrimaryKeyCheckIfNeeded(metadata, true, writer)
+
+            for (field in metadata.fields) {
+                val fieldName = field.simpleName.toString()
+                val fieldType = field.asType().toString()
+                val getter = metadata.getInternalGetter(fieldName)
+
+                when {
+                    Utils.isRealmModel(field) -> {
+                        emitEmptyLine()
+                        emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        beginControlFlow("if (%sObj != null)", fieldName)
+                            emitStatement("Long cache%1\$s = cache.get(%1\$sObj)", fieldName)
+                            beginControlFlow("if (cache%s == null)", fieldName)
+                                emitStatement("cache%s = %s.insert(realm, %sObj, cache)", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                            endControlFlow()
+                            emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1\$sIndex, rowIndex, cache%1\$s, false)", fieldName)
+                        endControlFlow()
+                    }
+                    Utils.isRealmModelList(field) -> {
+                        val genericType = Utils.getGenericTypeQualifiedName(field)
+                        emitEmptyLine()
+                        emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                        beginControlFlow("if (%sList != null)", fieldName)
+                            emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                            beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                                beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    emitStatement("cacheItemIndex%1\$s = %2\$s.insert(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                endControlFlow()
+                                emitStatement("%1\$sOsList.addRow(cacheItemIndex%1\$s)", fieldName)
+                            endControlFlow()
+                        endControlFlow()
+                    }
+                    Utils.isRealmValueList(field) -> {
+                        val genericType = Utils.getGenericTypeQualifiedName(field)
+                        val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+                        emitEmptyLine()
+                        emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                        beginControlFlow("if (%sList != null)", fieldName)
+                            emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                            beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                beginControlFlow("if (%1\$sItem == null)", fieldName)
+                                    emitStatement(fieldName + "OsList.addNull()")
+                                nextControlFlow("else")
+                                    emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                                endControlFlow()
+                            endControlFlow()
+                        endControlFlow()
+                    }
+                    else -> {
+                        if (metadata.primaryKey !== field) {
+                            setTableValues(writer, fieldType, fieldName, interfaceName, getter, false)
+                        }
+                    }
+                }
+            }
+
+            emitStatement("return rowIndex")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertListMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("void", "insert", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache")
+                emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                emitStatement("long tableNativePtr = table.getNativePtr()")
+                emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
+                if (metadata.hasPrimaryKey()) {
+                    emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+                }
+                emitStatement("%s object = null", qualifiedJavaClassName)
+
+                beginControlFlow("while (objects.hasNext())")
+                    emitStatement("object = (%s) objects.next()", qualifiedJavaClassName)
+                    beginControlFlow("if (cache.containsKey(object))")
+                        emitStatement("continue")
+                    endControlFlow()
+                    beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm() != null && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm().getPath().equals(realm.getPath()))")
+                        emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet\$proxyState().getRow\$realm().getIndex())")
+                        emitStatement("continue")
+                    endControlFlow()
+
+                    addPrimaryKeyCheckIfNeeded(metadata, true, writer)
+
+                    for (field in metadata.fields) {
+                        val fieldName = field.simpleName.toString()
+                        val fieldType = field.asType().toString()
+                        val getter = metadata.getInternalGetter(fieldName)
+
+                        if (Utils.isRealmModel(field)) {
+                            emitEmptyLine()
+                            emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                            beginControlFlow("if (%sObj != null)", fieldName)
+                                emitStatement("Long cache%1\$s = cache.get(%1\$sObj)", fieldName)
+                                beginControlFlow("if (cache%s == null)", fieldName)
+                                    emitStatement("cache%s = %s.insert(realm, %sObj, cache)", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                                endControlFlow()
+                                emitStatement("table.setLink(columnInfo.%1\$sIndex, rowIndex, cache%1\$s, false)", fieldName)
+                            endControlFlow()
+                        } else if (Utils.isRealmModelList(field)) {
+                            val genericType = Utils.getGenericTypeQualifiedName(field)
+                            emitEmptyLine()
+                            emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                            beginControlFlow("if (%sList != null)", fieldName)
+                                emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                                beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                    emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                                    beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                        emitStatement("cacheItemIndex%1\$s = %2\$s.insert(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                    endControlFlow()
+                                    emitStatement("%1\$sOsList.addRow(cacheItemIndex%1\$s)", fieldName)
+                                endControlFlow()
+                            endControlFlow()
+                        } else if (Utils.isRealmValueList(field)) {
+                            val genericType = Utils.getGenericTypeQualifiedName(field)
+                            val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+                            emitEmptyLine()
+                            emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                            beginControlFlow("if (%sList != null)", fieldName)
+                                emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                                beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                    beginControlFlow("if (%1\$sItem == null)", fieldName)
+                                        emitStatement("%1\$sOsList.addNull()", fieldName)
+                                    nextControlFlow("else")
+                                        emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                                    endControlFlow()
+                                endControlFlow()
+                            endControlFlow()
+                        } else {
+                            if (metadata.primaryKey !== field) {
+                                setTableValues(writer, fieldType, fieldName, interfaceName, getter, false)
+                            }
+                        }
+                    }
+                endControlFlow()
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertOrUpdateMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("long", "insertOrUpdate", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), "Realm", "realm", qualifiedJavaClassName.toString(), "object", "Map<RealmModel,Long>", "cache")
+
+            // If object is already in the Realm there is nothing to update
+            beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm() != null && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm().getPath().equals(realm.getPath()))")
+                emitStatement("return ((RealmObjectProxy) object).realmGet\$proxyState().getRow\$realm().getIndex()")
+            endControlFlow()
+            emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+            emitStatement("long tableNativePtr = table.getNativePtr()")
+            emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
+
+            if (metadata.hasPrimaryKey()) {
+                emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+            }
+            addPrimaryKeyCheckIfNeeded(metadata, false, writer)
+
+            for (field in metadata.fields) {
+                val fieldName = field.simpleName.toString()
+                val fieldType = field.asType().toString()
+                val getter = metadata.getInternalGetter(fieldName)
+
+                if (Utils.isRealmModel(field)) {
+                    emitEmptyLine()
+                    emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                    beginControlFlow("if (%sObj != null)", fieldName)
+                        emitStatement("Long cache%1\$s = cache.get(%1\$sObj)", fieldName)
+                        beginControlFlow("if (cache%s == null)", fieldName)
+                            emitStatement("cache%1\$s = %2\$s.insertOrUpdate(realm, %1\$sObj, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                        endControlFlow()
+                        emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1\$sIndex, rowIndex, cache%1\$s, false)", fieldName)
+                    nextControlFlow("else")
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                    endControlFlow()
+                } else if (Utils.isRealmModelList(field)) {
+                    val genericType = Utils.getGenericTypeQualifiedName(field)
+                    emitEmptyLine()
+                    emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                    emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    beginControlFlow("if (%1\$sList != null && %1\$sList.size() == %1\$sOsList.size())", fieldName)
+                        emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        emitStatement("int objects = %1\$sList.size()", fieldName)
+                        beginControlFlow("for (int i = 0; i < objects; i++)")
+                            emitStatement("%1\$s %2\$sItem = %2\$sList.get(i)", genericType, fieldName)
+                            emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                            beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                emitStatement("cacheItemIndex%1\$s = %2\$s.insertOrUpdate(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                            endControlFlow()
+                            emitStatement("%1\$sOsList.setRow(i, cacheItemIndex%1\$s)", fieldName)
+                        endControlFlow()
+                    nextControlFlow("else")
+                        emitStatement("%1\$sOsList.removeAll()", fieldName)
+                        beginControlFlow("if (%sList != null)", fieldName)
+                            beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                                beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    emitStatement("cacheItemIndex%1\$s = %2\$s.insertOrUpdate(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                endControlFlow()
+                                emitStatement("%1\$sOsList.addRow(cacheItemIndex%1\$s)", fieldName)
+                            endControlFlow()
+                        endControlFlow()
+                    endControlFlow()
+                    emitEmptyLine()
+                } else if (Utils.isRealmValueList(field)) {
+                    val genericType = Utils.getGenericTypeQualifiedName(field)
+                    val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+                    emitEmptyLine()
+                    emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                    emitStatement("%1\$sOsList.removeAll()", fieldName)
+                    emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    beginControlFlow("if (%sList != null)", fieldName)
+                        beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                            beginControlFlow("if (%1\$sItem == null)", fieldName)
+                                emitStatement("%1\$sOsList.addNull()", fieldName)
+                            nextControlFlow("else")
+                                emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                            endControlFlow()
+                        endControlFlow()
+                    endControlFlow()
+                    emitEmptyLine()
+                } else {
+                    if (metadata.primaryKey !== field) {
+                        setTableValues(writer, fieldType, fieldName, interfaceName, getter, true)
+                    }
+                }
+            }
+
+            emitStatement("return rowIndex")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertOrUpdateListMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod("void", "insertOrUpdate", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache")
+                emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                emitStatement("long tableNativePtr = table.getNativePtr()")
+                emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
+                if (metadata.hasPrimaryKey()) {
+                    emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+                }
+                emitStatement("%s object = null", qualifiedJavaClassName)
+                beginControlFlow("while (objects.hasNext())")
+                    emitStatement("object = (%s) objects.next()", qualifiedJavaClassName)
+                    beginControlFlow("if (cache.containsKey(object))")
+                        emitStatement("continue")
+                    endControlFlow()
+
+                    beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm() != null && ((RealmObjectProxy) object).realmGet\$proxyState().getRealm\$realm().getPath().equals(realm.getPath()))")
+                        emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet\$proxyState().getRow\$realm().getIndex())")
+                        emitStatement("continue")
+                    endControlFlow()
+                    addPrimaryKeyCheckIfNeeded(metadata, false, writer)
+
+                    for (field in metadata.fields) {
+                        val fieldName = field.simpleName.toString()
+                        val fieldType = field.asType().toString()
+                        val getter = metadata.getInternalGetter(fieldName)
+
+                        when {
+                            Utils.isRealmModel(field) -> {
+                                emitEmptyLine()
+                                emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                                beginControlFlow("if (%sObj != null)", fieldName)
+                                    emitStatement("Long cache%1\$s = cache.get(%1\$sObj)", fieldName)
+                                    beginControlFlow("if (cache%s == null)", fieldName)
+                                        emitStatement("cache%1\$s = %2\$s.insertOrUpdate(realm, %1\$sObj, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                    endControlFlow()
+                                    emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1\$sIndex, rowIndex, cache%1\$s, false)", fieldName)
+                                nextControlFlow("else")
+                                    // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                                    emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                                endControlFlow()
+                            }
+                            Utils.isRealmModelList(field) -> {
+                                val genericType = Utils.getGenericTypeQualifiedName(field)
+                                emitEmptyLine()
+                                emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                                emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                                beginControlFlow("if (%1\$sList != null && %1\$sList.size() == %1\$sOsList.size())", fieldName)
+                                    emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                                    emitStatement("int objectCount = %1\$sList.size()", fieldName)
+                                    beginControlFlow("for (int i = 0; i < objectCount; i++)")
+                                        emitStatement("%1\$s %2\$sItem = %2\$sList.get(i)", genericType, fieldName)
+                                        emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                                        beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                            emitStatement("cacheItemIndex%1\$s = %2\$s.insertOrUpdate(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                        endControlFlow()
+                                        emitStatement("%1\$sOsList.setRow(i, cacheItemIndex%1\$s)", fieldName)
+                                    endControlFlow()
+                                nextControlFlow("else")
+                                    emitStatement("%1\$sOsList.removeAll()", fieldName)
+                                    beginControlFlow("if (%sList != null)", fieldName)
+                                        beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                            emitStatement("Long cacheItemIndex%1\$s = cache.get(%1\$sItem)", fieldName)
+                                            beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                                emitStatement("cacheItemIndex%1\$s = %2\$s.insertOrUpdate(realm, %1\$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                            endControlFlow()
+                                            emitStatement("%1\$sOsList.addRow(cacheItemIndex%1\$s)", fieldName)
+                                        endControlFlow()
+                                    endControlFlow()
+                                endControlFlow()
+                                emitEmptyLine()
+                            }
+                            Utils.isRealmValueList(field) -> {
+                                val genericType = Utils.getGenericTypeQualifiedName(field)
+                                val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+                                emitEmptyLine()
+                                emitStatement("OsList %1\$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1\$sIndex)", fieldName)
+                                emitStatement("%1\$sOsList.removeAll()", fieldName)
+                                emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                                beginControlFlow("if (%sList != null)", fieldName)
+                                   beginControlFlow("for (%1\$s %2\$sItem : %2\$sList)", genericType, fieldName)
+                                        beginControlFlow("if (%1\$sItem == null)", fieldName)
+                                            emitStatement("%1\$sOsList.addNull()", fieldName)
+                                        nextControlFlow("else")
+                                            emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                                        endControlFlow()
+                                    endControlFlow()
+                                endControlFlow()
+                                emitEmptyLine()
+                            }
+                            else -> {
+                                if (metadata.primaryKey !== field) {
+                                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true)
+                                }
+                            }
+                        }
+                    }
+                endControlFlow()
+            endMethod()
+            emitEmptyLine()            
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun addPrimaryKeyCheckIfNeeded(metadata: ClassMetaData, throwIfPrimaryKeyDuplicate: Boolean, writer: JavaWriter) {
+        writer.apply {
+            if (metadata.hasPrimaryKey()) {
+                val primaryKeyGetter = metadata.primaryKeyGetter
+                val primaryKeyElement = metadata.primaryKey
+                if (metadata.isNullable(primaryKeyElement!!)) {
+                    if (Utils.isString(primaryKeyElement)) {
+                        emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        emitStatement("long rowIndex = Table.NO_MATCH")
+                        beginControlFlow("if (primaryKeyValue == null)")
+                            emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                        nextControlFlow("else")
+                            emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
+                        endControlFlow()
+                    } else {
+                        emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        emitStatement("long rowIndex = Table.NO_MATCH")
+                        beginControlFlow("if (primaryKeyValue == null)")
+                            emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                        nextControlFlow("else")
+                            emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                        endControlFlow()
+                    }
+                } else {
+                    emitStatement("long rowIndex = Table.NO_MATCH")
+                    emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                    beginControlFlow("if (primaryKeyValue != null)")
+                        if (Utils.isString(metadata.primaryKey)) {
+                            emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)")
+                        } else {
+                            emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                        }
+                    endControlFlow()
+                }
+
+                beginControlFlow("if (rowIndex == Table.NO_MATCH)")
+                    if (Utils.isString(metadata.primaryKey)) {
+                        emitStatement("rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue)")
+                    } else {
+                        emitStatement("rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                    }
+    
+                    if (throwIfPrimaryKeyDuplicate) {
+                        nextControlFlow("else")
+                        emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)")
+                    }
+                endControlFlow()
+                emitStatement("cache.put(object, rowIndex)")
+            } else {
+                emitStatement("long rowIndex = OsObject.createRow(table)")
+                emitStatement("cache.put(object, rowIndex)")
+            }
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCopyMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod(qualifiedJavaClassName, "copy", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
+                    "Realm", "realm",
+                    columnInfoClassName(), "columnInfo",
+                    qualifiedJavaClassName.toString(), "newObject",
+                    "boolean", "update",
+                    "Map<RealmModel,RealmObjectProxy>", "cache",
+                    "Set<ImportFlag>", "flags"
+            )
+                emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)")
+                beginControlFlow("if (cachedRealmObject != null)")
+                    emitStatement("return (%s) cachedRealmObject", qualifiedJavaClassName)
+                endControlFlow()
+                emitEmptyLine()
+                emitStatement("%1\$s realmObjectSource = (%1\$s) newObject", interfaceName)
+                emitEmptyLine()
+                emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)")
+
+                // Copy basic types
+                emitEmptyLine()
+                emitSingleLineComment("Add all non-\"object reference\" fields")
+                for (field in metadata.getBasicTypeFields()) {
+                    val fieldIndex = fieldIndexVariableReference(field)
+                    val fieldName = field.simpleName.toString()
+                    val getter = metadata.getInternalGetter(fieldName)
+                    emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter)
+                }
+
+                // Create the underlying object
+                emitEmptyLine()
+                emitSingleLineComment("Create the underlying object and cache it before setting any object/objectlist references")
+                emitSingleLineComment("This will allow us to break any circular dependencies by using the object cache.")
+                emitStatement("Row row = builder.createNewObject()")
+                emitStatement("%s realmObjectCopy = newProxyInstance(realm, row)", generatedClassName)
+                emitStatement("cache.put(newObject, realmObjectCopy)")
+
+                // Copy all object references or lists-of-objects
+                emitEmptyLine()
+                if (metadata.objectReferenceFields.isNotEmpty()) {
+                    emitSingleLineComment("Finally add all fields that reference other Realm Objects, either directly or through a list")
+                }
+                for (field in metadata.objectReferenceFields) {
+                    val fieldType = field.asType().toString()
+                    val fieldName = field.simpleName.toString()
+                    val getter = metadata.getInternalGetter(fieldName)
+                    val setter = metadata.getInternalSetter(fieldName)
+
+                    when {
+                        Utils.isRealmModel(field) -> {
+                            emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
+                            beginControlFlow("if (%sObj == null)", fieldName)
+                                emitStatement("realmObjectCopy.%s(null)", setter)
+                            nextControlFlow("else")
+                                emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                                beginControlFlow("if (cache%s != null)", fieldName)
+                                    emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
+                                nextControlFlow("else")
+                                    emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, update, cache, flags))", setter, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
+                                endControlFlow()
+                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            endControlFlow()
+                            emitEmptyLine()
+                        }
+                        Utils.isRealmModelList(field) -> {
+                            val genericType = Utils.getGenericTypeQualifiedName(field)
+                            emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
+                            beginControlFlow("if (%sList != null)", fieldName)
+                                emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()", genericType, fieldName, getter)
+                                // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
+                                emitStatement("%sRealmList.clear()", fieldName)
+                                beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                    emitStatement("%1\$s %2\$sItem = %2\$sList.get(i)", genericType, fieldName)
+                                    emitStatement("%1\$s cache%2\$s = (%1\$s) cache.get(%2\$sItem)", genericType, fieldName)
+                                    beginControlFlow("if (cache%s != null)", fieldName)
+                                        emitStatement("%1\$sRealmList.add(cache%1\$s)", fieldName)
+                                    nextControlFlow("else")
+                                        emitStatement("%1\$sRealmList.add(%2\$s.copyOrUpdate(realm, (%3\$s) realm.getSchema().getColumnInfo(%4\$s.class), %1\$sItem, update, cache, flags))", fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
+                                    endControlFlow()
+                                endControlFlow()
+                            endControlFlow()
+                            emitEmptyLine()
+                        }
+                        else -> {
+                            throw IllegalStateException("Unsupported field: $field")
+                        }
+                    }
+                }
+                emitStatement("return realmObjectCopy")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateDetachedCopyMethod(writer: JavaWriter) {
+        writer.apply {
+            beginMethod(qualifiedJavaClassName, "createDetachedCopy", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), qualifiedJavaClassName.toString(), "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache")
+                beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
+                    emitStatement("return null")
+                endControlFlow()
+                emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
+                emitStatement("%s unmanagedObject", qualifiedJavaClassName)
+                beginControlFlow("if (cachedObject == null)")
+                    emitStatement("unmanagedObject = new %s()", qualifiedJavaClassName)
+                    emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
+                nextControlFlow("else")
+                    emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
+                    beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
+                        emitStatement("return (%s) cachedObject.object", qualifiedJavaClassName)
+                    endControlFlow()
+                    emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedJavaClassName)
+                    emitStatement("cachedObject.minDepth = currentDepth")
+                endControlFlow()
+
+                // may cause an unused variable warning if the object contains only null lists
+                emitStatement("%1\$s unmanagedCopy = (%1\$s) unmanagedObject", interfaceName)
+                emitStatement("%1\$s realmSource = (%1\$s) realmObject", interfaceName)
+
+                for (field in metadata.fields) {
+                    val fieldName = field.simpleName.toString()
+                    val setter = metadata.getInternalSetter(fieldName)
+                    val getter = metadata.getInternalGetter(fieldName)
+                    when {
+                        Utils.isRealmModel(field) -> {
+                            emitEmptyLine()
+                            emitSingleLineComment("Deep copy of %s", fieldName)
+                            emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))", setter, Utils.getProxyClassSimpleName(field), getter)
+                        }
+                        Utils.isRealmModelList(field) -> {
+                            emitEmptyLine()
+                            emitSingleLineComment("Deep copy of %s", fieldName)
+                            beginControlFlow("if (currentDepth == maxDepth)")
+                                emitStatement("unmanagedCopy.%s(null)", setter)
+                            nextControlFlow("else")
+                                emitStatement("RealmList<%s> managed%sList = realmSource.%s()", Utils.getGenericTypeQualifiedName(field), fieldName, getter)
+                                emitStatement("RealmList<%1\$s> unmanaged%2\$sList = new RealmList<%1\$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
+                                emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
+                                emitStatement("int nextDepth = currentDepth + 1")
+                                emitStatement("int size = managed%sList.size()", fieldName)
+                                beginControlFlow("for (int i = 0; i < size; i++)")
+                                    emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)", Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
+                                    emitStatement("unmanaged%sList.add(item)", fieldName)
+                                endControlFlow()
+                            endControlFlow()
+                        }
+                        Utils.isRealmValueList(field) -> {
+                            emitEmptyLine()
+                            emitStatement("unmanagedCopy.%1\$s(new RealmList<%2\$s>())", setter, Utils.getGenericTypeQualifiedName(field))
+                            emitStatement("unmanagedCopy.%1\$s().addAll(realmSource.%1\$s())", getter)
+                        }
+                        Utils.isMutableRealmInteger(field) -> // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
+                            emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter)
+                        else -> {
+                            emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter)
+                        }
+                    }
+                }
+                emitEmptyLine()
+                emitStatement("return unmanagedObject")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+   
+    @Throws(IOException::class)
+    private fun emitUpdateMethod(writer: JavaWriter) {
+        if (!metadata.hasPrimaryKey()) {
+            return
+        }
+        writer.apply {
+            beginMethod(qualifiedJavaClassName, "update", EnumSet.of(Modifier.STATIC),
+                    "Realm", "realm", // Argument type & argument name
+                    columnInfoClassName(), "columnInfo",
+                    qualifiedJavaClassName.toString(), "realmObject",
+                    qualifiedJavaClassName.toString(), "newObject",
+                    "Map<RealmModel, RealmObjectProxy>", "cache",
+                    "Set<ImportFlag>", "flags"
+            )
+                emitStatement("%1\$s realmObjectTarget = (%1\$s) realmObject", interfaceName)
+                emitStatement("%1\$s realmObjectSource = (%1\$s) newObject", interfaceName)
+                emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                emitStatement("OsObjectBuilder builder = new OsObjectBuilder(table, columnInfo.maxColumnIndexValue, flags)")
+                for (field in metadata.fields) {
+                    val fieldType = field.asType().toString()
+                    val fieldName = field.simpleName.toString()
+                    val getter = metadata.getInternalGetter(fieldName)
+                    val fieldIndex = fieldIndexVariableReference(field)
+
+                    when {
+                        Utils.isRealmModel(field) -> {
+                            emitEmptyLine()
+                            emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
+                            beginControlFlow("if (%sObj == null)", fieldName)
+                                emitStatement("builder.addNull(%s)", fieldIndexVariableReference(field))
+                            nextControlFlow("else")
+                                emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                                beginControlFlow("if (cache%s != null)", fieldName)
+                                    emitStatement("builder.addObject(%s, cache%s)", fieldIndex, fieldName)
+                                nextControlFlow("else")
+                                    emitStatement("builder.addObject(%s, %s.copyOrUpdate(realm, (%s) realm.getSchema().getColumnInfo(%s.class), %sObj, true, cache, flags))", fieldIndex, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getFieldTypeQualifiedName(field), fieldName)
+                                endControlFlow()
+                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            endControlFlow()
+                        }
+                        Utils.isRealmModelList(field) -> {
+                            val genericType = Utils.getGenericTypeQualifiedName(field)
+                            emitEmptyLine()
+                            emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
+                            beginControlFlow("if (%sList != null)", fieldName)
+                                emitStatement("RealmList<%s> %sManagedCopy = new RealmList<%s>()", genericType, fieldName, genericType)
+                                beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                    emitStatement("%1\$s %2\$sItem = %2\$sList.get(i)", genericType, fieldName)
+                                    emitStatement("%1\$s cache%2\$s = (%1\$s) cache.get(%2\$sItem)", genericType, fieldName)
+                                    beginControlFlow("if (cache%s != null)", fieldName)
+                                        emitStatement("%1\$sManagedCopy.add(cache%1\$s)", fieldName)
+                                    nextControlFlow("else")
+                                        emitStatement("%1\$sManagedCopy.add(%2\$s.copyOrUpdate(realm, (%3\$s) realm.getSchema().getColumnInfo(%4\$s.class), %1\$sItem, true, cache, flags))", fieldName, Utils.getProxyClassSimpleName(field), columnInfoClassName(field), Utils.getGenericTypeQualifiedName(field))
+                                    endControlFlow()
+                                endControlFlow()
+                                emitStatement("builder.addObjectList(%s, %sManagedCopy)", fieldIndex, fieldName)
+                            nextControlFlow("else")
+                                emitStatement("builder.addObjectList(%s, new RealmList<%s>())", fieldIndex, genericType)
+                            endControlFlow()
+                        }
+                        else -> {
+                            emitStatement("builder.%s(%s, realmObjectSource.%s())", OsObjectBuilderTypeHelper.getOsObjectBuilderName(field), fieldIndex, getter)
+                        }
+                    }
+                }
+                emitEmptyLine()
+                emitStatement("builder.updateExistingObject()")
+                emitStatement("return realmObject")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitToStringMethod(writer: JavaWriter) {
+        if (metadata.containsToString()) {
+            return
+        }
+        writer.apply {
+            emitAnnotation("Override")
+            emitAnnotation("SuppressWarnings", "\"ArrayToString\"")
+            beginMethod("String", "toString", EnumSet.of(Modifier.PUBLIC))
+                beginControlFlow("if (!RealmObject.isValid(this))")
+                    emitStatement("return \"Invalid object\"")
+                endControlFlow()
+                emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleJavaClassName)
+
+                val fields = metadata.fields
+                var i = fields.size - 1
+                for (field in fields) {
+                    val fieldName = field.simpleName.toString()
+                    emitStatement("stringBuilder.append(\"{%s:\")", fieldName)
+                    when {
+                        Utils.isRealmModel(field) -> {
+                            val fieldTypeSimpleName = Utils.getFieldTypeQualifiedName(field).getSimpleName()
+                            emitStatement("stringBuilder.append(%s() != null ? \"%s\" : \"null\")", metadata.getInternalGetter(fieldName), fieldTypeSimpleName)
+                        }
+                        Utils.isRealmList(field) -> {
+                            val genericTypeSimpleName = Utils.getGenericTypeQualifiedName(field)?.getSimpleName()
+                            emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")", genericTypeSimpleName, metadata.getInternalGetter(fieldName))
+                        }
+                        Utils.isMutableRealmInteger(field) -> {
+                            emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName))
+                        }
+                        else -> {
+                            if (metadata.isNullable(field)) {
+                                emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")", metadata.getInternalGetter(fieldName), metadata.getInternalGetter(fieldName))
+                            } else {
+                                emitStatement("stringBuilder.append(%s())", metadata.getInternalGetter(fieldName))
+                            }
+                        }
+                    }
+                    emitStatement("stringBuilder.append(\"}\")")
+
+                    if (i-- > 0) {
+                        emitStatement("stringBuilder.append(\",\")")
+                    }
+                }
+
+                emitStatement("stringBuilder.append(\"]\")")
+                emitStatement("return stringBuilder.toString()")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    /**
+     * Currently, the hash value emitted from this could suddenly change as an object's index might
+     * alternate due to Realm Java using `Table#moveLastOver()`. Hash codes should therefore not
+     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
+     */
+    @Throws(IOException::class)
+    private fun emitHashcodeMethod(writer: JavaWriter) {
+        if (metadata.containsHashCode()) {
+            return
+        }
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
+                emitStatement("String realmName = proxyState.getRealm\$realm().getPath()")
+                emitStatement("String tableName = proxyState.getRow\$realm().getTable().getName()")
+                emitStatement("long rowIndex = proxyState.getRow\$realm().getIndex()")
+                emitEmptyLine()
+                emitStatement("int result = 17")
+                emitStatement("result = 31 * result + ((realmName != null) ? realmName.hashCode() : 0)")
+                emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
+                emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
+                emitStatement("return result")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+   
+
+   
+    @Throws(IOException::class)
+    private fun emitEqualsMethod(writer: JavaWriter) {
+        if (metadata.containsEquals()) {
+            return
+        }
+        val proxyClassName = Utils.getProxyClassName(qualifiedJavaClassName)
+        val otherObjectVarName = "a$simpleJavaClassName"
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
+                emitStatement("if (this == o) return true")
+                emitStatement("if (o == null || getClass() != o.getClass()) return false")
+                emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
+                emitEmptyLine()
+                emitStatement("String path = proxyState.getRealm\$realm().getPath()")
+                emitStatement("String otherPath = %s.proxyState.getRealm\$realm().getPath()", otherObjectVarName)
+                emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false")
+                emitEmptyLine()
+                emitStatement("String tableName = proxyState.getRow\$realm().getTable().getName()")
+                emitStatement("String otherTableName = %s.proxyState.getRow\$realm().getTable().getName()", otherObjectVarName)
+                emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false")
+                emitEmptyLine()
+                emitStatement("if (proxyState.getRow\$realm().getIndex() != %s.proxyState.getRow\$realm().getIndex()) return false", otherObjectVarName)
+                emitEmptyLine()
+                emitStatement("return true")
+            endMethod()
+        }
+    }
+   
+    @Throws(IOException::class)
+    private fun emitCreateOrUpdateUsingJsonObject(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("SuppressWarnings", "\"cast\"")
+            beginMethod(qualifiedJavaClassName,"createOrUpdateUsingJsonObject", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"), listOf("JSONException"))
+            val modelOrListCount = countModelOrListFields(metadata.fields)
+            if (modelOrListCount == 0) {
+                emitStatement("final List<String> excludeFields = Collections.<String> emptyList()")
+            } else {
+                emitStatement("final List<String> excludeFields = new ArrayList<String>(%1\$d)", modelOrListCount)
+            }
+
+            if (!metadata.hasPrimaryKey()) {
+                buildExcludeFieldsList(writer, metadata.fields)
+                emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)", qualifiedJavaClassName, qualifiedJavaClassName)
+            } else {
+                val pkType = if (Utils.isString(metadata.primaryKey)) "String" else "Long"
+                emitStatement("%s obj = null", qualifiedJavaClassName)
+                beginControlFlow("if (update)")
+                    emitStatement("Table table = realm.getTable(%s.class)", qualifiedJavaClassName)
+                    emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)", columnInfoClassName(), columnInfoClassName(), qualifiedJavaClassName)
+                    emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.primaryKey))
+                    emitStatement("long rowIndex = Table.NO_MATCH")
+                    if (metadata.isNullable(metadata.primaryKey!!)) {
+                        beginControlFlow("if (json.isNull(\"%s\"))", metadata.primaryKey!!.simpleName)
+                            emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                        nextControlFlow("else")
+                            emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))", pkType, pkType, metadata.primaryKey!!.simpleName)
+                        endControlFlow()
+                    } else {
+                        beginControlFlow("if (!json.isNull(\"%s\"))", metadata.primaryKey!!.simpleName)
+                            emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))", pkType, pkType, metadata.primaryKey!!.simpleName)
+                        endControlFlow()
+                    }
+                    beginControlFlow("if (rowIndex != Table.NO_MATCH)")
+                        emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                        beginControlFlow("try")
+                            emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())", qualifiedJavaClassName)
+                            emitStatement("obj = new %s()", generatedClassName)
+                        nextControlFlow("finally")
+                            emitStatement("objectContext.clear()")
+                        endControlFlow()
+                    endControlFlow()
+                endControlFlow()
+
+                beginControlFlow("if (obj == null)")
+                    buildExcludeFieldsList(writer, metadata.fields)
+                    val primaryKeyFieldType = QualifiedClassName(metadata.primaryKey!!.asType().toString())
+                    val primaryKeyFieldName = metadata.primaryKey!!.simpleName.toString()
+                    RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedJavaClassName, generatedClassName, primaryKeyFieldType, primaryKeyFieldName, writer)
+                endControlFlow()
+            }
+            emitEmptyLine()
+            emitStatement("final %1\$s objProxy = (%1\$s) obj", interfaceName)
+            for (field in metadata.fields) {
+                val fieldName = field.simpleName.toString()
+                val qualifiedFieldType = QualifiedClassName(field.asType().toString())
+                if (metadata.isPrimaryKey(field)) {
+                    continue  // Primary key has already been set when adding new row or finding the existing row.
+                }
+                when {
+                    Utils.isRealmModel(field) -> RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
+                            "objProxy",
+                            metadata.getInternalSetter(fieldName),
+                            fieldName,
+                            qualifiedFieldType,
+                            Utils.getProxyClassSimpleName(field),
+                            writer)
+                    Utils.isRealmModelList(field) -> RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
+                            "objProxy",
+                            metadata.getInternalGetter(fieldName),
+                            metadata.getInternalSetter(fieldName),
+                            fieldName,
+                            (field.asType() as DeclaredType).typeArguments[0].toString(),
+                            Utils.getProxyClassSimpleName(field),
+                            writer)
+                    Utils.isRealmValueList(field) -> emitStatement("ProxyUtils.setRealmListWithJsonObject(objProxy.%1\$s(), json, \"%2\$s\")", metadata.getInternalGetter(fieldName), fieldName)
+                    Utils.isMutableRealmInteger(field) -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                            "objProxy",
+                            metadata.getInternalGetter(fieldName),
+                            fieldName,
+                            qualifiedFieldType,
+                            writer)
+                    else -> RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                            "objProxy",
+                            metadata.getInternalSetter(fieldName),
+                            fieldName,
+                            qualifiedFieldType,
+                            writer
+                    )
+                }
+            }
+            emitStatement("return obj")
+            endMethod()
+            emitEmptyLine()            
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun buildExcludeFieldsList(writer: JavaWriter, fields: Collection<RealmFieldElement>) {
+        writer.apply {
+            for (field in fields) {
+                if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
+                    val fieldName = field.simpleName.toString()
+                    beginControlFlow("if (json.has(\"%1\$s\"))", fieldName)
+                        emitStatement("excludeFields.add(\"%1\$s\")", fieldName)
+                    endControlFlow()
+                }
+            }
+        }
+    }
+
+    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
+    // instead of createObject() to avoid parsing the stream twice.
+    @Throws(IOException::class)
+    private fun emitCreateUsingJsonStream(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("SuppressWarnings", "\"cast\"")
+            emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB")
+            beginMethod(qualifiedJavaClassName,"createUsingJsonStream", setOf(Modifier.PUBLIC, Modifier.STATIC), listOf("Realm", "realm", "JsonReader", "reader"), listOf("IOException"))
+            if (metadata.hasPrimaryKey()) {
+                emitStatement("boolean jsonHasPrimaryKey = false")
+            }
+            emitStatement("final %s obj = new %s()", qualifiedJavaClassName, qualifiedJavaClassName)
+            emitStatement("final %1\$s objProxy = (%1\$s) obj", interfaceName)
+            emitStatement("reader.beginObject()")
+            beginControlFlow("while (reader.hasNext())")
+                emitStatement("String name = reader.nextName()")
+                beginControlFlow("if (false)")
+                val fields = metadata.fields
+                for (field in fields) {
+                    val fieldName = field.simpleName.toString()
+                    val fieldType = QualifiedClassName(field.asType().toString())
+                    nextControlFlow("else if (name.equals(\"%s\"))", fieldName)
+
+                    when {
+                        Utils.isRealmModel(field) -> {
+                            RealmJsonTypeHelper.emitFillRealmObjectFromStream(
+                                    "objProxy",
+                                    metadata.getInternalSetter(fieldName),
+                                    fieldName,
+                                    fieldType,
+                                    Utils.getProxyClassSimpleName(field),
+                                    writer)
+                        }
+                        Utils.isRealmModelList(field) -> {
+                            RealmJsonTypeHelper.emitFillRealmListFromStream(
+                                    "objProxy",
+                                    metadata.getInternalGetter(fieldName),
+                                    metadata.getInternalSetter(fieldName),
+                                    QualifiedClassName((field.asType() as DeclaredType).typeArguments[0].toString()),
+                                    Utils.getProxyClassSimpleName(field),
+                                    writer)
+                        }
+                        Utils.isRealmValueList(field) -> {
+                            emitStatement("objProxy.%1\$s(ProxyUtils.createRealmListWithJsonStream(%2\$s.class, reader))", metadata.getInternalSetter(fieldName), Utils.getRealmListType(field))
+                        }
+                        Utils.isMutableRealmInteger(field) -> {
+                            RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                                    "objProxy",
+                                    metadata,
+                                    metadata.getInternalGetter(fieldName),
+                                    fieldName,
+                                    fieldType,
+                                    writer)
+                        }
+                        else -> {
+                            RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                                    "objProxy",
+                                    metadata,
+                                    metadata.getInternalSetter(fieldName),
+                                    fieldName,
+                                    fieldType,
+                                    writer)
+                        }
+                    }
+                }
+
+                nextControlFlow("else")
+                    emitStatement("reader.skipValue()")
+                endControlFlow()
+            endControlFlow()
+            emitStatement("reader.endObject()")
+            if (metadata.hasPrimaryKey()) {
+                beginControlFlow("if (!jsonHasPrimaryKey)")
+                    emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.primaryKey)
+                endControlFlow()
+            }
+            emitStatement("return realm.copyToRealm(obj)")
+            endMethod()
+            emitEmptyLine()            
+        }
+    }
+
+    private fun columnInfoClassName(): String {
+        return "${simpleJavaClassName}ColumnInfo"
+    }
+
+    /**
+     * Returns the name of the ColumnInfo class for the model class referenced in the field.
+     * I.e. for `com.test.Person`, it returns `Person.PersonColumnInfo`
+     */
+    private fun columnInfoClassName(field: VariableElement): String {
+        val qualifiedModelClassName = Utils.getModelClassQualifiedName(field)
+        return Utils.getSimpleColumnInfoClassName(qualifiedModelClassName)
+    }
+
+    private fun columnIndexVarName(variableElement: VariableElement): String {
+        return "${variableElement.simpleName}Index"
+    }
+
+    private fun mutableRealmIntegerFieldName(variableElement: VariableElement): String {
+        return "${variableElement.simpleName}MutableRealmInteger"
+    }
+
+    private fun fieldIndexVariableReference(variableElement: VariableElement?): String {
+        return "columnInfo.${columnIndexVarName(variableElement!!)}"
+    }
+
+    private fun getRealmType(field: VariableElement): Constants.RealmFieldType {
+        val fieldTypeCanonicalName: String = field.asType().toString()
+        val type: Constants.RealmFieldType? = Constants.JAVA_TO_REALM_TYPES[fieldTypeCanonicalName]
+        if (type != null) {
+            return type
+        }
+        if (Utils.isMutableRealmInteger(field)) {
+            return Constants.RealmFieldType.REALM_INTEGER
+        }
+        if (Utils.isRealmModel(field)) {
+            return Constants.RealmFieldType.OBJECT
+        }
+        if (Utils.isRealmModelList(field)) {
+            return Constants.RealmFieldType.LIST
+        }
+        if (Utils.isRealmValueList(field)) {
+            return Utils.getValueListFieldType(field)
+        }
+        return Constants.RealmFieldType.NOTYPE
+    }
+
+    private fun getRealmTypeChecked(field: VariableElement): Constants.RealmFieldType {
+        val type = getRealmType(field)
+        if (type === Constants.RealmFieldType.NOTYPE) {
+            throw IllegalStateException("Unsupported type " + field.asType().toString())
+        }
+        return type
+    }
+
+    companion object {
+        private val OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings"
+        private val BACKLINKS_FIELD_EXTENSION = "Backlinks"
+
+        private val IMPORTS: List<String>
+
+        init {
+            val l = Arrays.asList(
+                    "android.annotation.TargetApi",
+                    "android.os.Build",
+                    "android.util.JsonReader",
+                    "android.util.JsonToken",
+                    "io.realm.ImportFlag",
+                    "io.realm.exceptions.RealmMigrationNeededException",
+                    "io.realm.internal.ColumnInfo",
+                    "io.realm.internal.OsList",
+                    "io.realm.internal.OsObject",
+                    "io.realm.internal.OsSchemaInfo",
+                    "io.realm.internal.OsObjectSchemaInfo",
+                    "io.realm.internal.Property",
+                    "io.realm.internal.objectstore.OsObjectBuilder",
+                    "io.realm.ProxyUtils",
+                    "io.realm.internal.RealmObjectProxy",
+                    "io.realm.internal.Row",
+                    "io.realm.internal.Table",
+                    "io.realm.internal.android.JsonUtils",
+                    "io.realm.log.RealmLog",
+                    "java.io.IOException",
+                    "java.util.ArrayList",
+                    "java.util.Collections",
+                    "java.util.List",
+                    "java.util.Iterator",
+                    "java.util.Date",
+                    "java.util.Map",
+                    "java.util.HashMap",
+                    "java.util.Set",
+                    "org.json.JSONObject",
+                    "org.json.JSONException",
+                    "org.json.JSONArray")
+            IMPORTS = Collections.unmodifiableList(l)
+        }
+
+        private fun countModelOrListFields(fields: Collection<RealmFieldElement>): Int {
+            var count = 0
+            for (f in fields) {
+                if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
+                    count++
+                }
+            }
+            return count
+        }
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
deleted file mode 100644
index 94e3727902..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.EnumSet;
-import java.util.Locale;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-import javax.tools.JavaFileObject;
-
-import io.realm.annotations.Ignore;
-
-
-public class RealmProxyInterfaceGenerator {
-    private ProcessingEnvironment processingEnvironment;
-    private ClassMetaData metaData;
-    private final String className;
-
-    public RealmProxyInterfaceGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metaData) {
-        this.processingEnvironment = processingEnvironment;
-        this.metaData = metaData;
-        this.className = metaData.getFullyQualifiedClassName();
-    }
-
-    public void generate() throws IOException {
-        String qualifiedGeneratedInterfaceName =
-                String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
-        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedInterfaceName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-
-        writer.setIndent(Constants.INDENT);
-
-        writer
-                .emitPackage(Constants.REALM_PACKAGE_NAME)
-                .emitEmptyLine()
-                .beginType(qualifiedGeneratedInterfaceName, "interface", EnumSet.of(Modifier.PUBLIC));
-        for (VariableElement field : metaData.getFields()) {
-            if (field.getModifiers().contains(Modifier.STATIC) || (field.getAnnotation(Ignore.class) != null)) {
-                continue;
-            }
-            // The field is neither static nor ignored
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
-            writer
-                    .beginMethod(
-                            fieldTypeCanonicalName,
-                            metaData.getInternalGetter(fieldName),
-                            EnumSet.of(Modifier.PUBLIC))
-                    .endMethod();
-
-            // MutableRealmIntegers do not have setters.
-            if (Utils.isMutableRealmInteger(field)) { continue; }
-            writer
-                    .beginMethod(
-                            "void",
-                            metaData.getInternalSetter(fieldName),
-                            EnumSet.of(Modifier.PUBLIC),
-                            fieldTypeCanonicalName,
-                            "value")
-                    .endMethod();
-        }
-
-        // backlinks are final and have only a getter.
-        for (Backlink backlink : metaData.getBacklinkFields()) {
-            writer
-                    .beginMethod(
-                            backlink.getTargetFieldType(),
-                            metaData.getInternalGetter(backlink.getTargetField()),
-                            EnumSet.of(Modifier.PUBLIC))
-                    .endMethod();
-        }
-
-        writer.endType();
-        writer.close();
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.kt
new file mode 100644
index 0000000000..4f0ec896c0
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.kt
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor
+
+import com.squareup.javawriter.JavaWriter
+
+import java.io.BufferedWriter
+import java.io.IOException
+import java.util.EnumSet
+import java.util.Locale
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Modifier
+
+import io.realm.annotations.Ignore
+
+
+class RealmProxyInterfaceGenerator(private val processingEnvironment: ProcessingEnvironment, private val metaData: ClassMetaData) {
+
+    private val className: QualifiedClassName = metaData.qualifiedClassName
+
+    @Throws(IOException::class)
+    fun generate() {
+        val qualifiedGeneratedInterfaceName = String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className))
+        val sourceFile = processingEnvironment.filer.createSourceFile(qualifiedGeneratedInterfaceName)
+        val writer = JavaWriter(BufferedWriter(sourceFile.openWriter()!!))
+        writer.apply {
+            indent = Constants.INDENT
+            emitPackage(Constants.REALM_PACKAGE_NAME)
+            emitEmptyLine()
+            beginType(qualifiedGeneratedInterfaceName, "interface", EnumSet.of(Modifier.PUBLIC))
+
+            for (field in metaData.fields) {
+                if (field.modifiers.contains(Modifier.STATIC) || field.getAnnotation(Ignore::class.java) != null) {
+                    continue
+                }
+                // The field is neither static nor ignored
+                val fieldName = field.simpleName.toString()
+                val fieldTypeCanonicalName = field.asType().toString()
+                beginMethod(fieldTypeCanonicalName, metaData.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                endMethod()
+
+                // MutableRealmIntegers do not have setters.
+                if (Utils.isMutableRealmInteger(field)) {
+                    continue
+                }
+                beginMethod("void", metaData.getInternalSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value")
+                endMethod()
+            }
+
+            // backlinks are final and have only a getter.
+            for (backlink in metaData.backlinkFields) {
+                beginMethod(backlink.targetFieldType, metaData.getInternalGetter(backlink.targetField), EnumSet.of(Modifier.PUBLIC))
+                endMethod()
+            }
+
+            endType()
+            close()
+        }
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
deleted file mode 100644
index b67ac2bea8..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.tools.JavaFileObject;
-
-import io.realm.annotations.RealmModule;
-
-import static io.realm.processor.Constants.REALM_PACKAGE_NAME;
-
-
-public class RealmProxyMediatorGenerator {
-    private final String className;
-    private final ProcessingEnvironment processingEnvironment;
-    private final List<String> qualifiedModelClasses = new ArrayList<>();
-    private final List<String> qualifiedProxyClasses = new ArrayList<>();
-    private final List<String> simpleModelClassNames = new ArrayList<>();
-    private final List<String> internalClassNames = new ArrayList<>();
-
-
-    public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
-            String className, Set<ClassMetaData> classesToValidate) {
-        this.processingEnvironment = processingEnvironment;
-        this.className = className;
-
-        for (ClassMetaData metadata : classesToValidate) {
-            qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
-            String qualifiedProxyClassName = REALM_PACKAGE_NAME + "." + Utils.getProxyClassName(metadata.getFullyQualifiedClassName());
-            qualifiedProxyClasses.add(qualifiedProxyClassName);
-            simpleModelClassNames.add(metadata.getSimpleJavaClassName());
-            internalClassNames.add(metadata.getInternalClassName());
-        }
-    }
-
-    public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%sMediator", REALM_PACKAGE_NAME, className);
-        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-        writer.setIndent("    ");
-
-        writer.emitPackage(REALM_PACKAGE_NAME);
-        writer.emitEmptyLine();
-
-        List<String> imports  = new ArrayList<>(Arrays.asList("android.util.JsonReader",
-                "java.io.IOException",
-                "java.util.Collections",
-                "java.util.HashSet",
-                "java.util.List",
-                "java.util.Map",
-                "java.util.HashMap",
-                "java.util.Set",
-                "java.util.Iterator",
-                "java.util.Collection",
-                "io.realm.ImportFlag",
-                "io.realm.internal.ColumnInfo",
-                "io.realm.internal.RealmObjectProxy",
-                "io.realm.internal.RealmProxyMediator",
-                "io.realm.internal.Row",
-                "io.realm.internal.OsSchemaInfo",
-                "io.realm.internal.OsObjectSchemaInfo",
-                "org.json.JSONException",
-                "org.json.JSONObject"));
-
-        writer.emitImports(imports);
-        writer.emitEmptyLine();
-
-        writer.emitAnnotation(RealmModule.class);
-        writer.beginType(
-                qualifiedGeneratedClassName,        // full qualified name of the item to generate
-                "class",                            // the type of the item
-                Collections.<Modifier>emptySet(),   // modifiers to apply
-                "RealmProxyMediator");              // class to extend
-        writer.emitEmptyLine();
-
-        emitFields(writer);
-        emitGetExpectedObjectSchemaInfoMap(writer);
-        emitCreateColumnInfoMethod(writer);
-        emitGetSimpleClassNameMethod(writer);
-        emitNewInstanceMethod(writer);
-        emitGetClassModelList(writer);
-        emitCopyOrUpdateMethod(writer);
-        emitInsertObjectToRealmMethod(writer);
-        emitInsertListToRealmMethod(writer);
-        emitInsertOrUpdateObjectToRealmMethod(writer);
-        emitInsertOrUpdateListToRealmMethod(writer);
-        emitCreteOrUpdateUsingJsonObject(writer);
-        emitCreateUsingJsonStream(writer);
-        emitCreateDetachedCopyMethod(writer);
-        writer.endType();
-        writer.close();
-    }
-
-    private void emitFields(JavaWriter writer) throws IOException {
-        writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
-        writer.beginInitializer(true);
-        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(%s)", qualifiedModelClasses.size());
-        for (String clazz : qualifiedModelClasses) {
-            writer.emitStatement("modelClasses.add(%s.class)", clazz);
-        }
-        writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableSet(modelClasses)");
-        writer.endInitializer();
-        writer.emitEmptyLine();
-    }
-
-    private void emitGetExpectedObjectSchemaInfoMap(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo>",
-                "getExpectedObjectSchemaInfoMap",
-                EnumSet.of(Modifier.PUBLIC));
-
-        writer.emitStatement(
-                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = " +
-                        "new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(%s)", qualifiedProxyClasses.size());
-        for (int i = 0; i < qualifiedProxyClasses.size(); i++) {
-            writer.emitStatement("infoMap.put(%s.class, %s.getExpectedObjectSchemaInfo())",
-                    qualifiedModelClasses.get(i), qualifiedProxyClasses.get(i));
-        }
-        writer.emitStatement("return infoMap");
-
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "ColumnInfo",
-                "createColumnInfo",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", // Argument type & argument name
-                "OsSchemaInfo", "schemaInfo"
-        );
-
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.createColumnInfo(schemaInfo)",
-                        qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "String",
-                "getSimpleClassNameImpl",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz"
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return \"%s\"", internalClassNames.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmModel> E",
-                "newInstance",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<E>", "clazz",
-                "Object", "baseRealm",
-                "Row", "row",
-                "ColumnInfo", "columnInfo",
-                "boolean", "acceptDefaultValue",
-                "List<String>", "excludeFields"
-        );
-        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
-        writer.beginControlFlow("try")
-                .emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)");
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.nextControlFlow("finally")
-                .emitStatement("objectContext.clear()")
-                .endControlFlow();
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitGetClassModelList(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod("Set<Class<? extends RealmModel>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
-        writer.emitStatement("return MODEL_CLASSES");
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmModel> E",
-                "copyOrUpdate",
-                EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm",
-                "E", "obj",
-                "boolean", "update",
-                "Map<RealmModel, RealmObjectProxy>", "cache",
-                "Set<ImportFlag>", "flags"
-        );
-        writer.emitSingleLineComment("This cast is correct because obj is either");
-        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
-        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
-        writer.emitEmptyLine();
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%1$s columnInfo = (%1$s) realm.getSchema().getColumnInfo(%2$s.class)", Utils.getSimpleColumnInfoClassName(qualifiedModelClasses.get(i)), qualifiedModelClasses.get(i));
-                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, columnInfo, (%s) obj, update, cache, flags))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitInsertObjectToRealmMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "void",
-                "insert",
-                EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "RealmModel", "object", "Map<RealmModel, Long>", "cache");
-        writer.emitSingleLineComment("This cast is correct because obj is either");
-        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
-        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())");
-        writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitInsertOrUpdateObjectToRealmMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "void",
-                "insertOrUpdate",
-                EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "RealmModel", "obj", "Map<RealmModel, Long>", "cache");
-        writer.emitSingleLineComment("This cast is correct because obj is either");
-        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
-        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
-        writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insertOrUpdate(realm, (%s) obj, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitInsertOrUpdateListToRealmMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "void",
-                "insertOrUpdate",
-                EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
-
-        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
-        writer.emitStatement("RealmModel object = null");
-        writer.emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())");
-
-        writer.beginControlFlow("if (iterator.hasNext())")
-                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
-                .emitStatement("object = iterator.next()")
-                .emitSingleLineComment("This cast is correct because obj is either")
-                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
-                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
-                .emitEmptyLine();
-
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insertOrUpdate(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-
-        writer.beginControlFlow("if (iterator.hasNext())");
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insertOrUpdate(realm, iterator, cache)", qualifiedProxyClasses.get(i));
-            }
-        }, writer, false);
-        writer.endControlFlow();
-        writer.endControlFlow();
-
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitInsertListToRealmMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "void",
-                "insert",
-                EnumSet.of(Modifier.PUBLIC),
-                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
-
-        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
-        writer.emitStatement("RealmModel object = null");
-        writer.emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())");
-
-        writer.beginControlFlow("if (iterator.hasNext())")
-                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
-                .emitStatement("object = iterator.next()")
-                .emitSingleLineComment("This cast is correct because obj is either")
-                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
-                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
-                .emitEmptyLine();
-
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-
-        writer.beginControlFlow("if (iterator.hasNext())");
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("%s.insert(realm, iterator, cache)", qualifiedProxyClasses.get(i));
-            }
-        }, writer, false);
-        writer.endControlFlow();
-        writer.endControlFlow();
-
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmModel> E",
-                "createOrUpdateUsingJsonObject",
-                EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
-                Arrays.asList("JSONException")
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmModel> E",
-                "createUsingJsonStream",
-                EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
-                Arrays.asList("java.io.IOException")
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmModel> E",
-                "createDetachedCopy",
-                EnumSet.of(Modifier.PUBLIC),
-                "E", "realmObject", "int", "maxDepth", "Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>>", "cache"
-        );
-        writer.emitSingleLineComment("This cast is correct because obj is either");
-        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
-        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass()");
-        writer.emitEmptyLine();
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
-                        qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
-            }
-        }, writer, false);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    // Emits the control flow for selecting the appropriate proxy class based on the model class
-    // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
-    // Consider switching to HashMap or similar.
-    private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
-            throws IOException {
-        if (nullPointerCheck) {
-            writer.emitStatement("checkClass(clazz)");
-            writer.emitEmptyLine();
-        }
-        if (qualifiedModelClasses.size() == 0) {
-            writer.emitStatement("throw getMissingProxyClassException(clazz)");
-        } else {
-            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(0));
-            statement.emitStatement(0, writer);
-            for (int i = 1; i < qualifiedModelClasses.size(); i++) {
-                writer.nextControlFlow("else if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
-                statement.emitStatement(i, writer);
-            }
-            writer.nextControlFlow("else");
-            writer.emitStatement("throw getMissingProxyClassException(clazz)");
-            writer.endControlFlow();
-        }
-    }
-
-    // Identical to the above, but eliminates the un-needed "else" clauses for, e.g., return statements
-    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
-        emitMediatorShortCircuitSwitch(statement, writer, true);
-    }
-
-    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
-            throws IOException {
-        if (nullPointerCheck) {
-            writer.emitStatement("checkClass(clazz)");
-            writer.emitEmptyLine();
-        }
-        for (int i = 0; i < qualifiedModelClasses.size(); i++) {
-            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
-            statement.emitStatement(i, writer);
-            writer.endControlFlow();
-        }
-        writer.emitStatement("throw getMissingProxyClassException(clazz)");
-    }
-
-
-    private interface ProxySwitchStatement {
-        void emitStatement(int i, JavaWriter writer) throws IOException;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt
new file mode 100644
index 0000000000..18fd5dea62
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.kt
@@ -0,0 +1,463 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import com.squareup.javawriter.JavaWriter
+
+import java.io.BufferedWriter
+import java.io.IOException
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.EnumSet
+import java.util.Locale
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Modifier
+
+import io.realm.annotations.RealmModule
+import javax.tools.JavaFileObject
+
+class RealmProxyMediatorGenerator(private val processingEnvironment: ProcessingEnvironment,
+                                  private val className: SimpleClassName,
+                                  classesToValidate: Set<ClassMetaData>) {
+
+    private val qualifiedModelClasses = ArrayList<QualifiedClassName>()
+    private val qualifiedProxyClasses = ArrayList<QualifiedClassName>()
+    private val simpleModelClassNames = ArrayList<SimpleClassName>()
+    private val internalClassNames = ArrayList<String>()
+
+    init {
+        for (metadata in classesToValidate) {
+            qualifiedModelClasses.add(metadata.qualifiedClassName)
+            val qualifiedProxyClassName = QualifiedClassName("${Constants.REALM_PACKAGE_NAME}.${Utils.getProxyClassName(metadata.qualifiedClassName)}")
+            qualifiedProxyClasses.add(qualifiedProxyClassName)
+            simpleModelClassNames.add(metadata.simpleJavaClassName)
+            internalClassNames.add(metadata.internalClassName)
+        }
+    }
+
+    @Throws(IOException::class)
+    fun generate() {
+        val qualifiedGeneratedClassName: String = String.format(Locale.US, "%s.%sMediator", Constants.REALM_PACKAGE_NAME, className)
+        val sourceFile: JavaFileObject = processingEnvironment.filer.createSourceFile(qualifiedGeneratedClassName)
+        val imports = ArrayList(Arrays.asList("android.util.JsonReader",
+                "java.io.IOException",
+                "java.util.Collections",
+                "java.util.HashSet",
+                "java.util.List",
+                "java.util.Map",
+                "java.util.HashMap",
+                "java.util.Set",
+                "java.util.Iterator",
+                "java.util.Collection",
+                "io.realm.ImportFlag",
+                "io.realm.internal.ColumnInfo",
+                "io.realm.internal.RealmObjectProxy",
+                "io.realm.internal.RealmProxyMediator",
+                "io.realm.internal.Row",
+                "io.realm.internal.OsSchemaInfo",
+                "io.realm.internal.OsObjectSchemaInfo",
+                "org.json.JSONException",
+                "org.json.JSONObject"))
+
+        val writer = JavaWriter(BufferedWriter(sourceFile.openWriter()))
+        writer.apply {
+            indent = "    "
+            emitPackage(Constants.REALM_PACKAGE_NAME)
+            emitEmptyLine()
+            emitImports(imports)
+            emitEmptyLine()
+            emitAnnotation(RealmModule::class.java)
+            beginType(qualifiedGeneratedClassName,      // full qualified name of the item to generate
+                    "class",                      // the type of the item
+                    emptySet(),                        // modifiers to apply
+                    "RealmProxyMediator")  // class to extend
+            emitEmptyLine()
+            emitFields(this)
+            emitGetExpectedObjectSchemaInfoMap(this)
+            emitCreateColumnInfoMethod(this)
+            emitGetSimpleClassNameMethod(this)
+            emitNewInstanceMethod(this)
+            emitGetClassModelList(this)
+            emitCopyOrUpdateMethod(this)
+            emitInsertObjectToRealmMethod(this)
+            emitInsertListToRealmMethod(this)
+            emitInsertOrUpdateObjectToRealmMethod(this)
+            emitInsertOrUpdateListToRealmMethod(this)
+            emitCreteOrUpdateUsingJsonObject(this)
+            emitCreateUsingJsonStream(this)
+            emitCreateDetachedCopyMethod(this)
+            endType()
+            close()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitFields(writer: JavaWriter) {
+        writer.apply {
+            emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL))
+            beginInitializer(true)
+            emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(%s)", qualifiedModelClasses.size)
+            for (clazz in qualifiedModelClasses) {
+                emitStatement("modelClasses.add(%s.class)", clazz)
+            }
+            emitStatement("MODEL_CLASSES = Collections.unmodifiableSet(modelClasses)")
+            endInitializer()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitGetExpectedObjectSchemaInfoMap(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("Map<Class<? extends RealmModel>, OsObjectSchemaInfo>","getExpectedObjectSchemaInfoMap", EnumSet.of(Modifier.PUBLIC))
+                emitStatement("Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(%s)", qualifiedProxyClasses.size)
+                for (i in qualifiedProxyClasses.indices) {
+                    emitStatement("infoMap.put(%s.class, %s.getExpectedObjectSchemaInfo())", qualifiedModelClasses[i], qualifiedProxyClasses[i])
+                }
+                emitStatement("return infoMap")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateColumnInfoMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "ColumnInfo",
+                    "createColumnInfo",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Class<? extends RealmModel>", "clazz", // Argument type & argument name
+                    "OsSchemaInfo", "schemaInfo"
+            )
+            emitMediatorShortCircuitSwitch({ i: Int ->
+                emitStatement("return %s.createColumnInfo(schemaInfo)", qualifiedProxyClasses[i])
+            }, writer)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitGetSimpleClassNameMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "String",
+                    "getSimpleClassNameImpl",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Class<? extends RealmModel>", "clazz"
+            )
+                emitMediatorShortCircuitSwitch({ i: Int ->
+                        emitStatement("return \"%s\"", internalClassNames[i])
+                }, writer)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitNewInstanceMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "<E extends RealmModel> E",
+                    "newInstance",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Class<E>", "clazz",
+                    "Object", "baseRealm",
+                    "Row", "row",
+                    "ColumnInfo", "columnInfo",
+                    "boolean", "acceptDefaultValue",
+                    "List<String>", "excludeFields"
+            )
+                emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                beginControlFlow("try")
+                    emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)")
+                    emitMediatorShortCircuitSwitch({ i: Int ->
+                        emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses[i])
+                    }, writer)
+                nextControlFlow("finally")
+                    emitStatement("objectContext.clear()")
+                endControlFlow()
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitGetClassModelList(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod("Set<Class<? extends RealmModel>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC))
+                emitStatement("return MODEL_CLASSES")
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCopyOrUpdateMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "<E extends RealmModel> E",
+                    "copyOrUpdate",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Realm", "realm",
+                    "E", "obj",
+                    "boolean", "update",
+                    "Map<RealmModel, RealmObjectProxy>", "cache",
+                    "Set<ImportFlag>", "flags"
+            )
+                emitSingleLineComment("This cast is correct because obj is either")
+                emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())")
+                emitEmptyLine()
+                emitMediatorShortCircuitSwitch({i: Int ->
+                    emitStatement("%1\$s columnInfo = (%1\$s) realm.getSchema().getColumnInfo(%2\$s.class)", Utils.getSimpleColumnInfoClassName(qualifiedModelClasses[i]), qualifiedModelClasses[i])
+                    emitStatement("return clazz.cast(%s.copyOrUpdate(realm, columnInfo, (%s) obj, update, cache, flags))", qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                }, writer, false)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertObjectToRealmMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "void",
+                    "insert",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Realm", "realm", "RealmModel", "object", "Map<RealmModel, Long>", "cache")
+                emitSingleLineComment("This cast is correct because obj is either")
+                emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                emitEmptyLine()
+                emitMediatorSwitch({ i: Int ->
+                    emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                }, writer, false)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertOrUpdateObjectToRealmMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "void",
+                    "insertOrUpdate",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Realm", "realm", "RealmModel", "obj", "Map<RealmModel, Long>", "cache")
+                emitSingleLineComment("This cast is correct because obj is either")
+                emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())")
+                emitEmptyLine()
+                emitMediatorSwitch({ i: Int ->
+                    emitStatement("%s.insertOrUpdate(realm, (%s) obj, cache)", qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                }, writer, false)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertOrUpdateListToRealmMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "void",
+                    "insertOrUpdate",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Realm", "realm", "Collection<? extends RealmModel>", "objects")
+
+                emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()")
+                emitStatement("RealmModel object = null")
+                emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())")
+
+                beginControlFlow("if (iterator.hasNext())")
+                    emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                    emitStatement("object = iterator.next()")
+                    emitSingleLineComment("This cast is correct because obj is either")
+                    emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                    emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                    emitEmptyLine()
+
+                    emitMediatorSwitch({ i: Int ->
+                        emitStatement("%s.insertOrUpdate(realm, (%s) object, cache)", qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                    }, writer, false)
+
+                    beginControlFlow("if (iterator.hasNext())")
+                        emitMediatorSwitch({ i: Int ->
+                                emitStatement("%s.insertOrUpdate(realm, iterator, cache)", qualifiedProxyClasses[i])
+                        }, writer, false)
+                    endControlFlow()
+                endControlFlow()
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitInsertListToRealmMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "void",
+                    "insert",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "Realm", "realm", "Collection<? extends RealmModel>", "objects")
+
+                emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()")
+                emitStatement("RealmModel object = null")
+                emitStatement("Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>(objects.size())")
+
+                beginControlFlow("if (iterator.hasNext())")
+                        .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                        .emitStatement("object = iterator.next()")
+                        .emitSingleLineComment("This cast is correct because obj is either")
+                        .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                        .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                        .emitEmptyLine()
+
+                    emitMediatorSwitch({ i: Int ->
+                            emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                    }, writer, false)
+
+                    beginControlFlow("if (iterator.hasNext())")
+                        emitMediatorSwitch({ i: Int ->
+                            emitStatement("%s.insert(realm, iterator, cache)", qualifiedProxyClasses[i])
+                        }, writer, false)
+                    endControlFlow()
+                endControlFlow()
+
+            endMethod()
+            emitEmptyLine()    
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreteOrUpdateUsingJsonObject(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "<E extends RealmModel> E",
+                    "createOrUpdateUsingJsonObject",
+                    EnumSet.of(Modifier.PUBLIC),
+                    Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
+                    Arrays.asList("JSONException")
+            )
+                emitMediatorShortCircuitSwitch({ i: Int ->
+                        emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses[i])
+                }, writer)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateUsingJsonStream(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "<E extends RealmModel> E",
+                    "createUsingJsonStream",
+                    EnumSet.of(Modifier.PUBLIC),
+                    Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
+                    Arrays.asList("java.io.IOException")
+            )
+                emitMediatorShortCircuitSwitch({ i: Int ->
+                    emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses[i])
+                }, writer)
+            endMethod()
+            emitEmptyLine()
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitCreateDetachedCopyMethod(writer: JavaWriter) {
+        writer.apply {
+            emitAnnotation("Override")
+            beginMethod(
+                    "<E extends RealmModel> E",
+                    "createDetachedCopy",
+                    EnumSet.of(Modifier.PUBLIC),
+                    "E", "realmObject", "int", "maxDepth", "Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>>", "cache"
+            )
+                emitSingleLineComment("This cast is correct because obj is either")
+                emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass()")
+                emitEmptyLine()
+                emitMediatorShortCircuitSwitch({ i: Int ->
+                    emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
+                            qualifiedProxyClasses[i], qualifiedModelClasses[i])
+                }, writer, false)
+            endMethod()
+            emitEmptyLine()   
+        }
+    }
+
+    // Emits the control flow for selecting the appropriate proxy class based on the model class
+    // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
+    // Consider switching to HashMap or similar.
+    @Throws(IOException::class)
+    private fun emitMediatorSwitch(emitStatement: (index: Int) -> Unit, writer: JavaWriter, nullPointerCheck: Boolean) {
+        writer.apply {
+            if (nullPointerCheck) {
+                emitStatement("checkClass(clazz)")
+                emitEmptyLine()
+            }
+            if (qualifiedModelClasses.isEmpty()) {
+                emitStatement("throw getMissingProxyClassException(clazz)")
+            } else {
+                beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses[0])
+                emitStatement(0)
+                for (i in 1 until qualifiedModelClasses.size) {
+                    nextControlFlow("else if (clazz.equals(%s.class))", qualifiedModelClasses[i])
+                    emitStatement(i)
+                }
+                nextControlFlow("else")
+                emitStatement("throw getMissingProxyClassException(clazz)")
+                endControlFlow()
+            }
+        }
+    }
+
+    @Throws(IOException::class)
+    private fun emitMediatorShortCircuitSwitch(emitStatement: (index: Int) -> Unit, writer: JavaWriter, nullPointerCheck: Boolean = true) {
+        writer.apply {
+            if (nullPointerCheck) {
+                emitStatement("checkClass(clazz)")
+                emitEmptyLine()
+            }
+            for (i in qualifiedModelClasses.indices) {
+                beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses[i])
+                emitStatement(i)
+                endControlFlow()
+            }
+            emitStatement("throw getMissingProxyClassException(clazz)")
+        }
+    }
+
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
deleted file mode 100644
index f59358c298..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.tools.Diagnostic;
-
-
-public class RealmVersionChecker {
-    public static final String REALM_ANDROID_DOWNLOAD_URL = "https://static.realm.io/downloads/java/latest";
-
-    private static final String VERSION_URL = "https://static.realm.io/update/java?";
-    private static final String REALM_VERSION = Version.VERSION;
-    private static final String REALM_VERSION_PATTERN = "\\d+\\.\\d+\\.\\d+";
-    private static final int READ_TIMEOUT = 2000;
-    private static final int CONNECT_TIMEOUT = 4000;
-
-    private static RealmVersionChecker instance = null;
-
-    private ProcessingEnvironment processingEnvironment;
-
-    public static RealmVersionChecker getInstance(ProcessingEnvironment processingEnvironment) {
-        if (instance == null) {
-            instance = new RealmVersionChecker(processingEnvironment);
-        }
-        return instance;
-    }
-
-    private RealmVersionChecker(ProcessingEnvironment processingEnvironment) {
-        this.processingEnvironment = processingEnvironment;
-    }
-
-    public void executeRealmVersionUpdate() {
-        Thread backgroundThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                launchRealmCheck();
-            }
-        });
-
-        backgroundThread.start();
-
-        try {
-            backgroundThread.join(CONNECT_TIMEOUT + READ_TIMEOUT);
-        } catch (InterruptedException ignore) {
-            // We ignore this exception on purpose not to break the build system if this class fails
-        }
-    }
-
-    private void launchRealmCheck() {
-        //Check Realm version server
-        String latestVersionStr = checkLatestVersion();
-        if (!latestVersionStr.equals(REALM_VERSION)) {
-            printMessage("Version " + latestVersionStr + " of Realm is now available: " + REALM_ANDROID_DOWNLOAD_URL);
-        }
-    }
-
-    private String checkLatestVersion() {
-        String result = REALM_VERSION;
-        try {
-            URL url = new URL(VERSION_URL + REALM_VERSION);
-            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-            conn.setConnectTimeout(CONNECT_TIMEOUT);
-            conn.setReadTimeout(READ_TIMEOUT);
-            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
-            String latestVersion = rd.readLine();
-            // if the obtained string does not match the pattern, we are in a separate network.
-            if (latestVersion.matches(REALM_VERSION_PATTERN)) {
-                result = latestVersion;
-            }
-            rd.close();
-        } catch (IOException e) {
-            // We ignore this exception on purpose not to break the build system if this class fails
-        }
-        return result;
-    }
-
-    private void printMessage(String message) {
-        processingEnvironment.getMessager().printMessage(Diagnostic.Kind.OTHER, message);
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.kt
new file mode 100644
index 0000000000..3525e42f15
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.kt
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor
+
+import java.io.BufferedReader
+import java.io.IOException
+import java.io.InputStreamReader
+import java.net.HttpURLConnection
+import java.net.URL
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.tools.Diagnostic
+
+
+class RealmVersionChecker private constructor(private val processingEnvironment: ProcessingEnvironment) {
+
+    private val REALM_ANDROID_DOWNLOAD_URL = "https://static.realm.io/downloads/java/latest"
+    private val VERSION_URL = "https://static.realm.io/update/java?"
+    private val REALM_VERSION = Version.VERSION
+    private val REALM_VERSION_PATTERN = "\\d+\\.\\d+\\.\\d+"
+    private val READ_TIMEOUT = 2000
+    private val CONNECT_TIMEOUT = 4000
+
+    fun executeRealmVersionUpdate() {
+        val backgroundThread = Thread(Runnable { launchRealmCheck() })
+        backgroundThread.start()
+        try {
+            backgroundThread.join((CONNECT_TIMEOUT + READ_TIMEOUT).toLong())
+        } catch (ignore: InterruptedException) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        }
+    }
+
+    private fun launchRealmCheck() {
+        //Check Realm version server
+        val latestVersionStr = checkLatestVersion()
+        if (latestVersionStr != REALM_VERSION) {
+            printMessage("Version $latestVersionStr of Realm is now available: $REALM_ANDROID_DOWNLOAD_URL")
+        }
+    }
+
+    private fun checkLatestVersion(): String {
+        var result = REALM_VERSION
+        try {
+            val url = URL(VERSION_URL + REALM_VERSION)
+            val conn = url.openConnection() as HttpURLConnection
+            conn.connectTimeout = CONNECT_TIMEOUT
+            conn.readTimeout = READ_TIMEOUT
+            val rd = BufferedReader(InputStreamReader(conn.inputStream))
+            val latestVersion = rd.readLine()
+            // if the obtained string does not match the pattern, we are in a separate network.
+            if (latestVersion.matches(REALM_VERSION_PATTERN.toRegex())) {
+                result = latestVersion
+            }
+            rd.close()
+        } catch (e: IOException) {
+            // We ignore this exception on purpose not to break the build system if this class fails
+        }
+
+        return result
+    }
+
+    private fun printMessage(message: String) {
+        processingEnvironment.messager.printMessage(Diagnostic.Kind.OTHER, message)
+    }
+
+    companion object {
+        private var instance: RealmVersionChecker? = null
+        fun getInstance(env: ProcessingEnvironment): RealmVersionChecker {
+            if (instance == null) {
+                synchronized(RealmVersionChecker::class.java) {
+                    if (instance == null) {
+                        instance = RealmVersionChecker(env)
+                    }
+                }
+            }
+            return instance!!
+        }
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
deleted file mode 100644
index d6a0c84c69..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import java.util.Date;
-import java.util.List;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-
-/**
- * This class provides {@link TypeMirror} instances used in annotation processor.
- *
- * WARNING: Comparing type mirrors using either `==` or `equal()` can break when using incremental
- * annotation processing. Always use `Types.isSameType()` instead when comparing them.
- */
-class TypeMirrors {
-    final TypeMirror STRING_MIRROR;
-    final TypeMirror BINARY_MIRROR;
-    final TypeMirror BOOLEAN_MIRROR;
-    final TypeMirror LONG_MIRROR;
-    final TypeMirror INTEGER_MIRROR;
-    final TypeMirror SHORT_MIRROR;
-    final TypeMirror BYTE_MIRROR;
-    final TypeMirror DOUBLE_MIRROR;
-    final TypeMirror FLOAT_MIRROR;
-    final TypeMirror DATE_MIRROR;
-
-    final TypeMirror PRIMITIVE_LONG_MIRROR;
-    final TypeMirror PRIMITIVE_INT_MIRROR;
-    final TypeMirror PRIMITIVE_SHORT_MIRROR;
-    final TypeMirror PRIMITIVE_BYTE_MIRROR;
-
-    TypeMirrors(ProcessingEnvironment env) {
-        final Types typeUtils = env.getTypeUtils();
-        final Elements elementUtils = env.getElementUtils();
-
-        STRING_MIRROR = elementUtils.getTypeElement("java.lang.String").asType();
-        BINARY_MIRROR = typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.BYTE));
-        BOOLEAN_MIRROR = elementUtils.getTypeElement(Boolean.class.getName()).asType();
-        LONG_MIRROR = elementUtils.getTypeElement(Long.class.getName()).asType();
-        INTEGER_MIRROR = elementUtils.getTypeElement(Integer.class.getName()).asType();
-        SHORT_MIRROR = elementUtils.getTypeElement(Short.class.getName()).asType();
-        BYTE_MIRROR = elementUtils.getTypeElement(Byte.class.getName()).asType();
-        DOUBLE_MIRROR = elementUtils.getTypeElement(Double.class.getName()).asType();
-        FLOAT_MIRROR = elementUtils.getTypeElement(Float.class.getName()).asType();
-        DATE_MIRROR = elementUtils.getTypeElement(Date.class.getName()).asType();
-
-        PRIMITIVE_LONG_MIRROR = typeUtils.getPrimitiveType(TypeKind.LONG);
-        PRIMITIVE_INT_MIRROR = typeUtils.getPrimitiveType(TypeKind.INT);
-        PRIMITIVE_SHORT_MIRROR = typeUtils.getPrimitiveType(TypeKind.SHORT);
-        PRIMITIVE_BYTE_MIRROR = typeUtils.getPrimitiveType(TypeKind.BYTE);
-    }
-
-    /**
-     * @return the {@link TypeMirror} of the elements in {@code RealmList}.
-     */
-    public static TypeMirror getRealmListElementTypeMirror(VariableElement field) {
-        if (!Utils.isRealmList(field)) {
-            return null;
-        }
-        List<? extends TypeMirror> typeArguments = ((DeclaredType) field.asType()).getTypeArguments();
-        return (!typeArguments.isEmpty()) ? typeArguments.get(0) : null;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.kt
new file mode 100644
index 0000000000..e917487f0a
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:JvmName("TypeMirrors")
+package io.realm.processor
+
+import java.util.Date
+
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.DeclaredType
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+
+/**
+ * This class provides [TypeMirror] instances used in annotation processor.
+ *
+ * WARNING: Comparing type mirrors using either `==` or `equal()` can break when using incremental
+ * annotation processing. Always use `Types.isSameType()` instead when comparing them.
+ */
+class TypeMirrors(env: ProcessingEnvironment) {
+
+    @JvmField val STRING_MIRROR: TypeMirror
+    @JvmField val BINARY_MIRROR: TypeMirror
+    @JvmField val BOOLEAN_MIRROR: TypeMirror
+    @JvmField val LONG_MIRROR: TypeMirror
+    @JvmField val INTEGER_MIRROR: TypeMirror
+    @JvmField val SHORT_MIRROR: TypeMirror
+    @JvmField val BYTE_MIRROR: TypeMirror
+    @JvmField val DOUBLE_MIRROR: TypeMirror
+    @JvmField val FLOAT_MIRROR: TypeMirror
+    @JvmField val DATE_MIRROR: TypeMirror
+
+    @JvmField val PRIMITIVE_LONG_MIRROR: TypeMirror
+    @JvmField val PRIMITIVE_INT_MIRROR: TypeMirror
+    @JvmField val PRIMITIVE_SHORT_MIRROR: TypeMirror
+    @JvmField val PRIMITIVE_BYTE_MIRROR: TypeMirror
+
+    init {
+        val typeUtils = env.typeUtils
+        val elementUtils = env.elementUtils
+
+        STRING_MIRROR = elementUtils.getTypeElement("java.lang.String").asType()
+        BINARY_MIRROR = typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.BYTE))
+        BOOLEAN_MIRROR = elementUtils.getTypeElement(Boolean::class.javaObjectType.name).asType()
+        LONG_MIRROR = elementUtils.getTypeElement(Long::class.javaObjectType.name).asType()
+        INTEGER_MIRROR = elementUtils.getTypeElement(Int::class.javaObjectType.name).asType()
+        SHORT_MIRROR = elementUtils.getTypeElement(Short::class.javaObjectType.name).asType()
+        BYTE_MIRROR = elementUtils.getTypeElement(Byte::class.javaObjectType.name).asType()
+        DOUBLE_MIRROR = elementUtils.getTypeElement(Double::class.javaObjectType.name).asType()
+        FLOAT_MIRROR = elementUtils.getTypeElement(Float::class.javaObjectType.name).asType()
+        DATE_MIRROR = elementUtils.getTypeElement(Date::class.javaObjectType.name).asType()
+
+        PRIMITIVE_LONG_MIRROR = typeUtils.getPrimitiveType(TypeKind.LONG)
+        PRIMITIVE_INT_MIRROR = typeUtils.getPrimitiveType(TypeKind.INT)
+        PRIMITIVE_SHORT_MIRROR = typeUtils.getPrimitiveType(TypeKind.SHORT)
+        PRIMITIVE_BYTE_MIRROR = typeUtils.getPrimitiveType(TypeKind.BYTE)
+    }
+
+    companion object {
+        /**
+         * @return the [TypeMirror] of the elements in `RealmList`.
+         */
+        @JvmStatic
+        fun getRealmListElementTypeMirror(field: VariableElement): TypeMirror? {
+            if (!Utils.isRealmList(field)) {
+                return null
+            }
+            val typeArguments = (field.asType() as DeclaredType).typeArguments
+            return if (!typeArguments.isEmpty()) typeArguments[0] else null
+        }
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
deleted file mode 100644
index d091f6b797..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ /dev/null
@@ -1,423 +0,0 @@
-package io.realm.processor;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.List;
-
-import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ReferenceType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
-import io.realm.annotations.RealmNamingPolicy;
-import io.realm.processor.nameconverter.CamelCaseConverter;
-import io.realm.processor.nameconverter.IdentityConverter;
-import io.realm.processor.nameconverter.LowerCaseWithSeparatorConverter;
-import io.realm.processor.nameconverter.NameConverter;
-import io.realm.processor.nameconverter.PascalCaseConverter;
-
-/**
- * Utility methods working with the Realm processor.
- */
-public class Utils {
-
-    private static Types typeUtils;
-    private static Messager messager;
-    private static TypeMirror realmInteger;
-    private static DeclaredType realmList;
-    private static DeclaredType realmResults;
-    private static DeclaredType markerInterface;
-    private static TypeMirror realmModel;
-
-    public static void initialize(ProcessingEnvironment env) {
-        Elements elementUtils = env.getElementUtils();
-        typeUtils = env.getTypeUtils();
-        messager = env.getMessager();
-        realmInteger = elementUtils.getTypeElement("io.realm.MutableRealmInteger").asType();
-        realmList = typeUtils.getDeclaredType(
-                elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
-        realmResults = typeUtils.getDeclaredType(
-                env.getElementUtils().getTypeElement("io.realm.RealmResults"), typeUtils.getWildcardType(null, null));
-        realmModel = elementUtils.getTypeElement("io.realm.RealmModel").asType();
-        markerInterface = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmModel"));
-    }
-
-    /**
-     * @return true if the given element is the default public no arg constructor for a class.
-     */
-    public static boolean isDefaultConstructor(Element constructor) {
-        if (constructor.getModifiers().contains(Modifier.PUBLIC)) {
-            return ((ExecutableElement) constructor).getParameters().isEmpty();
-        }
-        return false;
-    }
-
-    public static String getProxyClassSimpleName(VariableElement field) {
-        if (typeUtils.isAssignable(field.asType(), realmList)) {
-            return getProxyClassName(getGenericTypeQualifiedName(field));
-        } else {
-            return getProxyClassName(getFieldTypeQualifiedName(field));
-        }
-    }
-
-    public static String getModelClassQualifiedName(VariableElement field) {
-        if (typeUtils.isAssignable(field.asType(), realmList)) {
-            return getGenericTypeQualifiedName(field);
-        } else {
-            return getFieldTypeQualifiedName(field);
-        }
-    }
-
-    /**
-     * @return the proxy class name for a given clazz
-     */
-    public static String getProxyClassName(String qualifiedClassName) {
-        return qualifiedClassName.replace(".", "_") + Constants.PROXY_SUFFIX;
-    }
-
-    /**
-     * @return {@code true} if a field is of type "java.lang.String", {@code false} otherwise.
-     * @throws IllegalArgumentException if the field is {@code null}.
-     */
-    public static boolean isString(VariableElement field) {
-        if (field == null) {
-            throw new IllegalArgumentException("Argument 'field' cannot be null.");
-        }
-        return getFieldTypeQualifiedName(field).equals("java.lang.String");
-    }
-
-    /**
-     * @return {@code true} if a field is a primitive type, {@code false} otherwise.
-     * @throws IllegalArgumentException if the typeString is {@code null}.
-     */
-    public static boolean isPrimitiveType(String typeString) {
-        if (typeString == null) {
-            throw new IllegalArgumentException("Argument 'typeString' cannot be null.");
-        }
-        return typeString.equals("byte") || typeString.equals("short") || typeString.equals("int") ||
-                typeString.equals("long") || typeString.equals("float") || typeString.equals("double") ||
-                typeString.equals("boolean") || typeString.equals("char");
-    }
-
-    /**
-     * @return {@code true} if a field is a boxed type, {@code false} otherwise.
-     * @throws IllegalArgumentException if the typeString is {@code null}.
-     */
-    public static boolean isBoxedType(String typeString) {
-        if (typeString == null) {
-            throw new IllegalArgumentException("Argument 'typeString' cannot be null.");
-        }
-        return typeString.equals(Byte.class.getName()) || typeString.equals(Short.class.getName()) ||
-                typeString.equals(Integer.class.getName()) || typeString.equals(Long.class.getName()) ||
-                typeString.equals(Float.class.getName()) || typeString.equals(Double.class.getName()) ||
-                typeString.equals(Boolean.class.getName());
-    }
-
-    /**
-     * @return {@code true} if a field is a type of primitive types, {@code false} otherwise.
-     * @throws IllegalArgumentException if the field is {@code null}.
-     */
-    public static boolean isPrimitiveType(VariableElement field) {
-        if (field == null) {
-            throw new IllegalArgumentException("Argument 'field' cannot be null.");
-        }
-        return field.asType().getKind().isPrimitive();
-    }
-
-    /**
-     * @return {@code true} if a field is of type "byte[]", {@code false} otherwise.
-     * @throws IllegalArgumentException if the field is {@code null}.
-     */
-    public static boolean isByteArray(VariableElement field) {
-        if (field == null) {
-            throw new IllegalArgumentException("Argument 'field' cannot be null.");
-        }
-        return getFieldTypeQualifiedName(field).equals("byte[]");
-    }
-
-    /**
-     * @return {@code true} if a given field type string is "java.lang.String", {@code false} otherwise.
-     * @throws IllegalArgumentException if the fieldType is {@code null}.
-     */
-    public static boolean isString(String fieldType) {
-        if (fieldType == null) {
-            throw new IllegalArgumentException("Argument 'fieldType' cannot be null.");
-        }
-        return String.class.getName().equals(fieldType);
-    }
-
-    /**
-     * @return {@code true} if a given type implement {@code RealmModel}, {@code false} otherwise.
-     */
-    public static boolean isImplementingMarkerInterface(Element classElement) {
-        return typeUtils.isAssignable(classElement.asType(), markerInterface);
-    }
-
-    /**
-     * @return {@code true} if a given field type is {@code MutableRealmInteger}, {@code false} otherwise.
-     */
-    public static boolean isMutableRealmInteger(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmInteger);
-    }
-
-    /**
-     * @return {@code true} if a given field type is {@code RealmList}, {@code false} otherwise.
-     */
-    public static boolean isRealmList(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmList);
-    }
-
-    /**
-     * @param field {@link VariableElement} of a value list field.
-     * @return element type of the list field.
-     */
-    public static Constants.RealmFieldType getValueListFieldType(VariableElement field) {
-        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-        return Constants.LIST_ELEMENT_TYPE_TO_REALM_TYPES.get(elementTypeMirror.toString());
-    }
-
-    /**
-     * @return {@code true} if a given field type is {@code RealmList} and its element type is {@code RealmObject},
-     * {@code false} otherwise.
-     */
-    public static boolean isRealmModelList(VariableElement field) {
-        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-        if (elementTypeMirror == null) {
-            return false;
-        }
-        return isRealmModel(elementTypeMirror);
-    }
-
-    /**
-     * @return {@code true} if a given field type is {@code RealmList} and its element type is value type,
-     * {@code false} otherwise.
-     */
-    public static boolean isRealmValueList(VariableElement field) {
-        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
-        if (elementTypeMirror == null) {
-            return false;
-        }
-        return !isRealmModel(elementTypeMirror);
-    }
-
-    /**
-     * @return {@code true} if a given field type is {@code RealmModel}, {@code false} otherwise.
-     */
-    public static boolean isRealmModel(Element field) {
-        return isRealmModel(field.asType());
-    }
-
-    /**
-     * @return {@code true} if a given type is {@code RealmModel}, {@code false} otherwise.
-     */
-    public static boolean isRealmModel(TypeMirror type) {
-        // This will return the wrong result if a model class doesn't exist at all, but
-        // the compiler will catch that eventually.
-        return typeUtils.isAssignable(type, realmModel);
-//        // Not sure what is happening here, but typeUtils.isAssignable("Foo", realmModel)
-//        // returns true even if Foo doesn't exist. No idea why this is happening.
-//        // For now punt on the problem and check the direct supertype which should be either
-//        // RealmObject or RealmModel.
-//        // Original implementation: ``
-//        //
-//        // Theory: It looks like if `type` has the internal TypeTag.ERROR (internal API) it
-//        // automatically translate to being assignable to everything. Possible some Java Specification
-//        // rule taking effect. In our case, however we can do better since all Realm classes
-//        // must be in the same compilation unit, so we should be able to look the type up.
-//        for (TypeMirror typeMirror : typeUtils.directSupertypes(type)) {
-//            String supertype = typeMirror.toString();
-//            if (supertype.equals("io.realm.RealmObject") || supertype.equals("io.realm.RealmModel")) {
-//                return true;
-//            }
-//        }
-//        return false;
-    }
-
-    public static boolean isRealmResults(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmResults);
-    }
-
-    // get the fully-qualified type name for the generic type of a RealmResults
-    public static String getRealmResultsType(VariableElement field) {
-        if (!Utils.isRealmResults(field)) { return null; }
-        ReferenceType type = getGenericTypeForContainer(field);
-        if (null == type) { return null; }
-        return type.toString();
-    }
-
-    // get the fully-qualified type name for the generic type of a RealmList
-    public static String getRealmListType(VariableElement field) {
-        if (!Utils.isRealmList(field)) { return null; }
-        ReferenceType type = getGenericTypeForContainer(field);
-        if (null == type) { return null; }
-        return type.toString();
-    }
-
-    // Note that, because subclassing subclasses of RealmObject is forbidden,
-    // there is no need to deal with constructs like:  <code>RealmResults&lt;? extends Foos&lt;</code>.
-    public static ReferenceType getGenericTypeForContainer(VariableElement field) {
-        TypeMirror fieldType = field.asType();
-        TypeKind kind = fieldType.getKind();
-        if (kind != TypeKind.DECLARED) { return null; }
-
-        List<? extends TypeMirror> args = ((DeclaredType) fieldType).getTypeArguments();
-        if (args.size() <= 0) { return null; }
-
-        fieldType = args.get(0);
-        kind = fieldType.getKind();
-        // We also support RealmList<byte[]>
-        if (kind != TypeKind.DECLARED && kind != TypeKind.ARRAY) { return null; }
-
-        return (ReferenceType) fieldType;
-    }
-
-    /**
-     * @return the qualified type name for a field.
-     */
-    public static String getFieldTypeQualifiedName(VariableElement field) {
-        return field.asType().toString();
-    }
-
-    /**
-     * @return the generic type for Lists of the form {@code List<type>}
-     */
-    public static String getGenericTypeQualifiedName(VariableElement field) {
-        TypeMirror fieldType = field.asType();
-        List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
-        if (typeArguments.size() == 0) {
-            return null;
-        }
-        return typeArguments.get(0).toString();
-    }
-
-    /**
-     * Strips the package name from a fully qualified class name.
-     */
-    public static String stripPackage(String fullyQualifiedClassName) {
-        String[] parts = fullyQualifiedClassName.split("\\.");
-        if (parts.length > 0) {
-            return parts[parts.length - 1];
-        } else {
-            return fullyQualifiedClassName;
-        }
-    }
-
-    public static void error(String message, Element element) {
-        if (element instanceof RealmFieldElement) {
-            // Element is being cast to Symbol internally which breaks any implementors of the
-            // Element interface. This is a hack to work around that. Bad bad Oracle
-            element = ((RealmFieldElement) element).getFieldReference();
-        }
-        messager.printMessage(Diagnostic.Kind.ERROR, message, element);
-    }
-
-    public static void error(String message) {
-        messager.printMessage(Diagnostic.Kind.ERROR, message);
-    }
-
-    public static void note(String message, Element element) {
-        if (element instanceof RealmFieldElement) {
-            // Element is being cast to Symbol internally which breaks any implementors of the
-            // Element interface. This is a hack to work around that. Bad bad Oracle
-            element = ((RealmFieldElement) element).getFieldReference();
-        }
-        messager.printMessage(Diagnostic.Kind.NOTE, message, element);
-    }
-
-    public static void note(String message) {
-        messager.printMessage(Diagnostic.Kind.NOTE, message);
-    }
-
-    public static Element getSuperClass(TypeElement classType) {
-        return typeUtils.asElement(classType.getSuperclass());
-    }
-
-    /**
-     * Returns the interface name for proxy class interfaces
-     */
-    public static String getProxyInterfaceName(String qualifiedClassName) {
-        return qualifiedClassName.replace(".", "_") + Constants.INTERFACE_SUFFIX;
-    }
-
-    public static NameConverter getNameFormatter(RealmNamingPolicy policy) {
-        if (policy == null) {
-            return new IdentityConverter();
-        }
-        switch (policy) {
-            case NO_POLICY: return new IdentityConverter();
-            case IDENTITY: return new IdentityConverter();
-            case LOWER_CASE_WITH_UNDERSCORES: return new LowerCaseWithSeparatorConverter('_');
-            case CAMEL_CASE: return new CamelCaseConverter();
-            case PASCAL_CASE: return new PascalCaseConverter();
-            default:
-                throw new IllegalArgumentException("Unknown policy: " + policy);
-        }
-    }
-
-    /**
-     * Tries to find the internal class name for a referenced type. In model classes this can
-     * happen with either direct object references or using `RealmList` or `RealmResults`.
-     * <p>
-     * This name is required by schema builders that operate on internal names and not the public ones.
-     * <p>
-     * Finding the internal name is easy if the referenced type is included in the current round
-     * of annotation processing. In that case the internal name was also calculated in the same round
-     * <p>
-     * If the referenced type was already compiled, e.g being included from library, then we need
-     * to get the name from the proxy class. Fortunately ProGuard should not have obfuscated any
-     * class files at this point, meaning we can look it up dynamically.
-     * <p>
-     * If a name is looked up using the class loader, it also means that developers need to
-     * combine a library and app module of model classes at runtime in the RealmConfiguration, but
-     * this should be a valid use case.
-     *
-     * @param qualifiedClassName type to lookup the internal name for.
-     * @param classCollection collection of classes found in the current round of annotation processing.
-     * @throws IllegalArgumentException If the internal name could not be looked up
-     * @return the statement that evalutes to the internal class name. This will either be a string
-     * constant or a reference to a static field in another class. In both cases, the return result
-     * should not be put in quotes.
-     */
-    public static String getReferencedTypeInternalClassNameStatement(String qualifiedClassName, ClassCollection classCollection) {
-
-        // Attempt to lookup internal name in current round
-        if (classCollection.containsQualifiedClass(qualifiedClassName)) {
-            ClassMetaData metadata = classCollection.getClassFromQualifiedName(qualifiedClassName);
-            return "\"" + metadata.getInternalClassName() + "\"";
-        }
-
-        // If we cannot find the name in the current processor round, we have to defer resolving the
-        // name to runtime. The reason being that the annotation processor can only access the
-        // compile type class path using Elements and Types which do not allow us to read
-        // field values.
-        //
-        // Doing it this way unfortunately means that if the class is not on the apps classpath
-        // a rather obscure class-not-found exception will be thrown when starting the app, but since
-        // this is probably a very niche use case that is acceptable for now.
-        //
-        // TODO: We could probably create an internal annotation like `@InternalName("__Permission")`
-        // which should make it possible for the annotation processor to read the value from the
-        // proxy class, even for files in other jar files.
-        return "io.realm." + Utils.getProxyClassName(qualifiedClassName) + ".ClassNameHelper.INTERNAL_CLASS_NAME";
-    }
-
-    /**
-     * Returns a simple reference to the ColumnInfo class inside this model class, i.e. the package
-     * name is not prefixed.
-     */
-    public static String getSimpleColumnInfoClassName(String qualifiedModelClassName) {
-        String simpleModelClassName = Utils.stripPackage(qualifiedModelClassName);
-        return Utils.getProxyClassName(qualifiedModelClassName) + "." + simpleModelClassName + "ColumnInfo";
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.kt
new file mode 100644
index 0000000000..a84b674d8e
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.kt
@@ -0,0 +1,434 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+package io.realm.processor
+
+import javax.annotation.processing.Messager
+import javax.annotation.processing.ProcessingEnvironment
+import javax.lang.model.element.Element
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.Modifier
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.lang.model.type.DeclaredType
+import javax.lang.model.type.ReferenceType
+import javax.lang.model.type.TypeKind
+import javax.lang.model.type.TypeMirror
+import javax.lang.model.util.Types
+import javax.tools.Diagnostic
+
+import io.realm.annotations.RealmNamingPolicy
+import io.realm.processor.nameconverter.CamelCaseConverter
+import io.realm.processor.nameconverter.IdentityConverter
+import io.realm.processor.nameconverter.LowerCaseWithSeparatorConverter
+import io.realm.processor.nameconverter.NameConverter
+import io.realm.processor.nameconverter.PascalCaseConverter
+
+/**
+ * Utility methods working with the Realm processor.
+ */
+object Utils {
+
+    private lateinit var typeUtils: Types
+    private lateinit var messager: Messager
+    private lateinit var realmInteger: TypeMirror
+    private lateinit var realmList: DeclaredType
+    private lateinit var realmResults: DeclaredType
+    private lateinit var markerInterface: DeclaredType
+    private lateinit var realmModel: TypeMirror
+
+    fun initialize(env: ProcessingEnvironment) {
+        val elementUtils = env.elementUtils
+        typeUtils = env.typeUtils
+        messager = env.messager
+        realmInteger = elementUtils.getTypeElement("io.realm.MutableRealmInteger").asType()
+        realmList = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null))
+        realmResults = typeUtils.getDeclaredType(env.elementUtils.getTypeElement("io.realm.RealmResults"), typeUtils.getWildcardType(null, null))
+        realmModel = elementUtils.getTypeElement("io.realm.RealmModel").asType()
+        markerInterface = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmModel"))
+    }
+
+    /**
+     * @return true if the given element is the default public no arg constructor for a class.
+     */
+    fun isDefaultConstructor(constructor: Element): Boolean {
+        return if (constructor.modifiers.contains(Modifier.PUBLIC)) {
+            (constructor as ExecutableElement).parameters.isEmpty()
+        } else false
+    }
+
+    fun getProxyClassSimpleName(field: VariableElement): SimpleClassName {
+        return if (typeUtils.isAssignable(field.asType(), realmList)) {
+            getProxyClassName(getGenericTypeQualifiedName(field)!!)
+        } else {
+            getProxyClassName(getFieldTypeQualifiedName(field))
+        }
+    }
+
+    fun getModelClassQualifiedName(field: VariableElement): QualifiedClassName {
+        return if (typeUtils.isAssignable(field.asType(), realmList)) {
+            getGenericTypeQualifiedName(field)!!
+        } else {
+            getFieldTypeQualifiedName(field)
+        }
+    }
+
+    /**
+     * @return the proxy class name for a given clazz
+     */
+    fun getProxyClassName(className: QualifiedClassName): SimpleClassName {
+        return SimpleClassName(className.toString().replace(".", "_") + Constants.PROXY_SUFFIX)
+    }
+
+    /**
+     * @return `true` if a field is of type "java.lang.String", `false` otherwise.
+     * @throws IllegalArgumentException if the field is `null`.
+     */
+    fun isString(field: VariableElement?): Boolean {
+        if (field == null) {
+            throw IllegalArgumentException("Argument 'field' cannot be null.")
+        }
+        return getFieldTypeQualifiedName(field).toString() == "java.lang.String"
+    }
+
+    /**
+     * @return `true` if a field is a primitive type, `false` otherwise.
+     * @throws IllegalArgumentException if the typeString is `null`.
+     */
+    fun isPrimitiveType(typeString: String): Boolean {
+        return typeString == "byte" || typeString == "short" || typeString == "int" ||
+                typeString == "long" || typeString == "float" || typeString == "double" ||
+                typeString == "boolean" || typeString == "char"
+    }
+
+    fun isPrimitiveType(type: QualifiedClassName): Boolean {
+        return isPrimitiveType(type.toString())
+    }
+
+    /**
+     * @return `true` if a field is a boxed type, `false` otherwise.
+     * @throws IllegalArgumentException if the typeString is `null`.
+     */
+    fun isBoxedType(typeString: String?): Boolean {
+        if (typeString == null) {
+            throw IllegalArgumentException("Argument 'typeString' cannot be null.")
+        }
+        return typeString == Byte::class.javaObjectType.name || typeString == Short::class.javaObjectType.name ||
+                typeString == Int::class.javaObjectType.name || typeString == Long::class.javaObjectType.name ||
+                typeString == Float::class.javaObjectType.name || typeString == Double::class.javaObjectType.name ||
+                typeString == Boolean::class.javaObjectType.name
+    }
+
+    /**
+     * @return `true` if a field is a type of primitive types, `false` otherwise.
+     * @throws IllegalArgumentException if the field is `null`.
+     */
+    fun isPrimitiveType(field: VariableElement?): Boolean {
+        if (field == null) {
+            throw IllegalArgumentException("Argument 'field' cannot be null.")
+        }
+        return field.asType().kind.isPrimitive
+    }
+
+    /**
+     * @return `true` if a field is of type "byte[]", `false` otherwise.
+     * @throws IllegalArgumentException if the field is `null`.
+     */
+    fun isByteArray(field: VariableElement?): Boolean {
+        if (field == null) {
+            throw IllegalArgumentException("Argument 'field' cannot be null.")
+        }
+        return getFieldTypeQualifiedName(field).toString() == "byte[]"
+    }
+
+    /**
+     * @return `true` if a given field type string is "java.lang.String", `false` otherwise.
+     * @throws IllegalArgumentException if the fieldType is `null`.
+     */
+    fun isString(fieldType: String?): Boolean {
+        if (fieldType == null) {
+            throw IllegalArgumentException("Argument 'fieldType' cannot be null.")
+        }
+        return String::class.java.name == fieldType
+    }
+
+    /**
+     * @return `true` if a given type implement `RealmModel`, `false` otherwise.
+     */
+    fun isImplementingMarkerInterface(classElement: Element): Boolean {
+        return typeUtils.isAssignable(classElement.asType(), markerInterface)
+    }
+
+    /**
+     * @return `true` if a given field type is `MutableRealmInteger`, `false` otherwise.
+     */
+    fun isMutableRealmInteger(field: VariableElement): Boolean {
+        return typeUtils.isAssignable(field.asType(), realmInteger)
+    }
+
+    /**
+     * @return `true` if a given field type is `RealmList`, `false` otherwise.
+     */
+    fun isRealmList(field: VariableElement): Boolean {
+        return typeUtils.isAssignable(field.asType(), realmList)
+    }
+
+    /**
+     * @param field [VariableElement] of a value list field.
+     * @return element type of the list field.
+     */
+    fun getValueListFieldType(field: VariableElement): Constants.RealmFieldType {
+        val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field)
+        return Constants.LIST_ELEMENT_TYPE_TO_REALM_TYPES[elementTypeMirror!!.toString()]!!
+    }
+
+    /**
+     * @return `true` if a given field type is `RealmList` and its element type is `RealmObject`,
+     * `false` otherwise.
+     */
+    fun isRealmModelList(field: VariableElement): Boolean {
+        val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field) ?: return false
+        return isRealmModel(elementTypeMirror)
+    }
+
+    /**
+     * @return `true` if a given field type is `RealmList` and its element type is value type,
+     * `false` otherwise.
+     */
+    fun isRealmValueList(field: VariableElement): Boolean {
+        val elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field) ?: return false
+        return !isRealmModel(elementTypeMirror)
+    }
+
+    /**
+     * @return `true` if a given field type is `RealmModel`, `false` otherwise.
+     */
+    fun isRealmModel(field: Element): Boolean {
+        return isRealmModel(field.asType())
+    }
+
+    /**
+     * @return `true` if a given type is `RealmModel`, `false` otherwise.
+     */
+    fun isRealmModel(type: TypeMirror?): Boolean {
+        // This will return the wrong result if a model class doesn't exist at all, but
+        // the compiler will catch that eventually.
+        return typeUtils.isAssignable(type, realmModel)
+        //        // Not sure what is happening here, but typeUtils.isAssignable("Foo", realmModel)
+        //        // returns true even if Foo doesn't exist. No idea why this is happening.
+        //        // For now punt on the problem and check the direct supertype which should be either
+        //        // RealmObject or RealmModel.
+        //        // Original implementation: ``
+        //        //
+        //        // Theory: It looks like if `type` has the internal TypeTag.ERROR (internal API) it
+        //        // automatically translate to being assignable to everything. Possible some Java Specification
+        //        // rule taking effect. In our case, however we can do better since all Realm classes
+        //        // must be in the same compilation unit, so we should be able to look the type up.
+        //        for (TypeMirror typeMirror : typeUtils.directSupertypes(type)) {
+        //            String supertype = typeMirror.toString();
+        //            if (supertype.equals("io.realm.RealmObject") || supertype.equals("io.realm.RealmModel")) {
+        //                return true;
+        //            }
+        //        }
+        //        return false;
+    }
+
+    fun isRealmResults(field: VariableElement): Boolean {
+        return typeUtils.isAssignable(field.asType(), realmResults)
+    }
+
+    // get the fully-qualified type name for the generic type of a RealmResults
+    fun getRealmResultsType(field: VariableElement): QualifiedClassName? {
+        if (!isRealmResults(field)) {
+            return null
+        }
+        val type = getGenericTypeForContainer(field) ?: return null
+        return QualifiedClassName(type.toString())
+    }
+
+    // get the fully-qualified type name for the generic type of a RealmList
+    fun getRealmListType(field: VariableElement): QualifiedClassName? {
+        if (!isRealmList(field)) {
+            return null
+        }
+        val type = getGenericTypeForContainer(field) ?: return null
+        return QualifiedClassName(type.toString())
+    }
+
+    // Note that, because subclassing subclasses of RealmObject is forbidden,
+    // there is no need to deal with constructs like:  <code>RealmResults&lt;? extends Foos&lt;</code>.
+    fun getGenericTypeForContainer(field: VariableElement): ReferenceType? {
+        var fieldType = field.asType()
+        var kind = fieldType.kind
+        if (kind != TypeKind.DECLARED) {
+            return null
+        }
+
+        val args = (fieldType as DeclaredType).typeArguments
+        if (args.size <= 0) {
+            return null
+        }
+
+        fieldType = args[0]
+        kind = fieldType.kind
+        // We also support RealmList<byte[]>
+        return if (kind != TypeKind.DECLARED && kind != TypeKind.ARRAY) {
+            null
+        } else fieldType as ReferenceType
+
+    }
+
+    /**
+     * @return the qualified type name for a field.
+     */
+    fun getFieldTypeQualifiedName(field: VariableElement): QualifiedClassName {
+        return QualifiedClassName(field.asType().toString())
+    }
+
+    /**
+     * @return the generic type for Lists of the form `List<type>`
+     */
+    fun getGenericTypeQualifiedName(field: VariableElement): QualifiedClassName? {
+        val fieldType = field.asType()
+        val typeArguments = (fieldType as DeclaredType).typeArguments
+        return if (typeArguments.isEmpty()) null else QualifiedClassName(typeArguments[0].toString())
+    }
+
+    /**
+     * Strips the package name from a fully qualified class name.
+     */
+    fun stripPackage(fullyQualifiedClassName: String): String {
+        val parts = fullyQualifiedClassName.split("\\.".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
+        return if (parts.isNotEmpty()) {
+            parts[parts.size - 1]
+        } else {
+            fullyQualifiedClassName
+        }
+    }
+
+    fun error(message: String?, element: Element) {
+        var e = element
+        if (element is RealmFieldElement) {
+            // Element is being cast to Symbol internally which breaks any implementors of the
+            // Element interface. This is a hack to work around that. Bad bad Oracle
+            e = element.fieldReference
+        }
+        messager.printMessage(Diagnostic.Kind.ERROR, message, e)
+    }
+
+    fun error(message: String?) {
+        messager.printMessage(Diagnostic.Kind.ERROR, message)
+    }
+
+    fun note(message: String?, element: Element) {
+        var e = element
+        if (element is RealmFieldElement) {
+            // Element is being cast to Symbol internally which breaks any implementors of the
+            // Element interface. This is a hack to work around that. Bad bad Oracle
+            e = element.fieldReference
+        }
+        messager.printMessage(Diagnostic.Kind.NOTE, message, e)
+    }
+
+    fun note(message: String?) {
+        messager.printMessage(Diagnostic.Kind.NOTE, message)
+    }
+
+    fun getSuperClass(classType: TypeElement): Element {
+        return typeUtils.asElement(classType.superclass)
+    }
+
+    /**
+     * Returns the interface name for proxy class interfaces
+     */
+    fun getProxyInterfaceName(qualifiedClassName: QualifiedClassName): SimpleClassName {
+        return SimpleClassName(qualifiedClassName.toString().replace(".", "_") + Constants.INTERFACE_SUFFIX)
+    }
+
+    fun getNameFormatter(policy: RealmNamingPolicy?): NameConverter {
+        if (policy == null) {
+            return IdentityConverter()
+        }
+        when (policy) {
+            RealmNamingPolicy.NO_POLICY -> return IdentityConverter()
+            RealmNamingPolicy.IDENTITY -> return IdentityConverter()
+            RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES -> return LowerCaseWithSeparatorConverter('_')
+            RealmNamingPolicy.CAMEL_CASE -> return CamelCaseConverter()
+            RealmNamingPolicy.PASCAL_CASE -> return PascalCaseConverter()
+            else -> throw IllegalArgumentException("Unknown policy: $policy")
+        }
+    }
+
+    /**
+     * Tries to find the internal class name for a referenced type. In model classes this can
+     * happen with either direct object references or using `RealmList` or `RealmResults`.
+     *
+     *
+     * This name is required by schema builders that operate on internal names and not the public ones.
+     *
+     *
+     * Finding the internal name is easy if the referenced type is included in the current round
+     * of annotation processing. In that case the internal name was also calculated in the same round
+     *
+     *
+     * If the referenced type was already compiled, e.g being included from library, then we need
+     * to get the name from the proxy class. Fortunately ProGuard should not have obfuscated any
+     * class files at this point, meaning we can look it up dynamically.
+     *
+     *
+     * If a name is looked up using the class loader, it also means that developers need to
+     * combine a library and app module of model classes at runtime in the RealmConfiguration, but
+     * this should be a valid use case.
+     *
+     * @param className type to lookup the internal name for.
+     * @param classCollection collection of classes found in the current round of annotation processing.
+     * @throws IllegalArgumentException If the internal name could not be looked up
+     * @return the statement that evalutes to the internal class name. This will either be a string
+     * constant or a reference to a static field in another class. In both cases, the return result
+     * should not be put in quotes.
+     */
+    fun getReferencedTypeInternalClassNameStatement(className: QualifiedClassName?, classCollection: ClassCollection): String {
+
+        // Attempt to lookup internal name in current round
+        if (classCollection.containsQualifiedClass(className)) {
+            val metadata = classCollection.getClassFromQualifiedName(className!!)
+            return "\"" + metadata.internalClassName + "\""
+        }
+
+        // If we cannot find the name in the current processor round, we have to defer resolving the
+        // name to runtime. The reason being that the annotation processor can only access the
+        // compile type class path using Elements and Types which do not allow us to read
+        // field values.
+        //
+        // Doing it this way unfortunately means that if the class is not on the apps classpath
+        // a rather obscure class-not-found exception will be thrown when starting the app, but since
+        // this is probably a very niche use case that is acceptable for now.
+        //
+        // TODO: We could probably create an internal annotation like `@InternalName("__Permission")`
+        // which should make it possible for the annotation processor to read the value from the
+        // proxy class, even for files in other jar files.
+        return "io.realm.${getProxyClassName(className!!)}.ClassNameHelper.INTERNAL_CLASS_NAME"
+    }
+
+    /**
+     * Returns a simple reference to the ColumnInfo class inside this model class, i.e. the package
+     * name is not prefixed.
+     */
+    fun getSimpleColumnInfoClassName(className: QualifiedClassName): String {
+        val simpleModelClassName = className.getSimpleName()
+        return "${getProxyClassName(className)}.${simpleModelClassName}ColumnInfo"
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ext/JavaWriterExt.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ext/JavaWriterExt.kt
new file mode 100644
index 0000000000..9067238f4a
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ext/JavaWriterExt.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+package io.realm.processor.ext
+
+import com.squareup.javawriter.JavaWriter
+import io.realm.processor.QualifiedClassName
+import io.realm.processor.SimpleClassName
+import javax.lang.model.element.Modifier
+
+fun JavaWriter.beginType(type: QualifiedClassName,
+                         kind: String,
+                         modifiers: Set<Modifier>,
+                         extendsType: QualifiedClassName,
+                         implementsType: Array<String>): JavaWriter {
+    return this.beginType(type.toString(), kind, modifiers, extendsType.toString(), *implementsType)
+}
+
+fun JavaWriter.beginType(type: QualifiedClassName,
+                         kind: String,
+                         modifiers: Set<Modifier>,
+                         extendsType: QualifiedClassName,
+                         implementsType: Array<SimpleClassName>): JavaWriter {
+    val types: Array<String> = implementsType.map { it.toString() }.toTypedArray()
+    return this.beginType(type.toString(), kind, modifiers, extendsType.toString(), *types)
+}
+
+fun JavaWriter.beginMethod(returnType: QualifiedClassName,
+                           name: String,
+                           modifiers: Set<Modifier>,
+                           vararg parameters: String): JavaWriter {
+    return this.beginMethod(returnType.toString(), name, modifiers, *parameters)
+}
+
+fun JavaWriter.beginMethod(returnType: QualifiedClassName,
+                           name: String,
+                           modifiers: Set<Modifier>,
+                           parameters: List<String>,
+                           throwsTypes: List<String>): JavaWriter {
+    return this.beginMethod(returnType.toString(), name, modifiers, parameters, throwsTypes)
+}
+
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.kt
similarity index 57%
rename from realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.kt
index f060cf2a41..d131746700 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/CamelCaseConverter.kt
@@ -13,32 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.processor.nameconverter;
+package io.realm.processor.nameconverter
 
 /**
  * Converter that converts input to "camelCase".
  */
-public class CamelCaseConverter implements NameConverter {
+class CamelCaseConverter : NameConverter {
 
-    private final WordTokenizer tokenizer = new WordTokenizer();
+    private val tokenizer = WordTokenizer()
 
-    @Override
-    public String convert(String name) {
-        String[] words = tokenizer.split(name);
-        StringBuilder output = new StringBuilder();
-        boolean firstWordEmitted = false;
-        for (int i = 0; i < words.length; i++) {
-            String word = words[i].toLowerCase();
+    override fun convert(name: String): String {
+        val words = tokenizer.split(name)
+        val output = StringBuilder()
+        var firstWordEmitted = false
+        for (i in words.indices) {
+            val word = words[i].toLowerCase()
             if (firstWordEmitted) {
-                int codepoint = word.codePointAt(0);
-                output.appendCodePoint(Character.toUpperCase(codepoint));
-                output.append(word.substring(Character.charCount(codepoint)));
+                val codepoint = word.codePointAt(0)
+                output.appendCodePoint(Character.toUpperCase(codepoint))
+                output.append(word.substring(Character.charCount(codepoint)))
             } else {
-                output.append(word);
-                firstWordEmitted = true;
+                output.append(word)
+                firstWordEmitted = true
             }
         }
 
-        return output.toString();
+        return output.toString()
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.kt
similarity index 74%
rename from realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.kt
index 4408407c3a..13e134da8b 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/IdentityConverter.kt
@@ -13,18 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.processor.nameconverter;
+package io.realm.processor.nameconverter
 
 /**
  * Converter that doesn't do any conversion when translating from Java to Realm.
  *
- * @see io.realm.annotations.RealmNamingPolicy#IDENTITY
+ * @see io.realm.annotations.RealmNamingPolicy.IDENTITY
  */
-public class IdentityConverter implements NameConverter {
+class IdentityConverter : NameConverter {
 
-    @Override
-    public String convert(String name) {
-        return name;
+    override fun convert(name: String): String {
+        return name
     }
 
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java
deleted file mode 100644
index 3be7b191a3..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor.nameconverter;
-
-/**
- * Converter that converts input to lower case with a defined separator character.
- */
-public class LowerCaseWithSeparatorConverter implements NameConverter {
-
-    private final WordTokenizer tokenizer = new WordTokenizer();
-    private final char separator;
-
-    public LowerCaseWithSeparatorConverter(char separator) {
-        this.separator = separator;
-    }
-
-    @Override
-    public String convert(String name) {
-        String[] words = tokenizer.split(name);
-        StringBuilder output = new StringBuilder();
-        for (int i = 0; i < words.length; i++) {
-            String word = words[i].toLowerCase();
-            output.append(word);
-            if (i < words.length - 1) {
-                output.append(separator);
-            }
-        }
-
-        return output.toString();
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.kt
new file mode 100644
index 0000000000..7f32ecb554
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/LowerCaseWithSeparatorConverter.kt
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter
+
+/**
+ * Converter that converts input to lower case with a defined separator character.
+ */
+class LowerCaseWithSeparatorConverter(private val separator: Char) : NameConverter {
+
+    private val tokenizer = WordTokenizer()
+
+    override fun convert(name: String): String {
+        val words = tokenizer.split(name)
+        val output = StringBuilder()
+        for (i in words.indices) {
+            val word = words[i].toLowerCase()
+            output.append(word)
+            if (i < words.size - 1) {
+                output.append(separator)
+            }
+        }
+
+        return output.toString()
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.kt
similarity index 79%
rename from realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.kt
index 593adf48ce..71db29acef 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/NameConverter.kt
@@ -13,19 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.processor.nameconverter;
+package io.realm.processor.nameconverter
 
 /**
  * Interface for converters that can implement a given naming policy.
  *
  * @see io.realm.annotations.RealmNamingPolicy
  */
-public interface NameConverter {
+interface NameConverter {
     /**
-     * Converts the {@code name} so it matches the {@link io.realm.annotations.RealmNamingPolicy}.
+     * Converts the `name` so it matches the [io.realm.annotations.RealmNamingPolicy].
      *
      * @param name string to convert.
      * @return the converted string.
      */
-    String convert(String name);
+    fun convert(name: String): String
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.kt
similarity index 60%
rename from realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java
rename to realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.kt
index 3849a72f64..41bdfa2359 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/PascalCaseConverter.kt
@@ -13,26 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.processor.nameconverter;
+package io.realm.processor.nameconverter
 
 /**
  * Converter that converts input to "PascalCase".
  */
-public class PascalCaseConverter implements NameConverter {
+class PascalCaseConverter : NameConverter {
 
-    private final WordTokenizer tokenizer = new WordTokenizer();
+    private val tokenizer = WordTokenizer()
 
-    @Override
-    public String convert(String name) {
-        String[] words = tokenizer.split(name);
-        StringBuilder output = new StringBuilder();
-        for (int i = 0; i < words.length; i++) {
-            String word = words[i].toLowerCase();
-            int codepoint = word.codePointAt(0);
-            output.appendCodePoint(Character.toUpperCase(codepoint));
-            output.append(word.substring(Character.charCount(codepoint)));
+    override fun convert(name: String): String {
+        val words = tokenizer.split(name)
+        val output = StringBuilder()
+        for (i in words.indices) {
+            val word = words[i].toLowerCase()
+            val codepoint = word.codePointAt(0)
+            output.appendCodePoint(Character.toUpperCase(codepoint))
+            output.append(word.substring(Character.charCount(codepoint)))
         }
 
-        return output.toString();
+        return output.toString()
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java
deleted file mode 100644
index 9a1e3caa27..0000000000
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright 2018 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.processor.nameconverter;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Segments a Java variable name into component words.
- *
- * Java variable names must follow the rules described in:
- * https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8
- *
- * In this implementation we treat word separators as any of the following:
- * <ol>
- *     <li>
- *         Anytime a {@code _} or {@code $} is encountered.
- *         Example is "_FooBar" or "_Foo$Bar" which both becomes "Foo" and "Bar".
- *     </li>
- *     <li>
- *         Anytime you switch from a lower case character to an upper case character as
- *         identified by a `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
- *         Example is "FooBar" which becomes "Foo" and "Bar".
- *     </li>
- *     <li>
- *         Anytime you switch from more than one uppercase character to a lower case one. As
- *         identified by `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
- *         Example is "FOOBar" which becomes "FOO" and "Bar.
- *     </li>
- *     <li>
- *         Some characters like emojiis are neither uppercase or lowercase characters, so they will
- *         not trigger any of the above rules.
- *         Examples are "my😁" and "MY😁" which are both treated as one word.
- *     </li>
- *     <li>
- *         Hungarian notation, i.e. strings starting with lowercase "m" followed by uppercase letter
- *         is stripped and not considered part of any word.
- *     </li>
- * </ol>
- */
-public class WordTokenizer {
-
-    /**
-     * Segments a string into words as described above
-     */
-    String[] split(String str) {
-        if (str == null || str.isEmpty()) {
-            return new String[0];
-        }
-
-        Integer previousCodepoint;
-        Integer currentCodepoint = null;
-        int length = str.length();
-        int offset = 0;
-        StringBuilder currentWord = new StringBuilder();
-        List<String> words = new ArrayList<>();
-        Boolean wordAllUpperCase = null;
-        int lastCodePointCharLength = 0;
-        while (offset < length) {
-            previousCodepoint = currentCodepoint;
-            currentCodepoint = str.codePointAt(offset);
-            int currentCharCount = Character.charCount(currentCodepoint);
-            boolean previousCodePointUpperCase = previousCodepoint != null && Character.isUpperCase(previousCodepoint);
-            boolean previousCodePointLowerCase = previousCodepoint != null && Character.isLowerCase(previousCodepoint);
-            boolean currentCodePointUpperCase = Character.isUpperCase(currentCodepoint);
-            boolean currentCodePointLowerCase = Character.isLowerCase(currentCodepoint);
-
-            // Separator char encountered not part of any word, but indicate a boundary
-            if (currentCodepoint == '_' || currentCodepoint == '$') {
-                if (currentWord.length() > 0) {
-                    words.add(currentWord.toString());
-                    currentWord.setLength(0);
-                }
-
-                wordAllUpperCase = null;
-                offset += currentCharCount;
-                lastCodePointCharLength = 0;
-                continue;
-            }
-
-            // Change between lower case and upper case indicate a word boundary
-            if (previousCodePointLowerCase && currentCodePointUpperCase) {
-                if (currentWord.length() > 0) {
-                    words.add(currentWord.toString());
-                    currentWord.setLength(0);
-                    currentWord.appendCodePoint(currentCodepoint);
-                }
-
-                wordAllUpperCase = true;
-                offset += currentCharCount;
-                lastCodePointCharLength = currentCharCount;
-                continue;
-            }
-
-            // Change between upper case and lower case indicated a word boundary on the previous
-            // char if multiple upper case characters where encountered.
-            if (currentWord.length() > 1
-                    && (wordAllUpperCase != null && wordAllUpperCase)
-                    && previousCodePointUpperCase && currentCodePointLowerCase) {
-                words.add(currentWord.substring(0, currentWord.length() - lastCodePointCharLength));
-                currentWord.substring(0, currentWord.length() - lastCodePointCharLength);
-                currentWord.delete(0, currentWord.length() - lastCodePointCharLength);
-                currentWord.appendCodePoint(currentCodepoint);
-
-                wordAllUpperCase = false;
-                offset += currentCharCount;
-                lastCodePointCharLength = currentCharCount;
-                continue;
-            }
-
-            // Add codepoint to current word
-            currentWord.appendCodePoint(currentCodepoint);
-            wordAllUpperCase = currentCodePointUpperCase && (wordAllUpperCase == null || wordAllUpperCase);
-            offset += currentCharCount;
-            lastCodePointCharLength = currentCharCount;
-        }
-
-        // Add final word when exiting loop
-        if (currentWord.length() > 0) {
-            words.add(currentWord.toString());
-        }
-
-        // Remove hungarian notation if found
-        if (words.get(0).equals("m")) {
-            words.remove(0);
-        }
-
-        String[] result = new String[words.size()];
-        words.toArray(result);
-        return result;
-    }
-}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.kt b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.kt
new file mode 100644
index 0000000000..c676c8033c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/nameconverter/WordTokenizer.kt
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor.nameconverter
+
+import java.util.ArrayList
+
+/**
+ * Segments a Java variable name into component words.
+ *
+ * Java variable names must follow the rules described in:
+ * https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8
+ *
+ * In this implementation we treat word separators as any of the following:
+ *
+ *  1. Anytime a `_` or `$` is encountered.
+ *     Example is "_FooBar" or "_Foo$Bar" which both becomes "Foo" and "Bar".
+ *
+ *  2. Anytime you switch from a lower case character to an upper case character as identified by a
+ *     `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
+ *     Example is "FooBar" which becomes "Foo" and "Bar".
+ *
+ *  3. Anytime you switch from more than one uppercase character to a lower case one. As identified
+ *     by `Character.isUpperCase(codepoint)` and `Character.isLowerCase(codepoint)`.
+ *     Example is "FOOBar" which becomes "FOO" and "Bar.
+ *
+ *  4. Some characters like emojiis are neither uppercase or lowercase characters, so they will
+ *     not trigger any of the above rules.
+ *     Examples are "my😁" and "MY😁" which are both treated as one word.
+ *
+ *  5. Hungarian notation, i.e. strings starting with lowercase "m" followed by uppercase letter
+ *     is stripped and not considered part of any word.
+ */
+class WordTokenizer {
+
+    /**
+     * Segments a string into words as described above
+     */
+    internal fun split(str: String?): Array<String> {
+        if (str == null || str.isEmpty()) {
+            return arrayOf()
+        }
+
+        var previousCodepoint: Int?
+        var currentCodepoint: Int? = null
+        val length = str.length
+        var offset = 0
+        val currentWord = StringBuilder()
+        val words = ArrayList<String>()
+        var wordAllUpperCase: Boolean? = null
+        var lastCodePointCharLength = 0
+        while (offset < length) {
+            previousCodepoint = currentCodepoint
+            currentCodepoint = str.codePointAt(offset)
+            val currentCharCount = Character.charCount(currentCodepoint)
+            val previousCodePointUpperCase = previousCodepoint != null && Character.isUpperCase(previousCodepoint)
+            val previousCodePointLowerCase = previousCodepoint != null && Character.isLowerCase(previousCodepoint)
+            val currentCodePointUpperCase = Character.isUpperCase(currentCodepoint)
+            val currentCodePointLowerCase = Character.isLowerCase(currentCodepoint)
+
+            // Separator char encountered not part of any word, but indicate a boundary
+            if (currentCodepoint == '_'.toInt() || currentCodepoint == '$'.toInt()) {
+                if (currentWord.isNotEmpty()) {
+                    words.add(currentWord.toString())
+                    currentWord.setLength(0)
+                }
+
+                wordAllUpperCase = null
+                offset += currentCharCount
+                lastCodePointCharLength = 0
+                continue
+            }
+
+            // Change between lower case and upper case indicate a word boundary
+            if (previousCodePointLowerCase && currentCodePointUpperCase) {
+                if (currentWord.isNotEmpty()) {
+                    words.add(currentWord.toString())
+                    currentWord.setLength(0)
+                    currentWord.appendCodePoint(currentCodepoint)
+                }
+
+                wordAllUpperCase = true
+                offset += currentCharCount
+                lastCodePointCharLength = currentCharCount
+                continue
+            }
+
+            // Change between upper case and lower case indicated a word boundary on the previous
+            // char if multiple upper case characters where encountered.
+            if (currentWord.length > 1
+                    && wordAllUpperCase != null && wordAllUpperCase
+                    && previousCodePointUpperCase && currentCodePointLowerCase) {
+                words.add(currentWord.substring(0, currentWord.length - lastCodePointCharLength))
+                currentWord.substring(0, currentWord.length - lastCodePointCharLength)
+                currentWord.delete(0, currentWord.length - lastCodePointCharLength)
+                currentWord.appendCodePoint(currentCodepoint)
+
+                wordAllUpperCase = false
+                offset += currentCharCount
+                lastCodePointCharLength = currentCharCount
+                continue
+            }
+
+            // Add codepoint to current word
+            currentWord.appendCodePoint(currentCodepoint)
+            wordAllUpperCase = currentCodePointUpperCase && (wordAllUpperCase == null || wordAllUpperCase)
+            offset += currentCharCount
+            lastCodePointCharLength = currentCharCount
+        }
+
+        // Add final word when exiting loop
+        if (currentWord.length > 0) {
+            words.add(currentWord.toString())
+        }
+
+        // Remove hungarian notation if found
+        if (words[0] == "m") {
+            words.removeAt(0)
+        }
+
+        return words.toTypedArray()
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
index 270007ac3e..b7ef785f6e 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TrustManagerCertificateValidationTests.java
@@ -27,6 +27,7 @@ public static void setUp() {
     //            adb push <realm-java>/tools/sync_test_server/keys/android_test_certificate.crt /sdcard/
     //            then import the certificate from the device (Settings/Security/Install from storage)
     @Test
+    @Ignore("FIXME: https://github.com/realm/realm-java/issues/6472")
     public void sslVerifyCallback_certificateChainWithRootCAInstalledShouldValidate() {
         // simulating the following certificate chain
         // ---
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index 08c58ce930..4624b3881f 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -19,6 +19,7 @@
 import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
@@ -50,6 +51,7 @@
 
     @Test
     @RunTestInLooperThread
+    @Ignore("FIXME: https://github.com/realm/realm-java/issues/6472")
     public void trustedRootCA() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
@@ -234,6 +236,7 @@ public void trustedRootCA_notExisting_certificate_willThrow() {
 
     @Test
     @RunTestInLooperThread
+    @Ignore("FIXME: https://github.com/realm/realm-java/issues/6472")
     public void combiningTrustedRootCA_and_disableSSLVerification() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
@@ -286,6 +289,7 @@ public void combiningTrustedRootCA_and_disableSSLVerification() throws Interrupt
     //            then import the certificate from the device (Settings/Security/Install from storage)
     @Test
     @RunTestInLooperThread
+    @Ignore("FIXME: https://github.com/realm/realm-java/issues/6472")
     public void sslVerifyCallback_isUsed() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
