diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9bb00126ad..c837445e46 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -16,12 +16,21 @@
 ### Breaking Changes
 
 * [ObjectServer] Updated protocol version to 19 which is only compatible with ROS > 2.0.0.
+* Realm has upgraded its RxJava1 support to RxJava2 (#3497)
+  * `Realm.asObservable()` has been renamed to `Realm.asFlowable()`.
+  * `RealmList.asObservable()` has been renamed to `RealmList.asFlowable()`.
+  * `RealmResults.asObservable()` has been renamed to `RealmResults.asFlowable()`.
+  * `RealmObject.asObservable()` has been renamed to `RealmObject.asFlowable()`.
+  * `RxObservableFactory` now return RxJava2 types instead of RxJava1 types.
 
 ### Deprecated
 
 ### Enhancements
 
 * Added `static RealmObject.getRealm(RealmModel)`, `RealmObject.getRealm()` and `DynamicRealmObject.getDynamicRealm()` (#4720).
+* Added `RealmResults.asChangesetObservable()` that emits the pair `(results, changeset)` (#4277).
+* Added `RealmList.asChangesetObservable()` that emits the pair `(list, changeset)` (#4277).
+* Added `RealmObject.asChangesetObservable()` that emits the pair `(object, changeset)` (#4277).
 
 ### Bug Fixes
 
@@ -36,6 +45,7 @@
 ### Bug Fixes
 
 * Fixed a JNI memory issue when doing queries which might potentially cause various native crashes.
+* Fixed a bug that `RealmList.deleteFromRealm(int)`, `RealmList.deleteFirstFromRealm()` and `RealmList.deleteLastFromRealm()` did not remove target objects from Realm. This bug was introduced in `3.7.1` (#5233).
 
 ## 3.7.1 (2017-09-07)
 
diff --git a/Jenkinsfile b/Jenkinsfile
index dc74785a4d..b1613502e4 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -51,7 +51,7 @@ try {
                 }
               } finally {
                 storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
-                storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+                // storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml' FIXME when updating examples
                 step([$class: 'LintPublisher'])
               }
             }
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 0f9f5242bd..361ed3b8f1 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -9,9 +9,9 @@ include 'moduleExample:app'
 include 'moduleExample:library'
 include 'realmModuleExample'
 include 'threadExample'
-include 'unitTestExample'
-include 'newsreaderExample'
-include 'rxJavaExample'
+//include 'unitTestExample' FIXME: Upgrade to RxJava2
+//include 'newsreaderExample' FIXME: Upgrade to RxJava2
+//include 'rxJavaExample' FIXME: Upgrade to RxJava2
 include 'objectServerExample'
 
 rootProject.name = 'realm-examples'
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 63c26342a1..7ffe3588bb 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -179,7 +179,7 @@ repositories {
 
 dependencies {
 
-    compileOnly 'io.reactivex:rxjava:1.1.0'
+    compileOnly 'io.reactivex.rxjava2:rxjava:2.1.0'
     compileOnly 'com.google.code.findbugs:findbugs-annotations:3.0.1'
 
     api "io.realm:realm-annotations:${version}"
@@ -191,7 +191,7 @@ dependencies {
 
     kaptAndroidTest project(':realm-annotations-processor')
     androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
-    androidTestImplementation 'io.reactivex:rxjava:1.1.0'
+    androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.0'
     androidTestImplementation 'com.android.support.test:runner:1.0.0'
     androidTestImplementation 'com.android.support.test:rules:1.0.0'
     androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 9a38ec50b1..7b38283cfa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -239,4 +239,8 @@ boolean isSnapshot(CollectionClass collectionClass) {
         return collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE ||
                 collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE;
     }
+
+    boolean isRealmList(ManagedCollection collectionClass) {
+        return collectionClass == ManagedCollection.MANAGED_REALMLIST;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 8e81f62878..c50e59cc54 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -34,6 +34,7 @@
 import java.util.concurrent.Future;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
@@ -613,15 +614,25 @@ public void sort_long() {
     public void deleteFromRealm() {
         OrderedRealmCollection<Dog> collection = createNonCyclicCollection(realm, collectionClass);
         assertEquals(1, collection.get(1).getAge());
-        realm.beginTransaction();
-        collection.deleteFromRealm(0);
-        realm.commitTransaction();
-        if (isSnapshot(collectionClass)) {
-            assertEquals(TEST_SIZE, collection.size());
-            assertFalse(collection.get(0).isValid());
-        } else {
-            assertEquals(TEST_SIZE - 1, collection.size());
-            assertEquals(2, collection.get(1).getAge());
+
+        int[] indexToDelete = {TEST_SIZE/2, TEST_SIZE - 2, 0};
+        int currentSize = TEST_SIZE;
+
+        for (int i = 0; i < indexToDelete.length; i++) {
+            int index = indexToDelete[i];
+            realm.beginTransaction();
+            Dog dog = collection.get(index);
+            collection.deleteFromRealm(index);
+            realm.commitTransaction();
+            if (isSnapshot(collectionClass)) {
+                assertEquals(TEST_SIZE, collection.size());
+                assertFalse(collection.get(index).isValid());
+            } else {
+                assertEquals(currentSize- 1, collection.size());
+            }
+            assertFalse(dog.isValid());
+            assertEquals(currentSize- 1, realm.where(Dog.class).count());
+            currentSize -= 1;
         }
     }
 
@@ -646,6 +657,7 @@ public void deleteFirstFromRealm() {
         assertEquals(0, collection.get(0).getAge());
 
         realm.beginTransaction();
+        Dog dog = collection.first();
         assertTrue(collection.deleteFirstFromRealm());
         realm.commitTransaction();
         if (isSnapshot(collectionClass)) {
@@ -655,6 +667,8 @@ public void deleteFirstFromRealm() {
             assertEquals(TEST_SIZE - 1, collection.size());
             assertEquals(1, collection.get(0).getAge());
         }
+        assertFalse(dog.isValid());
+        assertEquals(TEST_SIZE - 1, realm.where(Dog.class).count());
     }
 
     private OrderedRealmCollection<Dog> createNonCyclicCollection(Realm realm, ManagedCollection collectionClass) {
@@ -709,6 +723,7 @@ public void deleteFirstFromRealm_emptyCollection() {
     public void deleteLastFromRealm() {
         assertEquals(TEST_SIZE - 1, collection.last().getFieldLong());
         realm.beginTransaction();
+        AllJavaTypes allJavaTypes = collection.last();
         assertTrue(collection.deleteLastFromRealm());
         realm.commitTransaction();
         if (isSnapshot(collectionClass)) {
@@ -718,6 +733,8 @@ public void deleteLastFromRealm() {
             assertEquals(TEST_SIZE - 1, collection.size());
             assertEquals(TEST_SIZE - 2, collection.last().getFieldLong());
         }
+        assertFalse(allJavaTypes.isValid());
+        assertEquals(TEST_SIZE - 1, realm.where(AllJavaTypes.class).count());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 387920dc58..341b181ad4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -671,6 +672,12 @@ public void deleteAllFromRealm() {
         } else {
             assertEquals(0, collection.size());
         }
+        if (isRealmList(collectionClass)) {
+            // The parent object was not deleted
+            assertEquals(1, realm.where(AllJavaTypes.class).count());
+        } else {
+            assertEquals(0, realm.where(AllJavaTypes.class).count());
+        }
     }
 
     @Test(expected = IllegalStateException.class)
@@ -691,11 +698,10 @@ public void deleteAllFromRealm_emptyList() {
     @Test
     public void deleteAllFromRealm_invalidList() {
         realm.close();
-        try {
-            collection.deleteAllFromRealm();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(CoreMatchers.containsString(
+                "This Realm instance has already been closed, making it unusable."));
+        collection.deleteAllFromRealm();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index b6a6955cfe..3197a6b663 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,6 +16,11 @@
 
 package io.realm;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -24,15 +29,13 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.test.MoreAsserts;
-
 import java.io.File;
 import java.io.IOException;
 import java.util.Set;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.Single;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnimalModule;
 import io.realm.entities.AssetFileModule;
@@ -49,9 +52,10 @@
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rx.CollectionChange;
+import io.realm.rx.ObjectChange;
 import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
-import rx.Observable;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -701,52 +705,82 @@ public void modelClasses_forFilterableMediator() throws Exception {
     public void rxFactory() {
         final RxObservableFactory dummyFactory = new RxObservableFactory() {
             @Override
-            public Observable<Realm> from(Realm realm) {
+            public Flowable<Realm> from(Realm realm) {
+                return null;
+            }
+
+            @Override
+            public Flowable<DynamicRealm> from(DynamicRealm realm) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmModel> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results) {
+                return null;
+            }
+
+            @Override
+            public Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+                return null;
+            }
+
+            @Override
+            public Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+                return null;
+            }
+
+            @Override
+            public <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public Observable<DynamicRealm> from(DynamicRealm realm) {
+            public <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+            public Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
                 return null;
             }
 
             @Override
-            public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+            public Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+            public <E extends RealmModel> Flowable<E> from(Realm realm, E object) {
                 return null;
             }
 
             @Override
-            public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+            public <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, E object) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<E> from(Realm realm, E object) {
+            public Flowable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object) {
                 return null;
             }
 
             @Override
-            public Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object) {
+            public Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, DynamicRealmObject object) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+            public <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
                 return null;
             }
 
             @Override
-            public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+            public Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
                 return null;
             }
         };
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 057bc0d958..7cfc9f674d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -29,8 +29,8 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
@@ -39,7 +39,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -104,6 +103,7 @@ public void tearDown() throws Exception {
 
     private RealmList<Dog> createDeletedRealmList() {
         Owner owner = realm.where(Owner.class).findFirst();
+        //noinspection ConstantConditions
         RealmList<Dog> dogs = owner.getDogs();
 
         realm.beginTransaction();
@@ -473,6 +473,20 @@ public void remove_byIndex() {
 
         assertEquals(dog5, removedDog);
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
+    }
+
+    @Test
+    public void remove_first() {
+        Owner owner = realm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        realm.beginTransaction();
+        dogs.remove(0);
+        realm.commitTransaction();
+
+        assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -485,6 +499,7 @@ public void remove_last() {
         realm.commitTransaction();
 
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -510,6 +525,7 @@ public void remove_byObject() {
 
         assertTrue(result);
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -610,7 +626,7 @@ public void removeAll_unmanaged_wrongClass() {
     }
 
     @Test
-    public void remove_allAfterContainerObjectRemoved() {
+    public void removeAll_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
         realm.beginTransaction();
@@ -618,6 +634,14 @@ public void remove_allAfterContainerObjectRemoved() {
         dogs.removeAll(Collections.<Dog>emptyList());
     }
 
+    @Test
+    public void removeAll_outsideTransaction() {
+        List<Dog> objectsToRemove = Collections.singletonList(collection.get(0));
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(CoreMatchers.containsString("Objects can only be removed from inside a write transaction"));
+        collection.removeAll(objectsToRemove);
+    }
+
     @Test
     public void get_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
@@ -762,66 +786,6 @@ public void realmMethods_onDeletedLinkView() {
         }
     }
 
-    @Test
-    public void removeAllFromRealm() {
-        Owner owner = realm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-    }
-
-    @Test
-    public void removeAllFromRealm_outsideTransaction() {
-        Owner owner = realm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        try {
-            dogs.deleteAllFromRealm();
-            fail("removeAllFromRealm should be called in a transaction.");
-        } catch (IllegalStateException e) {
-            assertThat(e.getMessage(), CoreMatchers.containsString("Must be in a write transaction "));
-        }
-    }
-
-    @Test
-    public void removeAllFromRealm_emptyList() {
-        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-
-        // The dogs is empty now.
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-
-    }
-
-    @Test
-    public void removeAllFromRealm_invalidListShouldThrow() {
-        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-        realm.close();
-        realm = null;
-
-        try {
-            dogs.deleteAllFromRealm();
-            fail("dogs is invalid and it should throw an exception");
-        } catch (IllegalStateException e) {
-            assertEquals("This Realm instance has already been closed, making it unusable.", e.getMessage());
-        }
-    }
-
     @Test
     public void add_set_objectFromOtherThread() {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
@@ -871,7 +835,7 @@ public void add_set_dynamicObjectFromOtherThread() throws Throwable {
         final DynamicRealmObject dynDog = dynamicRealm.where(Dog.CLASS_NAME).findFirst();
         final String expectedMsg = "Cannot copy an object to a Realm instance created in another thread.";
 
-        final AtomicReference<Throwable> thrownErrorRef = new AtomicReference<Throwable>();
+        final AtomicReference<Throwable> thrownErrorRef = new AtomicReference<>();
 
         new Thread(new Runnable() {
             @Override
@@ -963,6 +927,7 @@ public void add_set_withWrongDynamicObjectType() {
     @Test
     public void add_set_dynamicObjectCreatedFromTypedRealm() {
         final String expectedMsg = "Cannot copy DynamicRealmObject between Realm instances.";
+        //noinspection ConstantConditions
         DynamicRealmObject dynDog = new DynamicRealmObject(realm.where(Dog.class).findFirst());
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index eafe61d82d..0e3d29d2df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -31,20 +31,24 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.Flowable;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Action;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Predicate;
 import io.realm.entities.AllTypes;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
-import rx.Observable;
-import rx.Subscription;
-import rx.functions.Action0;
-import rx.functions.Action1;
-import rx.functions.Func1;
+import io.realm.rx.CollectionChange;
+import io.realm.rx.ObjectChange;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -57,8 +61,8 @@
     public final RunInLooperThread looperThread = new RunInLooperThread() {
         @Override
         public void looperTearDown() {
-            if (subscription != null && !subscription.isUnsubscribed()) {
-                subscription.unsubscribe();
+            if (subscription != null && !subscription.isDisposed()) {
+                subscription.dispose();
             }
         }
     };
@@ -66,7 +70,7 @@ public void looperTearDown() {
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
     private Realm realm;
-    private Subscription subscription;
+    private Disposable subscription;
 
     @Before
     public void setUp() throws Exception {
@@ -90,15 +94,57 @@ public void realmObject_emittedOnSubscribe() {
         realm.commitTransaction();
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = obj.<AllTypes>asFlowable().subscribe(new Consumer <AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 assertTrue(rxObject == obj);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmObject_emitChangesetOnSubscribe() {
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                assertTrue(change.getObject() == obj);
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmObject_emitChangesetOnSubscribe() {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject obj = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                assertTrue(change.getObject() == obj);
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
+        dynamicRealm.close();
     }
 
     @Test
@@ -110,10 +156,35 @@ public void realmObject_emittedOnUpdate() {
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = obj.<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
+            @Override
+            public void accept(AllTypes allTypes) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        obj.setColumnLong(1);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmObject_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
+                    assertNotNull(change.getChangeset());
+                    assertTrue(change.getChangeset().isFieldChanged(AllTypes.FIELD_LONG));
                     looperThread.testComplete();
                 }
             }
@@ -124,6 +195,31 @@ public void call(AllTypes rxObject) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmObject_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(realm);
+        realm.beginTransaction();
+        final DynamicRealmObject obj = realm.createObject(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertNotNull(change.getChangeset());
+                    assertTrue(change.getChangeset().isFieldChanged(AllTypes.FIELD_LONG));
+                    looperThread.testComplete();
+                }
+            }
+        });
+        realm.beginTransaction();
+        obj.setLong(AllTypes.FIELD_LONG, 1);
+        realm.commitTransaction();
+    }
+
     @Test
     @UiThreadTest
     public void findFirst_emittedOnSubscribe() {
@@ -132,15 +228,15 @@ public void findFirst_emittedOnSubscribe() {
         realm.commitTransaction();
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 42).findFirst().<AllTypes>asObservable()
-                .subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 42).findFirst().<AllTypes>asFlowable()
+                .subscribe(new Consumer <AllTypes>() {
                     @Override
-                    public void call(AllTypes rxObject) {
+                    public void accept(AllTypes allTypes) throws Exception {
                         subscribedNotified.set(true);
                     }
                 });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -152,15 +248,15 @@ public void findFirstAsync_emittedOnSubscribe() {
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
-        subscription = asyncObj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = asyncObj.<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 assertTrue(rxObject == asyncObj);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -171,9 +267,9 @@ public void findFirstAsync_emittedOnUpdate() {
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
-        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -191,12 +287,12 @@ public void findFirstAsync_emittedOnDelete() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
-        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(final AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 switch (subscriberCalled.incrementAndGet()) {
                     case 1:
                         assertFalse(rxObject.isLoaded());
@@ -228,16 +324,32 @@ public void execute(Realm realm) {
     public void realmResults_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmResults_emittedChangesetOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<AllTypes>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<AllTypes>> change) throws Exception {
+                assertEquals(results, change.getCollection());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
     }
 
     @Test
@@ -247,16 +359,35 @@ public void realmList_emittedOnSubscribe() {
         realm.beginTransaction();
         final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
-        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+        subscription = list.asFlowable().subscribe(new Consumer<RealmList<Dog>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmList<Dog> rxList) {
+            public void accept(RealmList<Dog> rxList) throws Exception {
                 assertTrue(rxList == list);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmList_emittedChangesetOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+        subscription = list.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmList<Dog>>>() {
+            @Override
+            public void accept(CollectionChange<RealmList<Dog>> change) throws Exception {
+                assertEquals(list, change.getCollection());
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
     }
 
     @Test
@@ -265,17 +396,36 @@ public void dynamicRealmResults_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<DynamicRealmObject> rxResults) {
+            public void accept(RealmResults<DynamicRealmObject> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
         dynamicRealm.close();
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmResults_emittedChangesetOnSubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<DynamicRealmObject>> change) throws Exception {
+                assertEquals(results, change.getCollection());
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        dynamicRealm.close();
+        subscription.dispose();
     }
 
     @Test
@@ -287,9 +437,9 @@ public void realmResults_emittedOnUpdate() {
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.commitTransaction();
 
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> allTypes) {
+            public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -301,6 +451,29 @@ public void call(RealmResults<AllTypes> allTypes) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void realmResults_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        realm.commitTransaction();
+
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<AllTypes>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<AllTypes>> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, change.getChangeset().getInsertions().length);
+                    looperThread.testComplete();
+                }
+            }
+        });
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void realmList_emittedOnUpdate() {
@@ -310,11 +483,36 @@ public void realmList_emittedOnUpdate() {
         final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
 
-        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+        subscription = list.asFlowable().subscribe(new Consumer<RealmList<Dog>>() {
+            @Override
+            public void accept(RealmList<Dog> dogs) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, list.size());
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        list.add(new Dog());
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmList_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+
+        subscription = list.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmList<Dog>>>() {
             @Override
-            public void call(RealmList<Dog> dogs) {
+            public void accept(CollectionChange<RealmList<Dog>> change) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     assertEquals(1, list.size());
+                    assertEquals(1, change.getChangeset().getInsertions().length);
                     looperThread.testComplete();
                 }
             }
@@ -334,9 +532,9 @@ public void dynamicRealmResults_emittedOnUpdate() {
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
 
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void call(RealmResults<DynamicRealmObject> allTypes) {
+            public void accept(RealmResults<DynamicRealmObject> dynamicRealmObjects) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     dynamicRealm.close();
                     looperThread.testComplete();
@@ -349,21 +547,46 @@ public void call(RealmResults<DynamicRealmObject> allTypes) {
         dynamicRealm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmResults_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(dynamicRealm);
+        dynamicRealm.beginTransaction();
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        dynamicRealm.commitTransaction();
+
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<DynamicRealmObject>> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, change.getChangeset().getInsertions().length);
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+    }
+
     @Test
     @UiThreadTest
     public void findAllAsync_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -371,9 +594,9 @@ public void call(RealmResults<AllTypes> rxResults) {
     public void findAllAsync_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.getRealm();
-        subscription = realm.where(AllTypes.class).findAllAsync().asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = realm.where(AllTypes.class).findAllAsync().asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -389,15 +612,15 @@ public void call(RealmResults<AllTypes> rxResults) {
     @UiThreadTest
     public void realm_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -405,9 +628,9 @@ public void call(Realm rxRealm) {
     public void realm_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.getRealm();
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm realm) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -424,22 +647,23 @@ public void call(Realm rxRealm) {
     public void dynamicRealm_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+        subscription = dynamicRealm.asFlowable().subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm rxRealm) throws Exception {
                 assertTrue(rxRealm == dynamicRealm);
                 subscribedNotified.set(true);
             }
-        }, new Action1<Throwable>() {
+        }, new Consumer<Throwable>() {
             @Override
-            public void call(Throwable throwable) {
+            public void accept(Throwable throwable) throws Exception {
                 throwable.printStackTrace();
+                fail();
             }
         });
 
         assertTrue(subscribedNotified.get());
         dynamicRealm.close();
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -447,9 +671,9 @@ public void call(Throwable throwable) {
     public void dynamicRealm_emittedOnUpdate() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+        subscription = dynamicRealm.asFlowable().subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm dynamicRealm) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     dynamicRealm.close();
                     looperThread.testComplete();
@@ -466,15 +690,15 @@ public void call(DynamicRealm rxRealm) {
     @UiThreadTest
     public void unsubscribe_sameThread() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
         });
         assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
-        subscription.unsubscribe();
+        subscription.dispose();
         assertEquals(0, realm.sharedRealm.realmNotifier.getListenersListSize());
     }
 
@@ -483,9 +707,9 @@ public void call(Realm rxRealm) {
     public void unsubscribe_fromOtherThread() {
         final CountDownLatch unsubscribeCompleted = new CountDownLatch(1);
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final Subscription subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        final Disposable subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
@@ -496,7 +720,7 @@ public void call(Realm rxRealm) {
             @Override
             public void run() {
                 try {
-                    subscription.unsubscribe();
+                    subscription.dispose();
                     fail();
                 } catch (IllegalStateException ignored) {
                 } finally {
@@ -506,7 +730,7 @@ public void run() {
         }).start();
         TestHelper.awaitOrFail(unsubscribeCompleted);
         assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
-        // We cannot call subscription.unsubscribe() again, so manually close the extra Realm instance opened by
+        // We cannot call subscription.dispose() again, so manually close the extra Realm instance opened by
         // the Observable.
         realm.close();
     }
@@ -518,15 +742,16 @@ public void wrongGenericClassThrows() {
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<CyclicType> obs = obj.asObservable();
-        obs.subscribe(new Action1<CyclicType>() {
+        Flowable<CyclicType> obs = obj.asFlowable();
+        @SuppressWarnings("unused")
+        Disposable subscription = obs.subscribe(new Consumer<CyclicType>() {
             @Override
-            public void call(CyclicType cyclicType) {
+            public void accept(CyclicType cyclicType) throws Exception {
                 fail();
             }
-        }, new Action1<Throwable>() {
+        }, new Consumer<Throwable>() {
             @Override
-            public void call(Throwable ignored) {
+            public void accept(Throwable ignored) throws Exception {
             }
         });
     }
@@ -534,21 +759,22 @@ public void call(Throwable ignored) {
     @Test
     @UiThreadTest
     public void realm_closeInDoOnUnsubscribe() {
-        Observable<Realm> observable = realm.asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<Realm> observable = realm.asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<Realm>() {
+        subscription = observable.subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm realm) throws Exception {
+                assertEquals(2, Realm.getLocalInstanceCount(realm.getConfiguration()));
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -557,42 +783,42 @@ public void call(Realm rxRealm) {
     public void dynamicRealm_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealm> observable = dynamicRealm.asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<DynamicRealm> observable = dynamicRealm.asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<DynamicRealm>() {
+        subscription = observable.subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
     @Test
     @UiThreadTest
     public void realmResults_closeInDoOnUnsubscribe() {
-        Observable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = observable.subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> allTypes) {
+            public void accept(RealmResults<AllTypes> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -603,19 +829,19 @@ public void realmList_closeInDoOnUnsubscribe() {
         RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
 
-        Observable<RealmList<Dog>> observable = list.asObservable().doOnUnsubscribe(new Action0() {
+        Flowable<RealmList<Dog>> observable = list.asFlowable().doOnCancel(new Action() {
             @Override
-            public void call() {
+            public void run() throws Exception {
                 realm.close();
             }
         });
-        subscription = observable.subscribe(new Action1<RealmList<Dog>>() {
+        subscription = observable.subscribe(new Consumer<RealmList<Dog>>() {
             @Override
-            public void call(RealmList<Dog> dogs) {
+            public void accept(RealmList<Dog> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -624,21 +850,21 @@ public void call(RealmList<Dog> dogs) {
     public void dynamicRealmResults_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<RealmResults<DynamicRealmObject>> flowable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = flowable.subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void call(RealmResults<DynamicRealmObject> allTypes) {
+            public void accept(RealmResults<DynamicRealmObject> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
@@ -649,21 +875,21 @@ public void realmObject_closeInDoOnUnsubscribe() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<AllTypes> observable = realm.where(AllTypes.class).findFirst().<AllTypes>asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<AllTypes> flowable = realm.where(AllTypes.class).findFirst().<AllTypes>asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<AllTypes>() {
+        subscription = flowable.subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes allTypes) {
+            public void accept(AllTypes ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -675,21 +901,21 @@ public void dynamicRealmObject_closeInDoOnUnsubscribe() {
         realm.commitTransaction();
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealmObject> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<DynamicRealmObject> flowable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<DynamicRealmObject>() {
+        subscription = flowable.subscribe(new Consumer<DynamicRealmObject>() {
             @Override
-            public void call(DynamicRealmObject obj) {
+            public void accept(DynamicRealmObject ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
@@ -697,6 +923,7 @@ public void call(DynamicRealmObject obj) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void realmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -710,26 +937,26 @@ public void realmResults_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
-                    .filter(new Func1<RealmResults<AllTypes>, Boolean>() {
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asFlowable()
+                    .filter(new Predicate<RealmResults<AllTypes>>() {
                         @Override
-                        public Boolean call(RealmResults<AllTypes> results) {
+                        public boolean test(RealmResults<AllTypes> results) throws Exception {
                             return results.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<RealmResults<AllTypes>>() {
+                    .subscribe(new Consumer<RealmResults<AllTypes>>() {
                         @Override
-                        public void call(RealmResults<AllTypes> result) {
+                        public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -740,6 +967,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void dynamicRealmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -753,17 +981,17 @@ public void dynamicRealmResults_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
-                    .filter(new Func1<RealmResults<DynamicRealmObject>, Boolean>() {
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asFlowable()
+                    .filter(new Predicate<RealmResults<DynamicRealmObject>>() {
                         @Override
-                        public Boolean call(RealmResults<DynamicRealmObject> results) {
+                        public boolean test(RealmResults<DynamicRealmObject> results) throws Exception {
                             return results.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+                    .subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
                         @Override
-                        public void call(RealmResults<DynamicRealmObject> result) {
+                        public void accept(RealmResults<DynamicRealmObject> dynamicRealmObjects) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
@@ -771,9 +999,9 @@ public void call(RealmResults<DynamicRealmObject> result) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -784,6 +1012,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void realmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -797,26 +1026,26 @@ public void realmObject_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asObservable()
-                    .filter(new Func1<AllTypes, Boolean>() {
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asFlowable()
+                    .filter(new Predicate<AllTypes>() {
                         @Override
-                        public Boolean call(AllTypes obj) {
+                        public boolean test(AllTypes obj) throws Exception {
                             return obj.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<AllTypes>() {
+                    .subscribe(new Consumer<AllTypes>() {
                         @Override
-                        public void call(AllTypes result) {
+                        public void accept(AllTypes allTypes) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -827,6 +1056,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void dynamicRealmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -840,17 +1070,17 @@ public void dynamicRealmObject_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asObservable()
-                    .filter(new Func1<DynamicRealmObject, Boolean>() {
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asFlowable()
+                    .filter(new Predicate<DynamicRealmObject>() {
                         @Override
-                        public Boolean call(DynamicRealmObject obj) {
+                        public boolean test(DynamicRealmObject obj) throws Exception {
                             return obj.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<DynamicRealmObject>() {
+                    .subscribe(new Consumer<DynamicRealmObject>() {
                         @Override
-                        public void call(DynamicRealmObject result) {
+                        public void accept(DynamicRealmObject dynamicRealmObject) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
@@ -858,9 +1088,9 @@ public void call(DynamicRealmObject result) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index fd893254ba..3ddea3c362 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -662,7 +662,7 @@ public void defaultValue_setAndGet() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
                     // FIXME: Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -783,7 +783,7 @@ public void defaultValue_setMultipleTimes() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
                     // FIXME: Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -913,7 +913,7 @@ public void defaultValue_overwrittenByNonDefault() {
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
                     // FIXME: Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
index fe15002409..19ac174bc1 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
@@ -192,6 +192,17 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsList_nativeIsValid(JNIEnv* e
     return JNI_FALSE;
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDelete(JNIEnv* env, jclass, jlong list_ptr, jlong index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& list = *reinterpret_cast<List*>(list_ptr);
+        list.delete_at(S(index));
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDeleteAll(JNIEnv* env, jclass, jlong list_ptr)
 {
     TR_ENTER_PTR(list_ptr)
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index d1a101fda6..4e3e0fbc90 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit d1a101fda6999e070c1e73cc5aff002c3de7c129
+Subproject commit 4e3e0fbc90b0c5cea53bfe07c2b93da2a033fd5e
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index ad0911e2a4..cd819a8608 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.reactivex.Flowable;
 import javax.annotation.Nullable;
 
 import io.realm.exceptions.RealmException;
@@ -44,8 +45,6 @@
 import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * Base class for all Realm instances.
@@ -222,16 +221,16 @@ public boolean isInTransaction() {
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
+     * Returns an RxJava Flowable that monitors changes to this Realm. It will emit the current state
      * when subscribed to. Items will continually be emitted as the Realm is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items, you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items, you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * realm.asObservable().first().subscribe( ... ) // You only get the results once
+     * realm.asFlowable().first().subscribe( ... ) // You only get the results once
      * }
      * </pre>
      *
@@ -239,7 +238,7 @@ public boolean isInTransaction() {
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public abstract Observable asObservable();
+    public abstract Flowable asFlowable();
 
     /**
      * Removes all user-defined change listeners.
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 10bb52dab8..1dec0499b0 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+import io.reactivex.Flowable;
 import java.util.Locale;
 
 import io.realm.exceptions.RealmException;
@@ -25,8 +26,6 @@
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
@@ -261,7 +260,7 @@ static DynamicRealm createInstance(SharedRealm sharedRealm) {
      * {@inheritDoc}
      */
     @Override
-    public Observable<DynamicRealm> asObservable() {
+    public Flowable<DynamicRealm> asFlowable() {
         return configuration.getRxFactory().from(this);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 63b75e95b2..bd85dd7bb3 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -46,6 +46,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.reactivex.Flowable;
 import javax.annotation.Nullable;
 
 import io.realm.exceptions.RealmException;
@@ -63,8 +64,6 @@
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
@@ -183,7 +182,7 @@ private static OsSchemaInfo createExpectedSchemaInfo(RealmProxyMediator mediator
      * {@inheritDoc}
      */
     @Override
-    public Observable<Realm> asObservable() {
+    public Flowable<Realm> asFlowable() {
         return configuration.getRxFactory().from(this);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 4504abbc05..ad52ddfa33 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -399,7 +399,7 @@ public String toString() {
     static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
             try {
-                Class.forName("rx.Observable");
+                Class.forName("io.reactivex.Flowable");
                 rxJavaAvailable = true;
             } catch (ClassNotFoundException ignore) {
                 rxJavaAvailable = false;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 86575af28e..9eaf1645e6 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -28,14 +28,15 @@
 import java.util.Locale;
 import java.util.NoSuchElementException;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import io.realm.internal.InvalidRow;
 import io.realm.internal.OsList;
 import io.realm.internal.RealmObjectProxy;
-import rx.Observable;
-
+import io.realm.rx.CollectionChange;
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
@@ -584,7 +585,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     public void deleteFromRealm(int location) {
         if (isManaged()) {
             checkValidRealm();
-            osList.remove(location);
+            osList.delete(location);
             modCount++;
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -877,16 +878,16 @@ public String toString() {
     }
 
     /**
-     * Returns an Rx Observable that monitors changes to this RealmList. It will emit the current RealmList when
+     * Returns an Rx Flowable that monitors changes to this RealmList. It will emit the current RealmList when
      * subscribed to. RealmList will continually be emitted as the RealmList is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * list.asObservable()
+     * list.asFlowable()
      *      .first()
      *      .subscribe( ... ) // You only get the results once
      * }
@@ -902,17 +903,47 @@ public String toString() {
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
     @SuppressWarnings("unchecked")
-    public Observable<RealmList<E>> asObservable() {
+    public Flowable<RealmList<E>> asFlowable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
         } else if (realm instanceof DynamicRealm) {
             DynamicRealm dynamicRealm = (DynamicRealm) realm;
             RealmList<DynamicRealmObject> dynamicList = (RealmList<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
-            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicList);
+            Flowable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicList);
             return results;
         } else {
-            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
+        }
+    }
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmList. It will emit the current RealmList when
+     * subscribed. For each update to the RealmList a pair consisting of the RealmList and the
+     * {@link OrderedCollectionChangeSet} will be sent. The changeset will be {@code null} the first
+     * time an RealmList is emitted.
+     * <p>
+     * RealmList will continually be emitted as the RealmList is updated - {@code onComplete} will never be called.
+     * <p>
+ *   * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public Observable<CollectionChange<RealmList<E>>> asChangesetObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmList<DynamicRealmObject> dynamicResults = (RealmList<DynamicRealmObject>) this;
+            return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicResults);
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 020c7f5b07..6de1183104 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -18,13 +18,14 @@
 
 import android.app.IntentService;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.annotations.RealmClass;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.ManagableObject;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import rx.Observable;
-
+import io.realm.rx.ObjectChange;
 
 /**
  * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then
@@ -123,7 +124,7 @@ public final void deleteFromRealm() {
      * when observed.
      * <pre>
      * {@code
-     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asObservable()
+     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asFlowable()
      *      .filter(result.isLoaded() && result.isValid())
      *      .first()
      * }
@@ -536,7 +537,7 @@ public final boolean load() {
      * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
-        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<>(listener));
     }
 
     /**
@@ -601,7 +602,7 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener<E> listener) {
-        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<>(listener));
     }
 
     /**
@@ -652,19 +653,19 @@ public final void removeAllChangeListeners() {
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * Returns an RxJava Flowable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * When chaining a RealmObject flowable use {@code obj.<MyRealmObjectClass>asFlowable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * obj.asObservable()
+     * obj.asFlowable()
      *      .filter(obj -> obj.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the object once
@@ -683,25 +684,47 @@ public final void removeAllChangeListeners() {
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public final <E extends RealmObject> Observable<E> asObservable() {
+    public final <E extends RealmObject> Flowable<E> asFlowable() {
         //noinspection unchecked
-        return (Observable<E>) RealmObject.asObservable(this);
+        return (Flowable<E>) RealmObject.asFlowable(this);
+    }
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmObject. It will emit the current RealmObject when
+     * subscribed to. For each update to the RealmObject a pair consisting of the RealmObject and the
+     * {@link ObjectChangeSet} will be sent. The changeset will be {@code null} the first
+     * time the RealmObject is emitted.
+     * <p>
+     * The RealmObject will continually be emitted as it is updated - {@code onComplete} will never be called.
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public final <E extends RealmObject> Observable<ObjectChange<E>> asChangesetObservable() {
+        return (Observable) RealmObject.asChangesetObservable(this);
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * Returns an RxJava Flowable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asFlowable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * obj.asObservable()
+     * obj.asFlowable()
      *      .filter(obj -> obj.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the object once
@@ -713,7 +736,7 @@ public final void removeAllChangeListeners() {
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public static <E extends RealmModel> Observable<E> asObservable(E object) {
+    public static <E extends RealmModel> Flowable<E> asFlowable(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
@@ -723,7 +746,7 @@ public final void removeAllChangeListeners() {
                 DynamicRealm dynamicRealm = (DynamicRealm) realm;
                 DynamicRealmObject dynamicObject = (DynamicRealmObject) object;
                 @SuppressWarnings("unchecked")
-                Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
+                Flowable<E> observable = (Flowable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
                 return observable;
             } else {
                 throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
@@ -734,4 +757,44 @@ public final void removeAllChangeListeners() {
             throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
         }
     }
+
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmObject. It will emit the current RealmObject when
+     * subscribed to. For each update to the RealmObject a pair consisting of the RealmObject and the
+     * {@link ObjectChangeSet} will be sent. The changeset will be {@code null} the first
+     * time the RealmObject is emitted.
+     * <p>
+     * The RealmObject will continually be emitted as it is updated - {@code onComplete} will never be called.
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @param object RealmObject class that is being observed. Must be this class or its super types.
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public static <E extends RealmModel> Observable<ObjectChange<E>> asChangesetObservable(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
+            if (realm instanceof Realm) {
+                return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, object);
+            } else if (realm instanceof DynamicRealm) {
+                DynamicRealm dynamicRealm = (DynamicRealm) realm;
+                DynamicRealmObject dynamicObject = (DynamicRealmObject) object;
+                return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicObject);
+            } else {
+                throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
+                        " See https://realm.io/docs/java/latest/#rxjava for more details.");
+            }
+        } else {
+            // TODO Is this true? Should we just return Observable.just(object) ?
+            throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index b3596cbc43..b1d272dcc7 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -20,6 +20,8 @@
 import android.annotation.SuppressLint;
 import android.os.Looper;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
@@ -29,8 +31,7 @@
 import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
-import rx.Observable;
-
+import io.realm.rx.CollectionChange;
 
 /**
  * This class holds all the matches of a {@link RealmQuery} for a given Realm. The objects are not copied from
@@ -268,16 +269,16 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
     }
 
     /**
-     * Returns an Rx Observable that monitors changes to this RealmResults. It will emit the current RealmResults when
+     * Returns an Rx Flowable that monitors changes to this RealmResults. It will emit the current RealmResults when
      * subscribed to. RealmResults will continually be emitted as the RealmResults are updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * realm.where(Foo.class).findAllAsync().asObservable()
+     * realm.where(Foo.class).findAllAsync().asFlowable()
      *      .filter(results -> results.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the results once
@@ -295,17 +296,46 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
     @SuppressWarnings("unchecked")
-    public Observable<RealmResults<E>> asObservable() {
+    public Flowable<RealmResults<E>> asFlowable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
         } else if (realm instanceof DynamicRealm) {
             DynamicRealm dynamicRealm = (DynamicRealm) realm;
             RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
-            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicResults);
+            Flowable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicResults);
             return results;
         } else {
-            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
+        }
+    }
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmResults. It will emit the current RealmResults when
+     * subscribed. For each update to the RealmResult a pair consisting of the RealmResults and the
+     * {@link OrderedCollectionChangeSet} will be sent. The changeset will be {@code null} the first
+     * time an RealmResults is emitted.
+     * <p>
+     * RealmResults will continually be emitted as the RealmResults are updated - {@code onComplete} will never be called.
+     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public Observable<CollectionChange<RealmResults<E>>> asChangesetObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
+            return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicResults);
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsList.java b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
index 6346d1c141..7d9a794f63 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
@@ -78,6 +78,10 @@ public boolean isValid() {
         return nativeIsValid(nativePtr);
     }
 
+    public void delete(long index) {
+        nativeDelete(nativePtr, index);
+    }
+
     public void deleteAll() {
         nativeDeleteAll(nativePtr);
     }
@@ -113,5 +117,7 @@ public Table getTargetTable() {
 
     private static native boolean nativeIsValid(long nativePtr);
 
+    private static native void nativeDelete(long nativePtr, long index);
+
     private static native void nativeDeleteAll(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
index 86fcd889d5..b57b6c0ae3 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
@@ -17,16 +17,19 @@
 package io.realm.internal.util;
 
 /**
- * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
- * to support older versions of Android.
- *
- * Original source: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/Pair.java
- *
  * Container to ease passing around a tuple of two objects. This object provides a sensible
  * implementation of equals(), returning true if equals() is true on each of the contained
  * objects.
  */
 public class Pair<F, S> {
+    /**
+     * Implementation notes:
+     *
+     * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
+     * to support older versions of Android.
+     *
+     * Original source: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/Pair.java
+     */
     public F first;
     public S second;
 
@@ -85,6 +88,6 @@ public String toString() {
      * @return a Pair that is templatized with the types of a and b.
      */
     public static <A, B> Pair <A, B> create(A a, B b) {
-        return new Pair<A, B>(a, b);
+        return new Pair<>(a, b);
     }
 }
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java b/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java
new file mode 100644
index 0000000000..13e25f59af
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rx;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollection;
+import io.realm.RealmList;
+import io.realm.RealmResults;
+
+/**
+ * Container wrapping the result of a {@link io.realm.OrderedRealmCollectionChangeListener} being triggered.
+ * <p>
+ * This is used by {@link RealmResults#asChangesetObservable()}} and {@link RealmList#asChangesetObservable()} as
+ * RxJava is only capable of emitting one item, not multiple.
+ */
+public class CollectionChange<E extends OrderedRealmCollection> {
+
+    private final E collection;
+    private final OrderedCollectionChangeSet changeset;
+
+    /**
+     * Constructor for a CollectionChange.
+     *
+     * @param collection the collection that changed.
+     * @param changeset the changeset describing the change.
+     */
+    public CollectionChange(E collection, @Nullable OrderedCollectionChangeSet changeset) {
+        this.collection = collection;
+        this.changeset = changeset;
+    }
+
+    /**
+     * Returns the collection that was updated.
+     *
+     * @return collection that was updated.
+     */
+    public E getCollection() {
+        return collection;
+    }
+
+    /**
+     * Returns the changeset describing the update.
+     * <p>
+     * This will be {@code null} the first time the stream emits the collection as well as when a asynchronous query
+     * is loaded for the first time.
+     * <p>
+     * <pre>
+     * {@code
+     * // Example
+     * realm.where(Person.class).findAllAsync().asChangesetObservable()
+     *   .subscribe(new Consumer<CollectionChange>() {
+     *    \@Override
+     *     public void accept(CollectionChange item) throws Exception {
+     *       item.getChangeset(); // Will return null the first two times
+     *   }
+     * });
+     * }
+     * </pre>
+     *
+     * @return the changeset describing how the collection was updated.
+     */
+    @Nullable
+    public OrderedCollectionChangeSet getChangeset() {
+        return changeset;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        CollectionChange<?> that = (CollectionChange<?>) o;
+
+        if (!collection.equals(that.collection)) return false;
+        return changeset != null ? changeset.equals(that.changeset) : that.changeset == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = collection.hashCode();
+        result = 31 * result + (changeset != null ? changeset.hashCode() : 0);
+        return result;
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java b/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java
new file mode 100644
index 0000000000..b65ad15599
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package io.realm.rx;
+
+import javax.annotation.Nullable;
+
+import io.realm.ObjectChangeSet;
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+
+/**
+ * Container wrapping the result of a {@link io.realm.RealmObjectChangeListener} being triggered.
+ * <p>
+ * This is used by {@link RealmObject#asChangesetObservable()} and {@link RealmObject#asChangesetObservable(RealmModel)}
+ * as RxJava is only capable of emitting one item, not multiple.
+ */
+public class ObjectChange<E extends RealmModel> {
+
+    private final E object;
+    private final ObjectChangeSet changeset;
+
+    /**
+     * Constructor for a ObjectChange.
+     *
+     * @param object the object that was updated.
+     * @param changeset the changeset describing the update.
+     */
+    public ObjectChange(E object, @Nullable ObjectChangeSet changeset) {
+        this.object = object;
+        this.changeset = changeset;
+    }
+
+    public E getObject() {
+        return object;
+    }
+
+    /**
+     * Returns the changeset describing the update.
+     * <p>
+     * This will be {@code null} the first time the stream emits the object as well as when a asynchronous query
+     * is loaded for the first time.
+     * <p>
+     * <pre>
+     * {@code
+     * // Example
+     * realm.where(Person.class).findFirstAsync().asChangesetObservable()
+     *   .subscribe(new Consumer<ObjectChange>() {
+     *    \@Override
+     *     public void accept(ObjectChange item) throws Exception {
+     *       item.getChangeset(); // Will return null the first two times
+     *   }
+     * });
+     * }
+     * </pre>
+     *
+     * @return the changeset describing how the object was updated.
+     */
+    @Nullable
+    public ObjectChangeSet getChangeset() {
+        return changeset;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ObjectChange<?> that = (ObjectChange<?>) o;
+
+        if (!object.equals(that.object)) return false;
+        return changeset != null ? changeset.equals(that.changeset) : that.changeset == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = object.hashCode();
+        result = 31 * result + (changeset != null ? changeset.hashCode() : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "ObjectChange{" +
+                "object=" + object +
+                ", changeset=" + changeset +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 72fd5ac68e..36fa70e5b8 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -19,341 +19,576 @@
 import java.util.IdentityHashMap;
 import java.util.Map;
 
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+import io.reactivex.Observable;
+import io.reactivex.ObservableEmitter;
+import io.reactivex.ObservableOnSubscribe;
+import io.reactivex.Single;
+import io.reactivex.disposables.Disposables;
 import io.realm.DynamicRealm;
 import io.realm.DynamicRealmObject;
+import io.realm.ObjectChangeSet;
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmConfiguration;
 import io.realm.RealmList;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.RealmObjectChangeListener;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
-import rx.Observable;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.subscriptions.Subscriptions;
-
 
 /**
- * Factory class for creating Observables for RxJava (&lt;=1.1.*).
+ * Factory class for creating Observables for RxJava (&lt;=2.0.*).
  *
- * @see Realm#asObservable()
- * @see RealmObject#asObservable()
- * @see RealmResults#asObservable()
- * @see DynamicRealm#asObservable()
- * @see DynamicRealmObject#asObservable()
+ * @see Realm#asFlowable() ()
+ * @see RealmObject#asFlowable()
+ * @see RealmResults#asFlowable()
+ * @see DynamicRealm#asFlowable()
+ * @see DynamicRealmObject#asFlowable()
  */
 public class RealmObservableFactory implements RxObservableFactory {
 
     // Maps for storing strong references to Realm classes while they are subscribed to.
     // This is needed if users create Observables without manually maintaining a reference to them.
     // In that case RealmObjects/RealmResults/RealmLists might be GC'ed too early.
-    ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
         @Override
         protected StrongReferenceCounter<RealmResults> initialValue() {
-            return new StrongReferenceCounter<RealmResults>();
+            return new StrongReferenceCounter<>();
         }
     };
-    ThreadLocal<StrongReferenceCounter<RealmList>> listRefs = new ThreadLocal<StrongReferenceCounter<RealmList>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmList>> listRefs = new ThreadLocal<StrongReferenceCounter<RealmList>>() {
         @Override
         protected StrongReferenceCounter<RealmList> initialValue() {
-            return new StrongReferenceCounter<RealmList>();
+            return new StrongReferenceCounter<>();
         }
     };
-    ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
         @Override
         protected StrongReferenceCounter<RealmModel> initialValue() {
-            return new StrongReferenceCounter<RealmModel>();
+            return new StrongReferenceCounter<>();
         }
     };
 
+    private static final BackpressureStrategy BACK_PRESSURE_STRATEGY = BackpressureStrategy.LATEST;
+
     @Override
-    public Observable<Realm> from(Realm realm) {
+    public Flowable<Realm> from(Realm realm) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<Realm>() {
+        return Flowable.create(new FlowableOnSubscribe <Realm>() {
             @Override
-            public void call(final Subscriber<? super Realm> subscriber) {
-                // Gets instance to make sure that the Realm is open for as long as the
-                // Observable is subscribed to it.
+            public void subscribe(final FlowableEmitter<Realm> emitter) throws Exception {
+                // Instance is cached by Realm, so no need to keep strong reference
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
                     public void onChange(Realm realm) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(observableRealm);
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(realm);
                         }
                     }
                 };
                 observableRealm.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         observableRealm.removeChangeListener(listener);
                         observableRealm.close();
                     }
                 }));
-                subscriber.onNext(observableRealm);
+
+                // Emit current value immediately
+                emitter.onNext(observableRealm);
             }
-        });
+        }, BACK_PRESSURE_STRATEGY);
     }
 
     @Override
-    public Observable<DynamicRealm> from(DynamicRealm realm) {
+    public Flowable<DynamicRealm> from(DynamicRealm realm) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<DynamicRealm>() {
+        return Flowable.create(new FlowableOnSubscribe<DynamicRealm>() {
             @Override
-            public void call(final Subscriber<? super DynamicRealm> subscriber) {
-                // Gets instance to make sure that the Realm is open for as long as the
-                // Observable is subscribed to it.
+            public void subscribe(final FlowableEmitter<DynamicRealm> emitter) throws Exception {
+                // Instance is cached by Realm, so no need to keep strong reference
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 final RealmChangeListener<DynamicRealm> listener = new RealmChangeListener<DynamicRealm>() {
                     @Override
                     public void onChange(DynamicRealm realm) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(observableRealm);
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(realm);
                         }
                     }
                 };
                 observableRealm.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         observableRealm.removeChangeListener(listener);
                         observableRealm.close();
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(observableRealm);
+                // Emit current value immediately
+                emitter.onNext(observableRealm);
             }
-        });
+        }, BACK_PRESSURE_STRATEGY);
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
+    public <E extends RealmModel> Flowable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmResults<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmResults<E>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmResults<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
-
                 final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange(RealmResults<E> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(results);
+                    public void onChange(RealmResults<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(results);
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(results);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, final RealmResults<E> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+                final OrderedRealmCollectionChangeListener<RealmResults<E>> listener = new OrderedRealmCollectionChangeListener<RealmResults<E>>() {
+                    @Override
+                    public void onChange(RealmResults<E> e, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<RealmResults<E>>(results, changeSet));
                         }
                     }
                 };
                 results.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
                         resultsRefs.get().releaseReference(results);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(results);
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(results, null));
             }
         });
     }
 
     @Override
-    public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+    public Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmResults<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmResults<DynamicRealmObject>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
-
                 final RealmChangeListener<RealmResults<DynamicRealmObject>> listener = new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
                     @Override
-                    public void onChange(RealmResults<DynamicRealmObject> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(results);
+                    public void onChange(RealmResults<DynamicRealmObject> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(results);
                         }
                     }
                 };
                 results.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
                         resultsRefs.get().releaseReference(results);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(results);
+                // Emit current value immediately
+                emitter.onNext(results);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+        public Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<DynamicRealmObject>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+                final OrderedRealmCollectionChangeListener<RealmResults<DynamicRealmObject>> listener = new OrderedRealmCollectionChangeListener<RealmResults<DynamicRealmObject>>() {
+                    @Override
+                    public void onChange(RealmResults<DynamicRealmObject> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(results, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
+    public <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmList<E>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmList<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmList<E>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmList<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
-
                 final RealmChangeListener<RealmList<E>> listener = new RealmChangeListener<RealmList<E>>() {
                     @Override
-                    public void onChange(RealmList<E> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(list);
+                    public void onChange(RealmList<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(list);
                         }
                     }
                 };
                 list.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         list.removeChangeListener(listener);
                         observableRealm.close();
                         listRefs.get().releaseReference(list);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(list);
+                // Emit current value immediately
+                emitter.onNext(list);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, final RealmList<E> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+                final OrderedRealmCollectionChangeListener<RealmList<E>> listener = new OrderedRealmCollectionChangeListener<RealmList<E>>() {
+                    @Override
+                    public void onChange(RealmList<E> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(list, null));
             }
         });
     }
 
     @Override
-    public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+    public Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmList<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmList<DynamicRealmObject>>() {
             @Override
-            public void call(final Subscriber<? super RealmList<DynamicRealmObject>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmList<DynamicRealmObject>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
-
                 final RealmChangeListener<RealmList<DynamicRealmObject>> listener = new RealmChangeListener<RealmList<DynamicRealmObject>>() {
                     @Override
-                    public void onChange(RealmList<DynamicRealmObject> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(list);
+                    public void onChange(RealmList<DynamicRealmObject> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(list);
                         }
                     }
                 };
                 list.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         list.removeChangeListener(listener);
                         observableRealm.close();
                         listRefs.get().releaseReference(list);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(list);
+                // Emit current value immediately
+                emitter.onNext(list);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<DynamicRealmObject>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<DynamicRealmObject>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+                final OrderedRealmCollectionChangeListener<RealmList<DynamicRealmObject>> listener = new OrderedRealmCollectionChangeListener<RealmList<DynamicRealmObject>>() {
+                    @Override
+                    public void onChange(RealmList<DynamicRealmObject> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(list, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<E> from(final Realm realm, final E object) {
+    public <E extends RealmModel> Flowable<E> from(final Realm realm, final E object) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<E>() {
+        return Flowable.create(new FlowableOnSubscribe<E>() {
             @Override
-            public void call(final Subscriber<? super E> subscriber) {
+            public void subscribe(final FlowableEmitter<E> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
-
                 final RealmChangeListener<E> listener = new RealmChangeListener<E>() {
                     @Override
-                    public void onChange(E object) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(object);
+                    public void onChange(E obj) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(obj);
+                        }
+                    }
+                };
+                RealmObject.addChangeListener(object, listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        RealmObject.removeChangeListener(object, listener);
+                        observableRealm.close();
+                        objectRefs.get().releaseReference(object);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(object);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, final E object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<ObjectChange<E>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<ObjectChange<E>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+                final RealmObjectChangeListener<E> listener = new RealmObjectChangeListener<E>() {
+                    @Override
+                    public void onChange(E obj, ObjectChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new ObjectChange<>(obj, changeSet));
                         }
                     }
                 };
                 RealmObject.addChangeListener(object, listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(object);
+                // Emit current value immediately
+                emitter.onNext(new ObjectChange<>(object, null));
             }
         });
     }
 
     @Override
-    public Observable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) {
+    public Flowable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() {
+        return Flowable.create(new FlowableOnSubscribe<DynamicRealmObject>() {
             @Override
-            public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
+            public void subscribe(final FlowableEmitter<DynamicRealmObject> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
-
                 final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() {
                     @Override
-                    public void onChange(DynamicRealmObject object) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(object);
+                    public void onChange(DynamicRealmObject obj) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(obj);
                         }
                     }
                 };
                 RealmObject.addChangeListener(object, listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(object);
+                // Emit current value immediately
+                emitter.onNext(object);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, final DynamicRealmObject object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<ObjectChange<DynamicRealmObject>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<ObjectChange<DynamicRealmObject>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+                final RealmObjectChangeListener<DynamicRealmObject> listener = new RealmObjectChangeListener<DynamicRealmObject>() {
+                    @Override
+                    public void onChange(DynamicRealmObject obj, ObjectChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new ObjectChange<>(obj, changeSet));
+                        }
+                    }
+                };
+                object.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        object.removeChangeListener(listener);
+                        observableRealm.close();
+                        objectRefs.get().releaseReference(object);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new ObjectChange<>(object, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+    public <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
     @Override
-    public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+    public Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
@@ -364,7 +599,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return 37;
+        return 37; // Random number
     }
 
 
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
index efe20fbe92..04af747f38 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
@@ -16,16 +16,18 @@
 
 package io.realm.rx;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.Single;
 import io.realm.DynamicRealm;
 import io.realm.DynamicRealmObject;
+import io.realm.OrderedCollectionChangeSet;
 import io.realm.Realm;
 import io.realm.RealmList;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
-import rx.Observable;
-
 
 /**
  * Factory interface for creating Rx Observables for Realm classes.
@@ -33,57 +35,86 @@
 public interface RxObservableFactory {
 
     /**
-     * Creates an Observable for a {@link Realm}. It should emit the initial state of the Realm when subscribed to and
+     * Creates a Flowable for a {@link Realm}. It should emit the initial state of the Realm when subscribed to and
      * on each subsequent update of the Realm.
      * <p>
-     * Realm observables are hot observables as Realms are automatically kept up to date.
+     * Realm flowables are hot as Realms are automatically kept up to date.
      *
      * @param realm {@link Realm} to listen to changes for.
      * @return Rx observable that emit all updates to the Realm.
      */
-    Observable<Realm> from(Realm realm);
+    Flowable<Realm> from(Realm realm);
 
     /**
-     * Creates an Observable for a {@link DynamicRealm}. It should emit the initial state of the Realm when subscribed
+     * Creates a Flowable for a {@link DynamicRealm}. It should emit the initial state of the Realm when subscribed
      * to and on each subsequent update of the Realm.
      * <p>
-     * DynamicRealm observables are hot observables as DynamicRealms are automatically kept up to date.
+     * DynamicRealm observables are hot as DynamicRealms are automatically kept up to date.
      *
      * @param realm {@link DynamicRealm} to listen to changes for.
      * @return Rx observable that emit all updates to the DynamicRealm.
      */
-    Observable<DynamicRealm> from(DynamicRealm realm);
+    Flowable<DynamicRealm> from(DynamicRealm realm);
 
     /**
-     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * Creates a Flowable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
      * on each subsequent update of the RealmResults.
      * <p>
-     * RealmResults observables are hot observables as RealmResults are automatically kept up to date.
+     * RealmResults observables are hot as RealmResults are automatically kept up to date.
      *
      * @param results {@link RealmResults} to listen to changes for.
      * @param realm {@link Realm} instance results are coming from.
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates to the RealmObject.
      */
-    <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
+    <E extends RealmModel> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults it should emit the RealmResults + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link Realm} instance results are coming from.
+     * @param <E> type of RealmObject
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results);
+
+    /**
+     * Creates a Flowable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
      * on each subsequent update of the RealmResults.
      * <p>
-     * Realm observables are hot observables as RealmResults are automatically kept up to date.
+     * Realm observables are hot as RealmResults are automatically kept up to date.
      *
      * @param results {@link RealmResults} to listen to changes for.
      * @param realm {@link DynamicRealm} instance results are coming from.
      * @return Rx observable that emit all updates to the RealmResults.
      */
-    Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+    Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+
+    /**
+     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults it should emit the RealmResults + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link Realm} instance results are coming from.
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
      * subsequent update of the RealmList.
      * <p>
-     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     * RealmList observables are hot as RealmLists are automatically kept up to date.
      * <p>
      * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
      *
@@ -91,46 +122,102 @@
      * @param realm {@link Realm} instance list is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list);
+    <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list);
 
     /**
-     * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
+     * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
+     * on each subsequent update of the RealmIst it should emit the RealmList + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param list {@link RealmList} to listen to changes for.
+     * @param realm {@link Realm} instance list is coming from.
+     * @param <E> type of RealmObject
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list);
+
+    /**
+     * Creates a Flowable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
      * subsequent update of the RealmList.
      * <p>
-     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     * RealmList observables are hot as RealmLists are automatically kept up to date.
      * <p>
      * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
      *
      * @param list RealmList to listen to changes for.
      * @param realm {@link DynamicRealm} instance list is coming from.
      */
-    Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+    Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list);
 
     /**
-     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
+     * on each subsequent update of the RealmList it should emit the RealmList + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param list {@link RealmList} to listen to changes for.
+     * @param realm {@link Realm} instance list is coming from.
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+
+    /**
+     * Creates a Flowable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
      * subsequent update of the object.
      * <p>
-     * RealmObject observables are hot observables as RealmObjects are automatically kept up to date.
+     * RealmObject observables are hot as RealmObjects are automatically kept up to date.
      *
      * @param object RealmObject to listen to changes for.
      * @param realm {@link Realm} instance object is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmModel> Observable<E> from(Realm realm, E object);
+    <E extends RealmModel> Flowable<E> from(Realm realm, E object);
 
     /**
-     * Creates an Observable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
+     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * subsequent update of the object it should emit the object + the {@link io.realm.ObjectChangeSet} that describes
+     * the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefore be left to the user.
+     *
+     * @param object RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance object is coming from.
+     * @param <E> type of RealmObject
+     */
+    <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, E object);
+
+    /**
+     * Creates a Flowable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
      * on each subsequent update of the object.
      * <p>
-     * DynamicRealmObject observables are hot observables as DynamicRealmObjects automatically are kept up to date.
+     * DynamicRealmObject observables are hot as DynamicRealmObjects automatically are kept up to date.
      *
      * @param object DynamicRealmObject to listen to changes for.
      * @param realm {@link DynamicRealm} instance object is coming from.
      */
-    Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object);
+    Flowable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object);
+
+    /**
+     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * subsequent update of the object it should emit the object + the {@link io.realm.ObjectChangeSet} that describes
+     * the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefore be left to the user.
+     *
+     * @param object RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance object is coming from.
+     */
+    Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, DynamicRealmObject object);
 
     /**
-     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     * Creates a Single from a {@link RealmQuery}. It should emit the query and then complete.
      * <p>
      * A RealmQuery observable is cold.
      *
@@ -138,15 +225,15 @@
      * @param realm {@link Realm} instance query is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
+    <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
 
     /**
-     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     * Creates a Single from a {@link RealmQuery}. It should emit the query and then complete.
      * <p>
      * A RealmQuery observable is cold.
      *
      * @param query RealmObject to listen to changes for.
      * @param realm {@link DynamicRealm} instance query is coming from.
      */
-    Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query);
+    Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query);
 }
