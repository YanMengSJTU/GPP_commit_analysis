diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8f4f95d32a..ea90d0b865 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -20,6 +20,8 @@
 
 ### Bug Fixes
 
+* Crash with `LogicError` with `Bad version number` on notifier thread (#4369).
+
 ### Deprecated
 
 ### Internal
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index e6f4b4d734..b4b9663ba6 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -134,7 +134,7 @@
     private final Set<Backlink> backlinksToValidate = new HashSet<Backlink>();
 
     private boolean hasProcessedModules = false;
-    private int round;
+    private int round = -1;
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -146,8 +146,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         round++;
 
         if (round == 0) {
-            RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
-            updateChecker.executeRealmVersionUpdate();
+            RealmVersionChecker.getInstance(processingEnv).executeRealmVersionUpdate();
         }
 
         if (roundEnv.errorRaised()) { return true; }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 328426dc3a..0dc79ea020 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -115,7 +115,6 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitPersistedFieldAccessors(writer);
         emitBacklinkFieldAccessors(writer);
         emitCreateRealmObjectSchemaMethod(writer);
-        emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
@@ -611,7 +610,7 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                 String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                 String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                writer.emitStatement("realmObjectSchema.add(new Property(\"%s\", %s, %s, %s, %s))",
+                writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
                         fieldName,
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         primaryKeyFlag,
@@ -621,14 +620,14 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
                         .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
                         .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\")))",
+                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
                                 fieldName, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
                 String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
                         .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
                         .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(new Property(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\")))",
+                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
                                 fieldName, genericTypeSimpleName);
             }
         }
@@ -639,69 +638,6 @@ private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOExcep
                 .emitEmptyLine();
     }
 
-    private void emitInitTableMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod(
-                "Table", // Return type
-                "initTable", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "SharedRealm", "sharedRealm"); // Argument type & argument name
-
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
-
-        // For each field generate corresponding table index constant
-        for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
-            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                String nullableFlag;
-                if (metadata.isNullable(field)) {
-                    nullableFlag = "Table.NULLABLE";
-                } else {
-                    nullableFlag = "Table.NOT_NULLABLE";
-                }
-                writer.emitStatement("table.addColumn(%s, \"%s\", %s)",
-                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
-                        fieldName, nullableFlag);
-            } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName)
-                        .emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
-                                fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-            } else if (Utils.isRealmList(field)) {
-                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName)
-                        .emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName))
-                        .endControlFlow()
-                        .emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
-                                fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
-            }
-        }
-
-        for (VariableElement field : metadata.getIndexedFields()) {
-            String fieldName = field.getSimpleName().toString();
-            writer.emitStatement("table.addSearchIndex(table.getColumnIndex(\"%s\"))", fieldName);
-        }
-
-        if (metadata.hasPrimaryKey()) {
-            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            writer.emitStatement("table.setPrimaryKey(\"%s\")", fieldName);
-        } else {
-            writer.emitStatement("table.setPrimaryKey(\"\")");
-        }
-
-        writer.emitStatement("return table");
-
-        writer.endControlFlow();
-
-        writer.emitStatement("return sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
-        writer.endMethod()
-                .emitEmptyLine();
-    }
-
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
                 columnInfoClassName(),        // Return type
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index f02aefc106..65f4e7a843 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -38,9 +38,9 @@
 
 public class RealmProxyMediatorGenerator {
     private final String className;
-    private ProcessingEnvironment processingEnvironment;
-    private List<String> qualifiedModelClasses = new ArrayList<String>();
-    private List<String> qualifiedProxyClasses = new ArrayList<String>();
+    private final ProcessingEnvironment processingEnvironment;
+    private final List<String> qualifiedModelClasses = new ArrayList<String>();
+    private final List<String> qualifiedProxyClasses = new ArrayList<String>();
 
     public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
             String className, Set<ClassMetaData> classesToValidate) {
@@ -96,7 +96,6 @@ public void generate() throws IOException {
         writer.emitEmptyLine();
 
         emitFields(writer);
-        emitCreateTableMethod(writer);
         emitCreateRealmObjectSchema(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
@@ -135,7 +134,7 @@ private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
@@ -145,24 +144,6 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitCreateTableMethod(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "Table",
-                "createTable",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "SharedRealm", "sharedRealm"
-        );
-        emitMediatorSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.initTable(sharedRealm)", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
@@ -173,7 +154,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 "SharedRealm", "sharedRealm",
                 "boolean", "allowExtraColumns"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
@@ -192,7 +173,7 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.getFieldNames()", qualifiedProxyClasses.get(i));
@@ -210,7 +191,7 @@ private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz"
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return %s.getTableName()", qualifiedProxyClasses.get(i));
@@ -236,7 +217,7 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
         writer.beginControlFlow("try")
                 .emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)");
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses.get(i));
@@ -269,7 +250,7 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
         writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
         writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
@@ -412,7 +393,7 @@ private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcept
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Arrays.asList("JSONException")
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses.get(i));
@@ -431,7 +412,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                 Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
                 Arrays.asList("java.io.IOException")
         );
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses.get(i));
@@ -453,7 +434,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
         writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
         writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass()");
         writer.emitEmptyLine();
-        emitMediatorSwitch(new ProxySwitchStatement() {
+        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
@@ -492,6 +473,26 @@ private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter write
         }
     }
 
+    // Identical to the above, but eliminates the un-needed "else" clauses for, e.g., return statements
+    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
+        emitMediatorShortCircuitSwitch(statement, writer, true);
+    }
+
+    private void emitMediatorShortCircuitSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
+            throws IOException {
+        if (nullPointerCheck) {
+            writer.emitStatement("checkClass(clazz)");
+            writer.emitEmptyLine();
+        }
+        for (int i = 0; i < qualifiedModelClasses.size(); i++) {
+            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
+            statement.emitStatement(i, writer);
+            writer.endControlFlow();
+        }
+        writer.emitStatement("throw getMissingProxyClassException(clazz)");
+    }
+
+
     private String getProxyClassName(String clazz) {
         return clazz + Constants.PROXY_SUFFIX;
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index f8cb971a58..aaadd945d1 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -406,51 +406,26 @@ public final AllTypesColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("AllTypes")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
-            realmObjectSchema.add(new Property("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             if (!realmSchema.contains("AllTypes")) {
                 AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes")));
+            realmObjectSchema.add("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes"));
             if (!realmSchema.contains("AllTypes")) {
                 AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes")));
+            realmObjectSchema.add("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes"));
             return realmObjectSchema;
         }
         return realmSchema.get("AllTypes");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            Table table = sharedRealm.getTable("class_AllTypes");
-            table.addColumn(RealmFieldType.STRING, "columnString", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "columnDouble", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "columnBoolean", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "columnDate", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "columnBinary", Table.NOT_NULLABLE);
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", sharedRealm.getTable("class_AllTypes"));
-            if (!sharedRealm.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", sharedRealm.getTable("class_AllTypes"));
-            table.addSearchIndex(table.getColumnIndex("columnString"));
-            table.setPrimaryKey("columnString");
-            return table;
-        }
-        return sharedRealm.getTable("class_AllTypes");
-    }
-
     public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index c630f1f176..5a07ed0d92 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -191,28 +191,15 @@ public final BooleansColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("Booleans")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
-            realmObjectSchema.add(new Property("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             return realmObjectSchema;
         }
         return realmSchema.get("Booleans");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_Booleans")) {
-            Table table = sharedRealm.getTable("class_Booleans");
-            table.addColumn(RealmFieldType.BOOLEAN, "done", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "isReady", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "mCompleted", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "anotherBoolean", Table.NOT_NULLABLE);
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_Booleans");
-    }
-
     public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_Booleans")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index fa041cfb80..c91b122f0c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -843,68 +843,35 @@ public final NullTypesColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("NullTypes")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
-            realmObjectSchema.add(new Property("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
-            realmObjectSchema.add(new Property("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
+            realmObjectSchema.add("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+            realmObjectSchema.add("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
             if (!realmSchema.contains("NullTypes")) {
                 NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
             }
-            realmObjectSchema.add(new Property("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes")));
+            realmObjectSchema.add("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes"));
             return realmObjectSchema;
         }
         return realmSchema.get("NullTypes");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            Table table = sharedRealm.getTable("class_NullTypes");
-            table.addColumn(RealmFieldType.STRING, "fieldStringNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.STRING, "fieldStringNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "fieldBytesNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.BINARY, "fieldBytesNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldByteNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldByteNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldShortNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldShortNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldIntegerNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldLongNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "fieldLongNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.FLOAT, "fieldFloatNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNull", Table.NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "fieldDateNotNull", Table.NOT_NULLABLE);
-            table.addColumn(RealmFieldType.DATE, "fieldDateNull", Table.NULLABLE);
-            if (!sharedRealm.hasTable("class_NullTypes")) {
-                NullTypesRealmProxy.initTable(sharedRealm);
-            }
-            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", sharedRealm.getTable("class_NullTypes"));
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_NullTypes");
-    }
-
     public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_NullTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index e72e461844..4460594efa 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -31,26 +31,14 @@
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        checkClass(clazz);
-
-        if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.initTable(sharedRealm);
-        } else {
-            throw getMissingProxyClassException(clazz);
-        }
-    }
-
     @Override
     public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -59,9 +47,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -70,9 +57,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.getFieldNames();
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -81,9 +67,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return io.realm.AllTypesRealmProxy.getTableName();
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -95,9 +80,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
             if (clazz.equals(some.test.AllTypes.class)) {
                 return clazz.cast(new io.realm.AllTypesRealmProxy());
-            } else {
-                throw getMissingProxyClassException(clazz);
             }
+            throw getMissingProxyClassException(clazz);
         } finally {
             objectContext.clear();
         }
@@ -116,9 +100,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.copyOrUpdate(realm, (some.test.AllTypes) obj, update, cache));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -208,9 +191,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -220,9 +202,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createUsingJsonStream(realm, reader));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
     @Override
@@ -233,9 +214,8 @@ public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects
 
         if (clazz.equals(some.test.AllTypes.class)) {
             return clazz.cast(io.realm.AllTypesRealmProxy.createDetachedCopy((some.test.AllTypes) realmObject, 0, maxDepth, cache));
-        } else {
-            throw getMissingProxyClassException(clazz);
         }
+        throw getMissingProxyClassException(clazz);
     }
 
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 8336e88e4b..030081db38 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -145,24 +145,13 @@ public final SimpleColumnInfo clone() {
     public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
         if (!realmSchema.contains("Simple")) {
             RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
-            realmObjectSchema.add(new Property("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED));
-            realmObjectSchema.add(new Property("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED));
+            realmObjectSchema.add("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+            realmObjectSchema.add("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
             return realmObjectSchema;
         }
         return realmSchema.get("Simple");
     }
 
-    public static Table initTable(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable("class_Simple")) {
-            Table table = sharedRealm.getTable("class_Simple");
-            table.addColumn(RealmFieldType.STRING, "name", Table.NULLABLE);
-            table.addColumn(RealmFieldType.INTEGER, "age", Table.NOT_NULLABLE);
-            table.setPrimaryKey("");
-            return table;
-        }
-        return sharedRealm.getTable("class_Simple");
-    }
-
     public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
         if (!sharedRealm.hasTable("class_Simple")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index ba33c31d0c..f79aacad6f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -142,7 +142,7 @@ public void insert_realmModel() {
         allTypes.columnBoolean = false;
         allTypes.columnBinary = new byte[]{1, 2, 3};
         allTypes.columnDate = new Date();
-        allTypes.columnDouble = 3.1415;
+        allTypes.columnDouble = Math.PI;
         allTypes.columnFloat = 1.234567f;
         allTypes.columnString = "test data";
         allTypes.columnByte = 0x2A;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 3f99fdf619..9a38ec50b1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -123,7 +123,7 @@ private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
         obj.setFieldBoolean(((index % 2) == 0));
         obj.setFieldBinary(new byte[]{1, 2, 3});
         obj.setFieldDate(new Date(YEAR_MILLIS * 20 * (index - totalObjects / 2)));
-        obj.setFieldDouble(3.1415 + index);
+        obj.setFieldDouble(Math.PI + index);
         obj.setFieldFloat(1.234567f + index);
         obj.setFieldString("test data " + index);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index b5b1202400..1bec5cfa80 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -93,7 +93,7 @@ private void populateTestRealm(DynamicRealm realm, int objects) {
             allTypes.setBoolean(AllTypes.FIELD_BOOLEAN, (i % 3) == 0);
             allTypes.setBlob(AllTypes.FIELD_BINARY, new byte[]{1, 2, 3});
             allTypes.setDate(AllTypes.FIELD_DATE, new Date());
-            allTypes.setDouble(AllTypes.FIELD_DOUBLE, 3.1415D + i);
+            allTypes.setDouble(AllTypes.FIELD_DOUBLE, Math.PI + i);
             allTypes.setFloat(AllTypes.FIELD_FLOAT, 1.234567F + i);
             allTypes.setString(AllTypes.FIELD_STRING, "test data " + i);
             allTypes.setLong(AllTypes.FIELD_LONG, i);
@@ -675,7 +675,7 @@ public void equalTo_noFieldObjectShouldThrow() {
         dynamicRealm.commitTransaction();
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Field 'nonExisting' does not exist.");
+        thrown.expectMessage("Invalid query: field 'nonExisting' does not exist in table 'NoField'.");
         dynamicRealm.where(className).equalTo("nonExisting", 1);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 1ea36519e9..0ec3cd03fe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -96,7 +96,7 @@ public void iOSDataTypes() throws IOException {
                 assertEquals(1.234D + (double)i, obj.getDoubleCol(), 0D);
                 assertArrayEquals(new byte[]{1, 2, 3}, obj.getByteCol());
                 assertEquals("String " + Integer.toString(i), obj.getStringCol());
-                assertEquals(new Date((1000 + i) * 1000), obj.getDateCol());
+                assertEquals(new Date((1000L + i) * 1000), obj.getDateCol());
                 assertEquals("Foo", result.get(i).getChild().getName());
                 assertEquals(10, result.get(i).getChildren().size());
                 for (int j = 0; j < 10; j++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 9cd511e157..387920dc58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -499,11 +499,11 @@ public void avg() {
         // See setUp() for values of fields.
         // N = TEST_DATA_SIZE
 
-        // Type: double; a = 3.1415
+        // Type: double; a = Math.PI
         // a, a+1, ..., a+i, ..., a+N-1
-        // sum = 3.1415*N + N*(N-1)/2
-        // average = sum/N = 3.1415+(N-1)/2
-        double average = 3.1415 + (N - 1.0) * 0.5;
+        // sum = Math.PI*N + N*(N-1)/2
+        // average = sum/N = Math.PI+(N-1)/2
+        double average = Math.PI + (N - 1.0) * 0.5;
         assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
 
         // Type: long
@@ -575,7 +575,7 @@ public void aggregates_deleteLastRow() {
         assertEquals(sizeAfterRemove - 1, collection.max(AllJavaTypes.FIELD_LONG).intValue());
         // Sum of numbers 0 to M-1: (M-1)*M/2
         assertEquals((sizeAfterRemove - 1) * sizeAfterRemove / 2, collection.sum(AllJavaTypes.FIELD_LONG).intValue());
-        double average = 3.1415 + (sizeAfterRemove - 1.0) * 0.5;
+        double average = Math.PI + (sizeAfterRemove - 1.0) * 0.5;
         assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
         assertEquals(new Date(YEAR_MILLIS * 20 * (sizeAfterRemove / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
         assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
index 942e7cb848..c36aef4b56 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
@@ -337,4 +337,38 @@ public void onChange(AllTypes object, ObjectChangeSet changeSet) {
         allTypes.deleteFromRealm();
         realm.commitTransaction();
     }
+
+    // When there are more than 512 fields change, the JNI local ref table size limitation may be reached.
+    @Test
+    @RunTestInLooperThread
+    public void moreFieldsChangedThanLocalRefTableSize() {
+        final String CLASS_NAME = "ManyFields";
+        final int FIELD_COUNT = 1024;
+        RealmConfiguration config = looperThread.createConfiguration("many_fields");
+        final DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        realm.beginTransaction();
+        RealmSchema schema = realm.getSchema();
+        RealmObjectSchema objectSchema = schema.create(CLASS_NAME);
+        for (int i = 0; i < FIELD_COUNT; i++) {
+            objectSchema.addField("field" + i, int.class);
+        }
+        DynamicRealmObject obj = realm.createObject(CLASS_NAME);
+        realm.commitTransaction();
+
+        obj.addChangeListener(new RealmObjectChangeListener<DynamicRealmObject>() {
+            @Override
+            public void onChange(DynamicRealmObject object, ObjectChangeSet changeSet) {
+                assertEquals(FIELD_COUNT, changeSet.getChangedFields().length);
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        for (int i = 0; i < FIELD_COUNT; i++) {
+            obj.setInt("field" + i, 42);
+        }
+        realm.commitTransaction();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 44e32c935d..b49618fab1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -1264,7 +1264,7 @@ private void populateTestRealm(final Realm testRealm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -1285,11 +1285,11 @@ private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOf
                 AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
                 obj.setIndexBoolean(j % 2 == 0);
                 obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setIndexString(withNull ? null : "Test " + j);
                 obj.setNotIndexBoolean(j % 2 == 0);
                 obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setNotIndexString(withNull ? null : "Test " + j);
             }
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 2af194d3ef..2e802eb7f2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -484,22 +484,22 @@ public void queryMultipleRelationsString() {
     public void queryShouldFail() {
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat..hasTail", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (double dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo(".cat.hasTail", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (initial dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat.hasTail.", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (final dot)");
         } catch (IllegalArgumentException ignored) {
         }
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("not.there", true).findAll();
-            fail("Should throw Exception");
+            fail("Should throw Exception (non-existent column)");
         } catch (IllegalArgumentException ignored) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 387f098153..6d20ffcec0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -91,7 +91,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.columnBoolean = (i % 3) == 0;
             allTypes.columnBinary = new byte[]{1, 2, 3};
             allTypes.columnDate = new Date();
-            allTypes.columnDouble = 3.1415 + i;
+            allTypes.columnDouble = Math.PI + i;
             allTypes.columnFloat = 1.234567f;
             allTypes.columnString = "test data ";
             allTypes.columnByte = 0x2A;
@@ -251,7 +251,7 @@ public void dynamicRealm() {
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypesRealmModel.CLASS_NAME).findAll();
         assertEquals(TEST_DATA_SIZE, results.size());
         for (int i = 0; i < TEST_DATA_SIZE; i++) {
-            assertEquals(3.1415 + i, results.get(i).getDouble(AllTypesRealmModel.FIELD_DOUBLE), 0.0000001);
+            assertEquals(Math.PI + i, results.get(i).getDouble(AllTypesRealmModel.FIELD_DOUBLE), 0.0000001);
             assertEquals((i % 3) == 0, results.get(i).getBoolean(AllTypesRealmModel.FIELD_BOOLEAN));
         }
         dynamicRealm.close();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 2f5a772106..e69e20613f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -738,7 +738,7 @@ public void getFieldIndex() {
         RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
         dynamicRealm.beginTransaction();
-        RealmObjectSchema objectSchema = dynamicRealm.getSchema().create(className);
+        StandardRealmObjectSchema objectSchema = (StandardRealmObjectSchema) dynamicRealm.getSchema().create(className);
 
         assertNull(objectSchema.getFieldIndex(fieldName));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 53642936a0..3017d94dfc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -98,7 +98,7 @@ private void populateTestRealm(Realm testRealm, int dataSize) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.2345f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -139,8 +139,8 @@ private void populateNoPrimaryKeyNullTypesRows(Realm testRealm, int dataSize) {
             noPrimaryKeyNullTypes.setFieldLongNotNull((long) i);
             noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.2345f + i);
             noPrimaryKeyNullTypes.setFieldFloatNotNull(1.2345f + i);
-            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : 3.1415 + i);
-            noPrimaryKeyNullTypes.setFieldDoubleNotNull(3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : Math.PI + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNotNull(Math.PI + i);
             noPrimaryKeyNullTypes.setFieldDateNull((i % 3) == 0 ? null : new Date(DECADE_MILLIS * (i - (dataSize / 2))));
             noPrimaryKeyNullTypes.setFieldDateNotNull(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
         }
@@ -821,13 +821,13 @@ private void doTestForInDouble(String targetField) {
             fail();
         } catch (IllegalArgumentException ignored) {
         }
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 1}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 2}).findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{Math.PI + 1, Math.PI + 2}).findAll();
         assertEquals(2, resultList.size());
-        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{Math.PI + 1, Math.PI + 2}).findAll();
         assertEquals(198, resultList.size());
     }
 
@@ -996,7 +996,7 @@ public void in_dateNull() {
     public void in_doubleNotNull() {
         doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL);
         try {
-            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{Math.PI + 1, null, Math.PI + 2}).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -1005,7 +1005,7 @@ public void in_doubleNotNull() {
     @Test
     public void in_doubleNull() {
         doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL);
-        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{Math.PI + 1, null, Math.PI + 2}).findAll();
         assertEquals(131, resultList.size());
     }
 
@@ -3060,11 +3060,11 @@ private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOf
                 AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
                 obj.setIndexBoolean(j % 2 == 0);
                 obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setIndexString(withNull ? null : "Test " + j);
                 obj.setNotIndexBoolean(j % 2 == 0);
                 obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * j));
+                obj.setNotIndexDate(withNull ? null : new Date(1000L * j));
                 obj.setNotIndexString(withNull ? null : "Test " + j);
                 obj.setFieldObject(obj);
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 88dd2d6bf5..4c4069a9e8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -380,7 +380,7 @@ private void populateTestRealm(int objects) {
             allTypes.setColumnBoolean((i % 2) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(YEAR_MILLIS * (i - objects / 2)));
-            allTypes.setColumnDouble(3.1415 + i);
+            allTypes.setColumnDouble(Math.PI + i);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
@@ -404,7 +404,7 @@ private void populateTestRealm(Realm testRealm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 243ef1c246..aaf75da32c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -168,7 +168,7 @@ private void populateTestRealm(Realm realm, int objects) {
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDouble(Math.PI);
             allTypes.setColumnFloat(1.234567f + i);
 
             allTypes.setColumnString("test data " + i);
@@ -370,13 +370,13 @@ public void where_equalTo_invalidFieldName() throws IOException {
         }
 
         try {
-            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415d).findAll();
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", Math.PI).findAll();
             fail("Invalid field name");
         } catch (Exception ignored) {
         }
 
         try {
-            realm.where(AllTypes.class).equalTo("invalidcolumnname", 3.1415f).findAll();
+            realm.where(AllTypes.class).equalTo("invalidcolumnname", Math.PI).findAll();
             fail("Invalid field name");
         } catch (Exception ignored) {
         }
@@ -455,7 +455,7 @@ public void beginTransaction() throws IOException {
 
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
-        allTypes.setColumnFloat(3.1415f);
+        allTypes.setColumnFloat(3.14F);
         allTypes.setColumnString("a unique string");
         realm.commitTransaction();
 
@@ -464,7 +464,7 @@ public void beginTransaction() throws IOException {
 
         resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_STRING, "a unique string").findAll();
         assertEquals(1, resultList.size());
-        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 3.1415f).findAll();
+        resultList = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_FLOAT, 3.14F).findAll();
         assertEquals(1, resultList.size());
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 064af91f02..731c21d3a1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -69,6 +69,7 @@
 public class TestHelper {
 
     private static final Charset UTF_8 = Charset.forName("UTF-8");
+    private static final Random RANDOM = new Random();
 
     public static class ExpectedCountCallback implements RealmCache.Callback {
 
@@ -159,7 +160,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // Returns a random key used by encrypted Realms.
     public static byte[] getRandomKey() {
         byte[] key = new byte[64];
-        new Random().nextBytes(key);
+        RANDOM.nextBytes(key);
         return key;
     }
 
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index cb5f0a97d6..5913e1872e 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -37,7 +37,7 @@ set(classes_LIST
     io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
     io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.OsRealmSchema
-    io.realm.RealmObjectSchema io.realm.internal.Collection
+    io.realm.OsRealmObjectSchema io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
     io.realm.internal.OsObject
 )
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
similarity index 81%
rename from realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
index e6804a0ad5..bbbcbe2879 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmObjectSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_RealmObjectSchema.h"
+#include "io_realm_OsRealmObjectSchema.h"
 
 #include <object-store/src/object_schema.hpp>
 #include <object-store/src/property.hpp>
@@ -23,8 +23,8 @@
 #include "util.hpp"
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
-                                                                                      jstring className_)
+JNIEXPORT jlong JNICALL Java_io_realm_OsRealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
+                                                                                        jstring className_)
 {
     TR_ENTER()
     try {
@@ -37,7 +37,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmObjectSchema_nativeCreateRealmObjectS
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
@@ -48,7 +48,7 @@ JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeClose(JNIEnv* env,
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
                                                                          jlong property_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -63,7 +63,7 @@ JNIEXPORT void JNICALL Java_io_realm_RealmObjectSchema_nativeAddProperty(JNIEnv*
     CATCH_STD()
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_RealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jstring JNICALL Java_io_realm_OsRealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
@@ -76,7 +76,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmObjectSchema_nativeGetClassName(JNI
     return nullptr;
 }
 
-JNIEXPORT jlongArray JNICALL Java_io_realm_RealmObjectSchema_nativeGetProperties(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jlongArray JNICALL Java_io_realm_OsRealmObjectSchema_nativeGetProperties(JNIEnv* env, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index abe2e666d3..c35c042672 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -70,7 +70,8 @@ struct ChangeCallback {
             return;
         }
 
-        std::vector<jstring> field_names;
+        // The local ref of jstring needs to be released to avoid reach the local ref table size limitation.
+        std::vector<JavaGlobalRef> field_names;
         auto table = m_wrapper->m_object.row().get_table();
         for (size_t i = 0; i < change_set.columns.size(); ++i) {
             if (change_set.columns[i].empty()) {
@@ -78,11 +79,11 @@ struct ChangeCallback {
             }
             // FIXME: After full integration of the OS schema, parse the column name from
             // wrapper->m_object.get_object_schema() will be faster.
-            field_names.push_back(to_jstring(env, table->get_column_name(i)));
+            field_names.push_back(JavaGlobalRef(env, to_jstring(env, table->get_column_name(i)), true));
         }
         m_field_names_array = env->NewObjectArray(field_names.size(), java_lang_string, 0);
         for (size_t i = 0; i < field_names.size(); ++i) {
-            env->SetObjectArrayElement(m_field_names_array, i, field_names[i]);
+            env->SetObjectArrayElement(m_field_names_array, i, field_names[i].get());
         }
     }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index eca86a2800..42bd1567e8 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -1533,7 +1533,9 @@ static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData
             return true;
 
         default:
-            ThrowException(env, IllegalArgument, "Invalid primary key type: " + column_type);
+            std::ostringstream error_msg;
+            error_msg << "Invalid primary key type for column: " << column_name;
+            ThrowException(env, IllegalArgument, error_msg.str());
             return false;
     }
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
index a08aad4bd6..f2d0c3320d 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
@@ -29,9 +29,13 @@ class JavaGlobalRef {
         : m_ref(nullptr)
     {
     }
-    JavaGlobalRef(JNIEnv* env, jobject obj)
+    // Acquire a global ref on the given jobject. The local ref will be released if given release_local_ref is true.
+    JavaGlobalRef(JNIEnv* env, jobject obj, bool release_local_ref = false)
         : m_ref(obj ? env->NewGlobalRef(obj) : nullptr)
     {
+        if (release_local_ref) {
+            env->DeleteLocalRef(obj);
+        }
     }
     JavaGlobalRef(JavaGlobalRef&& rhs)
         : m_ref(rhs.m_ref)
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 3eada170f3..3b6c0f6110 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 3eada170f380174992b47b6023f375f3f372a9d2
+Subproject commit 3b6c0f611061dddabc489f0b9f264306893c96c8
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index acae142705..c2330bf87d 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -62,7 +62,7 @@
     static final String LISTENER_NOT_ALLOWED_MESSAGE = "Listeners cannot be used on current thread.";
 
 
-    volatile static Context applicationContext;
+    static volatile Context applicationContext;
 
     // Thread pool for all async operations (Query & transaction)
     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
@@ -642,7 +642,7 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
-    public SharedRealm getSharedRealm() {
+    SharedRealm getSharedRealm() {
         return sharedRealm;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
new file mode 100644
index 0000000000..922e28aba6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+class OsRealmObjectSchema extends RealmObjectSchema {
+    private final long nativePtr;
+
+    /**
+     * Creates a schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and properties through the object store. Even though the constructor
+     * is public, there is never a purpose which justifies calling it!
+     *
+     * @param className name of the class
+     */
+    OsRealmObjectSchema(String className) {
+        this.nativePtr = nativeCreateRealmObjectSchema(className);
+    }
+
+    OsRealmObjectSchema(long nativePtr) {
+        this.nativePtr = nativePtr;
+    }
+
+    @Override
+    public void close() {
+        Set<Property> properties = getProperties();
+        for (Property property : properties) {
+            property.close();
+        }
+        nativeClose(nativePtr);
+    }
+
+    @Override
+    public String getClassName() {
+        return nativeGetClassName(nativePtr);
+    }
+
+    @Override
+    public OsRealmObjectSchema setClassName(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removeField(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasField(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removeIndex(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema addPrimaryKey(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema removePrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema setRequired(String fieldName, boolean required) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isRequired(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isNullable(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isPrimaryKey(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasPrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getPrimaryKey() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Set<String> getFieldNames() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public OsRealmObjectSchema transform(Function function) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public RealmFieldType getFieldType(String fieldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    OsRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        nativeAddProperty(nativePtr, new Property(name, type, primary, indexed, required).getNativePtr());
+        return this;
+    }
+
+    @Override
+    OsRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        nativeAddProperty(nativePtr, new Property(name, type, linkedTo).getNativePtr());
+        return this;
+    }
+
+    long getNativePtr() {
+        return nativePtr;
+    }
+
+    private Set<Property> getProperties() {
+        long[] ptrs = nativeGetProperties(nativePtr);
+        Set<Property> properties = new LinkedHashSet<>(ptrs.length);
+        for (int i = 0; i < ptrs.length; i++) {
+            properties.add(new Property(ptrs[i]));
+        }
+        return properties;
+    }
+
+    static native long nativeCreateRealmObjectSchema(String className);
+
+    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
+
+    static native long[] nativeGetProperties(long nativePtr);
+
+    static native void nativeClose(long nativePtr);
+
+    static native String nativeGetClassName(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
index 9b7e100d95..f173f4da32 100644
--- a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@
  */
 class OsRealmSchema extends RealmSchema {
     static final class Creator extends RealmSchema {
-        private final Map<String, RealmObjectSchema> schema = new HashMap<>();
+        private final Map<String, OsRealmObjectSchema> schema = new HashMap<>();
 
         @Override
         public void close() { }
@@ -44,14 +44,14 @@ public RealmObjectSchema get(String className) {
         }
 
         @Override
-        public Set<RealmObjectSchema> getAll() {
+        public Set<OsRealmObjectSchema> getAll() {
             return new LinkedHashSet<>(schema.values());
         }
 
         @Override
         public RealmObjectSchema create(String className) {
             checkEmpty(className);
-            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
             schema.put(className, realmObjectSchema);
             return realmObjectSchema;
         }
@@ -60,6 +60,16 @@ public RealmObjectSchema create(String className) {
         public boolean contains(String className) {
             return schema.containsKey(className);
         }
+
+        @Override
+        public void remove(String className) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public RealmObjectSchema rename(String oldClassName, String newClassName) {
+            throw new UnsupportedOperationException();
+        }
     }
 
     private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
@@ -67,10 +77,10 @@ public boolean contains(String className) {
     private final long nativePtr;
 
     OsRealmSchema(Creator creator) {
-        Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
+        Set<OsRealmObjectSchema> realmObjectSchemas = creator.getAll();
         long[] schemaNativePointers = new long[realmObjectSchemas.size()];
         int i = 0;
-        for (RealmObjectSchema schema : realmObjectSchemas) {
+        for (OsRealmObjectSchema schema : realmObjectSchemas) {
             schemaNativePointers[i++] = schema.getNativePtr();
         }
         this.nativePtr = nativeCreateFromList(schemaNativePointers);
@@ -84,7 +94,7 @@ public long getNativePtr() {
     // See BaseRealm uses a StandardRealmSchema, not a OsRealmSchema.
     @Override
     public void close() {
-        Set<RealmObjectSchema> schemas = getAll();
+        Set<OsRealmObjectSchema> schemas = getAll();
         for (RealmObjectSchema schema : schemas) {
             schema.close();
         }
@@ -109,11 +119,11 @@ public RealmObjectSchema get(String className) {
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
     @Override
-    public Set<RealmObjectSchema> getAll() {
+    public Set<OsRealmObjectSchema> getAll() {
         long[] ptrs = nativeGetAll(nativePtr);
-        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
+        Set<OsRealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
         for (int i = 0; i < ptrs.length; i++) {
-            schemas.add(new RealmObjectSchema(ptrs[i]));
+            schemas.add(new OsRealmObjectSchema(ptrs[i]));
         }
         return schemas;
     }
@@ -128,11 +138,21 @@ public RealmObjectSchema get(String className) {
     public RealmObjectSchema create(String className) {
         // Adding a class is always permitted.
         checkEmpty(className);
-        RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
         dynamicClassToSchema.put(className, realmObjectSchema);
         return realmObjectSchema;
     }
 
+    @Override
+    public void remove(String className) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        throw new UnsupportedOperationException();
+    }
+
     /**
      * Checks if a given class already exists in the schema.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/Property.java
index 02557c6cd6..c96fbfe6c7 100644
--- a/realm/realm-library/src/main/java/io/realm/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/Property.java
@@ -28,13 +28,12 @@
 
     private final long nativePtr;
 
-    public Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
+    Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
         this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
     }
 
-    public Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        String linkedToName = linkedTo.getClassName();
-        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedToName);
+    Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedTo.getClassName());
     }
 
     protected Property(long nativePtr) {
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 857ec5f406..06302c0736 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -337,30 +337,34 @@ private static void initializeRealm(Realm realm) {
             boolean unversioned = currentVersion == UNVERSIONED;
             commitChanges = unversioned;
 
+            RealmConfiguration configuration = realm.getConfiguration();
+
             if (unversioned) {
-                realm.setVersion(realm.configuration.getSchemaVersion());
+                realm.setVersion(configuration.getSchemaVersion());
             }
-            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+
+            final RealmProxyMediator mediator = configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             if (unversioned) {
                 // Create all of the tables.
                 for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    mediator.createTable(modelClass, realm.sharedRealm);
+                    mediator.createRealmObjectSchema(modelClass, realm.getSchema());
                 }
             }
+
+            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Now that they have all been created, validate them.
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.schema.setColumnIndices(
-                    (unversioned) ? realm.configuration.getSchemaVersion() : currentVersion,
+            realm.getSchema().setColumnIndices(
+                    (unversioned) ? configuration.getSchemaVersion() : currentVersion,
                     columnInfoMap);
 
             if (unversioned) {
-                final Transaction transaction = realm.configuration.getInitialDataTransaction();
+                final Transaction transaction = configuration.getInitialDataTransaction();
                 if (transaction != null) {
                     transaction.execute(realm);
                 }
@@ -377,16 +381,18 @@ private static void initializeRealm(Realm realm) {
         }
     }
 
+    // Everything in this method needs to be behind a transaction lock
+    // to prevent multi-process interaction while the Realm is initialized.
     private static void initializeSyncedRealm(Realm realm) {
-        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
-        // the Realm is initialized.
         boolean commitChanges = false;
         try {
             realm.beginTransaction();
             long currentVersion = realm.getVersion();
-            final boolean unversioned = (currentVersion == UNVERSIONED);
+            final boolean unversioned = currentVersion == UNVERSIONED;
 
-            final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            RealmConfiguration configuration = realm.getConfiguration();
+
+            final RealmProxyMediator mediator = configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
             final OsRealmSchema.Creator schemaCreator = new OsRealmSchema.Creator();
@@ -396,15 +402,17 @@ private static void initializeSyncedRealm(Realm realm) {
 
             // Assumption: When SyncConfiguration then additive schema update mode.
             final OsRealmSchema schema = new OsRealmSchema(schemaCreator);
-            long newVersion = realm.configuration.getSchemaVersion();
+            long newVersion = configuration.getSchemaVersion();
             // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
             // It absolutely breaks encapsulation and needs to be fixed!
             long schemaNativePointer = schema.getNativePtr();
             if (realm.sharedRealm.requiresMigration(schemaNativePointer)) {
                 if (currentVersion >= newVersion) {
-                    throw new IllegalArgumentException(String.format("The schema was changed but the schema version " +
-                            "was not updated. The configured schema version (%d) must be higher than the one in the Realm " +
-                            "file (%d) in order to update the schema.", newVersion, currentVersion));
+                    throw new IllegalArgumentException(String.format(
+                            "The schema was changed but the schema version was not updated. " +
+                                    "The configured schema version (%d) must be greater than the version " +
+                                    " in the Realm file (%d) in order to update the schema.",
+                            newVersion, currentVersion));
                 }
                 realm.sharedRealm.updateSchema(schemaNativePointer, newVersion);
                 // The OS currently does not handle setting the schema version. We have to do it manually.
@@ -417,10 +425,12 @@ private static void initializeSyncedRealm(Realm realm) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.getSchema().setColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
+            realm.getSchema().setColumnIndices(
+                    (unversioned) ? newVersion : currentVersion,
+                    columnInfoMap);
 
             if (unversioned) {
-                final Transaction transaction = realm.configuration.getInitialDataTransaction();
+                final Transaction transaction = configuration.getInitialDataTransaction();
                 if (transaction != null) {
                     transaction.execute(realm);
                 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 7e6f77b43f..e575615082 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -1,5 +1,6 @@
+package io.realm;
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,19 +15,10 @@
  * limitations under the License.
  */
 
-package io.realm;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
 import java.util.Set;
 
 import io.realm.annotations.Required;
-import io.realm.internal.Table;
 
 
 /**
@@ -35,99 +27,12 @@
  *
  * @see io.realm.RealmMigration
  */
-public class RealmObjectSchema {
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
-        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
-        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
-        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
-        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
-        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
-        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
-        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
-        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
-        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
-        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
-        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private final BaseRealm realm;
-    final Table table;
-    private final Map<String, Long> columnIndices;
-    private final long nativePtr;
+public abstract class RealmObjectSchema {
 
     /**
-     * Creates a schema object for a given Realm class.
-     *
-     * @param realm Realm holding the objects.
-     * @param table table representation of the Realm class
-     * @param columnIndices mapping between field names and column indexes for the given table
+     * Release the object schema and any of native resources it might hold.
      */
-    RealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
-        this.realm = realm;
-        this.table = table;
-        this.columnIndices = columnIndices;
-        this.nativePtr = 0;
-    }
-
-    /**
-     * Creates a schema object using object store. This constructor is intended to be used by
-     * the validation of schema, object schemas and prorperties through the object store. Even though the constructor
-     * is public, there is never a purpose which justifies calling it!
-     *
-     * @param className name of the class
-     */
-    RealmObjectSchema(String className) {
-        this.realm = null;
-        this.table = null;
-        this.columnIndices = null;
-        this.nativePtr = nativeCreateRealmObjectSchema(className);
-    }
-
-    protected RealmObjectSchema(long nativePtr) {
-        this.realm = null;
-        this.table = null;
-        this.columnIndices = null;
-        this.nativePtr = nativePtr;
-    }
-
-    /**
-     * Closes/frees native resource. Even though the method is public, there is never a purpose which justifies calling
-     * it!
-     */
-    public void close() {
-        if (nativePtr != 0) {
-            Set<Property> properties = getProperties();
-            for (Property property : properties) {
-                property.close();
-            }
-            nativeClose(nativePtr);
-        }
-    }
-
-
-    protected long getNativePtr() {
-        return nativePtr;
-    }
+    public abstract void close();
 
     /**
      * Returns the name of the RealmObject class being represented by this schema.
@@ -139,53 +44,17 @@ protected long getNativePtr() {
      *
      * @return the name of the RealmObject class represented by this schema.
      */
-    public String getClassName() {
-        if (realm == null) {
-            return nativeGetClassName(nativePtr);
-        } else {
-            return table.getName().substring(Table.TABLE_PREFIX.length());
-        }
-    }
+    public abstract String getClassName();
 
     /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
-     * {@link RealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
      *
      * @param className the new name for this class.
      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
      * characters.
      * @see StandardRealmSchema#rename(String, String)
      */
-    public RealmObjectSchema setClassName(String className) {
-        realm.checkNotInSync(); // renaming a table is not permitted
-        checkEmpty(className);
-        String internalTableName = Table.TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
-        }
-        if (realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        // in case this table has a primary key, we need to transfer it after renaming the table.
-        String oldTableName = null;
-        String pkField = null;
-        if (table.hasPrimaryKey()) {
-            oldTableName = table.getName();
-            pkField = getPrimaryKey();
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.renameTable(table.getName(), internalTableName);
-        if (pkField != null && !pkField.isEmpty()) {
-            try {
-                table.setPrimaryKey(pkField);
-            } catch (Exception e) {
-                // revert the table name back when something goes wrong
-                realm.sharedRealm.renameTable(table.getName(), oldTableName);
-                throw e;
-            }
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema setClassName(String className);
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
@@ -203,33 +72,7 @@ public RealmObjectSchema setClassName(String className) {
      * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
      * already exists.
      */
-    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
-        if (metadata == null) {
-            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
-                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
-            } else {
-                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
-                        fieldName, fieldType));
-            }
-        }
-
-        checkNewFieldName(fieldName);
-        boolean nullable = metadata.defaultNullable;
-        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
-            nullable = false;
-        }
-
-        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
-        try {
-            addModifiers(fieldName, attributes);
-        } catch (Exception e) {
-            // Modifiers have been removed by the addModifiers method()
-            table.removeColumn(columnIndex);
-            throw e;
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);
 
     /**
      * Adds a new field that references another {@link RealmObject}.
@@ -239,12 +82,7 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
      * @return the updated schema.
      * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
      */
-    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
+    public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);
 
     /**
      * Adds a new field that references a {@link RealmList}.
@@ -254,40 +92,7 @@ public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
      */
-    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
-
-    /**
-     * Adds a property to an object schema. This method should only be used by proxy classes to set up a schema.
-     *
-     * @param property the property to add.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the method is called after opening a Realm.
-     */
-    protected RealmObjectSchema add(Property property) {
-        if (realm != null && nativePtr == 0) {
-            throw new IllegalArgumentException("Don't use this method.");
-        }
-        nativeAddProperty(nativePtr, property.getNativePtr());
-        return this;
-    }
-
-    private Set<Property> getProperties() {
-        if (realm == null) {
-            long[] ptrs = nativeGetProperties(nativePtr);
-            Set<Property> properties = new LinkedHashSet<>(ptrs.length);
-            for (int i = 0; i < ptrs.length; i++) {
-                properties.add(new Property(ptrs[i]));
-            }
-            return properties;
-        } else {
-            throw new IllegalArgumentException("Not possible");
-        }
-    }
+    public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);
 
     /**
      * Removes a field from the class.
@@ -296,19 +101,7 @@ protected RealmObjectSchema add(Property property) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist.
      */
-    public RealmObjectSchema removeField(String fieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(fieldName);
-        if (!hasField(fieldName)) {
-            throw new IllegalStateException(fieldName + " does not exist.");
-        }
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.getPrimaryKey() == columnIndex) {
-            table.setPrimaryKey(null);
-        }
-        table.removeColumn(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema removeField(String fieldName);
 
     /**
      * Renames a field from one name to another.
@@ -318,19 +111,7 @@ public RealmObjectSchema removeField(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
      */
-    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(currentFieldName);
-        checkFieldExists(currentFieldName);
-        checkLegalName(newFieldName);
-        checkFieldNameIsAvailable(newFieldName);
-        long columnIndex = getColumnIndex(currentFieldName);
-        table.renameColumn(columnIndex, newFieldName);
-
-        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
-
-        return this;
-    }
+    public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);
 
     /**
      * Tests if the class has field defined with the given name.
@@ -338,9 +119,7 @@ public RealmObjectSchema renameField(String currentFieldName, String newFieldNam
      * @param fieldName field name to test.
      * @return {@code true} if the field exists, {@code false} otherwise.
      */
-    public boolean hasField(String fieldName) {
-        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
-    }
+    public abstract boolean hasField(String fieldName);
 
     /**
      * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
@@ -351,16 +130,7 @@ public boolean hasField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
      * index defined.
      */
-    public RealmObjectSchema addIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException(fieldName + " already has an index.");
-        }
-        table.addSearchIndex(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema addIndex(String fieldName);
 
     /**
      * Checks if a given field has an index defined.
@@ -370,12 +140,7 @@ public RealmObjectSchema addIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see io.realm.annotations.Index
      */
-    public boolean hasIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        return table.hasSearchIndex(table.getColumnIndex(fieldName));
-    }
-
+    public abstract boolean hasIndex(String fieldName);
 
     /**
      * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
@@ -384,17 +149,7 @@ public boolean hasIndex(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
      */
-    public RealmObjectSchema removeIndex(String fieldName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException("Field is not indexed: " + fieldName);
-        }
-        table.removeSearchIndex(columnIndex);
-        return this;
-    }
+    public abstract RealmObjectSchema removeIndex(String fieldName);
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
@@ -406,20 +161,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
      * has a primary key defined.
      */
-    public RealmObjectSchema addPrimaryKey(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        if (table.hasPrimaryKey()) {
-            throw new IllegalStateException("A primary key is already defined");
-        }
-        table.setPrimaryKey(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            // No exception will be thrown since adding PrimaryKey implies the column has an index.
-            table.addSearchIndex(columnIndex);
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema addPrimaryKey(String fieldName);
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
@@ -429,18 +171,7 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
      */
-    public RealmObjectSchema removePrimaryKey() {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        long columnIndex = table.getPrimaryKey();
-        if (table.hasSearchIndex(columnIndex)) {
-            table.removeSearchIndex(columnIndex);
-        }
-        table.setPrimaryKey("");
-        return this;
-    }
+    public abstract RealmObjectSchema removePrimaryKey();
 
     /**
      * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
@@ -453,31 +184,7 @@ public RealmObjectSchema removePrimaryKey() {
      * the field already have been set as required.
      * @see Required
      */
-    public RealmObjectSchema setRequired(String fieldName, boolean required) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        boolean currentColumnRequired = isRequired(fieldName);
-        RealmFieldType type = table.getColumnType(columnIndex);
-
-        if (type == RealmFieldType.OBJECT) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
-        }
-        if (type == RealmFieldType.LIST) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
-        }
-        if (required && currentColumnRequired) {
-            throw new IllegalStateException("Field is already required: " + fieldName);
-        }
-        if (!required && !currentColumnRequired) {
-            throw new IllegalStateException("Field is already nullable: " + fieldName);
-        }
-
-        if (required) {
-            table.convertColumnToNotNullable(columnIndex);
-        } else {
-            table.convertColumnToNullable(columnIndex);
-        }
-        return this;
-    }
+    public abstract RealmObjectSchema setRequired(String fieldName, boolean required);
 
     /**
      * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
@@ -488,10 +195,7 @@ public RealmObjectSchema setRequired(String fieldName, boolean required) {
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
      */
-    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        setRequired(fieldName, !nullable);
-        return this;
-    }
+    public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);
 
     /**
      * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
@@ -501,10 +205,7 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setRequired(String, boolean)
      */
-    public boolean isRequired(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return !table.isColumnNullable(columnIndex);
-    }
+    public abstract boolean isRequired(String fieldName);
 
     /**
      * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
@@ -514,10 +215,7 @@ public boolean isRequired(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setNullable(String, boolean)
      */
-    public boolean isNullable(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.isColumnNullable(columnIndex);
-    }
+    public abstract boolean isNullable(String fieldName);
 
     /**
      * Checks if a given field is the primary key field.
@@ -527,10 +225,7 @@ public boolean isNullable(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #addPrimaryKey(String)
      */
-    public boolean isPrimaryKey(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return columnIndex == table.getPrimaryKey();
-    }
+    public abstract boolean isPrimaryKey(String fieldName);
 
     /**
      * Checks if the class has a primary key defined.
@@ -538,9 +233,7 @@ public boolean isPrimaryKey(String fieldName) {
      * @return {@code true} if a primary key is defined, {@code false} otherwise.
      * @see io.realm.annotations.PrimaryKey
      */
-    public boolean hasPrimaryKey() {
-        return table.hasPrimaryKey();
-    }
+    public abstract boolean hasPrimaryKey();
 
     /**
      * Returns the name of the primary key field.
@@ -548,26 +241,14 @@ public boolean hasPrimaryKey() {
      * @return the name of the primary key field.
      * @throws IllegalStateException if the class doesn't have a primary key defined.
      */
-    public String getPrimaryKey() {
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        return table.getColumnName(table.getPrimaryKey());
-    }
+    public abstract String getPrimaryKey();
 
     /**
      * Returns all fields in this class.
      *
      * @return a list of all the fields in this class.
      */
-    public Set<String> getFieldNames() {
-        int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<>(columnCount);
-        for (int i = 0; i < columnCount; i++) {
-            columnNames.add(table.getColumnName(i));
-        }
-        return columnNames;
-    }
+    public abstract Set<String> getFieldNames();
 
     /**
      * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
@@ -575,204 +256,20 @@ public String getPrimaryKey() {
      *
      * @return this schema.
      */
-    public RealmObjectSchema transform(Function function) {
-        if (function != null) {
-            long size = table.size();
-            for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
-            }
-        }
-
-        return this;
-    }
-
-    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
-    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
-        boolean indexAdded = false;
-        try {
-            if (attributes != null && attributes.length > 0) {
-                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
-                }
-
-                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
-                    addPrimaryKey(fieldName);
-                    indexAdded = true;
-                }
-
-                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
-            }
-        } catch (Exception e) {
-            // If something went wrong, revert all attributes.
-            long columnIndex = getColumnIndex(fieldName);
-            if (indexAdded) {
-                table.removeSearchIndex(columnIndex);
-            }
-            throw (RuntimeException) e;
-        }
-    }
-
-    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
-        if (attributeList == null || attributeList.length == 0) {
-            return false;
-        }
-        for (int i = 0; i < attributeList.length; i++) {
-            if (attributeList[i] == attribute) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void checkNewFieldName(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-    }
-
-    private void checkLegalName(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Field name can not be null or empty");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Field name can not contain '.'");
-        }
-    }
-
-    private void checkFieldNameIsAvailable(String fieldName) {
-        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private void checkFieldExists(String fieldName) {
-        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private long getColumnIndex(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex == -1) {
-            throw new IllegalArgumentException(
-                    String.format("Field name '%s' does not exist on schema for '%s",
-                            fieldName, getClassName()
-                    ));
-        }
-        return columnIndex;
-    }
-
-    private void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
+    public abstract RealmObjectSchema transform(Function function);
 
     /**
-     * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned.
+     * Returns the type used by the underlying storage engine to represent this field.
      *
-     * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes valid field type for the last field in a linked field
-     * @return list of column indices.
+     * @return the underlying type used by Realm to represent this field.
      */
-    // TODO: consider another caching strategy so linked classes are included in the cache.
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        if (fieldDescription == null || fieldDescription.equals("")) {
-            throw new IllegalArgumentException("Non-empty fieldname must be provided");
-        }
-        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
-        }
-        Table table = this.table;
-        boolean checkColumnType = validColumnTypes != null && validColumnTypes.length > 0;
-        if (fieldDescription.contains(".")) {
-            // Resolves field description down to last field name.
-            String[] names = fieldDescription.split("\\.");
-            long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length - 1; i++) {
-                long index = table.getColumnIndex(names[i]);
-                if (index < 0) {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-                RealmFieldType type = table.getColumnType(index);
-                if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
-                    table = table.getLinkTarget(index);
-                    columnIndices[i] = index;
-                } else {
-                    throw new IllegalArgumentException("Invalid query: " + names[i] + " does not refer to a class.");
-                }
-            }
-
-            // Checks if last field name is a valid field.
-            String columnName = names[names.length - 1];
-            long columnIndex = table.getColumnIndex(columnName);
-            columnIndices[names.length - 1] = columnIndex;
-            if (columnIndex < 0) {
-                throw new IllegalArgumentException(columnName + " is not a field name in class " + table.getName());
-            }
-            if (checkColumnType && !isValidType(table.getColumnType(columnIndex), validColumnTypes)) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch.", names[names.length - 1]));
-            }
-            return columnIndices;
-        } else {
-            Long fieldIndex = getFieldIndex(fieldDescription);
-            if (fieldIndex == null) {
-                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
-            }
-            RealmFieldType tableColumnType = table.getColumnType(fieldIndex);
-            if (checkColumnType && !isValidType(tableColumnType, validColumnTypes)) {
-                throw new IllegalArgumentException(String.format("Field '%s': type mismatch. Was %s, expected %s.",
-                        fieldDescription, tableColumnType, Arrays.toString(validColumnTypes)));
-            }
-            return new long[] {fieldIndex};
-        }
-    }
+    public abstract RealmFieldType getFieldType(String fieldName);
 
-    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
-        for (int i = 0; i < validColumnTypes.length; i++) {
-            if (validColumnTypes[i] == columnType) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index or null if it doesn't exists.
-     */
-    Long getFieldIndex(String fieldName) {
-        return columnIndices.get(fieldName);
-    }
+    abstract long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes);
 
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index.
-     * @throws IllegalArgumentException if the field does not exists.
-     */
-    long getAndCheckFieldIndex(String fieldName) {
-        Long index = columnIndices.get(fieldName);
-        if (index == null) {
-            throw new IllegalArgumentException("Field does not exist: " + fieldName);
-        }
-        return index;
-    }
+    abstract RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required);
 
-    /**
-     * Returns the type used by the underlying storage engine to represent this field.
-     *
-     * @return the underlying type used by Realm to represent this field.
-     */
-    public RealmFieldType getFieldType(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.getColumnType(columnIndex);
-    }
+    abstract RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo);
 
     /**
      * Function interface, used when traversing all objects of the current class and apply a function on each.
@@ -784,92 +281,13 @@ public RealmFieldType getFieldType(String fieldName) {
     }
 
     // Tuple containing data about each supported Java type.
-    private static class FieldMetaData {
-        public final RealmFieldType realmType;
-        public final boolean defaultNullable;
+    protected static class FieldMetaData {
+        protected final RealmFieldType realmType;
+        protected final boolean defaultNullable;
 
-        public FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
+        protected FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
             this.realmType = realmType;
             this.defaultNullable = defaultNullable;
         }
     }
-
-    static final class DynamicColumnMap implements Map<String, Long> {
-        private final Table table;
-
-        public DynamicColumnMap(Table table) {
-            this.table = table;
-        }
-
-        @Override
-        public Long get(Object key) {
-            long ret = table.getColumnIndex((String) key);
-            return ret < 0 ? null : ret;
-        }
-
-        @Override
-        public void clear() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsKey(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsValue(Object value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<Entry<String, Long>> entrySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<String> keySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long put(String key, Long value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void putAll(Map<? extends String, ? extends Long> map) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long remove(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public int size() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Collection<Long> values() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    static native long nativeCreateRealmObjectSchema(String className);
-
-    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
-
-    static native long[] nativeGetProperties(long nativePtr);
-
-    static native void nativeClose(long nativePtr);
-
-    static native String nativeGetClassName(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 0f2a19e70c..7f3a19197d 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -54,7 +54,7 @@
     private final Table table;
     private final BaseRealm realm;
     private final TableQuery query;
-    private final RealmObjectSchema schema;
+    private final StandardRealmObjectSchema schema;
     private Class<E> clazz;
     private String className;
     private LinkView linkView;
@@ -123,7 +123,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
         this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.table;
+        this.table = schema.getTable();
         this.linkView = null;
         this.query = table.where();
     }
@@ -141,7 +141,7 @@ private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
         this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.table;
+        this.table = schema.getTable();
         this.linkView = linkView;
         this.query = linkView.where();
     }
@@ -150,7 +150,7 @@ private RealmQuery(BaseRealm realm, String className) {
         this.realm = realm;
         this.className = className;
         this.schema = realm.getSchema().getSchemaForClass(className);
-        this.table = schema.table;
+        this.table = schema.getTable();
         this.query = table.where();
     }
 
@@ -158,7 +158,7 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
         this.realm = queryResults.realm;
         this.className = className;
         this.schema = realm.getSchema().getSchemaForClass(className);
-        this.table = schema.table;
+        this.table = schema.getTable();
         this.query = queryResults.getCollection().where();
     }
 
@@ -166,7 +166,7 @@ private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
         this.realm = realm;
         this.className = className;
         this.schema = realm.getSchema().getSchemaForClass(className);
-        this.table = schema.table;
+        this.table = schema.getTable();
         this.linkView = linkView;
         this.query = linkView.where();
     }
@@ -203,7 +203,7 @@ public boolean isValid() {
     public RealmQuery<E> isNull(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName);
+        long[] columnIndices = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
         this.query.isNull(columnIndices);
@@ -221,7 +221,7 @@ public boolean isValid() {
     public RealmQuery<E> isNotNull(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName);
+        long[] columnIndices = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
         this.query.isNotNull(columnIndices);
@@ -256,7 +256,7 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, String value, Case casing) {
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.equalTo(columnIndices, value, casing);
         return this;
     }
@@ -464,7 +464,7 @@ public boolean isValid() {
     }
 
     private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Date value) {
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.equalTo(columnIndices, value);
         return this;
     }
@@ -705,7 +705,7 @@ public boolean isValid() {
     public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         if (columnIndices.length > 1 && !casing.getValue()) {
             throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
         }
@@ -936,7 +936,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -952,7 +952,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -968,7 +968,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThan(columnIndices, value);
         return this;
     }
@@ -984,7 +984,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1000,7 +1000,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1016,7 +1016,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1032,7 +1032,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1048,7 +1048,7 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1064,7 +1064,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1080,7 +1080,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1096,7 +1096,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1112,7 +1112,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1128,7 +1128,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThan(columnIndices, value);
         return this;
     }
@@ -1144,7 +1144,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1160,7 +1160,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1176,7 +1176,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1192,7 +1192,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1208,7 +1208,7 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
@@ -1225,7 +1225,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, int from, int to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1242,7 +1242,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, long from, long to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1259,7 +1259,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, double from, double to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1276,7 +1276,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, float from, float to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1293,7 +1293,7 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.between(columnIndices, from, to);
         return this;
     }
@@ -1323,7 +1323,7 @@ public boolean isValid() {
     public RealmQuery<E> contains(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.contains(columnIndices, value, casing);
         return this;
     }
@@ -1352,7 +1352,7 @@ public boolean isValid() {
     public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.beginsWith(columnIndices, value, casing);
         return this;
     }
@@ -1381,7 +1381,7 @@ public boolean isValid() {
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.endsWith(columnIndices, value, casing);
         return this;
     }
@@ -1418,7 +1418,7 @@ public boolean isValid() {
     public RealmQuery<E> like(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.like(columnIndices, value, casing);
         return this;
     }
@@ -1497,7 +1497,7 @@ public boolean isValid() {
     public RealmQuery<E> isEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isEmpty(columnIndices);
         return this;
     }
@@ -1513,7 +1513,7 @@ public boolean isValid() {
     public RealmQuery<E> isNotEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isNotEmpty(columnIndices);
         return this;
     }
@@ -1835,7 +1835,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
-    public RealmResults<E> findAllSorted(String fieldNames[], Sort sortOrders[]) {
+    public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
         SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
@@ -1857,7 +1857,7 @@ private boolean isDynamicQuery() {
      * {@link RealmObject} or a child {@link RealmList}.
      * @see io.realm.RealmResults
      */
-    public RealmResults<E> findAllSortedAsync(String fieldNames[], final Sort[] sortOrders) {
+    public RealmResults<E> findAllSortedAsync(String[] fieldNames, final Sort[] sortOrders) {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index a340686cf5..e7a42bbc7e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -54,7 +54,7 @@
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
-    public abstract Set<RealmObjectSchema> getAll();
+    public abstract Set<? extends RealmObjectSchema> getAll();
 
     /**
      * Adds a new class to the Realm.
@@ -64,6 +64,23 @@
      */
     public abstract RealmObjectSchema create(String className);
 
+    /**
+     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
+     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
+     *
+     * @param className name of the class to remove.
+     */
+    public abstract void remove(String className);
+
+    /**
+     * Renames a class already in the Realm.
+     *
+     * @param oldClassName old class name.
+     * @param newClassName new class name.
+     * @return a schema object for renamed class.
+     */
+    public abstract RealmObjectSchema rename(String oldClassName, String newClassName);
+
     /**
      * Checks if a given class already exists in the schema.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
new file mode 100644
index 0000000000..cced1c6d23
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
@@ -0,0 +1,827 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.annotations.Required;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+
+
+class StandardRealmObjectSchema extends RealmObjectSchema {
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
+        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
+        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
+        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
+        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
+        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
+        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
+        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
+        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
+        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    private final BaseRealm realm;
+    private final Map<String, Long> columnIndices;
+    private final Table table;
+
+    /**
+     * Creates a schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     * @param columnIndices mapping between field names and column indexes for the given table
+     */
+    StandardRealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
+        this.realm = realm;
+        this.table = table;
+        this.columnIndices = columnIndices;
+    }
+
+    public Table getTable() {
+        return table;
+    }
+
+    /**
+     * There are no resources here that need closing.
+     */
+    @Override
+    public void close() { }
+
+    /**
+     * Returns the name of the RealmObject class being represented by this schema.
+     * <p>
+     * <ul>
+     * <li>When using a typed {@link Realm} this name is the same as the {@link RealmObject} class.</li>
+     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
+     * </ul>
+     *
+     * @return the name of the RealmObject class represented by this schema.
+     */
+    @Override
+    public String getClassName() {
+        return table.getName().substring(Table.TABLE_PREFIX.length());
+    }
+
+    /**
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
+     * {@link StandardRealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
+     *
+     * @param className the new name for this class.
+     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
+     * characters.
+     * @see StandardRealmSchema#rename(String, String)
+     */
+    @Override
+    public StandardRealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
+        checkEmpty(className);
+        String internalTableName = Table.TABLE_PREFIX + className;
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+        }
+        if (realm.sharedRealm.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        String oldTableName = null;
+        String pkField = null;
+        if (table.hasPrimaryKey()) {
+            oldTableName = table.getName();
+            pkField = getPrimaryKey();
+            table.setPrimaryKey(null);
+        }
+        realm.sharedRealm.renameTable(table.getName(), internalTableName);
+        if (pkField != null && !pkField.isEmpty()) {
+            try {
+                table.setPrimaryKey(pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
+        return this;
+    }
+
+    /**
+     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
+     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
+     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
+     * <p>
+     * To add fields that reference other RealmObjects or RealmLists use
+     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
+     * instead.
+     *
+     * @param fieldName name of the field to add.
+     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
+     * @param attributes set of attributes for this field.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
+     * already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
+        if (metadata == null) {
+            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
+                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
+                        fieldName, fieldType));
+            }
+        }
+
+        checkNewFieldName(fieldName);
+        boolean nullable = metadata.defaultNullable;
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
+        try {
+            addModifiers(fieldName, attributes);
+        } catch (Exception e) {
+            // Modifiers have been removed by the addModifiers method()
+            table.removeColumn(columnIndex);
+            throw e;
+        }
+        return this;
+    }
+
+    /**
+     * Adds a new field that references another {@link RealmObject}.
+     *
+     * @param fieldName name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Adds a new field that references a {@link RealmList}.
+     *
+     * @param fieldName name of the field to add.
+     * @param objectSchema schema for the Realm type being referenced.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        return this;
+    }
+
+    /**
+     * Removes a field from the class.
+     *
+     * @param fieldName field name to remove.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     */
+    @Override
+    public StandardRealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(fieldName);
+        if (!hasField(fieldName)) {
+            throw new IllegalStateException(fieldName + " does not exist.");
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.getPrimaryKey() == columnIndex) {
+            table.setPrimaryKey(null);
+        }
+        table.removeColumn(columnIndex);
+        return this;
+    }
+
+    /**
+     * Renames a field from one name to another.
+     *
+     * @param currentFieldName field name to rename.
+     * @param newFieldName the new field name.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
+     */
+    @Override
+    public StandardRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(currentFieldName);
+        checkFieldExists(currentFieldName);
+        checkLegalName(newFieldName);
+        checkFieldNameIsAvailable(newFieldName);
+        long columnIndex = getColumnIndex(currentFieldName);
+        table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
+        return this;
+    }
+
+    /**
+     * Tests if the class has field defined with the given name.
+     *
+     * @param fieldName field name to test.
+     * @return {@code true} if the field exists, {@code false} otherwise.
+     */
+    @Override
+    public boolean hasField(String fieldName) {
+        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
+    }
+
+    /**
+     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
+     * annotation on the field.
+     *
+     * @param fieldName field to add index to.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
+     * index defined.
+     */
+    @Override
+    public StandardRealmObjectSchema addIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException(fieldName + " already has an index.");
+        }
+        table.addSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Checks if a given field has an index defined.
+     *
+     * @param fieldName existing field name to check.
+     * @return {@code true} if field is indexed, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see io.realm.annotations.Index
+     */
+    @Override
+    public boolean hasIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        return table.hasSearchIndex(table.getColumnIndex(fieldName));
+    }
+
+
+    /**
+     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
+     *
+     * @param fieldName field to remove index from.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
+     */
+    @Override
+    public StandardRealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException("Field is not indexed: " + fieldName);
+        }
+        table.removeSearchIndex(columnIndex);
+        return this;
+    }
+
+    /**
+     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
+     * as well.
+     *
+     * @param fieldName field to set as primary key.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
+     * has a primary key defined.
+     */
+    @Override
+    public StandardRealmObjectSchema addPrimaryKey(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        if (table.hasPrimaryKey()) {
+            throw new IllegalStateException("A primary key is already defined");
+        }
+        table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
+     * the field as well.
+     *
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
+     */
+    @Override
+    public StandardRealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
+        table.setPrimaryKey("");
+        return this;
+    }
+
+    /**
+     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
+     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
+     *
+     * @param fieldName name of field in the class.
+     * @param required {@code true} if field should be required, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
+     * the field already have been set as required.
+     * @see Required
+     */
+    @Override
+    public StandardRealmObjectSchema setRequired(String fieldName, boolean required) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        boolean currentColumnRequired = isRequired(fieldName);
+        RealmFieldType type = table.getColumnType(columnIndex);
+
+        if (type == RealmFieldType.OBJECT) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
+        }
+        if (type == RealmFieldType.LIST) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
+        }
+        if (required && currentColumnRequired) {
+            throw new IllegalStateException("Field is already required: " + fieldName);
+        }
+        if (!required && !currentColumnRequired) {
+            throw new IllegalStateException("Field is already nullable: " + fieldName);
+        }
+
+        if (required) {
+            table.convertColumnToNotNullable(columnIndex);
+        } else {
+            table.convertColumnToNullable(columnIndex);
+        }
+        return this;
+    }
+
+    /**
+     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
+     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
+     *
+     * @param fieldName name of field in the class.
+     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
+     */
+    @Override
+    public StandardRealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        setRequired(fieldName, !nullable);
+        return this;
+    }
+
+    /**
+     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is required, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setRequired(String, boolean)
+     */
+    @Override
+    public boolean isRequired(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return !table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is required, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #setNullable(String, boolean)
+     */
+    @Override
+    public boolean isNullable(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.isColumnNullable(columnIndex);
+    }
+
+    /**
+     * Checks if a given field is the primary key field.
+     *
+     * @param fieldName field to check.
+     * @return {@code true} if it is the primary key field, {@code false} otherwise.
+     * @throws IllegalArgumentException if field name doesn't exist.
+     * @see #addPrimaryKey(String)
+     */
+    @Override
+    public boolean isPrimaryKey(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return columnIndex == table.getPrimaryKey();
+    }
+
+    /**
+     * Checks if the class has a primary key defined.
+     *
+     * @return {@code true} if a primary key is defined, {@code false} otherwise.
+     * @see io.realm.annotations.PrimaryKey
+     */
+    @Override
+    public boolean hasPrimaryKey() {
+        return table.hasPrimaryKey();
+    }
+
+    /**
+     * Returns the name of the primary key field.
+     *
+     * @return the name of the primary key field.
+     * @throws IllegalStateException if the class doesn't have a primary key defined.
+     */
+    @Override
+    public String getPrimaryKey() {
+        if (!table.hasPrimaryKey()) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        return table.getColumnName(table.getPrimaryKey());
+    }
+
+    /**
+     * Returns all fields in this class.
+     *
+     * @return a list of all the fields in this class.
+     */
+    @Override
+    public Set<String> getFieldNames() {
+        int columnCount = (int) table.getColumnCount();
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        for (int i = 0; i < columnCount; i++) {
+            columnNames.add(table.getColumnName(i));
+        }
+        return columnNames;
+    }
+
+    /**
+     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
+     * as a {@link DynamicRealmObject}.
+     *
+     * @return this schema.
+     */
+    @Override
+    public StandardRealmObjectSchema transform(Function function) {
+        if (function != null) {
+            long size = table.size();
+            for (long i = 0; i < size; i++) {
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+            }
+        }
+
+        return this;
+    }
+
+    /**
+     * Returns the type used by the underlying storage engine to represent this field.
+     *
+     * @return the underlying type used by Realm to represent this field.
+     */
+    @Override
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.getColumnType(columnIndex);
+    }
+
+    @Override
+    StandardRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
+
+        if (indexed) { table.addSearchIndex(columnIndex); }
+
+        if (primary) { table.setPrimaryKey(name); }
+
+        return this;
+    }
+
+    @Override
+    StandardRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        table.addColumnLink(
+                type,
+                name,
+                realm.getSharedRealm().getTable(StandardRealmSchema.TABLE_PREFIX + linkedTo.getClassName()));
+        return this;
+    }
+
+    /**
+     * Returns the column indices for the given field name. If a linked field is defined, the column index for
+     * each field is returned.
+     *
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return list of column indices.
+     */
+    // TODO: consider another caching strategy so linked classes are included in the cache.
+    @Override
+    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        if (fieldDescription == null || fieldDescription.equals("")) {
+            throw new IllegalArgumentException("Invalid query: field name is empty");
+        }
+        if (fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
+        }
+        String[] names = fieldDescription.split("\\.");
+
+        //final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+
+        long[] columnIndices = new long[names.length];
+        Table currentTable = table;
+        RealmFieldType columnType;
+        String columnName;
+        String tableName;
+        for (int i = 0; /* loop exits in the middle */ ; i++) {
+            columnName = names[i];
+            if (columnName.length() <= 0) {
+                throw new IllegalArgumentException(String.format(
+                        "Invalid query: empty column name in field '%s'.  " +
+                                "A field name must not begin with, end with, or contain adjacent periods ('.').",
+                                fieldDescription));
+            }
+
+            tableName = getTableName(currentTable);
+            long index = currentTable.getColumnIndex(columnName);
+            if (index < 0) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' does not exist in table '%s'.",
+                                columnName, tableName));
+            }
+            columnIndices[i] = index;
+
+            columnType = currentTable.getColumnType(index);
+
+            if (i >= names.length - 1) { break; }
+
+            if ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST)) {
+                throw new IllegalArgumentException(
+                        String.format("Invalid query: field '%s' in table '%s' is of type '%s'.  It must be a LIST or OBJECT type.",
+                                columnName, tableName, columnType.toString()));
+            }
+
+            currentTable = currentTable.getLinkTarget(index);
+        }
+
+        if ((validColumnTypes != null) && (validColumnTypes.length > 0) && !isValidType(columnType, validColumnTypes)) {
+            throw new IllegalArgumentException(
+                    String.format("Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
+                            columnName, tableName, columnType.toString()));
+        }
+
+        return columnIndices;
+    }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index or null if it doesn't exists.
+     */
+    Long getFieldIndex(String fieldName) {
+        return columnIndices.get(fieldName);
+    }
+
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     *
+     * @param fieldName field name to find index for.
+     * @return column index.
+     * @throws IllegalArgumentException if the field does not exists.
+     */
+    long getAndCheckFieldIndex(String fieldName) {
+        Long index = columnIndices.get(fieldName);
+        if (index == null) {
+            throw new IllegalArgumentException("Field does not exist: " + fieldName);
+        }
+        return index;
+    }
+
+    private String getTableName(Table table) {
+        return table.getName().substring(StandardRealmSchema.TABLE_PREFIX.length());
+    }
+
+    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
+    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
+        boolean indexAdded = false;
+        try {
+            if (attributes != null && attributes.length > 0) {
+                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                }
+
+                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
+                    addPrimaryKey(fieldName);
+                    indexAdded = true;
+                }
+
+                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
+            }
+        } catch (Exception e) {
+            // If something went wrong, revert all attributes.
+            long columnIndex = getColumnIndex(fieldName);
+            if (indexAdded) {
+                table.removeSearchIndex(columnIndex);
+            }
+            throw (RuntimeException) e;
+        }
+    }
+
+    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+        if (attributeList == null || attributeList.length == 0) {
+            return false;
+        }
+        for (int i = 0; i < attributeList.length; i++) {
+            if (attributeList[i] == attribute) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void checkNewFieldName(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+    }
+
+    private void checkLegalName(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Field name can not be null or empty");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Field name can not contain '.'");
+        }
+    }
+
+    private void checkFieldNameIsAvailable(String fieldName) {
+        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private void checkFieldExists(String fieldName) {
+        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private long getColumnIndex(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(
+                    String.format("Field name '%s' does not exist on schema for '%s",
+                            fieldName, getClassName()
+                    ));
+        }
+        return columnIndex;
+    }
+
+    private void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
+        for (int i = 0; i < validColumnTypes.length; i++) {
+            if (validColumnTypes[i] == columnType) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static final class DynamicColumnMap implements Map<String, Long> {
+        private final Table table;
+
+        DynamicColumnMap(Table table) {
+            this.table = table;
+        }
+
+        @Override
+        public Long get(Object key) {
+            long ret = table.getColumnIndex((String) key);
+            return ret < 0 ? null : ret;
+        }
+
+        @Override
+        public void clear() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean containsValue(Object value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<Entry<String, Long>> entrySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Set<String> keySet() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long put(String key, Long value) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void putAll(Map<? extends String, ? extends Long> map) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Long remove(Object key) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int size() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public Collection<Long> values() {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
index 9b224c9d44..3d3933d451 100644
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,9 +33,9 @@
  *
  * @see io.realm.RealmMigration
  */
-public class StandardRealmSchema extends RealmSchema {
+class StandardRealmSchema extends RealmSchema {
 
-    private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
+    static final String TABLE_PREFIX = Table.TABLE_PREFIX;
     private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
 
     // Caches Dynamic Class objects given as Strings to Realm Tables
@@ -43,9 +43,9 @@
     // Caches Class objects (both model classes and proxy classes) to Realm Tables
     private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
     // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<>();
+    private final Map<Class<? extends RealmModel>, StandardRealmObjectSchema> classToSchema = new HashMap<>();
     // Caches Class Strings to their Schema object
-    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+    private final Map<String, StandardRealmObjectSchema> dynamicClassToSchema = new HashMap<>();
 
     private final BaseRealm realm;
 
@@ -73,12 +73,12 @@ public RealmObjectSchema get(String className) {
         if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
 
         Table table = realm.getSharedRealm().getTable(internalClassName);
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
     }
 
     /**
-     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     * Returns the {@link StandardRealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
@@ -92,8 +92,8 @@ public RealmObjectSchema get(String className) {
                 continue;
             }
             Table table = realm.getSharedRealm().getTable(tableName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+            schemas.add(new StandardRealmObjectSchema(realm, table, columnIndices));
         }
         return schemas;
     }
@@ -117,8 +117,8 @@ public RealmObjectSchema create(String className) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
         Table table = realm.getSharedRealm().getTable(internalTableName);
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
     }
 
     /**
@@ -138,6 +138,7 @@ public boolean contains(String className) {
      *
      * @param className name of the class to remove.
      */
+    @Override
     public void remove(String className) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(className, EMPTY_STRING_MSG);
@@ -157,6 +158,7 @@ public void remove(String className) {
      * @param newClassName new class name.
      * @return a schema object for renamed class.
      */
+    @Override
     public RealmObjectSchema rename(String oldClassName, String newClassName) {
         realm.checkNotInSync(); // Destructive modifications are not permitted.
         checkEmpty(oldClassName, "Class names cannot be empty or null");
@@ -184,8 +186,8 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
             table.setPrimaryKey(pkField);
         }
 
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
+        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+        return new StandardRealmObjectSchema(realm, table, columnIndices);
     }
 
     private void checkEmpty(String str, String error) {
@@ -236,8 +238,8 @@ Table getTable(Class<? extends RealmModel> clazz) {
         return table;
     }
 
-    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        RealmObjectSchema classSchema = classToSchema.get(clazz);
+    StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        StandardRealmObjectSchema classSchema = classToSchema.get(clazz);
         if (classSchema != null) { return classSchema; }
 
         Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
@@ -247,7 +249,7 @@ RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         }
         if (classSchema == null) {
             Table table = getTable(clazz);
-            classSchema = new RealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
+            classSchema = new StandardRealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
             classToSchema.put(originalClass, classSchema);
         }
         if (isProxyClass(originalClass, clazz)) {
@@ -257,16 +259,16 @@ RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         return classSchema;
     }
 
-    RealmObjectSchema getSchemaForClass(String className) {
+    StandardRealmObjectSchema getSchemaForClass(String className) {
         className = Table.TABLE_PREFIX + className;
-        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
+        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
         if (dynamicSchema == null) {
             if (!realm.getSharedRealm().hasTable(className)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
             Table table = realm.getSharedRealm().getTable(className);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
+            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
+            dynamicSchema = new StandardRealmObjectSchema(realm, table, columnIndices);
             dynamicClassToSchema.put(className, dynamicSchema);
         }
         return dynamicSchema;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index d2c7319f5c..50c2c72983 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -54,14 +54,6 @@
      */
     public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
 
-    /**
-     * Creates the backing table in Realm for the given RealmObject class.
-     *
-     * @param clazz the {@link RealmObject} model class to create backing table for.
-     * @param sharedRealm the wrapper object of underlying native database.
-     */
-    public abstract Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm);
-
     /**
      * Validates the backing table in Realm for the given RealmObject class.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index ad81a72afd..6021c88720 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -100,43 +100,43 @@ public TableQuery not() {
 
     // Queries for integer values.
 
-    public TableQuery equalTo(long columnIndexes[], long value) {
+    public TableQuery equalTo(long[] columnIndexes, long value) {
         nativeEqual(nativePtr, columnIndexes, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], long value) {
+    public TableQuery notEqualTo(long[] columnIndex, long value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], long value) {
+    public TableQuery greaterThan(long[] columnIndex, long value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], long value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], long value) {
+    public TableQuery lessThan(long[] columnIndex, long value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], long value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, long value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], long value1, long value2) {
+    public TableQuery between(long[] columnIndex, long value1, long value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -144,43 +144,43 @@ public TableQuery between(long columnIndex[], long value1, long value2) {
 
     // Queries for float values.
 
-    public TableQuery equalTo(long columnIndex[], float value) {
+    public TableQuery equalTo(long[] columnIndex, float value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], float value) {
+    public TableQuery notEqualTo(long[] columnIndex, float value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], float value) {
+    public TableQuery greaterThan(long[] columnIndex, float value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], float value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, float value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], float value) {
+    public TableQuery lessThan(long[] columnIndex, float value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], float value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, float value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], float value1, float value2) {
+    public TableQuery between(long[] columnIndex, float value1, float value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -188,43 +188,43 @@ public TableQuery between(long columnIndex[], float value1, float value2) {
 
     // Queries for double values.
 
-    public TableQuery equalTo(long columnIndex[], double value) {
+    public TableQuery equalTo(long[] columnIndex, double value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], double value) {
+    public TableQuery notEqualTo(long[] columnIndex, double value) {
         nativeNotEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], double value) {
+    public TableQuery greaterThan(long[] columnIndex, double value) {
         nativeGreater(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], double value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, double value) {
         nativeGreaterEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], double value) {
+    public TableQuery lessThan(long[] columnIndex, double value) {
         nativeLess(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], double value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, double value) {
         nativeLessEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], double value1, double value2) {
+    public TableQuery between(long[] columnIndex, double value1, double value2) {
         nativeBetween(nativePtr, columnIndex, value1, value2);
         queryValidated = false;
         return this;
@@ -232,7 +232,7 @@ public TableQuery between(long columnIndex[], double value1, double value2) {
 
     // Query for boolean values.
 
-    public TableQuery equalTo(long columnIndex[], boolean value) {
+    public TableQuery equalTo(long[] columnIndex, boolean value) {
         nativeEqual(nativePtr, columnIndex, value);
         queryValidated = false;
         return this;
@@ -240,9 +240,9 @@ public TableQuery equalTo(long columnIndex[], boolean value) {
 
     // Queries for Date values.
 
-    private final static String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
+    private static final String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
-    public TableQuery equalTo(long columnIndex[], Date value) {
+    public TableQuery equalTo(long[] columnIndex, Date value) {
         if (value == null) {
             nativeIsNull(nativePtr, columnIndex);
         } else {
@@ -252,42 +252,42 @@ public TableQuery equalTo(long columnIndex[], Date value) {
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], Date value) {
+    public TableQuery notEqualTo(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long columnIndex[], Date value) {
+    public TableQuery greaterThan(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long columnIndex[], Date value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long columnIndex[], Date value) {
+    public TableQuery lessThan(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long columnIndex[], Date value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, Date value) {
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
         nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery between(long columnIndex[], Date value1, Date value2) {
+    public TableQuery between(long[] columnIndex, Date value1, Date value2) {
         if (value1 == null || value2 == null) {
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
         }
@@ -312,7 +312,7 @@ public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
 
     // Query for String values.
 
-    private final static String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
+    private static final String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
 
     // Equals
     public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
@@ -328,61 +328,61 @@ public TableQuery equalTo(long[] columnIndexes, String value) {
     }
 
     // Not Equals
-    public TableQuery notEqualTo(long columnIndex[], String value, Case caseSensitive) {
+    public TableQuery notEqualTo(long[] columnIndex, String value, Case caseSensitive) {
         nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long columnIndex[], String value) {
+    public TableQuery notEqualTo(long[] columnIndex, String value) {
         nativeNotEqual(nativePtr, columnIndex, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery beginsWith(long[] columnIndices, String value, Case caseSensitive) {
         nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long columnIndices[], String value) {
+    public TableQuery beginsWith(long[] columnIndices, String value) {
         nativeBeginsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery endsWith(long[] columnIndices, String value, Case caseSensitive) {
         nativeEndsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long columnIndices[], String value) {
+    public TableQuery endsWith(long[] columnIndices, String value) {
         nativeEndsWith(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery like(long[] columnIndices, String value, Case caseSensitive) {
         nativeLike(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long columnIndices[], String value) {
+    public TableQuery like(long[] columnIndices, String value) {
         nativeLike(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long columnIndices[], String value, Case caseSensitive) {
+    public TableQuery contains(long[] columnIndices, String value, Case caseSensitive) {
         nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long columnIndices[], String value) {
+    public TableQuery contains(long[] columnIndices, String value) {
         nativeContains(nativePtr, columnIndices, value, true);
         queryValidated = false;
         return this;
@@ -604,13 +604,13 @@ public Date minimumDate(long columnIndex) {
     }
 
     // isNull and isNotNull
-    public TableQuery isNull(long columnIndices[]) {
+    public TableQuery isNull(long[] columnIndices) {
         nativeIsNull(nativePtr, columnIndices);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotNull(long columnIndices[]) {
+    public TableQuery isNotNull(long[] columnIndices) {
         nativeIsNotNull(nativePtr, columnIndices);
         queryValidated = false;
         return this;
@@ -660,63 +660,63 @@ private void throwImmutable() {
 
     private native void nativeNot(long nativeQueryPtr);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, float value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], float value1, float value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, float value1, float value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeGreater(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeLess(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, double value);
 
-    private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
+    private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, double value1, double value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, boolean value);
 
-    private native void nativeEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
 
-    private native void nativeBetweenTimestamp(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeBetweenTimestamp(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
 
@@ -724,15 +724,15 @@ private void throwImmutable() {
 
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, String value, boolean caseSensitive);
 
-    private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeEndsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeLike(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
-    private native void nativeContains(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
 
     private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
 
@@ -768,9 +768,9 @@ private void throwImmutable() {
 
     private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-    private native void nativeIsNull(long nativePtr, long columnIndices[]);
+    private native void nativeIsNull(long nativePtr, long[] columnIndices);
 
-    private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
+    private native void nativeIsNotNull(long nativePtr, long[] columnIndices);
 
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
index 48cdee87fb..c611cb6674 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
@@ -18,9 +18,9 @@
 
 class TestUtil {
 
-    public native static long getMaxExceptionNumber();
+    public static native long getMaxExceptionNumber();
 
-    public native static String getExpectedMessage(long exceptionKind);
+    public static native String getExpectedMessage(long exceptionKind);
 
-    public native static void testThrowExceptions(long exceptionKind);
+    public static native void testThrowExceptions(long exceptionKind);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index dc410380d8..81218ae82e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -38,7 +38,6 @@
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
 import io.realm.internal.Util;
 
 
@@ -50,7 +49,7 @@
     private final Map<Class<? extends RealmModel>, RealmProxyMediator> mediators;
 
     public CompositeMediator(RealmProxyMediator... mediators) {
-        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<Class<? extends RealmModel>, RealmProxyMediator>();
+        final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
                 for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
@@ -67,12 +66,6 @@ public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> cla
         return mediator.createRealmObjectSchema(clazz, schema);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createTable(clazz, sharedRealm);
-    }
-
     @Override
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
             boolean allowExtraColumns) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index f0cdbf22b8..3f4f6fa471 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -38,7 +38,6 @@
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
 import io.realm.internal.Util;
 
 
@@ -60,7 +59,7 @@
     public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmModel>> allowedClasses) {
         this.originalMediator = originalMediator;
 
-        Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<Class<? extends RealmModel>>();
+        Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<>();
         if (originalMediator != null) {
             Set<Class<? extends RealmModel>> originalClasses = originalMediator.getModelClasses();
             for (Class<? extends RealmModel> clazz : allowedClasses) {
@@ -82,12 +81,6 @@ public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> cla
         return originalMediator.createRealmObjectSchema(clazz, schema);
     }
 
-    @Override
-    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.createTable(clazz, sharedRealm);
-    }
-
     @Override
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
             boolean allowExtraColumns) {
