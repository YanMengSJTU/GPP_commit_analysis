diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5055d2304c..0e4f427496 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,7 @@
 * Added `Realm.refresh()` and `DynamicRealm.refresh()` (#3476).
 * Added `Realm.getInstanceAsync()` and `DynamicRealm.getInstanceAsync()` (#2299).
 * Added `DynamicRealmObject#linkingObjects(String,String)` to support linking objects on `DynamicRealm` (#4492).
+* Added support for read only Realms using `RealmConfiguration.Builder.readOnly()` and `SyncConfiguration.Builder.readOnly()`(#1147).
 * Change listeners will now auto-expand variable names to be more descriptive when using Android Studio.
 
 ### Bug Fixes
diff --git a/realm/realm-library/src/androidTest/assets/readonly.realm b/realm/realm-library/src/androidTest/assets/readonly.realm
new file mode 100644
index 0000000000..d2d3637a8f
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/readonly.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 7b191920be..4064615145 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -402,6 +402,13 @@ public void equals() {
         assertTrue(config1.equals(config2));
     }
 
+    @Test
+    public void equals_respectReadOnly() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).assetFile("foo").build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).assetFile("foo").readOnly().build();
+        assertFalse(config1.equals(config2));
+    }
+
     @Test
     public void equalsWhenRxJavaUnavailable() {
         // Test for https://github.com/realm/realm-java/issues/2416
@@ -959,4 +966,40 @@ public void detectMissingEqualsInCustomMigration() {
             realm.close();
         }
     }
+
+    @Test
+    public void readOnly_initialTransaction_throws() {
+        // Check assetFile(), then initialTransaction();
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder()
+                .assetFile("foo")
+                .readOnly()
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // Do nothing
+                    }
+                });
+
+        try {
+            config.build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void readOnly_deleteRealmIfMigrationRequired_throws() {
+        try {
+            // This test doesn't actually fail on 'deleteRealmIfMigrationNeeded' + 'readOnly' but on
+            // 'assetFile' + 'deleteRealmIfMigrationNeed()'. This test is primarely here to prevent this
+            // case from accidentally parsing in the future.
+            new RealmConfiguration.Builder()
+                    .assetFile("foo")
+                    .readOnly()
+                    .deleteRealmIfMigrationNeeded()
+                    .build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 9356203617..abf5b79c5d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -18,8 +18,6 @@
 
 import android.content.Context;
 import android.os.Build;
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.test.InstrumentationRegistry;
@@ -48,7 +46,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
@@ -98,8 +95,10 @@
 import io.realm.entities.PrimaryKeyRequiredAsString;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
+import io.realm.entities.StringOnlyReadOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
@@ -4052,4 +4051,41 @@ public void refresh_insideTransactionThrows() {
         }
         realm.cancelTransaction();
     }
+
+    @Test
+    public void beginTransaction_readOnlyThrows() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class)
+                .assetFile("readonly.realm")
+                .readOnly()
+                .build();
+        Realm realm = Realm.getInstance(config);
+        try {
+            realm.beginTransaction();
+            fail();
+        } catch (IllegalStateException e) {
+            assertTrue(e.getMessage().startsWith("Write transactions cannot be used "));
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void getInstance_wrongSchemaInReadonlyThrows() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class, AllJavaTypes.class)
+                .assetFile("readonly.realm")
+                .readOnly()
+                .build();
+
+        // This will throw because the Realm doesn't have the correct schema, and a new file cannot be re-created
+        // because it is read only.
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java
new file mode 100644
index 0000000000..af886fc2cb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+
+/**
+ * WARNING: This class is used by some `readOnly()` tests. Modifying this class will cause these to fail.
+ * If this class is modified then `/assets/readonly.realm` must be re-created as well.
+ */
+public class StringOnlyReadOnly extends RealmObject {
+    private String chars;
+
+    public String getChars() {
+        return chars;
+    }
+
+    public void setChars(String chars) {
+        this.chars = chars;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 0a5352c989..383cf39c5c 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -340,8 +340,12 @@ public void onCall() {
      * incompatible schema changes.
      */
     public void beginTransaction() {
+        beginTransaction(false);
+    }
+
+    void beginTransaction(boolean ignoreReadOnly) {
         checkIfValid();
-        sharedRealm.beginTransaction();
+        sharedRealm.beginTransaction(ignoreReadOnly);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 025ec56556..51a2707b1a 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -38,6 +38,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
@@ -413,30 +414,34 @@ private static void initializeRealm(Realm realm) {
         // the Realm is initialized.
         boolean commitChanges = false;
         try {
-            realm.beginTransaction();
+            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
+            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
+            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
+            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
+            realm.beginTransaction(true);
             long currentVersion = realm.getVersion();
             boolean unversioned = currentVersion == UNVERSIONED;
             commitChanges = unversioned;
 
             RealmConfiguration configuration = realm.getConfiguration();
+            RealmProxyMediator mediator = configuration.getSchemaMediator();
+            Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
+            // Only allow creating the schema if not in read-only mode
             if (unversioned) {
+                if (configuration.isReadOnly()) {
+                    throw new IllegalArgumentException("Cannot create the Realm schema in a read-only file.");
+                }
                 realm.setVersion(configuration.getSchemaVersion());
-            }
-
-            final RealmProxyMediator mediator = configuration.getSchemaMediator();
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-
-            if (unversioned) {
                 // Create all of the tables.
                 for (Class<? extends RealmModel> modelClass : modelClasses) {
                     mediator.createRealmObjectSchema(modelClass, realm.getSchema());
                 }
             }
 
+            // Now that they have all been created, validate them.
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                // Now that they have all been created, validate them.
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
@@ -444,11 +449,10 @@ private static void initializeRealm(Realm realm) {
                     (unversioned) ? configuration.getSchemaVersion() : currentVersion,
                     columnInfoMap);
 
-            if (unversioned) {
-                final Transaction transaction = configuration.getInitialDataTransaction();
-                if (transaction != null) {
-                    transaction.execute(realm);
-                }
+            // Finally add any initial data
+            final Transaction transaction = configuration.getInitialDataTransaction();
+            if (transaction != null && unversioned) {
+                transaction.execute(realm);
             }
         } catch (Exception e) {
             commitChanges = false;
@@ -456,7 +460,7 @@ private static void initializeRealm(Realm realm) {
         } finally {
             if (commitChanges) {
                 realm.commitTransaction();
-            } else {
+            } else if (realm.isInTransaction()) {
                 realm.cancelTransaction();
             }
         }
@@ -469,7 +473,11 @@ private static void initializeSyncedRealm(Realm realm) {
         OsRealmSchema schema = null;
         OsRealmSchema.Creator schemaCreator = null;
         try {
-            realm.beginTransaction();
+            // We need to start a transaction no matter readOnly mode, because it acts as an interprocess lock.
+            // TODO: For proper inter-process support we also need to move e.g copying the asset file under an
+            // interprocess lock. This lock can obviously not be created by a Realm instance so we probably need
+            // to implement it in Object Store. When this happens, the `beginTransaction(true)` can be removed again.
+            realm.beginTransaction(true);
             long currentVersion = realm.getVersion();
             final boolean unversioned = currentVersion == UNVERSIONED;
 
@@ -478,41 +486,45 @@ private static void initializeSyncedRealm(Realm realm) {
             final RealmProxyMediator mediator = configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            schemaCreator = new OsRealmSchema.Creator();
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                mediator.createRealmObjectSchema(modelClass, schemaCreator);
-            }
+            long newVersion = configuration.getSchemaVersion();
 
-            // Assumption: When SyncConfiguration then additive schema update mode.
-            schema = new OsRealmSchema(schemaCreator);
-            schemaCreator.close();
-            schemaCreator = null;
+            // Update/create the schema if allowed
+            if (!configuration.isReadOnly()) {
+                schemaCreator = new OsRealmSchema.Creator();
+                for (Class<? extends RealmModel> modelClass : modelClasses) {
+                    mediator.createRealmObjectSchema(modelClass, schemaCreator);
+                }
 
-            long newVersion = configuration.getSchemaVersion();
-            if (realm.sharedRealm.requiresMigration(schema.getNativePtr())) {
-                if (currentVersion >= newVersion) {
-                    throw new IllegalArgumentException(String.format(
-                            "The schema was changed but the schema version was not updated. " +
-                                    "The configured schema version (%d) must be greater than the version " +
-                                    " in the Realm file (%d) in order to update the schema.",
-                            newVersion, currentVersion));
+                // Assumption: When SyncConfiguration then additive schema update mode.
+                schema = new OsRealmSchema(schemaCreator);
+                schemaCreator.close();
+                schemaCreator = null;
+
+                // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
+                // It absolutely breaks encapsulation and needs to be fixed!
+                if (realm.sharedRealm.requiresMigration(schema.getNativePtr())) {
+                    if (currentVersion >= newVersion) {
+                        throw new IllegalArgumentException(String.format(
+                                "The schema was changed but the schema version was not updated. " +
+                                        "The configured schema version (%d) must be greater than the version " +
+                                        " in the Realm file (%d) in order to update the schema.",
+                                newVersion, currentVersion));
+                    }
+                    realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
+                    // The OS currently does not handle setting the schema version. We have to do it manually.
+                    realm.setVersion(newVersion);
+                    commitChanges = true;
                 }
-                realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
-                // The OS currently does not handle setting the schema version. We have to do it manually.
-                realm.setVersion(newVersion);
-                commitChanges = true;
             }
 
+            // Validate the schema in the file
             final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
+            realm.getSchema().setInitialColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
 
-            realm.getSchema().setInitialColumnIndices(
-                    (unversioned) ? newVersion : currentVersion,
-                    columnInfoMap);
-
-            if (unversioned) {
+            if (unversioned && !configuration.isReadOnly()) {
                 final Transaction transaction = configuration.getInitialDataTransaction();
                 if (transaction != null) {
                     transaction.execute(realm);
@@ -525,7 +537,6 @@ private static void initializeSyncedRealm(Realm realm) {
             if (schemaCreator != null) {
                 schemaCreator.close();
             }
-
             if (schema != null) {
                 schema.close();
             }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 064a656a37..c12980872f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -97,6 +97,7 @@
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
+    private final boolean readOnly;
 
     // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
     // subsets of them.
@@ -111,7 +112,8 @@ protected RealmConfiguration(File realmDirectory,
             SharedRealm.Durability durability,
             RealmProxyMediator schemaMediator,
             RxObservableFactory rxObservableFactory,
-            Realm.Transaction initialDataTransaction) {
+            Realm.Transaction initialDataTransaction,
+            boolean readOnly) {
         this.realmDirectory = realmDirectory;
         this.realmFileName = realmFileName;
         this.canonicalPath = canonicalPath;
@@ -124,6 +126,7 @@ protected RealmConfiguration(File realmDirectory,
         this.schemaMediator = schemaMediator;
         this.rxObservableFactory = rxObservableFactory;
         this.initialDataTransaction = initialDataTransaction;
+        this.readOnly = readOnly;
     }
 
     public File getRealmDirectory() {
@@ -211,7 +214,7 @@ public String getPath() {
 
     /**
      * Checks if the Realm file defined by this configuration already exists.
-     *
+     * <p>
      * WARNING: This method is just a point-in-time check. Unless protected by external synchronization another
      * thread or process might have created or deleted the Realm file right after this method has returned.
      *
@@ -237,6 +240,16 @@ public RxObservableFactory getRxFactory() {
         return rxObservableFactory;
     }
 
+    /**
+     * Returns whether this Realm is read-only or not. Read-only Realms cannot be modified and will throw an
+     * {@link IllegalStateException} if {@link Realm#beginTransaction()} is called on it.
+     *
+     * @return {@code true} if this Realm is read only, {@code false} if not.
+     */
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
     @Override
     public boolean equals(Object obj) {
         if (this == obj) { return true; }
@@ -259,6 +272,7 @@ public boolean equals(Object obj) {
         if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) {
             return false;
         }
+        if (readOnly != that.readOnly) { return false; }
 
         return schemaMediator.equals(that.schemaMediator);
     }
@@ -277,6 +291,7 @@ public int hashCode() {
         result = 31 * result + durability.hashCode();
         result = 31 * result + (rxObservableFactory != null ? rxObservableFactory.hashCode() : 0);
         result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
+        result = 31 * result + (readOnly ? 1 : 0);
 
         return result;
     }
@@ -349,6 +364,8 @@ public String toString() {
         stringBuilder.append("durability: ").append(durability);
         stringBuilder.append("\n");
         stringBuilder.append("schemaMediator: ").append(schemaMediator);
+        stringBuilder.append("\n");
+        stringBuilder.append("readOnly: ").append(readOnly);
 
         return stringBuilder.toString();
     }
@@ -404,6 +421,7 @@ boolean isSyncConfiguration() {
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
+        private boolean readOnly;
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
@@ -433,6 +451,7 @@ private void initializeBuilder(Context context) {
             this.migration = null;
             this.deleteRealmIfMigrationNeeded = false;
             this.durability = SharedRealm.Durability.FULL;
+            this.readOnly = false;
             if (DEFAULT_MODULE != null) {
                 this.modules.add(DEFAULT_MODULE);
             }
@@ -615,16 +634,15 @@ public Builder initialData(Realm.Transaction transaction) {
          * When opening the Realm for the first time, instead of creating an empty file,
          * the Realm file will be copied from the provided asset file and used instead.
          * <p>
-         * <p>This cannot be configured to clear and recreate schema by calling {@link #deleteRealmIfMigrationNeeded()}
-         * at the same time as doing so will delete the copied asset schema.
-         * <p>
+         * This cannot be combined with {@link #deleteRealmIfMigrationNeeded()} as doing so would just result in the
+         * copied file being deleted.
          * <p>
          * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
          *
          * @param assetFile path to the asset database file.
          * @throws IllegalStateException if this is configured to clear its schema by calling {@link #deleteRealmIfMigrationNeeded()}.
          */
-        public Builder assetFile(final String assetFile) {
+        public Builder assetFile(String assetFile) {
             if (TextUtils.isEmpty(assetFile)) {
                 throw new IllegalArgumentException("A non-empty asset file path must be provided");
             }
@@ -634,12 +652,26 @@ public Builder assetFile(final String assetFile) {
             if (this.deleteRealmIfMigrationNeeded) {
                 throw new IllegalStateException("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().");
             }
-
             this.assetFilePath = assetFile;
 
             return this;
         }
 
+        /**
+         * Setting this will cause the Realm to become read only and all write transactions made against this Realm will
+         * fail with an {@link IllegalStateException}.
+         * <p>
+         * This in particular mean that {@link #initialData(Realm.Transaction)} will not work in combination with a
+         * read only Realm and setting this will result in a {@link IllegalStateException} being thrown.
+         * </p>
+         * Marking a Realm as read only only applies to the Realm in this process. Other processes can still
+         * write to the Realm.
+         */
+        public Builder readOnly() {
+            this.readOnly = true;
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
@@ -672,6 +704,20 @@ Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmMode
          * @return the created {@link RealmConfiguration}.
          */
         public RealmConfiguration build() {
+            // Check that readOnly() was applied to legal configuration. Right now it should only be allowed if
+            // an assetFile is configured
+            if (readOnly) {
+                if (initialDataTransaction != null) {
+                    throw new IllegalStateException("This Realm is marked as read-only. Read-only Realms cannot use initialData(Realm.Transaction).");
+                }
+                if (assetFilePath == null) {
+                    throw new IllegalStateException("Only Realms provided using 'assetFile(path)' can be marked read-only. No such Realm was provided.");
+                }
+                if (deleteRealmIfMigrationNeeded) {
+                    throw new IllegalStateException("'deleteRealmIfMigrationNeeded()' and read-only Realms cannot be combined");
+                }
+            }
+
             if (rxFactory == null && isRxJavaAvailable()) {
                 rxFactory = new RealmObservableFactory();
             }
@@ -687,7 +733,8 @@ public RealmConfiguration build() {
                     durability,
                     createSchemaMediator(modules, debugSchema),
                     rxFactory,
-                    initialDataTransaction
+                    initialDataTransaction,
+                    readOnly
             );
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index d59362b09e..4380fee5ba 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -899,6 +899,31 @@ private void checkForAddRemoveListener(Object listener, boolean checkListener) {
 
     /**
      * Adds a change listener to this {@link RealmList}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmList from being garbage collected.
+     * If the RealmList is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmList<Dog> dogs; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       dogs = realm.where(Person.class).findFirst().getDogs();
+     *       dogs.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+     *           \@Override
+     *           public void onChange(RealmList<Dog> dogs, OrderedCollectionChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -925,6 +950,31 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<
 
     /**
      * Adds a change listener to this {@link RealmList}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmList from being garbage collected.
+     * If the RealmList is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmList<Dog> dogs; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       dogs = realm.where(Person.class).findFirst().getDogs();
+     *       dogs.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
+     *           \@Override
+     *           public void onChange(RealmList<Dog> dogs) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 0648341216..85199653ac 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -316,6 +316,31 @@ public final boolean load() {
      * Adds a change listener to this RealmObject to get detailed information about changes. The listener will be
      * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
      * changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmObjectChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person, ObjectChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
@@ -330,6 +355,31 @@ public final boolean load() {
     /**
      * Adds a change listener to this RealmObject that will be triggered if any value field or referenced RealmObject
      * field is changed, or the RealmList field itself is changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
@@ -345,6 +395,32 @@ public final boolean load() {
      * Adds a change listener to a RealmObject to get detailed information about the changes. The listener will be
      * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
      * changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmObjectChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person, ObjectChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
+     *
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
@@ -375,6 +451,31 @@ public final boolean load() {
     /**
      * Adds a change listener to a RealmObject that will be triggered if any value field or referenced RealmObject field
      * is changed, or the RealmList field itself is changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 82c7e62893..4426d48f24 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -135,6 +135,31 @@ public boolean load() {
 
     /**
      * Adds a change listener to this {@link RealmResults}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmResults from being garbage collected.
+     * If the RealmResults is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmResults<Person> results; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       results = realm.where(Person.class).findAllAsync();
+     *       results.addChangeListener(new RealmChangeListener<RealmResults<Person>>() {
+     *           \@Override
+     *           public void onChange(RealmResults<Person> persons) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -148,6 +173,31 @@ public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
 
     /**
      * Adds a change listener to this {@link RealmResults}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmResults from being garbage collected.
+     * If the RealmResults is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmResults<Person> results; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       results = realm.where(Person.class).findAllAsync();
+     *       results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Person>>() {
+     *           \@Override
+     *           public void onChange(RealmResults<Person> persons, OrderedCollectionChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index a5aab3136a..a1e058a79a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -244,6 +244,15 @@ public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionLi
     }
 
     public void beginTransaction() {
+        beginTransaction(false);
+    }
+
+    public void beginTransaction(boolean ignoreReadOnly) {
+        // TODO ReadOnly is also supported by the Object Store Schema, but until we support that we need to enforce it
+        // ourselves.
+        if (!ignoreReadOnly && configuration.isReadOnly()) {
+            throw new IllegalStateException("Write transactions cannot be used when a Realm is marked as read-only.");
+        }
         detachIterators();
         executePendingRowQueries();
         nativeBeginTransaction(nativePtr);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 160c506996..19ce6ab69e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -92,6 +92,7 @@ private SyncConfiguration(File directory,
                                 RealmProxyMediator schemaMediator,
                                 RxObservableFactory rxFactory,
                                 Realm.Transaction initialDataTransaction,
+                                boolean readOnly,
                                 SyncUser user,
                                 URI serverUrl,
                                 SyncSession.ErrorHandler errorHandler,
@@ -110,7 +111,8 @@ private SyncConfiguration(File directory,
                 durability,
                 schemaMediator,
                 rxFactory,
-                initialDataTransaction
+                initialDataTransaction,
+                readOnly
         );
 
         this.user = user;
@@ -257,6 +259,7 @@ boolean isSyncConfiguration() {
         private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
         private boolean deleteRealmOnLogout = false;
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
+        private boolean readOnly = false;
         private boolean waitForServerChanges = false;
 
         /**
@@ -611,6 +614,21 @@ public Builder waitForInitialRemoteData() {
             return this;
         }
 
+        /**
+         * Setting this will cause the Realm to become read only and all write transactions made against this Realm will
+         * fail with an {@link IllegalStateException}.
+         * <p>
+         * This in particular mean that {@link #initialData(Realm.Transaction)} will not work in combination with a
+         * read only Realm and setting this will result in a {@link IllegalStateException} being thrown.
+         * </p>
+         * Marking a Realm as read only only applies to the Realm in this process. Other processes and devices can still
+         * write to the Realm.
+         */
+        public SyncConfiguration.Builder readOnly() {
+            this.readOnly = true;
+            return this;
+        }
+
         private String MD5(String in) {
             try {
                 MessageDigest digest = MessageDigest.getInstance("MD5");
@@ -652,6 +670,19 @@ public SyncConfiguration build() {
                 throw new IllegalStateException("serverUrl() and user() are both required.");
             }
 
+            // Check that readOnly() was applied to legal configuration. Right now it should only be allowd if
+            // an assetFile is configured
+            if (readOnly) {
+                if (initialDataTransaction != null) {
+                    throw new IllegalStateException("This Realm is marked as read-only. " +
+                            "Read-only Realms cannot use initialData(Realm.Transaction).");
+                }
+                if (!waitForServerChanges) {
+                    throw new IllegalStateException("A read-only Realms must be provided by some source. " +
+                            "'waitForInitialRemoteData()' wasn't enabled which is currently the only supported source.");
+                }
+            }
+
             // Check if the user has an identifier, if not, it cannot use /~/.
             if (serverUrl.toString().contains("/~/") && user.getIdentity() == null) {
                 throw new IllegalStateException("The serverUrl contains a /~/, but the user does not have an identity." +
@@ -718,6 +749,7 @@ public SyncConfiguration build() {
                     createSchemaMediator(modules, debugSchema),
                     rxFactory,
                     initialDataTransaction,
+                    readOnly,
 
                     // Sync Configuration specific
                     user,
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
new file mode 100644
index 0000000000..c8d7b1513e
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.Random;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.objectserver.BaseIntegrationTest;
+import io.realm.objectserver.utils.Constants;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestSyncConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+/**
+ * Catch all class for tests that not naturally fit anywhere else.
+ */
+public class SyncedRealmTests extends BaseIntegrationTest {
+
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
+    @Rule
+    public final TestSyncConfigurationFactory configurationFactory = new TestSyncConfigurationFactory();
+
+    @Test
+    @UiThreadTest
+    public void waitForInitialRemoteData_mainThreadThrows() {
+        final SyncUser user = loginUser();
+
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (IllegalStateException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // Login user on a worker thread, so this method can be used from both UI and non-ui threads.
+    @NonNull
+    private SyncUser loginUser() {
+        final CountDownLatch userReady = new CountDownLatch(1);
+        final AtomicReference<SyncUser> user = new AtomicReference<>();
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+                user.set(SyncUser.login(credentials, Constants.AUTH_URL));
+                userReady.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(userReady);
+        return user.get();
+    }
+
+    @Test
+    public void waitForInitialRemoteData() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo" + i);
+                }
+            }
+        });
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(10));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+        Realm.deleteRealm(configOld);
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes (pray it managed to do so within the time frame).
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .build();
+
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo 1" + i);
+                }
+            }
+        });
+        try {
+            assertEquals(20, realm.where(StringOnly.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    public void waitForInitialData_resilientInCaseOfRetries() throws InterruptedException {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        for (int i = 0; i < 10; i++) {
+            Thread t = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Realm realm = null;
+                    try {
+                        // This will cause the download latch called later to immediately throw an InterruptedException.
+                        Thread.currentThread().interrupt();
+                        realm = Realm.getInstance(config);
+                    } catch (DownloadingRealmInterruptedException ignored) {
+                        assertFalse(new File(config.getPath()).exists());
+                    } finally {
+                        if (realm != null) {
+                            realm.close();
+                            Realm.deleteRealm(config);
+                        }
+                    }
+                }
+            });
+            t.start();
+            t.join();
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    @RunTestInLooperThread
+    public void waitForInitialData_resilientInCaseOfRetriesAsync() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+        Random randomizer = new Random();
+
+        for (int i = 0; i < 10; i++) {
+            RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    fail();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    fail(exception.toString());
+                }
+            });
+            SystemClock.sleep(randomizer.nextInt(5));
+            task.cancel();
+        }
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void waitForInitialRemoteData_readOnlyTrue() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo" + i);
+                }
+            }
+        });
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(10));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+        Realm.deleteRealm(configOld);
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes (pray it managed to do so within the time frame).
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .readOnly()
+                .schema(StringOnly.class)
+                .build();
+        assertFalse(configNew.realmExists());
+
+        realm = Realm.getInstance(configNew);
+        assertEquals(10, realm.where(StringOnly.class).count());
+        realm.close();
+        user.logout();
+    }
+
+
+    @Test
+    public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .readOnly()
+                .schema(StringOnly.class)
+                .build();
+        assertFalse(configNew.realmExists());
+
+        Realm realm = null;
+        try {
+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the
+            // schema.
+            realm = Realm.getInstance(configNew);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+            user.logout();
+        }
+    }
+
+    @Test
+    public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData() // Not readonly so Client should be allowed to write schema
+                .schema(StringOnly.class) // This schema should be written when opening the empty Realm.
+                .schemaVersion(2)
+                .build();
+        assertFalse(config.realmExists());
+
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertEquals(0, realm.where(StringOnly.class).count());
+        } finally {
+            realm.close();
+            user.logout();
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
index 79081d405a..a6cd05356e 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
@@ -27,7 +27,7 @@
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.HttpUtils;
 
-class BaseIntegrationTest {
+public class BaseIntegrationTest {
 
     private static int originalLogLevel;
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java
index 4881139b82..cb82896b72 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncedRealmTests.java
@@ -165,7 +165,6 @@ public void waitForInitialData_resilientInCaseOfRetriesAsync() {
         Random randomizer = new Random();
 
         for (int i = 0; i < 10; i++) {
-            final int iteration = i;
             RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
                 @Override
                 public void onSuccess(Realm realm) {
