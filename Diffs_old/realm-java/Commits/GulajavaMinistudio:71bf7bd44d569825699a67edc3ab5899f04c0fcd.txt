diff --git a/CHANGELOG.md b/CHANGELOG.md
index 46411e8f0d..5403963378 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,8 @@
 
 ### Breaking Changes
 
+* Updated file format of Realm files. Existing Realm files will automatically be migrated to the new format when they are opened.
+* [ObjectServer] Due to file format changes, Realm Object Server 1.3.0 or later is required.
 * [ObjectServer] Added `onClientResetRequired(SyncSession, ClientResetHandler)` method to the `ErrorHandler` interface (#4080).
 
 ### Enhancements
@@ -12,8 +14,11 @@
   * Linking objects are not yet supported on dynamic objects
   * Migration for linking objects is not yet supported.
   * Backlink verification is incomplete.  Evil code can cause native crashes.
+* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
 * [ObjectServer] In case of a Client Reset, information about the location of the backed up Realm file is now reported through the `ErrorHandler` interface (#4080).
 * [ObjectServer] Authentication URLs now automatically append `/auth` if no other path segment is set (#4370).
+* The listener on `RealmObject` will only be triggered if the object changes (#3894).
+* Added `RealmObjectChangeListener` to get detailed information about `RealmObject` changes.
 
 ### Bug Fixes
 
@@ -22,6 +27,8 @@
 ### Internal
 
 * Using the Object Store's Session and SyncManager.
+* Upgraded to Realm Sync 1.5.0.
+* Upgraded to Realm Core 2.5.1.
 
 
 ## 3.0.1 (YYYY-MM-DD)
@@ -31,6 +38,7 @@
 * Now using Gradle 3.4.1
 * Now `targetSdkVersion` is 25.
 * Listeners on `RealmList` and `RealmResults` will be triggered immediately when the transaction is committed on the same thread (#4245).
+* `RealmQuery.distinct()` can be performed on unindexed fields (#2285).
 
 ### Bug Fixes
 
diff --git a/dependencies.list b/dependencies.list
index 857165a0d4..408853f4de 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.3.2
-REALM_SYNC_SHA256=be79d334ca8d87785a91fa5d68264bc62de49271936d5c19b6473f34cd47f9f0
+REALM_SYNC_VERSION=1.5.0
+REALM_SYNC_SHA256=2da0de557182e7d717d74808bf6d3f1e5f18d5c082744d29b96dca80555733a7
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
@@ -10,4 +10,4 @@ REALM_SYNC_SHA256=be79d334ca8d87785a91fa5d68264bc62de49271936d5c19b6473f34cd47f9
 # /tools/sync_test_server/Dockerfile specify which repo (apt) we should
 # install/use between 'realm' and 'realm-testing', the version below should
 # correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.2.1-270
+REALM_OBJECT_SERVER_DE_VERSION=1.3.0-294
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index 8a42675c8a..db813f22ad 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -61,7 +61,9 @@ realm {
 
 dependencies {
     compile 'com.android.support:support-v4:25.2.0'
+    compile 'com.android.support:appcompat-v7:25.2.0'
     compile 'com.android.support:design:25.2.0'
+    compile 'me.zhanghai.android.materialprogressbar:library:1.3.0'
     compile 'com.jakewharton:butterknife:8.3.0'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 97c67d2443..536b24ef90 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -17,32 +17,67 @@
 package io.realm.examples.objectserver;
 
 import android.content.Intent;
+import android.graphics.PorterDuff;
 import android.os.Bundle;
+import android.support.annotation.ColorRes;
 import android.support.v7.app.AppCompatActivity;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.view.View;
 import android.widget.TextView;
 
 import java.util.Locale;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.examples.objectserver.model.CRDTCounter;
+import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
 
 public class CounterActivity extends AppCompatActivity {
 
     private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
 
     private Realm realm;
+    private SyncSession session;
     private CRDTCounter counter;
     private SyncUser user;
+    private AtomicBoolean downloadingChanges = new AtomicBoolean(false);
+    private AtomicBoolean uploadingChanges = new AtomicBoolean(false);
+    private ProgressListener downloadListener = new ProgressListener() {
+        @Override
+        public void onChange(Progress progress) {
+            downloadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private ProgressListener uploadListener = new ProgressListener() {
+        @Override
+        public void onChange(Progress progress) {
+            uploadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private Runnable updateProgressBar = new Runnable() {
+        @Override
+        public void run() {
+            updateProgressBar(downloadingChanges.get(), uploadingChanges.get());
+        }
+    };
+
 
     @BindView(R.id.text_counter) TextView counterView;
+    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -86,12 +121,21 @@ public void onChange(CRDTCounter counter) {
                 }
             });
             counterView.setText("0");
+
+            // Setup progress listeners for indeterminate progress bars
+            session = SyncManager.getSession(config);
+            session.addDownloadProgressListener(ProgressMode.INDEFINITELY, downloadListener);
+            session.addUploadProgressListener(ProgressMode.INDEFINITELY, uploadListener);
         }
     }
 
     @Override
     protected void onStop() {
         super.onStop();
+        if (session != null) {
+            session.removeProgressListener(downloadListener);
+            session.removeProgressListener(uploadListener);
+        }
         closeRealm();
         user = null;
     }
@@ -132,6 +176,22 @@ public void decrementCounter() {
         adjustCounter(-1);
     }
 
+    private void updateProgressBar(boolean downloading, boolean uploading) {
+        @ColorRes int color = android.R.color.black;
+        int visibility = View.VISIBLE;
+        if (downloading && uploading) {
+            color = R.color.progress_both;
+        } else if (downloading) {
+            color = R.color.progress_download;
+        } else if (uploading) {
+            color = R.color.progress_upload;
+        } else {
+            visibility = View.GONE;
+        }
+        progressBar.getIndeterminateDrawable().setColorFilter(getResources().getColor(color), PorterDuff.Mode.SRC_IN);
+        progressBar.setVisibility(visibility);
+    }
+
     private void adjustCounter(final int adjustment) {
         // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
         // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
index 62127eca0d..df73031aa7 100644
--- a/examples/objectServerExample/src/main/res/layout/activity_counter.xml
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -1,7 +1,9 @@
 <RelativeLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
 
     <LinearLayout
         android:layout_width="match_parent"
@@ -34,4 +36,15 @@
         android:fontFamily="sans-serif-light"
         android:textSize="160sp"/>
 
+    <me.zhanghai.android.materialprogressbar.MaterialProgressBar
+        android:id="@+id/progressbar"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="top"
+        android:indeterminate="true"
+        app:mpb_progressStyle="horizontal"
+        android:visibility="gone"
+        style="@style/Widget.MaterialProgressBar.ProgressBar.Horizontal.NoPadding"
+        />
+
 </RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
index aada8ea195..8fec3b9456 100644
--- a/examples/objectServerExample/src/main/res/values/realm_colors.xml
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -20,4 +20,9 @@
     <color name="flamingo_darker">#d64881</color>
     <color name="touch_area_pressed">#dadada</color>
 
+    // Progress bar colors
+    <color name="progress_upload">#EF5350</color>
+    <color name="progress_download">#9CCC65</color>
+    <color name="progress_both">#FFA726</color>
+
 </resources>
\ No newline at end of file
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
index 4c79b44550..d79258c51d 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -44,7 +44,7 @@
  * }
  * </pre>
  * In the above example `Person` is related to `Dog` through the field `dog`.
- * This in turn means that an implict reverse relationship exists between the class `Dog`
+ * This in turn means that an implicit reverse relationship exists between the class `Dog`
  * and the class `Person`. This inverse relationship is made public and queryable by the `RealmResults`
  * field annotated with `@LinkingObject`. This makes it possible to query properties of the dogs owner
  * without having to manually maintain a "owner" field in the `Dog` class.
@@ -57,6 +57,8 @@
  *     <li>They are ignored when doing a `copyToRealm().`</li>
  *     <li>They are ignored when doing a `copyFromRealm().`</li>
  *     <li>They are ignored when using the various `createObjectFromJson*` and `createAllFromJson*` methods.</li>
+ *     <li>Listeners on an object with a `@LinkingObject` field will not be triggered if the linking objects change,
+ *     e.g: if another object drops a reference to this object.</li>
  * </ul>
  * <p>
  * In addition, they have the following restrictions:
@@ -92,6 +94,7 @@
  */
 @Retention(RetentionPolicy.SOURCE)
 @Target(ElementType.FIELD)
+@Beta
 public @interface LinkingObjects {
     /**
      * The name of a field that contains a relation to an instance of the
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 3e1b2dbc2b..8322220938 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -29,7 +29,9 @@ if (!ext.coreArchiveDir) {
 }
 ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/realm-sync-android-${project.coreVersion}.tar.gz")
 ext.coreDistributionDir = file("${projectDir}/distribution/realm-core/")
-ext.coreDir = file("${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
+ext.coreDir = file(project.coreSourcePath ?
+        "${project.coreSourcePath}/android-lib" :
+        "${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
 ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
 ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
 
@@ -46,11 +48,11 @@ android {
         externalNativeBuild {
             cmake {
                 arguments "-DREALM_CORE_DIST_DIR:STRING=${project.coreDir.getAbsolutePath()}",
-                          // FIXME:
-                          // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
-                          // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
-                          // JNI build currently (lack of lto linking support).
-                          // This file should be removed and use the one from Android SDK cmake package when it supports lto.
+                        // FIXME:
+                        // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+                        // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+                        // JNI build currently (lack of lto linking support).
+                        // This file should be removed and use the one from Android SDK cmake package when it supports lto.
                         "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
                 if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
                 if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
@@ -112,6 +114,15 @@ android {
             consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-objectServer.pro'
         }
     }
+
+    variantFilter { variant ->
+        def names = variant.flavors*.name
+
+        // Ignore the objectServer flavour when building from core source.
+        if (coreSourcePath && names.contains("objectServer")) {
+            variant.ignore = true
+        }
+    }
 }
 
 project.afterEvaluate {
@@ -183,7 +194,7 @@ task javadoc(type: Javadoc) {
         links "http://reactivex.io/RxJava/javadoc/"
         linksOffline "https://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
 
-        tags = [ betaTag ]
+        tags = [betaTag]
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -266,7 +277,7 @@ check.dependsOn tasks.checkstyle
 // Configuration options can be found here:
 // http://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html
 task connectedBenchmarks(type: GradleBuild) {
-    description =  'Run all benchmarks on connected devices'
+    description = 'Run all benchmarks on connected devices'
     group = 'Verification'
     buildFile = file("${projectDir}/build.gradle")
     startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.package', 'io.realm.benchmarks')
@@ -274,7 +285,7 @@ task connectedBenchmarks(type: GradleBuild) {
 }
 
 task connectedUnitTests(type: GradleBuild) {
-    description =  'Run all unit tests on connected devices'
+    description = 'Run all unit tests on connected devices'
     group = 'Verification'
     buildFile = file("${projectDir}/build.gradle")
     startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.notPackage', 'io.realm.benchmarks')
@@ -372,7 +383,7 @@ publishing {
                 accessKey project.hasProperty('s3AccessKey') ? s3AccessKey : 'noAccessKey'
                 secretKey project.hasProperty('s3SecretKey') ? s3SecretKey : 'noSecretKey'
             }
-            if(project.version.endsWith('-SNAPSHOT')) {
+            if (project.version.endsWith('-SNAPSHOT')) {
                 url "s3://realm-ci-artifacts/maven/snapshots/"
             } else {
                 url "s3://realm-ci-artifacts/maven/releases/"
@@ -412,7 +423,7 @@ task downloadCore() {
         return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
     }
 
-    def calcSha256Hash = {File targetFile ->
+    def calcSha256Hash = { File targetFile ->
         MessageDigest sha = MessageDigest.getInstance("SHA-256")
         Formatter hexHash = new Formatter()
         sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
@@ -496,9 +507,14 @@ task deployCore(group: 'build setup', description: 'Deploy the latest version of
         coreSourcePath ? compileCore : downloadCore
     }
 
+    // Build with the output from core source dir. No need to deploy anything.
+    onlyIf {
+        return !coreSourcePath
+    }
+
     outputs.upToDateWhen {
-        // Clean up the coreDir if it is newly downloaded or compiled from source
-        if (coreDownloaded || coreSourcePath) {
+        // Clean up the coreDir if it is newly downloaded
+        if (coreDownloaded) {
             return false
         }
 
@@ -589,52 +605,52 @@ android.productFlavors.all { flavor ->
         dependsOn "assemble${flavor.name.capitalize()}"
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/outputs/aar/realm-android-library-${flavor.name}-release.aar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.aar?publish=0"
     }
 
     task("bintraySources${flavor.name.capitalize()}", type: Exec) {
         dependsOn sourcesJar
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-sources.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-sources.jar?publish=0"
     }
 
     task("bintrayJavadoc${flavor.name.capitalize()}", type: Exec) {
         dependsOn javadocJar
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/libs/realm-android-library-${project.version}-javadoc.jar",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}-javadoc.jar?publish=0"
     }
 
     task("bintrayPom${flavor.name.capitalize()}", type: Exec) {
         dependsOn "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal"
         group = 'Publishing'
         commandLine 'curl',
-            '-X',
-            'PUT',
-            '-T',
-            "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
-            '-u',
-            "${userName}:${accessKey}",
-            "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
+                '-X',
+                'PUT',
+                '-T',
+                "${buildDir}/publications/${flavor.name}Publication/pom-default.xml",
+                '-u',
+                "${userName}:${accessKey}",
+                "https://api.bintray.com/content/realm/maven/realm-android-library${librarySuffix}/${project.version}/io/realm/realm-android-library${librarySuffix}/${project.version}/realm-android-library${librarySuffix}-${project.version}.pom?publish=0"
     }
 
     // OJO
@@ -738,11 +754,11 @@ def checkNdk(String ndkPath) {
     }
     if (detectedNdkVersion != project.ndkVersion) {
         throw new GradleException("Your NDK version: ${detectedNdkVersion}."
-                +" Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
+                + " Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
     }
 }
 
-def getValueFromPropertiesFile(File propFile, String key) {
+static def getValueFromPropertiesFile(File propFile, String key) {
     if (!propFile.isFile() || !propFile.canRead()) {
         return null
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index 302c3952e8..9c75ee8629 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -151,44 +151,6 @@ public void basic_multipleReferencesFromParentList() {
         assertEquals(parent, child.getListParents().last());
     }
 
-    // A listener registered on the backlinked object should be called when a commit adds a backlink
-    @Test
-    @RunTestInLooperThread
-    public void notification_onCommitModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
-
-
     // A listener registered on the backlinked object should not be called after the listener is removed
     @Test
     @RunTestInLooperThread
@@ -224,81 +186,6 @@ public void run(Realm realm) {
             child, parent);
     }
 
-    // A listener registered on the backlinked object should be called when a backlinked object is deleted
-    @Test
-    @RunTestInLooperThread
-    public void notification_onDeleteModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
-    // A listener registered on the backlinked object is called
-    // for an unrelated change on the an object of the same type!!
-    // This test exists only to document existing (but odd) behavior.
-    @Test
-    @RunTestInLooperThread
-    public void notification_notSentOnUnrelatedChangeModelObject() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 10);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        looperThreadRealm.commitTransaction();
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll().deleteAllFromRealm();
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
     // A listener registered on the backlinked field should be called when a commit adds a backlink
     @Test
     @RunTestInLooperThread
@@ -498,63 +385,6 @@ public void json_updateList() {
         assertTrue(parents.contains(parent));
     }
 
-    // A JSON update should generate a notifcation
-    @Test
-    @RunTestInLooperThread
-    public void json_jsonUpdateCausesNotification() {
-        final Realm looperThreadRealm = looperThread.realm;
-
-        looperThreadRealm.beginTransaction();
-        AllJavaTypes child = looperThreadRealm.createObject(AllJavaTypes.class, 1);
-        AllJavaTypes parent = looperThreadRealm.createObject(AllJavaTypes.class, 2);
-        parent.setFieldObject(child);
-        looperThreadRealm.commitTransaction();
-
-        RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
-        assertNotNull(results);
-        assertEquals(results.size(), 1);
-        child = results.first();
-
-        RealmResults<AllJavaTypes> parents = child.getObjectParents();
-        assertNotNull(parents);
-        assertEquals(1, parents.size());
-
-        final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener<AllJavaTypes> listener = new RealmChangeListener<AllJavaTypes>() {
-            @Override
-            public void onChange(AllJavaTypes object) {
-                counter.incrementAndGet();
-            }
-        };
-        child.addChangeListener(listener);
-
-        looperThreadRealm.beginTransaction();
-        try {
-            looperThreadRealm.createOrUpdateAllFromJson(AllJavaTypes.class, "[{ \"fieldId\" : 2, \"fieldObject\" : null }]");
-        } catch (RealmException e) {
-            fail("Failed loading JSON" + e);
-        }
-        looperThreadRealm.commitTransaction();
-
-        verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    RealmResults<AllJavaTypes> results = looperThreadRealm.where(AllJavaTypes.class).equalTo("fieldId", 1).findAll();
-                    assertNotNull(results);
-                    assertEquals(results.size(), 1);
-                    AllJavaTypes child = results.first();
-
-                    RealmResults<AllJavaTypes> parents = child.getObjectParents();
-                    assertNotNull(parents);
-                    assertEquals(0, parents.size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
-    }
-
     /**
      * Table validation should fail if the backinked column already exists in the target table.
      * The realm `backlinks-fieldInUse.realm` contains the classes `BacklinksSource` and `BacklinksTarget`
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 8e3f499af6..6bd270bab7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -28,7 +28,6 @@
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -799,28 +798,6 @@ public void run() {
         });
     }
 
-    // TODO: Fix or delete this test after integration of object notification from Object Store
-    @Test
-    @RunTestInLooperThread
-    @Ignore
-    public void realmObjectListenerAddedAfterCommit() {
-        Realm realm = looperThread.realm;
-        realm.beginTransaction();
-        AllTypes obj = realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        realm.beginTransaction();
-        obj.setColumnLong(42);
-        realm.commitTransaction();
-
-        obj.addChangeListener(new RealmChangeListener<AllTypes>() {
-            @Override
-            public void onChange(AllTypes object) {
-                looperThread.testComplete();
-            }
-        });
-    }
-
     public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
 
         @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
new file mode 100644
index 0000000000..942e7cb848
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ObjectChangeSetTests.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Dog;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.fail;
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+
+// Tests for detailed change notification on RealmObject.
+@RunWith(AndroidJUnit4.class)
+public class ObjectChangeSetTests {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
+
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            Realm realm = Realm.getInstance(realmConfig);
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    AllTypes allTypes = realm.createObject(AllTypes.class);
+                    allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+                    allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+                }
+            });
+            realm.close();
+        }
+    }
+
+    private void checkDeleted(AllTypes allTypes) {
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                assertEquals(0, changeSet.getChangedFields().length);
+                assertFalse(object.isValid());
+                assertTrue(changeSet.isDeleted());
+                looperThread.testComplete();
+            }
+        });
+        looperThread.keepStrongReference.add(allTypes);
+    }
+
+    private void checkChangedField(AllTypes allTypes, final String... fieldNames) {
+        assertNotNull(fieldNames);
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertEquals(fieldNames.length, changeSet.getChangedFields().length);
+                List<String> changedFields = Arrays.asList(changeSet.getChangedFields());
+                for (String name : fieldNames) {
+                    assertTrue(changeSet.isFieldChanged(name));
+                    assertFalse(changeSet.isFieldChanged(name + "NotThere"));
+                    if (!changedFields.contains(name)) {
+                        fail("Cannot find field " + name + " in field changes.");
+                    }
+                }
+                looperThread.testComplete();
+            }
+        });
+        looperThread.keepStrongReference.add(allTypes);
+    }
+
+    private void listenerShouldNotBeCalled(AllTypes allTypes) {
+        allTypes.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                fail();
+            }
+        });
+        looperThread.postRunnableDelayed(new Runnable() {
+            @Override
+            public void run() {
+                looperThread.testComplete();
+            }
+        }, 100);
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void objectDeleted() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkDeleted(allTypes);
+        realm.beginTransaction();
+        allTypes.deleteFromRealm();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLongField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_LONG);
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeStringField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_STRING);
+        realm.beginTransaction();
+        allTypes.setColumnString("42");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeFloatField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_FLOAT);
+        realm.beginTransaction();
+        allTypes.setColumnFloat(42.0f);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDoubleField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_DOUBLE);
+        realm.beginTransaction();
+        allTypes.setColumnDouble(42.0d);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeBooleanField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_BOOLEAN);
+        realm.beginTransaction();
+        allTypes.setColumnBoolean(true);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeDateField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_DATE);
+        realm.beginTransaction();
+        allTypes.setColumnDate(new Date());
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeBinaryField() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_BINARY);
+        realm.beginTransaction();
+        allTypes.setColumnBinary(new byte[] { 42 });
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldSetNewObject() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldSetNull() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.setColumnRealmObject(null);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldRemoveObject() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMOBJECT);
+        realm.beginTransaction();
+        allTypes.getColumnRealmObject().deleteFromRealm();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkFieldOriginalObjectChanged_notTrigger() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        listenerShouldNotBeCalled(allTypes);
+        realm.beginTransaction();
+        allTypes.getColumnRealmObject().setAge(42);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkListAddObject() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMLIST);
+        realm.beginTransaction();
+        allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeLinkListClear() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_REALMLIST);
+        realm.beginTransaction();
+        allTypes.getColumnRealmList().clear();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void changeAllFields() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        checkChangedField(allTypes, AllTypes.FIELD_LONG, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_REALMOBJECT,
+                AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT, AllTypes.FIELD_STRING, AllTypes.FIELD_BOOLEAN,
+                AllTypes.FIELD_BINARY, AllTypes.FIELD_DATE);
+        realm.beginTransaction();
+        allTypes.setColumnLong(42);
+        allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+        allTypes.setColumnRealmObject(realm.createObject(Dog.class));
+        allTypes.setColumnDouble(42.0d);
+        allTypes.setColumnFloat(42.0f);
+        allTypes.setColumnString("42");
+        allTypes.setColumnBoolean(true);
+        allTypes.setColumnBinary(new byte[] { 42 });
+        allTypes.setColumnDate(new Date());
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void findFirstAsync_changeSetIsNullWhenQueryReturns() {
+        Realm realm = looperThread.realm;
+        AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                assertTrue(object.isValid());
+                assertNull(changeSet);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Due to the fact that Object Store disallow adding notification block inside a transaction, the pending query
+    // for findFirstAsync needs to be executed first then move the listener from collection to the object before begin
+    // transaction.
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void findFirstAsync_queryExecutedByLocalCommit() {
+        Realm realm = looperThread.realm;
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+        final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
+        allTypes.addChangeListener(new RealmObjectChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object, ObjectChangeSet changeSet) {
+                int counter = listenerCounter.getAndIncrement();
+                switch (counter) {
+                    case 0:
+                        assertTrue(object.isValid());
+                        assertNull(changeSet);
+                        break;
+                    case 1:
+                        assertFalse(object.isValid());
+                        assertTrue(changeSet.isDeleted());
+                        assertEquals(0, changeSet.getChangedFields().length);
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
+                }
+            }
+        });
+        realm.beginTransaction();
+        allTypes.deleteFromRealm();
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index a9608250db..44e32c935d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -37,7 +37,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
-import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
@@ -628,10 +627,11 @@ public void onChange(AllTypes object) {
         }
     }
 
-    // Similar UC as #testForceLoadAsync using 'findFirst'.
+    // load should trigger the listener with empty change set.
     @Test
     @RunTestInLooperThread
     public void findFirstAsync_forceLoad() throws Throwable {
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
         Realm Realm = looperThread.realm;
         populateTestRealm(Realm, 10);
         final AllTypes realmResults = Realm.where(AllTypes.class)
@@ -640,10 +640,20 @@ public void findFirstAsync_forceLoad() throws Throwable {
 
         assertFalse(realmResults.isLoaded());
 
+        realmResults.addChangeListener(new RealmObjectChangeListener<RealmModel>() {
+            @Override
+            public void onChange(RealmModel object, ObjectChangeSet changeSet) {
+                assertNull(changeSet);
+                assertFalse(listenerCalled.get());
+                listenerCalled.set(true);
+            }
+        });
+
         assertTrue(realmResults.load());
         assertTrue(realmResults.isLoaded());
         assertEquals("test data 4", realmResults.getColumnString());
 
+        assertTrue(listenerCalled.get());
         looperThread.testComplete();
     }
 
@@ -871,15 +881,76 @@ public void distinctAsync_notIndexedFields() throws Throwable {
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
-            try {
-                realm.where(AnnotationIndexTypes.class).distinctAsync("notIndex" + fieldName);
-                fail("notIndex" + fieldName);
-            } catch (IllegalArgumentException ignored) {
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable changeListenerDone = new Runnable() {
+            final AtomicInteger signalCallbackFinished = new AtomicInteger(4);
+            @Override
+            public void run() {
+                if (signalCallbackFinished.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
             }
-        }
+        };
 
-        looperThread.testComplete();
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(2, distinctBool.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                changeListenerDone.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctString.size());
+                changeListenerDone.run();
+            }
+        });
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 7a5d21a4e5..1e04dca3e3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -1300,7 +1300,7 @@ public void migrationRequired_throwsOriginalException() {
             }
         }
     }
-    
+
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 01745e62f6..2f5a772106 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -48,7 +48,7 @@
     private RealmObjectSchema DOG_SCHEMA;
     private DynamicRealm realm;
     private RealmObjectSchema schema;
-    private RealmSchema realmSchema;
+    private StandardRealmSchema realmSchema;
 
     @Before
     public void setUp() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 4df192b9a3..e5e80ec6b4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -16,13 +16,11 @@
 
 package io.realm;
 
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -32,7 +30,6 @@
 import java.util.Calendar;
 import java.util.Date;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -67,6 +64,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class RealmObjectTests {
 
@@ -1019,9 +1017,9 @@ public void get_set_nonNullValueOnNullableFields() {
         // 3 Boolean
         nullTypes.setFieldBooleanNull(true);
         // 4 Byte
-        nullTypes.setFieldByteNull((byte)42);
+        nullTypes.setFieldByteNull((byte) 42);
         // 5 Short
-        nullTypes.setFieldShortNull((short)42);
+        nullTypes.setFieldShortNull((short) 42);
         // 6 Integer
         nullTypes.setFieldIntegerNull(42);
         // 7 Long
@@ -1042,9 +1040,9 @@ public void get_set_nonNullValueOnNullableFields() {
         // 3 Boolean
         assertTrue(nullTypes.getFieldBooleanNull());
         // 4 Byte
-        assertEquals((byte)42, (byte)nullTypes.getFieldByteNull().intValue());
+        assertEquals((byte) 42, (byte) nullTypes.getFieldByteNull().intValue());
         // 5 Short
-        assertEquals((short)42, (short)nullTypes.getFieldShortNull().intValue());
+        assertEquals((short) 42, (short) nullTypes.getFieldShortNull().intValue());
         // 6 Integer
         assertEquals(42, nullTypes.getFieldIntegerNull().intValue());
         // 7 Long
@@ -1575,37 +1573,40 @@ public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.addChangeListener(null);
+            dog.addChangeListener((RealmChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.addChangeListener((RealmObjectChangeListener) null);
             fail("adding null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        looperThread.testComplete();
     }
 
     @Test
     public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
-        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
-            @Override
-            public void run() throws Exception {
-                final Realm realm = Realm.getInstance(realmConfig);
-                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
-                //noinspection TryFinallyCanBeTryWithResources
-                try {
-                    dog.addChangeListener(null);
-                    fail("adding null change listener must throw an exception.");
-                } catch (IllegalArgumentException ignore) {
-                } finally {
-                    realm.close();
-                }
-            }
-        });
+        try {
+            dog.addChangeListener((RealmChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.addChangeListener((RealmObjectChangeListener) null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
     }
 
     @Test
     @RunTestInLooperThread
-    public void changeListener_triggeredWhenObjectIsdeleted() {
+    public void changeListener_triggeredWhenObjectIsDeleted() {
         final Realm realm = looperThread.realm;
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
@@ -1637,9 +1638,51 @@ public void onChange(Dog object) {
             });
             fail("adding change listener on unmanaged object must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog object, ObjectChangeSet changeSet) {
+                }
+            });
+            fail("adding change listener on unmanaged object must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
+    }
+
+    // Object Store will throw when adding change listener inside a transaction.
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwInsiderTransaction() {
+        Realm realm = looperThread.realm;
+
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        try {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog element) {
+                    fail();
+                }
+            });
+        } catch (IllegalStateException ignored) {
+        }
+
+        try {
+            dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+                @Override
+                public void onChange(Dog object, ObjectChangeSet changeSet) {
+                    fail();
+                }
+            });
+        } catch (IllegalStateException ignored) {
+        }
+        realm.cancelTransaction();
+
+        looperThread.testComplete();
     }
 
     @Test
@@ -1649,32 +1692,61 @@ public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.removeChangeListener(null);
+            dog.removeChangeListener((RealmChangeListener) null);
             fail("removing null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
-        } finally {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.removeChangeListener((RealmObjectChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
     }
 
     @Test
     public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
-        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
-            @Override
-            public void run() throws Exception {
-                final Realm realm = Realm.getInstance(realmConfig);
-                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
-                //noinspection TryFinallyCanBeTryWithResources
-                try {
-                    dog.removeChangeListener(null);
-                    fail("removing null change listener must throw an exception.");
-                } catch (IllegalArgumentException ignore) {
-                } finally {
-                    realm.close();
-                }
+        try {
+            dog.removeChangeListener((RealmChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        try {
+            dog.removeChangeListener((RealmObjectChangeListener) null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_insideTransaction() {
+        Realm realm = looperThread.realm;
+        final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+        RealmChangeListener<Dog> realmChangeListener = new RealmChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog element) {
             }
-        });
+        };
+        RealmObjectChangeListener<Dog> realmObjectChangeListener = new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+            }
+        };
+
+        dog.addChangeListener(realmChangeListener);
+        dog.addChangeListener(realmObjectChangeListener);
+
+        realm.beginTransaction();
+        dog.removeChangeListener(realmChangeListener);
+        dog.removeChangeListener(realmObjectChangeListener);
+        realm.cancelTransaction();
+        looperThread.testComplete();
     }
 
     /**
@@ -1691,7 +1763,13 @@ public void removeAllChangeListeners() {
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                assertTrue(false);
+                fail();
+            }
+        });
+        dog.addChangeListener(new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+                fail();
             }
         });
         dog.removeAllChangeListeners();
@@ -1700,6 +1778,8 @@ public void onChange(Dog object) {
         Dog sameDog = realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 13).findFirst();
         sameDog.setName("Jesper");
         realm.commitTransaction();
+        // Try to trigger the listeners.
+        realm.sharedRealm.refresh();
         looperThread.testComplete();
     }
 
@@ -1712,13 +1792,25 @@ public void removeChangeListener_throwOnUnmanagedObject() {
             public void onChange(Dog object) {
             }
         };
+        RealmObjectChangeListener objectChangeListener = new RealmObjectChangeListener<Dog>() {
+            @Override
+            public void onChange(Dog object, ObjectChangeSet changeSet) {
+            }
+        };
 
         try {
             dog.removeChangeListener(listener);
             fail("Failed to remove a listener from null Realm.");
         } catch (IllegalArgumentException ignore) {
-            looperThread.testComplete();
         }
+
+        try {
+            dog.removeChangeListener(objectChangeListener);
+            fail("Failed to remove a listener from null Realm.");
+        } catch (IllegalArgumentException ignore) {
+        }
+
+        looperThread.testComplete();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 27f6cae43e..53642936a0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -3114,12 +3114,13 @@ public void distinct_notIndexedFields() {
         final long numberOfObjects = 10;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).distinct(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
+                AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index e2ebc99b39..88dd2d6bf5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -267,12 +267,14 @@ public void distinct_notIndexedFields() {
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
+                .findAll().distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+        assertEquals(2, distinctBool.size());
+        for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
+                AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll()
+                    .distinct(field);
+            assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
 
@@ -542,18 +544,81 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+        Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll()
+                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING);
+
+        assertFalse(distinctBool.isLoaded());
+        assertTrue(distinctBool.isValid());
+        assertTrue(distinctBool.isEmpty());
+
+        assertFalse(distinctLong.isLoaded());
+        assertTrue(distinctLong.isValid());
+        assertTrue(distinctLong.isEmpty());
+
+        assertFalse(distinctDate.isLoaded());
+        assertTrue(distinctDate.isValid());
+        assertTrue(distinctDate.isEmpty());
+
+        assertFalse(distinctString.isLoaded());
+        assertTrue(distinctString.isValid());
+        assertTrue(distinctString.isEmpty());
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
+                }
             }
-        }
-        looperThread.testComplete();
+        };
+
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(2, distinctBool.size());
+                endTest.run();
+            }
+        });
+
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctLong.size());
+                endTest.run();
+            }
+        });
+
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctDate.size());
+                endTest.run();
+            }
+        });
+
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(numberOfBlocks, distinctString.size());
+                endTest.run();
+            }
+        });
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index da49a66229..86e5985fc8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -47,7 +47,7 @@
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
     private DynamicRealm realm;
-    private RealmSchema realmSchema;
+    private StandardRealmSchema realmSchema;
 
     @Before
     public void setUp() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 92774d8fee..243ef1c246 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -3690,34 +3690,34 @@ public void run(Realm realm) {
 
     @Test
     public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
-        final CatRealmProxy.CatColumnInfo catColumnInfo;
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.columnIndices.getColumnInfo(Cat.class);
+        final AtomicLong nameIndexNew = new AtomicLong(-1L);
 
+        // get the pre-update index for the "name" column.
+        CatRealmProxy.CatColumnInfo catColumnInfo
+                = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnIndices().getColumnInfo(Cat.class);
         final long nameIndex = catColumnInfo.nameIndex;
-        final AtomicLong nameIndexNew = new AtomicLong(-1L);
 
-        // Changes column index of "name".
+        // Change the index of the column "name".
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
                 final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
                 final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
                 catTable.removeColumn(nameIndex);
-                final long newIndex = catTable.addColumn(RealmFieldType.STRING,
-                        Cat.FIELD_NAME, true);
-
+                final long newIndex = catTable.addColumn(RealmFieldType.STRING, Cat.FIELD_NAME, true);
                 realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
-
                 nameIndexNew.set(newIndex);
             }
         });
+
         // We need to update index cache if the schema version was changed in the same thread.
         realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
 
-        // Checks if the index was changed.
+        // Verify that the index has changed.
         assertNotEquals(nameIndex, nameIndexNew);
 
-        // Checks if index in the ColumnInfo is updated.
+        // Verify that the index in the ColumnInfo has been updated.
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnIndices().getColumnInfo(Cat.class);
         assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
         assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index e3150acf8c..73bf9731c5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -251,21 +251,6 @@ public void callback_should_trigger_for_createObjectFromJson() {
         assumeThat(Build.VERSION.SDK_INT, greaterThanOrEqualTo(Build.VERSION_CODES.HONEYCOMB));
 
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (globalCommitInvocations.incrementAndGet() == 1) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
-
         try {
             InputStream in = TestHelper.loadJsonFromAssets(InstrumentationRegistry.getTargetContext(), "all_simple_types.json");
             realm.beginTransaction();
@@ -283,7 +268,7 @@ public void onChange(AllTypes object) {
                     assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
                     assertEquals(true, objectFromJson.isColumnBoolean());
                     assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
-                    typebasedCommitInvocations.incrementAndGet();
+                    looperThread.testComplete();
                 }
             });
 
@@ -301,20 +286,6 @@ public void onChange(AllTypes object) {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (globalCommitInvocations.incrementAndGet() == 1) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
 
         try {
             JSONObject json = new JSONObject();
@@ -339,7 +310,7 @@ public void onChange(AllTypes object) {
                     assertEquals(1.23D, objectFromJson.getColumnDouble(), 0D);
                     assertEquals(true, objectFromJson.isColumnBoolean());
                     assertArrayEquals(new byte[]{1, 2, 3}, objectFromJson.getColumnBinary());
-                    typebasedCommitInvocations.incrementAndGet();
+                    looperThread.testComplete();
                 }
             });
 
@@ -710,20 +681,6 @@ public void onChange(Dog object) {
     public void multiple_callbacks_should_be_invoked_realmobject_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                looperThread.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
-                        looperThread.testComplete();
-                    }
-                });
-            }
-        };
-
-        realm.addChangeListener(listener);
 
         realm.beginTransaction();
         Dog akamaru = realm.createObject(Dog.class);
@@ -737,6 +694,17 @@ public void run() {
                 @Override
                 public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
+                    if (typebasedCommitInvocations.get() > NUMBER_OF_LISTENERS) {
+                        fail();
+                    } else if (typebasedCommitInvocations.get() == NUMBER_OF_LISTENERS) {
+                        // Delayed post in case the listener gets triggered more time than expected.
+                        looperThread.postRunnableDelayed(new Runnable() {
+                            @Override
+                            public void run() {
+                                looperThread.testComplete();
+                            }
+                        }, 500);
+                    }
                 }
             });
         }
@@ -832,20 +800,6 @@ public void onChange(RealmResults<Dog> object) {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_sync() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                if (realm.where(Dog.class).count() == 2) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(1, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
 
         realm.beginTransaction();
         realm.createObject(Dog.class);
@@ -856,92 +810,56 @@ public void run() {
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                typebasedCommitInvocations.incrementAndGet();
+                assertEquals(17, object.getAge());
+                looperThread.testComplete();
             }
         });
 
-        Thread thread = new Thread() {
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-                bgRealm.beginTransaction();
-                bgRealm.createObject(Dog.class);
-                bgRealm.commitTransaction();
-                bgRealm.close();
+            public void execute(Realm realm) {
+                realm.where(Dog.class).findFirst().setAge(17);
             }
-        };
-        thread.start();
-        try {
-            thread.join();
-        } catch (InterruptedException e) {
-            fail(e.getMessage());
-        }
+        });
     }
 
     // UC 3 Async RealmObject.
     // 1. Creates RealmObject async query.
-    // 2. Waits COMPLETED_ASYNC_REALM_OBJECT then commits transaction in another non-looper thread.
+    // 2. Waits async returns then change the object.
     // 3. Listener on the RealmObject gets triggered again.
     @Test
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_async() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                // Checks if the 2nd transaction is committed.
-                if (realm.where(Dog.class).count() == 2) {
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            assertEquals(2, typebasedCommitInvocations.get());
-                            looperThread.testComplete();
-                        }
-                    });
-                }
-            }
-        });
 
         realm.beginTransaction();
-        realm.createObject(Dog.class);
+        realm.createObject(Dog.class).setAge(1);
         realm.commitTransaction();
 
-        final Thread thread = new Thread() {
-            @Override
-            public void run() {
-                if (typebasedCommitInvocations.get() != 1) {
-                    try {
-                        Thread.sleep(200);
-                    } catch (InterruptedException e) {
-                        fail(e.getMessage());
-                    }
-                }
-                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
-                bgRealm.beginTransaction();
-                bgRealm.createObject(Dog.class);
-                bgRealm.commitTransaction();
-                bgRealm.close();
-            }
-        };
-
         Dog dog = realm.where(Dog.class).findFirstAsync();
         looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                typebasedCommitInvocations.incrementAndGet();
-
-                if (typebasedCommitInvocations.get() == 1) {
-                    try {
-                        thread.join();
-                    } catch (InterruptedException e) {
-                        fail(e.getMessage());
-                    }
+                switch (typebasedCommitInvocations.incrementAndGet()) {
+                    case 1:
+                        assertEquals(1, object.getAge());
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.where(Dog.class).findFirst().setAge(17);
+                            }
+                        });
+                        break;
+                    case 2:
+                        assertEquals(17, object.getAge());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
                 }
             }
         });
-
-        thread.start();
     }
 
     // UC 3 Sync RealmResults.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index cbf00b2ceb..e04e8b4d4f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -242,7 +242,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         table2.addSearchIndex(column2);
         try {
             table2.setPrimaryKey(column2);
-        } catch (RealmError ignored) {
+        } catch (IllegalStateException ignored) {
             // Column has no search index.
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index b5c26f71fd..1212415ce0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -120,16 +120,6 @@ public void getInstanceForDistinct_multipleFields() {
         assertEquals(intColumn, sortDescriptor.getColumnIndices()[1][0]);
     }
 
-    @Test
-    public void getInstanceForDistinct_shouldThrowIfNoSearchIndex() {
-        RealmFieldType type = RealmFieldType.STRING;
-        table.addColumn(type, type.name());
-
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("must be indexed");
-        SortDescriptor.getInstanceForDistinct(table, type.name());
-    }
-
     @Test
     public void getInstanceForDistinct_shouldThrowOnInvalidField() {
         List<RealmFieldType> types = new ArrayList<RealmFieldType>();
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
new file mode 100644
index 0000000000..22c31bc2a5
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressTests {
+
+    @Test
+    public void getFractionTransferred() {
+        Object[][] testData = {
+            { 0L, 0L, 1.0D },
+            { 0L, 1L, 0.0D },
+            { 1L, 1L, 1.0D },
+            { 1L, 2L, 0.5D }
+        };
+
+        for (Object[] test : testData) {
+            long transferredBytes = (long) test[0];
+            long transferableBytes = (long) test[1];
+            double fraction = (double) test[2];
+            Progress progress = new Progress(transferredBytes, transferableBytes);
+            String errorMessage = String.format(Locale.US, "Failed with: (%d, %d)", transferredBytes, transferableBytes);
+            assertEquals(errorMessage, fraction, progress.getFractionTransferred(), 0.0D);
+        }
+    }
+
+    @Test
+    public void getTransferredBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferredBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferredBytes);
+            Progress progress = new Progress(transferredBytes, Long.MAX_VALUE);
+            assertEquals(errorMessage, transferredBytes, progress.getTransferredBytes());
+        }
+    }
+
+    @Test
+    public void getTransferableBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferableBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferableBytes);
+            Progress progress = new Progress(0, transferableBytes);
+            assertEquals(errorMessage, transferableBytes, progress.getTransferableBytes());
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 2c53ce2bd5..3376d0a512 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -61,6 +61,54 @@ public void get_syncValues() {
         assertEquals(configuration, session.getConfiguration());
     }
 
+    @Test
+    public void addDownloadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void addUploadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void removeProgressListener() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        ProgressListener[] listeners = new ProgressListener[] {
+                null,
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 1, not present
+                    }
+                },
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 2, present
+                    }
+                }
+        };
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);
+
+        // Check that remove works unconditionally for all input
+        for (ProgressListener listener : listeners) {
+            session.removeProgressListener(listener);
+        }
+        realm.close();
+    }
+
     // Check that a Client Reset is correctly reported.
     @Test
     @RunTestInLooperThread
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 0b64588552..96b1eec789 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -36,9 +36,10 @@ set(classes_LIST
     io.realm.internal.Table io.realm.internal.CheckedRow
     io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
-    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.RealmSchema
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.OsRealmSchema
     io.realm.RealmObjectSchema io.realm.internal.Collection
     io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
+    io.realm.internal.OsObject
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
@@ -86,23 +87,25 @@ add_library(lib_realm_core STATIC IMPORTED)
 set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH}
                                                 IMPORTED_LINK_INTERFACE_LIBRARIES atomic)
 
-# Sync static library
-set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
-# Workaround for old core's funny ABI nicknames
-if (NOT EXISTS ${sync_lib_PATH})
-    if (ARMEABI)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
-    elseif (ARMEABI_V7A)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
-    elseif (ARM64_V8A)
-        set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
-    else()
-        message(FATAL_ERROR "Cannot find core lib file: ${sync_lib_PATH}")
+if (build_SYNC)
+    # Sync static library
+    set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
+    # Workaround for old core's funny ABI nicknames
+    if (NOT EXISTS ${sync_lib_PATH})
+        if (ARMEABI)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
+        elseif (ARMEABI_V7A)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
+        elseif (ARM64_V8A)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
+        else()
+            message(FATAL_ERROR "Cannot find sync lib file: ${sync_lib_PATH}")
+        endif()
     endif()
+    add_library(lib_realm_sync STATIC IMPORTED)
+    set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
+                                                    IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 endif()
-add_library(lib_realm_sync STATIC IMPORTED)
-set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
-                                                IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
 
 # build application's shared lib
 include_directories(${REALM_CORE_DIST_DIR}/include
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
similarity index 86%
rename from realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
rename to realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
index 7bc774c51c..5d78cae226 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmSchema.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <jni.h>
-#include "io_realm_RealmSchema.h"
+#include "io_realm_OsRealmSchema.h"
 
 #include <object-store/src/schema.hpp>
 #include <object-store/src/object_schema.hpp>
@@ -25,7 +25,7 @@
 using namespace realm;
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_OsRealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
                                                                        jlongArray objectSchemaPtrs_)
 {
     TR_ENTER()
@@ -43,14 +43,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_RealmSchema_nativeCreateFromList(JNIEnv* e
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_RealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
+JNIEXPORT void JNICALL Java_io_realm_OsRealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     Schema* schema = reinterpret_cast<Schema*>(nativePtr);
     delete schema;
 }
 
-JNIEXPORT jlongArray JNICALL Java_io_realm_RealmSchema_nativeGetAll(JNIEnv* env, jclass, jlong nativePtr)
+JNIEXPORT jlongArray JNICALL Java_io_realm_OsRealmSchema_nativeGetAll(JNIEnv* env, jclass, jlong nativePtr)
 {
     TR_ENTER_PTR(nativePtr)
     try {
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index e3a58bbad2..88e80e151f 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <jni.h>
+#include <string>
 
 #include "io_realm_SyncSession.h"
 
@@ -22,22 +23,22 @@
 #include "object-store/src/sync/sync_session.hpp"
 
 #include "util.hpp"
+#include "jni_util/jni_utils.hpp"
 
-using namespace std;
 using namespace realm;
 using namespace sync;
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
-                                                                              jstring localRealmPath,
-                                                                              jstring accessToken,
+                                                                              jstring j_local_realm_path,
+                                                                              jstring j_access_token,
                                                                               jstring sync_realm_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor local_realm_path(env, localRealmPath);
+        JStringAccessor local_realm_path(env, j_local_realm_path);
         auto session = SyncManager::shared().get_existing_session(local_realm_path);
         if (session) {
-            JStringAccessor access_token(env, accessToken);
+            JStringAccessor access_token(env, j_access_token);
             JStringAccessor realm_url(env, sync_realm_url);
             session->refresh_access_token(access_token, std::string(realm_url));
             return JNI_TRUE;
@@ -49,3 +50,67 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JN
     CATCH_STD()
     return JNI_FALSE;
 }
+
+
+JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIEnv* env, jclass,
+                                                                            jstring j_local_realm_path,
+                                                                            jlong listener_id, jint direction,
+                                                                            jboolean is_streaming)
+{
+    try {
+        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
+        realm::StringData local_realm_path(JStringAccessor(env, j_local_realm_path));
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (!session) {
+            // FIXME: We should lift this restriction
+            ThrowException(env, IllegalState,
+                           "Cannot register a progress listener before a session is "
+                           "created. A session will be created after the first call to Realm.getInstance().");
+            return static_cast<jlong>(0);
+        }
+
+        SyncSession::NotifierType type =
+            (direction == 1) ? SyncSession::NotifierType::download : SyncSession::NotifierType::upload;
+
+        std::function<SyncProgressNotifierCallback> callback = [local_realm_path, listener_id](
+            uint64_t transferred, uint64_t transferrable) {
+            JNIEnv* local_env = jni_util::JniUtils::get_env(true);
+
+            auto path = to_jstring(local_env, local_realm_path);
+            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path, listener_id,
+                                            static_cast<jlong>(transferred), static_cast<jlong>(transferrable));
+
+            // All exceptions will be caught on the Java side of handlers, but errors will still end
+            // up here, so we need to do something sensible with them.
+            // Throwing a C++ exception will terminate the sync thread and cause the pending Java
+            // exception to become visible. For some (unknown) reason Logcat will not see the C++
+            // exception, only the Java one.
+            if (local_env->ExceptionCheck()) {
+                local_env->ExceptionDescribe();
+                throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
+            }
+
+            // Callback happens on a thread not controlled by the JVM. So manual cleanup is
+            // required.
+            local_env->DeleteLocalRef(path);
+        };
+        uint64_t token = session->register_progress_notifier(callback, type, to_bool(is_streaming));
+        return static_cast<jlong>(token);
+    }
+    CATCH_STD()
+    return static_cast<jlong>(0);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveProgressListener(JNIEnv* env, jclass,
+                                                                              jstring j_local_realm_path,
+                                                                              jlong listener_token)
+{
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (session) {
+            session->unregister_progress_notifier(static_cast<uint64_t>(listener_token));
+        }
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
new file mode 100644
index 0000000000..abe2e666d3
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsObject.h"
+
+#include <realm/row.hpp>
+#include <object_schema.hpp>
+#include <object.hpp>
+
+#include "util.hpp"
+
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+
+// We need to control the life cycle of Object, weak ref of Java OsObject and the NotificationToken.
+// Wrap all three together, so when the Java object gets GCed, all three of them will be invalidated.
+struct ObjectWrapper {
+    JavaGlobalWeakRef m_row_object_weak_ref;
+    NotificationToken m_notification_token;
+    realm::Object m_object;
+
+    ObjectWrapper(realm::Object& object)
+        : m_row_object_weak_ref()
+        , m_notification_token()
+        , m_object(std::move(object))
+    {
+    }
+
+    ObjectWrapper(ObjectWrapper&&) = delete;
+    ObjectWrapper& operator=(ObjectWrapper&&) = delete;
+
+    ObjectWrapper(ObjectWrapper const&) = delete;
+    ObjectWrapper& operator=(ObjectWrapper const&) = delete;
+
+    ~ObjectWrapper()
+    {
+    }
+};
+
+struct ChangeCallback {
+    ChangeCallback(ObjectWrapper* wrapper)
+        : m_wrapper(wrapper)
+    {
+    }
+
+    void parse_fields(JNIEnv* env, CollectionChangeSet const& change_set)
+    {
+        if (m_field_names_array) {
+            return;
+        }
+
+        if (!change_set.deletions.empty()) {
+            m_deleted = true;
+            return;
+        }
+
+        std::vector<jstring> field_names;
+        auto table = m_wrapper->m_object.row().get_table();
+        for (size_t i = 0; i < change_set.columns.size(); ++i) {
+            if (change_set.columns[i].empty()) {
+                continue;
+            }
+            // FIXME: After full integration of the OS schema, parse the column name from
+            // wrapper->m_object.get_object_schema() will be faster.
+            field_names.push_back(to_jstring(env, table->get_column_name(i)));
+        }
+        m_field_names_array = env->NewObjectArray(field_names.size(), java_lang_string, 0);
+        for (size_t i = 0; i < field_names.size(); ++i) {
+            env->SetObjectArrayElement(m_field_names_array, i, field_names[i]);
+        }
+    }
+
+    JNIEnv* check_env()
+    {
+        JNIEnv* env = JniUtils::get_env(false);
+        if (!env || env->ExceptionCheck()) {
+            // JVM detached or java exception has been thrown before.
+            return nullptr;
+        }
+        return env;
+    }
+
+    void before(CollectionChangeSet const& change_set)
+    {
+        JNIEnv* env = check_env();
+        if (!env) {
+            return;
+        }
+
+        parse_fields(env, change_set);
+    }
+
+    void after(CollectionChangeSet const& change_set)
+    {
+        JNIEnv* env = check_env();
+        if (!env) {
+            return;
+        }
+        if (change_set.empty()) {
+            return;
+        }
+
+        parse_fields(env, change_set);
+
+        m_wrapper->m_row_object_weak_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
+            static JavaMethod notify_change_listeners(env, row_obj, "notifyChangeListeners",
+                                                      "([Ljava/lang/String;)V");
+            env->CallVoidMethod(row_obj, notify_change_listeners, m_field_names_array);
+        });
+    }
+
+    void error(std::exception_ptr err)
+    {
+        if (err) {
+            try {
+                std::rethrow_exception(err);
+            }
+            catch (const std::exception& e) {
+                Log::e("Caught exception in object change callback %1", e.what());
+            }
+        }
+    }
+
+private:
+    ObjectWrapper* m_wrapper;
+    bool m_deleted = false;
+    jobjectArray m_field_names_array = nullptr;
+};
+
+static void finalize_object(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<ObjectWrapper*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_object);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreate(JNIEnv*, jclass, jlong shared_realm_ptr,
+                                                                      jlong row_ptr)
+{
+    TR_ENTER_PTR(row_ptr)
+
+    // FIXME: Currently OsObject is only used for object notifications. Since the Object Store's schema has not been
+    // fully integrated with realm-java, we pass a dummy ObjectSchema to create Object.
+    static const ObjectSchema dummy_object_schema;
+
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& row = *(reinterpret_cast<Row*>(row_ptr));
+    Object object(shared_realm, dummy_object_schema, row); // no throw
+    auto wrapper = new ObjectWrapper(object);              // no throw
+
+    return reinterpret_cast<jlong>(wrapper);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStartListening(JNIEnv* env, jobject instance,
+                                                                             jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ObjectWrapper*>(native_ptr);
+        if (!wrapper->m_row_object_weak_ref) {
+            wrapper->m_row_object_weak_ref = JavaGlobalWeakRef(env, instance);
+        }
+
+        // The wrapper pointer will be used in the callback. But it should never become an invalid pointer when the
+        // notification block gets called. This should be guaranteed by the Object Store that after the notification
+        // token is destroyed, the block shouldn't be called.
+        wrapper->m_notification_token = wrapper->m_object.add_notification_block(ChangeCallback(wrapper));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ObjectWrapper*>(native_ptr);
+        wrapper->m_notification_token = {};
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 48e47cf726..7946856b1c 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -53,6 +53,10 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
         java_util_date = GetClass(env, "java/util/Date");
         java_util_date_init = env->GetMethodID(java_util_date, "<init>", "(J)V");
+#if REALM_ENABLE_SYNC
+        java_syncmanager_class = GetClass(env, "io/realm/SyncManager");
+        java_notify_progress_listener = env->GetStaticMethodID(java_syncmanager_class, "notifyProgressListener", "(Ljava/lang/String;JJJ)V");
+#endif
     }
 
     return JNI_VERSION_1_6;
@@ -70,6 +74,9 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
         env->DeleteGlobalRef(java_lang_double);
         env->DeleteGlobalRef(java_util_date);
         env->DeleteGlobalRef(java_lang_string);
+        #if REALM_ENABLE_SYNC
+            env->DeleteGlobalRef(java_syncmanager_class);
+        #endif
         JniUtils::release();
     }
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 283c948fba..f29c5a3335 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -29,8 +29,7 @@ static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 // Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
 // DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
 // program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap
-// it
-// because the size of local reference table is relative small (512 bytes on Android).
+// it because the size of local reference table is relative small (512 bytes on Android).
 template <typename T>
 class JavaLocalRef {
 public:
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 14c2c7e703..3eada170f3 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 14c2c7e7038850302f60f6fa1e36a22bceb3ab94
+Subproject commit 3eada170f380174992b47b6023f375f3f372a9d2
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 75e2598b12..8908d1ae3e 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -43,6 +43,10 @@ jclass java_lang_string;
 jmethodID java_lang_double_init;
 jclass java_util_date;
 jmethodID java_util_date_init;
+#if REALM_ENABLE_SYNC
+jclass java_syncmanager_class;
+jmethodID java_notify_progress_listener;
+#endif
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
@@ -106,6 +110,9 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
     }
+    catch (realm::LogicError e) {
+        ThrowException(env, IllegalState, e.what());
+    }
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
     }
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index c0ec632f62..615887dfa7 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -703,6 +703,10 @@ extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
 extern jclass java_util_date;
 extern jmethodID java_util_date_init;
+#if REALM_ENABLE_SYNC
+extern jclass java_syncmanager_class;
+extern jmethodID java_notify_progress_listener;
+#endif
 
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index f3fc9a16b4..acae142705 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -68,10 +68,10 @@
     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
-    protected RealmConfiguration configuration;
+    protected final RealmConfiguration configuration;
     protected SharedRealm sharedRealm;
 
-    RealmSchema schema;
+    protected final StandardRealmSchema schema;
 
     protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
@@ -85,7 +85,7 @@ public void onSchemaVersionChanged(long currentVersion) {
                                 RealmCache.updateSchemaCache((Realm) BaseRealm.this);
                             }
                         }, true);
-        this.schema = new RealmSchema(this);
+        this.schema = new StandardRealmSchema(this);
     }
 
     /**
@@ -464,7 +464,7 @@ void setVersion(long version) {
      *
      * @return The {@link RealmSchema} for this Realm.
      */
-    public RealmSchema getSchema() {
+    public StandardRealmSchema getSchema() {
         return schema;
     }
 
@@ -481,8 +481,6 @@ public RealmSchema getSchema() {
             result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
                     false, Collections.<String>emptyList());
         }
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setTableVersion$realm();
         return result;
     }
 
@@ -491,8 +489,6 @@ public RealmSchema getSchema() {
         UncheckedRow row = table.getUncheckedRow(rowIndex);
         E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
                 acceptDefaultValue, excludeFields);
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setTableVersion$realm();
         return result;
     }
 
@@ -515,11 +511,6 @@ public RealmSchema getSchema() {
                     schema.getColumnInfo(clazz), false, Collections.<String>emptyList());
         }
 
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
-        if (rowIndex != Table.NO_MATCH) {
-            proxy.realmGet$proxyState().setTableVersion$realm();
-        }
-
         return result;
     }
 
@@ -651,6 +642,10 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
+    public SharedRealm getSharedRealm() {
+        return sharedRealm;
+    }
+
     // Internal delegate for migrations.
     protected interface MigrationCallback {
         void migrationComplete();
@@ -672,7 +667,7 @@ public void set(BaseRealm realm, Row row, ColumnInfo columnInfo,
             this.excludeFields = excludeFields;
         }
 
-        public BaseRealm getRealm() {
+        BaseRealm getRealm() {
             return realm;
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 862255f0b5..0d1d518201 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -344,7 +344,7 @@ public DynamicRealmObject getObject(String fieldName) {
         try {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
             String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-            return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
+            return new RealmList<>(className, linkView, proxyState.getRealm$realm());
         } catch (IllegalArgumentException e) {
             checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
             throw e;
@@ -713,7 +713,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
             typeValidated = false;
         } else {
             String listType = list.className != null ? list.className
-                    : Table.tableNameToClassName(proxyState.getRealm$realm().schema.getTable(list.clazz).getName());
+                    : Table.tableNameToClassName(proxyState.getRealm$realm().getSchema().getTable(list.clazz).getName());
             if (!linkTargetTableName.equals(listType)) {
                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                         "The elements in the list are not the proper type. " +
diff --git a/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java b/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java
new file mode 100644
index 0000000000..1c5277c903
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ObjectChangeSet.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Information about the changes made to an object.
+ *
+ * @see RealmObject#addChangeListener(RealmObjectChangeListener) .
+ */
+public interface ObjectChangeSet {
+
+    /**
+     * @return true if the object has been deleted from the Realm.
+     */
+    boolean isDeleted();
+
+    /**
+     * @return the names of changed fields if the object still exists and there are field changes. Returns an empty
+     * {@code String[]} if the object has been deleted.
+     */
+    String[] getChangedFields();
+
+    /**
+     * Checks if a given field has been changed.
+     *
+     * @param fieldName to be checked if its value has been changed.
+     * @return {@code true} if the field has been changed. It returns {@code false} if the object is deleted, the field
+     * cannot be found or the field hasn't been changed.
+     */
+    boolean isFieldChanged(String fieldName);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
new file mode 100644
index 0000000000..9b7e100d95
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * Class for interacting with the Realm schema using a dynamic API. This makes it possible
+ * to add, delete and change the classes in the Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
+ *
+ * @see RealmMigration
+ */
+class OsRealmSchema extends RealmSchema {
+    static final class Creator extends RealmSchema {
+        private final Map<String, RealmObjectSchema> schema = new HashMap<>();
+
+        @Override
+        public void close() { }
+
+        @Override
+        public RealmObjectSchema get(String className) {
+            checkEmpty(className);
+            return (!contains(className)) ? null : schema.get(className);
+        }
+
+        @Override
+        public Set<RealmObjectSchema> getAll() {
+            return new LinkedHashSet<>(schema.values());
+        }
+
+        @Override
+        public RealmObjectSchema create(String className) {
+            checkEmpty(className);
+            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+            schema.put(className, realmObjectSchema);
+            return realmObjectSchema;
+        }
+
+        @Override
+        public boolean contains(String className) {
+            return schema.containsKey(className);
+        }
+    }
+
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    private final long nativePtr;
+
+    OsRealmSchema(Creator creator) {
+        Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
+        long[] schemaNativePointers = new long[realmObjectSchemas.size()];
+        int i = 0;
+        for (RealmObjectSchema schema : realmObjectSchemas) {
+            schemaNativePointers[i++] = schema.getNativePtr();
+        }
+        this.nativePtr = nativeCreateFromList(schemaNativePointers);
+    }
+
+    public long getNativePtr() {
+        return this.nativePtr;
+    }
+
+    // THIS IS NEVER CALLED!
+    // See BaseRealm uses a StandardRealmSchema, not a OsRealmSchema.
+    @Override
+    public void close() {
+        Set<RealmObjectSchema> schemas = getAll();
+        for (RealmObjectSchema schema : schemas) {
+            schema.close();
+        }
+        nativeClose(nativePtr);
+    }
+
+    /**
+     * Returns the Realm schema for a given class.
+     *
+     * @param className name of the class
+     * @return schema object for that class or {@code null} if the class doesn't exists.
+     */
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className);
+        return (!contains(className)) ? null : dynamicClassToSchema.get(className);
+    }
+
+    /**
+     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     *
+     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
+     */
+    @Override
+    public Set<RealmObjectSchema> getAll() {
+        long[] ptrs = nativeGetAll(nativePtr);
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(ptrs.length);
+        for (int i = 0; i < ptrs.length; i++) {
+            schemas.add(new RealmObjectSchema(ptrs[i]));
+        }
+        return schemas;
+    }
+
+    /**
+     * Adds a new class to the Realm.
+     *
+     * @param className name of the class.
+     * @return a Realm schema object for that class.
+     */
+    @Override
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkEmpty(className);
+        RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
+        dynamicClassToSchema.put(className, realmObjectSchema);
+        return realmObjectSchema;
+    }
+
+    /**
+     * Checks if a given class already exists in the schema.
+     *
+     * @param className class name to check.
+     * @return {@code true} if the class already exists. {@code false} otherwise.
+     */
+    @Override
+    public boolean contains(String className) {
+        return dynamicClassToSchema.containsKey(className);
+    }
+
+    static void checkEmpty(String str) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    static native long nativeCreateFromList(long[] objectSchemaPtrs);
+
+    static native void nativeClose(long nativePtr);
+
+    static native long[] nativeGetAll(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 74b72fb127..58ef76c7ec 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -17,11 +17,11 @@
 package io.realm;
 
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
 
-import io.realm.internal.InvalidRow;
+import io.realm.internal.ObserverPairList;
 import io.realm.internal.PendingRow;
 import io.realm.internal.Row;
+import io.realm.internal.OsObject;
 import io.realm.internal.UncheckedRow;
 
 
@@ -30,18 +30,57 @@
  * {@link RealmObject} and {@link DynamicRealmObject}.
  */
 public final class ProxyState<E extends RealmModel> implements PendingRow.FrontEnd {
+
+    static class RealmChangeListenerWrapper<T extends RealmModel> implements RealmObjectChangeListener<T> {
+        private final RealmChangeListener<T> listener;
+
+        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            if (listener == null) {
+                throw new IllegalArgumentException("Listener should not be null");
+            }
+            this.listener = listener;
+        }
+
+        @Override
+        public void onChange(T object, ObjectChangeSet changes) {
+            listener.onChange(object);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof RealmChangeListenerWrapper &&
+                    listener == ((RealmChangeListenerWrapper) obj).listener;
+        }
+
+        @Override
+        public int hashCode() {
+            return listener.hashCode();
+        }
+    }
+
+    private static class QueryCallback implements ObserverPairList.Callback<OsObject.ObjectObserverPair> {
+
+        @Override
+        public void onCalled(OsObject.ObjectObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange((RealmModel) observer, null);
+        }
+    }
+
     private E model;
 
     // true only while executing the constructor of the enclosing proxy object
     private boolean underConstruction = true;
 
     private Row row;
+    private OsObject osObject;
     private BaseRealm realm;
     private boolean acceptDefaultValue;
     private List<String> excludeFields;
 
-    private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
-    protected long currentTableVersion = -1;
+    private ObserverPairList<OsObject.ObjectObserverPair> observerPairs =
+            new ObserverPairList<OsObject.ObjectObserverPair>();
+    private static QueryCallback queryCallback = new QueryCallback();
 
     public ProxyState() {}
 
@@ -84,44 +123,34 @@ public ProxyState(E model) {
     /**
      * Notifies all registered listeners.
      */
-    private void notifyChangeListeners() {
-        if (!listeners.isEmpty()) {
-            for (RealmChangeListener<E> listener : listeners) {
-                if (realm.sharedRealm == null || realm.sharedRealm.isClosed()) {
-                    return;
-                }
-                listener.onChange(model);
-            }
-        }
+    private void notifyQueryFinished() {
+        observerPairs.foreach(queryCallback);
     }
 
-    public void addChangeListener(RealmChangeListener<E> listener) {
-        if (!listeners.contains(listener)) {
-            listeners.add(listener);
-        }
-        // this might be called after query returns. So it is still necessary to register.
-        if (row instanceof UncheckedRow) {
-            registerToRealmNotifier();
+    public void addChangeListener(RealmObjectChangeListener<E> listener) {
+        if (row instanceof PendingRow) {
+            observerPairs.add(new OsObject.ObjectObserverPair<E>(model, listener));
+        } else if (row instanceof UncheckedRow) {
+            registerToObjectNotifier();
+            if (osObject != null) {
+                osObject.addListener(model, listener);
+            }
         }
     }
 
-    public void removeChangeListener(RealmChangeListener<E> listener) {
-        listeners.remove(listener);
-        if (listeners.isEmpty() && row instanceof UncheckedRow) {
-            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
+    public void removeChangeListener(RealmObjectChangeListener<E> listener) {
+        if (osObject != null) {
+            osObject.removeListener(model, listener);
+        } else {
+            observerPairs.remove(model, listener);
         }
     }
 
     public void removeAllChangeListeners() {
-        listeners.clear();
-        if (row instanceof UncheckedRow) {
-            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
-        }
-    }
-
-    public void setTableVersion$realm() {
-        if (row.getTable() != null) {
-            currentTableVersion = row.getTable().getVersion();
+        if (osObject != null) {
+            osObject.removeListener(model);
+        } else {
+            observerPairs.clear();
         }
     }
 
@@ -135,25 +164,17 @@ public void setConstructionFinished() {
         excludeFields = null;
     }
 
-    private void registerToRealmNotifier() {
+    private void registerToObjectNotifier() {
         if (realm.sharedRealm == null || realm.sharedRealm.isClosed() || !row.isAttached()) {
             return;
         }
 
-        realm.sharedRealm.realmNotifier.addChangeListener(this, new RealmChangeListener<ProxyState<E>>() {
-            @Override
-            public void onChange(ProxyState<E> element) {
-                long tableVersion = -1;
-                if (row.isAttached()) {
-                    // If the Row gets detached, table version will be -1 and it is different from current value.
-                    tableVersion = row.getTable().getVersion();
-                }
-                if (currentTableVersion != tableVersion) {
-                    currentTableVersion = tableVersion;
-                    notifyChangeListeners();
-                }
-            }
-        });
+        if (osObject == null) {
+            osObject = new OsObject(realm.sharedRealm, (UncheckedRow) row);
+            osObject.setObserverPairs(observerPairs);
+            // We should never need observerPairs after pending row returns.
+            observerPairs = null;
+        }
     }
 
     public boolean isLoaded() {
@@ -162,22 +183,17 @@ public boolean isLoaded() {
 
     public void load() {
         if (row instanceof PendingRow) {
-            row = ((PendingRow) row).executeQuery();
-            if (!(row instanceof InvalidRow)) {
-                registerToRealmNotifier();
-            }
-            notifyChangeListeners();
+            ((PendingRow) row).executeQuery();
         }
     }
 
     @Override
     public void onQueryFinished(Row row) {
         this.row = row;
-        notifyChangeListeners();
+        // getTable should return a non-null table since the row should always be valid here.
+        notifyQueryFinished();
         if (row.isAttached()) {
-            // getTable should return a non-null table since the row should always be valid here.
-            currentTableVersion = row.getTable().getVersion();
-            registerToRealmNotifier();
+            registerToObjectNotifier();
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 49604bb690..857ec5f406 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -293,7 +293,7 @@ private static Realm createAndValidate(RealmConfiguration configuration, ColumnI
 
         if (columnIndices != null) {
             // Copies global cache as a Realm local indices cache.
-            realm.schema.columnIndices = columnIndices.clone();
+            realm.schema.setColumnIndices(columnIndices);
         } else {
             final boolean syncingConfig = configuration.isSyncConfiguration();
 
@@ -355,8 +355,9 @@ private static void initializeRealm(Realm realm) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.schema.columnIndices = new ColumnIndices(
-                    (unversioned) ? realm.configuration.getSchemaVersion() : currentVersion, columnInfoMap);
+            realm.schema.setColumnIndices(
+                    (unversioned) ? realm.configuration.getSchemaVersion() : currentVersion,
+                    columnInfoMap);
 
             if (unversioned) {
                 final Transaction transaction = realm.configuration.getInitialDataTransaction();
@@ -388,23 +389,24 @@ private static void initializeSyncedRealm(Realm realm) {
             final RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
 
-            final ArrayList<RealmObjectSchema> realmObjectSchemas = new ArrayList<>();
-            final RealmSchema realmSchemaCache = new RealmSchema();
+            final OsRealmSchema.Creator schemaCreator = new OsRealmSchema.Creator();
             for (Class<? extends RealmModel> modelClass : modelClasses) {
-                RealmObjectSchema realmObjectSchema = mediator.createRealmObjectSchema(modelClass, realmSchemaCache);
-                realmObjectSchemas.add(realmObjectSchema);
+                mediator.createRealmObjectSchema(modelClass, schemaCreator);
             }
 
             // Assumption: When SyncConfiguration then additive schema update mode.
-            final RealmSchema schema = new RealmSchema(realmObjectSchemas);
+            final OsRealmSchema schema = new OsRealmSchema(schemaCreator);
             long newVersion = realm.configuration.getSchemaVersion();
-            if (realm.sharedRealm.requiresMigration(schema)) {
+            // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
+            // It absolutely breaks encapsulation and needs to be fixed!
+            long schemaNativePointer = schema.getNativePtr();
+            if (realm.sharedRealm.requiresMigration(schemaNativePointer)) {
                 if (currentVersion >= newVersion) {
                     throw new IllegalArgumentException(String.format("The schema was changed but the schema version " +
                             "was not updated. The configured schema version (%d) must be higher than the one in the Realm " +
                             "file (%d) in order to update the schema.", newVersion, currentVersion));
                 }
-                realm.sharedRealm.updateSchema(schema, newVersion);
+                realm.sharedRealm.updateSchema(schemaNativePointer, newVersion);
                 // The OS currently does not handle setting the schema version. We have to do it manually.
                 realm.setVersion(newVersion);
                 commitChanges = true;
@@ -415,7 +417,7 @@ private static void initializeSyncedRealm(Realm realm) {
                 columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
 
-            realm.schema.columnIndices = new ColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
+            realm.getSchema().setColumnIndices((unversioned) ? newVersion : currentVersion, columnInfoMap);
 
             if (unversioned) {
                 final Transaction transaction = realm.configuration.getInitialDataTransaction();
@@ -601,7 +603,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) {
         if (clazz == null || in == null) {
             return;
         }
@@ -809,7 +811,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException {
+    public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) {
         if (clazz == null || in == null) {
             return null;
         }
@@ -974,10 +976,10 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects) {
         if (objects == null) {
-            return new ArrayList<E>();
+            return new ArrayList<>();
         }
-        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
-        ArrayList<E> realmObjects = new ArrayList<E>();
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
+        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, false, cache));
@@ -1050,7 +1052,7 @@ public void insert(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<>();
         configuration.getSchemaMediator().insert(this, object, cache);
     }
 
@@ -1120,7 +1122,7 @@ public void insertOrUpdate(RealmModel object) {
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
-        Map<RealmModel, Long> cache = new HashMap<RealmModel, Long>();
+        Map<RealmModel, Long> cache = new HashMap<>();
         configuration.getSchemaMediator().insertOrUpdate(this, object, cache);
     }
 
@@ -1139,11 +1141,11 @@ public void insertOrUpdate(RealmModel object) {
      */
     public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
         if (objects == null) {
-            return new ArrayList<E>(0);
+            return new ArrayList<>(0);
         }
 
-        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
-        ArrayList<E> realmObjects = new ArrayList<E>();
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<>();
+        ArrayList<E> realmObjects = new ArrayList<>();
         for (E object : objects) {
             checkNotNullObject(object);
             realmObjects.add(copyOrUpdate(object, true, cache));
@@ -1197,11 +1199,11 @@ public void insertOrUpdate(RealmModel object) {
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
         checkMaxDepth(maxDepth);
         if (realmObjects == null) {
-            return new ArrayList<E>(0);
+            return new ArrayList<>(0);
         }
 
-        ArrayList<E> unmanagedObjects = new ArrayList<E>();
-        Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
+        ArrayList<E> unmanagedObjects = new ArrayList<>();
+        Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
             unmanagedObjects.add(createDetachedCopy(object, maxDepth, listCache));
@@ -1653,7 +1655,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      */
     ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
         final long currentSchemaVersion = sharedRealm.getSchemaVersion();
-        final long cacheSchemaVersion = schema.columnIndices.getSchemaVersion();
+        final long cacheSchemaVersion = schema.getSchemaVersion();
         if (currentSchemaVersion == cacheSchemaVersion) {
             return null;
         }
@@ -1666,7 +1668,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
             // Not found in global cache. create it.
             final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
             final Map<Class<? extends RealmModel>, ColumnInfo> map;
-            map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            map = new HashMap<>(modelClasses.size());
             try {
                 for (Class<? extends RealmModel> clazz : modelClasses) {
                     final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
@@ -1678,7 +1680,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
 
             cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
         }
-        schema.columnIndices.copyFrom(cacheForCurrentVersion, mediator);
+        schema.setColumnIndices(cacheForCurrentVersion, mediator);
         return createdGlobalCache;
     }
 
@@ -1755,7 +1757,7 @@ public static int getLocalInstanceCount(RealmConfiguration configuration) {
         class Callback {
             public void onSuccess() {}
 
-            public void onError(Exception e) {}
+            public void onError(Exception ignore) {}
         }
 
         /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index ae372e6f37..27a63ac04a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -51,9 +51,9 @@
 
     private static class RefAndCount {
         // The Realm instance in this thread.
-        private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<BaseRealm>();
+        private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<>();
         // How many references to this Realm instance in this thread.
-        private final ThreadLocal<Integer> localCount = new ThreadLocal<Integer>();
+        private final ThreadLocal<Integer> localCount = new ThreadLocal<>();
         // How many threads have instances refer to this configuration.
         private int globalCount = 0;
     }
@@ -85,14 +85,14 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
 
     // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
     // are not allowed and an exception will be thrown when trying to add it to the cache map.
-    private static Map<String, RealmCache> cachesMap = new HashMap<String, RealmCache>();
+    private static final Map<String, RealmCache> cachesMap = new HashMap<>();
 
     private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
     private static final String WRONG_REALM_CLASS_MESSAGE = "The type of Realm class must be Realm or DynamicRealm.";
 
     private RealmCache(RealmConfiguration config) {
         configuration = config;
-        refAndCountMap = new EnumMap<RealmCacheType, RefAndCount>(RealmCacheType.class);
+        refAndCountMap = new EnumMap<>(RealmCacheType.class);
         for (RealmCacheType type : RealmCacheType.values()) {
             refAndCountMap.put(type, new RefAndCount());
         }
@@ -164,7 +164,7 @@ private RealmCache(RealmConfiguration config) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
                 final BaseRealm realm = refAndCount.localRealm.get();
                 // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.columnIndices.clone());
+                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.getColumnIndices());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 549908bb4f..ec33d39900 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -74,7 +74,7 @@
     public RealmList() {
         collection = null;
         view = null;
-        unmanagedList = new ArrayList<E>();
+        unmanagedList = new ArrayList<>();
     }
 
     /**
@@ -92,7 +92,7 @@ public RealmList(E... objects) {
         }
         collection = null;
         view = null;
-        unmanagedList = new ArrayList<E>(objects.length);
+        unmanagedList = new ArrayList<>(objects.length);
         Collections.addAll(unmanagedList, objects);
     }
 
@@ -246,7 +246,7 @@ private E copyToRealmIfNeeded(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
 
             if (proxy instanceof DynamicRealmObject) {
-                String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
+                String listClassName = StandardRealmSchema.getSchemaForTable(view.getTargetTable());
                 if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
                     String objectClassName = ((DynamicRealmObject) object).getType();
                     if (listClassName.equals(objectClassName)) {
@@ -813,11 +813,13 @@ private void checkValidView() {
         }
         checkValidView();
         if (className != null) {
-            return new OrderedRealmCollectionSnapshot<E>(realm,
+            return new OrderedRealmCollectionSnapshot<>(
+                    realm,
                     new io.realm.internal.Collection(realm.sharedRealm, view, null),
                     className);
         } else {
-            return new OrderedRealmCollectionSnapshot<E>(realm,
+            return new OrderedRealmCollectionSnapshot<>(
+                    realm,
                     new io.realm.internal.Collection(realm.sharedRealm, view, null),
                     clazz);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index e76a0e2746..74025c2544 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -313,12 +313,28 @@ public final boolean load() {
     }
 
     /**
-     * Adds a change listener to this RealmObject.
+     * Adds a change listener to this RealmObject to get detailed information about changes. The listener will be
+     * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
+     * changed.
+     *
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
+     */
+    public final <E extends RealmModel> void addChangeListener(RealmObjectChangeListener<E> listener) {
+        //noinspection unchecked
+        RealmObject.addChangeListener((E) this, listener);
+    }
+
+    /**
+     * Adds a change listener to this RealmObject that will be triggered if any value field or referenced RealmObject
+     * field is changed, or the RealmList field itself is changed.
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
-     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
         //noinspection unchecked
@@ -326,15 +342,18 @@ public final boolean load() {
     }
 
     /**
-     * Adds a change listener to a RealmObject.
+     * Adds a change listener to a RealmObject to get detailed information about the changes. The listener will be
+     * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
+     * changed.
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
-     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalArgumentException if the {@code object} is {@code null} or an unmanaged object, or the change
+     * listener is {@code null}.
      * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
-    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+    public static <E extends RealmModel> void addChangeListener(E object, RealmObjectChangeListener<E> listener) {
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
@@ -353,6 +372,32 @@ public final boolean load() {
         }
     }
 
+    /**
+     * Adds a change listener to a RealmObject that will be triggered if any value field or referenced RealmObject field
+     * is changed, or the RealmList field itself is changed.
+     *
+     * @param object RealmObject to add listener to.
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the {@code object} is {@code null} or an unmanaged object, or the change
+     * listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to add a listener inside a transaction.
+     */
+    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+    }
+
+    /**
+     * Removes a previously registered listener.
+     *
+     * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     */
+    public final void removeChangeListener(RealmObjectChangeListener listener) {
+        RealmObject.removeChangeListener(this, listener);
+    }
+
     /**
      * Removes a previously registered listener.
      *
@@ -373,7 +418,7 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
-    public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
+    public static <E extends RealmModel> void removeChangeListener(E object, RealmObjectChangeListener listener) {
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
@@ -392,6 +437,19 @@ public final void removeChangeListener(RealmChangeListener listener) {
         }
     }
 
+    /**
+     * Removes a previously registered listener on the given RealmObject.
+     *
+     * @param object RealmObject to remove listener from.
+     * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     */
+    public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener<E> listener) {
+        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+    }
+
     /**
      * Removes all registered listeners.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
new file mode 100644
index 0000000000..af172a0e16
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.annotations.LinkingObjects;
+
+/**
+ * {@code RealmObjectChangeListener} can be registered on a {@link RealmModel} or {@link RealmObject} to receive
+ * detailed notifications when an object changes.
+ * <p>
+ * Realm instances on a thread without an {@link android.os.Looper} cannot register a {@code RealmObjectChangeListener}.
+ * <p>
+ * Listener cannot be registered inside a transaction.
+ *
+ * @param <T> The type of {@link RealmModel} on which your listener will be registered.
+ * @see Realm#addChangeListener(RealmChangeListener)
+ * @see Realm#removeAllChangeListeners()
+ * @see Realm#removeChangeListener(RealmChangeListener)
+ */
+public interface RealmObjectChangeListener<T extends RealmModel> {
+
+    /**
+     * When this gets called to return the results of an asynchronous query made by {@link RealmQuery#findFirstAsync()},
+     * {@code changeSet} will be {@code null}.
+     * <p>
+     * When this gets called because the object was deleted, {@code changeSet.isDeleted()} will return {@code true}
+     * and {@code changeSet.getFieldChanges()} will return {@code null}.
+     * <p>
+     * When this gets called because the object was modified, {@code changeSet.isDeleted()} will return {@code false}
+     * and {@code changeSet.getFieldChanges()} will return the detailed information about the fields' changes.
+     * <p>
+     * If a field points to another RealmObject this listener will only be triggered if the field is set to a new object
+     * or null. Updating the referenced RealmObject will not trigger this listener.
+     * <p>
+     * If a field points to a RealmList, this listener will only be triggered if one or multiple objects are inserted,
+     * removed or moved within the List. Updating the objects in the RealmList will not trigger this listener.
+     * <p>
+     * Changes to {@link LinkingObjects} annotated {@link RealmResults} fields will not be monitored, nor reported
+     * through this change listener.
+     * @param object the {@code RealmObject} this listener is registered to.
+     * @param changeSet the detailed information about the changes.
+     */
+    void onChange(T object, ObjectChangeSet changeSet);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index fd71b473d3..7e6f77b43f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -18,6 +18,7 @@
 
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
@@ -39,32 +40,34 @@
     private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
 
     static {
-        SUPPORTED_SIMPLE_FIELDS = new HashMap<Class<?>, FieldMetaData>();
-        SUPPORTED_SIMPLE_FIELDS.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
-        SUPPORTED_SIMPLE_FIELDS.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
-        SUPPORTED_SIMPLE_FIELDS.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
-        SUPPORTED_SIMPLE_FIELDS.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
-        SUPPORTED_SIMPLE_FIELDS.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        SUPPORTED_SIMPLE_FIELDS.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        SUPPORTED_SIMPLE_FIELDS.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
-        SUPPORTED_SIMPLE_FIELDS.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
+        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
+        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
+        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
+        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
+        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
+        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
+        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
+        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
+        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
+        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
+        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
     }
 
     private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
 
     static {
-        SUPPORTED_LINKED_FIELDS = new HashMap<Class<?>, FieldMetaData>();
-        SUPPORTED_LINKED_FIELDS.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
-        SUPPORTED_LINKED_FIELDS.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
+        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
+        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
     }
 
     private final BaseRealm realm;
@@ -151,7 +154,7 @@ public String getClassName() {
      * @param className the new name for this class.
      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
      * characters.
-     * @see RealmSchema#rename(String, String)
+     * @see StandardRealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
         realm.checkNotInSync(); // renaming a table is not permitted
@@ -276,7 +279,7 @@ protected RealmObjectSchema add(Property property) {
     private Set<Property> getProperties() {
         if (realm == null) {
             long[] ptrs = nativeGetProperties(nativePtr);
-            Set<Property> properties = new LinkedHashSet<Property>(ptrs.length);
+            Set<Property> properties = new LinkedHashSet<>(ptrs.length);
             for (int i = 0; i < ptrs.length; i++) {
                 properties.add(new Property(ptrs[i]));
             }
@@ -559,7 +562,7 @@ public String getPrimaryKey() {
      */
     public Set<String> getFieldNames() {
         int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<String>(columnCount);
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
         for (int i = 0; i < columnCount; i++) {
             columnNames.add(table.getColumnName(i));
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 1cdb37a1a2..0f2a19e70c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -51,13 +51,13 @@
  */
 public class RealmQuery<E extends RealmModel> {
 
-    private BaseRealm realm;
+    private final Table table;
+    private final BaseRealm realm;
+    private final TableQuery query;
+    private final RealmObjectSchema schema;
     private Class<E> clazz;
     private String className;
-    private Table table;
-    private RealmObjectSchema schema;
     private LinkView linkView;
-    private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
     static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
@@ -71,7 +71,7 @@
      * to run it.
      */
     public static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
-        return new RealmQuery<E>(realm, clazz);
+        return new RealmQuery<>(realm, clazz);
     }
 
     /**
@@ -83,7 +83,7 @@
      * to run it.
      */
     public static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
-        return new RealmQuery<E>(realm, className);
+        return new RealmQuery<>(realm, className);
     }
 
     /**
@@ -97,7 +97,7 @@
     @SuppressWarnings("unchecked")
     public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
         if (queryResults.classSpec != null) {
-            return new RealmQuery<E>(queryResults, queryResults.classSpec);
+            return new RealmQuery<>(queryResults, queryResults.classSpec);
         } else {
             return new RealmQuery(queryResults, queryResults.className);
         }
@@ -122,7 +122,7 @@
     private RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
         this.table = schema.table;
         this.linkView = null;
         this.query = table.where();
@@ -131,7 +131,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
     private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
         this.table = queryResults.getTable();
         this.linkView = null;
         this.query = queryResults.getCollection().where();
@@ -140,7 +140,7 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
     private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.schema.getSchemaForClass(clazz);
+        this.schema = realm.getSchema().getSchemaForClass(clazz);
         this.table = schema.table;
         this.linkView = linkView;
         this.query = linkView.where();
@@ -149,7 +149,7 @@ private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
     private RealmQuery(BaseRealm realm, String className) {
         this.realm = realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
+        this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.table;
         this.query = table.where();
     }
@@ -157,7 +157,7 @@ private RealmQuery(BaseRealm realm, String className) {
     private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
         this.realm = queryResults.realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
+        this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.table;
         this.query = queryResults.getCollection().where();
     }
@@ -165,7 +165,7 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
     private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
         this.realm = realm;
         this.className = className;
-        this.schema = realm.schema.getSchemaForClass(className);
+        this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.table;
         this.linkView = linkView;
         this.query = linkView.where();
@@ -1522,11 +1522,13 @@ public boolean isValid() {
      * Returns a distinct set of objects of a specific class. If the result is sorted, the first
      * object will be returned in case of multiple occurrences, otherwise it is undefined which
      * object is returned.
+     * <p>
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
      *
      * @param fieldName the field name.
      * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
@@ -1539,13 +1541,14 @@ public boolean isValid() {
      * Asynchronously returns a distinct set of objects of a specific class. If the result is
      * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
      * undefined which object is returned.
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
      *
      * @param fieldName the field name.
      * @return immediately a {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
      * query completes.
-     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
         realm.checkIfValid();
@@ -1906,12 +1909,7 @@ public E findFirst() {
         realm.checkIfValid();
 
         long tableRowIndex = getSourceRowIndexForFirstObject();
-        if (tableRowIndex >= 0) {
-            E realmObject = realm.get(clazz, className, tableRowIndex);
-            return realmObject;
-        } else {
-            return null;
-        }
+        return (tableRowIndex < 0) ? null : realm.get(clazz, className, tableRowIndex);
     }
 
     /**
@@ -1967,9 +1965,9 @@ public E findFirstAsync() {
         RealmResults<E> results;
         Collection collection = new Collection(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
         if (isDynamicQuery()) {
-            results = new RealmResults<E>(realm, collection, className);
+            results = new RealmResults<>(realm, collection, className);
         } else {
-            results = new RealmResults<E>(realm, collection, clazz);
+            results = new RealmResults<>(realm, collection, clazz);
         }
         if (loadResults) {
             results.load();
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 631ce02530..a340686cf5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,16 +16,13 @@
 
 package io.realm;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
-import io.realm.internal.Util;
 
 
 /**
@@ -34,69 +31,15 @@
  * <p>
  * All changes must happen inside a write transaction for the particular Realm.
  *
- * @see io.realm.RealmMigration
+ * @see RealmMigration
  */
-public class RealmSchema {
-
-    private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
-    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
-
-    // Caches Dynamic Class objects given as Strings to Realm Tables
-    private final Map<String, Table> dynamicClassToTable = new HashMap<String, Table>();
-    // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<Class<? extends RealmModel>, Table>();
-    // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmModel>, RealmObjectSchema>();
-    // Caches Class Strings to their Schema object
-    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
-
-    private final BaseRealm realm;
-    private long nativePtr;
-    ColumnIndices columnIndices; // Cached field look up
-
-    /**
-     * Creates a wrapper to easily manipulate the current schema of a Realm.
-     */
-    RealmSchema(BaseRealm realm) {
-        this.realm = realm;
-        this.nativePtr = 0;
-    }
+public abstract class RealmSchema {
+    private ColumnIndices columnIndices; // Cached field look up
 
     /**
-     * Creates a wrappor to easily manipulate Object Store schemas. This constructor should only be called by
-     * proxy classes during validation of schema.
+     * Release the schema and any of native resources it might hold.
      */
-    RealmSchema() {
-        // This is the case where the schema is created from the proxy classes.
-        // dynamicClassToSchema is used to keep track of which model classes have been processed.
-        this.realm = null;
-        this.nativePtr = 0;
-        // TODO: create a Object Store realm::Schema object and store the native pointer
-    }
-
-
-    RealmSchema(ArrayList<RealmObjectSchema> realmObjectSchemas) {
-        long list[] = new long[realmObjectSchemas.size()];
-        for (int i = 0; i < realmObjectSchemas.size(); i++) {
-            list[i] = realmObjectSchemas.get(i).getNativePtr();
-        }
-        this.nativePtr = nativeCreateFromList(list);
-        this.realm = null;
-    }
-
-    public long getNativePtr() {
-        return this.nativePtr;
-    }
-
-    public void close() {
-        if (nativePtr != 0) {
-            Set<RealmObjectSchema> schemas = getAll();
-            for (RealmObjectSchema schema : schemas) {
-                schema.close();
-            }
-            nativeClose(nativePtr);
-        }
-    }
+    public abstract void close();
 
     /**
      * Returns the Realm schema for a given class.
@@ -104,54 +47,14 @@ public void close() {
      * @param className name of the class
      * @return schema object for that class or {@code null} if the class doesn't exists.
      */
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className, EMPTY_STRING_MSG);
-        if (realm == null) {
-            if (contains(className)) {
-                return dynamicClassToSchema.get(className);
-            } else {
-                return null;
-            }
-        } else {
-            String internalClassName = TABLE_PREFIX + className;
-            if (realm.sharedRealm.hasTable(internalClassName)) {
-                Table table = realm.sharedRealm.getTable(internalClassName);
-                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-                return new RealmObjectSchema(realm, table, columnIndices);
-            } else {
-                return null;
-            }
-        }
-    }
+    public abstract RealmObjectSchema get(String className);
 
     /**
-     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     * Returns the {@link RealmObjectSchema}s for all RealmObject classes that can be saved in this Realm.
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
-    public Set<RealmObjectSchema> getAll() {
-        if (realm == null) {
-            long[] ptrs = nativeGetAll(nativePtr);
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(ptrs.length);
-            for (int i = 0; i < ptrs.length; i++) {
-                schemas.add(new RealmObjectSchema(ptrs[i]));
-            }
-            return schemas;
-        } else {
-            int tableCount = (int) realm.sharedRealm.size();
-            Set<RealmObjectSchema> schemas = new LinkedHashSet<RealmObjectSchema>(tableCount);
-            for (int i = 0; i < tableCount; i++) {
-                String tableName = realm.sharedRealm.getTableName(i);
-                if (!Table.isModelTable(tableName)) {
-                    continue;
-                }
-                Table table = realm.sharedRealm.getTable(tableName);
-                RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-                schemas.add(new RealmObjectSchema(realm, table, columnIndices));
-            }
-            return schemas;
-        }
-    }
+    public abstract Set<RealmObjectSchema> getAll();
 
     /**
      * Adds a new class to the Realm.
@@ -159,82 +62,7 @@ public RealmObjectSchema get(String className) {
      * @param className name of the class.
      * @return a Realm schema object for that class.
      */
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        if (realm == null) {
-            RealmObjectSchema realmObjectSchema = new RealmObjectSchema(className);
-            dynamicClassToSchema.put(className, realmObjectSchema);
-            return realmObjectSchema;
-        } else {
-            String internalTableName = TABLE_PREFIX + className;
-            if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-                throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
-            }
-            if (realm.sharedRealm.hasTable(internalTableName)) {
-                throw new IllegalArgumentException("Class already exists: " + className);
-            }
-            Table table = realm.sharedRealm.getTable(internalTableName);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            return new RealmObjectSchema(realm, table, columnIndices);
-        }
-    }
-
-    /**
-     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
-     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
-     *
-     * @param className name of the class to remove.
-     */
-    public void remove(String className) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
-        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
-        Table table = getTable(className);
-        if (table.hasPrimaryKey()) {
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.removeTable(internalTableName);
-    }
-
-    /**
-     * Renames a class already in the Realm.
-     *
-     * @param oldClassName old class name.
-     * @param newClassName new class name.
-     * @return a schema object for renamed class.
-     */
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(oldClassName, "Class names cannot be empty or null");
-        checkEmpty(newClassName, "Class names cannot be empty or null");
-        String oldInternalName = TABLE_PREFIX + oldClassName;
-        String newInternalName = TABLE_PREFIX + newClassName;
-        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (realm.sharedRealm.hasTable(newInternalName)) {
-            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
-        }
-
-        // Checks if there is a primary key defined for the old class.
-        Table oldTable = getTable(oldClassName);
-        String pkField = null;
-        if (oldTable.hasPrimaryKey()) {
-            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
-            oldTable.setPrimaryKey(null);
-        }
-
-        realm.sharedRealm.renameTable(oldInternalName, newInternalName);
-        Table table = realm.sharedRealm.getTable(newInternalName);
-
-        // Sets the primary key for the new class if necessary.
-        if (pkField != null) {
-            table.setPrimaryKey(pkField);
-        }
-
-        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-        return new RealmObjectSchema(realm, table, columnIndices);
-    }
+    public abstract RealmObjectSchema create(String className);
 
     /**
      * Checks if a given class already exists in the schema.
@@ -242,116 +70,46 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
      * @param className class name to check.
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
-    public boolean contains(String className) {
-        if (realm == null) {
-            return dynamicClassToSchema.containsKey(className);
-        } else {
-            return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
-        }
-    }
+    public abstract boolean contains(String className);
 
-    private void checkEmpty(String str, String error) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException(error);
-        }
+    final void setColumnIndices(ColumnIndices columnIndices) {
+        this.columnIndices = columnIndices.clone();
     }
 
-    private void checkHasTable(String className, String errorMsg) {
-        String internalTableName = TABLE_PREFIX + className;
-        if (!realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException(errorMsg);
-        }
+    final void setColumnIndices(long version, Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap) {
+        columnIndices = new ColumnIndices(version, columnInfoMap);
     }
 
-    ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
-        final ColumnInfo columnInfo = columnIndices.getColumnInfo(clazz);
-        if (columnInfo == null) {
-            throw new IllegalStateException("No validated schema information found for " + realm.configuration.getSchemaMediator().getTableName(clazz));
-        }
-        return columnInfo;
-    }
-
-    Table getTable(String className) {
-        className = Table.TABLE_PREFIX + className;
-        Table table = dynamicClassToTable.get(className);
-        if (table == null) {
-            if (!realm.sharedRealm.hasTable(className)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            table = realm.sharedRealm.getTable(className);
-            dynamicClassToTable.put(className, table);
-        }
-        return table;
+    void setColumnIndices(ColumnIndices cacheForCurrentVersion, RealmProxyMediator mediator) {
+        columnIndices.copyFrom(cacheForCurrentVersion, mediator);
     }
 
-    Table getTable(Class<? extends RealmModel> clazz) {
-        Table table = classToTable.get(clazz);
-        if (table == null) {
-            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-            if (isProxyClass(originalClass, clazz)) {
-                // If passed 'clazz' is the proxy, try again with model class.
-                table = classToTable.get(originalClass);
-            }
-            if (table == null) {
-                table = realm.sharedRealm.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass));
-                classToTable.put(originalClass, table);
-            }
-            if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'.
-                classToTable.put(clazz, table);
-            }
-        }
-        return table;
+    final ColumnIndices getColumnIndices() {
+        checkIndices();
+        return columnIndices.clone();
     }
 
-    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        RealmObjectSchema classSchema = classToSchema.get(clazz);
-        if (classSchema == null) {
-            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-            if (isProxyClass(originalClass, clazz)) {
-                // If passed 'clazz' is the proxy, try again with model class.
-                classSchema = classToSchema.get(originalClass);
-            }
-            if (classSchema == null) {
-                Table table = getTable(clazz);
-                classSchema = new RealmObjectSchema(realm, table, columnIndices.getColumnInfo(originalClass).getIndicesMap());
-                classToSchema.put(originalClass, classSchema);
-            }
-            if (isProxyClass(originalClass, clazz)) {
-                // 'clazz' is the proxy class for 'originalClass'.
-                classToSchema.put(clazz, classSchema);
-            }
-        }
-        return classSchema;
+    final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
+        checkIndices();
+        return columnIndices.getColumnInfo(clazz);
     }
 
-    private static boolean isProxyClass(Class<? extends RealmModel> modelClass,
-            Class<? extends RealmModel> testee) {
-        return modelClass != testee;
+    final long getSchemaVersion() {
+        checkIndices();
+        return this.columnIndices.getSchemaVersion();
     }
 
-    RealmObjectSchema getSchemaForClass(String className) {
-        className = Table.TABLE_PREFIX + className;
-        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
-        if (dynamicSchema == null) {
-            if (!realm.sharedRealm.hasTable(className)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            Table table = realm.sharedRealm.getTable(className);
-            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
-            dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
-            dynamicClassToSchema.put(className, dynamicSchema);
-        }
-        return dynamicSchema;
+    final boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
+        return modelClass.equals(testee);
     }
 
     static String getSchemaForTable(Table table) {
         return table.getName().substring(Table.TABLE_PREFIX.length());
     }
 
-    static native long nativeCreateFromList(long[] objectSchemaPtrs);
-
-    static native void nativeClose(long nativePtr);
-
-    static native long[] nativeGetAll(long nativePtr);
+    private void checkIndices() {
+        if (this.columnIndices == null) {
+            throw new IllegalStateException("Attempt to use column index before set.");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
new file mode 100644
index 0000000000..9b224c9d44
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.internal.Table;
+import io.realm.internal.Util;
+
+
+/**
+ * Class for interacting with the Realm schema using a dynamic API. This makes it possible
+ * to add, delete and change the classes in the Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
+ *
+ * @see io.realm.RealmMigration
+ */
+public class StandardRealmSchema extends RealmSchema {
+
+    private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
+    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+
+    // Caches Dynamic Class objects given as Strings to Realm Tables
+    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to their Schema object
+    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<>();
+    // Caches Class Strings to their Schema object
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    private final BaseRealm realm;
+
+    /**
+     * Creates a wrapper to easily manipulate the current schema of a Realm.
+     */
+    StandardRealmSchema(BaseRealm realm) {
+        this.realm = realm;
+    }
+
+    @Override
+    public void close() { }
+
+    /**
+     * Returns the Realm schema for a given class.
+     *
+     * @param className name of the class
+     * @return schema object for that class or {@code null} if the class doesn't exists.
+     */
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalClassName = TABLE_PREFIX + className;
+        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
+
+        Table table = realm.getSharedRealm().getTable(internalClassName);
+        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+        return new RealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
+     *
+     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
+     */
+    @Override
+    public Set<RealmObjectSchema> getAll() {
+        int tableCount = (int) realm.getSharedRealm().size();
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+        for (int i = 0; i < tableCount; i++) {
+            String tableName = realm.getSharedRealm().getTableName(i);
+            if (!Table.isModelTable(tableName)) {
+                continue;
+            }
+            Table table = realm.getSharedRealm().getTable(tableName);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            schemas.add(new RealmObjectSchema(realm, table, columnIndices));
+        }
+        return schemas;
+    }
+
+    /**
+     * Adds a new class to the Realm.
+     *
+     * @param className name of the class.
+     * @return a Realm schema object for that class.
+     */
+    @Override
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+
+        String internalTableName = TABLE_PREFIX + className;
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
+        }
+        if (realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        Table table = realm.getSharedRealm().getTable(internalTableName);
+        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+        return new RealmObjectSchema(realm, table, columnIndices);
+    }
+
+    /**
+     * Checks if a given class already exists in the schema.
+     *
+     * @param className class name to check.
+     * @return {@code true} if the class already exists. {@code false} otherwise.
+     */
+    @Override
+    public boolean contains(String className) {
+        return realm.getSharedRealm().hasTable(Table.TABLE_PREFIX + className);
+    }
+
+    /**
+     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
+     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
+     *
+     * @param className name of the class to remove.
+     */
+    public void remove(String className) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = TABLE_PREFIX + className;
+        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
+        Table table = getTable(className);
+        if (table.hasPrimaryKey()) {
+            table.setPrimaryKey(null);
+        }
+        realm.getSharedRealm().removeTable(internalTableName);
+    }
+
+    /**
+     * Renames a class already in the Realm.
+     *
+     * @param oldClassName old class name.
+     * @param newClassName new class name.
+     * @return a schema object for renamed class.
+     */
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkEmpty(oldClassName, "Class names cannot be empty or null");
+        checkEmpty(newClassName, "Class names cannot be empty or null");
+        String oldInternalName = TABLE_PREFIX + oldClassName;
+        String newInternalName = TABLE_PREFIX + newClassName;
+        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
+        if (realm.getSharedRealm().hasTable(newInternalName)) {
+            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
+        }
+
+        // Checks if there is a primary key defined for the old class.
+        Table oldTable = getTable(oldClassName);
+        String pkField = null;
+        if (oldTable.hasPrimaryKey()) {
+            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
+            oldTable.setPrimaryKey(null);
+        }
+
+        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
+        Table table = realm.getSharedRealm().getTable(newInternalName);
+
+        // Sets the primary key for the new class if necessary.
+        if (pkField != null) {
+            table.setPrimaryKey(pkField);
+        }
+
+        RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+        return new RealmObjectSchema(realm, table, columnIndices);
+    }
+
+    private void checkEmpty(String str, String error) {
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException(error);
+        }
+    }
+
+    private void checkHasTable(String className, String errorMsg) {
+        String internalTableName = TABLE_PREFIX + className;
+        if (!realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException(errorMsg);
+        }
+    }
+
+    Table getTable(String className) {
+        className = Table.TABLE_PREFIX + className;
+        Table table = dynamicClassToTable.get(className);
+        if (table != null) { return table; }
+
+        if (!realm.getSharedRealm().hasTable(className)) {
+            throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+        }
+        table = realm.getSharedRealm().getTable(className);
+        dynamicClassToTable.put(className, table);
+
+        return table;
+    }
+
+    Table getTable(Class<? extends RealmModel> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table != null) { return table; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            table = classToTable.get(originalClass);
+        }
+        if (table == null) {
+            table = realm.getSharedRealm().getTable(realm.getConfiguration().getSchemaMediator().getTableName(originalClass));
+            classToTable.put(originalClass, table);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToTable.put(clazz, table);
+        }
+
+        return table;
+    }
+
+    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        RealmObjectSchema classSchema = classToSchema.get(clazz);
+        if (classSchema != null) { return classSchema; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            classSchema = classToSchema.get(originalClass);
+        }
+        if (classSchema == null) {
+            Table table = getTable(clazz);
+            classSchema = new RealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
+            classToSchema.put(originalClass, classSchema);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToSchema.put(clazz, classSchema);
+        }
+        return classSchema;
+    }
+
+    RealmObjectSchema getSchemaForClass(String className) {
+        className = Table.TABLE_PREFIX + className;
+        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
+        if (dynamicSchema == null) {
+            if (!realm.getSharedRealm().hasTable(className)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            Table table = realm.getSharedRealm().getTable(className);
+            RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
+            dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
+            dynamicClassToSchema.put(className, dynamicSchema);
+        }
+        return dynamicSchema;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
index 7e726a0df3..876b031b9d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
@@ -33,13 +33,13 @@
  *
  * @param <T> the type of {@link ObserverPair}.
  */
-class ObserverPairList<T extends ObserverPairList.ObserverPair> {
+public class ObserverPairList<T extends ObserverPairList.ObserverPair> {
 
     /**
      * @param <T> the type of observer.
      * @param <S> the type of listener.
      */
-    abstract static class ObserverPair<T, S> {
+    public abstract static class ObserverPair<T, S> {
         final WeakReference<T> observerRef;
         protected final S listener;
         // Should only be set by the outer class. To marked it as removed in case it is removed in foreach callback.
@@ -81,7 +81,7 @@ public int hashCode() {
      *
      * @param <T> type of ObserverPair.
      */
-    interface Callback<T extends ObserverPair> {
+    public interface Callback<T extends ObserverPair> {
         void onCalled(T pair, Object observer);
     }
 
@@ -96,7 +96,7 @@ public int hashCode() {
      *
      * @param callback to be executed on the pair.
      */
-    void foreach(Callback<T> callback) {
+    public void foreach(Callback<T> callback) {
         for (T pair : pairs) {
             if (cleared) {
                 break;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
new file mode 100644
index 0000000000..5cf394d4ad
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.ObjectChangeSet;
+import io.realm.RealmModel;
+import io.realm.RealmObjectChangeListener;
+
+
+/**
+ * Java wrapper for Object Store's {@code Object} class. Currently it is only used for object notifications.
+ */
+public class OsObject implements NativeObject {
+
+    private static class OsObjectChangeSet implements ObjectChangeSet {
+        final String[] changedFields;
+        final boolean deleted;
+
+        OsObjectChangeSet(String[] changedFields, boolean deleted) {
+            this.changedFields = changedFields;
+            this.deleted = deleted;
+        }
+
+        @Override
+        public boolean isDeleted() {
+            return deleted;
+        }
+
+        @Override
+        public String[] getChangedFields() {
+            return changedFields;
+        }
+
+        @Override
+        public boolean isFieldChanged(String fieldName) {
+            for (String name : changedFields) {
+                if (name.equals(fieldName)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    public static class ObjectObserverPair<T extends RealmModel>
+            extends ObserverPairList.ObserverPair<T, RealmObjectChangeListener<T>> {
+        public ObjectObserverPair(T observer, RealmObjectChangeListener<T> listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(T observer, ObjectChangeSet changeSet) {
+            listener.onChange(observer, changeSet);
+        }
+    }
+
+    private static class Callback implements ObserverPairList.Callback<ObjectObserverPair> {
+        private final String[] changedFields;
+
+        Callback(String[] changedFields) {
+            this.changedFields = changedFields;
+        }
+
+        private ObjectChangeSet createChangeSet() {
+            boolean isDeleted = changedFields == null;
+            return new OsObjectChangeSet(isDeleted ? new String[0] : changedFields, isDeleted);
+        }
+
+        @Override
+        public void onCalled(ObjectObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange((RealmModel) observer, createChangeSet());
+        }
+    }
+
+    private final long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    private ObserverPairList<ObjectObserverPair> observerPairs = new ObserverPairList<ObjectObserverPair>();
+
+    public OsObject(SharedRealm sharedRealm, UncheckedRow row) {
+        nativePtr = nativeCreate(sharedRealm.getNativePtr(), row.getNativePtr());
+        sharedRealm.context.addReference(this);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public <T extends RealmModel> void addListener(T observer, RealmObjectChangeListener<T> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        ObjectObserverPair<T> pair = new ObjectObserverPair<T>(observer, listener);
+        observerPairs.add(pair);
+    }
+
+    public <T extends RealmModel> void removeListener(T observer) {
+        observerPairs.removeByObserver(observer);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    public <T extends RealmModel> void removeListener(T observer, RealmObjectChangeListener<T> listener) {
+        observerPairs.remove(observer, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    // Set the ObserverPairList. This is useful for the findAllAsync. When the pendingRow returns the results, the whole
+    // listener list has to be moved from ProxyState to here.
+    public void setObserverPairs(ObserverPairList<ObjectObserverPair> pairs) {
+        if (!observerPairs.isEmpty()) {
+            throw new IllegalStateException("'observerPairs' is not empty. Listeners have been added before.");
+        }
+
+        observerPairs = pairs;
+        if (!pairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+    }
+
+    // Called by JNI
+    @SuppressWarnings("unused")
+    private void notifyChangeListeners(String[] changedFields) {
+        observerPairs.foreach(new Callback(changedFields));
+    }
+
+    private static native long nativeGetFinalizerPtr();
+
+    private static native long nativeCreate(long shared_realm_ptr, long rowPtr);
+
+    private native void nativeStartListening(long nativePtr);
+
+    private native void nativeStopListening(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 90c1dbc74e..65bff1f38e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -29,6 +29,7 @@
     private static final String QUERY_EXECUTED_MESSAGE =
             "The query has been executed. This 'PendingRow' is not valid anymore.";
 
+    private SharedRealm sharedRealm;
     private Collection pendingCollection;
     private RealmChangeListener<PendingRow> listener;
     private WeakReference<FrontEnd> frontEndRef;
@@ -36,39 +37,18 @@
 
     public PendingRow(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor,
             final boolean returnCheckedRow) {
+        this.sharedRealm = sharedRealm;
         pendingCollection = new Collection(sharedRealm, query, sortDescriptor, null);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
             public void onChange(PendingRow pendingRow) {
-                if (frontEndRef == null) {
-                    throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
-                }
-                FrontEnd frontEnd = frontEndRef.get();
-                if (frontEnd == null) {
-                    // The front end is GCed.
-                    clearPendingCollection();
-                    return;
-                }
-
-                if (pendingCollection.isValid()) {
-                    // PendingRow will always get the first Row of the query since we only support findFirst.
-                    UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
-                    // If no rows returned by the query, notify the frontend with an invalid row.
-                    if (uncheckedRow != null) {
-                        Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
-                        // Ask the front end to reset the row and stop async query.
-                        frontEnd.onQueryFinished(row);
-                    } else {
-                        frontEnd.onQueryFinished(InvalidRow.INSTANCE);
-                    }
-                }
-
-                clearPendingCollection();
+                notifyFrontEnd();
             }
         };
         pendingCollection.addListener(this, listener);
         this.returnCheckedRow = returnCheckedRow;
+        sharedRealm.addPendingRow(this);
     }
 
     // To set the front end of this PendingRow.
@@ -225,22 +205,43 @@ private void clearPendingCollection() {
         pendingCollection.removeListener(this, listener);
         pendingCollection = null;
         listener = null;
+        sharedRealm.removePendingRow(this);
     }
 
-    public Row executeQuery() {
-        if (pendingCollection == null) {
-            throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
-        }
+    private void notifyFrontEnd() {
         if (frontEndRef == null) {
             throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
         }
+        FrontEnd frontEnd = frontEndRef.get();
+        if (frontEnd == null) {
+            // The front end is GCed.
+            clearPendingCollection();
+            return;
+        }
+
+        if (pendingCollection.isValid()) {
+            // PendingRow will always get the first Row of the query since we only support findFirst.
+            UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+            // If no rows returned by the query, notify the frontend with an invalid row.
+            if (uncheckedRow != null) {
+                Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+                // Ask the front end to reset the row and stop async query.
+                frontEnd.onQueryFinished(row);
+            } else {
+                // No row matches the query, return a invalid row.
+                frontEnd.onQueryFinished(InvalidRow.INSTANCE);
+            }
+        }
 
-        UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
         clearPendingCollection();
+    }
 
-        if (uncheckedRow == null) {
-            return InvalidRow.INSTANCE;
+    // Execute the query immediately and call frontend's onQueryFinished().
+    public void executeQuery() {
+        if (pendingCollection == null) {
+            throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
         }
-        return returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+
+        notifyFrontEnd();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 814af27fb8..0abfa51f0f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -24,7 +24,6 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 
 import io.realm.RealmConfiguration;
-import io.realm.RealmSchema;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
@@ -110,12 +109,13 @@ public byte getNativeValue() {
         }
     }
 
+    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
+    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<>();
+    public final List<WeakReference<Collection.Iterator>> iterators = new ArrayList<>();
+
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
-    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<WeakReference<Collection>>();
     public final Capabilities capabilities;
-    public final List<WeakReference<Collection.Iterator>> iterators =
-            new ArrayList<WeakReference<Collection.Iterator>>();
 
     public static class VersionID implements Comparable<VersionID> {
         public final long version;
@@ -174,8 +174,9 @@ public int hashCode() {
         void onSchemaVersionChanged(long currentVersion);
     }
 
+    private final RealmConfiguration configuration;
+
     private long nativePtr;
-    private RealmConfiguration configuration;
     final Context context;
     private long lastSchemaVersion;
     private final SchemaVersionListener schemaChangeListener;
@@ -241,6 +242,7 @@ public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionLi
 
     public void beginTransaction() {
         detachIterators();
+        executePendingRowQueries();
         nativeBeginTransaction(nativePtr);
         invokeSchemaChangeListenerIfSchemaChanged();
     }
@@ -343,8 +345,8 @@ public boolean compact() {
      * Updates the underlying schema based on the schema description.
      * Calling this method must be done from inside a write transaction.
      */
-    public void updateSchema(RealmSchema schema, long version) {
-        nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
+    public void updateSchema(long schemaNativePointer, long version) {
+        nativeUpdateSchema(nativePtr, schemaNativePointer, version);
     }
 
     public void setAutoRefresh(boolean enabled) {
@@ -356,8 +358,8 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    public boolean requiresMigration(RealmSchema schema) {
-        return nativeRequiresMigration(nativePtr, schema.getNativePtr());
+    public boolean requiresMigration(long schemaNativePointer) {
+        return nativeRequiresMigration(nativePtr, schemaNativePointer);
     }
 
     @Override
@@ -403,7 +405,7 @@ public void invokeSchemaChangeListenerIfSchemaChanged() {
     // See https://github.com/realm/realm-java/issues/3883 for more information.
     // Should only be called by Iterator's constructor.
     void addIterator(Collection.Iterator iterator) {
-        iterators.add(new WeakReference<Collection.Iterator>(iterator));
+        iterators.add(new WeakReference<>(iterator));
     }
 
     // The detaching should happen before transaction begins.
@@ -428,6 +430,38 @@ void invalidateIterators() {
         iterators.clear();
     }
 
+    // addPendingRow, removePendingRow and executePendingRow queries are to solve that the listener cannot be added
+    // inside a transaction. For the findFirstAsync(), listener is registered on an Object Store Results first, then move
+    // the listeners to the Object when the query for Results returns. When beginTransaction() called, all listeners'
+    // on the results will be triggered first, that leads to the registration of listeners on the Object which will
+    // throw because of the transaction has already begun. So here we execute all PendingRow queries first before
+    // calling the Object Store begin_transaction to avoid the problem.
+    // Add pending row to the list when it is created. It should be called in the PendingRow constructor.
+    void addPendingRow(PendingRow pendingRow) {
+       pendingRows.add(new WeakReference<PendingRow>(pendingRow));
+    }
+
+    // Remove pending row from the list. It should be called when pending row's query finished.
+    void removePendingRow(PendingRow pendingRow) {
+        for (WeakReference<PendingRow> ref : pendingRows) {
+            PendingRow row = ref.get();
+            if (row == null || row == pendingRow) {
+                pendingRows.remove(ref);
+            }
+        }
+    }
+
+    // Execute all pending row queries.
+    private void executePendingRowQueries() {
+        for (WeakReference<PendingRow> ref : pendingRows) {
+            PendingRow row = ref.get();
+            if (row != null) {
+                row.executeQuery();
+            }
+        }
+        pendingRows.clear();
+    }
+
     private static native void nativeInit(String temporaryDirectoryPath);
 
     // Keep last session as an 'object' to avoid any reference to sync code
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
index 181df8820c..3df785ef92 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -121,11 +121,6 @@ private static void checkFieldTypeForDistinct(FieldDescriptor descriptor, String
                     "Distinct is not supported on '%s' field '%s' in '%s'.",
                     descriptor.getFieldType().toString(), descriptor.getFieldName(), fieldDescriptions));
         }
-        if (!descriptor.hasSearchIndex()) {
-            throw new IllegalArgumentException(String.format(
-                    "Field '%s' in '%s' must be indexed in order to use it for distinct queries.",
-                    descriptor.getFieldName(), fieldDescriptions));
-        }
     }
 
     // Called by JNI.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
new file mode 100644
index 0000000000..cac85f8077
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.util;
+
+/**
+ * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
+ * to support older versions of Android.
+ *
+ * Container to ease passing around a tuple of two objects. This object provides a sensible
+ * implementation of equals(), returning true if equals() is true on each of the contained
+ * objects.
+ */
+public class Pair<F, S> {
+    public F first;
+    public S second;
+
+    /**
+     * Constructor for a Pair.
+     *
+     * @param first the first object in the Pair.
+     * @param second the second object in the pair.
+     */
+    public Pair(F first, S second) {
+        this.first = first;
+        this.second = second;
+    }
+
+    /**
+     * Checks the two objects for equality by delegating to their respective
+     * {@link Object#equals(Object)} methods.
+     *
+     * @param o the {@link Pair} to which this one is to be checked for equality.
+     * @return true if the underlying objects of the Pair are both considered
+     *         equal.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof Pair)) {
+            return false;
+        }
+        Pair<?, ?> p = (Pair<?, ?>) o;
+        return equals(p.first, first) && (equals(p.second, second));
+    }
+
+    private boolean equals(Object a, Object b) {
+        return (a == b) || (a != null && a.equals(b));
+    }
+
+    /**
+     * Compute a hash code using the hash codes of the underlying objects.
+     *
+     * @return a hashcode of the Pair.
+     */
+    @Override
+    public int hashCode() {
+        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());
+    }
+
+    @Override
+    public String toString() {
+        return "Pair{" + String.valueOf(first) + " " + String.valueOf(second) + "}";
+    }
+
+    /**
+     * Convenience method for creating an appropriately typed pair.
+     *
+     * @param a the first object in the Pair.
+     * @param b the second object in the pair.
+     * @return a Pair that is templatized with the types of a and b.
+     */
+    public static <A, B> Pair <A, B> create(A a, B b) {
+        return new Pair<A, B>(a, b);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/Progress.java b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
new file mode 100644
index 0000000000..db4e7cdc9a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Class used to encapsulate progress notifications when either downloading or uploading Realm data.
+ * Each instance of this class is an immutable snapshot of the current progress.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, the progress reported by
+ * {@link #getFractionTransferred()} can both increase and decrease since more changes might be added while
+ * the progres listener is registered. This means it is possible for one notification to report
+ * {@code true} for {@link #isTransferComplete()}, and then on the next event report {@code false}.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, progress can only ever
+ * increase, and once {@link #isTransferComplete()} returns {@code true}, no further events will be generated.
+ *
+ * @see SyncSession#addDownloadProgressListener(ProgressMode, ProgressListener)
+ * @see SyncSession#addUploadProgressListener(ProgressMode, ProgressListener)
+ */
+public class Progress {
+
+    private final long transferredBytes;
+    private final long transferableBytes;
+
+    /**
+     * Creates a snapshot of the current progress when downloading or uploading changes.
+     *
+     * @param transferredBytes number of bytes transferred.
+     * @param transferableBytes total number of bytes that needs to be transferred (including those already transferred).
+     */
+    Progress(long transferredBytes, long transferableBytes) {
+        this.transferredBytes = transferredBytes;
+        this.transferableBytes = transferableBytes;
+    }
+
+    /**
+     * Returns the total number of bytes that has been transferred since the {@link ProgressListener} was added.
+     *
+     * @return the total number of bytes transferred since the {@link ProgressListener} was added.
+     */
+    public long getTransferredBytes() {
+        return transferredBytes;
+    }
+
+    /**
+     * Returns the total number of transferable bytes (bytes that have been transferred + bytes pending transfer).
+     * <p>
+     * If the {@link ProgressListener} is tracking downloads, this number represents the size of the changesets
+     * generated by all other clients using the Realm.
+     * <p>
+     * If the {@link ProgressListener} is tracking uploads, this number represents the size of changesets created
+     * locally.
+     *
+     * @return the total number of bytes that has been transferred + number of bytes still pending transfer.
+     */
+    public long getTransferableBytes() {
+        return transferableBytes;
+    }
+
+    /**
+     * The fraction of bytes transferred out of all transferable bytes. Counting from since the {@link ProgressListener}
+     * was added.
+     *
+     * @return a number between {@code 0.0} and {@code 1.0}, where {@code 0.0} represents that no data has been
+     *         transferred yet, and {@code 1.0} that all data has been transferred.
+     */
+    public double getFractionTransferred() {
+        if (transferableBytes == 0) {
+            return 1.0D;
+        } else {
+            double percentage = (double) transferredBytes / (double) transferableBytes;
+            return percentage > 1.0D ? 1.0D : percentage;
+        }
+    }
+
+    /**
+     * Returns {@code true} when all pending bytes have been transferred.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, this method can return
+     * {@code false} for subsequent events after returning {@code true}.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, when this method
+     * returns {@code true}, no more progress events will be sent.
+     *
+     * @return {@code true} if all changes have been transferred, {@code false} otherwise.
+     */
+    public boolean isTransferComplete() {
+        return transferredBytes >= transferableBytes;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Progress progress = (Progress) o;
+
+        if (transferredBytes != progress.transferredBytes) return false;
+        return transferableBytes == progress.transferableBytes;
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (int) (transferredBytes ^ (transferredBytes >>> 32));
+        result = 31 * result + (int) (transferableBytes ^ (transferableBytes >>> 32));
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Progress{" +
+                "transferredBytes=" + transferredBytes +
+                ", transferableBytes=" + transferableBytes +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
new file mode 100644
index 0000000000..5b5798f2d4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Interface used when interested in updates on data either being uploaded to or downloaded from
+ * a Realm Object Server.
+ */
+public interface ProgressListener {
+    /**
+     * This method will be called periodically from the underlying Object Server Client responsible
+     * for uploading and downloading changes from the remote Object Server.
+     * <p>
+     * This callback will <i>not</i> happen on the UI thread, but on the worker thread controlling
+     * the Object Server Client. Use {@code Activity.runOnUiThread(Runnable)} or similar to update
+     * any UI elements.
+     * <p>
+     * <pre>
+     * {@code
+     * // Adding an upload progress listener that completes when all known changes have been
+     * // uploaded.
+     * session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+     *   \@Override
+     *    public void onChange(Progress progress) {
+     *      activity.runOnUiThread(new Runnable() {
+     *        \@Override
+     *         public void run() {
+     *           updateProgressBar(progress);
+     *         }
+     *      });
+     *      if (progress.isTransferComplete() {
+     *        session.removeProgressListener(this);
+     *      }
+     *    }
+     * });
+     * }
+     * </pre>
+     *
+     * @param progress an immutable progress change event with information about current progress. This object is thread safe.
+     */
+    void onChange(Progress progress);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
new file mode 100644
index 0000000000..f80f63150d
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Enum describing how to listen to progress changes.
+ */
+public enum ProgressMode {
+    /**
+     * When registering the {@link ProgressListener}, it will record the current size of changes, and will only
+     * continue to report progress updates until those changes have been either downloaded or uploaded. After that
+     * the progress listener will not report any further changes.
+     * <p>
+     * This means that listeners registered in this mode should be done <i>before</i> changes are written to
+     * the Realm.
+     * <p>
+     * Progress reported in this mode will only ever increase.
+     * <p>
+     * This is useful when e.g. reporting progress when downloading a Realm for the first time.
+     */
+    CURRENT_CHANGES,
+
+    /**
+     * A {@link ProgressListener} registered in this mode, will continue to report progress changes, even
+     * if changes are being added after the listener was registered.
+     * <p>
+     * Progress reported in this mode can both increase and decrease, e.g. if large amounts of data is
+     * written after registering the listener.
+     * <p>
+     * This is useful when you want to track if all changes have been uploaded to the server from the device.
+     */
+    INDEFINITELY
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 691538c59b..fe72ce86fe 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,9 +16,9 @@
 
 package io.realm;
 
-import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -90,7 +90,7 @@ public void onClientResetRequired(SyncSession session, ClientResetHandler handle
         }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
-    private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
+    private static Map<String, SyncSession> sessions = new ConcurrentHashMap<>();
     private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
@@ -248,6 +248,24 @@ private static synchronized void notifyErrorHandler(int errorCode, String errorM
         }
     }
 
+    /**
+     * All progress listener events from native Sync are reported to this method.
+     * It costs 2 HashMap lookups for each listener triggered (one to find the session, one to
+     * find the progress listener), but it means we don't have to cache anything on the C++ side which
+     * can leak since we don't have control over the session lifecycle.
+     */
+    @SuppressWarnings("unused")
+    private static synchronized void notifyProgressListener(String localRealmPath, long listenerId, long transferedBytes, long transferableBytes) {
+        SyncSession session = sessions.get(localRealmPath);
+        if (session != null) {
+            try {
+                session.notifyProgressListener(listenerId, transferedBytes, transferableBytes);
+            } catch (Exception exception) {
+                RealmLog.error(exception);
+            }
+        }
+    }
+
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index f2c40281ba..75736ce98f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -17,11 +17,16 @@
 package io.realm;
 
 import java.net.URI;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.Map;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.internal.Keep;
 import io.realm.internal.KeepMember;
@@ -33,6 +38,7 @@
 import io.realm.internal.network.NetworkStateReceiver;
 import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 
 /**
@@ -50,6 +56,8 @@
 public class SyncSession {
     private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
     private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
+    private final static int DIRECTION_DOWNLOAD = 1;
+    private final static int DIRECTION_UPLOAD = 2;
 
     private final SyncConfiguration configuration;
     private final ErrorHandler errorHandler;
@@ -60,6 +68,19 @@
     private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
     private volatile boolean isClosed = false;
 
+    // We need JavaId -> Listener so C++ can trigger callbacks without keeping a reference to the
+    // jobject, which would require a similar map on the C++ side.
+    // We need Listener -> Token map in order to remove the progress listener in C++ from Java.
+    private Map<Long, Pair<ProgressListener, Progress>> listenerIdToProgressListenerMap = new HashMap<>();
+    private Map<ProgressListener, Long> progressListenerToOsTokenMap = new IdentityHashMap<>();
+    // Counter used to assign all ProgressListeners on this session with a unique id.
+    // ListenerId is created by Java to enable C++ to reference the java listener without holding
+    // a reference to the actual object.
+    // ListenerToken is the same concept, but created by OS and represents the listener.
+    // We can unfortunately not just use the ListenerToken, since we need it to be available before
+    // we register the listener.
+    AtomicLong progressListenerId = new AtomicLong(-1);
+
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
         this.errorHandler = configuration.getErrorHandler();
@@ -110,6 +131,105 @@ void notifySessionError(int errorCode, String errorMessage) {
         }
     }
 
+    // Called from native code
+    @SuppressWarnings("unused")
+    @KeepMember
+    synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
+        Pair<ProgressListener, Progress> listener = listenerIdToProgressListenerMap.get(listenerId);
+        if (listener != null) {
+            Progress newProgressNotification = new Progress(transferredBytes, transferableBytes);
+            if (!newProgressNotification.equals(listener.second)) {
+                listener.first.onChange(newProgressNotification);
+                listener.second = newProgressNotification;
+            }
+        } else {
+            RealmLog.debug("Trying unknown listener failed: " + listenerId);
+        }
+    }
+    
+    /**
+     * Adds a progress listener tracking changes that need to be downloaded from the Realm Object
+     * Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addDownloadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_DOWNLOAD, listener);
+    }
+
+    /**
+     * Adds a progress listener tracking changes that need to be uploaded from the device to the
+     * Realm Object Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addUploadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_UPLOAD, listener);
+    }
+
+    /**
+     * Removes a progress listener. If the listener wasn't registered, this method will do nothing.
+     *
+     * @param listener listener to remove.
+     */
+    public synchronized void removeProgressListener(ProgressListener listener) {
+        if (listener == null) {
+            return;
+        }
+        // If an exception is thrown somewhere in here, we will most likely leave the various
+        // maps in an inconsistent manner. Not much we can do about it.
+        Long token = progressListenerToOsTokenMap.remove(listener);
+        if (token != null) {
+            Iterator<Map.Entry<Long, Pair<ProgressListener, Progress>>> it = listenerIdToProgressListenerMap.entrySet().iterator();
+            while (it.hasNext()) {
+                Map.Entry<Long, Pair<ProgressListener, Progress>> entry = it.next();
+                if (entry.getValue().first.equals(listener)) {
+                    it.remove();
+                    break;
+                }
+            }
+            nativeRemoveProgressListener(configuration.getPath(), token);
+        }
+    }
+
+    private void addProgressListener(ProgressMode mode, int direction, ProgressListener listener) {
+        checkProgressListenerArguments(mode, listener);
+        boolean isStreaming = (mode == ProgressMode.INDEFINITELY);
+        long listenerId = progressListenerId.incrementAndGet();
+
+        // A listener might be triggered immediately as part of `nativeAddProgressListener`, so
+        // we need to make sure it can be found by SyncManager.notifyProgressListener()
+        listenerIdToProgressListenerMap.put(listenerId, new Pair<ProgressListener, Progress>(listener, null));
+        long listenerToken = nativeAddProgressListener(configuration.getPath(), listenerId , direction, isStreaming);
+        if (listenerToken == 0) {
+            // ObjectStore did not register the listener. This can happen if a
+            // listener is registered with ProgressMode.CURRENT_CHANGES and no changes actually
+            // exists. In that case the listener was triggered immediately and we just need
+            // to clean it up, since it will never be called again.
+            listenerIdToProgressListenerMap.remove(listenerId);
+        } else {
+            // Listener was properly registered.
+            progressListenerToOsTokenMap.put(listener, listenerToken);
+        }
+    }
+
+    private void checkProgressListenerArguments(ProgressMode mode, ProgressListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+        if (mode == null) {
+            throw new IllegalArgumentException("Non-null 'mode' required.");
+        }
+    }
+
     void close() {
         isClosed = true;
         if (networkRequest != null) {
@@ -356,5 +476,7 @@ private void clearScheduledAccessTokenRefresh() {
     }
 
     private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
+    private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
+    private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
 }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
similarity index 59%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
rename to realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 764b511ee7..57e50f7616 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -14,19 +14,31 @@
  * limitations under the License.
  */
 
-package io.realm.objectserver;
+package io.realm;
 
 import android.support.test.InstrumentationRegistry;
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import java.util.UUID;
+
+import io.realm.ObjectServerError;
 import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
 import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.HttpUtils;
+import io.realm.objectserver.utils.UserFactory;
+
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
 
-class BaseIntegrationTest {
+public class BaseIntegrationTest {
 
     @BeforeClass
     public static void setUp () throws Exception {
@@ -45,8 +57,28 @@ public static void setUp () throws Exception {
     public static void tearDown () throws Exception {
         try {
             HttpUtils.stopSyncServer();
+            SyncManager.reset();
         } catch (Exception e) {
             RealmLog.error("Failed to stop Sync Server", e);
         }
     }
+
+    /**
+     * Login the admin user synchronously.
+     */
+    public SyncUser loginAdminUser() {
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
+        return SyncUser.login(credentials, Constants.AUTH_URL);
+    }
+
+    /**
+     * Create new random user and log in.
+     */
+    public SyncUser loginUser() {
+        String id = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(id, "password", true);
+        return SyncUser.login(credentials, Constants.AUTH_URL);
+    }
+
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index b25ce7f907..89d598e1b8 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -6,6 +6,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ClientResetHandler;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
index 2754115d44..5963837ab7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
@@ -26,6 +26,7 @@
 import java.util.Date;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index ffb20cd32c..7d1d8c7a14 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -32,6 +32,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
+import io.realm.BaseIntegrationTest;
 import io.realm.ClientResetHandler;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
new file mode 100644
index 0000000000..54473d4ec7
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.support.annotation.NonNull;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.URI;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.BaseIntegrationTest;
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.entities.AllTypes;
+import io.realm.objectserver.utils.Constants;
+import io.realm.rule.TestSyncConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressListenerTests extends BaseIntegrationTest {
+
+    private static final long TEST_SIZE = 10;
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @NonNull
+    private SyncConfiguration createSyncConfig() {
+        SyncUser user = loginAdminUser();
+        return configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).build();
+    }
+
+    private void writeSampleData(Realm realm) {
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnString("Object " + i);
+        }
+        realm.commitTransaction();
+    }
+
+    private void assertTransferComplete(Progress progress, boolean nonZeroChange) {
+        assertTrue(progress.isTransferComplete());
+        assertEquals(1.0D, progress.getFractionTransferred(), 0.0D);
+        assertEquals(progress.getTransferableBytes(), progress.getTransferredBytes());
+        if (nonZeroChange) {
+            assertTrue(progress.getTransferredBytes() > 0);
+        }
+    }
+
+    // Create remote data for a given user.
+    private URI createRemoteData(SyncUser user) {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_USER_REALM).build();
+        final Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+        final CountDownLatch changesUploaded = new CountDownLatch(1);
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    session.removeProgressListener(this);
+                    changesUploaded.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(changesUploaded);
+        realm.close();
+        return config.getServerUrl();
+    }
+
+    @Test
+    public void downloadProgressListener_changesOnly() {
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        SyncUser userWithData = loginUser();
+        URI serverUrl = createRemoteData(userWithData);
+        SyncUser adminUser = loginAdminUser();
+
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    Realm realm = Realm.getInstance(config);
+                    assertEquals(TEST_SIZE, realm.where(AllTypes.class).count());
+                    realm.close();
+                    allChangesDownloaded.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        realm.close();
+        userWithData.logout();
+        adminUser.logout();
+    }
+
+    @Test
+    public void downloadProgressListener_indefinitely() throws InterruptedException {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        final CountDownLatch startWorker = new CountDownLatch(1);
+        final SyncUser userWithData = loginUser();
+
+        URI serverUrl = createRemoteData(userWithData);
+
+        // Create worker thread that puts data into another Realm.
+        // This is to avoid blocking one progress listener while waiting for another to complete.
+        Thread worker = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                TestHelper.awaitOrFail(startWorker);
+                createRemoteData(userWithData);
+            }
+        });
+        worker.start();
+
+        SyncUser adminUser = loginAdminUser();
+        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        Realm userRealm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(userWithData, Constants.SYNC_USER_REALM).build()); // Keep session alive
+        SyncSession session = SyncManager.getSession(adminConfig);
+        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch (transferCompleted.incrementAndGet()) {
+                        case 1:
+                            // Initial trigger when registering
+                            assertTransferComplete(progress, false);
+                            break;
+                        case 2: {
+                            assertTransferComplete(progress, true);
+                            Realm adminRealm = Realm.getInstance(adminConfig);
+                            assertEquals(TEST_SIZE, adminRealm.where(AllTypes.class).count());
+                            adminRealm.close();
+                            startWorker.countDown();
+                            break;
+                        }
+                        case 3: {
+                            assertTransferComplete(progress, true);
+                            Realm adminRealm = Realm.getInstance(adminConfig);
+                            assertEquals(TEST_SIZE * 2, adminRealm.where(AllTypes.class).count());
+                            adminRealm.close();
+                            allChangesDownloaded.countDown();
+                            break;
+                        }
+                        default:
+                            fail();
+                    }
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        adminRealm.close();
+        userRealm.close();
+        userWithData.logout();
+        adminUser.logout();
+        worker.join();
+    }
+
+    @Test
+    public void uploadProgressListener_changesOnly() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    allChangeUploaded.countDown();
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void uploadProgressListener_indefinitely() {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch testDone = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+
+        writeSampleData(realm); // Write first batch of sample data
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch(transferCompleted.incrementAndGet()) {
+                        case 1:
+                            Realm realm = Realm.getInstance(config);
+                            writeSampleData(realm);
+                            realm.close();
+                            break;
+                        case 2:
+                            assertTransferComplete(progress, true);
+                            testDone.countDown();
+                            break;
+                        default:
+                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(testDone);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    Realm realm = Realm.getInstance(config);
+                    writeSampleData(realm);
+                    realm.close();
+                    session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                        @Override
+                        public void onChange(Progress progress) {
+                            if (progress.isTransferComplete()) {
+                                allChangeUploaded.countDown();
+                            }
+                        }
+                    });
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback_mixProgressModes() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(3);
+        final AtomicBoolean progressCompletedReported = new AtomicBoolean(false);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    allChangeUploaded.countDown();
+                    if (progressCompletedReported.compareAndSet(false, true)) {
+                        Realm realm = Realm.getInstance(config);
+                        writeSampleData(realm);
+                        realm.close();
+                        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                            @Override
+                            public void onChange(Progress progress) {
+                                if (progress.isTransferComplete()) {
+                                    allChangeUploaded.countDown();
+                                }
+                            }
+                        });
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addProgressListener_triggerImmediatelyWhenRegistered() {
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+
+        checkListener(session, ProgressMode.INDEFINITELY);
+        checkListener(session, ProgressMode.CURRENT_CHANGES);
+
+        realm.close();
+    }
+
+    private void checkListener(SyncSession session, ProgressMode progressMode) {
+        final CountDownLatch listenerCalled = new CountDownLatch(1);
+        session.addDownloadProgressListener(progressMode, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                listenerCalled.countDown();
+            }
+        });
+        TestHelper.awaitOrFail(listenerCalled);
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index e5347effc8..a4c11802dd 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,8 +18,9 @@
 
 public class Constants {
 
-    public static String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
-    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+    public static String SYNC_USER_REALM = "realm://127.0.0.1:9080/~/tests";
+    public static String SYNC_SERVER_URL = "realm://127.0.0.1:9080/tests";
+    public static String SYNC_SERVER_URL_2 = "realm://127.0.0.1:9080/tests2";
 
     public static String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
     public static String AUTH_URL = AUTH_SERVER_URL + "auth";
