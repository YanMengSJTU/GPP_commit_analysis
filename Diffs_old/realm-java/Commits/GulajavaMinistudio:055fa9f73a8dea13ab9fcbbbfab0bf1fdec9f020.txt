diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9dcb1a99c4..771001e515 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,11 +9,15 @@
 * Removed deprecated API `RealmObject.removeChangeListeners()`. Use `RealmObject.removeAllChangeListeners()` instead.
 * `SyncUser.Callback` to becomes generic.
 * Removed `SyncUser.getAccessToken` method from public API, and rename it to `getRefreshToken`.
+* Removed `UNSUPPORTED_TABLE`, `UNSUPPORTED_MIXED` and `UNSUPPORTED_DATE` from `RealmFieldType`.
+* Relaxed upper bound of type parameter of `RealmList`, `RealmQuery`, `RealmResults`, `RealmCollection`, `OrderedRealmCollection` and `OrderedRealmCollectionSnapshot`.
 
 ## Deprecated
 
 ## Enhancements
 
+* Now users can use `String`, `byte[]`, `Boolean`, `Long`, `Integer`, `Short`, `Byte`, `Double`, `Float` and `Date` as a type parameter of `RealmList`.
+
 ## Bug Fixes
 
 ## Internal
@@ -29,6 +33,7 @@
 ### Breaking Changes
 
 * `RealmResults.distinct()`/`RealmResults.distinctAsync()` have been removed. Use `RealmQuery.distinct()`/`RealmQuery.distinctAsync()` instead.
+* `RealmQuery.createQuery(Realm, Class)`, `RealmQuery.createDynamicQuery(DynamicRealm, String)`, `RealmQuery.createQueryFromResult(RealmResults)` and `RealmQuery.createQueryFromList(RealmList)` have been removed. Use `Realm.where(Class)`, `DynamicRealm.where(String)`, RealmResults.where()` and `RealmList.where()` instead.
 
 ### Enhancements
 
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index bc4d648959..643704a169 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -174,7 +174,7 @@ class KotlinExampleActivity : Activity() {
 
             // Sorting
             val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
-            status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
+            status += "\nSorting ${sortedPersons.last()?.name} == ${realm.where(Person::class.java).findAll().first()?.name}"
 
         } finally {
             realm.close()
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index d58b0bc051..3f9cae0b10 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -57,6 +57,7 @@
     private final List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
     private final Set<Backlink> backlinks = new HashSet<Backlink>();
     private final Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
+    private final Set<VariableElement> nullableValueListFields = new HashSet<VariableElement>(); // Set of fields whose elements can be nullable
 
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
@@ -66,21 +67,36 @@
     private boolean containsHashCode;
 
     private final List<TypeMirror> validPrimaryKeyTypes;
+    private final List<TypeMirror> validListValueTypes;
     private final Types typeUtils;
     private final Elements elements;
 
-    public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
+    public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
         elements = env.getElementUtils();
-        TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
+
+
         validPrimaryKeyTypes = Arrays.asList(
-                stringType,
-                typeUtils.getPrimitiveType(TypeKind.SHORT),
-                typeUtils.getPrimitiveType(TypeKind.INT),
-                typeUtils.getPrimitiveType(TypeKind.LONG),
-                typeUtils.getPrimitiveType(TypeKind.BYTE)
+                typeMirrors.STRING_MIRROR,
+                typeMirrors.PRIMITIVE_LONG_MIRROR,
+                typeMirrors.PRIMITIVE_INT_MIRROR,
+                typeMirrors.PRIMITIVE_SHORT_MIRROR,
+                typeMirrors.PRIMITIVE_BYTE_MIRROR
+        );
+
+        validListValueTypes = Arrays.asList(
+                typeMirrors.STRING_MIRROR,
+                typeMirrors.BINARY_MIRROR,
+                typeMirrors.BOOLEAN_MIRROR,
+                typeMirrors.LONG_MIRROR,
+                typeMirrors.INTEGER_MIRROR,
+                typeMirrors.SHORT_MIRROR,
+                typeMirrors.BYTE_MIRROR,
+                typeMirrors.DOUBLE_MIRROR,
+                typeMirrors.FLOAT_MIRROR,
+                typeMirrors.DATE_MIRROR
         );
 
         for (Element element : classType.getEnclosedElements()) {
@@ -167,6 +183,15 @@ public boolean isNullable(VariableElement variableElement) {
         return nullableFields.contains(variableElement);
     }
 
+    /**
+     * Checks if the element of {@code RealmList} designated by {@code realmListVariableElement} is nullable.
+     *
+     * @return {@code true} if the element is nullable type, {@code false} otherwise.
+     */
+    public boolean isElementNullable(VariableElement realmListVariableElement) {
+        return nullableValueListFields.contains(realmListVariableElement);
+    }
+
     /**
      * Checks if a VariableElement is indexed.
      *
@@ -240,7 +265,7 @@ public boolean generate() {
         packageName = packageElement.getQualifiedName().toString();
 
         if (!categorizeClassElements()) { return false; }
-        if (!checkListTypes()) { return false; }
+        if (!checkCollectionTypes()) { return false; }
         if (!checkReferenceTypes()) { return false; }
         if (!checkDefaultConstructor()) { return false; }
         if (!checkForFinalFields()) { return false; }
@@ -274,25 +299,14 @@ private boolean categorizeClassElements() {
         return true;
     }
 
-    private boolean checkListTypes() {
+    private boolean checkCollectionTypes() {
         for (VariableElement field : fields) {
-            if (Utils.isRealmList(field) || Utils.isRealmResults(field)) {
-                // Check for missing generic (default back to Object)
-                if (Utils.getGenericTypeQualifiedName(field) == null) {
-                    Utils.error("No generic type supplied for field", field);
+            if (Utils.isRealmList(field)) {
+                if (!checkRealmListType(field)) {
                     return false;
                 }
-
-                // Check that the referenced type is a concrete class and not an interface
-                TypeMirror fieldType = field.asType();
-                List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
-                String genericCanonicalType = typeArguments.get(0).toString();
-                TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
-                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                    Utils.error(
-                            "Only concrete Realm classes are allowed in RealmLists. "
-                                    + "Neither interfaces nor abstract classes are allowed.",
-                            field);
+            } else if (Utils.isRealmResults(field)) {
+                if (!checkRealmResultsType(field)) {
                     return false;
                 }
             }
@@ -301,6 +315,75 @@ private boolean checkListTypes() {
         return true;
     }
 
+    private boolean checkRealmListType(VariableElement field) {
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error("No generic type supplied for field", field);
+            return false;
+        }
+
+        // Check that the referenced type is a concrete class and not an interface
+        TypeMirror fieldType = field.asType();
+        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
+        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class of interface*/) {
+            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
+            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                Utils.error(
+                        "Only concrete Realm classes are allowed in RealmLists. "
+                                + "Neither interfaces nor abstract classes are allowed.",
+                        field);
+                return false;
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!validListValueTypes.contains(elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
+            final StringBuilder messageBuilder = new StringBuilder(
+                    "Element type of RealmList must be a class implementing 'RealmModel' or one of the ");
+            final String separator = ", ";
+            for (TypeMirror type : validListValueTypes) {
+                messageBuilder.append('\'').append(type.toString()).append('\'').append(separator);
+            }
+            messageBuilder.setLength(messageBuilder.length() - separator.length());
+            messageBuilder.append('.');
+            Utils.error(messageBuilder.toString(), field);
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean checkRealmResultsType(VariableElement field) {
+        // Only classes implementing RealmModel are allowed since RealmResults field is used only for backlinks.
+
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error("No generic type supplied for field", field);
+            return false;
+        }
+
+        TypeMirror fieldType = field.asType();
+        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
+        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class or interface*/) {
+            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
+            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                Utils.error(
+                        "Only concrete Realm classes are allowed in RealmResults. "
+                                + "Neither interfaces nor abstract classes are allowed.",
+                        field);
+                return false;
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!Utils.isRealmModel(elementTypeMirror)) {
+            Utils.error("Element type of RealmResults must be a class implementing 'RealmModel'.", field);
+            return false;
+        }
+
+        return true;
+    }
+
     private boolean checkReferenceTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmModel(field)) {
@@ -376,14 +459,23 @@ private boolean categorizeField(Element element) {
             if (!categorizeIndexField(element, field)) { return false; }
         }
 
-        if (isRequiredField(field)) {
+        // @Required annotation of RealmList field only affects its value type, not field itself.
+        if (Utils.isRealmList(field)) {
+            // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
+            if (!hasRequiredAnnotation(field)) {
+                final List<? extends TypeMirror> fieldTypeArguments = ((DeclaredType) field.asType()).getTypeArguments();
+                if (fieldTypeArguments.isEmpty() || !Utils.isRealmModel(fieldTypeArguments.get(0))) {
+                    nullableValueListFields.add(field);
+                }
+            }
+        } else if (isRequiredField(field)) {
             categorizeRequiredField(element, field);
         } else {
-            // The field doesn't have the @Required annotation.
+            // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
             // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
             // nullableFields.
-            // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
-            if (!Utils.isPrimitiveType(field) && !Utils.isRealmList(field)) {
+            // RealmList of models, RealmResults(backlinks) and primitive types are NOT nullable. @Required annotation is not supported.
+            if (!Utils.isPrimitiveType(field) && !Utils.isRealmResults(field)) {
                 nullableFields.add(field);
             }
         }
@@ -409,8 +501,26 @@ private boolean categorizeField(Element element) {
         return true;
     }
 
+    /**
+     * This method only checks if the field has {@code @Required} annotation.
+     * In most cases, you should use {@link #isRequiredField(VariableElement)} to take into account
+     * Kotlin's annotation as well.
+     *
+     * @param field target field.
+     * @return {@code true} if the field has {@code @Required} annotation, {@code false} otherwise.
+     * @see #isRequiredField(VariableElement)
+     */
+    private boolean hasRequiredAnnotation(VariableElement field) {
+        return field.getAnnotation(Required.class) != null;
+    }
+
+    /**
+     * Checks if the field is annotated as required.
+     * @param field target field.
+     * @return {@code true} if the field is annotated as required, {@code false} otherwise.
+     */
     private boolean isRequiredField(VariableElement field) {
-        if (field.getAnnotation(Required.class) != null) {
+        if (hasRequiredAnnotation(field)) {
             return true;
         }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 9dd2b68b8c..fbce99063d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -54,7 +54,16 @@
         REALM_INTEGER("INTEGER", "Long"),
         OBJECT("OBJECT", "Object"),
         LIST("LIST", "List"),
-        BACKLINK("BACKLINK", null);
+
+        BACKLINK("LINKING_OBJECTS", null),
+
+        INTEGER_LIST("INTEGER_LIST", "List"),
+        BOOLEAN_LIST("BOOLEAN_LIST", "List"),
+        STRING_LIST("STRING_LIST", "List"),
+        BINARY_LIST("BINARY_LIST", "List"),
+        DATE_LIST("DATE_LIST", "List"),
+        FLOAT_LIST("FLOAT_LIST", "List"),
+        DOUBLE_LIST("DOUBLE_LIST", "List");
 
         private final String realmType;
         private final String javaType;
@@ -110,4 +119,22 @@ public String getJavaType() {
         // TODO: add support for char and Char
         JAVA_TO_REALM_TYPES = Collections.unmodifiableMap(m);
     }
+
+
+    static final Map<String, RealmFieldType> LIST_ELEMENT_TYPE_TO_REALM_TYPES;
+
+    static {
+        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
+        m.put("java.lang.Byte", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Short", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Integer", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Long", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Float", RealmFieldType.FLOAT_LIST);
+        m.put("java.lang.Double", RealmFieldType.DOUBLE_LIST);
+        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN_LIST);
+        m.put("java.lang.String", RealmFieldType.STRING_LIST);
+        m.put("java.util.Date", RealmFieldType.DATE_LIST);
+        m.put("byte[]", RealmFieldType.BINARY_LIST);
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES = Collections.unmodifiableMap(m);
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index ef75e16923..758a5ce031 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -172,6 +172,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
     // Create all proxy classes
     private boolean processAnnotations(RoundEnvironment roundEnv) {
+        final TypeMirrors typeMirrors = new TypeMirrors(processingEnv);
+
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
             // The class must either extend RealmObject or implement RealmModel
@@ -186,7 +188,7 @@ private boolean processAnnotations(RoundEnvironment roundEnv) {
                 return false;
             }
 
-            ClassMetaData metadata = new ClassMetaData(processingEnv, (TypeElement) classElement);
+            ClassMetaData metadata = new ClassMetaData(processingEnv, typeMirrors, (TypeElement) classElement);
             if (!metadata.isModelClass()) { continue; }
 
             Utils.note("Processing class " + metadata.getSimpleClassName());
@@ -202,7 +204,7 @@ private boolean processAnnotations(RoundEnvironment roundEnv) {
                 Utils.error(e.getMessage(), classElement);
             }
 
-            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, metadata);
+            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, typeMirrors, metadata);
             try {
                 sourceCodeGenerator.generate();
             } catch (IOException e) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 8b2ea52b8d..e1ea070565 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -32,6 +32,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.JavaFileObject;
 
@@ -76,6 +77,7 @@
     }
 
     private final ProcessingEnvironment processingEnvironment;
+    private final TypeMirrors typeMirrors;
     private final ClassMetaData metadata;
     private final String simpleClassName;
     private final String qualifiedClassName;
@@ -83,8 +85,9 @@
     private final String qualifiedGeneratedClassName;
     private final boolean suppressWarnings;
 
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
+    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, TypeMirrors typeMirrors, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
+        this.typeMirrors = typeMirrors;
         this.metadata = metadata;
         this.simpleClassName = metadata.getSimpleClassName();
         this.qualifiedClassName = metadata.getFullyQualifiedClassName();
@@ -312,7 +315,8 @@ private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOExcep
             } else if (Utils.isRealmModel(field)) {
                 emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
             } else if (Utils.isRealmList(field)) {
-                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName, elementTypeMirror);
             } else {
                 throw new UnsupportedOperationException(String.format(Locale.US,
                         "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
@@ -501,15 +505,17 @@ public void emit(JavaWriter writer) throws IOException {
     //@formatter:on
 
     /**
-     * LinkLists
+     * ModelList, ValueList
      */
     //@formatter:off
     private void emitRealmList(
             JavaWriter writer,
             final VariableElement field,
             String fieldName,
-            String fieldTypeCanonicalName) throws IOException {
-        String genericType = Utils.getGenericTypeQualifiedName(field);
+            String fieldTypeCanonicalName,
+            final TypeMirror elementTypeMirror) throws IOException {
+        final String genericType = Utils.getGenericTypeQualifiedName(field);
+        final boolean forRealmModel = Utils.isRealmModel(elementTypeMirror);
 
         // Getter
         writer.emitAnnotation("Override");
@@ -518,9 +524,15 @@ private void emitRealmList(
                 .emitSingleLineComment("use the cached value if available")
                 .beginControlFlow("if (" + fieldName + "RealmList != null)")
                 .emitStatement("return " + fieldName + "RealmList")
-                .nextControlFlow("else")
-                .emitStatement("OsList osList = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
-                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, osList, proxyState.getRealm$realm())",
+                .nextControlFlow("else");
+                if (Utils.isRealmModelList(field)) {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
+                            fieldIndexVariableReference(field));
+                } else {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
+                            fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
+                }
+                writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, osList, proxyState.getRealm$realm())",
                         genericType, genericType)
                 .emitStatement("return " + fieldName + "RealmList")
                 .endControlFlow()
@@ -538,12 +550,17 @@ public void emit(JavaWriter writer) throws IOException {
                         field.getSimpleName().toString())
                         .emitStatement("return")
                         .endControlFlow();
-                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
-                writer.beginControlFlow("if (value != null && !value.isManaged())")
+
+                if (!forRealmModel) {
+                    return;
+                }
+
+                writer.emitSingleLineComment("if the list contains unmanaged RealmObjects, convert them to managed.")
+                        .beginControlFlow("if (value != null && !value.isManaged())")
                         .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
-                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
-                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
-                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
+                        .emitStatement("final RealmList<%1$s> original = value", genericType)
+                        .emitStatement("value = new RealmList<%1$s>()", genericType)
+                        .beginControlFlow("for (%1$s item : original)", genericType)
                         .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
                         .emitStatement("value.add(item)")
                         .nextControlFlow("else")
@@ -555,25 +572,72 @@ public void emit(JavaWriter writer) throws IOException {
                 // LinkView currently does not support default value feature. Just fallback to normal code.
             }
         });
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-                .emitStatement("OsList osList = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
-                .emitStatement("osList.removeAll()")
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                if (Utils.isRealmModelList(field)) {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
+                            fieldIndexVariableReference(field));
+                } else {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
+                            fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
+                }
+                writer.emitStatement("osList.removeAll()")
                 .beginControlFlow("if (value == null)")
                 .emitStatement("return")
-                .endControlFlow()
-                .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
-                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
-                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
-                .endControlFlow()
-                .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
-                .endControlFlow()
-                .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-                .endControlFlow()
-                .endMethod();
+                .endControlFlow();
+
+        if (forRealmModel) {
+            writer.beginControlFlow("for (RealmModel linkedObject : value)")
+                    .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
+                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
+                    .endControlFlow()
+                    .beginControlFlow("if (((RealmObjectProxy) linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
+                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
+                    .endControlFlow()
+                    .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
+                    .endControlFlow();
+        } else {
+            writer.beginControlFlow("for (%1$s item : value)", genericType)
+                    .beginControlFlow("if (item == null)")
+                    .emitStatement(metadata.isElementNullable(field) ? "osList.addNull()" : "throw new IllegalArgumentException(\"Storing 'null' into " + fieldName + "' is not allowed by the schema.\")")
+                    .nextControlFlow("else")
+                    .emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
+                    .endControlFlow()
+                    .endControlFlow();
+        }
+        writer.endMethod();
+
     }
     //@formatter:on
 
+    private String getStatementForAppendingValueToOsList(
+            @SuppressWarnings("SameParameterValue") String osListVariableName,
+            @SuppressWarnings("SameParameterValue") String valueVariableName,
+            TypeMirror elementTypeMirror) {
+        if (elementTypeMirror == typeMirrors.STRING_MIRROR) {
+            return osListVariableName + ".addString(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.LONG_MIRROR || elementTypeMirror == typeMirrors.INTEGER_MIRROR
+                || elementTypeMirror == typeMirrors.SHORT_MIRROR || elementTypeMirror == typeMirrors.BYTE_MIRROR) {
+            return osListVariableName + ".addLong(" + valueVariableName + ".longValue())";
+        }
+        if (elementTypeMirror.equals(typeMirrors.BINARY_MIRROR)) {
+            return osListVariableName + ".addBinary(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.DATE_MIRROR) {
+            return osListVariableName + ".addDate(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.BOOLEAN_MIRROR) {
+            return osListVariableName + ".addBoolean(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.DOUBLE_MIRROR) {
+            return osListVariableName + ".addDouble(" + valueVariableName + ".doubleValue())";
+        }
+        if (elementTypeMirror == typeMirrors.FLOAT_MIRROR) {
+            return osListVariableName + ".addFloat(" + valueVariableName + ".floatValue())";
+        }
+        throw new RuntimeException("unexpected element type: " + elementTypeMirror.toString());
+    }
+
     private interface CodeEmitter {
         void emit(JavaWriter writer) throws IOException;
     }
@@ -666,7 +730,7 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
 
-            Constants.RealmFieldType fieldType = getRealmType(field);
+            Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
             switch (fieldType) {
                 case NOTYPE:
                     // Perhaps this should fail quickly?
@@ -679,12 +743,34 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                     break;
 
                 case LIST:
+                    // only for model list.
                     String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                     writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
                             fieldName, genericTypeSimpleName);
                     break;
 
-                default:
+                case INTEGER_LIST:
+                case BOOLEAN_LIST:
+                case STRING_LIST:
+                case BINARY_LIST:
+                case DATE_LIST:
+                case FLOAT_LIST:
+                case DOUBLE_LIST:
+                    writer.emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)",
+                            fieldName, fieldType.getRealmType(), metadata.isElementNullable(field) ? "!Property.REQUIRED" : "Property.REQUIRED");
+                    break;
+
+                case BACKLINK:
+                    throw new IllegalArgumentException("LinkingObject field should not be added to metadata");
+
+                case INTEGER:
+                case FLOAT:
+                case DOUBLE:
+                case BOOLEAN:
+                case STRING:
+                case DATE:
+                case BINARY:
+                case REALM_INTEGER:
                     String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
                     String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
                     String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
@@ -694,6 +780,10 @@ private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOExce
                             primaryKeyFlag,
                             indexedFlag,
                             nullableFlag);
+                    break;
+
+                default:
+                    throw new IllegalArgumentException("'fieldType' " + fieldName + " is not handled");
             }
         }
         for (Backlink backlink: metadata.getBacklinkFields()) {
@@ -1005,7 +1095,7 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
@@ -1021,7 +1111,23 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
                         .endControlFlow()
                         .endControlFlow();
-
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement(fieldName + "OsList.addNull()")
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
@@ -1085,7 +1191,7 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
@@ -1102,6 +1208,23 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .endControlFlow();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
@@ -1161,7 +1284,7 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
@@ -1180,6 +1303,25 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitEmptyLine();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
@@ -1245,7 +1387,7 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
@@ -1264,6 +1406,26 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                         .endControlFlow()
                         .emitEmptyLine();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList",
+                                fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
@@ -1395,7 +1557,7 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                             .endControlFlow()
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer.emitEmptyLine()
                         .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
@@ -1417,6 +1579,8 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .emitEmptyLine();
 
+            } else if (Utils.isRealmValueList(field)) {
+                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
             } else if (Utils.isMutableRealmInteger(field)) {
                 writer.emitEmptyLine()
                         .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
@@ -1471,7 +1635,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                         .emitSingleLineComment("Deep copy of %s", fieldName)
                         .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
                                 setter, Utils.getProxyClassSimpleName(field), getter);
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 writer
                         .emitEmptyLine()
                         .emitSingleLineComment("Deep copy of %s", fieldName)
@@ -1490,6 +1654,11 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                         .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                         .endControlFlow();
+            } else if (Utils.isRealmValueList(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("unmanagedCopy.%1$s(new RealmList<%2$s>())", setter, Utils.getGenericTypeQualifiedName(field))
+                        .emitStatement("unmanagedCopy.%1$s().addAll(realmSource.%1$s())", getter);
             } else if (Utils.isMutableRealmInteger(field)) {
                 // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
                 writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
@@ -1498,6 +1667,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
             }
         }
 
+        writer.emitEmptyLine();
         writer.emitStatement("return unmanagedObject");
         writer.endMethod();
         writer.emitEmptyLine();
@@ -1541,7 +1711,7 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
@@ -1561,6 +1731,8 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .endControlFlow()
                         .endControlFlow();
 
+            } else if (Utils.isRealmValueList(field)) {
+                writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
             } else if (Utils.isMutableRealmInteger(field)) {
                 writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
             } else {
@@ -1778,7 +1950,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         writer
                 );
 
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
                         "objProxy",
                         metadata.getInternalGetter(fieldName),
@@ -1788,6 +1960,10 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isRealmValueList(field)) {
+                // FIXME need to implement logic for value list fields.
+                writer.emitSingleLineComment(String.format(Locale.ENGLISH,
+                        "TODO implement logic for value list %1$s.", field.getSimpleName()));
             } else if (Utils.isMutableRealmInteger(field)) {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
                         "objProxy",
@@ -1860,7 +2036,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                         writer
                 );
 
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
                         "objProxy",
                         metadata.getInternalGetter(fieldName),
@@ -1869,6 +2045,9 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isRealmValueList(field)) {
+                // FIXME need to implement logic for value list fields.
+                writer.emitSingleLineComment("TODO implement logic for value list.");
             } else if (Utils.isMutableRealmInteger(field)) {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                         "objProxy",
@@ -1946,9 +2125,16 @@ private static int countModelOrListFields(Collection<VariableElement> fields) {
         if (Utils.isRealmModel(field)) {
             return Constants.RealmFieldType.OBJECT;
         }
-        if (Utils.isRealmList(field)) {
+        if (Utils.isRealmModelList(field)) {
             return Constants.RealmFieldType.LIST;
         }
+        if (Utils.isRealmValueList(field)) {
+            final Constants.RealmFieldType fieldType = Utils.getValueListFieldType(field);
+            if (fieldType == null) {
+                return Constants.RealmFieldType.NOTYPE;
+            }
+            return fieldType;
+        }
         return Constants.RealmFieldType.NOTYPE;
     }
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
new file mode 100644
index 0000000000..8757727a14
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.util.Date;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+
+/**
+ * This class provides {@link TypeMirror} instances used in annotation processor.
+ */
+class TypeMirrors {
+    final TypeMirror STRING_MIRROR;
+    final TypeMirror BINARY_MIRROR;
+    final TypeMirror BOOLEAN_MIRROR;
+    final TypeMirror LONG_MIRROR;
+    final TypeMirror INTEGER_MIRROR;
+    final TypeMirror SHORT_MIRROR;
+    final TypeMirror BYTE_MIRROR;
+    final TypeMirror DOUBLE_MIRROR;
+    final TypeMirror FLOAT_MIRROR;
+    final TypeMirror DATE_MIRROR;
+
+    final TypeMirror PRIMITIVE_LONG_MIRROR;
+    final TypeMirror PRIMITIVE_INT_MIRROR;
+    final TypeMirror PRIMITIVE_SHORT_MIRROR;
+    final TypeMirror PRIMITIVE_BYTE_MIRROR;
+
+    TypeMirrors(ProcessingEnvironment env) {
+        final Types typeUtils = env.getTypeUtils();
+        final Elements elementUtils = env.getElementUtils();
+
+        STRING_MIRROR = elementUtils.getTypeElement("java.lang.String").asType();
+        BINARY_MIRROR = typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.BYTE));
+        BOOLEAN_MIRROR = elementUtils.getTypeElement(Boolean.class.getName()).asType();
+        LONG_MIRROR = elementUtils.getTypeElement(Long.class.getName()).asType();
+        INTEGER_MIRROR = elementUtils.getTypeElement(Integer.class.getName()).asType();
+        SHORT_MIRROR = elementUtils.getTypeElement(Short.class.getName()).asType();
+        BYTE_MIRROR = elementUtils.getTypeElement(Byte.class.getName()).asType();
+        DOUBLE_MIRROR = elementUtils.getTypeElement(Double.class.getName()).asType();
+        FLOAT_MIRROR = elementUtils.getTypeElement(Float.class.getName()).asType();
+        DATE_MIRROR = elementUtils.getTypeElement(Date.class.getName()).asType();
+
+        PRIMITIVE_LONG_MIRROR = typeUtils.getPrimitiveType(TypeKind.LONG);
+        PRIMITIVE_INT_MIRROR = typeUtils.getPrimitiveType(TypeKind.INT);
+        PRIMITIVE_SHORT_MIRROR = typeUtils.getPrimitiveType(TypeKind.SHORT);
+        PRIMITIVE_BYTE_MIRROR = typeUtils.getPrimitiveType(TypeKind.BYTE);
+    }
+
+    /**
+     * @return the {@link TypeMirror} of the elements in {@code RealmList}.
+     */
+    public static TypeMirror getRealmListElementTypeMirror(VariableElement field) {
+        if (!Utils.isRealmList(field)) {
+            return null;
+        }
+        return ((DeclaredType) field.asType()).getTypeArguments().get(0);
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 5d08a68c25..24d20531cd 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -164,11 +164,51 @@ public static boolean isRealmList(VariableElement field) {
         return typeUtils.isAssignable(field.asType(), realmList);
     }
 
+    /**
+     * @param field {@link VariableElement} of a value list field.
+     * @return element type of the list field.
+     */
+    public static Constants.RealmFieldType getValueListFieldType(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        return Constants.LIST_ELEMENT_TYPE_TO_REALM_TYPES.get(elementTypeMirror.toString());
+    }
+
+    /**
+     * @return {@code true} if a given field type is {@code RealmList} and its element type is {@Code RealmObject},
+     * {@code false} otherwise.
+     */
+    public static boolean isRealmModelList(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        if (elementTypeMirror == null) {
+            return false;
+        }
+        return isRealmModel(elementTypeMirror);
+    }
+
+    /**
+     * @return {@code true} if a given field type is {@code RealmList} and its element type is value type,
+     * {@code false} otherwise.
+     */
+    public static boolean isRealmValueList(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        if (elementTypeMirror == null) {
+            return false;
+        }
+        return !isRealmModel(elementTypeMirror);
+    }
+
     /**
      * @return {@code true} if a given field type is {@code RealmModel}, {@code false} otherwise.
      */
-    public static boolean isRealmModel(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmModel);
+    public static boolean isRealmModel(Element field) {
+        return isRealmModel(field.asType());
+    }
+
+    /**
+     * @return {@code true} if a given type is {@code RealmModel}, {@code false} otherwise.
+     */
+    public static boolean isRealmModel(TypeMirror type) {
+        return typeUtils.isAssignable(type, realmModel);
     }
 
     public static boolean isRealmResults(VariableElement field) {
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
index 193a0804f9..76a8f61ffd 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
@@ -25,6 +25,7 @@
 import javax.lang.model.element.Modifier;
 import javax.tools.JavaFileObject;
 
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static org.truth0.Truth.ASSERT;
 
@@ -32,6 +33,7 @@
 public class RealmBacklinkProcessorTest {
     private final JavaFileObject backlinks = JavaFileObjects.forResource("some/test/Backlinks.java");
     private final JavaFileObject backlinksTarget = JavaFileObjects.forResource("some/test/BacklinkTarget.java");
+    private final JavaFileObject invalidResultsValueType = JavaFileObjects.forResource("some/test/InvalidResultsElementType.java");
 
     @Test
     public void compileBacklinks() {
@@ -202,4 +204,12 @@ public void failsOnLinkingObjectsWithFieldWrongType() throws IOException {
                     .hasGetter(false)
                     .hasSetter(false);
     }
+
+    @Test
+    public void failToCompileInvalidResultsElementType() {
+        ASSERT.about(javaSource())
+                .that(invalidResultsValueType)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java
new file mode 100644
index 0000000000..1cb0bf9bb9
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import javax.tools.JavaFileObject;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static org.truth0.Truth.ASSERT;
+
+
+public class ValueListProcessorTest {
+    private final JavaFileObject valueList = JavaFileObjects.forResource("some/test/ValueList.java");
+    private final JavaFileObject invalidListValueType = JavaFileObjects.forResource("some/test/InvalidListElementType.java");
+
+    @Test
+    @Ignore("need to implement primitive list support in realm-library")
+    public void compileValueList() {
+        ASSERT.about(javaSource())
+                .that(valueList)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failToCompileInvalidListElementType() {
+        ASSERT.about(javaSource())
+                .that(invalidListValueType)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 3a914bf064..72a21aa73c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -34,7 +34,7 @@
 
 @SuppressWarnings("all")
 public class AllTypesRealmProxy extends some.test.AllTypes
-    implements RealmObjectProxy, AllTypesRealmProxyInterface {
+        implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
     static final class AllTypesColumnInfo extends ColumnInfo {
         long columnStringIndex;
@@ -47,9 +47,19 @@
         long columnMutableRealmIntegerIndex;
         long columnObjectIndex;
         long columnRealmListIndex;
+        long columnStringListIndex;
+        long columnBinaryListIndex;
+        long columnBooleanListIndex;
+        long columnLongListIndex;
+        long columnIntegerListIndex;
+        long columnShortListIndex;
+        long columnByteListIndex;
+        long columnDoubleListIndex;
+        long columnFloatListIndex;
+        long columnDateListIndex;
 
         AllTypesColumnInfo(OsSchemaInfo schemaInfo) {
-            super(10);
+            super(20);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("AllTypes");
             this.columnStringIndex = addColumnDetails("columnString", objectSchemaInfo);
             this.columnLongIndex = addColumnDetails("columnLong", objectSchemaInfo);
@@ -61,6 +71,16 @@
             this.columnMutableRealmIntegerIndex = addColumnDetails("columnMutableRealmInteger", objectSchemaInfo);
             this.columnObjectIndex = addColumnDetails("columnObject", objectSchemaInfo);
             this.columnRealmListIndex = addColumnDetails("columnRealmList", objectSchemaInfo);
+            this.columnStringListIndex = addColumnDetails("columnStringList", objectSchemaInfo);
+            this.columnBinaryListIndex = addColumnDetails("columnBinaryList", objectSchemaInfo);
+            this.columnBooleanListIndex = addColumnDetails("columnBooleanList", objectSchemaInfo);
+            this.columnLongListIndex = addColumnDetails("columnLongList", objectSchemaInfo);
+            this.columnIntegerListIndex = addColumnDetails("columnIntegerList", objectSchemaInfo);
+            this.columnShortListIndex = addColumnDetails("columnShortList", objectSchemaInfo);
+            this.columnByteListIndex = addColumnDetails("columnByteList", objectSchemaInfo);
+            this.columnDoubleListIndex = addColumnDetails("columnDoubleList", objectSchemaInfo);
+            this.columnFloatListIndex = addColumnDetails("columnFloatList", objectSchemaInfo);
+            this.columnDateListIndex = addColumnDetails("columnDateList", objectSchemaInfo);
             addBacklinkDetails(schemaInfo, "parentObjects", "AllTypes", "columnObject");
         }
 
@@ -88,6 +108,16 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
             dst.columnObjectIndex = src.columnObjectIndex;
             dst.columnRealmListIndex = src.columnRealmListIndex;
+            dst.columnStringListIndex = src.columnStringListIndex;
+            dst.columnBinaryListIndex = src.columnBinaryListIndex;
+            dst.columnBooleanListIndex = src.columnBooleanListIndex;
+            dst.columnLongListIndex = src.columnLongListIndex;
+            dst.columnIntegerListIndex = src.columnIntegerListIndex;
+            dst.columnShortListIndex = src.columnShortListIndex;
+            dst.columnByteListIndex = src.columnByteListIndex;
+            dst.columnDoubleListIndex = src.columnDoubleListIndex;
+            dst.columnFloatListIndex = src.columnFloatListIndex;
+            dst.columnDateListIndex = src.columnDateListIndex;
         }
     }
 
@@ -105,16 +135,36 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         fieldNames.add("columnMutableRealmInteger");
         fieldNames.add("columnObject");
         fieldNames.add("columnRealmList");
+        fieldNames.add("columnStringList");
+        fieldNames.add("columnBinaryList");
+        fieldNames.add("columnBooleanList");
+        fieldNames.add("columnLongList");
+        fieldNames.add("columnIntegerList");
+        fieldNames.add("columnShortList");
+        fieldNames.add("columnByteList");
+        fieldNames.add("columnDoubleList");
+        fieldNames.add("columnFloatList");
+        fieldNames.add("columnDateList");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
     private AllTypesColumnInfo columnInfo;
     private ProxyState<some.test.AllTypes> proxyState;
     private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
-                @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
-                @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
-            };
+        @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
+        @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
+    };
     private RealmList<some.test.AllTypes> columnRealmListRealmList;
+    private RealmList<String> columnStringListRealmList;
+    private RealmList<byte[]> columnBinaryListRealmList;
+    private RealmList<Boolean> columnBooleanListRealmList;
+    private RealmList<Long> columnLongListRealmList;
+    private RealmList<Integer> columnIntegerListRealmList;
+    private RealmList<Short> columnShortListRealmList;
+    private RealmList<Byte> columnByteListRealmList;
+    private RealmList<Double> columnDoubleListRealmList;
+    private RealmList<Float> columnFloatListRealmList;
+    private RealmList<Date> columnDateListRealmList;
     private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
 
     AllTypesRealmProxy() {
@@ -361,7 +411,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         if (columnRealmListRealmList != null) {
             return columnRealmListRealmList;
         } else {
-            OsList osList = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
+            OsList osList = proxyState.getRow$realm().getModelList(columnInfo.columnRealmListIndex);
             columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, osList, proxyState.getRealm$realm());
             return columnRealmListRealmList;
         }
@@ -376,6 +426,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
                 return;
             }
+            // if the list contains unmanaged RealmObjects, convert them to managed.
             if (value != null && !value.isManaged()) {
                 final Realm realm = (Realm) proxyState.getRealm$realm();
                 final RealmList<some.test.AllTypes> original = value;
@@ -391,12 +442,12 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
 
         proxyState.getRealm$realm().checkIfValid();
-        OsList osList = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
+        OsList osList = proxyState.getRow$realm().getModelList(columnInfo.columnRealmListIndex);
         osList.removeAll();
         if (value == null) {
             return;
         }
-        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
+        for (RealmModel linkedObject : value) {
             if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                 throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
             }
@@ -407,6 +458,396 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
     }
 
+    @Override
+    public RealmList<String> realmGet$columnStringList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnStringListRealmList != null) {
+            return columnStringListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnStringListIndex, RealmFieldType.STRING_LIST);
+            columnStringListRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return columnStringListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnStringList(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnStringList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnStringListIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.String item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addString(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<byte[]> realmGet$columnBinaryList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnBinaryListRealmList != null) {
+            return columnBinaryListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBinaryListIndex, RealmFieldType.BINARY_LIST);
+            columnBinaryListRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return columnBinaryListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnBinaryList(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnBinaryList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBinaryListIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (byte[] item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBinary(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$columnBooleanList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnBooleanListRealmList != null) {
+            return columnBooleanListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBooleanListIndex, RealmFieldType.BOOLEAN_LIST);
+            columnBooleanListRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return columnBooleanListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnBooleanList(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnBooleanList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBooleanListIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBoolean(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Long> realmGet$columnLongList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnLongListRealmList != null) {
+            return columnLongListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnLongListIndex, RealmFieldType.INTEGER_LIST);
+            columnLongListRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return columnLongListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnLongList(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnLongList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnLongListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$columnIntegerList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnIntegerListRealmList != null) {
+            return columnIntegerListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnIntegerListIndex, RealmFieldType.INTEGER_LIST);
+            columnIntegerListRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return columnIntegerListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnIntegerList(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnIntegerList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnIntegerListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Short> realmGet$columnShortList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnShortListRealmList != null) {
+            return columnShortListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnShortListIndex, RealmFieldType.INTEGER_LIST);
+            columnShortListRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return columnShortListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnShortList(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnShortList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnShortListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$columnByteList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnByteListRealmList != null) {
+            return columnByteListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnByteListIndex, RealmFieldType.INTEGER_LIST);
+            columnByteListRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return columnByteListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnByteList(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnByteList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnByteListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Double> realmGet$columnDoubleList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnDoubleListRealmList != null) {
+            return columnDoubleListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDoubleListIndex, RealmFieldType.DOUBLE_LIST);
+            columnDoubleListRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return columnDoubleListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnDoubleList(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnDoubleList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDoubleListIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Float> realmGet$columnFloatList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnFloatListRealmList != null) {
+            return columnFloatListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnFloatListIndex, RealmFieldType.FLOAT_LIST);
+            columnFloatListRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return columnFloatListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnFloatList(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnFloatList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnFloatListIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addFloat(item.floatValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Date> realmGet$columnDateList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnDateListRealmList != null) {
+            return columnDateListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDateListIndex, RealmFieldType.DATE_LIST);
+            columnDateListRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return columnDateListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnDateList(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnDateList")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDateListIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.util.Date item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDate(item);
+            }
+        }
+    }
+
     @Override
     public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
         BaseRealm realm = proxyState.getRealm$realm();
@@ -430,6 +871,16 @@ private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         builder.addPersistedProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
         builder.addPersistedLinkProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
         builder.addPersistedLinkProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
+        builder.addPersistedValueListProperty("columnStringList", RealmFieldType.STRING_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnBinaryList", RealmFieldType.BINARY_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnBooleanList", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnLongList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnIntegerList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnShortList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnByteList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnDoubleList", RealmFieldType.DOUBLE_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnFloatList", RealmFieldType.FLOAT_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnDateList", RealmFieldType.DATE_LIST, !Property.REQUIRED);
         builder.addComputedLinkProperty("parentObjects", "AllTypes", "columnObject");
         return builder.build();
     }
@@ -452,8 +903,8 @@ public static String getTableName() {
 
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
-        throws JSONException {
-        final List<String> excludeFields = new ArrayList<String>(2);
+            throws JSONException {
+        final List<String> excludeFields = new ArrayList<String>(12);
         some.test.AllTypes obj = null;
         if (update) {
             Table table = realm.getTable(some.test.AllTypes.class);
@@ -479,8 +930,38 @@ public static String getTableName() {
             if (json.has("columnObject")) {
                 excludeFields.add("columnObject");
             }
-            if (json.has("columnRealmList")) {
-                excludeFields.add("columnRealmList");
+            if (json.has("columnRealmList")) {
+                excludeFields.add("columnRealmList");
+            }
+            if (json.has("columnStringList")) {
+                excludeFields.add("columnStringList");
+            }
+            if (json.has("columnBinaryList")) {
+                excludeFields.add("columnBinaryList");
+            }
+            if (json.has("columnBooleanList")) {
+                excludeFields.add("columnBooleanList");
+            }
+            if (json.has("columnLongList")) {
+                excludeFields.add("columnLongList");
+            }
+            if (json.has("columnIntegerList")) {
+                excludeFields.add("columnIntegerList");
+            }
+            if (json.has("columnShortList")) {
+                excludeFields.add("columnShortList");
+            }
+            if (json.has("columnByteList")) {
+                excludeFields.add("columnByteList");
+            }
+            if (json.has("columnDoubleList")) {
+                excludeFields.add("columnDoubleList");
+            }
+            if (json.has("columnFloatList")) {
+                excludeFields.add("columnFloatList");
+            }
+            if (json.has("columnDateList")) {
+                excludeFields.add("columnDateList");
             }
             if (json.has("columnString")) {
                 if (json.isNull("columnString")) {
@@ -564,13 +1045,23 @@ public static String getTableName() {
                 }
             }
         }
+        // TODO implement logic for value listcolumnStringList.
+        // TODO implement logic for value listcolumnBinaryList.
+        // TODO implement logic for value listcolumnBooleanList.
+        // TODO implement logic for value listcolumnLongList.
+        // TODO implement logic for value listcolumnIntegerList.
+        // TODO implement logic for value listcolumnShortList.
+        // TODO implement logic for value listcolumnByteList.
+        // TODO implement logic for value listcolumnDoubleList.
+        // TODO implement logic for value listcolumnFloatList.
+        // TODO implement logic for value listcolumnDateList.
         return obj;
     }
 
     @SuppressWarnings("cast")
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
-        throws IOException {
+            throws IOException {
         boolean jsonHasPrimaryKey = false;
         final some.test.AllTypes obj = new some.test.AllTypes();
         final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
@@ -636,7 +1127,7 @@ public static String getTableName() {
             } else if (name.equals("columnMutableRealmInteger")) {
                 Long val = null;
                 if (reader.peek() != JsonToken.NULL) {
-                    val = reader.nextLong()
+                    val = reader.nextLong();
                 } else {
                     reader.skipValue();
                 }
@@ -662,6 +1153,26 @@ public static String getTableName() {
                     }
                     reader.endArray();
                 }
+            } else if (name.equals("columnStringList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnBinaryList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnBooleanList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnLongList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnIntegerList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnShortList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnByteList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnDoubleList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnFloatList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnDateList")) {
+                // TODO implement logic for value list.
             } else {
                 reader.skipValue();
             }
@@ -767,6 +1278,16 @@ public static String getTableName() {
             }
         }
 
+        realmObjectCopy.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
+        realmObjectCopy.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
+        realmObjectCopy.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
+        realmObjectCopy.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
+        realmObjectCopy.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
+        realmObjectCopy.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
+        realmObjectCopy.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
+        realmObjectCopy.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
+        realmObjectCopy.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
+        realmObjectCopy.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
         return realmObject;
     }
 
@@ -828,6 +1349,126 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
                 columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
             }
         }
+
+        RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+        if (columnStringListList != null) {
+            OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+            for (java.lang.String columnStringListItem : columnStringListList) {
+                if (columnStringListItem == null) {
+                    columnStringListOsList.addNull();
+                } else {
+                    columnStringListOsList.addString(columnStringListItem);
+                }
+            }
+        }
+
+        RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+        if (columnBinaryListList != null) {
+            OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+            for (byte[] columnBinaryListItem : columnBinaryListList) {
+                if (columnBinaryListItem == null) {
+                    columnBinaryListOsList.addNull();
+                } else {
+                    columnBinaryListOsList.addBinary(columnBinaryListItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+        if (columnBooleanListList != null) {
+            OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+            for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                if (columnBooleanListItem == null) {
+                    columnBooleanListOsList.addNull();
+                } else {
+                    columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+        if (columnLongListList != null) {
+            OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+            for (java.lang.Long columnLongListItem : columnLongListList) {
+                if (columnLongListItem == null) {
+                    columnLongListOsList.addNull();
+                } else {
+                    columnLongListOsList.addLong(columnLongListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+        if (columnIntegerListList != null) {
+            OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+            for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                if (columnIntegerListItem == null) {
+                    columnIntegerListOsList.addNull();
+                } else {
+                    columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+        if (columnShortListList != null) {
+            OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+            for (java.lang.Short columnShortListItem : columnShortListList) {
+                if (columnShortListItem == null) {
+                    columnShortListOsList.addNull();
+                } else {
+                    columnShortListOsList.addLong(columnShortListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+        if (columnByteListList != null) {
+            OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+            for (java.lang.Byte columnByteListItem : columnByteListList) {
+                if (columnByteListItem == null) {
+                    columnByteListOsList.addNull();
+                } else {
+                    columnByteListOsList.addLong(columnByteListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+        if (columnDoubleListList != null) {
+            OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+            for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                if (columnDoubleListItem == null) {
+                    columnDoubleListOsList.addNull();
+                } else {
+                    columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+        if (columnFloatListList != null) {
+            OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+            for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                if (columnFloatListItem == null) {
+                    columnFloatListOsList.addNull();
+                } else {
+                    columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                }
+            }
+        }
+
+        RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+        if (columnDateListList != null) {
+            OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+            for (java.util.Date columnDateListItem : columnDateListList) {
+                if (columnDateListItem == null) {
+                    columnDateListOsList.addNull();
+                } else {
+                    columnDateListOsList.addDate(columnDateListItem);
+                }
+            }
+        }
         return rowIndex;
     }
 
@@ -896,6 +1537,126 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
                 }
             }
+
+            RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+            if (columnStringListList != null) {
+                OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+                for (java.lang.String columnStringListItem : columnStringListList) {
+                    if (columnStringListItem == null) {
+                        columnStringListOsList.addNull();
+                    } else {
+                        columnStringListOsList.addString(columnStringListItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+            if (columnBinaryListList != null) {
+                OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+                for (byte[] columnBinaryListItem : columnBinaryListList) {
+                    if (columnBinaryListItem == null) {
+                        columnBinaryListOsList.addNull();
+                    } else {
+                        columnBinaryListOsList.addBinary(columnBinaryListItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+            if (columnBooleanListList != null) {
+                OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+                for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                    if (columnBooleanListItem == null) {
+                        columnBooleanListOsList.addNull();
+                    } else {
+                        columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+            if (columnLongListList != null) {
+                OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+                for (java.lang.Long columnLongListItem : columnLongListList) {
+                    if (columnLongListItem == null) {
+                        columnLongListOsList.addNull();
+                    } else {
+                        columnLongListOsList.addLong(columnLongListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+            if (columnIntegerListList != null) {
+                OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+                for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                    if (columnIntegerListItem == null) {
+                        columnIntegerListOsList.addNull();
+                    } else {
+                        columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+            if (columnShortListList != null) {
+                OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+                for (java.lang.Short columnShortListItem : columnShortListList) {
+                    if (columnShortListItem == null) {
+                        columnShortListOsList.addNull();
+                    } else {
+                        columnShortListOsList.addLong(columnShortListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+            if (columnByteListList != null) {
+                OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+                for (java.lang.Byte columnByteListItem : columnByteListList) {
+                    if (columnByteListItem == null) {
+                        columnByteListOsList.addNull();
+                    } else {
+                        columnByteListOsList.addLong(columnByteListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+            if (columnDoubleListList != null) {
+                OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+                for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                    if (columnDoubleListItem == null) {
+                        columnDoubleListOsList.addNull();
+                    } else {
+                        columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+            if (columnFloatListList != null) {
+                OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+                for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                    if (columnFloatListItem == null) {
+                        columnFloatListOsList.addNull();
+                    } else {
+                        columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                    }
+                }
+            }
+
+            RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+            if (columnDateListList != null) {
+                OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+                for (java.util.Date columnDateListItem : columnDateListList) {
+                    if (columnDateListItem == null) {
+                        columnDateListOsList.addNull();
+                    } else {
+                        columnDateListOsList.addDate(columnDateListItem);
+                    }
+                }
+            }
         }
     }
 
@@ -965,6 +1726,146 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             }
         }
 
+
+        OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+        columnStringListOsList.removeAll();
+        RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+        if (columnStringListList != null) {
+            for (java.lang.String columnStringListItem : columnStringListList) {
+                if (columnStringListItem == null) {
+                    columnStringListOsList.addNull();
+                } else {
+                    columnStringListOsList.addString(columnStringListItem);
+                }
+            }
+        }
+
+
+        OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+        columnBinaryListOsList.removeAll();
+        RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+        if (columnBinaryListList != null) {
+            for (byte[] columnBinaryListItem : columnBinaryListList) {
+                if (columnBinaryListItem == null) {
+                    columnBinaryListOsList.addNull();
+                } else {
+                    columnBinaryListOsList.addBinary(columnBinaryListItem);
+                }
+            }
+        }
+
+
+        OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+        columnBooleanListOsList.removeAll();
+        RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+        if (columnBooleanListList != null) {
+            for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                if (columnBooleanListItem == null) {
+                    columnBooleanListOsList.addNull();
+                } else {
+                    columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                }
+            }
+        }
+
+
+        OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+        columnLongListOsList.removeAll();
+        RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+        if (columnLongListList != null) {
+            for (java.lang.Long columnLongListItem : columnLongListList) {
+                if (columnLongListItem == null) {
+                    columnLongListOsList.addNull();
+                } else {
+                    columnLongListOsList.addLong(columnLongListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+        columnIntegerListOsList.removeAll();
+        RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+        if (columnIntegerListList != null) {
+            for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                if (columnIntegerListItem == null) {
+                    columnIntegerListOsList.addNull();
+                } else {
+                    columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+        columnShortListOsList.removeAll();
+        RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+        if (columnShortListList != null) {
+            for (java.lang.Short columnShortListItem : columnShortListList) {
+                if (columnShortListItem == null) {
+                    columnShortListOsList.addNull();
+                } else {
+                    columnShortListOsList.addLong(columnShortListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+        columnByteListOsList.removeAll();
+        RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+        if (columnByteListList != null) {
+            for (java.lang.Byte columnByteListItem : columnByteListList) {
+                if (columnByteListItem == null) {
+                    columnByteListOsList.addNull();
+                } else {
+                    columnByteListOsList.addLong(columnByteListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+        columnDoubleListOsList.removeAll();
+        RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+        if (columnDoubleListList != null) {
+            for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                if (columnDoubleListItem == null) {
+                    columnDoubleListOsList.addNull();
+                } else {
+                    columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                }
+            }
+        }
+
+
+        OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+        columnFloatListOsList.removeAll();
+        RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+        if (columnFloatListList != null) {
+            for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                if (columnFloatListItem == null) {
+                    columnFloatListOsList.addNull();
+                } else {
+                    columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                }
+            }
+        }
+
+
+        OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+        columnDateListOsList.removeAll();
+        RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+        if (columnDateListList != null) {
+            for (java.util.Date columnDateListItem : columnDateListList) {
+                if (columnDateListItem == null) {
+                    columnDateListOsList.addNull();
+                } else {
+                    columnDateListOsList.addDate(columnDateListItem);
+                }
+            }
+        }
+
         return rowIndex;
     }
 
@@ -1041,6 +1942,146 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 }
             }
 
+
+            OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+            columnStringListOsList.removeAll();
+            RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+            if (columnStringListList != null) {
+                for (java.lang.String columnStringListItem : columnStringListList) {
+                    if (columnStringListItem == null) {
+                        columnStringListOsList.addNull();
+                    } else {
+                        columnStringListOsList.addString(columnStringListItem);
+                    }
+                }
+            }
+
+
+            OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+            columnBinaryListOsList.removeAll();
+            RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+            if (columnBinaryListList != null) {
+                for (byte[] columnBinaryListItem : columnBinaryListList) {
+                    if (columnBinaryListItem == null) {
+                        columnBinaryListOsList.addNull();
+                    } else {
+                        columnBinaryListOsList.addBinary(columnBinaryListItem);
+                    }
+                }
+            }
+
+
+            OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+            columnBooleanListOsList.removeAll();
+            RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+            if (columnBooleanListList != null) {
+                for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                    if (columnBooleanListItem == null) {
+                        columnBooleanListOsList.addNull();
+                    } else {
+                        columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                    }
+                }
+            }
+
+
+            OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+            columnLongListOsList.removeAll();
+            RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+            if (columnLongListList != null) {
+                for (java.lang.Long columnLongListItem : columnLongListList) {
+                    if (columnLongListItem == null) {
+                        columnLongListOsList.addNull();
+                    } else {
+                        columnLongListOsList.addLong(columnLongListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+            columnIntegerListOsList.removeAll();
+            RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+            if (columnIntegerListList != null) {
+                for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                    if (columnIntegerListItem == null) {
+                        columnIntegerListOsList.addNull();
+                    } else {
+                        columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+            columnShortListOsList.removeAll();
+            RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+            if (columnShortListList != null) {
+                for (java.lang.Short columnShortListItem : columnShortListList) {
+                    if (columnShortListItem == null) {
+                        columnShortListOsList.addNull();
+                    } else {
+                        columnShortListOsList.addLong(columnShortListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+            columnByteListOsList.removeAll();
+            RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+            if (columnByteListList != null) {
+                for (java.lang.Byte columnByteListItem : columnByteListList) {
+                    if (columnByteListItem == null) {
+                        columnByteListOsList.addNull();
+                    } else {
+                        columnByteListOsList.addLong(columnByteListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+            columnDoubleListOsList.removeAll();
+            RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+            if (columnDoubleListList != null) {
+                for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                    if (columnDoubleListItem == null) {
+                        columnDoubleListOsList.addNull();
+                    } else {
+                        columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+            columnFloatListOsList.removeAll();
+            RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+            if (columnFloatListList != null) {
+                for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                    if (columnFloatListItem == null) {
+                        columnFloatListOsList.addNull();
+                    } else {
+                        columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                    }
+                }
+            }
+
+
+            OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+            columnDateListOsList.removeAll();
+            RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+            if (columnDateListList != null) {
+                for (java.util.Date columnDateListItem : columnDateListList) {
+                    if (columnDateListItem == null) {
+                        columnDateListOsList.addNull();
+                    } else {
+                        columnDateListOsList.addDate(columnDateListItem);
+                    }
+                }
+            }
+
         }
     }
 
@@ -1089,6 +2130,37 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 unmanagedcolumnRealmListList.add(item);
             }
         }
+
+        unmanagedCopy.realmSet$columnStringList(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$columnStringList().addAll(realmSource.realmGet$columnStringList());
+
+        unmanagedCopy.realmSet$columnBinaryList(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$columnBinaryList().addAll(realmSource.realmGet$columnBinaryList());
+
+        unmanagedCopy.realmSet$columnBooleanList(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$columnBooleanList().addAll(realmSource.realmGet$columnBooleanList());
+
+        unmanagedCopy.realmSet$columnLongList(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$columnLongList().addAll(realmSource.realmGet$columnLongList());
+
+        unmanagedCopy.realmSet$columnIntegerList(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$columnIntegerList().addAll(realmSource.realmGet$columnIntegerList());
+
+        unmanagedCopy.realmSet$columnShortList(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$columnShortList().addAll(realmSource.realmGet$columnShortList());
+
+        unmanagedCopy.realmSet$columnByteList(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$columnByteList().addAll(realmSource.realmGet$columnByteList());
+
+        unmanagedCopy.realmSet$columnDoubleList(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$columnDoubleList().addAll(realmSource.realmGet$columnDoubleList());
+
+        unmanagedCopy.realmSet$columnFloatList(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$columnFloatList().addAll(realmSource.realmGet$columnFloatList());
+
+        unmanagedCopy.realmSet$columnDateList(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$columnDateList().addAll(realmSource.realmGet$columnDateList());
+
         return unmanagedObject;
     }
 
@@ -1127,6 +2199,16 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 }
             }
         }
+        realmObjectTarget.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
+        realmObjectTarget.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
+        realmObjectTarget.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
+        realmObjectTarget.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
+        realmObjectTarget.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
+        realmObjectTarget.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
+        realmObjectTarget.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
+        realmObjectTarget.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
+        realmObjectTarget.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
+        realmObjectTarget.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
         return realmObject;
     }
 
@@ -1176,6 +2258,46 @@ public String toString() {
         stringBuilder.append("{columnRealmList:");
         stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
         stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnStringList:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$columnStringList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBinaryList:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$columnBinaryList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBooleanList:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$columnBooleanList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnLongList:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$columnLongList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnIntegerList:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$columnIntegerList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnShortList:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$columnShortList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnByteList:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$columnByteList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDoubleList:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$columnDoubleList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnFloatList:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$columnFloatList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDateList:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$columnDateList().size()).append("]");
+        stringBuilder.append("}");
         stringBuilder.append("]");
         return stringBuilder.toString();
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index ccacda2a95..43544b3e1e 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -57,9 +57,29 @@
         long fieldDateNotNullIndex;
         long fieldDateNullIndex;
         long fieldObjectNullIndex;
+        long fieldStringListNotNullIndex;
+        long fieldStringListNullIndex;
+        long fieldBinaryListNotNullIndex;
+        long fieldBinaryListNullIndex;
+        long fieldBooleanListNotNullIndex;
+        long fieldBooleanListNullIndex;
+        long fieldLongListNotNullIndex;
+        long fieldLongListNullIndex;
+        long fieldIntegerListNotNullIndex;
+        long fieldIntegerListNullIndex;
+        long fieldShortListNotNullIndex;
+        long fieldShortListNullIndex;
+        long fieldByteListNotNullIndex;
+        long fieldByteListNullIndex;
+        long fieldDoubleListNotNullIndex;
+        long fieldDoubleListNullIndex;
+        long fieldFloatListNotNullIndex;
+        long fieldFloatListNullIndex;
+        long fieldDateListNotNullIndex;
+        long fieldDateListNullIndex;
 
         NullTypesColumnInfo(OsSchemaInfo schemaInfo) {
-            super(21);
+            super(41);
             OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NullTypes");
             this.fieldStringNotNullIndex = addColumnDetails("fieldStringNotNull", objectSchemaInfo);
             this.fieldStringNullIndex = addColumnDetails("fieldStringNull", objectSchemaInfo);
@@ -82,6 +102,26 @@
             this.fieldDateNotNullIndex = addColumnDetails("fieldDateNotNull", objectSchemaInfo);
             this.fieldDateNullIndex = addColumnDetails("fieldDateNull", objectSchemaInfo);
             this.fieldObjectNullIndex = addColumnDetails("fieldObjectNull", objectSchemaInfo);
+            this.fieldStringListNotNullIndex = addColumnDetails("fieldStringListNotNull", objectSchemaInfo);
+            this.fieldStringListNullIndex = addColumnDetails("fieldStringListNull", objectSchemaInfo);
+            this.fieldBinaryListNotNullIndex = addColumnDetails("fieldBinaryListNotNull", objectSchemaInfo);
+            this.fieldBinaryListNullIndex = addColumnDetails("fieldBinaryListNull", objectSchemaInfo);
+            this.fieldBooleanListNotNullIndex = addColumnDetails("fieldBooleanListNotNull", objectSchemaInfo);
+            this.fieldBooleanListNullIndex = addColumnDetails("fieldBooleanListNull", objectSchemaInfo);
+            this.fieldLongListNotNullIndex = addColumnDetails("fieldLongListNotNull", objectSchemaInfo);
+            this.fieldLongListNullIndex = addColumnDetails("fieldLongListNull", objectSchemaInfo);
+            this.fieldIntegerListNotNullIndex = addColumnDetails("fieldIntegerListNotNull", objectSchemaInfo);
+            this.fieldIntegerListNullIndex = addColumnDetails("fieldIntegerListNull", objectSchemaInfo);
+            this.fieldShortListNotNullIndex = addColumnDetails("fieldShortListNotNull", objectSchemaInfo);
+            this.fieldShortListNullIndex = addColumnDetails("fieldShortListNull", objectSchemaInfo);
+            this.fieldByteListNotNullIndex = addColumnDetails("fieldByteListNotNull", objectSchemaInfo);
+            this.fieldByteListNullIndex = addColumnDetails("fieldByteListNull", objectSchemaInfo);
+            this.fieldDoubleListNotNullIndex = addColumnDetails("fieldDoubleListNotNull", objectSchemaInfo);
+            this.fieldDoubleListNullIndex = addColumnDetails("fieldDoubleListNull", objectSchemaInfo);
+            this.fieldFloatListNotNullIndex = addColumnDetails("fieldFloatListNotNull", objectSchemaInfo);
+            this.fieldFloatListNullIndex = addColumnDetails("fieldFloatListNull", objectSchemaInfo);
+            this.fieldDateListNotNullIndex = addColumnDetails("fieldDateListNotNull", objectSchemaInfo);
+            this.fieldDateListNullIndex = addColumnDetails("fieldDateListNull", objectSchemaInfo);
         }
 
         NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
@@ -119,6 +159,26 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
             dst.fieldDateNotNullIndex = src.fieldDateNotNullIndex;
             dst.fieldDateNullIndex = src.fieldDateNullIndex;
             dst.fieldObjectNullIndex = src.fieldObjectNullIndex;
+            dst.fieldStringListNotNullIndex = src.fieldStringListNotNullIndex;
+            dst.fieldStringListNullIndex = src.fieldStringListNullIndex;
+            dst.fieldBinaryListNotNullIndex = src.fieldBinaryListNotNullIndex;
+            dst.fieldBinaryListNullIndex = src.fieldBinaryListNullIndex;
+            dst.fieldBooleanListNotNullIndex = src.fieldBooleanListNotNullIndex;
+            dst.fieldBooleanListNullIndex = src.fieldBooleanListNullIndex;
+            dst.fieldLongListNotNullIndex = src.fieldLongListNotNullIndex;
+            dst.fieldLongListNullIndex = src.fieldLongListNullIndex;
+            dst.fieldIntegerListNotNullIndex = src.fieldIntegerListNotNullIndex;
+            dst.fieldIntegerListNullIndex = src.fieldIntegerListNullIndex;
+            dst.fieldShortListNotNullIndex = src.fieldShortListNotNullIndex;
+            dst.fieldShortListNullIndex = src.fieldShortListNullIndex;
+            dst.fieldByteListNotNullIndex = src.fieldByteListNotNullIndex;
+            dst.fieldByteListNullIndex = src.fieldByteListNullIndex;
+            dst.fieldDoubleListNotNullIndex = src.fieldDoubleListNotNullIndex;
+            dst.fieldDoubleListNullIndex = src.fieldDoubleListNullIndex;
+            dst.fieldFloatListNotNullIndex = src.fieldFloatListNotNullIndex;
+            dst.fieldFloatListNullIndex = src.fieldFloatListNullIndex;
+            dst.fieldDateListNotNullIndex = src.fieldDateListNotNullIndex;
+            dst.fieldDateListNullIndex = src.fieldDateListNullIndex;
         }
     }
 
@@ -147,11 +207,51 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         fieldNames.add("fieldDateNotNull");
         fieldNames.add("fieldDateNull");
         fieldNames.add("fieldObjectNull");
+        fieldNames.add("fieldStringListNotNull");
+        fieldNames.add("fieldStringListNull");
+        fieldNames.add("fieldBinaryListNotNull");
+        fieldNames.add("fieldBinaryListNull");
+        fieldNames.add("fieldBooleanListNotNull");
+        fieldNames.add("fieldBooleanListNull");
+        fieldNames.add("fieldLongListNotNull");
+        fieldNames.add("fieldLongListNull");
+        fieldNames.add("fieldIntegerListNotNull");
+        fieldNames.add("fieldIntegerListNull");
+        fieldNames.add("fieldShortListNotNull");
+        fieldNames.add("fieldShortListNull");
+        fieldNames.add("fieldByteListNotNull");
+        fieldNames.add("fieldByteListNull");
+        fieldNames.add("fieldDoubleListNotNull");
+        fieldNames.add("fieldDoubleListNull");
+        fieldNames.add("fieldFloatListNotNull");
+        fieldNames.add("fieldFloatListNull");
+        fieldNames.add("fieldDateListNotNull");
+        fieldNames.add("fieldDateListNull");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
     private NullTypesColumnInfo columnInfo;
     private ProxyState<some.test.NullTypes> proxyState;
+    private RealmList<String> fieldStringListNotNullRealmList;
+    private RealmList<String> fieldStringListNullRealmList;
+    private RealmList<byte[]> fieldBinaryListNotNullRealmList;
+    private RealmList<byte[]> fieldBinaryListNullRealmList;
+    private RealmList<Boolean> fieldBooleanListNotNullRealmList;
+    private RealmList<Boolean> fieldBooleanListNullRealmList;
+    private RealmList<Long> fieldLongListNotNullRealmList;
+    private RealmList<Long> fieldLongListNullRealmList;
+    private RealmList<Integer> fieldIntegerListNotNullRealmList;
+    private RealmList<Integer> fieldIntegerListNullRealmList;
+    private RealmList<Short> fieldShortListNotNullRealmList;
+    private RealmList<Short> fieldShortListNullRealmList;
+    private RealmList<Byte> fieldByteListNotNullRealmList;
+    private RealmList<Byte> fieldByteListNullRealmList;
+    private RealmList<Double> fieldDoubleListNotNullRealmList;
+    private RealmList<Double> fieldDoubleListNullRealmList;
+    private RealmList<Float> fieldFloatListNotNullRealmList;
+    private RealmList<Float> fieldFloatListNullRealmList;
+    private RealmList<Date> fieldDateListNotNullRealmList;
+    private RealmList<Date> fieldDateListNullRealmList;
 
     NullTypesRealmProxy() {
         proxyState.setConstructionFinished();
@@ -823,7 +923,787 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
             throw new IllegalArgumentException("'value' belongs to a different Realm.");
         }
-        proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
+        proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    public RealmList<String> realmGet$fieldStringListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldStringListNotNullRealmList != null) {
+            return fieldStringListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNotNullIndex, RealmFieldType.STRING_LIST);
+            fieldStringListNotNullRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return fieldStringListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldStringListNotNull(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldStringListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNotNullIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.String item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldStringListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addString(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<String> realmGet$fieldStringListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldStringListNullRealmList != null) {
+            return fieldStringListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNullIndex, RealmFieldType.STRING_LIST);
+            fieldStringListNullRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return fieldStringListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldStringListNull(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldStringListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNullIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.String item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addString(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<byte[]> realmGet$fieldBinaryListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBinaryListNotNullRealmList != null) {
+            return fieldBinaryListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNotNullIndex, RealmFieldType.BINARY_LIST);
+            fieldBinaryListNotNullRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return fieldBinaryListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldBinaryListNotNull(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBinaryListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNotNullIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (byte[] item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldBinaryListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addBinary(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<byte[]> realmGet$fieldBinaryListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBinaryListNullRealmList != null) {
+            return fieldBinaryListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNullIndex, RealmFieldType.BINARY_LIST);
+            fieldBinaryListNullRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return fieldBinaryListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldBinaryListNull(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBinaryListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNullIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (byte[] item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBinary(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$fieldBooleanListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBooleanListNotNullRealmList != null) {
+            return fieldBooleanListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNotNullIndex, RealmFieldType.BOOLEAN_LIST);
+            fieldBooleanListNotNullRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return fieldBooleanListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldBooleanListNotNull(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBooleanListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNotNullIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldBooleanListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addBoolean(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$fieldBooleanListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBooleanListNullRealmList != null) {
+            return fieldBooleanListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNullIndex, RealmFieldType.BOOLEAN_LIST);
+            fieldBooleanListNullRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return fieldBooleanListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldBooleanListNull(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBooleanListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNullIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBoolean(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Long> realmGet$fieldLongListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldLongListNotNullRealmList != null) {
+            return fieldLongListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldLongListNotNullRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return fieldLongListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldLongListNotNull(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldLongListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldLongListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Long> realmGet$fieldLongListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldLongListNullRealmList != null) {
+            return fieldLongListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldLongListNullRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return fieldLongListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldLongListNull(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldLongListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$fieldIntegerListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldIntegerListNotNullRealmList != null) {
+            return fieldIntegerListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldIntegerListNotNullRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return fieldIntegerListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldIntegerListNotNull(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldIntegerListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldIntegerListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$fieldIntegerListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldIntegerListNullRealmList != null) {
+            return fieldIntegerListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldIntegerListNullRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return fieldIntegerListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldIntegerListNull(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldIntegerListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Short> realmGet$fieldShortListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldShortListNotNullRealmList != null) {
+            return fieldShortListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldShortListNotNullRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return fieldShortListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldShortListNotNull(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldShortListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldShortListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Short> realmGet$fieldShortListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldShortListNullRealmList != null) {
+            return fieldShortListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldShortListNullRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return fieldShortListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldShortListNull(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldShortListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$fieldByteListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldByteListNotNullRealmList != null) {
+            return fieldByteListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldByteListNotNullRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return fieldByteListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldByteListNotNull(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldByteListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldByteListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$fieldByteListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldByteListNullRealmList != null) {
+            return fieldByteListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldByteListNullRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return fieldByteListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldByteListNull(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldByteListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Double> realmGet$fieldDoubleListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDoubleListNotNullRealmList != null) {
+            return fieldDoubleListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNotNullIndex, RealmFieldType.DOUBLE_LIST);
+            fieldDoubleListNotNullRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return fieldDoubleListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDoubleListNotNull(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDoubleListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNotNullIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldDoubleListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Double> realmGet$fieldDoubleListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDoubleListNullRealmList != null) {
+            return fieldDoubleListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNullIndex, RealmFieldType.DOUBLE_LIST);
+            fieldDoubleListNullRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return fieldDoubleListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDoubleListNull(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDoubleListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNullIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Float> realmGet$fieldFloatListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldFloatListNotNullRealmList != null) {
+            return fieldFloatListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNotNullIndex, RealmFieldType.FLOAT_LIST);
+            fieldFloatListNotNullRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return fieldFloatListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldFloatListNotNull(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldFloatListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNotNullIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldFloatListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addFloat(item.floatValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Float> realmGet$fieldFloatListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldFloatListNullRealmList != null) {
+            return fieldFloatListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNullIndex, RealmFieldType.FLOAT_LIST);
+            fieldFloatListNullRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return fieldFloatListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldFloatListNull(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldFloatListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNullIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addFloat(item.floatValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Date> realmGet$fieldDateListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDateListNotNullRealmList != null) {
+            return fieldDateListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNotNullIndex, RealmFieldType.DATE_LIST);
+            fieldDateListNotNullRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return fieldDateListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDateListNotNull(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDateListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNotNullIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.util.Date item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldDateListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addDate(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Date> realmGet$fieldDateListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDateListNullRealmList != null) {
+            return fieldDateListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNullIndex, RealmFieldType.DATE_LIST);
+            fieldDateListNullRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return fieldDateListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDateListNull(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDateListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNullIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.util.Date item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDate(item);
+            }
+        }
     }
 
     private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
@@ -849,6 +1729,26 @@ private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
         builder.addPersistedProperty("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
         builder.addPersistedProperty("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
         builder.addPersistedLinkProperty("fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
+        builder.addPersistedValueListProperty("fieldStringListNotNull", RealmFieldType.STRING_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldStringListNull", RealmFieldType.STRING_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBinaryListNotNull", RealmFieldType.BINARY_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBinaryListNull", RealmFieldType.BINARY_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBooleanListNotNull", RealmFieldType.BOOLEAN_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBooleanListNull", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldLongListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldLongListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldIntegerListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldIntegerListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldShortListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldShortListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldByteListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldByteListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDoubleListNotNull", RealmFieldType.DOUBLE_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDoubleListNull", RealmFieldType.DOUBLE_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldFloatListNotNull", RealmFieldType.FLOAT_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldFloatListNull", RealmFieldType.FLOAT_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDateListNotNull", RealmFieldType.DATE_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDateListNull", RealmFieldType.DATE_LIST, !Property.REQUIRED);
         return builder.build();
     }
 
@@ -871,11 +1771,72 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        final List<String> excludeFields = new ArrayList<String>(1);
+        final List<String> excludeFields = new ArrayList<String>(21);
         if (json.has("fieldObjectNull")) {
             excludeFields.add("fieldObjectNull");
         }
+        if (json.has("fieldStringListNotNull")) {
+            excludeFields.add("fieldStringListNotNull");
+        }
+        if (json.has("fieldStringListNull")) {
+            excludeFields.add("fieldStringListNull");
+        }
+        if (json.has("fieldBinaryListNotNull")) {
+            excludeFields.add("fieldBinaryListNotNull");
+        }
+        if (json.has("fieldBinaryListNull")) {
+            excludeFields.add("fieldBinaryListNull");
+        }
+        if (json.has("fieldBooleanListNotNull")) {
+            excludeFields.add("fieldBooleanListNotNull");
+        }
+        if (json.has("fieldBooleanListNull")) {
+            excludeFields.add("fieldBooleanListNull");
+        }
+        if (json.has("fieldLongListNotNull")) {
+            excludeFields.add("fieldLongListNotNull");
+        }
+        if (json.has("fieldLongListNull")) {
+            excludeFields.add("fieldLongListNull");
+        }
+        if (json.has("fieldIntegerListNotNull")) {
+            excludeFields.add("fieldIntegerListNotNull");
+        }
+        if (json.has("fieldIntegerListNull")) {
+            excludeFields.add("fieldIntegerListNull");
+        }
+        if (json.has("fieldShortListNotNull")) {
+            excludeFields.add("fieldShortListNotNull");
+        }
+        if (json.has("fieldShortListNull")) {
+            excludeFields.add("fieldShortListNull");
+        }
+        if (json.has("fieldByteListNotNull")) {
+            excludeFields.add("fieldByteListNotNull");
+        }
+        if (json.has("fieldByteListNull")) {
+            excludeFields.add("fieldByteListNull");
+        }
+        if (json.has("fieldDoubleListNotNull")) {
+            excludeFields.add("fieldDoubleListNotNull");
+        }
+        if (json.has("fieldDoubleListNull")) {
+            excludeFields.add("fieldDoubleListNull");
+        }
+        if (json.has("fieldFloatListNotNull")) {
+            excludeFields.add("fieldFloatListNotNull");
+        }
+        if (json.has("fieldFloatListNull")) {
+            excludeFields.add("fieldFloatListNull");
+        }
+        if (json.has("fieldDateListNotNull")) {
+            excludeFields.add("fieldDateListNotNull");
+        }
+        if (json.has("fieldDateListNull")) {
+            excludeFields.add("fieldDateListNull");
+        }
         some.test.NullTypes obj = realm.createObjectInternal(some.test.NullTypes.class, true, excludeFields);
+
         final NullTypesRealmProxyInterface objProxy = (NullTypesRealmProxyInterface) obj;
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
@@ -1035,6 +1996,26 @@ public static String getTableName() {
                 objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
             }
         }
+        // TODO implement logic for value listfieldStringListNotNull.
+        // TODO implement logic for value listfieldStringListNull.
+        // TODO implement logic for value listfieldBinaryListNotNull.
+        // TODO implement logic for value listfieldBinaryListNull.
+        // TODO implement logic for value listfieldBooleanListNotNull.
+        // TODO implement logic for value listfieldBooleanListNull.
+        // TODO implement logic for value listfieldLongListNotNull.
+        // TODO implement logic for value listfieldLongListNull.
+        // TODO implement logic for value listfieldIntegerListNotNull.
+        // TODO implement logic for value listfieldIntegerListNull.
+        // TODO implement logic for value listfieldShortListNotNull.
+        // TODO implement logic for value listfieldShortListNull.
+        // TODO implement logic for value listfieldByteListNotNull.
+        // TODO implement logic for value listfieldByteListNull.
+        // TODO implement logic for value listfieldDoubleListNotNull.
+        // TODO implement logic for value listfieldDoubleListNull.
+        // TODO implement logic for value listfieldFloatListNotNull.
+        // TODO implement logic for value listfieldFloatListNull.
+        // TODO implement logic for value listfieldDateListNotNull.
+        // TODO implement logic for value listfieldDateListNull.
         return obj;
     }
 
@@ -1206,6 +2187,46 @@ public static String getTableName() {
                     some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createUsingJsonStream(realm, reader);
                     objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
                 }
+            } else if (name.equals("fieldStringListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldStringListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBinaryListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBinaryListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBooleanListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBooleanListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldLongListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldLongListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldIntegerListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldIntegerListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldShortListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldShortListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldByteListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldByteListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDoubleListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDoubleListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldFloatListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldFloatListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDateListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDateListNull")) {
+                // TODO implement logic for value list.
             } else {
                 reader.skipValue();
             }
@@ -1278,6 +2299,26 @@ public static String getTableName() {
                 realmObjectCopy.realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
             }
         }
+        realmObjectCopy.realmSet$fieldStringListNotNull(realmObjectSource.realmGet$fieldStringListNotNull());
+        realmObjectCopy.realmSet$fieldStringListNull(realmObjectSource.realmGet$fieldStringListNull());
+        realmObjectCopy.realmSet$fieldBinaryListNotNull(realmObjectSource.realmGet$fieldBinaryListNotNull());
+        realmObjectCopy.realmSet$fieldBinaryListNull(realmObjectSource.realmGet$fieldBinaryListNull());
+        realmObjectCopy.realmSet$fieldBooleanListNotNull(realmObjectSource.realmGet$fieldBooleanListNotNull());
+        realmObjectCopy.realmSet$fieldBooleanListNull(realmObjectSource.realmGet$fieldBooleanListNull());
+        realmObjectCopy.realmSet$fieldLongListNotNull(realmObjectSource.realmGet$fieldLongListNotNull());
+        realmObjectCopy.realmSet$fieldLongListNull(realmObjectSource.realmGet$fieldLongListNull());
+        realmObjectCopy.realmSet$fieldIntegerListNotNull(realmObjectSource.realmGet$fieldIntegerListNotNull());
+        realmObjectCopy.realmSet$fieldIntegerListNull(realmObjectSource.realmGet$fieldIntegerListNull());
+        realmObjectCopy.realmSet$fieldShortListNotNull(realmObjectSource.realmGet$fieldShortListNotNull());
+        realmObjectCopy.realmSet$fieldShortListNull(realmObjectSource.realmGet$fieldShortListNull());
+        realmObjectCopy.realmSet$fieldByteListNotNull(realmObjectSource.realmGet$fieldByteListNotNull());
+        realmObjectCopy.realmSet$fieldByteListNull(realmObjectSource.realmGet$fieldByteListNull());
+        realmObjectCopy.realmSet$fieldDoubleListNotNull(realmObjectSource.realmGet$fieldDoubleListNotNull());
+        realmObjectCopy.realmSet$fieldDoubleListNull(realmObjectSource.realmGet$fieldDoubleListNull());
+        realmObjectCopy.realmSet$fieldFloatListNotNull(realmObjectSource.realmGet$fieldFloatListNotNull());
+        realmObjectCopy.realmSet$fieldFloatListNull(realmObjectSource.realmGet$fieldFloatListNull());
+        realmObjectCopy.realmSet$fieldDateListNotNull(realmObjectSource.realmGet$fieldDateListNotNull());
+        realmObjectCopy.realmSet$fieldDateListNull(realmObjectSource.realmGet$fieldDateListNull());
         return realmObject;
     }
 
@@ -1346,38 +2387,278 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
         if (realmGet$fieldLongNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         }
-        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
-        if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
+        }
+
+        RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+        if (fieldStringListNotNullList != null) {
+            OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+            for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                if (fieldStringListNotNullItem == null) {
+                    fieldStringListNotNullOsList.addNull();
+                } else {
+                    fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+        if (fieldStringListNullList != null) {
+            OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+            for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                if (fieldStringListNullItem == null) {
+                    fieldStringListNullOsList.addNull();
+                } else {
+                    fieldStringListNullOsList.addString(fieldStringListNullItem);
+                }
+            }
+        }
+
+        RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+        if (fieldBinaryListNotNullList != null) {
+            OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+            for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                if (fieldBinaryListNotNullItem == null) {
+                    fieldBinaryListNotNullOsList.addNull();
+                } else {
+                    fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+        if (fieldBinaryListNullList != null) {
+            OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+            for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                if (fieldBinaryListNullItem == null) {
+                    fieldBinaryListNullOsList.addNull();
+                } else {
+                    fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+        if (fieldBooleanListNotNullList != null) {
+            OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+            for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                if (fieldBooleanListNotNullItem == null) {
+                    fieldBooleanListNotNullOsList.addNull();
+                } else {
+                    fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+        if (fieldBooleanListNullList != null) {
+            OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+            for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                if (fieldBooleanListNullItem == null) {
+                    fieldBooleanListNullOsList.addNull();
+                } else {
+                    fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+        if (fieldLongListNotNullList != null) {
+            OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+            for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                if (fieldLongListNotNullItem == null) {
+                    fieldLongListNotNullOsList.addNull();
+                } else {
+                    fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+        if (fieldLongListNullList != null) {
+            OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+            for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                if (fieldLongListNullItem == null) {
+                    fieldLongListNullOsList.addNull();
+                } else {
+                    fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+        if (fieldIntegerListNotNullList != null) {
+            OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+            for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                if (fieldIntegerListNotNullItem == null) {
+                    fieldIntegerListNotNullOsList.addNull();
+                } else {
+                    fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+        if (fieldIntegerListNullList != null) {
+            OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+            for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                if (fieldIntegerListNullItem == null) {
+                    fieldIntegerListNullOsList.addNull();
+                } else {
+                    fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+        if (fieldShortListNotNullList != null) {
+            OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+            for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                if (fieldShortListNotNullItem == null) {
+                    fieldShortListNotNullOsList.addNull();
+                } else {
+                    fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+        if (fieldShortListNullList != null) {
+            OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+            for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                if (fieldShortListNullItem == null) {
+                    fieldShortListNullOsList.addNull();
+                } else {
+                    fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+        if (fieldByteListNotNullList != null) {
+            OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+            for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                if (fieldByteListNotNullItem == null) {
+                    fieldByteListNotNullOsList.addNull();
+                } else {
+                    fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+        if (fieldByteListNullList != null) {
+            OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+            for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                if (fieldByteListNullItem == null) {
+                    fieldByteListNullOsList.addNull();
+                } else {
+                    fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                }
+            }
         }
-        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
-        if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+
+        RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+        if (fieldDoubleListNotNullList != null) {
+            OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+            for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                if (fieldDoubleListNotNullItem == null) {
+                    fieldDoubleListNotNullOsList.addNull();
+                } else {
+                    fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                }
+            }
         }
-        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
-        if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+
+        RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+        if (fieldDoubleListNullList != null) {
+            OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+            for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                if (fieldDoubleListNullItem == null) {
+                    fieldDoubleListNullOsList.addNull();
+                } else {
+                    fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                }
+            }
         }
-        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
-        if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+
+        RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+        if (fieldFloatListNotNullList != null) {
+            OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+            for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                if (fieldFloatListNotNullItem == null) {
+                    fieldFloatListNotNullOsList.addNull();
+                } else {
+                    fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                }
+            }
         }
-        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
-        if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+
+        RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+        if (fieldFloatListNullList != null) {
+            OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+            for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                if (fieldFloatListNullItem == null) {
+                    fieldFloatListNullOsList.addNull();
+                } else {
+                    fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                }
+            }
         }
-        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
-        if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+
+        RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+        if (fieldDateListNotNullList != null) {
+            OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+            for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                if (fieldDateListNotNullItem == null) {
+                    fieldDateListNotNullOsList.addNull();
+                } else {
+                    fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                }
+            }
         }
 
-        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
-        if (fieldObjectNullObj != null) {
-            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
-            if (cachefieldObjectNull == null) {
-                cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+        RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+        if (fieldDateListNullList != null) {
+            OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+            for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                if (fieldDateListNullItem == null) {
+                    fieldDateListNullOsList.addNull();
+                } else {
+                    fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                }
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         }
         return rowIndex;
     }
@@ -1487,6 +2768,246 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                 }
                 table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
             }
+
+            RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+            if (fieldStringListNotNullList != null) {
+                OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+                for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                    if (fieldStringListNotNullItem == null) {
+                        fieldStringListNotNullOsList.addNull();
+                    } else {
+                        fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+            if (fieldStringListNullList != null) {
+                OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+                for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                    if (fieldStringListNullItem == null) {
+                        fieldStringListNullOsList.addNull();
+                    } else {
+                        fieldStringListNullOsList.addString(fieldStringListNullItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+            if (fieldBinaryListNotNullList != null) {
+                OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+                for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                    if (fieldBinaryListNotNullItem == null) {
+                        fieldBinaryListNotNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+            if (fieldBinaryListNullList != null) {
+                OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+                for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                    if (fieldBinaryListNullItem == null) {
+                        fieldBinaryListNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+            if (fieldBooleanListNotNullList != null) {
+                OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+                for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                    if (fieldBooleanListNotNullItem == null) {
+                        fieldBooleanListNotNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+            if (fieldBooleanListNullList != null) {
+                OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+                for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                    if (fieldBooleanListNullItem == null) {
+                        fieldBooleanListNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+            if (fieldLongListNotNullList != null) {
+                OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+                for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                    if (fieldLongListNotNullItem == null) {
+                        fieldLongListNotNullOsList.addNull();
+                    } else {
+                        fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+            if (fieldLongListNullList != null) {
+                OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+                for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                    if (fieldLongListNullItem == null) {
+                        fieldLongListNullOsList.addNull();
+                    } else {
+                        fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+            if (fieldIntegerListNotNullList != null) {
+                OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+                for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                    if (fieldIntegerListNotNullItem == null) {
+                        fieldIntegerListNotNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+            if (fieldIntegerListNullList != null) {
+                OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+                for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                    if (fieldIntegerListNullItem == null) {
+                        fieldIntegerListNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+            if (fieldShortListNotNullList != null) {
+                OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+                for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                    if (fieldShortListNotNullItem == null) {
+                        fieldShortListNotNullOsList.addNull();
+                    } else {
+                        fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+            if (fieldShortListNullList != null) {
+                OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+                for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                    if (fieldShortListNullItem == null) {
+                        fieldShortListNullOsList.addNull();
+                    } else {
+                        fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+            if (fieldByteListNotNullList != null) {
+                OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+                for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                    if (fieldByteListNotNullItem == null) {
+                        fieldByteListNotNullOsList.addNull();
+                    } else {
+                        fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+            if (fieldByteListNullList != null) {
+                OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+                for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                    if (fieldByteListNullItem == null) {
+                        fieldByteListNullOsList.addNull();
+                    } else {
+                        fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+            if (fieldDoubleListNotNullList != null) {
+                OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+                for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                    if (fieldDoubleListNotNullItem == null) {
+                        fieldDoubleListNotNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+            if (fieldDoubleListNullList != null) {
+                OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+                for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                    if (fieldDoubleListNullItem == null) {
+                        fieldDoubleListNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+            if (fieldFloatListNotNullList != null) {
+                OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+                for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                    if (fieldFloatListNotNullItem == null) {
+                        fieldFloatListNotNullOsList.addNull();
+                    } else {
+                        fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+            if (fieldFloatListNullList != null) {
+                OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+                for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                    if (fieldFloatListNullItem == null) {
+                        fieldFloatListNullOsList.addNull();
+                    } else {
+                        fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                    }
+                }
+            }
+
+            RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+            if (fieldDateListNotNullList != null) {
+                OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+                for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                    if (fieldDateListNotNullItem == null) {
+                        fieldDateListNotNullOsList.addNull();
+                    } else {
+                        fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+            if (fieldDateListNullList != null) {
+                OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+                for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                    if (fieldDateListNullItem == null) {
+                        fieldDateListNullOsList.addNull();
+                    } else {
+                        fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                    }
+                }
+            }
         }
     }
 
@@ -1571,65 +3092,345 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
-        if (realmGet$fieldLongNotNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
+        if (realmGet$fieldLongNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
+        }
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
+        if (realmGet$fieldLongNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
+        }
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
+        } else {
+            Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+        }
+
+        OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+        fieldStringListNotNullOsList.removeAll();
+        RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+        if (fieldStringListNotNullList != null) {
+            for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                if (fieldStringListNotNullItem == null) {
+                    fieldStringListNotNullOsList.addNull();
+                } else {
+                    fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+        fieldStringListNullOsList.removeAll();
+        RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+        if (fieldStringListNullList != null) {
+            for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                if (fieldStringListNullItem == null) {
+                    fieldStringListNullOsList.addNull();
+                } else {
+                    fieldStringListNullOsList.addString(fieldStringListNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+        fieldBinaryListNotNullOsList.removeAll();
+        RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+        if (fieldBinaryListNotNullList != null) {
+            for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                if (fieldBinaryListNotNullItem == null) {
+                    fieldBinaryListNotNullOsList.addNull();
+                } else {
+                    fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+        fieldBinaryListNullOsList.removeAll();
+        RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+        if (fieldBinaryListNullList != null) {
+            for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                if (fieldBinaryListNullItem == null) {
+                    fieldBinaryListNullOsList.addNull();
+                } else {
+                    fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+        fieldBooleanListNotNullOsList.removeAll();
+        RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+        if (fieldBooleanListNotNullList != null) {
+            for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                if (fieldBooleanListNotNullItem == null) {
+                    fieldBooleanListNotNullOsList.addNull();
+                } else {
+                    fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+        fieldBooleanListNullOsList.removeAll();
+        RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+        if (fieldBooleanListNullList != null) {
+            for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                if (fieldBooleanListNullItem == null) {
+                    fieldBooleanListNullOsList.addNull();
+                } else {
+                    fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                }
+            }
+        }
+
+
+        OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+        fieldLongListNotNullOsList.removeAll();
+        RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+        if (fieldLongListNotNullList != null) {
+            for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                if (fieldLongListNotNullItem == null) {
+                    fieldLongListNotNullOsList.addNull();
+                } else {
+                    fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                }
+            }
+        }
+
+
+        OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+        fieldLongListNullOsList.removeAll();
+        RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+        if (fieldLongListNullList != null) {
+            for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                if (fieldLongListNullItem == null) {
+                    fieldLongListNullOsList.addNull();
+                } else {
+                    fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                }
+            }
+        }
+
+
+        OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+        fieldIntegerListNotNullOsList.removeAll();
+        RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+        if (fieldIntegerListNotNullList != null) {
+            for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                if (fieldIntegerListNotNullItem == null) {
+                    fieldIntegerListNotNullOsList.addNull();
+                } else {
+                    fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                }
+            }
+        }
+
+
+        OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+        fieldIntegerListNullOsList.removeAll();
+        RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+        if (fieldIntegerListNullList != null) {
+            for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                if (fieldIntegerListNullItem == null) {
+                    fieldIntegerListNullOsList.addNull();
+                } else {
+                    fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                }
+            }
+        }
+
+
+        OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+        fieldShortListNotNullOsList.removeAll();
+        RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+        if (fieldShortListNotNullList != null) {
+            for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                if (fieldShortListNotNullItem == null) {
+                    fieldShortListNotNullOsList.addNull();
+                } else {
+                    fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                }
+            }
+        }
+
+
+        OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+        fieldShortListNullOsList.removeAll();
+        RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+        if (fieldShortListNullList != null) {
+            for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                if (fieldShortListNullItem == null) {
+                    fieldShortListNullOsList.addNull();
+                } else {
+                    fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                }
+            }
         }
-        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
-        if (realmGet$fieldLongNull != null) {
-            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
+
+
+        OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+        fieldByteListNotNullOsList.removeAll();
+        RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+        if (fieldByteListNotNullList != null) {
+            for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                if (fieldByteListNotNullItem == null) {
+                    fieldByteListNotNullOsList.addNull();
+                } else {
+                    fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                }
+            }
         }
-        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
-        if (realmGet$fieldFloatNotNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
+
+
+        OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+        fieldByteListNullOsList.removeAll();
+        RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+        if (fieldByteListNullList != null) {
+            for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                if (fieldByteListNullItem == null) {
+                    fieldByteListNullOsList.addNull();
+                } else {
+                    fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                }
+            }
         }
-        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
-        if (realmGet$fieldFloatNull != null) {
-            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
+
+
+        OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+        fieldDoubleListNotNullOsList.removeAll();
+        RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+        if (fieldDoubleListNotNullList != null) {
+            for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                if (fieldDoubleListNotNullItem == null) {
+                    fieldDoubleListNotNullOsList.addNull();
+                } else {
+                    fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                }
+            }
         }
-        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
-        if (realmGet$fieldDoubleNotNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
+
+
+        OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+        fieldDoubleListNullOsList.removeAll();
+        RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+        if (fieldDoubleListNullList != null) {
+            for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                if (fieldDoubleListNullItem == null) {
+                    fieldDoubleListNullOsList.addNull();
+                } else {
+                    fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                }
+            }
         }
-        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
-        if (realmGet$fieldDoubleNull != null) {
-            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
+
+
+        OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+        fieldFloatListNotNullOsList.removeAll();
+        RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+        if (fieldFloatListNotNullList != null) {
+            for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                if (fieldFloatListNotNullItem == null) {
+                    fieldFloatListNotNullOsList.addNull();
+                } else {
+                    fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                }
+            }
         }
-        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
-        if (realmGet$fieldDateNotNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
+
+
+        OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+        fieldFloatListNullOsList.removeAll();
+        RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+        if (fieldFloatListNullList != null) {
+            for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                if (fieldFloatListNullItem == null) {
+                    fieldFloatListNullOsList.addNull();
+                } else {
+                    fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                }
+            }
         }
-        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
-        if (realmGet$fieldDateNull != null) {
-            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
-        } else {
-            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
+
+
+        OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+        fieldDateListNotNullOsList.removeAll();
+        RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+        if (fieldDateListNotNullList != null) {
+            for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                if (fieldDateListNotNullItem == null) {
+                    fieldDateListNotNullOsList.addNull();
+                } else {
+                    fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                }
+            }
         }
 
-        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
-        if (fieldObjectNullObj != null) {
-            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
-            if (cachefieldObjectNull == null) {
-                cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+
+        OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+        fieldDateListNullOsList.removeAll();
+        RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+        if (fieldDateListNullList != null) {
+            for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                if (fieldDateListNullItem == null) {
+                    fieldDateListNullOsList.addNull();
+                } else {
+                    fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                }
             }
-            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
-        } else {
-            Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
         }
+
         return rowIndex;
     }
 
@@ -1780,6 +3581,286 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
             } else {
                 Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
             }
+
+            OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+            fieldStringListNotNullOsList.removeAll();
+            RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+            if (fieldStringListNotNullList != null) {
+                for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                    if (fieldStringListNotNullItem == null) {
+                        fieldStringListNotNullOsList.addNull();
+                    } else {
+                        fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+            fieldStringListNullOsList.removeAll();
+            RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+            if (fieldStringListNullList != null) {
+                for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                    if (fieldStringListNullItem == null) {
+                        fieldStringListNullOsList.addNull();
+                    } else {
+                        fieldStringListNullOsList.addString(fieldStringListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+            fieldBinaryListNotNullOsList.removeAll();
+            RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+            if (fieldBinaryListNotNullList != null) {
+                for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                    if (fieldBinaryListNotNullItem == null) {
+                        fieldBinaryListNotNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+            fieldBinaryListNullOsList.removeAll();
+            RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+            if (fieldBinaryListNullList != null) {
+                for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                    if (fieldBinaryListNullItem == null) {
+                        fieldBinaryListNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+            fieldBooleanListNotNullOsList.removeAll();
+            RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+            if (fieldBooleanListNotNullList != null) {
+                for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                    if (fieldBooleanListNotNullItem == null) {
+                        fieldBooleanListNotNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+            fieldBooleanListNullOsList.removeAll();
+            RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+            if (fieldBooleanListNullList != null) {
+                for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                    if (fieldBooleanListNullItem == null) {
+                        fieldBooleanListNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+            fieldLongListNotNullOsList.removeAll();
+            RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+            if (fieldLongListNotNullList != null) {
+                for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                    if (fieldLongListNotNullItem == null) {
+                        fieldLongListNotNullOsList.addNull();
+                    } else {
+                        fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+            fieldLongListNullOsList.removeAll();
+            RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+            if (fieldLongListNullList != null) {
+                for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                    if (fieldLongListNullItem == null) {
+                        fieldLongListNullOsList.addNull();
+                    } else {
+                        fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+            fieldIntegerListNotNullOsList.removeAll();
+            RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+            if (fieldIntegerListNotNullList != null) {
+                for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                    if (fieldIntegerListNotNullItem == null) {
+                        fieldIntegerListNotNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+            fieldIntegerListNullOsList.removeAll();
+            RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+            if (fieldIntegerListNullList != null) {
+                for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                    if (fieldIntegerListNullItem == null) {
+                        fieldIntegerListNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+            fieldShortListNotNullOsList.removeAll();
+            RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+            if (fieldShortListNotNullList != null) {
+                for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                    if (fieldShortListNotNullItem == null) {
+                        fieldShortListNotNullOsList.addNull();
+                    } else {
+                        fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+            fieldShortListNullOsList.removeAll();
+            RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+            if (fieldShortListNullList != null) {
+                for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                    if (fieldShortListNullItem == null) {
+                        fieldShortListNullOsList.addNull();
+                    } else {
+                        fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+            fieldByteListNotNullOsList.removeAll();
+            RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+            if (fieldByteListNotNullList != null) {
+                for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                    if (fieldByteListNotNullItem == null) {
+                        fieldByteListNotNullOsList.addNull();
+                    } else {
+                        fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+            fieldByteListNullOsList.removeAll();
+            RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+            if (fieldByteListNullList != null) {
+                for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                    if (fieldByteListNullItem == null) {
+                        fieldByteListNullOsList.addNull();
+                    } else {
+                        fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+            fieldDoubleListNotNullOsList.removeAll();
+            RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+            if (fieldDoubleListNotNullList != null) {
+                for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                    if (fieldDoubleListNotNullItem == null) {
+                        fieldDoubleListNotNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+            fieldDoubleListNullOsList.removeAll();
+            RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+            if (fieldDoubleListNullList != null) {
+                for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                    if (fieldDoubleListNullItem == null) {
+                        fieldDoubleListNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+            fieldFloatListNotNullOsList.removeAll();
+            RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+            if (fieldFloatListNotNullList != null) {
+                for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                    if (fieldFloatListNotNullItem == null) {
+                        fieldFloatListNotNullOsList.addNull();
+                    } else {
+                        fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                    }
+                }
+            }
+
+
+            OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+            fieldFloatListNullOsList.removeAll();
+            RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+            if (fieldFloatListNullList != null) {
+                for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                    if (fieldFloatListNullItem == null) {
+                        fieldFloatListNullOsList.addNull();
+                    } else {
+                        fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+            fieldDateListNotNullOsList.removeAll();
+            RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+            if (fieldDateListNotNullList != null) {
+                for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                    if (fieldDateListNotNullItem == null) {
+                        fieldDateListNotNullOsList.addNull();
+                    } else {
+                        fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+            fieldDateListNullOsList.removeAll();
+            RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+            if (fieldDateListNullList != null) {
+                for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                    if (fieldDateListNullItem == null) {
+                        fieldDateListNullOsList.addNull();
+                    } else {
+                        fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                    }
+                }
+            }
+
         }
     }
 
@@ -1825,6 +3906,67 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
 
         // Deep copy of fieldObjectNull
         unmanagedCopy.realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(realmSource.realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+
+        unmanagedCopy.realmSet$fieldStringListNotNull(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$fieldStringListNotNull().addAll(realmSource.realmGet$fieldStringListNotNull());
+
+        unmanagedCopy.realmSet$fieldStringListNull(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$fieldStringListNull().addAll(realmSource.realmGet$fieldStringListNull());
+
+        unmanagedCopy.realmSet$fieldBinaryListNotNull(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$fieldBinaryListNotNull().addAll(realmSource.realmGet$fieldBinaryListNotNull());
+
+        unmanagedCopy.realmSet$fieldBinaryListNull(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$fieldBinaryListNull().addAll(realmSource.realmGet$fieldBinaryListNull());
+
+        unmanagedCopy.realmSet$fieldBooleanListNotNull(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$fieldBooleanListNotNull().addAll(realmSource.realmGet$fieldBooleanListNotNull());
+
+        unmanagedCopy.realmSet$fieldBooleanListNull(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$fieldBooleanListNull().addAll(realmSource.realmGet$fieldBooleanListNull());
+
+        unmanagedCopy.realmSet$fieldLongListNotNull(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$fieldLongListNotNull().addAll(realmSource.realmGet$fieldLongListNotNull());
+
+        unmanagedCopy.realmSet$fieldLongListNull(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$fieldLongListNull().addAll(realmSource.realmGet$fieldLongListNull());
+
+        unmanagedCopy.realmSet$fieldIntegerListNotNull(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$fieldIntegerListNotNull().addAll(realmSource.realmGet$fieldIntegerListNotNull());
+
+        unmanagedCopy.realmSet$fieldIntegerListNull(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$fieldIntegerListNull().addAll(realmSource.realmGet$fieldIntegerListNull());
+
+        unmanagedCopy.realmSet$fieldShortListNotNull(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$fieldShortListNotNull().addAll(realmSource.realmGet$fieldShortListNotNull());
+
+        unmanagedCopy.realmSet$fieldShortListNull(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$fieldShortListNull().addAll(realmSource.realmGet$fieldShortListNull());
+
+        unmanagedCopy.realmSet$fieldByteListNotNull(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$fieldByteListNotNull().addAll(realmSource.realmGet$fieldByteListNotNull());
+
+        unmanagedCopy.realmSet$fieldByteListNull(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$fieldByteListNull().addAll(realmSource.realmGet$fieldByteListNull());
+
+        unmanagedCopy.realmSet$fieldDoubleListNotNull(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$fieldDoubleListNotNull().addAll(realmSource.realmGet$fieldDoubleListNotNull());
+
+        unmanagedCopy.realmSet$fieldDoubleListNull(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$fieldDoubleListNull().addAll(realmSource.realmGet$fieldDoubleListNull());
+
+        unmanagedCopy.realmSet$fieldFloatListNotNull(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$fieldFloatListNotNull().addAll(realmSource.realmGet$fieldFloatListNotNull());
+
+        unmanagedCopy.realmSet$fieldFloatListNull(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$fieldFloatListNull().addAll(realmSource.realmGet$fieldFloatListNull());
+
+        unmanagedCopy.realmSet$fieldDateListNotNull(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$fieldDateListNotNull().addAll(realmSource.realmGet$fieldDateListNotNull());
+
+        unmanagedCopy.realmSet$fieldDateListNull(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$fieldDateListNull().addAll(realmSource.realmGet$fieldDateListNull());
+
         return unmanagedObject;
     }
 
@@ -1918,6 +4060,86 @@ public String toString() {
         stringBuilder.append("{fieldObjectNull:");
         stringBuilder.append(realmGet$fieldObjectNull() != null ? "NullTypes" : "null");
         stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldStringListNotNull:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$fieldStringListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldStringListNull:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$fieldStringListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBinaryListNotNull:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$fieldBinaryListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBinaryListNull:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$fieldBinaryListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanListNotNull:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$fieldBooleanListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanListNull:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$fieldBooleanListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongListNotNull:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$fieldLongListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongListNull:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$fieldLongListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerListNotNull:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$fieldIntegerListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerListNull:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$fieldIntegerListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortListNotNull:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$fieldShortListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortListNull:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$fieldShortListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteListNotNull:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$fieldByteListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteListNull:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$fieldByteListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleListNotNull:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$fieldDoubleListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleListNull:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$fieldDoubleListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatListNotNull:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$fieldFloatListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatListNull:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$fieldFloatListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateListNotNull:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$fieldDateListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateListNull:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$fieldDateListNull().size()).append("]");
+        stringBuilder.append("}");
         stringBuilder.append("]");
         return stringBuilder.toString();
     }
@@ -1958,5 +4180,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index f3d88fc2cb..4539db1355 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -51,6 +51,18 @@
 
     private RealmList<AllTypes> columnRealmList;
 
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Integer> columnIntegerList;
+    private RealmList<Short> columnShortList;
+    private RealmList<Byte> columnByteList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
+
     @LinkingObjects(FIELD_PARENTS)
     private final RealmResults<AllTypes> parentObjects = null;
 
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java
new file mode 100644
index 0000000000..217aee5523
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.math.BigInteger;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class InvalidListElementType extends RealmObject {
+    public RealmList<BigInteger> bigIntegerList;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java
new file mode 100644
index 0000000000..dd832054d8
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.math.BigInteger;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class InvalidResultsElementType extends RealmObject {
+    public InvalidResultsElementType child;
+
+    @LinkingObjects("child")
+    public RealmResults<BigInteger> bigIntegerBacklinks;
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
index 1904076340..45bc47aae6 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
@@ -66,6 +66,45 @@
 
     private NullTypes fieldObjectNull;
 
+    @Required
+    private RealmList<String> fieldStringListNotNull;
+    private RealmList<String> fieldStringListNull;
+
+    @Required
+    private RealmList<byte[]> fieldBinaryListNotNull;
+    private RealmList<byte[]> fieldBinaryListNull;
+
+    @Required
+    private RealmList<Boolean> fieldBooleanListNotNull;
+    private RealmList<Boolean> fieldBooleanListNull;
+
+    @Required
+    private RealmList<Long> fieldLongListNotNull;
+    private RealmList<Long> fieldLongListNull;
+
+    @Required
+    private RealmList<Integer> fieldIntegerListNotNull;
+    private RealmList<Integer> fieldIntegerListNull;
+
+    @Required
+    private RealmList<Short> fieldShortListNotNull;
+    private RealmList<Short> fieldShortListNull;
+
+    @Required
+    private RealmList<Byte> fieldByteListNotNull;
+    private RealmList<Byte> fieldByteListNull;
+
+    @Required
+    private RealmList<Double> fieldDoubleListNotNull;
+    private RealmList<Double> fieldDoubleListNull;
+
+    @Required
+    private RealmList<Float> fieldFloatListNotNull;
+    private RealmList<Float> fieldFloatListNull;
+
+    @Required
+    private RealmList<Date> fieldDateListNotNull;
+    private RealmList<Date> fieldDateListNull;
 
     public String getFieldStringNotNull() {
         return realmGet$fieldStringNotNull();
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java b/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java
new file mode 100644
index 0000000000..33d615fc8e
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class ValueList extends RealmObject {
+    public RealmList<String> stringList;
+    public RealmList<byte[]> binaryList;
+    public RealmList<Boolean> booleanList;
+    public RealmList<Long> longList;
+    public RealmList<Integer> integerList;
+    public RealmList<Short> shortList;
+    public RealmList<Byte> byteList;
+    public RealmList<Double> doubleList;
+    public RealmList<Float> floatList;
+    public RealmList<Date> integerList;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index 9877018d9b..c87b63b0ce 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -1159,7 +1159,11 @@ public void getFieldNames() {
         String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID, AllJavaTypes.FIELD_LONG,
                 AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT,
                 AllJavaTypes.FIELD_DOUBLE, AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE,
-                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
+                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST,
+                AllJavaTypes.FIELD_STRING_LIST, AllJavaTypes.FIELD_BINARY_LIST, AllJavaTypes.FIELD_BOOLEAN_LIST,
+                AllJavaTypes.FIELD_LONG_LIST, AllJavaTypes.FIELD_INTEGER_LIST, AllJavaTypes.FIELD_SHORT_LIST,
+                AllJavaTypes.FIELD_BYTE_LIST, AllJavaTypes.FIELD_DOUBLE_LIST, AllJavaTypes.FIELD_FLOAT_LIST,
+                AllJavaTypes.FIELD_DATE_LIST};
         String[] keys = dObjTyped.getFieldNames();
         // After the stable ID support, primary key field will be inserted first before others. So even FIELD_STRING is
         // the first defined field in the class, it will be inserted after FIELD_ID.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index 39c5d346b2..9d881dd773 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -174,11 +174,6 @@ public void linkingObjects_invalidFieldType() {
         for (RealmFieldType fieldType : RealmFieldType.values()) {
             try {
                 switch (fieldType) {
-                    // skip unsupported types
-                    case UNSUPPORTED_TABLE: // fall-through
-                    case UNSUPPORTED_MIXED: // fall-through
-                    case UNSUPPORTED_DATE:
-                        continue;
                     // skip valid types
                     case OBJECT: // fall-through
                     case LIST:
@@ -207,6 +202,41 @@ public void linkingObjects_invalidFieldType() {
                     case DOUBLE:
                         object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DOUBLE);
                         break;
+                    case INTEGER_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_INT_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case BOOLEAN_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BOOLEAN_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case STRING_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_STRING_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case BINARY_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BINARY_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case DATE_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DATE_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case FLOAT_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_FLOAT_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case DOUBLE_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DOUBLE_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
                     default:
                         fail("unknown type: " + fieldType);
                         break;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
new file mode 100644
index 0000000000..0e8cddf5d4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
@@ -0,0 +1,1563 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.annotation.Nullable;
+
+import io.realm.entities.NullTypes;
+import io.realm.internal.Table;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.ManagedRealmListForValueTests.ListType.BINARY_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BOOLEAN_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BYTE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DATE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DOUBLE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.FLOAT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.INTEGER_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.LONG_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.SHORT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.STRING_LIST;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+/**
+ * Unit tests specific for RealmList with value elements.
+ */
+@RunWith(Parameterized.class)
+public class ManagedRealmListForValueTests extends CollectionTests {
+
+    static final int NON_NULL_TEST_SIZE = 10;
+    static final int NULLABLE_TEST_SIZE = NON_NULL_TEST_SIZE * 2;
+
+    enum ListType {
+        STRING_LIST(String.class.getName()),
+        BOOLEAN_LIST(Boolean.class.getName()),
+        BINARY_LIST(byte[].class.getSimpleName()/* using simple name since array class is a bit special */),
+        LONG_LIST(Long.class.getName()),
+        INTEGER_LIST(Integer.class.getName()),
+        SHORT_LIST(Short.class.getName()),
+        BYTE_LIST(Byte.class.getName()),
+        DOUBLE_LIST(Double.class.getName()),
+        FLOAT_LIST(Float.class.getName()),
+        DATE_LIST(Date.class.getName());
+
+        private final String valueTypeName;
+
+        ListType(String valueTypeName) {
+            this.valueTypeName = valueTypeName;
+        }
+
+        public String getValueTypeName() {
+            return valueTypeName;
+        }
+    }
+
+    @Parameterized.Parameters(name = "{index}: Type: {0}, Nullable?: {1}")
+    public static Collection<Object[]> parameters() {
+        final List<Object[]> paramsList = new ArrayList<>();
+        for (ListType listType : ListType.values()) {
+            paramsList.add(new Object[] {listType, Boolean.TRUE});
+            paramsList.add(new Object[] {listType, Boolean.FALSE});
+        }
+        return paramsList;
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Parameterized.Parameter
+    public ListType listType;
+
+    @Parameterized.Parameter(1)
+    public Boolean isTypeNullable;
+
+    private Realm realm;
+    private NullTypes object;
+    private RealmList list;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() throws Exception {
+        final RealmConfiguration.Builder configurationBuilder = configFactory.createConfigurationBuilder();
+        configurationBuilder.schema(NullTypes.class);
+        RealmConfiguration realmConfig = configurationBuilder.build();
+
+        realm = Realm.getInstance(realmConfig);
+
+        realm.beginTransaction();
+        object = realm.createObject(NullTypes.class, 0);
+        for (ListType type : ListType.values()) {
+            for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+                switch (type) {
+                    case STRING_LIST: {
+                        final RealmList nonnull = object.getFieldStringListNotNull();
+                        nonnull.add(generateValue(STRING_LIST, i));
+                        final RealmList nullable = object.getFieldStringListNull();
+                        nullable.add("" + i);
+                        nullable.add(null);
+                    }
+                    break;
+                    case BOOLEAN_LIST: {
+                        final RealmList nonnull = object.getFieldBooleanListNotNull();
+                        nonnull.add(generateValue(BOOLEAN_LIST, i));
+                        final RealmList nullable = object.getFieldBooleanListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BINARY_LIST: {
+                        final RealmList nonnull = object.getFieldBinaryListNotNull();
+                        nonnull.add(generateValue(BINARY_LIST, i));
+                        final RealmList nullable = object.getFieldBinaryListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case LONG_LIST: {
+                        final RealmList nonnull = object.getFieldLongListNotNull();
+                        nonnull.add(generateValue(LONG_LIST, i));
+                        final RealmList nullable = object.getFieldLongListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case INTEGER_LIST: {
+                        final RealmList nonnull = object.getFieldIntegerListNotNull();
+                        nonnull.add(generateValue(INTEGER_LIST, i));
+                        final RealmList nullable = object.getFieldIntegerListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case SHORT_LIST: {
+                        final RealmList nonnull = object.getFieldShortListNotNull();
+                        nonnull.add(generateValue(SHORT_LIST, i));
+                        final RealmList nullable = object.getFieldShortListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BYTE_LIST: {
+                        final RealmList nonnull = object.getFieldByteListNotNull();
+                        nonnull.add(generateValue(BYTE_LIST, i));
+                        final RealmList nullable = object.getFieldByteListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DOUBLE_LIST: {
+                        final RealmList nonnull = object.getFieldDoubleListNotNull();
+                        nonnull.add(generateValue(DOUBLE_LIST, i));
+                        final RealmList nullable = object.getFieldDoubleListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case FLOAT_LIST: {
+                        final RealmList nonnull = object.getFieldFloatListNotNull();
+                        nonnull.add(generateValue(FLOAT_LIST, i));
+                        final RealmList nullable = object.getFieldFloatListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DATE_LIST: {
+                        final RealmList nonnull = object.getFieldDateListNotNull();
+                        nonnull.add(generateValue(DATE_LIST, i));
+                        final RealmList nullable = object.getFieldDateListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    default:
+                        throw new AssertionError("unexpected value type: " + listType.name());
+                }
+            }
+        }
+        realm.commitTransaction();
+
+        list = getListFor(object, listType, isTypeNullable);
+    }
+
+    static RealmList<?> getListFor(NullTypes object, ListType listType, boolean nullable) {
+        switch (listType) {
+            case STRING_LIST:
+                return nullable ? object.getFieldStringListNull() : object.getFieldStringListNotNull();
+            case BOOLEAN_LIST:
+                return nullable ? object.getFieldBooleanListNull() : object.getFieldBooleanListNotNull();
+            case BINARY_LIST:
+                return nullable ? object.getFieldBinaryListNull() : object.getFieldBinaryListNotNull();
+            case LONG_LIST:
+                return nullable ? object.getFieldLongListNull() : object.getFieldLongListNotNull();
+            case INTEGER_LIST:
+                return nullable ? object.getFieldIntegerListNull() : object.getFieldIntegerListNotNull();
+            case SHORT_LIST:
+                return nullable ? object.getFieldShortListNull() : object.getFieldShortListNotNull();
+            case BYTE_LIST:
+                return nullable ? object.getFieldByteListNull() : object.getFieldByteListNotNull();
+            case DOUBLE_LIST:
+                return nullable ? object.getFieldDoubleListNull() : object.getFieldDoubleListNotNull();
+            case FLOAT_LIST:
+                return nullable ? object.getFieldFloatListNull() : object.getFieldFloatListNotNull();
+            case DATE_LIST:
+                return nullable ? object.getFieldDateListNull() : object.getFieldDateListNotNull();
+            default:
+                throw new AssertionError("unexpected value type: " + listType.name());
+        }
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    static Object generateValue(ListType listType, int i) {
+        switch (listType) {
+            case STRING_LIST:
+                return "" + i;
+            case BOOLEAN_LIST:
+                return i % 2 == 0 ? Boolean.FALSE : Boolean.TRUE;
+            case BINARY_LIST:
+                return new byte[] {(byte) i};
+            case LONG_LIST:
+                return (long) i;
+            case INTEGER_LIST:
+                return i;
+            case SHORT_LIST:
+                return (short) i;
+            case BYTE_LIST:
+                return (byte) i;
+            case DOUBLE_LIST:
+                return (double) i;
+            case FLOAT_LIST:
+                return (float) i;
+            case DATE_LIST:
+                return new Date(i);
+            default:
+                throw new AssertionError("unexpected value type: " + listType.name());
+        }
+    }
+
+    private static Object generateHugeValue(ListType listType, int size) {
+        final byte[] bytes = new byte[size];
+        switch (listType) {
+            case STRING_LIST:
+                Arrays.fill(bytes, (byte) 'a');
+                return new String(bytes, Charset.forName("US-ASCII"));
+            case BINARY_LIST:
+                return bytes;
+            default:
+                throw new AssertionError("'generateHugeValue' does not support this type: " + listType.name());
+        }
+    }
+
+    private void assertValueEquals(@Nullable Object expected, @Nullable Object actual) {
+        assertValueEquals(null, expected, actual);
+    }
+
+    private void assertValueEquals(@SuppressWarnings("SameParameterValue") @Nullable String message, @Nullable Object expected, @Nullable Object actual) {
+        if (listType == BINARY_LIST) {
+            assertArrayEquals(message, (byte[]) expected, (byte[]) actual);
+        } else {
+            assertEquals(message, expected, actual);
+        }
+    }
+
+    @Test
+    public void readValues() {
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            switch (listType) {
+                case STRING_LIST: {
+                    assertEquals(generateValue(STRING_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BOOLEAN_LIST: {
+                    assertEquals(generateValue(BOOLEAN_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BINARY_LIST: {
+                    assertArrayEquals((byte[]) generateValue(BINARY_LIST, i), (byte[]) list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case LONG_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(LONG_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case INTEGER_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(INTEGER_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case SHORT_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(SHORT_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BYTE_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(BYTE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case DOUBLE_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(DOUBLE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case FLOAT_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(FLOAT_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case DATE_LIST: {
+                    assertEquals(generateValue(DATE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                default:
+                    throw new AssertionError("unexpected value type: " + listType.name());
+            }
+            if (isTypeNullable) {
+                assertNull(list.get(i * 2 + 1));
+            }
+        }
+    }
+
+    @Test
+    public void isValid() {
+        assertTrue(list.isValid());
+
+        realm.close();
+
+        assertFalse(list.isValid());
+    }
+
+    @Test
+    public void isValid_whenParentRemoved() {
+        realm.beginTransaction();
+        object.deleteFromRealm();
+        realm.commitTransaction();
+
+        // RealmList contained in removed object is invalid.
+        assertFalse(list.isValid());
+    }
+
+    @Test
+    public void add_exceedingSizeLimitValueThrows() {
+        if (listType != STRING_LIST && listType != BINARY_LIST) {
+            return;
+        }
+
+        final int sizeLimit;
+        switch (listType) {
+            case STRING_LIST:
+                sizeLimit = Table.MAX_STRING_SIZE;
+                break;
+            case BINARY_LIST:
+                sizeLimit = Table.MAX_BINARY_SIZE;
+                break;
+            default:
+                throw new AssertionError("Unexpected list type: " + listType.name());
+        }
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                //noinspection unchecked
+                list.add(generateHugeValue(listType, sizeLimit));
+            }
+        });
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final long sizeBeforeException = list.size();
+                thrown.expect(IllegalArgumentException.class);
+                try {
+                    //noinspection unchecked
+                    list.add(generateHugeValue(listType, sizeLimit + 1));
+                } finally {
+                    // FIXME This assertion fails now. Code will be fixed in master branch first.
+                    assertEquals(sizeBeforeException, list.size());
+                }
+            }
+        });
+    }
+
+    @Test
+    public void move_outOfBoundsLowerThrows() {
+        realm.beginTransaction();
+        try {
+            list.move(0, -1);
+            fail("Indexes < 0 should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void move_outOfBoundsHigherThrows() {
+        realm.beginTransaction();
+        try {
+            list.move(list.size() - 1, list.size());
+            fail("Indexes >= size() should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+            ignored.printStackTrace();
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void clear_then_add() {
+        realm.beginTransaction();
+        list.clear();
+
+        assertTrue(list.isEmpty());
+
+        //noinspection unchecked
+        list.add(generateValue(listType, -100));
+
+        realm.commitTransaction();
+
+        assertEquals(1, list.size());
+    }
+
+    @Test
+    public void size() {
+        assertEquals(isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE, list.size());
+    }
+
+    @Test
+    public void remove_nonNullByIndex() {
+        final int targetIndex = 6;
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove(targetIndex);
+                final int dataIndex = isTypeNullable ? targetIndex / 2 : targetIndex;
+                assertValueEquals(generateValue(listType, dataIndex), removed);
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i < targetIndex ? i : i + 1;
+            if (isTypeNullable) {
+                if (originalIndex % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void remove_nullByIndex() {
+        if (!isTypeNullable) {
+            return;
+        }
+
+        final int targetIndex = 7;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertNull(list.remove(targetIndex));
+                assertEquals(NULLABLE_TEST_SIZE - 1, list.size());
+            }
+        });
+
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i < targetIndex ? i : i + 1;
+            if (originalIndex % 2 == 1) {
+                assertNull(list.get(i));
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void remove_first() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove(0);
+                assertValueEquals(generateValue(listType, 0), removed);
+            }
+        });
+
+        assertEquals((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1, list.size());
+    }
+
+    @Test
+    public void remove_last() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1);
+                if (isTypeNullable) {
+                    assertNull(removed);
+                } else {
+                    assertValueEquals(generateValue(listType, NON_NULL_TEST_SIZE - 1), removed);
+                }
+            }
+        });
+
+        assertEquals((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1, list.size());
+    }
+
+    @Test
+    public void remove_fromEmptyListThrows() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.clear();
+                thrown.expect(IndexOutOfBoundsException.class);
+                list.remove(0);
+            }
+        });
+    }
+
+    @Test
+    public void remove_byObject() {
+        final Object value = list.get(0);
+        final int initialSize = list.size();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (listType == BINARY_LIST) {
+                    assertFalse(list.remove(value));  // since 'equals()' never return true against binary array.
+                } else {
+                    assertTrue(list.remove(value));
+                }
+            }
+        });
+
+        assertEquals((listType == BINARY_LIST) ? initialSize : (initialSize - 1), list.size());
+    }
+
+    @Test
+    public void remove_byNull() {
+        final int initialSize = list.size();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (isTypeNullable) {
+                    assertTrue(list.remove(null));
+                } else {
+                    assertFalse(list.remove(null));
+                }
+            }
+        });
+
+        assertEquals(isTypeNullable ? (initialSize - 1) : initialSize, list.size());
+    }
+
+    @Test
+    public void deleteFirst() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertTrue(list.deleteFirstFromRealm());
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i + 1;
+            if (isTypeNullable) {
+                if (originalIndex % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void deleteLast() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertTrue(list.deleteLastFromRealm());
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            if (isTypeNullable) {
+                if (i % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, i / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, i), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void addAt_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.add(generateValue(listType, 100));
+    }
+
+    @Test
+    public void addAt_invalidIndex() {
+        final int initialSize = list.size();
+        try {
+            realm.beginTransaction();
+            //noinspection unchecked
+            list.add(initialSize + 1, generateValue(listType, 1000));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            // make sure that the size is not changed
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void set_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.set(0, generateValue(listType, 100));
+    }
+
+    @Test
+    public void set_invalidIndex() {
+        final int initialSize = list.size();
+        try {
+            realm.beginTransaction();
+            //noinspection unchecked
+            list.set(initialSize, generateValue(listType, 1000));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            // make sure that the size is not changed
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void move_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.move(0, 1);
+    }
+
+    @Test
+    public void clear_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.clear();
+    }
+
+    @Test
+    public void remove_atAfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.remove(0);
+    }
+
+    @Test
+    public void remove_objectAfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.remove(generateValue(listType, 4));
+    }
+
+    @Test
+    public void remove_unsupportedTypeIgnored() {
+        final int initialSize = list.size();
+
+        final List<Object> unsupportedValues = Arrays.<Object>asList(
+                new int[] {0},
+                new StringBuilder("0")
+        );
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (Object unsupportedValue : unsupportedValues) {
+                    //noinspection UseBulkOperation
+                    assertFalse(list.remove(unsupportedValue));
+                }
+            }
+        });
+
+        assertEquals(initialSize, list.size());
+    }
+
+    @Test
+    public void removeAll() {
+        final List<Object> toBeRemoved = Arrays.asList(
+                null,
+                generateValue(listType, 2),
+                generateValue(listType, 4));
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (!isTypeNullable && listType == BINARY_LIST) {
+                    //noinspection unchecked
+                    assertFalse(list.removeAll(toBeRemoved)); // since 'equals()' never return true against binary array.
+                } else {
+                    //noinspection unchecked
+                    assertTrue(list.removeAll(toBeRemoved));
+                }
+            }
+        });
+
+        switch (listType) {
+            case BINARY_LIST:
+                assertEquals(NON_NULL_TEST_SIZE, list.size());
+                break;
+            case BOOLEAN_LIST:
+                assertEquals(NON_NULL_TEST_SIZE / 2, list.size());
+                break;
+            default:
+                assertEquals(NON_NULL_TEST_SIZE - 2, list.size());
+                break;
+        }
+    }
+
+    @Test
+    public void removeAll_unsupportedTypeIgnored() {
+        final int initialSize = list.size();
+
+        final List<Object> unsupportedValues = Arrays.<Object>asList(
+                new int[] {0},
+                new StringBuilder("0")
+        );
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                //noinspection unchecked
+                assertFalse(list.removeAll(unsupportedValues));
+            }
+        });
+
+        assertEquals(initialSize, list.size());
+    }
+
+    @Test
+    public void removeAll_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.removeAll(Collections.emptyList());
+    }
+
+    @Test
+    public void get_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.get(0);
+    }
+
+    @Test
+    public void first_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.first();
+    }
+
+    @Test
+    public void last_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.last();
+    }
+
+    @Test
+    public void size_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.size();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void where() {
+        list.where();
+    }
+
+    @Test
+    public void toString_() {
+        final StringBuilder sb = new StringBuilder("RealmList<").append(listType.getValueTypeName()).append(">@[");
+        final String separator = ",";
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            final Object value = generateValue(listType, i);
+
+            if (value instanceof byte[]) {
+                sb.append("byte[").append(((byte[]) value).length).append("]");
+            } else {
+                sb.append(value);
+            }
+            sb.append(separator);
+            if (isTypeNullable) {
+                sb.append("null").append(separator);
+            }
+        }
+        sb.setLength(sb.length() - separator.length());
+        sb.append("]");
+
+        assertEquals(sb.toString(), list.toString());
+    }
+
+    @Test
+    public void toString_AfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+        assertEquals("RealmList<" + listType.getValueTypeName() + ">@[invalid]", list.toString());
+    }
+
+    @Test
+    public void deleteAllFromRealm() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+
+        assertEquals(0, list.size());
+    }
+
+    @Test
+    public void deleteAllFromRealm_outsideTransaction() {
+        try {
+            list.deleteAllFromRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertTrue(e.getMessage().contains("Cannot modify managed objects outside of a write transaction"));
+        }
+    }
+
+    @Test
+    public void deleteAllFromRealm_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+        assertEquals(0, list.size());
+
+        // The dogs is empty now.
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+        assertEquals(0, list.size());
+    }
+
+    @Test
+    public void deleteAllFromRealm_invalidListShouldThrow() {
+        realm.close();
+        realm = null;
+
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(is("This Realm instance has already been closed, making it unusable."));
+        list.deleteAllFromRealm();
+    }
+
+    @Test
+    public void add_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.add(null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void addAt_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.add(1, null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void set_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.set(0, null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forAddObject() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(1, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(3, changes.getInsertions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(generateValue(listType, 100));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forAddAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(1, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getInsertions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(1, generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forSet() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(1, changes.getChanges().length);
+                assertEquals(1, changes.getChanges()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.set(1, generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        if (listType == BINARY_LIST) {
+            assertArrayEquals((byte[]) generateValue(listType, 100), (byte[]) list.remove(1));
+        } else {
+            assertEquals(generateValue(listType, 100), list.remove(1));
+        }
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveObject() {
+        if (listType == BINARY_LIST) {
+            // 'removeAll()' never remove byte array element since 'equals()' never return true against byte array.
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 101));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        assertTrue(list.remove(generateValue(listType, 101)));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveAll() {
+        if (listType == BINARY_LIST) {
+            // 'removeAll()' never remove byte array element since 'equals()' never return true against byte array.
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(listType == BOOLEAN_LIST ? 3 : 2, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletionRanges().length);
+                assertEquals(listType == BOOLEAN_LIST ? 0 : 1, changes.getDeletionRanges()[0].startIndex);
+                assertEquals(listType == BOOLEAN_LIST ? 3 : 2, changes.getDeletionRanges()[0].length);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+
+        final boolean removed = list.removeAll(Arrays.asList(generateValue(listType, 100), generateValue(listType, 200), generateValue(listType, 300)));
+        assertTrue(removed);
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forDeleteAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.deleteFromRealm(1);
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forDeleteAll() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(3, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletionRanges().length);
+                assertEquals(0, changes.getDeletionRanges()[0].startIndex);
+                assertEquals(3, changes.getDeletionRanges()[0].length);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.deleteAllFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+            }
+        });
+
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                fail();
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                fail();
+            }
+        });
+
+        list.removeAllChangeListeners();
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        // This one is added after removal, so it should be triggered.
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                listenerCalledCount.incrementAndGet();
+                looperThread.testComplete();
+            }
+        });
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(1, listenerCalledCount.get());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        RealmChangeListener<RealmList<Object>> listener1 = new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                fail();
+            }
+        };
+        OrderedRealmCollectionChangeListener<RealmList<Object>> listener2 =
+                new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+                    @Override
+                    public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                        assertEquals(0, listenerCalledCount.getAndIncrement());
+                        looperThread.testComplete();
+                    }
+                };
+
+        list.addChangeListener(listener1);
+        list.addChangeListener(listener2);
+
+        list.removeChangeListener(listener1);
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        list.add(generateValue(listType, 500));
+        realm.commitTransaction();
+        assertEquals(1, listenerCalledCount.get());
+    }
+
+    @Test
+    public void createSnapshot() {
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(is(RealmList.ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE));
+        list.createSnapshot();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java
new file mode 100644
index 0000000000..1d7dc8b403
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java
@@ -0,0 +1,467 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.ManagedRealmListForValueTests.ListType;
+import io.realm.entities.NullTypes;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.ManagedRealmListForValueTests.ListType.BINARY_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BOOLEAN_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BYTE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DATE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DOUBLE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.FLOAT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.INTEGER_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.LONG_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.SHORT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.STRING_LIST;
+import static io.realm.ManagedRealmListForValueTests.NON_NULL_TEST_SIZE;
+import static io.realm.ManagedRealmListForValueTests.NULLABLE_TEST_SIZE;
+import static io.realm.ManagedRealmListForValueTests.generateValue;
+import static io.realm.ManagedRealmListForValueTests.getListFor;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+
+/**
+ * Unit tests specific for RealmList with value elements.
+ */
+@RunWith(Parameterized.class)
+public class ManagedRealmListForValue_toArrayTests extends CollectionTests {
+
+    @Parameterized.Parameters(name = "{index}: Type: {0}, Nullable?: {1}")
+    public static Collection<Object[]> parameters() {
+        final List<Object[]> paramsList = new ArrayList<>();
+        for (ListType listType : ListType.values()) {
+            paramsList.add(new Object[] {listType, Boolean.TRUE});
+            paramsList.add(new Object[] {listType, Boolean.FALSE});
+        }
+        return paramsList;
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Parameterized.Parameter
+    public ListType listType;
+
+    @Parameterized.Parameter(1)
+    public Boolean typeIsNullable;
+
+    private Realm realm;
+    private RealmList list;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() throws Exception {
+        final RealmConfiguration.Builder configurationBuilder = configFactory.createConfigurationBuilder();
+        configurationBuilder.schema(NullTypes.class);
+        RealmConfiguration realmConfig = configurationBuilder.build();
+
+        realm = Realm.getInstance(realmConfig);
+
+        realm.beginTransaction();
+        final NullTypes object = realm.createObject(NullTypes.class, 0);
+        for (ListType type : ListType.values()) {
+            for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+                switch (type) {
+                    case STRING_LIST: {
+                        final RealmList nonnull = object.getFieldStringListNotNull();
+                        nonnull.add(generateValue(STRING_LIST, i));
+                        final RealmList nullable = object.getFieldStringListNull();
+                        nullable.add("" + i);
+                        nullable.add(null);
+                    }
+                    break;
+                    case BOOLEAN_LIST: {
+                        final RealmList nonnull = object.getFieldBooleanListNotNull();
+                        nonnull.add(generateValue(BOOLEAN_LIST, i));
+                        final RealmList nullable = object.getFieldBooleanListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BINARY_LIST: {
+                        final RealmList nonnull = object.getFieldBinaryListNotNull();
+                        nonnull.add(generateValue(BINARY_LIST, i));
+                        final RealmList nullable = object.getFieldBinaryListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case LONG_LIST: {
+                        final RealmList nonnull = object.getFieldLongListNotNull();
+                        nonnull.add(generateValue(LONG_LIST, i));
+                        final RealmList nullable = object.getFieldLongListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case INTEGER_LIST: {
+                        final RealmList nonnull = object.getFieldIntegerListNotNull();
+                        nonnull.add(generateValue(INTEGER_LIST, i));
+                        final RealmList nullable = object.getFieldIntegerListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case SHORT_LIST: {
+                        final RealmList nonnull = object.getFieldShortListNotNull();
+                        nonnull.add(generateValue(SHORT_LIST, i));
+                        final RealmList nullable = object.getFieldShortListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BYTE_LIST: {
+                        final RealmList nonnull = object.getFieldByteListNotNull();
+                        nonnull.add(generateValue(BYTE_LIST, i));
+                        final RealmList nullable = object.getFieldByteListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DOUBLE_LIST: {
+                        final RealmList nonnull = object.getFieldDoubleListNotNull();
+                        nonnull.add(generateValue(DOUBLE_LIST, i));
+                        final RealmList nullable = object.getFieldDoubleListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case FLOAT_LIST: {
+                        final RealmList nonnull = object.getFieldFloatListNotNull();
+                        nonnull.add(generateValue(FLOAT_LIST, i));
+                        final RealmList nullable = object.getFieldFloatListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DATE_LIST: {
+                        final RealmList nonnull = object.getFieldDateListNotNull();
+                        nonnull.add(generateValue(DATE_LIST, i));
+                        final RealmList nullable = object.getFieldDateListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    default:
+                        throw new AssertionError("unexpected value type: " + listType.name());
+                }
+            }
+        }
+        realm.commitTransaction();
+
+        list = getListFor(object, listType, typeIsNullable);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void toArray() {
+        final Object[] expected = new Object[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = generateValue(listType, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = generateValue(listType, i);
+            }
+        }
+
+        if (listType != BINARY_LIST) {
+            assertArrayEquals(expected, list.toArray());
+        } else {
+            final Object[] array = list.toArray();
+            assertEquals(expected.length, array.length);
+            for (int i = 0; i < expected.length; i++) {
+                if (expected[i] == null) {
+                    assertNull(array[i]);
+                } else {
+                    assertTrue(array[i] instanceof byte[]);
+                    assertArrayEquals((byte[]) expected[i], (byte[]) array[i]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void toArray_withStringArray() {
+        if (listType != STRING_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new String[0]);
+            // should not reach here
+            return;
+        }
+
+        final String[] expected = new String[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (String) generateValue(STRING_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (String) generateValue(STRING_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new String[0]);
+        assertEquals(String.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withBooleanArray() {
+        if (listType != BOOLEAN_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Boolean[0]);
+            // should not reach here
+            return;
+        }
+
+        final Boolean[] expected = new Boolean[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Boolean) generateValue(BOOLEAN_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Boolean) generateValue(BOOLEAN_LIST, i);
+            }
+        }
+
+        final Object[] returnedArray = list.toArray(new Boolean[0]);
+        assertEquals(Boolean.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withBinaryArray() {
+        if (listType != BINARY_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new byte[0][]);
+            // should not reach here
+            return;
+        }
+
+        final byte[][] expected = new byte[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE][];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (byte[]) generateValue(BINARY_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (byte[]) generateValue(BINARY_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new byte[0][]);
+        assertEquals(byte[].class, returnedArray.getClass().getComponentType());
+
+        assertEquals(expected.length, returnedArray.length);
+        for (int i = 0; i < expected.length; i++) {
+            if (expected[i] == null) {
+                assertNull(returnedArray[i]);
+            } else {
+                assertTrue(returnedArray[i] instanceof byte[]);
+                assertArrayEquals(expected[i], (byte[]) returnedArray[i]);
+            }
+        }
+    }
+
+    @Test
+    public void toArray_withLongArray() {
+        if (listType != LONG_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Long[0]);
+            // should not reach here
+            return;
+        }
+
+        final Long[] expected = new Long[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Long) generateValue(LONG_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Long) generateValue(LONG_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Long[0]);
+        assertEquals(Long.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withIntegerArray() {
+        if (listType != INTEGER_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Integer[0]);
+            // should not reach here
+            return;
+        }
+
+        final Integer[] expected = new Integer[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Integer) generateValue(INTEGER_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Integer) generateValue(INTEGER_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Integer[0]);
+        assertEquals(Integer.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withShortArray() {
+        if (listType != SHORT_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Short[0]);
+            // should not reach here
+            return;
+        }
+
+        final Short[] expected = new Short[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Short) generateValue(SHORT_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Short) generateValue(SHORT_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Short[0]);
+        assertEquals(Short.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withByteArray() {
+        if (listType != BYTE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Byte[0]);
+            // should not reach here
+            return;
+        }
+
+        final Byte[] expected = new Byte[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Byte) generateValue(BYTE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Byte) generateValue(BYTE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Byte[0]);
+        assertEquals(Byte.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withDoubleArray() {
+        if (listType != DOUBLE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Double[0]);
+            // should not reach here
+            return;
+        }
+
+        final Double[] expected = new Double[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Double) generateValue(DOUBLE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Double) generateValue(DOUBLE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Double[0]);
+        assertEquals(Double.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withFloatArray() {
+        if (listType != FLOAT_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Float[0]);
+            // should not reach here
+            return;
+        }
+
+        final Float[] expected = new Float[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Float) generateValue(FLOAT_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Float) generateValue(FLOAT_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Float[0]);
+        assertEquals(Float.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withDateArray() {
+        if (listType != DATE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Date[0]);
+            // should not reach here
+            return;
+        }
+
+        final Date[] expected = new Date[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Date) generateValue(DATE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Date) generateValue(DATE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Date[0]);
+        assertEquals(Date.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 534730bb58..d7e705a0fd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -642,16 +642,21 @@ public void listIterator_unsupportedMethods() {
             fail();
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
-        } catch (IllegalStateException e) {
+        } catch (IllegalStateException e) { // since next() was never called.
             assertRealmList();
         }
 
         try {
             it.add(null);
-            fail();
+            if (collectionClass != CollectionClass.UNMANAGED_REALMLIST) {
+                fail();
+            }
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
         } catch (IllegalArgumentException e) {
+            if (collectionClass == CollectionClass.UNMANAGED_REALMLIST) {
+                fail();
+            }
             assertRealmList();
         }
 
@@ -660,7 +665,7 @@ public void listIterator_unsupportedMethods() {
             fail();
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
-        } catch (IllegalStateException e) {
+        } catch (IllegalStateException e) { // since the collection is empty
             assertRealmList();
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
index 9811beed32..5ef1233760 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
@@ -62,9 +62,16 @@
 
         list = new ArrayList<>(Arrays.asList(RealmFieldType.values()));
         list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
-        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
-        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
-        list.remove(RealmFieldType.UNSUPPORTED_DATE);
+
+        // FIXME zaki50 revisit once we implement query for Primitive List
+        list.remove(RealmFieldType.STRING_LIST);
+        list.remove(RealmFieldType.BINARY_LIST);
+        list.remove(RealmFieldType.BOOLEAN_LIST);
+        list.remove(RealmFieldType.INTEGER_LIST);
+        list.remove(RealmFieldType.DOUBLE_LIST);
+        list.remove(RealmFieldType.FLOAT_LIST);
+        list.remove(RealmFieldType.DATE_LIST);
+
         NOT_SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
         NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 3197a6b663..633cbe6e64 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -715,42 +715,42 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmModel> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+            public <E> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results) {
+            public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+            public <E> Flowable<RealmResults<E>> from(DynamicRealm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+            public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+            public <E> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list) {
+            public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+            public <E> Flowable<RealmList<E>> from(DynamicRealm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+            public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, RealmList<E> list) {
                 return null;
             }
 
@@ -775,12 +775,12 @@ public void rxFactory() {
             }
 
             @Override
-            public <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+            public <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
                 return null;
             }
 
             @Override
-            public Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+            public <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query) {
                 return null;
             }
         };
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 7cfc9f674d..6547300fed 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -141,9 +141,11 @@ public void add_unmanagedMode() {
         assertEquals(object, list.get(0));
     }
 
-    @Test (expected = IllegalArgumentException.class)
+    @Test
     public void add_nullInUnmanagedMode() {
-        new RealmList<AllTypes>().add(null);
+        final RealmList<AllTypes> list = new RealmList<>();
+        assertTrue(list.add(null));
+        assertEquals(1, list.size());
     }
 
     @Test
@@ -189,9 +191,25 @@ public void add_objectAtIndexInManagedMode() {
         assertEquals("Dog 42", collection.get(0).getName());
     }
 
-    @Test (expected = IllegalArgumentException.class)
+    @Test
+    public void add_objectAtInvalidIndexInManagedModeThrows() {
+        final int initialDogCount = realm.where(Dog.class).findAll().size();
+
+        realm.beginTransaction();
+        try {
+            final int invalidIndex = collection.size() + 1;
+            collection.add(invalidIndex, new Dog("Dog 42"));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            assertEquals(initialDogCount, realm.where(Dog.class).findAll().size());
+        }
+    }
+
+    @Test
     public void add_nullAtIndexInUnmanagedMode() {
-        new RealmList<AllTypes>().add(0, null);
+        final RealmList<AllTypes> list = new RealmList<>();
+        list.add(0, null);
+        assertEquals(1, list.size());
     }
 
     @Test
@@ -223,11 +241,9 @@ public void set_managedMode() {
 
     @Test
     public void set_nullInUnmanagedMode() {
-        @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        RealmList<AllTypes> list = new RealmList<>();
         list.add(new AllTypes());
-        thrown.expect(IllegalArgumentException.class);
-        list.set(0, null);
+        assertNotNull(list.set(0, null));
     }
 
     @Test
@@ -684,12 +700,12 @@ public void where_afterContainerObjectRemoved() {
     @Test
     public void toString_AfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
-        assertEquals("Dog@[invalid]", dogs.toString());
+        assertEquals("RealmList<Dog>@[invalid]", dogs.toString());
     }
 
     @Test
     public void toString_managedMode() {
-        StringBuilder sb = new StringBuilder("Dog@[");
+        StringBuilder sb = new StringBuilder("RealmList<Dog>@[");
         for (int i = 0; i < collection.size() - 1; i++) {
             sb.append(((RealmObjectProxy) (collection.get(i))).realmGet$proxyState().getRow$realm().getIndex());
             sb.append(",");
@@ -894,6 +910,7 @@ public void add_set_withWrongDynamicObjectType() {
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
                 .getList(Owner.FIELD_DOGS);
+        list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
         DynamicRealmObject dynCat = dynamicRealm.createObject(Cat.CLASS_NAME);
 
         try {
@@ -934,6 +951,7 @@ public void add_set_dynamicObjectCreatedFromTypedRealm() {
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
                 .getList(Owner.FIELD_DOGS);
+        list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
 
         try {
             list.add(dynDog);
@@ -1084,7 +1102,7 @@ public void createSnapshot_shouldUseTargetTable() {
         realm.commitTransaction();
         assertEquals(sizeBefore - 1, collection.size());
 
-        assertNotNull(collection.osList);
-        assertEquals(collection.osList.getTargetTable().getName(), snapshot.getTable().getName());
+        assertNotNull(collection.getOsList());
+        assertEquals(collection.getOsList().getTargetTable().getName(), snapshot.getTable().getName());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 258b29483a..be4bc94e1f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -121,7 +121,7 @@ public void row_isValid() {
         realm.commitTransaction();
 
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
-        assertEquals(10, row.getColumnCount());
+        assertEquals(17, row.getColumnCount());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index 52442d9351..7c12ddba71 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -26,14 +26,18 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.internal.Table;
@@ -85,7 +89,7 @@ public RealmSchemaTests(SchemaType type) {
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schema(AllJavaTypes.class, Owner.class, PrimaryKeyAsString.class, Cat.class, Dog.class,
-                        DogPrimaryKey.class)
+                        DogPrimaryKey.class, NullTypes.class)
                 .build();
         Realm.getInstance(realmConfig).close(); // create Schema
         if (type == SchemaType.MUTABLE) {
@@ -105,16 +109,18 @@ public void tearDown() {
     @Test
     public void getAll() {
         Set<RealmObjectSchema> objectSchemas = realmSchema.getAll();
-        assertEquals(6, objectSchemas.size());
+        assertEquals(7, objectSchemas.size());
 
-        List<String> expectedTables = Arrays.asList(
-                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString");
+        List<String> expectedTables = new ArrayList<>(Arrays.asList(
+                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString", NullTypes.CLASS_NAME));
         for (RealmObjectSchema objectSchema : objectSchemas) {
             assertThat(objectSchema, CoreMatchers.instanceOf(type.objectSchemaClass));
-            if (!expectedTables.contains(objectSchema.getClassName())) {
-                fail(objectSchema.getClassName() + " was not found");
+            if (!expectedTables.remove(objectSchema.getClassName())) {
+                fail(objectSchema.getClassName() + " is not expected");
             }
         }
+        assertTrue("expected class is not contained in schema: " + (expectedTables.isEmpty() ? "" : expectedTables.get(0)),
+                expectedTables.isEmpty());
     }
 
     @Test
@@ -561,6 +567,46 @@ public void rename_shouldUpdateDynamicCache() {
         assertEquals("bar", bar.getClassName());
     }
 
+    @Test
+    public void schemaInformationOfPrimitiveLists() {
+        Map<String, RealmFieldType> fieldNameToType = new HashMap<>();
+        fieldNameToType.put(NullTypes.FIELD_STRING_LIST_NULL, RealmFieldType.STRING_LIST);
+        fieldNameToType.put(NullTypes.FIELD_STRING_LIST_NOT_NULL, RealmFieldType.STRING_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BINARY_LIST_NULL, RealmFieldType.BINARY_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BINARY_LIST_NOT_NULL, RealmFieldType.BINARY_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BOOLEAN_LIST_NULL, RealmFieldType.BOOLEAN_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BOOLEAN_LIST_NOT_NULL, RealmFieldType.BOOLEAN_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DATE_LIST_NULL, RealmFieldType.DATE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DATE_LIST_NOT_NULL, RealmFieldType.DATE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DOUBLE_LIST_NULL, RealmFieldType.DOUBLE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DOUBLE_LIST_NOT_NULL, RealmFieldType.DOUBLE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_FLOAT_LIST_NULL, RealmFieldType.FLOAT_LIST);
+        fieldNameToType.put(NullTypes.FIELD_FLOAT_LIST_NOT_NULL, RealmFieldType.FLOAT_LIST);
+        fieldNameToType.put(NullTypes.FIELD_LONG_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_LONG_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_INTEGER_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_INTEGER_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_SHORT_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_SHORT_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BYTE_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BYTE_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+
+        final RealmObjectSchema objectSchema = realmSchema.get(NullTypes.CLASS_NAME);
+        assertNotNull(objectSchema);
+
+        for (Map.Entry<String, RealmFieldType> entry : fieldNameToType.entrySet()) {
+            final String fieldName = entry.getKey();
+            final RealmFieldType expectedType = entry.getValue();
+
+            assertEquals(expectedType, objectSchema.getFieldType(fieldName));
+            assertEquals("isNullable('" + fieldName + "')",
+                    !fieldName.endsWith("NotNull"), objectSchema.isNullable(fieldName));
+            assertEquals("isRequired('" + fieldName + "')",
+                    fieldName.endsWith("NotNull"), objectSchema.isRequired(fieldName));
+            assertFalse(objectSchema.isPrimaryKey(fieldName));
+        }
+    }
+
     @Test
     public void rename_newNameExists() {
         if (type == SchemaType.IMMUTABLE) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 6485e6ed5c..37d51b8bcd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -64,8 +64,6 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.annotation.Nullable;
-
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
@@ -120,7 +118,6 @@
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
@@ -132,7 +129,6 @@
 import static org.mockito.Mockito.when;
 
 
-
 @RunWith(AndroidJUnit4.class)
 public class RealmTests {
     private final static int TEST_DATA_SIZE = 10;
@@ -1304,6 +1300,14 @@ public void copyToRealm() {
         allTypes.setColumnRealmObject(dog);
         allTypes.setColumnRealmList(list);
 
+        allTypes.setColumnStringList(new RealmList<String>("1"));
+        allTypes.setColumnBinaryList(new RealmList<byte[]>(new byte[] {1}));
+        allTypes.setColumnBooleanList(new RealmList<Boolean>(true));
+        allTypes.setColumnLongList(new RealmList<Long>(1L));
+        allTypes.setColumnDoubleList(new RealmList<Double>(1D));
+        allTypes.setColumnFloatList(new RealmList<Float>(1F));
+        allTypes.setColumnDateList(new RealmList<Date>(new Date(1L)));
+
         realm.beginTransaction();
         AllTypes realmTypes = realm.copyToRealm(allTypes);
         realm.commitTransaction();
@@ -1318,7 +1322,22 @@ public void copyToRealm() {
         assertArrayEquals(allTypes.getColumnBinary(), realmTypes.getColumnBinary());
         assertEquals(allTypes.getColumnRealmObject().getName(), dog.getName());
         assertEquals(list.size(), realmTypes.getColumnRealmList().size());
+        //noinspection ConstantConditions
         assertEquals(list.get(0).getName(), realmTypes.getColumnRealmList().get(0).getName());
+        assertEquals(1, realmTypes.getColumnStringList().size());
+        assertEquals("1", realmTypes.getColumnStringList().get(0));
+        assertEquals(1, realmTypes.getColumnBooleanList().size());
+        assertEquals(true, realmTypes.getColumnBooleanList().get(0));
+        assertEquals(1, realmTypes.getColumnBinaryList().size());
+        assertArrayEquals(new byte[] {1}, realmTypes.getColumnBinaryList().get(0));
+        assertEquals(1, realmTypes.getColumnLongList().size());
+        assertEquals((Long) 1L, realmTypes.getColumnLongList().get(0));
+        assertEquals(1, realmTypes.getColumnDoubleList().size());
+        assertEquals((Double) 1D, realmTypes.getColumnDoubleList().get(0));
+        assertEquals(1, realmTypes.getColumnFloatList().size());
+        assertEquals((Float) 1F, realmTypes.getColumnFloatList().get(0));
+        assertEquals(1, realmTypes.getColumnDateList().size());
+        assertEquals(new Date(1), realmTypes.getColumnDateList().get(0));
     }
 
     @Test
@@ -1393,8 +1412,8 @@ public void copyToRealm_cyclicListReferences() {
         oneCyclicType.setName("One");
         CyclicType anotherCyclicType = new CyclicType();
         anotherCyclicType.setName("Two");
-        oneCyclicType.setObjects(new RealmList(anotherCyclicType));
-        anotherCyclicType.setObjects(new RealmList(oneCyclicType));
+        oneCyclicType.setObjects(new RealmList<>(anotherCyclicType));
+        anotherCyclicType.setObjects(new RealmList<>(oneCyclicType));
 
         realm.beginTransaction();
         CyclicType realmObject = realm.copyToRealm(oneCyclicType);
@@ -1414,6 +1433,15 @@ public void copyToRealm_convertsNullToDefaultValue() {
         assertEquals("", realmTypes.getColumnString());
         assertEquals(new Date(0), realmTypes.getColumnDate());
         assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
+
+        assertNotNull(realmTypes.getColumnRealmList());
+        assertNotNull(realmTypes.getColumnStringList());
+        assertNotNull(realmTypes.getColumnBinaryList());
+        assertNotNull(realmTypes.getColumnBooleanList());
+        assertNotNull(realmTypes.getColumnLongList());
+        assertNotNull(realmTypes.getColumnDoubleList());
+        assertNotNull(realmTypes.getColumnFloatList());
+        assertNotNull(realmTypes.getColumnDateList());
     }
 
     // Check that using copyToRealm will set the primary key directly instead of first setting
@@ -1713,6 +1741,13 @@ public void execute(Realm realm) {
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
                 obj.setColumnBoxedBoolean(true);
+                obj.setColumnStringList(new RealmList<>("1"));
+                obj.setColumnBooleanList(new RealmList<>(false));
+                obj.setColumnBinaryList(new RealmList<>(new byte[] {1}));
+                obj.setColumnLongList(new RealmList<>(1L));
+                obj.setColumnDoubleList(new RealmList<>(1D));
+                obj.setColumnFloatList(new RealmList<>(1F));
+                obj.setColumnDateList(new RealmList<>(new Date(1L)));
                 realm.copyToRealm(obj);
 
                 AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
@@ -1726,6 +1761,13 @@ public void execute(Realm realm) {
                 obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
                 obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
                 obj2.setColumnBoxedBoolean(false);
+                obj2.setColumnStringList(new RealmList<>("2", "3"));
+                obj2.setColumnBooleanList(new RealmList<>(true, false));
+                obj2.setColumnBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+                obj2.setColumnLongList(new RealmList<>(2L, 3L));
+                obj2.setColumnDoubleList(new RealmList<>(2D, 3D));
+                obj2.setColumnFloatList(new RealmList<>(2F, 3F));
+                obj2.setColumnDateList(new RealmList<>(new Date(2L), new Date(3L)));
                 realm.copyToRealmOrUpdate(obj2);
             }
         });
@@ -1745,6 +1787,27 @@ public void execute(Realm realm) {
         assertEquals(1, obj.getColumnRealmList().size());
         assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
         assertFalse(obj.getColumnBoxedBoolean());
+        assertEquals(2, obj.getColumnStringList().size());
+        assertEquals("2", obj.getColumnStringList().get(0));
+        assertEquals("3", obj.getColumnStringList().get(1));
+        assertEquals(2, obj.getColumnBooleanList().size());
+        assertEquals(true, obj.getColumnBooleanList().get(0));
+        assertEquals(false, obj.getColumnBooleanList().get(1));
+        assertEquals(2, obj.getColumnBinaryList().size());
+        assertArrayEquals(new byte[] {2}, obj.getColumnBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, obj.getColumnBinaryList().get(1));
+        assertEquals(2, obj.getColumnLongList().size());
+        assertEquals((Long) 2L, obj.getColumnLongList().get(0));
+        assertEquals((Long) 3L, obj.getColumnLongList().get(1));
+        assertEquals(2, obj.getColumnDoubleList().size());
+        assertEquals((Double) 2D, obj.getColumnDoubleList().get(0));
+        assertEquals((Double) 3D, obj.getColumnDoubleList().get(1));
+        assertEquals(2, obj.getColumnFloatList().size());
+        assertEquals((Float) 2F, obj.getColumnFloatList().get(0));
+        assertEquals((Float) 3F, obj.getColumnFloatList().get(1));
+        assertEquals(2, obj.getColumnDateList().size());
+        assertEquals(new Date(2L), obj.getColumnDateList().get(0));
+        assertEquals(new Date(3L), obj.getColumnDateList().get(1));
     }
 
     @Test
@@ -2764,6 +2827,17 @@ public void copyToRealm_defaultValuesAreIgnored() {
             list.add(listItem);
             obj.setFieldList(list);
 
+            obj.setFieldStringList(new RealmList<>("2", "3"));
+            obj.setFieldBooleanList(new RealmList<>(true, false));
+            obj.setFieldBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+            obj.setFieldLongList(new RealmList<>(2L, 3L));
+            obj.setFieldIntegerList(new RealmList<>(2, 3));
+            obj.setFieldShortList(new RealmList<>((short) 2, (short) 3));
+            obj.setFieldByteList(new RealmList<>((byte) 2, (byte) 3));
+            obj.setFieldDoubleList(new RealmList<>(2D, 3D));
+            obj.setFieldFloatList(new RealmList<>(2F, 3F));
+            obj.setFieldDateList(new RealmList<>(new Date(2L), new Date(3L)));
+
             managedObj = realm.copyToRealm(obj);
         }
         realm.commitTransaction();
@@ -2781,11 +2855,42 @@ public void copyToRealm_defaultValuesAreIgnored() {
         assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0D);
         assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
         assertEquals(fieldDateValue, managedObj.getFieldDate());
-        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertArrayEquals(fieldBinaryValue, managedObj.getFieldBinary());
         assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
         assertEquals(1, managedObj.getFieldList().size());
         assertEquals(fieldListIntValue, managedObj.getFieldList().first().getFieldInt());
 
+        assertEquals(2, managedObj.getFieldStringList().size());
+        assertEquals("2", managedObj.getFieldStringList().get(0));
+        assertEquals("3", managedObj.getFieldStringList().get(1));
+        assertEquals(2, managedObj.getFieldBooleanList().size());
+        assertEquals(true, managedObj.getFieldBooleanList().get(0));
+        assertEquals(false, managedObj.getFieldBooleanList().get(1));
+        assertEquals(2, managedObj.getFieldBinaryList().size());
+        assertArrayEquals(new byte[] {2}, managedObj.getFieldBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, managedObj.getFieldBinaryList().get(1));
+        assertEquals(2, managedObj.getFieldLongList().size());
+        assertEquals((Long) 2L, managedObj.getFieldLongList().get(0));
+        assertEquals((Long) 3L, managedObj.getFieldLongList().get(1));
+        assertEquals(2, managedObj.getFieldIntegerList().size());
+        assertEquals((Integer) 2, managedObj.getFieldIntegerList().get(0));
+        assertEquals((Integer) 3, managedObj.getFieldIntegerList().get(1));
+        assertEquals(2, managedObj.getFieldShortList().size());
+        assertEquals((Short) (short) 2, managedObj.getFieldShortList().get(0));
+        assertEquals((Short) (short) 3, managedObj.getFieldShortList().get(1));
+        assertEquals(2, managedObj.getFieldByteList().size());
+        assertEquals((Byte) (byte) 2, managedObj.getFieldByteList().get(0));
+        assertEquals((Byte) (byte) 3, managedObj.getFieldByteList().get(1));
+        assertEquals(2, managedObj.getFieldDoubleList().size());
+        assertEquals((Double) 2D, managedObj.getFieldDoubleList().get(0));
+        assertEquals((Double) 3D, managedObj.getFieldDoubleList().get(1));
+        assertEquals(2, managedObj.getFieldFloatList().size());
+        assertEquals((Float) 2F, managedObj.getFieldFloatList().get(0));
+        assertEquals((Float) 3F, managedObj.getFieldFloatList().get(1));
+        assertEquals(2, managedObj.getFieldDateList().size());
+        assertEquals(new Date(2L), managedObj.getFieldDateList().get(0));
+        assertEquals(new Date(3L), managedObj.getFieldDateList().get(1));
+
         // Makes sure that excess object by default value is not created.
         assertEquals(2, realm.where(RandomPrimaryKey.class).count());
     }
@@ -2820,6 +2925,17 @@ public void copyFromRealm_defaultValuesAreIgnored() {
             list.add(listItem);
             obj.setFieldList(list);
 
+            obj.setFieldStringList(new RealmList<>("2", "3"));
+            obj.setFieldBooleanList(new RealmList<>(true, false));
+            obj.setFieldBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+            obj.setFieldLongList(new RealmList<>(2L, 3L));
+            obj.setFieldIntegerList(new RealmList<>(2, 3));
+            obj.setFieldShortList(new RealmList<>((short) 2, (short) 3));
+            obj.setFieldByteList(new RealmList<>((byte) 2, (byte) 3));
+            obj.setFieldDoubleList(new RealmList<>(2D, 3D));
+            obj.setFieldFloatList(new RealmList<>(2F, 3F));
+            obj.setFieldDateList(new RealmList<>(new Date(2L), new Date(3L)));
+
             managedObj = realm.copyToRealm(obj);
         }
         realm.commitTransaction();
@@ -2838,10 +2954,42 @@ public void copyFromRealm_defaultValuesAreIgnored() {
         assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0D);
         assertEquals(managedObj.isFieldBoolean(), copy.isFieldBoolean());
         assertEquals(managedObj.getFieldDate(), copy.getFieldDate());
-        assertTrue(Arrays.equals(managedObj.getFieldBinary(), copy.getFieldBinary()));
+        assertArrayEquals(managedObj.getFieldBinary(), copy.getFieldBinary());
         assertEquals(managedObj.getFieldObject().getFieldInt(), copy.getFieldObject().getFieldInt());
         assertEquals(1, copy.getFieldList().size());
+        //noinspection ConstantConditions
         assertEquals(managedObj.getFieldList().first().getFieldInt(), copy.getFieldList().first().getFieldInt());
+
+        assertEquals(2, managedObj.getFieldStringList().size());
+        assertEquals("2", managedObj.getFieldStringList().get(0));
+        assertEquals("3", managedObj.getFieldStringList().get(1));
+        assertEquals(2, managedObj.getFieldBooleanList().size());
+        assertEquals(true, managedObj.getFieldBooleanList().get(0));
+        assertEquals(false, managedObj.getFieldBooleanList().get(1));
+        assertEquals(2, managedObj.getFieldBinaryList().size());
+        assertArrayEquals(new byte[] {2}, managedObj.getFieldBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, managedObj.getFieldBinaryList().get(1));
+        assertEquals(2, managedObj.getFieldLongList().size());
+        assertEquals((Long) 2L, managedObj.getFieldLongList().get(0));
+        assertEquals((Long) 3L, managedObj.getFieldLongList().get(1));
+        assertEquals(2, managedObj.getFieldIntegerList().size());
+        assertEquals((Integer) 2, managedObj.getFieldIntegerList().get(0));
+        assertEquals((Integer) 3, managedObj.getFieldIntegerList().get(1));
+        assertEquals(2, managedObj.getFieldShortList().size());
+        assertEquals((Short) (short) 2, managedObj.getFieldShortList().get(0));
+        assertEquals((Short) (short) 3, managedObj.getFieldShortList().get(1));
+        assertEquals(2, managedObj.getFieldByteList().size());
+        assertEquals((Byte) (byte) 2, managedObj.getFieldByteList().get(0));
+        assertEquals((Byte) (byte) 3, managedObj.getFieldByteList().get(1));
+        assertEquals(2, managedObj.getFieldDoubleList().size());
+        assertEquals((Double) 2D, managedObj.getFieldDoubleList().get(0));
+        assertEquals((Double) 3D, managedObj.getFieldDoubleList().get(1));
+        assertEquals(2, managedObj.getFieldFloatList().size());
+        assertEquals((Float) 2F, managedObj.getFieldFloatList().get(0));
+        assertEquals((Float) 3F, managedObj.getFieldFloatList().get(1));
+        assertEquals(2, managedObj.getFieldDateList().size());
+        assertEquals(new Date(2L), managedObj.getFieldDateList().get(0));
+        assertEquals(new Date(3L), managedObj.getFieldDateList().get(1));
     }
 
     // Tests close Realm in another thread different from where it is created.
@@ -4157,6 +4305,7 @@ public void init_waitForFilesDir() throws NoSuchMethodException, InvocationTarge
         when(mockContext.getFilesDir()).then(new Answer<File>() {
             int calls = 0;
             File userFolder = tmpFolder.newFolder();
+
             @Override
             public File answer(InvocationOnMock invocationOnMock) throws Throwable {
                 calls++;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index d253569dcb..530ca471b2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -92,21 +92,29 @@ public void onResult(int count) {
     }
 
     public static RealmFieldType getColumnType(Object o) {
-        if (o instanceof Boolean)
+        if (o instanceof Boolean) {
             return RealmFieldType.BOOLEAN;
-        if (o instanceof String)
+        }
+        if (o instanceof String) {
             return RealmFieldType.STRING;
-        if (o instanceof Long)
+        }
+        if (o instanceof Long) {
             return RealmFieldType.INTEGER;
-        if (o instanceof Float)
+        }
+        if (o instanceof Float) {
             return RealmFieldType.FLOAT;
-        if (o instanceof Double)
+        }
+        if (o instanceof Double) {
             return RealmFieldType.DOUBLE;
-        if (o instanceof Date)
+        }
+        if (o instanceof Date) {
             return RealmFieldType.DATE;
-        if (o instanceof byte[])
+        }
+        if (o instanceof byte[]) {
             return RealmFieldType.BINARY;
-        return RealmFieldType.UNSUPPORTED_MIXED;
+        }
+
+        throw new IllegalArgumentException("Unsupported type");
     }
 
     /**
@@ -203,8 +211,6 @@ public static long addRowWithValues(Table table, Object... values) {
                         table.setBinaryByteArray(columnIndex, rowIndex, (byte[]) value, false);
                     }
                     break;
-                case UNSUPPORTED_MIXED:
-                case UNSUPPORTED_TABLE:
                 default:
                     throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int) columnIndex]));
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 22e509c956..8a85897b55 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -45,6 +45,18 @@
     public static final String FIELD_BINARY = "fieldBinary";
     public static final String FIELD_OBJECT = "fieldObject";
     public static final String FIELD_LIST = "fieldList";
+
+    public static final String FIELD_STRING_LIST = "fieldStringList";
+    public static final String FIELD_BINARY_LIST = "fieldBinaryList";
+    public static final String FIELD_BOOLEAN_LIST = "fieldBooleanList";
+    public static final String FIELD_LONG_LIST = "fieldLongList";
+    public static final String FIELD_INTEGER_LIST = "fieldIntegerList";
+    public static final String FIELD_SHORT_LIST = "fieldShortList";
+    public static final String FIELD_BYTE_LIST = "fieldByteList";
+    public static final String FIELD_DOUBLE_LIST = "fieldDoubleList";
+    public static final String FIELD_FLOAT_LIST = "fieldFloatList";
+    public static final String FIELD_DATE_LIST = "fieldDateList";
+
     public static final String FIELD_LO_OBJECT = "objectParents";
     public static final String FIELD_LO_LIST = "listParents";
 
@@ -77,6 +89,17 @@
     private AllJavaTypes fieldObject;
     private RealmList<AllJavaTypes> fieldList;
 
+    private RealmList<String> fieldStringList;
+    private RealmList<byte[]> fieldBinaryList;
+    private RealmList<Boolean> fieldBooleanList;
+    private RealmList<Long> fieldLongList;
+    private RealmList<Integer> fieldIntegerList;
+    private RealmList<Short> fieldShortList;
+    private RealmList<Byte> fieldByteList;
+    private RealmList<Double> fieldDoubleList;
+    private RealmList<Float> fieldFloatList;
+    private RealmList<Date> fieldDateList;
+
     @LinkingObjects(FIELD_OBJECT)
     private final RealmResults<AllJavaTypes> objectParents = null;
 
@@ -203,6 +226,86 @@ public void setFieldList(RealmList<AllJavaTypes> columnRealmList) {
         this.fieldList = columnRealmList;
     }
 
+    public RealmList<String> getFieldStringList() {
+        return fieldStringList;
+    }
+
+    public void setFieldStringList(RealmList<String> fieldStringList) {
+        this.fieldStringList = fieldStringList;
+    }
+
+    public RealmList<byte[]> getFieldBinaryList() {
+        return fieldBinaryList;
+    }
+
+    public void setFieldBinaryList(RealmList<byte[]> fieldBinaryList) {
+        this.fieldBinaryList = fieldBinaryList;
+    }
+
+    public RealmList<Boolean> getFieldBooleanList() {
+        return fieldBooleanList;
+    }
+
+    public void setFieldBooleanList(RealmList<Boolean> fieldBooleanList) {
+        this.fieldBooleanList = fieldBooleanList;
+    }
+
+    public RealmList<Long> getFieldLongList() {
+        return fieldLongList;
+    }
+
+    public void setFieldLongList(RealmList<Long> fieldLongList) {
+        this.fieldLongList = fieldLongList;
+    }
+
+    public RealmList<Integer> getFieldIntegerList() {
+        return fieldIntegerList;
+    }
+
+    public void setFieldIntegerList(RealmList<Integer> fieldIntegerList) {
+        this.fieldIntegerList = fieldIntegerList;
+    }
+
+    public RealmList<Short> getFieldShortList() {
+        return fieldShortList;
+    }
+
+    public void setFieldShortList(RealmList<Short> fieldShortList) {
+        this.fieldShortList = fieldShortList;
+    }
+
+    public RealmList<Byte> getFieldByteList() {
+        return fieldByteList;
+    }
+
+    public void setFieldByteList(RealmList<Byte> fieldByteList) {
+        this.fieldByteList = fieldByteList;
+    }
+
+    public RealmList<Double> getFieldDoubleList() {
+        return fieldDoubleList;
+    }
+
+    public void setFieldDoubleList(RealmList<Double> fieldDoubleList) {
+        this.fieldDoubleList = fieldDoubleList;
+    }
+
+    public RealmList<Float> getFieldFloatList() {
+        return fieldFloatList;
+    }
+
+    public void setFieldFloatList(RealmList<Float> fieldFloatList) {
+        this.fieldFloatList = fieldFloatList;
+    }
+
+    public RealmList<Date> getFieldDateList() {
+        return fieldDateList;
+    }
+
+    public void setFieldDateList(RealmList<Date> fieldDateList) {
+        this.fieldDateList = fieldDateList;
+    }
+
     public RealmResults<AllJavaTypes> getObjectParents() {
         return objectParents;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
index 5e7d80bacc..f4322445aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -37,8 +37,18 @@
     public static final String FIELD_REALMOBJECT = "columnRealmObject";
     public static final String FIELD_REALMLIST = "columnRealmList";
 
+    public static final String FIELD_STRING_LIST = "columnStringList";
+    public static final String FIELD_BINARY_LIST = "columnBinaryList";
+    public static final String FIELD_BOOLEAN_LIST = "columnBooleanList";
+    public static final String FIELD_LONG_LIST = "columnLongList";
+    public static final String FIELD_DOUBLE_LIST = "columnDoubleList";
+    public static final String FIELD_FLOAT_LIST = "columnFloatList";
+    public static final String FIELD_DATE_LIST = "columnDateList";
+
     public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT
-            = new String[] {FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
+            = new String[] {FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT,
+            FIELD_STRING_LIST, FIELD_BINARY_LIST, FIELD_BOOLEAN_LIST, FIELD_LONG_LIST,
+            FIELD_DOUBLE_LIST, FIELD_FLOAT_LIST, FIELD_DATE_LIST};
 
     @Required
     private String columnString = "";
@@ -55,6 +65,14 @@
     private Dog columnRealmObject;
     private RealmList<Dog> columnRealmList;
 
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
     public String getColumnString() {
         return columnString;
     }
@@ -130,4 +148,60 @@ public void setColumnRealmObject(Dog columnRealmObject) {
     public void setColumnRealmList(RealmList<Dog> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
+
+    public RealmList<String> getColumnStringList() {
+        return columnStringList;
+    }
+
+    public void setColumnStringList(RealmList<String> columnStringList) {
+        this.columnStringList = columnStringList;
+    }
+
+    public RealmList<byte[]> getColumnBinaryList() {
+        return columnBinaryList;
+    }
+
+    public void setColumnBinaryList(RealmList<byte[]> columnBinaryList) {
+        this.columnBinaryList = columnBinaryList;
+    }
+
+    public RealmList<Boolean> getColumnBooleanList() {
+        return columnBooleanList;
+    }
+
+    public void setColumnBooleanList(RealmList<Boolean> columnBooleanList) {
+        this.columnBooleanList = columnBooleanList;
+    }
+
+    public RealmList<Long> getColumnLongList() {
+        return columnLongList;
+    }
+
+    public void setColumnLongList(RealmList<Long> columnLongList) {
+        this.columnLongList = columnLongList;
+    }
+
+    public RealmList<Double> getColumnDoubleList() {
+        return columnDoubleList;
+    }
+
+    public void setColumnDoubleList(RealmList<Double> columnDoubleList) {
+        this.columnDoubleList = columnDoubleList;
+    }
+
+    public RealmList<Float> getColumnFloatList() {
+        return columnFloatList;
+    }
+
+    public void setColumnFloatList(RealmList<Float> columnFloatList) {
+        this.columnFloatList = columnFloatList;
+    }
+
+    public RealmList<Date> getColumnDateList() {
+        return columnDateList;
+    }
+
+    public void setColumnDateList(RealmList<Date> columnDateList) {
+        this.columnDateList = columnDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
index 5965b6d031..c6bff3fda0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
@@ -35,6 +35,14 @@
     private RealmList<DogPrimaryKey> columnRealmList;
     private Boolean columnBoxedBoolean;
 
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
     public String getColumnString() {
         return columnString;
     }
@@ -114,4 +122,60 @@ public Boolean getColumnBoxedBoolean() {
     public void setColumnBoxedBoolean(Boolean columnBoxedBoolean) {
         this.columnBoxedBoolean = columnBoxedBoolean;
     }
+
+    public RealmList<String> getColumnStringList() {
+        return columnStringList;
+    }
+
+    public void setColumnStringList(RealmList<String> columnStringList) {
+        this.columnStringList = columnStringList;
+    }
+
+    public RealmList<byte[]> getColumnBinaryList() {
+        return columnBinaryList;
+    }
+
+    public void setColumnBinaryList(RealmList<byte[]> columnBinaryList) {
+        this.columnBinaryList = columnBinaryList;
+    }
+
+    public RealmList<Boolean> getColumnBooleanList() {
+        return columnBooleanList;
+    }
+
+    public void setColumnBooleanList(RealmList<Boolean> columnBooleanList) {
+        this.columnBooleanList = columnBooleanList;
+    }
+
+    public RealmList<Long> getColumnLongList() {
+        return columnLongList;
+    }
+
+    public void setColumnLongList(RealmList<Long> columnLongList) {
+        this.columnLongList = columnLongList;
+    }
+
+    public RealmList<Double> getColumnDoubleList() {
+        return columnDoubleList;
+    }
+
+    public void setColumnDoubleList(RealmList<Double> columnDoubleList) {
+        this.columnDoubleList = columnDoubleList;
+    }
+
+    public RealmList<Float> getColumnFloatList() {
+        return columnFloatList;
+    }
+
+    public void setColumnFloatList(RealmList<Float> columnFloatList) {
+        this.columnFloatList = columnFloatList;
+    }
+
+    public RealmList<Date> getColumnDateList() {
+        return columnDateList;
+    }
+
+    public void setColumnDateList(RealmList<Date> columnDateList) {
+        this.columnDateList = columnDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
index 0378e64817..c9e13697d3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
@@ -27,42 +27,63 @@
 public class DefaultValueOfField extends RealmObject {
 
     public static final String CLASS_NAME = "DefaultValueOfField";
-    public static String FIELD_IGNORED = "fieldIgnored";
-    public static String FIELD_RANDOM_STRING = "fieldRandomString";
-    public static String FIELD_STRING = "fieldString";
-    public static String FIELD_SHORT = "fieldShort";
-    public static String FIELD_INT = "fieldInt";
-    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
-    public static String FIELD_LONG = "fieldLong";
-    public static String FIELD_BYTE = "fieldByte";
-    public static String FIELD_FLOAT = "fieldFloat";
-    public static String FIELD_DOUBLE = "fieldDouble";
-    public static String FIELD_BOOLEAN = "fieldBoolean";
-    public static String FIELD_DATE = "fieldDate";
-    public static String FIELD_BINARY = "fieldBinary";
-    public static String FIELD_OBJECT = "fieldObject";
-    public static String FIELD_LIST = "fieldList";
-
-
-    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
-    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
-    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
-    public static int FIELD_INT_DEFAULT_VALUE = 123456;
-    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
-    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
-    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
-    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
-    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
-    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
-    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
-    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
-    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
-    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+    public static final String FIELD_IGNORED = "fieldIgnored";
+    public static final String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static final String FIELD_STRING = "fieldString";
+    public static final String FIELD_SHORT = "fieldShort";
+    public static final String FIELD_INT = "fieldInt";
+    public static final String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static final String FIELD_LONG = "fieldLong";
+    public static final String FIELD_BYTE = "fieldByte";
+    public static final String FIELD_FLOAT = "fieldFloat";
+    public static final String FIELD_DOUBLE = "fieldDouble";
+    public static final String FIELD_BOOLEAN = "fieldBoolean";
+    public static final String FIELD_DATE = "fieldDate";
+    public static final String FIELD_BINARY = "fieldBinary";
+    public static final String FIELD_OBJECT = "fieldObject";
+    public static final String FIELD_LIST = "fieldList";
+
+
+    public static final String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static final String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static final short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static final int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static final long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static final long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static final byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static final float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static final double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static final boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static final Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static final byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static final RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static final RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+    public static final RealmList<String> FIELD_STRING_LIST_DEFAULT_VALUE;
+    public static final RealmList<Boolean> FIELD_BOOLEAN_LIST_DEFAULT_VALUE;
+    public static final RealmList<byte[]> FIELD_BINARY_LIST_DEFAULT_VALUE;
+    public static final RealmList<Long> FIELD_LONG_LIST_DEFAULT_VALUE;
+    public static final RealmList<Integer> FIELD_INTEGER_LIST_DEFAULT_VALUE;
+    public static final RealmList<Short> FIELD_SHORT_LIST_DEFAULT_VALUE;
+    public static final RealmList<Byte> FIELD_BYTE_LIST_DEFAULT_VALUE;
+    public static final RealmList<Double> FIELD_DOUBLE_LIST_DEFAULT_VALUE;
+    public static final RealmList<Float> FIELD_FLOAT_LIST_DEFAULT_VALUE;
+    public static final RealmList<Date> FIELD_DATE_LIST_DEFAULT_VALUE;
 
     static {
         FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
         FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
         FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+
+        FIELD_STRING_LIST_DEFAULT_VALUE = new RealmList<>("1");
+        FIELD_BOOLEAN_LIST_DEFAULT_VALUE = new RealmList<>(true);
+        FIELD_BINARY_LIST_DEFAULT_VALUE = new RealmList<>(new byte[] {1});
+        FIELD_LONG_LIST_DEFAULT_VALUE = new RealmList<>(1L);
+        FIELD_INTEGER_LIST_DEFAULT_VALUE = new RealmList<>(1);
+        FIELD_SHORT_LIST_DEFAULT_VALUE = new RealmList<>((short) 1);
+        FIELD_BYTE_LIST_DEFAULT_VALUE = new RealmList<>((byte) 1);
+        FIELD_DOUBLE_LIST_DEFAULT_VALUE = new RealmList<>(1D);
+        FIELD_FLOAT_LIST_DEFAULT_VALUE = new RealmList<>(1F);
+        FIELD_DATE_LIST_DEFAULT_VALUE = new RealmList<>(new Date(1));
     }
 
     public static String lastRandomStringValue;
@@ -83,8 +104,18 @@
     private RandomPrimaryKey fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
     private RealmList<RandomPrimaryKey> fieldList = FIELD_LIST_DEFAULT_VALUE;
 
-    public DefaultValueOfField() {
+    private RealmList<String> fieldStringList = FIELD_STRING_LIST_DEFAULT_VALUE;
+    private RealmList<byte[]> fieldBinaryList = FIELD_BINARY_LIST_DEFAULT_VALUE;
+    private RealmList<Boolean> fieldBooleanList = FIELD_BOOLEAN_LIST_DEFAULT_VALUE;
+    private RealmList<Long> fieldLongList = FIELD_LONG_LIST_DEFAULT_VALUE;
+    private RealmList<Integer> fieldIntegerList = FIELD_INTEGER_LIST_DEFAULT_VALUE;
+    private RealmList<Short> fieldShortList = FIELD_SHORT_LIST_DEFAULT_VALUE;
+    private RealmList<Byte> fieldByteList = FIELD_BYTE_LIST_DEFAULT_VALUE;
+    private RealmList<Double> fieldDoubleList = FIELD_DOUBLE_LIST_DEFAULT_VALUE;
+    private RealmList<Float> fieldFloatList = FIELD_FLOAT_LIST_DEFAULT_VALUE;
+    private RealmList<Date> fieldDateList = FIELD_DATE_LIST_DEFAULT_VALUE;
 
+    public DefaultValueOfField() {
     }
 
     public DefaultValueOfField(long fieldLong) {
@@ -210,4 +241,84 @@ public void setFieldObject(RandomPrimaryKey fieldObject) {
     public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
         this.fieldList = fieldList;
     }
+
+    public RealmList<String> getFieldStringList() {
+        return fieldStringList;
+    }
+
+    public void setFieldStringList(RealmList<String> fieldStringList) {
+        this.fieldStringList = fieldStringList;
+    }
+
+    public RealmList<byte[]> getFieldBinaryList() {
+        return fieldBinaryList;
+    }
+
+    public void setFieldBinaryList(RealmList<byte[]> fieldBinaryList) {
+        this.fieldBinaryList = fieldBinaryList;
+    }
+
+    public RealmList<Boolean> getFieldBooleanList() {
+        return fieldBooleanList;
+    }
+
+    public void setFieldBooleanList(RealmList<Boolean> fieldBooleanList) {
+        this.fieldBooleanList = fieldBooleanList;
+    }
+
+    public RealmList<Long> getFieldLongList() {
+        return fieldLongList;
+    }
+
+    public void setFieldLongList(RealmList<Long> fieldLongList) {
+        this.fieldLongList = fieldLongList;
+    }
+
+    public RealmList<Integer> getFieldIntegerList() {
+        return fieldIntegerList;
+    }
+
+    public void setFieldIntegerList(RealmList<Integer> fieldIntegerList) {
+        this.fieldIntegerList = fieldIntegerList;
+    }
+
+    public RealmList<Short> getFieldShortList() {
+        return fieldShortList;
+    }
+
+    public void setFieldShortList(RealmList<Short> fieldShortList) {
+        this.fieldShortList = fieldShortList;
+    }
+
+    public RealmList<Byte> getFieldByteList() {
+        return fieldByteList;
+    }
+
+    public void setFieldByteList(RealmList<Byte> fieldByteList) {
+        this.fieldByteList = fieldByteList;
+    }
+
+    public RealmList<Double> getFieldDoubleList() {
+        return fieldDoubleList;
+    }
+
+    public void setFieldDoubleList(RealmList<Double> fieldDoubleList) {
+        this.fieldDoubleList = fieldDoubleList;
+    }
+
+    public RealmList<Float> getFieldFloatList() {
+        return fieldFloatList;
+    }
+
+    public void setFieldFloatList(RealmList<Float> fieldFloatList) {
+        this.fieldFloatList = fieldFloatList;
+    }
+
+    public RealmList<Date> getFieldDateList() {
+        return fieldDateList;
+    }
+
+    public void setFieldDateList(RealmList<Date> fieldDateList) {
+        this.fieldDateList = fieldDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
index db8d4a2dbb..47842e8796 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
@@ -66,6 +66,27 @@
     public static final String FIELD_LO_OBJECT = "objectParents";
     public static final String FIELD_LO_LIST = "listParents";
 
+    public static final String FIELD_STRING_LIST_NOT_NULL = "fieldStringListNotNull";
+    public static final String FIELD_STRING_LIST_NULL = "fieldStringListNull";
+    public static final String FIELD_BINARY_LIST_NOT_NULL = "fieldBinaryListNotNull";
+    public static final String FIELD_BINARY_LIST_NULL = "fieldBinaryListNull";
+    public static final String FIELD_BOOLEAN_LIST_NOT_NULL = "fieldBooleanListNotNull";
+    public static final String FIELD_BOOLEAN_LIST_NULL = "fieldBooleanListNull";
+    public static final String FIELD_LONG_LIST_NOT_NULL = "fieldLongListNotNull";
+    public static final String FIELD_LONG_LIST_NULL = "fieldLongListNull";
+    public static final String FIELD_INTEGER_LIST_NOT_NULL = "fieldIntegerListNotNull";
+    public static final String FIELD_INTEGER_LIST_NULL = "fieldIntegerListNull";
+    public static final String FIELD_SHORT_LIST_NOT_NULL = "fieldShortListNotNull";
+    public static final String FIELD_SHORT_LIST_NULL = "fieldShortListNull";
+    public static final String FIELD_BYTE_LIST_NOT_NULL = "fieldByteListNotNull";
+    public static final String FIELD_BYTE_LIST_NULL = "fieldByteListNull";
+    public static final String FIELD_DOUBLE_LIST_NOT_NULL = "fieldDoubleListNotNull";
+    public static final String FIELD_DOUBLE_LIST_NULL = "fieldDoubleListNull";
+    public static final String FIELD_FLOAT_LIST_NOT_NULL = "fieldFloatListNotNull";
+    public static final String FIELD_FLOAT_LIST_NULL = "fieldFloatListNull";
+    public static final String FIELD_DATE_LIST_NOT_NULL = "fieldDateListNotNull";
+    public static final String FIELD_DATE_LIST_NULL = "fieldDateListNull";
+
     @PrimaryKey
     private int id;
 
@@ -114,6 +135,46 @@
     // never nullable
     private RealmList<NullTypes> fieldListNull;
 
+    @Required
+    private RealmList<String> fieldStringListNotNull;
+    private RealmList<String> fieldStringListNull;
+
+    @Required
+    private RealmList<byte[]> fieldBinaryListNotNull;
+    private RealmList<byte[]> fieldBinaryListNull;
+
+    @Required
+    private RealmList<Boolean> fieldBooleanListNotNull;
+    private RealmList<Boolean> fieldBooleanListNull;
+
+    @Required
+    private RealmList<Long> fieldLongListNotNull;
+    private RealmList<Long> fieldLongListNull;
+
+    @Required
+    private RealmList<Integer> fieldIntegerListNotNull;
+    private RealmList<Integer> fieldIntegerListNull;
+
+    @Required
+    private RealmList<Short> fieldShortListNotNull;
+    private RealmList<Short> fieldShortListNull;
+
+    @Required
+    private RealmList<Byte> fieldByteListNotNull;
+    private RealmList<Byte> fieldByteListNull;
+
+    @Required
+    private RealmList<Double> fieldDoubleListNotNull;
+    private RealmList<Double> fieldDoubleListNull;
+
+    @Required
+    private RealmList<Float> fieldFloatListNotNull;
+    private RealmList<Float> fieldFloatListNull;
+
+    @Required
+    private RealmList<Date> fieldDateListNotNull;
+    private RealmList<Date> fieldDateListNull;
+
     // never nullable
     @LinkingObjects(FIELD_OBJECT_NULL)
     private final RealmResults<NullTypes> objectParents = null;
@@ -313,4 +374,164 @@ public void setFieldListNull(RealmList<NullTypes> fieldListNull) {
     public RealmResults<NullTypes> getListParents() {
         return listParents;
     }
+
+    public RealmList<String> getFieldStringListNotNull() {
+        return fieldStringListNotNull;
+    }
+
+    public void setFieldStringListNotNull(RealmList<String> fieldStringListNotNull) {
+        this.fieldStringListNotNull = fieldStringListNotNull;
+    }
+
+    public RealmList<String> getFieldStringListNull() {
+        return fieldStringListNull;
+    }
+
+    public void setFieldStringListNull(RealmList<String> fieldStringListNull) {
+        this.fieldStringListNull = fieldStringListNull;
+    }
+
+    public RealmList<byte[]> getFieldBinaryListNotNull() {
+        return fieldBinaryListNotNull;
+    }
+
+    public void setFieldBinaryListNotNull(RealmList<byte[]> fieldBinaryListNotNull) {
+        this.fieldBinaryListNotNull = fieldBinaryListNotNull;
+    }
+
+    public RealmList<byte[]> getFieldBinaryListNull() {
+        return fieldBinaryListNull;
+    }
+
+    public void setFieldBinaryListNull(RealmList<byte[]> fieldBinaryListNull) {
+        this.fieldBinaryListNull = fieldBinaryListNull;
+    }
+
+    public RealmList<Boolean> getFieldBooleanListNotNull() {
+        return fieldBooleanListNotNull;
+    }
+
+    public void setFieldBooleanListNotNull(RealmList<Boolean> fieldBooleanListNotNull) {
+        this.fieldBooleanListNotNull = fieldBooleanListNotNull;
+    }
+
+    public RealmList<Boolean> getFieldBooleanListNull() {
+        return fieldBooleanListNull;
+    }
+
+    public void setFieldBooleanListNull(RealmList<Boolean> fieldBooleanListNull) {
+        this.fieldBooleanListNull = fieldBooleanListNull;
+    }
+
+    public RealmList<Long> getFieldLongListNotNull() {
+        return fieldLongListNotNull;
+    }
+
+    public void setFieldLongListNotNull(RealmList<Long> fieldLongListNotNull) {
+        this.fieldLongListNotNull = fieldLongListNotNull;
+    }
+
+    public RealmList<Long> getFieldLongListNull() {
+        return fieldLongListNull;
+    }
+
+    public void setFieldLongListNull(RealmList<Long> fieldLongListNull) {
+        this.fieldLongListNull = fieldLongListNull;
+    }
+
+    public RealmList<Integer> getFieldIntegerListNotNull() {
+        return fieldIntegerListNotNull;
+    }
+
+    public void setFieldIntegerListNotNull(RealmList<Integer> fieldIntegerListNotNull) {
+        this.fieldIntegerListNotNull = fieldIntegerListNotNull;
+    }
+
+    public RealmList<Integer> getFieldIntegerListNull() {
+        return fieldIntegerListNull;
+    }
+
+    public void setFieldIntegerListNull(RealmList<Integer> fieldIntegerListNull) {
+        this.fieldIntegerListNull = fieldIntegerListNull;
+    }
+
+    public RealmList<Short> getFieldShortListNotNull() {
+        return fieldShortListNotNull;
+    }
+
+    public void setFieldShortListNotNull(RealmList<Short> fieldShortListNotNull) {
+        this.fieldShortListNotNull = fieldShortListNotNull;
+    }
+
+    public RealmList<Short> getFieldShortListNull() {
+        return fieldShortListNull;
+    }
+
+    public void setFieldShortListNull(RealmList<Short> fieldShortListNull) {
+        this.fieldShortListNull = fieldShortListNull;
+    }
+
+    public RealmList<Byte> getFieldByteListNotNull() {
+        return fieldByteListNotNull;
+    }
+
+    public void setFieldByteListNotNull(RealmList<Byte> fieldByteListNotNull) {
+        this.fieldByteListNotNull = fieldByteListNotNull;
+    }
+
+    public RealmList<Byte> getFieldByteListNull() {
+        return fieldByteListNull;
+    }
+
+    public void setFieldByteListNull(RealmList<Byte> fieldByteListNull) {
+        this.fieldByteListNull = fieldByteListNull;
+    }
+
+    public RealmList<Double> getFieldDoubleListNotNull() {
+        return fieldDoubleListNotNull;
+    }
+
+    public void setFieldDoubleListNotNull(RealmList<Double> fieldDoubleListNotNull) {
+        this.fieldDoubleListNotNull = fieldDoubleListNotNull;
+    }
+
+    public RealmList<Double> getFieldDoubleListNull() {
+        return fieldDoubleListNull;
+    }
+
+    public void setFieldDoubleListNull(RealmList<Double> fieldDoubleListNull) {
+        this.fieldDoubleListNull = fieldDoubleListNull;
+    }
+
+    public RealmList<Float> getFieldFloatListNotNull() {
+        return fieldFloatListNotNull;
+    }
+
+    public void setFieldFloatListNotNull(RealmList<Float> fieldFloatListNotNull) {
+        this.fieldFloatListNotNull = fieldFloatListNotNull;
+    }
+
+    public RealmList<Float> getFieldFloatListNull() {
+        return fieldFloatListNull;
+    }
+
+    public void setFieldFloatListNull(RealmList<Float> fieldFloatListNull) {
+        this.fieldFloatListNull = fieldFloatListNull;
+    }
+
+    public RealmList<Date> getFieldDateListNotNull() {
+        return fieldDateListNotNull;
+    }
+
+    public void setFieldDateListNotNull(RealmList<Date> fieldDateListNotNull) {
+        this.fieldDateListNotNull = fieldDateListNotNull;
+    }
+
+    public RealmList<Date> getFieldDateListNull() {
+        return fieldDateListNull;
+    }
+
+    public void setFieldDateListNull(RealmList<Date> fieldDateListNull) {
+        this.fieldDateListNull = fieldDateListNull;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
new file mode 100644
index 0000000000..2b266233ce
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
@@ -0,0 +1,484 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class OsListTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SharedRealm sharedRealm;
+    private UncheckedRow row;
+    private OsObjectSchemaInfo testObjectSchemaInfo;
+
+    @Before
+    public void setUp() {
+        OsObjectSchemaInfo objectSchemaInfo = new OsObjectSchemaInfo.Builder("TestModel")
+                .addPersistedValueListProperty("longList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("doubleList", RealmFieldType.DOUBLE_LIST,  !Property.REQUIRED)
+                .addPersistedValueListProperty("floatList", RealmFieldType.FLOAT_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("booleanList", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("binaryList", RealmFieldType.BINARY_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("dateList", RealmFieldType.DATE_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("stringList", RealmFieldType.STRING_LIST, !Property.REQUIRED)
+
+                .addPersistedValueListProperty("requiredLongList", RealmFieldType.INTEGER_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredDoubleList", RealmFieldType.DOUBLE_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredFloatList", RealmFieldType.FLOAT_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredBooleanList", RealmFieldType.BOOLEAN_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredBinaryList", RealmFieldType.BINARY_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredDateList", RealmFieldType.DATE_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredStringList", RealmFieldType.STRING_LIST, Property.REQUIRED)
+
+                .build();
+        List<OsObjectSchemaInfo> objectSchemaInfoList = new ArrayList<OsObjectSchemaInfo>();
+        objectSchemaInfoList.add(objectSchemaInfo);
+
+        OsSchemaInfo schemaInfo = new OsSchemaInfo(objectSchemaInfoList);
+
+        RealmConfiguration config = configFactory.createConfiguration();
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true)
+                .schemaInfo(schemaInfo);
+        sharedRealm = SharedRealm.getInstance(configBuilder);
+        sharedRealm.beginTransaction();
+        Table table = sharedRealm.getTable(Table.getTableNameForClass("TestModel"));
+        row = table.getUncheckedRow(OsObject.createRow(table));
+        sharedRealm.commitTransaction();
+
+        schemaInfo = sharedRealm.getSchemaInfo();
+        testObjectSchemaInfo = schemaInfo.getObjectSchemaInfo("TestModel");
+
+        sharedRealm.beginTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.cancelTransaction();
+        sharedRealm.close();
+    }
+
+    private void addNull_insertNull_setNull_nullableList(OsList osList) {
+        assertNotNull(osList.getValue(1));
+        osList.insertNull(1);
+        assertNull(osList.getValue(1));
+
+        osList.addNull();
+        assertNull(osList.getValue(osList.size() - 1));
+
+        assertNotNull(osList.getValue(2));
+        osList.setNull(2);
+        assertNull(osList.getValue(2));
+    }
+
+    private void addNull_insertNull_setNull_requiredList(OsList osList) {
+        long initialSize = osList.size();
+        try {
+            osList.insertNull(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+
+        initialSize = osList.size();
+        try {
+            osList.addNull();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+
+        initialSize = osList.size();
+        try {
+            osList.setNull(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+    }
+
+    private void add_insert_set_values_long(OsList osList) {
+        osList.addLong(42);
+        Long value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42, value.longValue());
+
+        osList.insertLong(0, 24);
+        value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24, value.longValue());
+
+        osList.setLong(0, 42);
+        value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42, value.longValue());
+    }
+
+    @Test
+    public void add_insert_set_get_Long() {
+        long index = testObjectSchemaInfo.getProperty("longList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_long(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_get_set_required_Long() {
+        long index = testObjectSchemaInfo.getProperty("requiredLongList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_long(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_double(OsList osList) {
+        osList.addDouble(42d);
+        Double value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42d, value.doubleValue(), 0d);
+
+        osList.insertDouble(0, 24);
+        value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24d, value.longValue(), 0d);
+
+        osList.setDouble(0, 42);
+        value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42d, value.longValue(), 0d);
+    }
+
+    @Test
+    public void add_insert_set_get_Double() {
+        long index = testObjectSchemaInfo.getProperty("doubleList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_double(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_required_Double() {
+        long index = testObjectSchemaInfo.getProperty("requiredDoubleList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_double(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_float(OsList osList) {
+        osList.addFloat(42f);
+        Float value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42f, value.doubleValue(), 0f);
+
+        osList.insertFloat(0, 24f);
+        value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24f, value.longValue(), 0f);
+
+        osList.setFloat(0, 42f);
+        value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42f, value.longValue(), 0f);
+    }
+
+    @Test
+    public void add_insert_get_Float() {
+        long index = testObjectSchemaInfo.getProperty("floatList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_float(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_get_required_Float() {
+        long index = testObjectSchemaInfo.getProperty("requiredFloatList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_float(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_boolean(OsList osList) {
+        osList.addBoolean(true);
+        Boolean value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertTrue(value);
+
+        osList.insertBoolean(0, false);
+        value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertFalse(value);
+
+        osList.setBoolean(0, true);
+        value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertTrue(value);
+    }
+
+    @Test
+    public void add_insert_set_get_Boolean() {
+        long index = testObjectSchemaInfo.getProperty("booleanList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_boolean(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_required_Boolean() {
+        long index = testObjectSchemaInfo.getProperty("requiredBooleanList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_boolean(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_Date() {
+        long index = testObjectSchemaInfo.getProperty("dateList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        Date date42 = new Date(42);
+        Date date24 = new Date(24);
+
+        osList.addDate(null);
+        Date value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.addDate(date42);
+        value = (Date) osList.getValue(1);
+        assertNotNull(value);
+        assertEquals(date42, value);
+
+        osList.insertDate(0, null);
+        value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertDate(0, date24);
+        value = (Date) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(date24, value);
+
+        osList.insertNull(0);
+        value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setDate(5, date42);
+        value = (Date) osList.getValue(5);
+        assertNotNull(value);
+        assertEquals(date42, value);
+
+        osList.setDate(5, null);
+        value = (Date) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_Date() {
+        long index = testObjectSchemaInfo.getProperty("requiredDateList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertDate(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addDate(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setDate(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void add_insert_get_String() {
+        long index = testObjectSchemaInfo.getProperty("stringList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        osList.addString(null);
+        String value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.addString("42");
+        value = (String) osList.getValue(1);
+        assertNotNull(value);
+        assertEquals("42", value);
+
+        osList.insertString(0, null);
+        value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertString(0, "24");
+        value = (String) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals("24", value);
+
+        osList.insertNull(0);
+        value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setString(5, "24");
+        value = (String) osList.getValue(5);
+        assertNotNull(value);
+        assertEquals("24", value);
+
+        osList.setString(5, null);
+        value = (String) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_String() {
+        long index = testObjectSchemaInfo.getProperty("requiredStringList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertString(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addString(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setString(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void add_insert_get_Binary() {
+        long index = testObjectSchemaInfo.getProperty("binaryList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        byte[] bytes42 = new byte[1];
+        bytes42[0] = 42;
+        byte[] bytes24 = new byte[2];
+        bytes24[0] = 24;
+        bytes24[1] = 24;
+
+        osList.addBinary(null);
+        byte[] value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.addBinary(bytes42);
+        value = (byte[]) osList.getValue(1);
+        assertNotNull(value);
+        assertArrayEquals(bytes42, value);
+
+        osList.insertBinary(0, null);
+        value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertBinary(0, bytes24);
+        value = (byte[]) osList.getValue(0);
+        assertNotNull(value);
+        assertArrayEquals(bytes24, value);
+
+        osList.insertNull(0);
+        value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setBinary(5, bytes24);
+        value = (byte[]) osList.getValue(5);
+        assertNotNull(value);
+        assertArrayEquals(bytes24, value);
+
+        osList.setBinary(5, null);
+        value = (byte[]) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_Binary() {
+        long index = testObjectSchemaInfo.getProperty("requiredBinaryList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertBinary(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addBinary(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setBinary(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index 02ee939e37..a8c4bd22f5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -240,10 +240,14 @@ public void getInstanceForSort_shouldThrowOnLinkListField() {
         for (RealmFieldType type : RealmFieldType.values()) {
             if (!filter.contains(type)) {
                 switch (type) {
-                    case UNSUPPORTED_DATE:
-                    case UNSUPPORTED_TABLE:
-                    case UNSUPPORTED_MIXED:
                     case LINKING_OBJECTS: // TODO: should be supported?s
+                    case INTEGER_LIST: // FIXME zaki50 revisit this once Primitive List query is implemented
+                    case BOOLEAN_LIST:
+                    case STRING_LIST:
+                    case BINARY_LIST:
+                    case DATE_LIST:
+                    case FLOAT_LIST:
+                    case DOUBLE_LIST:
                         break;
                     case LIST:
                     case OBJECT:
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
index b7c6e43b90..e1c613eb86 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -28,7 +28,6 @@
 import java.util.Set;
 
 import io.realm.entities.StringOnly;
-import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 54172550a3..b2759133f5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -34,7 +34,6 @@
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 43339cab79..922044f17d 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -34,7 +34,6 @@
 
 import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createNamedTestUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index 16ceef31c0..c87639c9c6 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -21,7 +21,6 @@
 
 import org.hamcrest.CoreMatchers;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -42,7 +41,6 @@
 import io.realm.internal.SharedRealm;
 import io.realm.exceptions.IncompatibleSyncedFileException;
 import io.realm.objectserver.utils.StringOnlyModule;
-import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
similarity index 75%
rename from realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
rename to realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
index 23b8f908a5..9e7573c865 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package io.realm.rule;
+package io.realm;
 
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
+import io.realm.internal.OsRealmConfig;
+import io.realm.rule.TestRealmConfigurationFactory;
 
 /**
  * Test rule used for creating SyncConfigurations. Will ensure that any Realm files are deleted when the
@@ -26,6 +26,8 @@
 public class TestSyncConfigurationFactory extends TestRealmConfigurationFactory {
 
     public SyncConfiguration.Builder createSyncConfigurationBuilder(SyncUser user, String url) {
-        return new SyncConfiguration.Builder(user, url).directory(getRoot());
+        return new SyncConfiguration.Builder(user, url)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .directory(getRoot());
     }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
index 34731cedcf..e9b6330a90 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -14,49 +14,22 @@
  * limitations under the License.
  */
 
-#include <jni.h>
 #include "io_realm_internal_Collection.h"
 
 #include <shared_realm.hpp>
 #include <results.hpp>
 #include <list.hpp>
 
+#include "java_class_global_def.hpp"
 #include "java_sort_descriptor.hpp"
+#include "observable_collection_wrapper.hpp"
 #include "util.hpp"
-#include "java_class_global_def.hpp"
-
-#include "jni_util/java_class.hpp"
-#include "jni_util/java_global_weak_ref.hpp"
-#include "jni_util/java_method.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
 using namespace realm::_impl;
 
-// We need to control the life cycle of Results, weak ref of Java Collection object and the NotificationToken.
-// Wrap all three together, so when the Java Collection object gets GCed, all three of them will be invalidated.
-struct ResultsWrapper {
-    JavaGlobalWeakRef m_collection_weak_ref;
-    NotificationToken m_notification_token;
-    Results m_results;
-
-    ResultsWrapper(Results& results)
-        : m_collection_weak_ref()
-        , m_notification_token()
-        , m_results(std::move(results))
-    {
-    }
-
-    ResultsWrapper(ResultsWrapper&&) = delete;
-    ResultsWrapper& operator=(ResultsWrapper&&) = delete;
-
-    ResultsWrapper(ResultsWrapper const&) = delete;
-    ResultsWrapper& operator=(ResultsWrapper const&) = delete;
-
-    ~ResultsWrapper()
-    {
-    }
-};
+typedef ObservableCollectionWrapper<Results> ResultsWrapper;
 
 static void finalize_results(jlong ptr);
 
@@ -104,7 +77,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFro
 {
     TR_ENTER()
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
+        auto& list_wrapper = *reinterpret_cast<ObservableCollectionWrapper<List>*>(list_ptr);
+        auto& list = list_wrapper.collection();
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         Results results = j_sort_desc ?
             list.sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor()) :
@@ -122,7 +96,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(J
     TR_ENTER_PTR(native_ptr);
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto snapshot_results = wrapper->m_results.snapshot();
+        auto snapshot_results = wrapper->collection().snapshot();
         auto snapshot_wrapper = new ResultsWrapper(snapshot_results);
         return reinterpret_cast<jlong>(snapshot_wrapper);
     }
@@ -137,7 +111,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeContains(JNIE
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto row = reinterpret_cast<Row*>(native_row_ptr);
-        size_t index = wrapper->m_results.index_of(RowExpr(*row));
+        size_t index = wrapper->collection().index_of(RowExpr(*row));
         return to_jbool(index != not_found);
     }
     CATCH_STD();
@@ -150,7 +124,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetRow(JNIEnv* e
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.get(static_cast<size_t>(index));
+        auto row = wrapper->collection().get(static_cast<size_t>(index));
         return reinterpret_cast<jlong>(new Row(std::move(row)));
     }
     CATCH_STD()
@@ -162,7 +136,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv*
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto optional_row = wrapper->m_results.first();
+        auto optional_row = wrapper->collection().first();
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
@@ -176,7 +150,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv*
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto optional_row = wrapper->m_results.last();
+        auto optional_row = wrapper->collection().last();
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
@@ -190,7 +164,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeClear(JNIEnv* env
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        wrapper->m_results.clear();
+        wrapper->collection().clear();
     }
     CATCH_STD()
 }
@@ -200,7 +174,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSize(JNIEnv* env
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        return static_cast<jlong>(wrapper->m_results.size());
+        return static_cast<jlong>(wrapper->collection().size());
     }
     CATCH_STD()
     return 0;
@@ -217,13 +191,13 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
         Optional<Mixed> value;
         switch (agg_func) {
             case io_realm_internal_Collection_AGGREGATE_FUNCTION_MINIMUM:
-                value = wrapper->m_results.min(index);
+                value = wrapper->collection().min(index);
                 break;
             case io_realm_internal_Collection_AGGREGATE_FUNCTION_MAXIMUM:
-                value = wrapper->m_results.max(index);
+                value = wrapper->collection().max(index);
                 break;
             case io_realm_internal_Collection_AGGREGATE_FUNCTION_AVERAGE: {
-                Optional<double> value_count(wrapper->m_results.average(index));
+                Optional<double> value_count(wrapper->collection().average(index));
                 if (value_count) {
                     value = Optional<Mixed>(Mixed(value_count.value()));
                 }
@@ -233,7 +207,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
                 break;
             }
             case io_realm_internal_Collection_AGGREGATE_FUNCTION_SUM:
-                value = wrapper->m_results.sum(index);
+                value = wrapper->collection().sum(index);
                 break;
             default:
                 REALM_UNREACHABLE();
@@ -267,7 +241,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
+        auto sorted_result = wrapper->collection().sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
     }
     CATCH_STD()
@@ -281,7 +255,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv*
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto distinct_result =
-            wrapper->m_results.distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
+            wrapper->collection().distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
     }
     CATCH_STD()
@@ -293,38 +267,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStartListening(JN
 {
     TR_ENTER_PTR(native_ptr)
 
-    static JavaClass os_results_class(env, "io/realm/internal/Collection");
-    static JavaMethod notify_change_listeners(env, os_results_class, "notifyChangeListeners", "(J)V");
-
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        if (!wrapper->m_collection_weak_ref) {
-            wrapper->m_collection_weak_ref = JavaGlobalWeakRef(env, instance);
-        }
-
-        auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
-            // OS will call all notifiers' callback in one run, so check the Java exception first!!
-            if (env->ExceptionCheck())
-                return;
-
-            if (err) {
-                try {
-                    std::rethrow_exception(err);
-                }
-                catch (const std::exception& e) {
-                    realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
-                    return;
-                }
-            }
-
-            wrapper->m_collection_weak_ref.call_with_local_ref(env, [&](JNIEnv* local_env, jobject collection_obj) {
-                local_env->CallVoidMethod(
-                    collection_obj, notify_change_listeners,
-                    reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
-            });
-        };
-
-        wrapper->m_notification_token = wrapper->m_results.add_notification_callback(cb);
+        wrapper->start_listening(env, instance);
     }
     CATCH_STD()
 }
@@ -335,7 +280,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStopListening(JNI
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        wrapper->m_notification_token = {};
+        wrapper->stop_listening();
     }
     CATCH_STD()
 }
@@ -352,7 +297,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* en
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
 
-        auto table_view = wrapper->m_results.get_tableview();
+        auto table_view = wrapper->collection().get_tableview();
         Query* query =
             new Query(table_view.get_parent(), std::unique_ptr<TableViewBase>(new TableView(std::move(table_view))));
         return reinterpret_cast<jlong>(query);
@@ -369,7 +314,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv*
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto row = reinterpret_cast<Row*>(row_native_ptr);
 
-        return static_cast<jlong>(wrapper->m_results.index_of(RowExpr(*row)));
+        return static_cast<jlong>(wrapper->collection().index_of(RowExpr(*row)));
     }
     CATCH_STD()
     return npos;
@@ -380,7 +325,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JN
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.last();
+        auto row = wrapper->collection().last();
         if (row && row->is_attached()) {
             row->move_last_over();
             return JNI_TRUE;
@@ -396,7 +341,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(J
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.first();
+        auto row = wrapper->collection().first();
         if (row && row->is_attached()) {
             row->move_last_over();
             return JNI_TRUE;
@@ -413,7 +358,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* en
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.get(index);
+        auto row = wrapper->collection().get(index);
         if (row.is_attached()) {
             row.move_last_over();
         }
@@ -426,7 +371,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeIsValid(JNIEn
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        return wrapper->m_results.is_valid();
+        return wrapper->collection().is_valid();
     }
     CATCH_STD()
     return JNI_FALSE;
@@ -437,7 +382,7 @@ JNIEXPORT jbyte JNICALL Java_io_realm_internal_Collection_nativeGetMode(JNIEnv*
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        switch (wrapper->m_results.get_mode()) {
+        switch (wrapper->collection().get_mode()) {
             case Results::Mode::Empty:
                 return io_realm_internal_Collection_MODE_EMPTY;
             case Results::Mode::Table:
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
index 19ac174bc1..ccee1c9720 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
@@ -20,44 +20,95 @@
 #include <results.hpp>
 #include <shared_realm.hpp>
 
+#include "observable_collection_wrapper.hpp"
+#include "java_accessor.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 #include "util.hpp"
 
 using namespace realm;
+using namespace realm::util;
+using namespace realm::_impl;
 
-static void finalize_list(jlong ptr)
+typedef ObservableCollectionWrapper<List> ListWrapper;
+
+namespace {
+void finalize_list(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
-    delete reinterpret_cast<List*>(ptr);
+    delete reinterpret_cast<ListWrapper*>(ptr);
+}
+
+inline void add_value(JNIEnv* env, jlong list_ptr, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().add(context, value);
+}
+
+inline void insert_value(JNIEnv* env, jlong list_ptr, jlong pos, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().insert(context, pos, value);
 }
 
+inline void set_value(JNIEnv* env, jlong list_ptr, jlong pos, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().set(context, pos, value);
+}
+
+// Check nullable earlier https://github.com/realm/realm-object-store/issues/544
+inline void check_nullable(JNIEnv* env, jlong list_ptr, jobject jobject_ptr = nullptr)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+    if (!jobject_ptr && !is_nullable(wrapper.collection().get_type())) {
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                             "This 'RealmList' is not nullable. A non-null value is expected.");
+    }
+}
+} // anonymous namespace
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_list);
 }
 
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_OsList_nativeCreate(JNIEnv* env, jclass, jlong shared_realm_ptr, jlong row_ptr,
-                                                                        jlong column_index)
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_OsList_nativeCreate(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                        jlong row_ptr, jlong column_index)
 {
     TR_ENTER_PTR(row_ptr)
 
     try {
         auto& row = *reinterpret_cast<realm::Row*>(row_ptr);
 
-        if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, &row, column_index, type_LinkList)) {
+        if (!ROW_AND_COL_INDEX_VALID(env, &row, column_index)) {
             return 0;
         }
 
         auto& shared_realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);
-        LinkViewRef link_view_ref(row.get_linklist(column_index));
-        auto list_ptr = new List(shared_realm, link_view_ref);
+        jlong ret[2];
 
-        Table* target_table_ptr = &(link_view_ref)->get_target_table();
-        LangBindHelper::bind_table_ptr(target_table_ptr);
+        List list(shared_realm, *row.get_table(), column_index, row.get_index());
+        ListWrapper* wrapper_ptr = new ListWrapper(list);
+        ret[0] = reinterpret_cast<jlong>(wrapper_ptr);
 
-        jlong ret[2];
-        ret[0] = reinterpret_cast<jlong>(list_ptr);
-        ret[1] = reinterpret_cast<jlong>(target_table_ptr);
+        if (wrapper_ptr->collection().get_type() == PropertyType::Object) {
+            LinkViewRef link_view_ref(row.get_linklist(column_index));
+
+            Table* target_table_ptr = &(link_view_ref)->get_target_table();
+            LangBindHelper::bind_table_ptr(target_table_ptr);
+            ret[1] = reinterpret_cast<jlong>(target_table_ptr);
+        }
+        else {
+            ret[1] = reinterpret_cast<jlong>(nullptr);
+        }
 
         jlongArray ret_array = env->NewLongArray(2);
         if (!ret_array) {
@@ -77,8 +128,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetRow(JNIEnv* env,
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        auto row = list.get(column_index);
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        auto row = wrapper.collection().get(column_index);
         return reinterpret_cast<jlong>(new Row(std::move(row)));
     }
     CATCH_STD()
@@ -91,8 +142,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddRow(JNIEnv* env, j
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.add(static_cast<size_t>(target_row_index));
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().add(static_cast<size_t>(target_row_index));
     }
     CATCH_STD()
 }
@@ -103,8 +154,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertRow(JNIEnv* env
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.insert(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().insert(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
     }
     CATCH_STD()
 }
@@ -115,8 +166,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetRow(JNIEnv* env, j
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.set(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().set(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
     }
     CATCH_STD()
 }
@@ -127,8 +178,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeMove(JNIEnv* env, jcl
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.move(source_index, target_index);
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().move(source_index, target_index);
     }
     CATCH_STD()
 }
@@ -138,8 +189,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeRemove(JNIEnv* env, j
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.remove(index);
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().remove(index);
     }
     CATCH_STD()
 }
@@ -149,8 +200,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeRemoveAll(JNIEnv* env
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.remove_all();
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().remove_all();
     }
     CATCH_STD()
 }
@@ -160,8 +211,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeSize(JNIEnv* env, jc
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        return list.size();
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        return wrapper.collection().size();
     }
     CATCH_STD()
     return 0;
@@ -172,8 +223,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetQuery(JNIEnv* env
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        auto query = list.get_query();
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        auto query = wrapper.collection().get_query();
         return reinterpret_cast<jlong>(new Query(std::move(query)));
     }
     CATCH_STD()
@@ -185,8 +236,8 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsList_nativeIsValid(JNIEnv* e
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        return list.is_valid();
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        return wrapper.collection().is_valid();
     }
     CATCH_STD()
     return JNI_FALSE;
@@ -197,8 +248,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDelete(JNIEnv* env, j
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.delete_at(S(index));
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().delete_at(S(index));
     }
     CATCH_STD()
 }
@@ -208,8 +259,293 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDeleteAll(JNIEnv* env
     TR_ENTER_PTR(list_ptr)
 
     try {
-        auto& list = *reinterpret_cast<List*>(list_ptr);
-        list.delete_all();
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().delete_all();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeStartListening(JNIEnv* env, jobject instance,
+                                                                              jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ListWrapper*>(native_ptr);
+        wrapper->start_listening(env, instance);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ListWrapper*>(native_ptr);
+        wrapper->stop_listening();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddNull(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        add_value(env, list_ptr, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertNull(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        insert_value(env, list_ptr, pos, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetNull(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        set_value(env, list_ptr, pos, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddLong(JNIEnv* env, jclass, jlong list_ptr, jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertLong(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetLong(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                   jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddDouble(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertDouble(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetDouble(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddFloat(JNIEnv* env, jclass, jlong list_ptr, jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertFloat(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                       jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetFloat(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                    jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddBoolean(JNIEnv* env, jclass, jlong list_ptr,
+                                                                      jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertBoolean(JNIEnv* env, jclass, jlong list_ptr,
+                                                                         jlong pos, jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetBoolean(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddBinary(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        add_value(env, list_ptr, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertBinary(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        insert_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetBinary(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        set_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddDate(JNIEnv* env, jclass, jlong list_ptr, jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
     }
     CATCH_STD()
 }
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertDate(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetDate(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                   jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddString(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        add_value(env, list_ptr, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertString(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        insert_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD();
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetString(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        set_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_OsList_nativeGetValue(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        JavaAccessorContext context(env);
+        return any_cast<jobject>(wrapper.collection().get(context, pos));
+    }
+    CATCH_STD()
+
+    return nullptr;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index 567aae92fa..68fe07ac89 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -249,7 +249,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeEnableChangeNo
 #if REALM_ENABLE_SYNC
 JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
     JNIEnv* env, jclass, jlong native_ptr, jstring j_sync_realm_url, jstring j_auth_url, jstring j_user_id,
-    jstring j_reresh_token)
+    jstring j_reresh_token, jbyte j_session_stop_policy)
 {
     TR_ENTER_PTR(native_ptr)
     auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
@@ -320,9 +320,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSy
             std::copy_n(config.encryption_key.begin(), 64, sync_encryption_key->begin());
         }
 
+        SyncSessionStopPolicy session_stop_policy = static_cast<SyncSessionStopPolicy>(j_session_stop_policy);
+
         JStringAccessor realm_url(env, j_sync_realm_url);
         config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
-            user, realm_url, SyncSessionStopPolicy::AfterChangesUploaded, std::move(bind_handler), std::move(error_handler),
+            user, realm_url, session_stop_policy, std::move(bind_handler), std::move(error_handler),
             nullptr, sync_encryption_key});
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index c078d9d33d..ced1e5d440 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -17,8 +17,8 @@
 #include <sstream>
 
 #include "util.hpp"
+#include "io_realm_internal_Property.h"
 #include "io_realm_internal_Table.h"
-#include "tablebase_tpl.hpp"
 
 #include "shared_realm.hpp"
 #include "util/format.hpp"
@@ -173,8 +173,14 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable(J
         ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
         return JNI_FALSE;
     }
-    size_t column_index = S(columnIndex);
-    return to_jbool(table->is_nullable(column_index));
+
+    if (table->get_column_type(S(columnIndex)) != type_Table) {
+        // for other than primitive list (including object, object list).
+        return to_jbool(table->is_nullable(S(columnIndex))); // noexcept
+    }
+    // For primitive list
+    // FIXME: Add test in https://github.com/realm/realm-java/pull/5221 before merging to master
+    return to_jbool(table->get_descriptor()->get_subdescriptor(S(columnIndex))->is_nullable(S(0))); // noexcept
 }
 
 
@@ -513,7 +519,16 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(JNIEnv*
         return 0;
     }
 
-    return static_cast<jint>(TBL(nativeTablePtr)->get_column_type(S(columnIndex))); // noexcept
+    auto column_type = TBL(nativeTablePtr)->get_column_type(S(columnIndex)); // noexcept
+    if (column_type != type_Table) {
+        // For other than primitive list (including object, object list).
+        return static_cast<jint>(column_type);
+    }
+    // For primitive list
+    // FIXME: Add test in https://github.com/realm/realm-java/pull/5221 before merging to master
+    // FIXME: Add method in Object Store to return a PropertyType.
+    return static_cast<jint>(TBL(nativeTablePtr)->get_descriptor()->get_subdescriptor(S(columnIndex))->get_column_type(S(0))
+                             + io_realm_internal_Property_TYPE_ARRAY); // noexcept
 }
 
 
@@ -618,8 +633,13 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(JNI
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary)) {
         return nullptr;
     }
+    try {
+        realm::BinaryData bin = TBL(nativeTablePtr)->get_binary(S(columnIndex), S(rowIndex));
+        return JavaClassGlobalDef::new_byte_array(env, bin);
+    }
+    CATCH_STD()
 
-    return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex); // noexcept
+    return nullptr;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink(JNIEnv* env, jobject, jlong nativeTablePtr,
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index bf3a2a2543..319597fb17 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -15,6 +15,7 @@
  */
 
 #include "io_realm_internal_UncheckedRow.h"
+#include "io_realm_internal_Property.h"
 
 #include "java_accessor.hpp"
 #include "util.hpp"
@@ -71,7 +72,13 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType(J
                                                                                jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return static_cast<jint>(ROW(nativeRowPtr)->get_column_type(S(columnIndex))); // noexcept
+    auto column_type = ROW(nativeRowPtr)->get_column_type(S(columnIndex)); // noexcept
+    if (column_type != type_Table) {
+        return static_cast<jint>(column_type);
+    }
+    // FIXME: Add test in https://github.com/realm/realm-java/pull/5221 before merging to master
+    return static_cast<jint>(ROW(nativeRowPtr)->get_table()->get_descriptor()->get_subdescriptor(S(columnIndex))->get_column_type(S(0))
+                             + io_realm_internal_Property_TYPE_ARRAY); // noexcept
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex(JNIEnv* env, jobject, jlong nativeRowPtr)
@@ -164,22 +171,12 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteAr
         return nullptr;
     }
 
-    BinaryData bin = ROW(nativeRowPtr)->get_binary(S(columnIndex));
-    if (bin.is_null()) {
-        return nullptr;
-    }
-    else if (bin.size() <= MAX_JSIZE) {
-        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult) {
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
-                                    reinterpret_cast<const jbyte*>(bin.data())); // throws
-        }
-        return jresult;
-    }
-    else {
-        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return nullptr;
+    try {
+        BinaryData bin = ROW(nativeRowPtr)->get_binary(S(columnIndex));
+        return JavaClassGlobalDef::new_byte_array(env, bin);
     }
+    CATCH_STD()
+    return nullptr;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink(JNIEnv* env, jobject, jlong nativeRowPtr,
diff --git a/realm/realm-library/src/main/cpp/java_accessor.hpp b/realm/realm-library/src/main/cpp/java_accessor.hpp
index 4ec2e0cbd4..333f77a3f4 100644
--- a/realm/realm-library/src/main/cpp/java_accessor.hpp
+++ b/realm/realm-library/src/main/cpp/java_accessor.hpp
@@ -25,8 +25,11 @@
 #include <realm/binary_data.hpp>
 #include <realm/table.hpp>
 
+#include <object_accessor.hpp>
+#include <util/any.hpp>
 #include <util/format.hpp>
 
+#include "java_class_global_def.hpp"
 #include "java_exception_def.hpp"
 #include "jni_util/java_exception_thrower.hpp"
 
@@ -62,7 +65,8 @@ class JPrimitiveArrayAccessor {
     JPrimitiveArrayAccessor(const JPrimitiveArrayAccessor&) = default;
     JPrimitiveArrayAccessor& operator=(const JPrimitiveArrayAccessor&) = default;
 
-    inline bool is_null() {
+    inline bool is_null()
+    {
         return !m_elements_holder->m_jarray;
     }
 
@@ -148,6 +152,114 @@ class JObjectArrayAccessor {
     jsize m_size;
 };
 
+// An object accessor context which can be used to create and access objects
+// using util::Any as the type-erased value type. In addition, this serves as
+// the reference implementation of an accessor context that must be implemented
+// by each binding.
+class JavaAccessorContext {
+public:
+    JavaAccessorContext(JNIEnv* env)
+        : m_env(env){}
+
+    // Convert from core types to the boxed type
+    util::Any box(BinaryData v) const
+    {
+        return reinterpret_cast<jobject>(JavaClassGlobalDef::new_byte_array(m_env, v));
+    }
+    util::Any box(List /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(Object /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(Results /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(StringData v) const
+    {
+        return reinterpret_cast<jobject>(to_jstring(m_env, v));
+    }
+    util::Any box(Timestamp v) const
+    {
+        return JavaClassGlobalDef::new_date(m_env, v);
+    }
+    util::Any box(bool v) const
+    {
+        return _impl::JavaClassGlobalDef::new_boolean(m_env, v);
+    }
+    util::Any box(double v) const
+    {
+        return _impl::JavaClassGlobalDef::new_double(m_env, v);
+    }
+    util::Any box(float v) const
+    {
+        return _impl::JavaClassGlobalDef::new_float(m_env, v);
+    }
+    util::Any box(int64_t v) const
+    {
+        return _impl::JavaClassGlobalDef::new_long(m_env, v);
+    }
+    util::Any box(util::Optional<bool> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_boolean(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<double> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_double(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<float> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_float(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<int64_t> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_long(m_env, v.value()) : nullptr;
+    }
+    util::Any box(RowExpr) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+
+    // Any properties are only supported by the Cocoa binding to enable reading
+    // old Realm files that may have used them. Other bindings can safely not
+    // implement this.
+    util::Any box(Mixed) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+
+    // Convert from the boxed type to core types. This needs to be implemented
+    // for all of the types which `box()` can take, plus `RowExpr` and optional
+    // versions of the numeric types, minus `List` and `Results`.
+    //
+    // `create` and `update` are only applicable to `unbox<RowExpr>`. If
+    // `create` is false then when given something which is not a managed Realm
+    // object `unbox()` should simply return a detached row expr, while if it's
+    // true then `unbox()` should create a new object in the context's Realm
+    // using the provided value. If `update` is true then upsert semantics
+    // should be used for this.
+    template <typename T>
+    T unbox(util::Any& v, bool /*create*/ = false, bool /*update*/ = false) const
+    {
+        return any_cast<T>(v);
+    }
+
+private:
+    JNIEnv* m_env;
+
+    inline void check_value_not_null(util::Any& v, const char* expected_type) const
+    {
+        if (!v.has_value()) {
+            THROW_JAVA_EXCEPTION(
+                m_env, JavaExceptionDef::IllegalArgument,
+                util::format("This field is required. A non-null '%1' type value is expected.", expected_type));
+        }
+    }
+};
+
 // Accessor for jbyteArray
 template <>
 inline JPrimitiveArrayAccessor<jbyteArray, jbyte>::ElementsHolder::ElementsHolder(JNIEnv* env, jbyteArray jarray)
@@ -196,7 +308,8 @@ inline std::vector<char> JPrimitiveArrayAccessor<jbyteArray, jbyte>::transform<s
 
 // Accessor for jbooleanArray
 template <>
-inline JPrimitiveArrayAccessor<jbooleanArray, jboolean>::ElementsHolder::ElementsHolder(JNIEnv* env, jbooleanArray jarray)
+inline JPrimitiveArrayAccessor<jbooleanArray, jboolean>::ElementsHolder::ElementsHolder(JNIEnv* env,
+                                                                                        jbooleanArray jarray)
     : m_env(env)
     , m_jarray(jarray)
     , m_data_ptr(jarray ? env->GetBooleanArrayElements(jarray, nullptr) : nullptr)
@@ -228,6 +341,95 @@ inline JPrimitiveArrayAccessor<jlongArray, jlong>::ElementsHolder::~ElementsHold
     }
 }
 
+template <>
+inline bool JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Boolean");
+    return any_cast<jboolean>(v) == JNI_TRUE;
+}
+
+template <>
+inline int64_t JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Long");
+    return static_cast<int64_t>(any_cast<jlong>(v));
+}
+
+template <>
+inline double JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Double");
+    return static_cast<double>(any_cast<jdouble>(v));
+}
+
+template <>
+inline float JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Float");
+    return static_cast<float>(any_cast<jfloat>(v));
+}
+
+template <>
+inline StringData JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    if (!v.has_value()) {
+        return StringData();
+    }
+    auto& value = any_cast<JStringAccessor&>(v);
+    return value;
+}
+
+template <>
+inline BinaryData JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    if (!v.has_value())
+        return BinaryData();
+    auto& value = any_cast<JByteArrayAccessor&>(v);
+    return value.transform<BinaryData>();
+}
+
+template <>
+inline Timestamp JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? from_milliseconds(any_cast<jlong>(v)) : Timestamp();
+}
+
+template <>
+inline RowExpr JavaAccessorContext::unbox(util::Any&, bool, bool) const
+{
+    REALM_TERMINATE("not supported");
+}
+
+template <>
+inline util::Optional<bool> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jboolean>(v) == JNI_TRUE) : util::none;
+}
+
+template <>
+inline util::Optional<int64_t> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(static_cast<int64_t>(any_cast<jlong>(v))) : util::none;
+}
+
+template <>
+inline util::Optional<double> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jdouble>(v)) : util::none;
+}
+
+template <>
+inline util::Optional<float> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jfloat>(v)) : util::none;
+}
+
+template <>
+inline Mixed JavaAccessorContext::unbox(util::Any&, bool, bool) const
+{
+    REALM_TERMINATE("not supported");
+}
+
 } // namespace realm
 } // namespace _impl
 
diff --git a/realm/realm-library/src/main/cpp/java_class_global_def.cpp b/realm/realm-library/src/main/cpp/java_class_global_def.cpp
new file mode 100644
index 0000000000..d1ecd443ca
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_class_global_def.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "realm/array_blob.hpp"
+
+#include "java_class_global_def.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+jbyteArray JavaClassGlobalDef::new_byte_array(JNIEnv* env, const BinaryData& binary_data)
+{
+    static_assert(MAX_JSIZE >= ArrayBlob::max_binary_size, "ArrayBlob's max size is too big.");
+
+    if (binary_data.is_null()) {
+        return nullptr;
+    }
+
+    auto size = static_cast<jsize>(binary_data.size());
+    jbyteArray ret = env->NewByteArray(size);
+    if (!ret) {
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::OutOfMemory,
+                             util::format("'NewByteArray' failed with size %1.", size));
+    }
+
+    env->SetByteArrayRegion(ret, 0, size, reinterpret_cast<const jbyte*>(binary_data.data()));
+    return ret;
+}
diff --git a/realm/realm-library/src/main/cpp/java_class_global_def.hpp b/realm/realm-library/src/main/cpp/java_class_global_def.hpp
index d47e5dc5d4..268082de8e 100644
--- a/realm/realm-library/src/main/cpp/java_class_global_def.hpp
+++ b/realm/realm-library/src/main/cpp/java_class_global_def.hpp
@@ -26,6 +26,9 @@
 #include <realm/util/assert.hpp>
 
 namespace realm {
+
+class BinaryData;
+
 namespace _impl {
 
 // Manage a global static jclass pool which will be initialized when JNI_OnLoad() called.
@@ -46,6 +49,7 @@ class JavaClassGlobalDef {
         , m_java_lang_double(env, "java/lang/Double", false)
         , m_java_util_date(env, "java/util/Date", false)
         , m_java_lang_string(env, "java/lang/String", false)
+        , m_java_lang_boolean(env, "java/lang/Boolean", false)
         , m_shared_realm_schema_change_callback(env, "io/realm/internal/SharedRealm$SchemaChangedCallback", false)
         , m_realm_notifier(env, "io/realm/internal/RealmNotifier", false)
     {
@@ -56,6 +60,7 @@ class JavaClassGlobalDef {
     jni_util::JavaClass m_java_lang_double;
     jni_util::JavaClass m_java_util_date;
     jni_util::JavaClass m_java_lang_string;
+    jni_util::JavaClass m_java_lang_boolean;
 
     jni_util::JavaClass m_shared_realm_schema_change_callback;
     jni_util::JavaClass m_realm_notifier;
@@ -113,9 +118,24 @@ class JavaClassGlobalDef {
         return instance()->m_java_lang_double;
     }
 
+    // java.lang.Boolean
+    inline static jobject new_boolean(JNIEnv* env, bool value)
+    {
+        static jni_util::JavaMethod init(env, instance()->m_java_lang_boolean, "<init>", "(Z)V");
+        return env->NewObject(instance()->m_java_lang_boolean, init, value ? JNI_TRUE : JNI_FALSE);
+    }
+    inline static const jni_util::JavaClass& java_lang_boolean()
+    {
+        return instance()->m_java_lang_boolean;
+    }
+
     // java.util.Date
+    // return nullptr if ts is null
     inline static jobject new_date(JNIEnv* env, const realm::Timestamp& ts)
     {
+        if (ts.is_null()) {
+            return nullptr;
+        }
         static jni_util::JavaMethod init(env, instance()->m_java_util_date, "<init>", "(J)V");
         return env->NewObject(instance()->m_java_util_date, init, to_milliseconds(ts));
     }
@@ -130,6 +150,10 @@ class JavaClassGlobalDef {
         return instance()->m_java_lang_string;
     }
 
+    // byte[]
+    // return nullptr if binary_data is null
+    static jbyteArray new_byte_array(JNIEnv* env, const BinaryData& binary_data);
+
     // io.realm.internal.SharedRealm.SchemaChangedCallback
     inline static const jni_util::JavaClass& shared_realm_schema_change_callback()
     {
diff --git a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
new file mode 100644
index 0000000000..ed53c62c9f
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
+#define REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
+
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/log.hpp"
+
+namespace realm {
+namespace _impl {
+
+// Wrapper of Object Store List & Results.
+// We need to control the life cycle of Results/List, weak ref of Java Collection object and the NotificationToken.
+// Wrap all three together, so when the Java Collection object gets GCed, all three of them will be invalidated.
+template <typename T>
+class ObservableCollectionWrapper {
+public:
+    ObservableCollectionWrapper(T& collection)
+        : m_collection_weak_ref()
+        , m_notification_token()
+        , m_collection(std::move(collection))
+    {
+    }
+
+    ~ObservableCollectionWrapper() = default;
+
+    ObservableCollectionWrapper(ObservableCollectionWrapper&&) = delete;
+    ObservableCollectionWrapper& operator=(ObservableCollectionWrapper&&) = delete;
+    ObservableCollectionWrapper(ObservableCollectionWrapper const&) = delete;
+    ObservableCollectionWrapper& operator=(ObservableCollectionWrapper const&) = delete;
+
+    T& collection()
+    {
+        return m_collection;
+    };
+    void start_listening(JNIEnv* env, jobject j_collection_object);
+    void stop_listening();
+
+private:
+    jni_util::JavaGlobalWeakRef m_collection_weak_ref;
+    NotificationToken m_notification_token;
+    T m_collection;
+};
+
+template <typename T>
+void ObservableCollectionWrapper<T>::start_listening(JNIEnv* env, jobject j_collection_object)
+{
+    static jni_util::JavaClass os_results_class(env, "io/realm/internal/ObservableCollection");
+    static jni_util::JavaMethod notify_change_listeners(env, os_results_class, "notifyChangeListeners", "(J)V");
+
+    if (!m_collection_weak_ref) {
+        m_collection_weak_ref = jni_util::JavaGlobalWeakRef(env, j_collection_object);
+    }
+
+    auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
+        // OS will call all notifiers' callback in one run, so check the Java exception first!!
+        if (env->ExceptionCheck())
+            return;
+
+        if (err) {
+            try {
+                std::rethrow_exception(err);
+            }
+            catch (const std::exception& e) {
+                realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
+                return;
+            }
+        }
+
+        m_collection_weak_ref.call_with_local_ref(env, [&](JNIEnv* local_env, jobject collection_obj) {
+            local_env->CallVoidMethod(
+                collection_obj, notify_change_listeners,
+                reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
+        });
+    };
+
+    m_notification_token = m_collection.add_notification_callback(cb);
+}
+
+template <typename T>
+void ObservableCollectionWrapper<T>::stop_listening()
+{
+    m_notification_token = {};
+}
+
+} // namespace realm
+} // namespace _impl
+
+#endif // REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
diff --git a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
deleted file mode 100644
index 54db725c51..0000000000
--- a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_JNI_TABLEBASE_TPL_HPP
-#define REALM_JNI_TABLEBASE_TPL_HPP
-
-#include <realm.hpp>
-
-template <class T>
-jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex)) {
-        return nullptr;
-    }
-
-    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary(S(columnIndex), S(rowIndex));
-    if (bin.is_null()) {
-        return nullptr;
-    }
-    if (bin.size() <= MAX_JSIZE) {
-        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult) {
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
-                                    reinterpret_cast<const jbyte *>(bin.data())); // throws
-        }
-        return jresult;
-    }
-    else {
-        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return nullptr;
-    }
-}
-
-#endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 72fd8b3ea5..f21d1bfc09 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -110,7 +110,15 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ThrowException(env, IllegalState, ss.str());
     }
     catch (realm::LogicError e) {
-        ThrowException(env, IllegalState, e.what());
+        ExceptionKind kind;
+        if (e.kind() == LogicError::string_too_big || e.kind() == LogicError::binary_too_big ||
+            e.kind() == LogicError::column_not_nullable) {
+            kind = IllegalArgument;
+        }
+        else {
+            kind = IllegalState;
+        }
+        ThrowException(env, kind, e.what());
     }
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
@@ -255,23 +263,6 @@ void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx)
     ThrowException(env, IllegalArgument, ss.str());
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
-{
-    const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
-    if (!data) {
-        ThrowException(env, IllegalArgument, "ByteBuffer is invalid");
-        return false;
-    }
-    jlong size = env->GetDirectBufferCapacity(jByteBuffer);
-    if (size < 0) {
-        ThrowException(env, IllegalArgument, "Can't get BufferCapacity.");
-        return false;
-    }
-    bin = BinaryData(data, S(size));
-    return true;
-}
-
-
 //*********************************************************************
 // String handling
 //*********************************************************************
@@ -473,7 +464,7 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         buf_size = Xcode::find_utf8_buf_size(begin, end, error_code);
     }
     char* tmp_char_array = new char[buf_size]; // throws
-    m_data.reset(tmp_char_array);
+    m_data.reset(tmp_char_array, std::default_delete<char[]>());
     {
         const jchar* in_begin = chars.data();
         const jchar* in_end = in_begin + chars.size();
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index c5c536f5b3..21bb35c354 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -433,9 +433,6 @@ inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex
            TypeValid(env, pTable, columnIndex, expectColType);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
-
-
 // Utility function for appending StringData, which is returned
 // by a lot of core functions, and might potentially be NULL.
 std::string concat_stringdata(const char* message, realm::StringData data);
@@ -488,7 +485,7 @@ class JStringAccessor {
 private:
     JNIEnv* m_env;
     bool m_is_null;
-    std::unique_ptr<char[]> m_data;
+    std::shared_ptr<char> m_data;
     std::size_t m_size;
 };
 
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index f924430967..012085f1f8 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -113,8 +113,6 @@ public DynamicRealmObject(RealmModel obj) {
                 return (E) getObject(fieldName);
             case LIST:
                 return (E) getList(fieldName);
-            case UNSUPPORTED_TABLE:
-            case UNSUPPORTED_MIXED:
             default:
                 throw new IllegalStateException("Field type not supported: " + type);
         }
@@ -337,18 +335,18 @@ public DynamicRealmObject getObject(String fieldName) {
     }
 
     /**
-     * Returns the {@link RealmList} of objects being linked to from this field.
+     * Returns the {@link RealmList} of {@link DynamicRealmObject}s being linked from the given field.
      *
      * @param fieldName the name of the field.
      * @return the {@link RealmList} data for this field.
-     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of objects.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         proxyState.getRealm$realm().checkIfValid();
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
-            OsList osList = proxyState.getRow$realm().getLinkList(columnIndex);
+            OsList osList = proxyState.getRow$realm().getList(columnIndex);
             //noinspection ConstantConditions
             @Nonnull
             String className = osList.getTargetTable().getClassName();
@@ -359,6 +357,18 @@ public DynamicRealmObject getObject(String fieldName) {
         }
     }
 
+    /**
+     * Returns the {@link RealmList} of values being linked from the given field.
+     *
+     * @param fieldName the name of the field.
+     * @return the {@link RealmList} data for this field.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of values.
+     */
+    public <T> RealmList<T> getValueList(String fieldName, Class<T> valueClass) {
+        // TODO implement this
+        return null;
+    }
+
     /**
      * Checks if the value of a given field is {@code null}.
      *
@@ -383,8 +393,6 @@ public boolean isNull(String fieldName) {
             case DATE:
                 return proxyState.getRow$realm().isNull(columnIndex);
             case LIST:
-            case UNSUPPORTED_TABLE:
-            case UNSUPPORTED_MIXED:
             default:
                 return false;
         }
@@ -501,9 +509,29 @@ private void setValue(String fieldName, Object value) {
         } else if (valueClass == DynamicRealmObject.class) {
             setObject(fieldName, (DynamicRealmObject) value);
         } else if (valueClass == RealmList.class) {
-            @SuppressWarnings("unchecked")
-            RealmList<DynamicRealmObject> list = (RealmList<DynamicRealmObject>) value;
-            setList(fieldName, list);
+            RealmList<?> list = (RealmList<?>) value;
+            if (list.className == null && list.clazz == null) {
+                // unmanaged RealmList
+                long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+                final RealmFieldType columnType = proxyState.getRow$realm().getColumnType(columnIndex);
+                if (columnType == RealmFieldType.LIST) {
+                    //noinspection unchecked
+                    for (Object element : list) {
+                        if (!(element instanceof RealmModel)) {
+                            throw new IllegalArgumentException("All elements in the list must be an instance of RealmModel.");
+                        }
+                    }
+                    //noinspection unchecked
+                    setList(fieldName, (RealmList<DynamicRealmObject>) list);
+                } else {
+                    setValueList(fieldName, list);
+                }
+            } else if (list.className != null || RealmModel.class.isAssignableFrom(list.clazz)) {
+                //noinspection unchecked
+                setList(fieldName, (RealmList<DynamicRealmObject>) list);
+            } else {
+                setValueList(fieldName, list);
+            }
         } else {
             throw new IllegalArgumentException("Value is of an type not supported: " + value.getClass());
         }
@@ -713,7 +741,7 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
         }
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        OsList osList = proxyState.getRow$realm().getLinkList(columnIndex);
+        OsList osList = proxyState.getRow$realm().getList(columnIndex);
         Table linkTargetTable = osList.getTargetTable();
         //noinspection ConstantConditions
         @Nonnull
@@ -760,6 +788,19 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
         }
     }
 
+    /**
+     * Sets the reference to a {@link RealmList} on the given field.
+     *
+     * @param fieldName field name.
+     * @param list list of references.
+     * @throws IllegalArgumentException if field name doesn't exist, it is not a list field, the type
+     * of the object represented by the DynamicRealmObject doesn't match or any element in the list belongs to a
+     * different Realm.
+     */
+    public void setValueList(String fieldName, RealmList<?> list) {
+        // TODO implement this
+    }
+
     /**
      * Sets the value to {@code null} for the given field.
      *
@@ -923,10 +964,8 @@ public String toString() {
                     break;
                 case LIST:
                     String targetClassName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getClassName();
-                    sb.append(String.format(Locale.US, "RealmList<%s>[%s]", targetClassName, proxyState.getRow$realm().getLinkList(columnIndex).size()));
+                    sb.append(String.format(Locale.US, "RealmList<%s>[%s]", targetClassName, proxyState.getRow$realm().getList(columnIndex).size()));
                     break;
-                case UNSUPPORTED_TABLE:
-                case UNSUPPORTED_MIXED:
                 default:
                     sb.append("?");
                     break;
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 4034f5c062..0024658bd9 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -100,7 +100,7 @@
  * As you can see, after deletion, the size and elements order of snapshot stay the same as before. But the element at
  * the position becomes invalid.
  */
-public interface OrderedRealmCollection<E extends RealmModel> extends List<E>, RealmCollection<E> {
+public interface OrderedRealmCollection<E> extends List<E>, RealmCollection<E> {
 
     /**
      * Gets the first object from the collection.
@@ -108,6 +108,7 @@
      * @return the first object.
      * @throws IndexOutOfBoundsException if the collection is empty.
      */
+    @Nullable
     E first();
 
     /**
@@ -124,6 +125,7 @@
      * @return the last object.
      * @throws IndexOutOfBoundsException if the collection is empty.
      */
+    @Nullable
     E last();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
index b9a5261c85..24216e776d 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import javax.annotation.Nullable;
+
 /**
  * {@link OrderedRealmCollectionChangeListener} can be registered with a {@link RealmResults} to receive a notification
  * with a {@link OrderedCollectionChangeSet} to describe the details of what have been changed in the collection from
@@ -36,5 +38,5 @@
      * @param changeSet object with information about which rows in the collection were added, removed or modified.
      * {@code null} is returned the first time an async query is completed.
      */
-    void onChange(T t, OrderedCollectionChangeSet changeSet);
+    void onChange(T t, @Nullable OrderedCollectionChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
index 2f6d096990..39163349d9 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -9,6 +9,7 @@
 
 import javax.annotation.Nullable;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Collection;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
@@ -20,7 +21,7 @@
 /**
  * General implementation for {@link OrderedRealmCollection} which is based on the {@code Collection}.
  */
-abstract class OrderedRealmCollectionImpl<E extends RealmModel>
+abstract class OrderedRealmCollectionImpl<E>
         extends AbstractList<E> implements OrderedRealmCollection<E> {
     private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by 'RealmResults' or" +
             " 'OrderedRealmCollectionSnapshot'.";
@@ -28,6 +29,9 @@
     final BaseRealm realm;
     @Nullable final Class<E> classSpec;   // Return type
     @Nullable final String className;     // Class name used by DynamicRealmObjects
+    // FIXME implement this
+    @SuppressFBWarnings("SS_SHOULD_BE_STATIC")
+    final boolean forValues = false;
 
     final Collection collection;
 
@@ -108,15 +112,23 @@ public boolean contains(@Nullable Object object) {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
+    @Nullable
     public E get(int location) {
         realm.checkIfValid();
-        return realm.get(classSpec, className, collection.getUncheckedRow(location));
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
+
+        //noinspection unchecked
+        return (E) realm.get((Class<? extends RealmModel>) classSpec, className, collection.getUncheckedRow(location));
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E first() {
         return firstImpl(true, null);
     }
@@ -134,8 +146,14 @@ public E first(@Nullable E defaultValue) {
     private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
         UncheckedRow row = collection.firstUncheckedRow();
 
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
+
         if (row != null) {
-            return realm.get(classSpec, className, row);
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmModel>) classSpec, className, row);
         } else {
             if (shouldThrow) {
                 throw new IndexOutOfBoundsException("No results were found.");
@@ -149,6 +167,7 @@ private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E last() {
         return lastImpl(true, null);
     }
@@ -167,8 +186,14 @@ public E last(@Nullable E defaultValue) {
     private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
         UncheckedRow row = collection.lastUncheckedRow();
 
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
+
         if (row != null) {
-            return realm.get(classSpec, className, row);
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmModel>) classSpec, className, row);
         } else {
             if (shouldThrow) {
                 throw new IndexOutOfBoundsException("No results were found.");
@@ -535,7 +560,12 @@ public boolean addAll(@SuppressWarnings("NullableProblems") java.util.Collection
 
         @Override
         protected E convertRowToObject(UncheckedRow row) {
-            return realm.get(classSpec, className, row);
+            if (forValues) {
+                // TODO implement this
+                return null;
+            }
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmObject>) classSpec, className, row);
         }
     }
 
@@ -558,7 +588,12 @@ protected E convertRowToObject(UncheckedRow row) {
 
         @Override
         protected E convertRowToObject(UncheckedRow row) {
-            return realm.get(classSpec, className, row);
+            if (forValues) {
+                // TODO implement this
+                return null;
+            }
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmObject>) classSpec, className, row);
         }
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
index 6a2989647d..5e4ce01545 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
@@ -48,7 +48,7 @@
  * }
  * </pre>
  */
-public class OrderedRealmCollectionSnapshot<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+public class OrderedRealmCollectionSnapshot<E> extends OrderedRealmCollectionImpl<E> {
 
     private int size = -1;
 
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index f95bb86647..6644275d38 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -432,6 +432,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
      * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects to create.
      * @param json an array where each JSONObject must map to the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -461,6 +464,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json array with object data.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -490,6 +496,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
      * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects to create.
      * @param json the JSON array as a String where each object can map to the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -519,6 +528,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
      * the default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with an array of JSON objects.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -552,6 +564,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects created.
      * @param inputStream the JSON array as a InputStream. All objects in the array must be of the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -588,6 +603,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the InputStream with a list of object data in JSON format.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -628,6 +646,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
      * object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
      * @return created object or {@code null} if no JSON data was provided.
@@ -657,6 +678,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
      * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json {@link org.json.JSONObject} with object data.
      * @return created or updated {@link io.realm.RealmObject}.
@@ -685,6 +709,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
      * object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
      * @return created object or {@code null} if JSON string was empty or null.
@@ -716,6 +743,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
@@ -750,6 +780,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
      * @return created object or {@code null} if JSON string was empty or null.
@@ -805,6 +838,9 @@ static Realm createInstance(SharedRealm sharedRealm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the {@link InputStream} with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 55e6bc687e..7516d2b3bc 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -35,7 +35,7 @@
  *
  * @param <E> type of {@link RealmObject} stored in the collection.
  */
-public interface RealmCollection<E extends RealmModel> extends Collection<E>, ManagableObject {
+public interface RealmCollection<E> extends Collection<E>, ManagableObject {
 
     /**
      * Returns a {@link RealmQuery}, which can be used to query for specific objects from this collection.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index 38b923d97e..2514255c69 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -18,10 +18,45 @@
 
 import java.nio.ByteBuffer;
 
-import javax.annotation.Nullable;
-
 import io.realm.internal.Keep;
+import io.realm.internal.Property;
+
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_BINARY;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_BOOLEAN;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_DATE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_DOUBLE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_FLOAT;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_INTEGER;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_LINKING_OBJECTS;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_LIST;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_OBJECT;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_STRING;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_DATE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_MIXED;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_TABLE;
+import static io.realm.RealmFieldTypeConstants.LIST_OFFSET;
+import static io.realm.RealmFieldTypeConstants.MAX_CORE_TYPE_VALUE;
+
 
+interface RealmFieldTypeConstants {
+    int LIST_OFFSET = Property.TYPE_ARRAY;
+
+    int CORE_TYPE_VALUE_INTEGER = 0;
+    int CORE_TYPE_VALUE_BOOLEAN = 1;
+    int CORE_TYPE_VALUE_STRING = 2;
+    int CORE_TYPE_VALUE_BINARY = 4;
+    int CORE_TYPE_VALUE_UNSUPPORTED_TABLE = 5;
+    int CORE_TYPE_VALUE_UNSUPPORTED_MIXED = 6;
+    int CORE_TYPE_VALUE_UNSUPPORTED_DATE = 7;
+    int CORE_TYPE_VALUE_DATE = 8;
+    int CORE_TYPE_VALUE_FLOAT = 9;
+    int CORE_TYPE_VALUE_DOUBLE = 10;
+    int CORE_TYPE_VALUE_OBJECT = 12;
+    int CORE_TYPE_VALUE_LIST = 13;
+    int CORE_TYPE_VALUE_LINKING_OBJECTS = 14;
+
+    int MAX_CORE_TYPE_VALUE = CORE_TYPE_VALUE_LINKING_OBJECTS;
+}
 
 /**
  * List of the types used by Realm's underlying storage engine.
@@ -33,27 +68,38 @@
 @Keep
 public enum RealmFieldType {
     // Makes sure numbers match with <realm/column_type.hpp>.
-    INTEGER(0),
-    BOOLEAN(1),
-    STRING(2),
-    BINARY(4),
-    UNSUPPORTED_TABLE(5),
-    UNSUPPORTED_MIXED(6),
-    UNSUPPORTED_DATE(7),
-    DATE(8),
-    FLOAT(9),
-    DOUBLE(10),
-    OBJECT(12),
-    LIST(13),
-    LINKING_OBJECTS(14);
+    INTEGER(CORE_TYPE_VALUE_INTEGER),
+    BOOLEAN(CORE_TYPE_VALUE_BOOLEAN),
+    STRING(CORE_TYPE_VALUE_STRING),
+    BINARY(CORE_TYPE_VALUE_BINARY),
+    DATE(CORE_TYPE_VALUE_DATE),
+    FLOAT(CORE_TYPE_VALUE_FLOAT),
+    DOUBLE(CORE_TYPE_VALUE_DOUBLE),
+    OBJECT(CORE_TYPE_VALUE_OBJECT),
+
+    LIST(CORE_TYPE_VALUE_LIST),
+    LINKING_OBJECTS(CORE_TYPE_VALUE_LINKING_OBJECTS),
+
+    INTEGER_LIST(CORE_TYPE_VALUE_INTEGER + LIST_OFFSET),
+    BOOLEAN_LIST(CORE_TYPE_VALUE_BOOLEAN + LIST_OFFSET),
+    STRING_LIST(CORE_TYPE_VALUE_STRING + LIST_OFFSET),
+    BINARY_LIST(CORE_TYPE_VALUE_BINARY + LIST_OFFSET),
+    DATE_LIST(CORE_TYPE_VALUE_DATE + LIST_OFFSET),
+    FLOAT_LIST(CORE_TYPE_VALUE_FLOAT + LIST_OFFSET),
+    DOUBLE_LIST(CORE_TYPE_VALUE_DOUBLE + LIST_OFFSET);
 
     // Primitive array for fast mapping between between native values and their Realm type.
-    private static final RealmFieldType[] typeList = new RealmFieldType[15];
+    private static final RealmFieldType[] basicTypes = new RealmFieldType[MAX_CORE_TYPE_VALUE + 1];
+    private static final RealmFieldType[] listTypes = new RealmFieldType[MAX_CORE_TYPE_VALUE + 1];
 
     static {
-        RealmFieldType[] columnTypes = values();
-        for (int i = 0; i < columnTypes.length; i++) {
-            typeList[columnTypes[i].nativeValue] = columnTypes[i];
+        for (RealmFieldType columnType : values()) {
+            final int nativeValue = columnType.nativeValue;
+            if (nativeValue < LIST_OFFSET) {
+                basicTypes[nativeValue] = columnType;
+            } else {
+                listTypes[nativeValue - LIST_OFFSET] = columnType;
+            }
         }
     }
 
@@ -80,30 +126,39 @@ public int getNativeValue() {
      */
     public boolean isValid(Object obj) {
         switch (nativeValue) {
-            case 0:
+            case CORE_TYPE_VALUE_INTEGER:
                 return (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte);
-            case 1:
+            case CORE_TYPE_VALUE_BOOLEAN:
                 return (obj instanceof Boolean);
-            case 2:
+            case CORE_TYPE_VALUE_STRING:
                 return (obj instanceof String);
-            case 4:
+            case CORE_TYPE_VALUE_BINARY:
                 return (obj instanceof byte[] || obj instanceof ByteBuffer);
-            case 5:
-                //noinspection ConstantConditions
-                return (obj == null || obj instanceof Object[][]);
-            case 7:
-                return (obj instanceof java.util.Date); // The unused DateTime.
-            case 8:
+            case CORE_TYPE_VALUE_DATE:
                 return (obj instanceof java.util.Date);
-            case 9:
+            case CORE_TYPE_VALUE_FLOAT:
                 return (obj instanceof Float);
-            case 10:
+            case CORE_TYPE_VALUE_DOUBLE:
                 return (obj instanceof Double);
-            case 12:
+            case CORE_TYPE_VALUE_OBJECT:
                 return false;
-            case 13:
+            case CORE_TYPE_VALUE_LIST:
                 return false;
-            case 14:
+            case CORE_TYPE_VALUE_LINKING_OBJECTS:
+                return false;
+            case CORE_TYPE_VALUE_INTEGER + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_BOOLEAN + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_STRING + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_BINARY + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_DATE + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_FLOAT + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_DOUBLE + LIST_OFFSET:
                 return false;
             default:
                 throw new RuntimeException("Unsupported Realm type:  " + this);
@@ -118,12 +173,21 @@ public boolean isValid(Object obj) {
      * @throws IllegalArgumentException if value isn't valid.
      */
     public static RealmFieldType fromNativeValue(int value) {
-        if (0 <= value && value < typeList.length) {
-            RealmFieldType e = typeList[value];
+        if (0 <= value && value < basicTypes.length) {
+            RealmFieldType e = basicTypes[value];
             if (e != null) {
                 return e;
             }
         }
+        if (LIST_OFFSET <= value) {
+            final int elementValue = value - LIST_OFFSET;
+            if (elementValue < listTypes.length) {
+                RealmFieldType e = listTypes[elementValue];
+                if (e != null) {
+                    return e;
+                }
+            }
+        }
         throw new IllegalArgumentException("Invalid native Realm type: " + value);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index 78499e64b5..7bcbe78c35 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -28,17 +28,18 @@
 import java.util.Locale;
 import java.util.NoSuchElementException;
 
-import io.reactivex.Flowable;
-import io.reactivex.Observable;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.OsList;
 import io.realm.internal.OsObjectStore;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.rx.CollectionChange;
 
+
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
  * RealmList has two modes: A managed and unmanaged mode. In managed mode all objects are persisted inside a Realm, in
@@ -57,20 +58,23 @@
  * @param <E> the class of objects in list.
  */
 
-public class RealmList<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public class RealmList<E> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
-    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
-    private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
-    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction";
+    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode.";
+    static final String ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE = "This feature is available only when the element type is implementing RealmModel.";
+    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction.";
 
-    private final io.realm.internal.Collection collection;
     @Nullable
     protected Class<E> clazz;
     @Nullable
     protected String className;
-    final OsList osList;
+
+    // Always null if RealmList is unmanaged, always non-null if managed.
+    private final ManagedListOperator<E> osListOperator;
     final protected BaseRealm realm;
     private List<E> unmanagedList;
+    // Used for listeners on RealmList<RealmModel>
+    private io.realm.internal.Collection osResults;
 
     /**
      * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
@@ -80,9 +84,8 @@
      * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
-        collection = null;
-        osList = null;
         realm = null;
+        osListOperator = null;
         unmanagedList = new ArrayList<>();
     }
 
@@ -95,14 +98,14 @@ public RealmList() {
      *
      * @param objects initial objects in the list.
      */
+    @SafeVarargs
     public RealmList(E... objects) {
         //noinspection ConstantConditions
         if (objects == null) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
-        collection = null;
-        osList = null;
         realm = null;
+        osListOperator = null;
         unmanagedList = new ArrayList<>(objects.length);
         Collections.addAll(unmanagedList, objects);
     }
@@ -115,17 +118,19 @@ public RealmList(E... objects) {
      * @param realm reference to Realm containing the data.
      */
     RealmList(Class<E> clazz, OsList osList, BaseRealm realm) {
-        this.collection = new io.realm.internal.Collection(realm.sharedRealm, osList, null);
         this.clazz = clazz;
-        this.osList = osList;
+        osListOperator = getOperator(realm, osList, clazz, null);
         this.realm = realm;
     }
 
     RealmList(String className, OsList osList, BaseRealm realm) {
-        this.collection = new io.realm.internal.Collection(realm.sharedRealm, osList, null);
-        this.osList = osList;
         this.realm = realm;
         this.className = className;
+        osListOperator = getOperator(realm, osList, null, className);
+    }
+
+    OsList getOsList() {
+        return osListOperator.getOsList();
     }
 
     /**
@@ -152,7 +157,7 @@ public boolean isManaged() {
     }
 
     private boolean isAttached() {
-        return osList != null && osList.isValid();
+        return osListOperator != null && osListOperator.isValid();
     }
 
     /**
@@ -169,22 +174,18 @@ private boolean isAttached() {
      * </ol>
      *
      * @param location the index at which to insert.
-     * @param object the object to add.
+     * @param element the element to add.
      * @throws IllegalStateException if Realm instance has been closed or container object has been removed.
      * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
      */
     @Override
-    public void add(int location, E object) {
-        checkValidObject(object);
+    public void add(int location, @Nullable E element) {
+        //noinspection ConstantConditions
         if (isManaged()) {
             checkValidRealm();
-            if (location < 0 || location > size()) {
-                throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size());
-            }
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            osList.insertRow(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
+            osListOperator.insert(location, element);
         } else {
-            unmanagedList.add(location, object);
+            unmanagedList.add(location, element);
         }
         modCount++;
     }
@@ -205,12 +206,10 @@ public void add(int location, E object) {
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      */
     @Override
-    public boolean add(E object) {
-        checkValidObject(object);
+    public boolean add(@Nullable E object) {
         if (isManaged()) {
             checkValidRealm();
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            osList.addRow(proxy.realmGet$proxyState().getRow$realm().getIndex());
+            osListOperator.append(object);
         } else {
             unmanagedList.add(object);
         }
@@ -236,70 +235,17 @@ public boolean add(E object) {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
-    public E set(int location, E object) {
-        checkValidObject(object);
+    public E set(int location, @Nullable E object) {
         E oldObject;
         if (isManaged()) {
             checkValidRealm();
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            oldObject = get(location);
-            osList.setRow(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
-            return oldObject;
+            oldObject = osListOperator.set(location, object);
         } else {
             oldObject = unmanagedList.set(location, object);
         }
         return oldObject;
     }
 
-    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
-    private E copyToRealmIfNeeded(E object) {
-        if (object instanceof RealmObjectProxy) {
-            RealmObjectProxy proxy = (RealmObjectProxy) object;
-
-            if (proxy instanceof DynamicRealmObject) {
-                //noinspection ConstantConditions
-                @Nonnull
-                String listClassName = className;
-                if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
-                    String objectClassName = ((DynamicRealmObject) object).getType();
-                    if (listClassName.equals(objectClassName)) {
-                        // Same Realm instance and same target table
-                        return object;
-                    } else {
-                        // Different target table
-                        throw new IllegalArgumentException(String.format(Locale.US,
-                                "The object has a different type from list's." +
-                                " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
-                    }
-                } else if (realm.threadId == proxy.realmGet$proxyState().getRealm$realm().threadId) {
-                    // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
-                    // you have to run a full schema validation for each object.
-                    // And copying from another Realm instance pointed to the same Realm file is not supported as well.
-                    throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
-                } else {
-                    throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
-                }
-            } else {
-                // Object is already in this realm
-                if (proxy.realmGet$proxyState().getRow$realm() != null && proxy.realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    if (realm != proxy.realmGet$proxyState().getRealm$realm()) {
-                        throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
-                    }
-                    return object;
-                }
-            }
-        }
-
-        // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
-        Realm realm = (Realm) this.realm;
-        if (OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(),
-                realm.getConfiguration().getSchemaMediator().getSimpleClassName(object.getClass())) != null) {
-            return realm.copyToRealmOrUpdate(object);
-        } else {
-            return realm.copyToRealm(object);
-        }
-    }
-
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
      * RealmObjects will be shifted so no {@code null} values are introduced.
@@ -313,10 +259,15 @@ private E copyToRealmIfNeeded(E object) {
     public void move(int oldPos, int newPos) {
         if (isManaged()) {
             checkValidRealm();
-            osList.move(oldPos, newPos);
+            osListOperator.move(oldPos, newPos);
         } else {
-            checkIndex(oldPos);
-            checkIndex(newPos);
+            final int listSize = unmanagedList.size();
+            if (oldPos < 0 || listSize <= oldPos) {
+                throw new IndexOutOfBoundsException("Invalid index " + oldPos + ", size is " + listSize);
+            }
+            if (newPos < 0 || listSize <= newPos) {
+                throw new IndexOutOfBoundsException("Invalid index " + newPos + ", size is " + listSize);
+            }
             E object = unmanagedList.remove(oldPos);
             if (newPos > oldPos) {
                 unmanagedList.add(newPos - 1, object);
@@ -338,7 +289,7 @@ public void move(int oldPos, int newPos) {
     public void clear() {
         if (isManaged()) {
             checkValidRealm();
-            osList.removeAll();
+            osListOperator.removeAll();
         } else {
             unmanagedList.clear();
         }
@@ -359,7 +310,7 @@ public E remove(int location) {
         if (isManaged()) {
             checkValidRealm();
             removedItem = get(location);
-            osList.remove(location);
+            osListOperator.remove(location);
         } else {
             removedItem = unmanagedList.remove(location);
         }
@@ -385,7 +336,7 @@ public E remove(int location) {
      * @throws NullPointerException if {@code object} is {@code null}.
      */
     @Override
-    public boolean remove(Object object) {
+    public boolean remove(@Nullable Object object) {
         if (isManaged() && !realm.isInTransaction()) {
             throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
         }
@@ -422,7 +373,7 @@ public boolean removeAll(Collection<?> collection) {
     @Override
     public boolean deleteFirstFromRealm() {
         if (isManaged()) {
-            if (size() > 0) {
+            if (!osListOperator.isEmpty()) {
                 deleteFromRealm(0);
                 modCount++;
                 return true;
@@ -440,8 +391,8 @@ public boolean deleteFirstFromRealm() {
     @Override
     public boolean deleteLastFromRealm() {
         if (isManaged()) {
-            if (size() > 0) {
-                deleteFromRealm(size() - 1);
+            if (!osListOperator.isEmpty()) {
+                osListOperator.deleteLast();
                 modCount++;
                 return true;
             } else {
@@ -461,10 +412,11 @@ public boolean deleteLastFromRealm() {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
+    @Nullable
     public E get(int location) {
         if (isManaged()) {
             checkValidRealm();
-            return realm.get(clazz, className, osList.getUncheckedRow(location));
+            return osListOperator.get(location);
         } else {
             return unmanagedList.get(location);
         }
@@ -474,6 +426,7 @@ public E get(int location) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E first() {
         return firstImpl(true, null);
     }
@@ -491,7 +444,7 @@ public E first(@Nullable E defaultValue) {
     private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
         if (isManaged()) {
             checkValidRealm();
-            if (!osList.isEmpty()) {
+            if (!osListOperator.isEmpty()) {
                 return get(0);
             }
         } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
@@ -509,6 +462,7 @@ private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E last() {
         return lastImpl(true, null);
     }
@@ -526,8 +480,8 @@ public E last(@Nullable E defaultValue) {
     private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
         if (isManaged()) {
             checkValidRealm();
-            if (!osList.isEmpty()) {
-                return get((int) osList.size() - 1);
+            if (!osListOperator.isEmpty()) {
+                return get(osListOperator.size() - 1);
             }
         } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(unmanagedList.size() - 1);
@@ -587,7 +541,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     public void deleteFromRealm(int location) {
         if (isManaged()) {
             checkValidRealm();
-            osList.delete(location);
+            osListOperator.delete(location);
             modCount++;
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -604,8 +558,7 @@ public void deleteFromRealm(int location) {
     public int size() {
         if (isManaged()) {
             checkValidRealm();
-            long size = osList.size();
-            return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
+            return osListOperator.size();
         } else {
             return unmanagedList.size();
         }
@@ -622,6 +575,9 @@ public int size() {
     public RealmQuery<E> where() {
         if (isManaged()) {
             checkValidRealm();
+            if (!osListOperator.forRealmModel()) {
+                throw new IllegalStateException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+            }
             return RealmQuery.createQueryFromList(this);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -634,11 +590,8 @@ public int size() {
     @Override
     @Nullable
     public Number min(String fieldName) {
-        if (isManaged()) {
-            return this.where().min(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return where().min(fieldName);
     }
 
     /**
@@ -647,11 +600,8 @@ public Number min(String fieldName) {
     @Override
     @Nullable
     public Number max(String fieldName) {
-        if (isManaged()) {
-            return this.where().max(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().max(fieldName);
     }
 
     /**
@@ -659,11 +609,8 @@ public Number max(String fieldName) {
      */
     @Override
     public Number sum(String fieldName) {
-        if (isManaged()) {
-            return this.where().sum(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().sum(fieldName);
     }
 
     /**
@@ -671,11 +618,8 @@ public Number sum(String fieldName) {
      */
     @Override
     public double average(String fieldName) {
-        if (isManaged()) {
-            return this.where().average(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().average(fieldName);
     }
 
     /**
@@ -684,11 +628,8 @@ public double average(String fieldName) {
     @Override
     @Nullable
     public Date maxDate(String fieldName) {
-        if (isManaged()) {
-            return this.where().maximumDate(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().maximumDate(fieldName);
     }
 
     /**
@@ -697,11 +638,8 @@ public Date maxDate(String fieldName) {
     @Override
     @Nullable
     public Date minDate(String fieldName) {
-        if (isManaged()) {
-            return this.where().minimumDate(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().minimumDate(fieldName);
     }
 
     /**
@@ -711,8 +649,8 @@ public Date minDate(String fieldName) {
     public boolean deleteAllFromRealm() {
         if (isManaged()) {
             checkValidRealm();
-            if (size() > 0) {
-                osList.deleteAll();
+            if (!osListOperator.isEmpty()) {
+                osListOperator.deleteAll();
                 modCount++;
                 return true;
             } else {
@@ -762,12 +700,7 @@ public boolean contains(@Nullable Object object) {
                 }
             }
 
-            for (E e : this) {
-                if (e.equals(object)) {
-                    return true;
-                }
-            }
-            return false;
+            return super.contains(object);
         } else {
             return unmanagedList.contains(object);
         }
@@ -808,20 +741,6 @@ public boolean contains(@Nullable Object object) {
         }
     }
 
-    private void checkValidObject(E object) {
-        //noinspection ConstantConditions
-        if (object == null) {
-            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
-        }
-    }
-
-    private void checkIndex(int location) {
-        int size = size();
-        if (location < 0 || location >= size) {
-            throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size);
-        }
-    }
-
     private void checkValidRealm() {
         realm.checkIfValid();
     }
@@ -835,47 +754,104 @@ private void checkValidRealm() {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
         checkValidRealm();
+        if (!osListOperator.forRealmModel()) {
+            throw new IllegalStateException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+        }
         if (className != null) {
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, osList, null),
+                    new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null),
                     className);
         } else {
             // 'clazz' is non-null when 'dynamicClassName' is null.
             //noinspection ConstantConditions
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, osList, null),
+                    new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null),
                     clazz);
         }
     }
 
     @Override
     public String toString() {
-        StringBuilder sb = new StringBuilder();
-        if (isManaged()) {
-            // 'clazz' is non-null when 'dynamicClassName' is null.
-            //noinspection ConstantConditions
-            sb.append(className != null ? className : realm.getSchema().getSchemaForClass(clazz).getClassName());
-        } else {
-            sb.append(getClass().getSimpleName());
-        }
-        sb.append("@[");
-        if (isManaged() && !isAttached()) {
-            sb.append("invalid");
+        final String separator = ",";
+        final StringBuilder sb = new StringBuilder();
+
+        if (!isManaged()) {
+            // Build String for unmanaged RealmList
+
+            // Unmanaged RealmList does not know actual element type.
+            sb.append("RealmList<?>@[");
+            // Print list values
+            final int size = size();
+            for (int i = 0; i < size; i++) {
+                final E value = get(i);
+                if (value instanceof RealmModel) {
+                    sb.append(System.identityHashCode(value));
+                } else {
+                    if (value instanceof byte[]) {
+                        sb.append("byte[").append(((byte[]) value).length).append("]");
+                    } else {
+                        sb.append(value);
+                    }
+                }
+                sb.append(separator);
+            }
+            if (0 < size()) {
+                sb.setLength(sb.length() - separator.length());
+            }
+            sb.append("]");
         } else {
-            for (int i = 0; i < size(); i++) {
-                if (isManaged()) {
-                    sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
+            // Build String for managed RealmList
+
+            // Determines type of List
+            sb.append("RealmList<");
+            if (className != null) {
+                sb.append(className);
+            } else {
+                // 'clazz' is non-null when 'dynamicClassName' is null.
+                //noinspection ConstantConditions,unchecked
+                if (isClassForRealmModel(clazz)) {
+                    //noinspection ConstantConditions,unchecked
+                    sb.append(realm.getSchema().getSchemaForClass((Class<RealmModel>) clazz).getClassName());
                 } else {
-                    sb.append(System.identityHashCode(get(i)));
+                    if (clazz == byte[].class) {
+                        sb.append(clazz.getSimpleName());
+                    } else {
+                        sb.append(clazz.getName());
+                    }
+                }
+            }
+            sb.append(">@[");
+
+            //Print list values
+            if (!isAttached()) {
+                sb.append("invalid");
+            } else if (isClassForRealmModel(clazz)) {
+                for (int i = 0; i < size(); i++) {
+                    //noinspection ConstantConditions
+                    sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
+                    sb.append(separator);
                 }
-                if (i < size() - 1) {
-                    sb.append(',');
+                if (0 < size()) {
+                    sb.setLength(sb.length() - separator.length());
+                }
+            } else {
+                for (int i = 0; i < size(); i++) {
+                    final E value = get(i);
+                    if (value instanceof byte[]) {
+                        sb.append("byte[").append(((byte[]) value).length).append("]");
+                    } else {
+                        sb.append(value);
+                    }
+                    sb.append(separator);
+                }
+                if (0 < size()) {
+                    sb.setLength(sb.length() - separator.length());
                 }
             }
+            sb.append("]");
         }
-        sb.append("]");
         return sb.toString();
     }
 
@@ -909,10 +885,8 @@ public String toString() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
         } else if (realm instanceof DynamicRealm) {
-            DynamicRealm dynamicRealm = (DynamicRealm) realm;
-            RealmList<DynamicRealmObject> dynamicList = (RealmList<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
-            Flowable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicList);
+            Flowable<RealmList<E>> results = realm.configuration.getRxFactory().from((DynamicRealm) realm, this);
             return results;
         } else {
             throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
@@ -927,7 +901,7 @@ public String toString() {
      * <p>
      * RealmList will continually be emitted as the RealmList is updated - {@code onComplete} will never be called.
      * <p>
- *   * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * * Note that when the {@link Realm} is accessed from threads other than where it was created,
      * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
      * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
      * instead.
@@ -992,7 +966,11 @@ private void checkForAddRemoveListener(@Nullable Object listener, boolean checkL
      */
     public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().addListener(this, listener);
+        } else {
+            osListOperator.getOsList().addListener(this, listener);
+        }
     }
 
     /**
@@ -1005,7 +983,11 @@ public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>>
      */
     public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeListener(this, listener);
+        } else {
+            osListOperator.getOsList().removeListener(this, listener);
+        }
     }
 
     /**
@@ -1043,7 +1025,11 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<
      */
     public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().addListener(this, listener);
+        } else {
+            osListOperator.getOsList().addListener(this, listener);
+        }
     }
 
     /**
@@ -1056,7 +1042,11 @@ public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeListener(this, listener);
+        } else {
+            osListOperator.getOsList().removeListener(this, listener);
+        }
     }
 
     /**
@@ -1067,7 +1057,11 @@ public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeAllChangeListeners() {
         checkForAddRemoveListener(null, false);
-        collection.removeAllListeners();
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeAllListeners();
+        } else {
+            osListOperator.getOsList().removeAllListeners();
+        }
     }
 
     // Custom RealmList iterator.
@@ -1105,6 +1099,7 @@ public boolean hasNext() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public E next() {
             checkValidRealm();
             checkConcurrentModification();
@@ -1178,6 +1173,7 @@ public boolean hasPrevious() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public E previous() {
             checkConcurrentModification();
             int i = cursor - 1;
@@ -1211,7 +1207,7 @@ public int previousIndex() {
          * {@inheritDoc}
          */
         @Override
-        public void set(E e) {
+        public void set(@Nullable E e) {
             realm.checkIfValid();
             if (lastRet < 0) {
                 throw new IllegalStateException();
@@ -1230,10 +1226,10 @@ public void set(E e) {
          * Adding a new object to the RealmList. If the object is not already manage by Realm it will be transparently
          * copied using {@link Realm#copyToRealmOrUpdate(RealmModel)}
          *
-         * @see #add(RealmModel)
+         * @see #add(Object)
          */
         @Override
-        public void add(E e) {
+        public void add(@Nullable E e) {
             realm.checkIfValid();
             checkConcurrentModification();
             try {
@@ -1247,4 +1243,680 @@ public void add(E e) {
             }
         }
     }
+
+    private static boolean isClassForRealmModel(Class<?> clazz) {
+        return RealmModel.class.isAssignableFrom(clazz);
+    }
+
+    private ManagedListOperator<E> getOperator(BaseRealm realm, OsList osList, @Nullable Class<E> clazz, @Nullable String className) {
+        if (clazz == null || isClassForRealmModel(clazz)) {
+            return new RealmModelListOperator<>(realm, osList, clazz, className);
+        }
+        if (clazz == String.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new StringListOperator(realm, osList, (Class<String>) clazz);
+        }
+        if (clazz == Long.class || clazz == Integer.class || clazz == Short.class || clazz == Byte.class) {
+            return new LongListOperator<>(realm, osList, clazz);
+        }
+        if (clazz == Boolean.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BooleanListOperator(realm, osList, (Class<Boolean>) clazz);
+        }
+        if (clazz == byte[].class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BinaryListOperator(realm, osList, (Class<byte[]>) clazz);
+        }
+        if (clazz == Double.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DoubleListOperator(realm, osList, (Class<Double>) clazz);
+        }
+        if (clazz == Float.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new FloatListOperator(realm, osList, (Class<Float>) clazz);
+        }
+        if (clazz == Date.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DateListOperator(realm, osList, (Class<Date>) clazz);
+        }
+        throw new IllegalArgumentException("Unexpected value class: " + clazz.getName());
+    }
+
+    // TODO: Object Store is not able to merge change set for links list. Luckily since we were still using LinkView
+    // when ship the fine grain notifications, the listener on RealmList is actually added to a OS Results which is
+    // created from the link view. OS Results is computing the change set by comparing the old/new collection. So it
+    // will give the right results if you remove all elements from a RealmList then add all them back and add one more
+    // new element. By right results it means the change set only include one insertion. But if the listener is on the
+    // OS List, the change set will include all ranges of th list. So we keep the old behaviour for
+    // RealmList<RealmModel> for now. See https://github.com/realm/realm-object-store/issues/541
+    private io.realm.internal.Collection getOrCreateOsResultsForListener() {
+        if (osResults == null) {
+            this.osResults = new io.realm.internal.Collection(realm.sharedRealm, osListOperator.getOsList(), null);
+        }
+        return osResults;
+    }
+}
+
+/**
+ * This class provides facade for against {@link OsList}. {@link OsList} is used for both {@link RealmModel}s
+ * and values, but there are some subtle differences in actual operation.
+ * <p>
+ * This class provides common interface for them.
+ * <p>
+ * You need to use appropriate sub-class for underlying field type.
+ *
+ * @param <T> class of element which is returned on read operation.
+ */
+abstract class ManagedListOperator<T> {
+    static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values.";
+    static final String INVALID_OBJECT_TYPE_MESSAGE = "Unacceptable value type. Acceptable: %1$s, actual: %2$s .";
+
+    final BaseRealm realm;
+    final OsList osList;
+    @Nullable
+    final Class<T> clazz;
+
+    ManagedListOperator(BaseRealm realm, OsList osList, @Nullable Class<T> clazz) {
+        this.realm = realm;
+        this.clazz = clazz;
+        this.osList = osList;
+    }
+
+    public abstract boolean forRealmModel();
+
+    public final OsList getOsList() {
+        return osList;
+    }
+
+    public final boolean isValid() {
+        return osList.isValid();
+    }
+
+    public final int size() {
+        final long actualSize = osList.size();
+        return actualSize < Integer.MAX_VALUE ? (int) actualSize : Integer.MAX_VALUE;
+    }
+
+    public final boolean isEmpty() {
+        return osList.isEmpty();
+    }
+
+    protected abstract void checkValidValue(@Nullable Object value);
+
+    @Nullable
+    public abstract T get(int index);
+
+    public final void append(@Nullable Object value) {
+        checkValidValue(value);
+
+        if (value == null) {
+            appendNull();
+        } else {
+            appendValue(value);
+        }
+    }
+
+    private void appendNull() {
+        osList.addNull();
+    }
+
+    abstract protected void appendValue(Object value);
+
+    public final void insert(int index, @Nullable Object value) {
+        checkValidValue(value);
+
+        if (value == null) {
+            insertNull(index);
+        } else {
+            insertValue(index, value);
+        }
+
+    }
+
+    protected void insertNull(int index) {
+        osList.insertNull(index);
+    }
+
+    protected abstract void insertValue(int index, Object value);
+
+    @Nullable
+    public final T set(int index, @Nullable Object value) {
+        checkValidValue(value);
+
+        //noinspection unchecked
+        final T oldObject = get(index);
+        if (value == null) {
+            setNull(index);
+        } else {
+            setValue(index, value);
+        }
+        return oldObject;
+    }
+
+    protected void setNull(int index) {
+        osList.setNull(index);
+    }
+
+    abstract protected void setValue(int index, Object value);
+
+    final void move(int oldPos, int newPos) {
+        osList.move(oldPos, newPos);
+    }
+
+    final void remove(int index) {
+        osList.remove(index);
+    }
+
+    final void removeAll() {
+        osList.removeAll();
+    }
+
+    final void delete(int index) {
+        osList.delete(index);
+    }
+
+    final void deleteLast() {
+        osList.delete(osList.size() - 1);
+    }
+
+    final void deleteAll() {
+        osList.deleteAll();
+    }
+
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link RealmModel} list field.
+ */
+final class RealmModelListOperator<T> extends ManagedListOperator<T> {
+
+    @Nullable
+    private final String className;
+
+    RealmModelListOperator(BaseRealm realm, OsList osList, @Nullable Class<T> clazz, @Nullable String className) {
+        super(realm, osList, clazz);
+        this.className = className;
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return true;
+    }
+
+    @Override
+    public T get(int index) {
+        //noinspection unchecked
+        return (T) realm.get((Class<? extends RealmModel>) clazz, className, osList.getUncheckedRow(index));
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
+        }
+        if (!(value instanceof RealmModel)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.String",
+                            value.getClass().getName()));
+        }
+    }
+
+    private void checkInsertIndex(int index) {
+        final int size = size();
+        if (index < 0 || size < index) {
+            throw new IndexOutOfBoundsException("Invalid index " + index + ", size is " + osList.size());
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        final RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.addRow(proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    protected void insertNull(int index) {
+        throw new RuntimeException("Should not reach here.");
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        // need to check in advance to avoid unnecessary copy of unmanaged object into Realm.
+        checkInsertIndex(index);
+
+        RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.insertRow(index, proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    protected void setNull(int index) {
+        throw new RuntimeException("Should not reach here.");
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.setRow(index, proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
+    private <E extends RealmModel> E copyToRealmIfNeeded(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+
+            if (proxy instanceof DynamicRealmObject) {
+                //noinspection ConstantConditions
+                @Nonnull
+                String listClassName = className;
+                if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
+                    String objectClassName = ((DynamicRealmObject) object).getType();
+                    if (listClassName.equals(objectClassName)) {
+                        // Same Realm instance and same target table
+                        return object;
+                    } else {
+                        // Different target table
+                        throw new IllegalArgumentException(String.format(Locale.US,
+                                "The object has a different type from list's." +
+                                        " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
+                    }
+                } else if (realm.threadId == proxy.realmGet$proxyState().getRealm$realm().threadId) {
+                    // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
+                    // you have to run a full schema validation for each object.
+                    // And copying from another Realm instance pointed to the same Realm file is not supported as well.
+                    throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
+                } else {
+                    throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
+                }
+            } else {
+                // Object is already in this realm
+                if (proxy.realmGet$proxyState().getRow$realm() != null && proxy.realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    if (realm != proxy.realmGet$proxyState().getRealm$realm()) {
+                        throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
+                    }
+                    return object;
+                }
+            }
+        }
+
+        // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
+        Realm realm = (Realm) this.realm;
+        if (OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(),
+                realm.getConfiguration().getSchemaMediator().getSimpleClassName(object.getClass())) != null) {
+            return realm.copyToRealmOrUpdate(object);
+        } else {
+            return realm.copyToRealm(object);
+        }
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link String} list field.
+ */
+final class StringListOperator extends ManagedListOperator<String> {
+
+    StringListOperator(BaseRealm realm, OsList osList, Class<String> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public String get(int index) {
+        return (String) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof String)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.String",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addString((String) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertString(index, (String) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setString(index, (String) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code long} list field.
+ */
+final class LongListOperator<T> extends ManagedListOperator<T> {
+
+    LongListOperator(BaseRealm realm, OsList osList, Class<T> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public T get(int index) {
+        final Long value = (Long) osList.getValue(index);
+        if (value == null) {
+            return null;
+        }
+        if (clazz == Long.class) {
+            //noinspection unchecked
+            return (T) value;
+        }
+        if (clazz == Integer.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Integer.valueOf(value.intValue()));
+        }
+        if (clazz == Short.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Short.valueOf(value.shortValue()));
+        }
+        if (clazz == Byte.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Byte.valueOf(value.byteValue()));
+        }
+        //noinspection ConstantConditions
+        throw new IllegalStateException("Unexpected element type: " + clazz.getName());
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Long, java.lang.Integer, java.lang.Short, java.lang.Byte",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addLong(((Number) value).longValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertLong(index, ((Number) value).longValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setLong(index, ((Number) value).longValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code boolean} list field.
+ */
+final class BooleanListOperator extends ManagedListOperator<Boolean> {
+
+    BooleanListOperator(BaseRealm realm, OsList osList, Class<Boolean> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Boolean get(int index) {
+        return (Boolean) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Boolean)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Boolean",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addBoolean((Boolean) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertBoolean(index, (Boolean) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setBoolean(index, (Boolean) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code byte[]} list field.
+ */
+final class BinaryListOperator extends ManagedListOperator<byte[]> {
+
+    BinaryListOperator(BaseRealm realm, OsList osList, Class<byte[]> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public byte[] get(int index) {
+        return (byte[]) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof byte[])) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "byte[]",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addBinary((byte[]) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertBinary(index, (byte[]) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setBinary(index, (byte[]) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code double} list field.
+ */
+final class DoubleListOperator extends ManagedListOperator<Double> {
+
+    DoubleListOperator(BaseRealm realm, OsList osList, Class<Double> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Double get(int index) {
+        return (Double) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Number",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addDouble(((Number) value).doubleValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertDouble(index, ((Number) value).doubleValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setDouble(index, ((Number) value).doubleValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code float} list field.
+ */
+final class FloatListOperator extends ManagedListOperator<Float> {
+
+    FloatListOperator(BaseRealm realm, OsList osList, Class<Float> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Float get(int index) {
+        return (Float) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Number",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addFloat(((Number) value).floatValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertFloat(index, ((Number) value).floatValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setFloat(index, ((Number) value).floatValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link Date} list field.
+ */
+final class DateListOperator extends ManagedListOperator<Date> {
+
+    DateListOperator(BaseRealm realm, OsList osList, Class<Date> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Date get(int index) {
+        return (Date) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Date)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.util.Date",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addDate((Date) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertDate(index, (Date) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setDate(index, (Date) value);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 30a584b996..27f0129173 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -255,6 +255,9 @@ public boolean hasIndex(String fieldName) {
     /**
      * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
      * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
+     * <p>
+     * If the type of designated field is a list of values (not {@link RealmObject}s , specified nullability
+     * only affects its elements, not the field itself. Value list itself is always non-nullable.
      *
      * @param fieldName name of field in the class.
      * @param required {@code true} if field should be required, {@code false} otherwise.
@@ -269,6 +272,9 @@ public boolean hasIndex(String fieldName) {
     /**
      * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
      * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
+     * <p>
+     * If the type of designated field is a list of values (not {@link RealmObject}s , specified nullability
+     * only affects its elements, not the field itself. Value list itself is always non-nullable.
      *
      * @param fieldName name of field in the class.
      * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index a87ff88b7d..5081ecfbc4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -53,7 +53,7 @@
  * @see Realm#where(Class)
  * @see RealmResults#where()
  */
-public class RealmQuery<E extends RealmModel> {
+public class RealmQuery<E> {
 
     private final Table table;
     private final BaseRealm realm;
@@ -61,7 +61,9 @@
     private final RealmObjectSchema schema;
     private Class<E> clazz;
     private String className;
+    private final boolean forValues;
     private final OsList osList;
+
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
     private static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
@@ -74,7 +76,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
+    static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
         return new RealmQuery<>(realm, clazz);
     }
 
@@ -86,7 +88,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
+    static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
         return new RealmQuery<>(realm, className);
     }
 
@@ -98,7 +100,7 @@
      * to run it.
      */
     @SuppressWarnings("unchecked")
-    public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
+    static <E> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
         //noinspection ConstantConditions
         return (queryResults.classSpec == null)
                 ? new RealmQuery(queryResults, queryResults.className)
@@ -113,43 +115,78 @@
      * to run it.
      */
     @SuppressWarnings("unchecked")
-    public static <E extends RealmModel> RealmQuery<E> createQueryFromList(RealmList<E> list) {
+    static <E> RealmQuery<E> createQueryFromList(RealmList<E> list) {
         //noinspection ConstantConditions
         return (list.clazz == null)
-                ? new RealmQuery(list.realm, list.osList, list.className)
-                : new RealmQuery(list.realm, list.osList, list.clazz);
+                ? new RealmQuery(list.realm, list.getOsList(), list.className)
+                : new RealmQuery(list.realm, list.getOsList(), list.clazz);
+    }
+
+    private static boolean isClassForRealmModel(Class<?> clazz) {
+        return RealmModel.class.isAssignableFrom(clazz);
     }
 
     private RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.getTable();
-        this.osList = null;
-        this.query = table.where();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = schema.getTable();
+            this.osList = null;
+            this.query = table.where();
+        }
     }
 
     private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = queryResults.getTable();
-        this.osList = null;
-        this.query = queryResults.getCollection().where();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = queryResults.getTable();
+            this.osList = null;
+            this.query = queryResults.getCollection().where();
+        }
     }
 
     private RealmQuery(BaseRealm realm, OsList osList, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.getTable();
-        this.osList = osList;
-        this.query = osList.getQuery();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = schema.getTable();
+            this.osList = osList;
+            this.query = osList.getQuery();
+        }
     }
 
     private RealmQuery(BaseRealm realm, String className) {
         this.realm = realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
         this.query = table.where();
@@ -159,6 +196,7 @@ private RealmQuery(BaseRealm realm, String className) {
     private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
         this.realm = queryResults.realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
         this.query = queryResults.getCollection().where();
@@ -168,6 +206,7 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
     private RealmQuery(BaseRealm realm, OsList osList, String className) {
         this.realm = realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
         this.query = osList.getQuery();
@@ -1932,8 +1971,14 @@ private boolean isDynamicQuery() {
     public E findFirst() {
         realm.checkIfValid();
 
+        if (forValues) {
+            // TODO implement this;
+            return null;
+        }
+
         long tableRowIndex = getSourceRowIndexForFirstObject();
-        return (tableRowIndex < 0) ? null : realm.get(clazz, className, tableRowIndex);
+        //noinspection unchecked
+        return (tableRowIndex < 0) ? null : (E) realm.get((Class<? extends RealmModel>) clazz, className, tableRowIndex);
     }
 
     /**
@@ -1949,6 +1994,10 @@ public E findFirst() {
     public E findFirstAsync() {
         realm.checkIfValid();
 
+        if (forValues) {
+            throw new UnsupportedOperationException("findFirstAsync() available only when type parameter 'E' is implementing RealmModel.");
+        }
+
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
         Row row;
         if (realm.isInTransaction()) {
@@ -1969,8 +2018,11 @@ public E findFirstAsync() {
             //noinspection unchecked
             result = (E) new DynamicRealmObject(realm, row);
         } else {
-            result = realm.getConfiguration().getSchemaMediator().newInstance(
-                    clazz, realm, row, realm.getSchema().getColumnInfo(clazz),
+            //noinspection unchecked
+            final Class<? extends RealmModel> modelClass = (Class<? extends RealmModel>) clazz;
+            //noinspection unchecked
+            result = (E) realm.getConfiguration().getSchemaMediator().newInstance(
+                    modelClass, realm, row, realm.getSchema().getColumnInfo(modelClass),
                     false, Collections.<String>emptyList());
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 0619784ffa..e7892701dd 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -60,7 +60,7 @@
  * @see RealmQuery#findAll()
  * @see Realm#executeTransaction(Realm.Transaction)
  */
-public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+public class RealmResults<E> extends OrderedRealmCollectionImpl<E> {
 
     // Called from Realm Proxy classes
     @SuppressLint("unused")
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index f3a5426cdd..f3a3e1f97b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal;
 
+import java.util.Locale;
+
 import io.realm.RealmFieldType;
 
 
@@ -95,6 +97,39 @@ public void setNull(long columnIndex) {
         }
     }
 
+    @Override
+    public OsList getList(long columnIndex) {
+        RealmFieldType fieldType = getTable().getColumnType(columnIndex);
+        if (fieldType != RealmFieldType.LIST) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US, "Field '%s' is not a 'RealmList'.",
+                            getTable().getColumnName(columnIndex)));
+        }
+        return super.getList(columnIndex);
+    }
+
+    @Override
+    public OsList getModelList(long columnIndex) {
+        RealmFieldType fieldType = getTable().getColumnType(columnIndex);
+        if (fieldType != RealmFieldType.LIST) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US, "Field '%s' is not a 'RealmList'.",
+                            getTable().getColumnName(columnIndex)));
+        }
+        return super.getModelList(columnIndex);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
+        final RealmFieldType actualFieldType = getTable().getColumnType(columnIndex);
+        if (fieldType != actualFieldType) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US, "The type of field '%1$s' is not 'RealmFieldType.%2$s'.",
+                            getTable().getColumnName(columnIndex), fieldType.name()));
+        }
+        return super.getValueList(columnIndex, fieldType);
+    }
+
     @Override
     protected native long nativeGetColumnCount(long nativeTablePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
index ec81feb7e9..df0b2c6cf0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Collection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
@@ -22,7 +22,6 @@
 
 import javax.annotation.Nullable;
 
-import io.realm.OrderedCollectionChangeSet;
 import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.RealmChangeListener;
 
@@ -31,68 +30,11 @@
  * Java wrapper of Object Store Results class.
  * It is the backend of binding's query results and back links.
  */
-@Keep
-public class Collection implements NativeObject {
+public class Collection implements NativeObject, ObservableCollection {
 
     private static final String CLOSED_REALM_MESSAGE =
             "This Realm instance has already been closed, making it unusable.";
 
-    private static class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
-        public CollectionObserverPair(T observer, Object listener) {
-            super(observer, listener);
-        }
-
-        public void onChange(T observer, OrderedCollectionChangeSet changes) {
-            if (listener instanceof OrderedRealmCollectionChangeListener) {
-                //noinspection unchecked
-                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, changes);
-            } else if (listener instanceof RealmChangeListener) {
-                //noinspection unchecked
-                ((RealmChangeListener<T>) listener).onChange(observer);
-            } else {
-                throw new RuntimeException("Unsupported listener type: " + listener);
-            }
-        }
-    }
-
-    private static class RealmChangeListenerWrapper<T> implements OrderedRealmCollectionChangeListener<T> {
-        private final RealmChangeListener<T> listener;
-
-        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
-            this.listener = listener;
-        }
-
-        @Override
-        public void onChange(T collection, OrderedCollectionChangeSet changes) {
-            listener.onChange(collection);
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            return obj instanceof RealmChangeListenerWrapper &&
-                    listener == ((RealmChangeListenerWrapper) obj).listener;
-        }
-
-        @Override
-        public int hashCode() {
-            return listener.hashCode();
-        }
-    }
-
-    private static class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
-        private final OrderedCollectionChangeSet changeSet;
-
-        Callback(OrderedCollectionChangeSet changeSet) {
-            this.changeSet = changeSet;
-        }
-
-        @Override
-        public void onCalled(CollectionObserverPair pair, Object observer) {
-            //noinspection unchecked
-            pair.onChange(observer, changeSet);
-        }
-    }
-
     // Custom Collection iterator. It ensures that we only iterate on a Realm collection that hasn't changed.
     public static abstract class Iterator<T> implements java.util.Iterator<T> {
         Collection iteratorCollection;
@@ -130,6 +72,7 @@ public boolean hasNext() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public T next() {
             checkValid();
             pos++;
@@ -170,6 +113,7 @@ void checkValid() {
             }
         }
 
+        @Nullable
         T get(int pos) {
             return convertRowToObject(iteratorCollection.getUncheckedRow(pos));
         }
@@ -199,7 +143,7 @@ public ListIterator(Collection collection, int start) {
          */
         @Override
         @Deprecated
-        public void add(T object) {
+        public void add(@Nullable T object) {
             throw new UnsupportedOperationException("Adding an element is not supported. Use Realm.createObject() instead.");
         }
 
@@ -225,6 +169,7 @@ public int nextIndex() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public T previous() {
             checkValid();
             try {
@@ -253,7 +198,7 @@ public int previousIndex() {
          */
         @Override
         @Deprecated
-        public void set(T object) {
+        public void set(@Nullable T object) {
             throw new UnsupportedOperationException("Replacing and element is not supported.");
         }
     }
@@ -514,8 +459,8 @@ public boolean isValid() {
     }
 
     // Called by JNI
-    @SuppressWarnings("unused")
-    private void notifyChangeListeners(long nativeChangeSetPtr) {
+    @Override
+    public void notifyChangeListeners(long nativeChangeSetPtr) {
         if (nativeChangeSetPtr == 0 && isLoaded()) {
             return;
         }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
index fba9493fb2..79510c7e08 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -105,7 +105,17 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public OsList getLinkList(long columnIndex) {
+    public OsList getList(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public OsList getModelList(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
         throw getStubException();
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index f834da2b3c..b4cf5a0e4d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -67,7 +67,7 @@ public void realmClosed(RealmConfiguration configuration) {
     }
 
     public Object[] getUserAndServerUrl(RealmConfiguration config) {
-        return new Object[6];
+        return new Object[7];
     }
 
     public static ObjectServerFacade getFacade(boolean needSyncFacade) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
new file mode 100644
index 0000000000..7004df192c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
@@ -0,0 +1,72 @@
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
+import io.realm.RealmChangeListener;
+
+// Helper class for supporting add change listeners on OsResults & OsList.
+@Keep
+interface ObservableCollection {
+
+    class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
+        public CollectionObserverPair(T observer, Object listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(T observer, @Nullable OrderedCollectionChangeSet changes) {
+            if (listener instanceof OrderedRealmCollectionChangeListener) {
+                //noinspection unchecked
+                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, changes);
+            } else if (listener instanceof RealmChangeListener) {
+                //noinspection unchecked
+                ((RealmChangeListener<T>) listener).onChange(observer);
+            } else {
+                throw new RuntimeException("Unsupported listener type: " + listener);
+            }
+        }
+    }
+
+    class RealmChangeListenerWrapper<T> implements OrderedRealmCollectionChangeListener<T> {
+        private final RealmChangeListener<T> listener;
+
+        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            this.listener = listener;
+        }
+
+        @Override
+        public void onChange(T collection, @Nullable OrderedCollectionChangeSet changes) {
+            listener.onChange(collection);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof RealmChangeListenerWrapper &&
+                    listener == ((RealmChangeListenerWrapper) obj).listener;
+        }
+
+        @Override
+        public int hashCode() {
+            return listener.hashCode();
+        }
+    }
+
+    class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
+        private final OrderedCollectionChangeSet changeSet;
+
+        Callback(@Nullable OrderedCollectionChangeSet changeSet) {
+            this.changeSet = changeSet;
+        }
+
+        @Override
+        public void onCalled(CollectionObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange(observer, changeSet);
+        }
+    }
+
+    // Called by JNI
+    @SuppressWarnings("SameParameterValue")
+    void notifyChangeListeners(long nativeChangeSetPtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsList.java b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
index 7d9a794f63..bedf3e928a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
@@ -1,14 +1,23 @@
 package io.realm.internal;
 
+import java.util.Date;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedRealmCollectionChangeListener;
+import io.realm.RealmChangeListener;
+
 /**
  * Java wrapper of Object Store List class. This backs managed versions of RealmList.
  */
-public class OsList implements NativeObject {
+public class OsList implements NativeObject, ObservableCollection {
 
     private final long nativePtr;
     private final NativeContext context;
     private final Table targetTable;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    private final ObserverPairList<CollectionObserverPair> observerPairs =
+            new ObserverPairList<CollectionObserverPair>();
 
     public OsList(UncheckedRow row, long columnIndex) {
         SharedRealm sharedRealm = row.getTable().getSharedRealm();
@@ -18,7 +27,11 @@ public OsList(UncheckedRow row, long columnIndex) {
         this.context = sharedRealm.context;
         context.addReference(this);
 
-        targetTable = new Table(sharedRealm, ptrs[1]);
+        if (ptrs[1] != 0) {
+            targetTable = new Table(sharedRealm, ptrs[1]);
+        } else {
+            targetTable = null;
+        }
     }
 
     @Override
@@ -47,6 +60,119 @@ public void setRow(long pos, long targetRowIndex) {
         nativeSetRow(nativePtr, pos, targetRowIndex);
     }
 
+    public void addNull() {
+        nativeAddNull(nativePtr);
+    }
+
+    public void insertNull(long pos) {
+        nativeInsertNull(nativePtr, pos);
+    }
+
+    public void setNull(long pos) {
+        nativeSetNull(nativePtr, pos);
+    }
+
+    public void addLong(long value) {
+        nativeAddLong(nativePtr, value);
+    }
+
+    public void insertLong(long pos, long value) {
+        nativeInsertLong(nativePtr, pos, value);
+    }
+
+    public void setLong(long pos, long value) {
+        nativeSetLong(nativePtr, pos, value);
+    }
+
+    public void addDouble(double value) {
+        nativeAddDouble(nativePtr, value);
+    }
+
+    public void insertDouble(long pos, double value) {
+        nativeInsertDouble(nativePtr, pos, value);
+    }
+
+    public void setDouble(long pos, double value) {
+        nativeSetDouble(nativePtr, pos, value);
+    }
+
+    public void addFloat(float value) {
+        nativeAddFloat(nativePtr, value);
+    }
+
+    public void insertFloat(long pos, float value) {
+        nativeInsertFloat(nativePtr, pos, value);
+    }
+
+    public void setFloat(long pos, float value) {
+        nativeSetFloat(nativePtr, pos, value);
+    }
+
+    public void addBoolean(boolean value) {
+        nativeAddBoolean(nativePtr, value);
+    }
+
+    public void insertBoolean(long pos, boolean value) {
+        nativeInsertBoolean(nativePtr, pos, value);
+    }
+
+    public void setBoolean(long pos, boolean value) {
+        nativeSetBoolean(nativePtr, pos, value);
+    }
+
+    public void addBinary(@Nullable byte[] value) {
+        nativeAddBinary(nativePtr, value);
+    }
+
+    public void insertBinary(long pos, @Nullable byte[] value) {
+        nativeInsertBinary(nativePtr, pos, value);
+    }
+
+    public void setBinary(long pos, @Nullable byte[] value) {
+        nativeSetBinary(nativePtr, pos, value);
+    }
+
+    public void addString(@Nullable String value) {
+        nativeAddString(nativePtr, value);
+    }
+
+    public void insertString(long pos, @Nullable String value) {
+        nativeInsertString(nativePtr, pos, value);
+    }
+
+    public void setString(long pos, @Nullable String value) {
+        nativeSetString(nativePtr, pos, value);
+    }
+
+    public void addDate(@Nullable Date value) {
+        if (value == null) {
+            nativeAddNull(nativePtr);
+        } else {
+            nativeAddDate(nativePtr, value.getTime());
+        }
+    }
+
+    public void insertDate(long pos, @Nullable Date value) {
+        if (value == null) {
+            nativeInsertNull(nativePtr, pos);
+        } else {
+            nativeInsertDate(nativePtr, pos, value.getTime());
+        }
+    }
+
+    public void setDate(long pos, @Nullable Date value) {
+        if (value == null) {
+            nativeSetNull(nativePtr, pos);
+        } else {
+            nativeSetDate(nativePtr, pos, value.getTime());
+        }
+    }
+
+    @Nullable
+    public Object getValue(long pos) {
+        return nativeGetValue(nativePtr, pos);
+    }
+
     public void move(long sourceIndex, long targetIndex) {
         nativeMove(nativePtr, sourceIndex, targetIndex);
     }
@@ -90,6 +216,44 @@ public Table getTargetTable() {
         return targetTable;
     }
 
+    public <T> void addListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        CollectionObserverPair<T> collectionObserverPair = new CollectionObserverPair<T>(observer, listener);
+        observerPairs.add(collectionObserverPair);
+    }
+
+    public <T> void addListener(T observer, RealmChangeListener<T> listener) {
+        addListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public <T> void removeListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        observerPairs.remove(observer, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    public <T> void removeListener(T observer, RealmChangeListener<T> listener) {
+        removeListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public void removeAllListeners() {
+        observerPairs.clear();
+        nativeStopListening(nativePtr);
+    }
+
+    // Called by JNI
+    @Override
+    public void notifyChangeListeners(long nativeChangeSetPtr) {
+        if (nativeChangeSetPtr == 0) {
+            // First time "query" returns. Do nothing.
+            return;
+        }
+        observerPairs.foreach(new Callback(new OsCollectionChangeSet(nativeChangeSetPtr)));
+    }
+
     private static native long nativeGetFinalizerPtr();
 
     // TODO: nativeTablePtr is not necessary. It is used to create FieldDescriptor which should be generated from
@@ -120,4 +284,58 @@ public Table getTargetTable() {
     private static native void nativeDelete(long nativePtr, long index);
 
     private static native void nativeDeleteAll(long nativePtr);
+
+    private static native void nativeAddNull(long nativePtr);
+
+    private static native void nativeInsertNull(long nativePtr, long pos);
+
+    private static native void nativeSetNull(long nativePtr, long pos);
+
+    private static native void nativeAddLong(long nativePtr, long value);
+
+    private static native void nativeInsertLong(long nativePtr, long pos, long value);
+
+    private static native void nativeSetLong(long nativePtr, long pos, long value);
+
+    private static native void nativeAddDouble(long nativePtr, double value);
+
+    private static native void nativeInsertDouble(long nativePtr, long pos, double value);
+
+    private static native void nativeSetDouble(long nativePtr, long pos, double value);
+
+    private static native void nativeAddFloat(long nativePtr, float value);
+
+    private static native void nativeInsertFloat(long nativePtr, long pos, float value);
+
+    private static native void nativeSetFloat(long nativePtr, long pos, float value);
+
+    private static native void nativeAddBoolean(long nativePtr, boolean value);
+
+    private static native void nativeInsertBoolean(long nativePtr, long pos, boolean value);
+
+    private static native void nativeSetBoolean(long nativePtr, long pos, boolean value);
+
+    private static native void nativeAddBinary(long nativePtr, @Nullable byte[] value);
+
+    private static native void nativeInsertBinary(long nativePtr, long pos, @Nullable byte[] value);
+
+    private static native void nativeSetBinary(long nativePtr, long pos, @Nullable byte[] value);
+
+    private static native void nativeAddDate(long nativePtr, long value);
+
+    private static native void nativeInsertDate(long nativePtr, long pos, long value);
+
+    private static native void nativeSetDate(long nativePtr, long pos, long value);
+
+    private static native void nativeAddString(long nativePtr, @Nullable String value);
+
+    private static native void nativeInsertString(long nativePtr, long pos, @Nullable String value);
+
+    private static native void nativeSetString(long nativePtr, long pos, @Nullable String value);
+
+    private static native Object nativeGetValue(long nativePtr, long pos);
+
+    private native void nativeStartListening(long nativePtr);
+
+    private native void nativeStopListening(long nativePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
index 36c7e9aef5..5b25bc1d43 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -46,22 +46,36 @@ public Builder(String className) {
         }
 
         /**
-         * Adds a persisted non-link property to this builder.
+         * Adds a persisted non-link, non value list property to this builder.
          *
          * @param name the name of the property.
          * @param type the type of the property.
          * @param isPrimaryKey set to true if this property is the primary key.
          * @param isIndexed set to true if this property needs an index.
-         * @param isRequired set to false if this property is not nullable.
+         * @param isRequired set to true if this property is not nullable.
          * @return this {@code OsObjectSchemaInfo}.
          */
         public Builder addPersistedProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
-                                   boolean isRequired) {
+                boolean isRequired) {
             final Property property = new Property(name, type, isPrimaryKey, isIndexed, isRequired);
             persistedPropertyList.add(property);
             return this;
         }
 
+        /**
+         * Adds a persisted value list property to this builder.
+         *
+         * @param name the name of the property.
+         * @param type the type of the property. It must be one of value list type.
+         * @param isRequired set to true if this property is not nullable.
+         * @return this {@code OsObjectSchemaInfo}.
+         */
+        public Builder addPersistedValueListProperty(String name, RealmFieldType type, boolean isRequired) {
+            final Property property = new Property(name, type, !Property.PRIMARY_KEY, !Property.INDEXED, isRequired);
+            persistedPropertyList.add(property);
+            return this;
+        }
+
         /**
          * Adds a persisted link property to this {@code OsObjectSchemaInfo}. A persisted link property will be stored
          * in the Realm file's schema.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
index f83f4f765c..3ff9eeb4de 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -56,6 +56,22 @@ public byte getNativeValue() {
         }
     }
 
+    public enum SyncSessionStopPolicy {
+        IMMEDIATELY(SYNCSESSION_STOP_POLICY_VALUE_IMMEDIATELY), // Immediately stop the session as soon as all Realms/Sessions go out of scope.
+        LIVE_INDEFINITELY(SYNCSESSION_STOP_POLICY_VALUE_LIVE_INDEFINETELY),   // Never stop the session.
+        AFTER_CHANGES_UPLOADED(SYNCSESSION_STOP_POLICY_VALUE_AFTER_CHANGES_UPLOADED); // Once all Realms/Sessions go out of scope, wait for uploads to complete and stop.
+
+        final byte value;
+
+        SyncSessionStopPolicy(byte value) {
+            this.value = value;
+        }
+
+        public byte getNativeValue() {
+            return value;
+        }
+    }
+
     /**
      * Builder class for creating {@code OsRealmConfig}. The {@code OsRealmConfig} instance should only be created by
      * {@link SharedRealm}.
@@ -134,6 +150,9 @@ OsRealmConfig build() {
     private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 3;
     private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 4;
     private static final byte SCHEMA_MODE_VALUE_MANUAL = 5;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_IMMEDIATELY = 0;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_LIVE_INDEFINETELY = 1;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_AFTER_CHANGES_UPLOADED = 2;
 
     private final static long nativeFinalizerPtr = nativeGetFinalizerPtr();
 
@@ -165,13 +184,14 @@ private OsRealmConfig(final RealmConfiguration config,
         NativeContext.dummyContext.addReference(this);
 
         // Retrieve Sync settings first. We need syncRealmUrl to identify if this is a SyncConfig
-        Object[] syncUserConf = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(realmConfiguration);
-        String syncUserIdentifier = (String) syncUserConf[0];
-        String syncRealmUrl = (String) syncUserConf[1];
-        String syncRealmAuthUrl = (String) syncUserConf[2];
-        String syncRefreshToken = (String) syncUserConf[3];
-        boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncUserConf[4]));
-        String syncSslTrustCertificatePath = (String) syncUserConf[5];
+        Object[] syncConfigurationOptions = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(realmConfiguration);
+        String syncUserIdentifier = (String) syncConfigurationOptions[0];
+        String syncRealmUrl = (String) syncConfigurationOptions[1];
+        String syncRealmAuthUrl = (String) syncConfigurationOptions[2];
+        String syncRefreshToken = (String) syncConfigurationOptions[3];
+        boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncConfigurationOptions[4]));
+        String syncSslTrustCertificatePath = (String) syncConfigurationOptions[5];
+        Byte sessionStopPolicy = (Byte) syncConfigurationOptions[6];
 
         // Set encryption key
         byte[] key = config.getEncryptionKey();
@@ -215,7 +235,7 @@ private OsRealmConfig(final RealmConfiguration config,
         // Set sync config
         if (syncRealmUrl != null) {
             nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
-                    syncRefreshToken);
+                    syncRefreshToken, sessionStopPolicy);
             nativeSetSyncConfigSslSettings(nativePtr, syncClientValidateSsl, syncSslTrustCertificatePath);
         }
     }
@@ -255,7 +275,7 @@ private native void nativeSetSchemaConfig(long nativePtr, byte schemaMode, long
     private static native void nativeEnableChangeNotification(long nativePtr, boolean enableNotification);
 
     private static native void nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
-                                                            String authUrl, String userId, String refreshToken);
+                                                            String authUrl, String userId, String refreshToken, byte sessionStopPolicy);
 
     private static native void nativeSetSyncConfigSslSettings(long nativePtr,
                                                               boolean validateSsl, String trustCertificatePath);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 67c16c24b9..88ace3a27b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -134,7 +134,17 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public OsList getLinkList(long columnIndex) {
+    public OsList getList(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public OsList getModelList(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
         throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Property.java b/realm/realm-library/src/main/java/io/realm/internal/Property.java
index 4cb755f768..03a1026223 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Property.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Property.java
@@ -21,6 +21,14 @@
 
 import io.realm.RealmFieldType;
 
+import static io.realm.RealmFieldType.BINARY_LIST;
+import static io.realm.RealmFieldType.BOOLEAN_LIST;
+import static io.realm.RealmFieldType.DATE_LIST;
+import static io.realm.RealmFieldType.DOUBLE_LIST;
+import static io.realm.RealmFieldType.FLOAT_LIST;
+import static io.realm.RealmFieldType.INTEGER_LIST;
+import static io.realm.RealmFieldType.STRING_LIST;
+
 
 /**
  * Class for handling properties/fields.
@@ -64,7 +72,6 @@
     }
 
     Property(String name, RealmFieldType type, String linkedClassName) {
-        // Ignore the isRequired when creating the linking property.
         this(nativeCreatePersistedLinkProperty(name, convertFromRealmFieldType(type, false), linkedClassName));
     }
 
@@ -110,6 +117,28 @@ private static int convertFromRealmFieldType(RealmFieldType fieldType, boolean i
             case DOUBLE:
                 type = TYPE_DOUBLE;
                 break;
+            case INTEGER_LIST:
+                //noinspection PointlessBitwiseExpression
+                type = TYPE_INT | TYPE_ARRAY;
+                break;
+            case BOOLEAN_LIST:
+                type = TYPE_BOOL | TYPE_ARRAY;
+                break;
+            case STRING_LIST:
+                type = TYPE_STRING | TYPE_ARRAY;
+                break;
+            case BINARY_LIST:
+                type = TYPE_DATA | TYPE_ARRAY;
+                break;
+            case DATE_LIST:
+                type = TYPE_DATE | TYPE_ARRAY;
+                break;
+            case FLOAT_LIST:
+                type = TYPE_FLOAT | TYPE_ARRAY;
+                break;
+            case DOUBLE_LIST:
+                type = TYPE_DOUBLE | TYPE_ARRAY;
+                break;
             default:
                 throw new IllegalArgumentException(
                         String.format(Locale.US, "Unsupported filed type: '%s'.", fieldType.name()));
@@ -142,6 +171,21 @@ private static RealmFieldType convertToRealmFieldType(int propertyType) {
                 return RealmFieldType.FLOAT;
             case TYPE_DOUBLE:
                 return RealmFieldType.DOUBLE;
+            //noinspection PointlessBitwiseExpression
+            case TYPE_INT | TYPE_ARRAY:
+                return INTEGER_LIST;
+            case TYPE_BOOL | TYPE_ARRAY:
+                return BOOLEAN_LIST;
+            case TYPE_STRING | TYPE_ARRAY:
+                return STRING_LIST;
+            case TYPE_DATA | TYPE_ARRAY:
+                return BINARY_LIST;
+            case TYPE_DATE | TYPE_ARRAY:
+                return DATE_LIST;
+            case TYPE_FLOAT | TYPE_ARRAY:
+                return FLOAT_LIST;
+            case TYPE_DOUBLE | TYPE_ARRAY:
+                return DOUBLE_LIST;
             default:
                 throw new IllegalArgumentException(
                         String.format(Locale.US, "Unsupported property type: '%d'", propertyType));
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index 655ef6d224..f1a556f057 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -81,7 +81,12 @@
 
     boolean isNullLink(long columnIndex);
 
-    OsList getLinkList(long columnIndex);
+    // FIXME remove this in DynamicRealm PR
+    OsList getList(long columnIndex);
+
+    OsList getModelList(long columnIndex);
+
+    OsList getValueList(long columnIndex, RealmFieldType fieldType);
 
     void setLong(long columnIndex, long value);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index d17c236ee2..5c98952c7d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -173,7 +173,17 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public OsList getLinkList(long columnIndex) {
+    public OsList getList(long columnIndex) {
+        return new OsList(this, columnIndex);
+    }
+
+    @Override
+    public OsList getModelList(long columnIndex) {
+        return new OsList(this, columnIndex);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
         return new OsList(this, columnIndex);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 36fa70e5b8..8b72dd0c12 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -145,7 +145,7 @@ public void run() {
     }
 
     @Override
-    public <E extends RealmModel> Flowable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
+    public <E> Flowable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
         return Flowable.create(new FlowableOnSubscribe<RealmResults<E>>() {
             @Override
@@ -182,7 +182,7 @@ public void run() {
     }
 
     @Override
-    public <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, final RealmResults<E> results) {
+    public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
         return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<E>>>() {
             @Override
@@ -218,18 +218,18 @@ public void run() {
     }
 
     @Override
-    public Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+    public <E> Flowable<RealmResults<E>> from(DynamicRealm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Flowable.create(new FlowableOnSubscribe<RealmResults<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmResults<E>>() {
             @Override
-            public void subscribe(final FlowableEmitter<RealmResults<DynamicRealmObject>> emitter) throws Exception {
+            public void subscribe(final FlowableEmitter<RealmResults<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
-                final RealmChangeListener<RealmResults<DynamicRealmObject>> listener = new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
+                final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange(RealmResults<DynamicRealmObject> results) {
+                    public void onChange(RealmResults<E> results) {
                         if (!emitter.isCancelled()) {
                             emitter.onNext(results);
                         }
@@ -255,18 +255,18 @@ public void run() {
     }
 
     @Override
-        public Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+    public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<E>>>() {
             @Override
-            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<DynamicRealmObject>>> emitter) throws Exception {
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<E>>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
-                final OrderedRealmCollectionChangeListener<RealmResults<DynamicRealmObject>> listener = new OrderedRealmCollectionChangeListener<RealmResults<DynamicRealmObject>>() {
+                final OrderedRealmCollectionChangeListener<RealmResults<E>> listener = new OrderedRealmCollectionChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange(RealmResults<DynamicRealmObject> results, OrderedCollectionChangeSet changeSet) {
+                    public void onChange(RealmResults<E> results, OrderedCollectionChangeSet changeSet) {
                         if (!emitter.isDisposed()) {
                             emitter.onNext(new CollectionChange<>(results, changeSet));
                         }
@@ -291,7 +291,7 @@ public void run() {
     }
 
     @Override
-    public <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
+    public <E> Flowable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
         return Flowable.create(new FlowableOnSubscribe<RealmList<E>>() {
             @Override
@@ -328,7 +328,7 @@ public void run() {
     }
 
     @Override
-    public <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, final RealmList<E> list) {
+    public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
         return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<E>>>() {
             @Override
@@ -364,18 +364,18 @@ public void run() {
     }
 
     @Override
-    public Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+    public <E> Flowable<RealmList<E>> from(DynamicRealm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Flowable.create(new FlowableOnSubscribe<RealmList<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmList<E>>() {
             @Override
-            public void subscribe(final FlowableEmitter<RealmList<DynamicRealmObject>> emitter) throws Exception {
+            public void subscribe(final FlowableEmitter<RealmList<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
-                final RealmChangeListener<RealmList<DynamicRealmObject>> listener = new RealmChangeListener<RealmList<DynamicRealmObject>>() {
+                final RealmChangeListener<RealmList<E>> listener = new RealmChangeListener<RealmList<E>>() {
                     @Override
-                    public void onChange(RealmList<DynamicRealmObject> results) {
+                    public void onChange(RealmList<E> results) {
                         if (!emitter.isCancelled()) {
                             emitter.onNext(list);
                         }
@@ -401,18 +401,18 @@ public void run() {
     }
 
     @Override
-    public Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+    public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<DynamicRealmObject>>>() {
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<E>>>() {
             @Override
-            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<DynamicRealmObject>>> emitter) throws Exception {
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<E>>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
-                final OrderedRealmCollectionChangeListener<RealmList<DynamicRealmObject>> listener = new OrderedRealmCollectionChangeListener<RealmList<DynamicRealmObject>>() {
+                final OrderedRealmCollectionChangeListener<RealmList<E>> listener = new OrderedRealmCollectionChangeListener<RealmList<E>>() {
                     @Override
-                    public void onChange(RealmList<DynamicRealmObject> results, OrderedCollectionChangeSet changeSet) {
+                    public void onChange(RealmList<E> results, OrderedCollectionChangeSet changeSet) {
                         if (!emitter.isDisposed()) {
                             emitter.onNext(new CollectionChange<>(results, changeSet));
                         }
@@ -583,12 +583,12 @@ public void run() {
     }
 
     @Override
-    public <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+    public <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
     @Override
-    public Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+    public <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
index 04af747f38..e5784f42ac 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
@@ -67,7 +67,7 @@
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates to the RealmObject.
      */
-    <E extends RealmModel> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
+    <E> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
@@ -82,7 +82,7 @@
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates + their changeset.
      */
-    <E extends RealmModel> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results);
+    <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results);
 
     /**
      * Creates a Flowable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
@@ -94,7 +94,7 @@
      * @param realm {@link DynamicRealm} instance results are coming from.
      * @return Rx observable that emit all updates to the RealmResults.
      */
-    Flowable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+    <E> Flowable<RealmResults<E>> from(DynamicRealm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
@@ -108,7 +108,7 @@
      * @param realm {@link Realm} instance results are coming from.
      * @return Rx observable that emit all updates + their changeset.
      */
-    Observable<CollectionChange<RealmResults<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+    <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
@@ -120,9 +120,9 @@
      *
      * @param list RealmObject to listen to changes for.
      * @param realm {@link Realm} instance list is coming from.
-     * @param <E> type of RealmObject
+     * @param <E> type of query target
      */
-    <E extends RealmModel> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list);
+    <E> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
@@ -137,7 +137,7 @@
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates + their changeset.
      */
-    <E extends RealmModel> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list);
+    <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list);
 
     /**
      * Creates a Flowable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
@@ -150,7 +150,7 @@
      * @param list RealmList to listen to changes for.
      * @param realm {@link DynamicRealm} instance list is coming from.
      */
-    Flowable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+    <E> Flowable<RealmList<E>> from(DynamicRealm realm, RealmList<E> list);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
@@ -164,7 +164,7 @@
      * @param realm {@link Realm} instance list is coming from.
      * @return Rx observable that emit all updates + their changeset.
      */
-    Observable<CollectionChange<RealmList<DynamicRealmObject>>> changesetsFrom(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+    <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, RealmList<E> list);
 
     /**
      * Creates a Flowable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
@@ -174,7 +174,7 @@
      *
      * @param object RealmObject to listen to changes for.
      * @param realm {@link Realm} instance object is coming from.
-     * @param <E> type of RealmObject
+     * @param <E> type of query target
      */
     <E extends RealmModel> Flowable<E> from(Realm realm, E object);
 
@@ -223,9 +223,9 @@
      *
      * @param query RealmQuery to emit.
      * @param realm {@link Realm} instance query is coming from.
-     * @param <E> type of RealmObject
+     * @param <E> type of query target
      */
-    <E extends RealmModel> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
+    <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
 
     /**
      * Creates a Single from a {@link RealmQuery}. It should emit the query and then complete.
@@ -235,5 +235,5 @@
      * @param query RealmObject to listen to changes for.
      * @param realm {@link DynamicRealm} instance query is coming from.
      */
-    Single<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query);
+    <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 2b69a760a0..88b0d9dc25 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -88,6 +88,7 @@
     @Nullable
     private final String serverCertificateFilePath;
     private final boolean waitForInitialData;
+    private final OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy;
 
     private SyncConfiguration(File directory,
                                 String filename,
@@ -116,7 +117,8 @@ private SyncConfiguration(File directory,
                                 String serverCertificateAssetName,
                                 @Nullable
                                 String serverCertificateFilePath,
-                                boolean waitForInitialData
+                                boolean waitForInitialData,
+                                OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy
     ) {
         super(directory,
                 filename,
@@ -143,6 +145,7 @@ private SyncConfiguration(File directory,
         this.serverCertificateAssetName = serverCertificateAssetName;
         this.serverCertificateFilePath = serverCertificateFilePath;
         this.waitForInitialData = waitForInitialData;
+        this.sessionStopPolicy = sessionStopPolicy;
     }
 
     /**
@@ -345,6 +348,17 @@ boolean isSyncConfiguration() {
         return true;
     }
 
+    /**
+     * NOTE: Only for internal usage. May change without warning.
+     *
+     * Returns the stop policy for the session for this Realm once the Realm has been closed.
+     *
+     * @return the stop policy used by the session once the Realm is closed.
+     */
+    public OsRealmConfig.SyncSessionStopPolicy getSessionStopPolicy() {
+        return sessionStopPolicy;
+    }
+
     /**
      * Builder used to construct instances of a SyncConfiguration in a fluent manner.
      */
@@ -379,7 +393,7 @@ boolean isSyncConfiguration() {
         private String serverCertificateAssetName;
         @Nullable
         private String serverCertificateFilePath;
-
+        private OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy = OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED;
         /**
          * Creates an instance of the Builder for the SyncConfiguration.
          * <p>
@@ -613,6 +627,18 @@ public Builder encryptionKey(byte[] key) {
             return this;
         }
 
+        /**
+         * DEBUG method. This makes it possible to define different policies for when a session should be stopped when
+         * the Realm is closed.
+         *
+         * @param policy how a session for a Realm should behave when the Realm is closed.
+         */
+        SyncConfiguration.Builder sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy policy) {
+            sessionStopPolicy = policy;
+            return this;
+        }
+
+
         /**
          * Sets the schema version of the Realm.
          * <p>
@@ -937,7 +963,8 @@ public SyncConfiguration build() {
                     syncClientValidateSsl,
                     serverCertificateAssetName,
                     serverCertificateFilePath,
-                    waitForServerChanges
+                    waitForServerChanges,
+                    sessionStopPolicy
             );
         }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 4de59a8788..f4c3d4d9df 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -92,9 +92,10 @@ public void realmClosed(RealmConfiguration configuration) {
             String rosUserIdentity = user.getIdentity();
             String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
             String rosSerializedUser = user.toJson();
-            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath()};
+            byte sessionStopPolicy = syncConfig.getSessionStopPolicy().getNativeValue();
+            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath(), sessionStopPolicy};
         } else {
-            return new Object[6];
+            return new Object[7];
         }
     }
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
index 65542f0925..fa0406c914 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -32,7 +32,6 @@
 import io.realm.objectserver.utils.HttpUtils;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 
 /**
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
index 08888b9941..8d16609bee 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -18,7 +18,6 @@
 
 import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
-import android.text.style.TabStopSpan;
 
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -34,7 +33,6 @@
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
similarity index 98%
rename from realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
rename to realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index b260e71ccb..0c6f778b30 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -1,4 +1,4 @@
-package io.realm.objectserver;
+package io.realm;
 
 import android.os.Handler;
 import android.os.HandlerThread;
@@ -16,22 +16,12 @@
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 
-import io.realm.Realm;
-import io.realm.RealmChangeListener;
-import io.realm.RealmResults;
-import io.realm.StandardIntegrationTest;
-import io.realm.SyncConfiguration;
-import io.realm.SyncCredentials;
-import io.realm.SyncManager;
-import io.realm.SyncSession;
-import io.realm.SyncUser;
-import io.realm.TestHelper;
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
+import io.realm.internal.OsRealmConfig;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
-import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
 import static org.junit.Assert.assertEquals;
@@ -327,6 +317,7 @@ public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
 
         final SyncConfiguration syncConfiguration = configFactory
                 .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED)
                 .modules(new StringOnlyModule())
                 .build();
         Realm realm = Realm.getInstance(syncConfiguration);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
index e1943ae61c..307c46660a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -43,7 +43,7 @@
 import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
-import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.TestSyncConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
index 85c69b9236..fef9b158bd 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
@@ -27,7 +27,7 @@
 import io.realm.objectserver.ManagementRealmTests;
 import io.realm.objectserver.ProcessCommitTests;
 import io.realm.objectserver.ProgressListenerTests;
-import io.realm.objectserver.SyncSessionTests;
+import io.realm.SyncSessionTests;
 
 // Test suite includes all integration tests. Makes it easy to run all integration tests in the Android Studio.
 @RunWith(Suite.class)
