diff --git a/CHANGELOG.md b/CHANGELOG.md
index a695fc6407..7b5246a1e0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -2,6 +2,8 @@
 
 ### Enhancements
 
+* [ObjectServer] Added `SyncSession.uploadAllLocalChanges()`.
+
 ### Bug Fixes
 
 ### Internal
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 9ee2ba5d0e..42d6918d5c 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -35,6 +35,8 @@ ext.coreDir = file(project.coreSourcePath ?
         "${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
 ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
 ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
+// Set to true to enable linking with debug core.
+ext.enableDebugCore = project.hasProperty('enableDebugCore') ? project.getProperty('enableDebugCore') : false
 
 android {
     compileSdkVersion 25
@@ -54,7 +56,8 @@ android {
                         // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
                         // JNI build currently (lack of lto linking support).
                         // This file should be removed and use the one from Android SDK cmake package when it supports lto.
-                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
+                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}",
+                        "-DENABLE_DEBUG_CORE=$project.enableDebugCore"
                 if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
                 if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
                 if (project.hasProperty('buildTargetABIs') && !project.getProperty('buildTargetABIs').trim().isEmpty()) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index f30d459da5..45b4219113 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -803,10 +803,9 @@ public void utf8Tests() {
                 o.setColumnLong(i);
                 o.setColumnString(codePoint);
 
-                AllTypes realmType = realm.where(AllTypes.class).equalTo("columnLong", i).findFirst();
                 if (i > 1) {
                     assertEquals("Codepoint: " + i + " / " + currentUnicode, codePoint,
-                            realmType.getColumnString()); // codepoint 0 is NULL, ignore for now.
+                            o.getColumnString()); // codepoint 0 is NULL, ignore for now.
                 }
                 i++;
             }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index acf65b49ac..853d888d33 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Before;
@@ -23,6 +25,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestSyncConfigurationFactory;
@@ -47,6 +51,9 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
     @Before
     public void setUp() {
         user = createTestUser();
@@ -182,4 +189,30 @@ public void onError(SyncSession session, ObjectServerError error) {
         // Trigger error
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
+
+    @Test
+    @UiThreadTest
+    public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {
+        SyncUser user = createTestUser();
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getSession(configuration).uploadAllLocalChanges();
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    @UiThreadTest
+    public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {
+        SyncUser user = createTestUser();
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getSession(configuration).downloadAllServerChanges();
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index e49a13e89b..d88f3f8295 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -151,8 +151,11 @@ public void session() throws IOException {
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
                 .build();
         // This will trigger the creation of the session
-        Realm.getInstance(config);
+        Realm realm = Realm.getInstance(config);
         SyncSession session = SyncManager.getSession(config);
         assertEquals(user, session.getUser()); // see also SessionTests
+
+        realm.close();
+        SyncManager.reset();
     }
 }
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 3d7e3159a5..b2bd687dd8 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -62,23 +62,25 @@ create_javah(TARGET jni_headers
     DEPENDS ${classes_PATH}
 )
 
-# TODO: Ideally the debug build should link with core's debug build. But core dbg lib has
-# some compile options problems with arm, especially with macro REALM_DEBUG. Link to core
-# dbg for debug build when that gets solved.
-# We always link to the non-dbg version of core libs for now.
-# This means only JNI part has debugging symbols with debug build.
-# Debugging with core source code will also be done though anther approach -- compiling the core
-# with cmake inside android project.
+# Link to core/sync debug lib for debug build if it is debug build and linking with debug core is enabled.
+# FIXME: Ideally we should linking to debug core on CI for testing, but the assertions slow down the CI a lot.
+if (CMAKE_BUILD_TYPE STREQUAL "Debug" AND ${ENABLE_DEBUG_CORE})
+    set(debug_lib_SUFFIX "-dbg")
+    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DREALM_DEBUG")
+else()
+    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DNDEBUG")
+endif()
+
 # Configure import realm core lib
-set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-${ANDROID_ABI}.a)
+set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-${ANDROID_ABI}${debug_lib_SUFFIX}.a)
 # Workaround for old core's funny ABI nicknames
 if (NOT EXISTS ${core_lib_PATH})
     if (ARMEABI)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm.a)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm${debug_lib_SUFFIX}.a)
     elseif (ARMEABI_V7A)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm-v7a.a)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm-v7a${debug_lib_SUFFIX}.a)
     elseif (ARM64_V8A)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm64.a)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm64${debug_lib_SUFFIX}.a)
     else()
         message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
     endif()
@@ -93,15 +95,15 @@ set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PAT
 
 if (build_SYNC)
     # Sync static library
-    set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
+    set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}${debug_lib_SUFFIX}.a)
     # Workaround for old core's funny ABI nicknames
     if (NOT EXISTS ${sync_lib_PATH})
         if (ARMEABI)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm${debug_lib_SUFFIX}.a)
         elseif (ARMEABI_V7A)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a${debug_lib_SUFFIX}.a)
         elseif (ARM64_V8A)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
+            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64${debug_lib_SUFFIX}.a)
         else()
             message(FATAL_ERROR "Cannot find sync lib file: ${sync_lib_PATH}")
         endif()
@@ -151,7 +153,7 @@ endif()
 # And this issue doesn't seem to impact the core compiling.
 set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")
 #-ggdb doesn't play well with -flto
-set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
+set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -ggdb -Og")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
 
 # Set link flags
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 5dde2c61e5..4acc008018 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -146,7 +146,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadComple
 
         if (session) {
             static JavaClass java_sync_session_class(env, "io/realm/SyncSession");
-            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesDownloaded",
+            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesSent",
                                                         "(Ljava/lang/Long;Ljava/lang/String;)V");
             JavaGlobalRef java_session_object_ref(env, session_object);
 
@@ -170,8 +170,43 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadComple
     return JNI_FALSE;
 }
 
-JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jclass,
-                                                                 jstring j_local_realm_path)
+JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForUploadCompletion(JNIEnv* env,
+                                                                                     jobject session_object,
+                                                                                     jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            static JavaClass java_sync_session_class(env, "io/realm/SyncSession");
+            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesSent",
+                                                        "(Ljava/lang/Long;Ljava/lang/String;)V");
+            JavaGlobalRef java_session_object_ref(env, session_object);
+
+            bool listener_registered =
+                session->wait_for_upload_completion([java_session_object_ref](std::error_code error) {
+                    JNIEnv* env = JniUtils::get_env(true);
+                    JavaLocalRef<jobject> java_error_code;
+                    JavaLocalRef<jstring> java_error_message;
+                    if (error != std::error_code{}) {
+                        java_error_code = JavaLocalRef<jobject>(env, NewLong(env, error.value()));
+                        java_error_message = JavaLocalRef<jstring>(env, env->NewStringUTF(error.message().c_str()));
+                    }
+                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method,
+                                        java_error_code.get(), java_error_message.get());
+                });
+
+            return to_jbool(listener_registered);
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+
+JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jclass, jstring j_local_realm_path)
 {
     TR_ENTER()
     try {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index a0fed2a44b..0e65fcae3c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -23,7 +23,7 @@
  */
 public enum ErrorCode {
 
-    // See https://github.com/realm/realm-sync/blob/master/doc/protocol_17.md
+    // See https://github.com/realm/realm-sync/blob/master/doc/protocol.md
     // See https://github.com/realm/realm-object-server/blob/master/object-server/doc/problems.md
 
     // Realm Java errors (0-49)
@@ -44,6 +44,13 @@
     REUSE_OF_SESSION_IDENT(107),     // Overlapping reuse of session identifier (BIND)
     BOUND_IN_OTHER_SESSION(108),     // Client file bound in other session (IDENT)
     BAD_MESSAGE_ORDER(109),          // Bad input message order
+    BAD_ORIGIN_FILE_IDENT(110),      // Bad origin file identifier in changeset header (DOWNLOAD)
+    BAD_SERVER_VERSION_DOWNLOAD(111),// Bad server version in changeset header (DOWNLOAD)
+    BAD_CHANGESET_DOWNLOAD(112),     // Bad changeset (DOWNLOAD)
+    BAD_REQUEST_IDENT(113),          // Bad request identifier (MARK)
+    BAD_ERROR_CODE(114),             // Bad error code (ERROR)
+    BAD_COMPRESSION(115),            // Bad compression (DOWNLOAD)
+    BAD_CLIENT_VERSION_DOWNLOAD(116),// Bad last integrated client version in changeset header (DOWNLOAD)
 
     // Session level errors (200 - 299)
     SESSION_CLOSED(200, Category.RECOVERABLE),      // Session closed (no error)
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index 2a0438ff01..a6c774090e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -71,7 +71,7 @@
     private RealmAsyncTask refreshTokenNetworkRequest;
     private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
     private volatile boolean isClosed = false;
-    private final AtomicReference<WaitForServerChangesWrapper> waitingForServerChanges = new AtomicReference<>(null);
+    private final AtomicReference<WaitForSessionWrapper> waitingForServerChanges = new AtomicReference<>(null);
     private final Object waitForChangesMutex = new Object();
 
     // We need JavaId -> Listener so C++ can trigger callbacks without keeping a reference to the
@@ -294,14 +294,16 @@ void close() {
         clearScheduledAccessTokenRefresh();
     }
 
-    // This method will be called once all changes have been downloaded.
-    // This method might be called on another thread than the one that called `downloadAllServerChanges`.
+    // This method will be called once all changes have been downloaded or uploaded.
+    // This method might be called on another thread than the one that called `downloadAllServerChanges` or
+    // `uploadAllLocalChanges()`
+    //
     // Be very careful with synchronized blocks.
     // If the native listener was successfully registered, Object Store guarantees that this method will be called at
     // least once, even if the session is closed.
     @SuppressWarnings("unused")
-    private void notifyAllChangesDownloaded(Long errorcode, String errorMessage) {
-        WaitForServerChangesWrapper wrapper = waitingForServerChanges.get();
+    private void notifyAllChangesSent(Long errorcode, String errorMessage) {
+        WaitForSessionWrapper wrapper = waitingForServerChanges.get();
         if (wrapper != null) {
             wrapper.handleResult(errorcode, errorMessage);
         }
@@ -328,26 +330,74 @@ public void downloadAllServerChanges() throws InterruptedException {
         // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
         // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
         synchronized (waitForChangesMutex) {
-            if (!isClosed) {
-                WaitForServerChangesWrapper wrapper = new WaitForServerChangesWrapper();
-                waitingForServerChanges.set(wrapper);
-                boolean listenerRegistered = nativeWaitForDownloadCompletion(configuration.getPath());
-                if (!listenerRegistered) {
-                    waitingForServerChanges.set(null);
-                    throw new ObjectServerError(ErrorCode.UNKNOWN, "It was not possible to download all changes. Has the SyncClient been started?");
+            waitForChanges(DIRECTION_DOWNLOAD);
+        }
+    }
+
+    /**
+     * Calling this method will block until all known local changes have been uploaded to the server.
+     * This will involve network access, so calling this method should only be done from a non-UI thread.
+     * <p>
+     * If the device is offline, this method might never return.
+     * <p>
+     * This method cannot be called before the session has been started.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the thread was interrupted while downloading was in progress.
+     */
+    public void uploadAllLocalChanges() throws InterruptedException {
+        checkIfNotOnMainThread("uploadAllLocalChanges() cannot be called from the main thread.");
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            waitForChanges(DIRECTION_UPLOAD);
+        }
+    }
+
+    /**
+     * This method should only be called when guarded by the {@link #waitForChangesMutex}.
+     * It will block into all changes have been either uploaded or downloaded depending on the chosen direction.
+     *
+     * @param direction either {@link #DIRECTION_DOWNLOAD} or {@link #DIRECTION_UPLOAD}
+     */
+    private void waitForChanges(int direction) throws InterruptedException {
+        if (direction != DIRECTION_DOWNLOAD && direction != DIRECTION_UPLOAD) {
+            throw new IllegalArgumentException("Unknown direction: " + direction);
+        }
+        if (!isClosed) {
+            WaitForSessionWrapper wrapper = new WaitForSessionWrapper();
+            waitingForServerChanges.set(wrapper);
+            boolean listenerRegistered = (direction == DIRECTION_DOWNLOAD)
+                    ? nativeWaitForDownloadCompletion(configuration.getPath())
+                    : nativeWaitForUploadCompletion(configuration.getPath());
+            if (!listenerRegistered) {
+                waitingForServerChanges.set(null);
+                String errorMsg = "";
+                switch (direction) {
+                    case DIRECTION_DOWNLOAD: errorMsg = "It was not possible to download all remote changes."; break;
+                    case DIRECTION_UPLOAD: errorMsg = "It was not possible upload all local changes."; break;
+                    default:
+                        throw new IllegalArgumentException("Unknown direction: " + direction);
                 }
-                wrapper.waitForServerChanges();
 
-                // This might return after the session was closed. In that case, just ignore any result
-                try {
-                    if (!isClosed) {
-                        if (!wrapper.isSuccess()) {
-                            wrapper.throwExceptionIfNeeded();
-                        }
+                throw new ObjectServerError(ErrorCode.UNKNOWN, errorMsg + " Has the SyncClient been started?");
+            }
+            wrapper.waitForServerChanges();
+
+            // This might return after the session was closed. In that case, just ignore any result
+            try {
+                if (!isClosed) {
+                    if (!wrapper.isSuccess()) {
+                        wrapper.throwExceptionIfNeeded();
                     }
-                } finally {
-                    waitingForServerChanges.set(null);
                 }
+            } finally {
+                waitingForServerChanges.set(null);
             }
         }
     }
@@ -596,10 +646,11 @@ private void clearScheduledAccessTokenRefresh() {
         }
     }
 
-    // Wrapper class for handling the async operations of the underlying SyncSession calling `async_wait_for_download_completion`
-    private static class WaitForServerChangesWrapper {
+    // Wrapper class for handling the async operations of the underlying SyncSession calling
+    // `async_wait_for_download_completion` or `async_wait_for_upload_completion`
+    private static class WaitForSessionWrapper {
 
-        private final CountDownLatch waitForChanges = new CountDownLatch(1);
+        private final CountDownLatch waiter = new CountDownLatch(1);
         private volatile boolean resultReceived = false;
         private Long errorCode = null;
         private String errorMessage;
@@ -609,12 +660,12 @@ private void clearScheduledAccessTokenRefresh() {
          */
         public void waitForServerChanges() throws InterruptedException {
             if (!resultReceived) {
-                waitForChanges.await();
+                waiter.await();
             }
         }
 
         /**
-         * Process the result of a waiting action. This will also unblock anyone who called {@link #waitForChanges}.
+         * Process the result of a waiting action. This will also unblock anyone who called {@link #waiter}.
          *
          * @param errorCode error code if an error occurred, {@code null} if changes were successfully downloaded.
          * @param errorMessage error message (if any).
@@ -623,7 +674,7 @@ public void handleResult(Long errorCode, String errorMessage) {
             this.errorCode = errorCode;
             this.errorMessage = errorMessage;
             this.resultReceived = true;
-            waitForChanges.countDown();
+            waiter.countDown();
         }
 
         public boolean isSuccess() {
@@ -646,5 +697,6 @@ public void throwExceptionIfNeeded() {
     private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
     private static native boolean nativeRefreshAccessToken(String localRealmPath, String accessToken, String realmUrl);
     private native boolean nativeWaitForDownloadCompletion(String localRealmPath);
+    private native boolean nativeWaitForUploadCompletion(String localRealmPath);
     private static native byte nativeGetState(String localRealmPath);
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
index be5da797a7..8b79a0776a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -67,7 +67,7 @@ public void waitForInitialRemoteData_mainThreadThrows() {
     }
 
     @Test
-    public void waitForInitialRemoteData() {
+    public void waitForInitialRemoteData() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
@@ -85,7 +85,7 @@ public void execute(Realm realm) {
                 }
             }
         });
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(10));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
         user.logout();
         Realm.deleteRealm(configOld);
@@ -181,7 +181,7 @@ public void onError(Throwable exception) {
     }
 
     @Test
-    public void waitForInitialRemoteData_readOnlyTrue() {
+    public void waitForInitialRemoteData_readOnlyTrue() throws InterruptedException {
         String username = UUID.randomUUID().toString();
         String password = "password";
         SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
@@ -199,7 +199,7 @@ public void execute(Realm realm) {
                 }
             }
         });
-        SystemClock.sleep(TimeUnit.SECONDS.toMillis(10));  // FIXME: Replace with Sync Progress Notifications once available.
+        SyncManager.getSession(configOld).uploadAllLocalChanges();
         realm.close();
         user.logout();
         Realm.deleteRealm(configOld);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
index 695fd03989..a46591ca58 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/SyncSessionTests.java
@@ -1,6 +1,7 @@
 package io.realm.objectserver;
 
 import android.os.SystemClock;
+import android.support.test.annotation.UiThreadTest;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Rule;
@@ -15,6 +16,7 @@
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
+import io.realm.entities.AllTypes;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestSyncConfigurationFactory;
@@ -79,4 +81,29 @@ public void getState_closedRealm() {
         } catch (IllegalStateException expected) {
         }
     }
+
+    @Test
+    public void uploadDownloadAllChanges() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncConfiguration userConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        SyncConfiguration adminConfig = configFactory
+                .createSyncConfigurationBuilder(adminUser, userConfig.getServerUrl().toString())
+                .build();
+
+        Realm userRealm = Realm.getInstance(userConfig);
+        userRealm.beginTransaction();
+        userRealm.createObject(AllTypes.class);
+        userRealm.commitTransaction();
+        SyncManager.getSession(userConfig).uploadAllLocalChanges();
+        userRealm.close();
+
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        SyncManager.getSession(adminConfig).downloadAllServerChanges();
+        adminRealm.refresh();
+        assertEquals(1, adminRealm.where(AllTypes.class).count());
+        adminRealm.close();
+    }
 }
