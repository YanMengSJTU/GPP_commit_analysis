diff --git a/README.md b/README.md
index b0be5811ec..481f049743 100644
--- a/README.md
+++ b/README.md
@@ -36,15 +36,15 @@ Prerequisites:
 
 Once you have completed all the pre-requisites building Realm is done with a simple command
 
-    ./gradlew assemble
+    ./gradlew androidJar
     
     
-That command will generate the .aar file and annotation processor jar for Realm. You will find them in realm/build/outputs/aar and realm-annotations-processor/build/libs, respectively.
+That command will generate the .jar file containing the Realm runtime and the annotation processor. You will find it in realm/build/libs.
 
 ### Other Commands
 
- * `./gradlew generatereleaseJavadoc` will generate the Javadocs
- * `./gradlew connectedCheck` will run the tests on a connected Android device
+ * `./gradlew generateReleaseJavadoc` will generate the Javadocs
+ * `./gradlew realm:connectedCheck` will run the tests on a connected Android device
 
 Generating the Javadoc using the command above will report a failure (1 error, 30+ warnings). The Javadoc is generated, and we will fix 
 `realm/build.gradle` in the near future.
@@ -71,7 +71,7 @@ See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 ## License
 
 Realm Java is published under the Apache 2.0 license.  
-The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/cocoa/latest/#faq).
+The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](http://realm.io/docs/java/#faq).
 
 ## Feedback
 
diff --git a/build-distribution.sh b/build-distribution.sh
index 0fb4362a43..e731e46c22 100755
--- a/build-distribution.sh
+++ b/build-distribution.sh
@@ -7,46 +7,25 @@ version=$(cat version.txt)
 echo "Cleaning the distribution folder"
 git clean -xfd distribution
 
-echo "Building the annotation processor"
-(
-    cd realm-annotations-processor
-    ./gradlew assemble
-)
-
 echo "Building Realm"
-./gradlew realm:assemble
-
-echo "Building the Javadocs"
-./gradlew realm:javadocReleaseJar
+./gradlew realm:androidJar realm:javadocReleaseJar
 
 echo "Copying files to the distribution folder"
-sed -i.bak "s/CHANGEME/${version}/g" distribution/realm/build.gradle
-rm -f distribution/realm/build.gradle.bak
 cp -f changelog.txt distribution
-cp realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar distribution
-cp realm/build/outputs/aar/realm-${version}.aar distribution/realm
+cp realm/build/libs/realm-${version}.jar distribution
 cp -R realm/build/docs/javadoc distribution
 cp realm/build/libs/realm-${version}-javadoc.jar distribution
 
 echo "Copying files to the distribution/RealmIntroExample folder"
 cp -R examples/introExample/src distribution/RealmIntroExample/app
-mkdir -p distribution/RealmIntroExample/app/libs
-cp realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar distribution/RealmIntroExample/app/libs
-mkdir -p distribution/RealmIntroExample/realm
-cp -R distribution/realm distribution/RealmIntroExample
 
 echo "Copying files to the distribution/RealmGridViewExample folder"
 cp -R examples/gridViewExample/src distribution/RealmGridViewExample/app
-mkdir -p distribution/RealmGridViewExample/app/libs
-cp realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar distribution/RealmGridViewExample/app/libs
-mkdir -p distribution/RealmGridViewExample/realm
-cp -R distribution/realm distribution/RealmGridViewExample
 
 echo "Copying files to the distribution/RealmMigrationExample folder"
 cp -R examples/migrationExample/src distribution/RealmMigrationExample/app
-mkdir -p distribution/RealmMigrationExample/app/libs
-cp realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar distribution/RealmMigrationExample/app/libs
-mkdir -p distribution/RealmMigrationExample/realm
-cp -R distribution/realm distribution/RealmMigrationExample
+
+echo "Copying files to the distribution/RealmConcurrencyExample folder"
+cp -R examples/concurrencyExample/src distribution/RealmConcurrencyExample/app
 
 echo  "Done"
diff --git a/build.gradle b/build.gradle
index 12c1c1f156..e4b66f446f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,11 +1,12 @@
 buildscript {
     repositories {
-        mavenCentral()
+        jcenter()
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:0.12.2'
         classpath 'de.undercouch:gradle-download-task:1.0'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:0.5' // Version 0.6 seems to require gradle 2.0+
     }
 }
 
@@ -14,6 +15,6 @@ allprojects {
   version = new File('version.txt').text
 
   repositories {
-    mavenCentral()
+    jcenter()
   }
 }
diff --git a/changelog.txt b/changelog.txt
index 3fefa3e824..79f593a325 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,5 +1,19 @@
-0.70.2 ()
-  * Adding RealmQuery.count method
+0.72.0 (??)
+  * Extending sorting to more types: boolean, short, int, long, float, double, Date, and String fields are now supported
+  * Better support for Java 7 and 8 in the annotations processor
+
+0.71.0 (07 Oct 2014)
+  * Simplified the release artifact to a single Jar file
+  * Added support for Eclipse
+  * Added support for deploying to Maven
+  * Throw exception if nested write transactions are used (it's not allowed)
+  * Javadoc updated
+  * Fixed bug in RealmResults: https://github.com/realm/realm-java/issues/453
+  * New annotation @Index to add search index to a field (currently only supporting String fields) 
+  * Made the annotations processor more verbose and strict
+  * Adding RealmQuery.count() method
+  * Added a new example about concurrency
+  * Upgrading to core 0.84.0
 
 0.70.1 (30 Sep 2014)
   * Enable unit testing for the realm project
diff --git a/distribution/README.txt b/distribution/README.txt
index 23960d0a70..cefc8531f1 100644
--- a/distribution/README.txt
+++ b/distribution/README.txt
@@ -11,8 +11,8 @@ Examples
 Included in this distribution are a couple of examples.
 You can try them out from Android Studio through "File->Import Project" and selecting the
 build.gradle file in the respective example. Then click "Run".
-But more importantly check out the source code in RealmIntroExample/app/src which will give examples
-for how to use the API.
+But more importantly check out the source code in RealmIntroExample/app/src
+which will provide examples for how to use the API.
 
 Feedback
 --------
diff --git a/distribution/RealmConcurrencyExample/.gitignore b/distribution/RealmConcurrencyExample/.gitignore
new file mode 100644
index 0000000000..afbdab33e9
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/.gitignore
@@ -0,0 +1,6 @@
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
diff --git a/distribution/RealmConcurrencyExample/app/.gitignore b/distribution/RealmConcurrencyExample/app/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/app/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/distribution/RealmConcurrencyExample/app/build.gradle b/distribution/RealmConcurrencyExample/app/build.gradle
new file mode 100644
index 0000000000..5ef986842a
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/app/build.gradle
@@ -0,0 +1,24 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 20
+    buildToolsVersion "20.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.concurrency"
+        minSdkVersion 14
+        targetSdkVersion 20
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile 'io.realm:realm-android:0.71.0'
+}
diff --git a/distribution/RealmConcurrencyExample/app/proguard-rules.pro b/distribution/RealmConcurrencyExample/app/proguard-rules.pro
new file mode 100644
index 0000000000..bb65c6fe88
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/app/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/distribution/RealmConcurrencyExample/build.gradle b/distribution/RealmConcurrencyExample/build.gradle
new file mode 100644
index 0000000000..9b8abe4fe1
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.12.2'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
diff --git a/distribution/RealmConcurrencyExample/gradle.properties b/distribution/RealmConcurrencyExample/gradle.properties
new file mode 100644
index 0000000000..5d08ba75bb
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/gradle.properties
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..1e61d1fd3a
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip
diff --git a/distribution/RealmConcurrencyExample/gradlew b/distribution/RealmConcurrencyExample/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmConcurrencyExample/gradlew.bat b/distribution/RealmConcurrencyExample/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/distribution/RealmConcurrencyExample/realm_version_check.timestamp b/distribution/RealmConcurrencyExample/realm_version_check.timestamp
new file mode 100644
index 0000000000..8bd051a4dd
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/realm_version_check.timestamp
@@ -0,0 +1 @@
+1412087116619
diff --git a/distribution/RealmConcurrencyExample/settings.gradle b/distribution/RealmConcurrencyExample/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/distribution/RealmConcurrencyExample/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/distribution/RealmGridViewExample/app/build.gradle b/distribution/RealmGridViewExample/app/build.gradle
index 99e173e3f6..62cd826dac 100644
--- a/distribution/RealmGridViewExample/app/build.gradle
+++ b/distribution/RealmGridViewExample/app/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 20
@@ -21,7 +20,6 @@ android {
 }
 
 dependencies {
-    apt fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'io.realm:realm-android:0.71.0'
     compile 'com.google.code.gson:gson:2.3'
-    compile project(':realm')
 }
diff --git a/distribution/RealmGridViewExample/build.gradle b/distribution/RealmGridViewExample/build.gradle
index 9dd1852556..0f587fbcfd 100644
--- a/distribution/RealmGridViewExample/build.gradle
+++ b/distribution/RealmGridViewExample/build.gradle
@@ -6,7 +6,6 @@ buildscript {
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:0.12.2'
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.3'
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
     }
diff --git a/distribution/RealmGridViewExample/settings.gradle b/distribution/RealmGridViewExample/settings.gradle
index 3a4f504d53..9d495b34f8 100644
--- a/distribution/RealmGridViewExample/settings.gradle
+++ b/distribution/RealmGridViewExample/settings.gradle
@@ -1,2 +1 @@
-include ':app'
-include ':realm'
\ No newline at end of file
+include ':app'
\ No newline at end of file
diff --git a/distribution/RealmIntroExample/app/build.gradle b/distribution/RealmIntroExample/app/build.gradle
index 7837ced415..74fe45cf38 100644
--- a/distribution/RealmIntroExample/app/build.gradle
+++ b/distribution/RealmIntroExample/app/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 20
@@ -21,6 +20,5 @@ android {
 }
 
 dependencies {
-    apt fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':realm')
+    compile 'io.realm:realm-android:0.71.0'
 }
\ No newline at end of file
diff --git a/distribution/RealmIntroExample/build.gradle b/distribution/RealmIntroExample/build.gradle
index 38421024ec..9b8abe4fe1 100644
--- a/distribution/RealmIntroExample/build.gradle
+++ b/distribution/RealmIntroExample/build.gradle
@@ -6,7 +6,6 @@ buildscript {
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:0.12.2'
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.3'
 
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
diff --git a/distribution/RealmIntroExample/settings.gradle b/distribution/RealmIntroExample/settings.gradle
index 2077877d06..e7b4def49c 100644
--- a/distribution/RealmIntroExample/settings.gradle
+++ b/distribution/RealmIntroExample/settings.gradle
@@ -1,2 +1 @@
 include ':app'
-include ':realm'
diff --git a/distribution/RealmMigrationExample/app/build.gradle b/distribution/RealmMigrationExample/app/build.gradle
index 7e1688f850..d46896f831 100644
--- a/distribution/RealmMigrationExample/app/build.gradle
+++ b/distribution/RealmMigrationExample/app/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 20
@@ -21,6 +20,5 @@ android {
 }
 
 dependencies {
-    apt fileTree(dir: 'libs', include: ['*.jar'])
-    compile project(':realm')
+    compile 'io.realm:realm-android:0.71.0'
 }
\ No newline at end of file
diff --git a/distribution/RealmMigrationExample/settings.gradle b/distribution/RealmMigrationExample/settings.gradle
index 2077877d06..e7b4def49c 100644
--- a/distribution/RealmMigrationExample/settings.gradle
+++ b/distribution/RealmMigrationExample/settings.gradle
@@ -1,2 +1 @@
 include ':app'
-include ':realm'
diff --git a/distribution/realm/build.gradle b/distribution/realm/build.gradle
deleted file mode 100644
index afb6d235fe..0000000000
--- a/distribution/realm/build.gradle
+++ /dev/null
@@ -1,2 +0,0 @@
-configurations.create("default")
-artifacts.add("default", file("realm-CHANGEME.aar"))
\ No newline at end of file
diff --git a/distribution/realm/src/main/AndroidManifest.xml b/distribution/realm/src/main/AndroidManifest.xml
deleted file mode 100644
index 8deea15631..0000000000
--- a/distribution/realm/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm" >
-    <application android:allowBackup="true"/>
-</manifest>
\ No newline at end of file
diff --git a/examples/concurrencyExample/build.gradle b/examples/concurrencyExample/build.gradle
new file mode 100644
index 0000000000..418a4279a2
--- /dev/null
+++ b/examples/concurrencyExample/build.gradle
@@ -0,0 +1,28 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+
+    defaultConfig {
+        applicationId "io.realm.examples.concurrency"
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            runProguard false
+            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile files("../../realm/build/libs/realm-${version}.jar")
+}
diff --git a/examples/concurrencyExample/proguard-rules.pro b/examples/concurrencyExample/proguard-rules.pro
new file mode 100644
index 0000000000..200fdffd58
--- /dev/null
+++ b/examples/concurrencyExample/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/examples/concurrencyExample/src/main/AndroidManifest.xml b/examples/concurrencyExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..be2982ac29
--- /dev/null
+++ b/examples/concurrencyExample/src/main/AndroidManifest.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.concurrency">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity
+            android:name=".RealmExampleActivity"
+            android:configChanges="keyboardHidden|orientation|screenSize"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+        <service
+            android:name=".services.SpawningService"
+            android:configChanges="keyboardHidden|orientation|screenSize"
+            android:enabled="true"
+            android:exported="false"
+            android:label="Realm Service" />
+
+        <service
+            android:name=".services.TransactionService"
+            android:configChanges="keyboardHidden|orientation|screenSize"
+            android:enabled="true"
+            android:exported="false"
+            android:label="Realm Service" />
+    </application>
+
+</manifest>
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
new file mode 100644
index 0000000000..224eaa0ca6
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.RadioGroup;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.RealmList;
+import io.realm.examples.concurrency.model.Cat;
+import io.realm.examples.concurrency.model.Dog;
+import io.realm.examples.concurrency.model.Person;
+import io.realm.examples.concurrency.services.SpawningService;
+import io.realm.examples.concurrency.services.TransactionService;
+
+public class RealmExampleActivity extends Activity implements View.OnClickListener {
+
+    @SuppressWarnings("UnusedDeclaration")
+    public static final String TAG = RealmExampleActivity.class.getName();
+
+    private Realm realm = null;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_realm_example);
+
+        findViewById(R.id.insert_record_button).setOnClickListener(this);
+        findViewById(R.id.quit_button).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                stopTransactionTests();
+            }
+        });
+
+        // Reset the realm data before starting the tests
+        Realm.deleteRealmFile(this);
+
+        // Acquire a realm object
+        realm = Realm.getInstance(this);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+	//Alternatively can use transaction tests here...
+        //startTransactionTests();
+
+        startSpawnTests();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+	//Alternatively can use transaction tests here...
+        //stopTransactionTests();
+
+        stopSpawnTests();
+    }
+
+    // Using the screen form the user can inject into the Realm
+    // even if other threads are creating transactions.
+    @Override
+    public void onClick(View v) {
+        String personName = ((TextView) findViewById(R.id.name)).getText().toString();
+        String personAge = ((TextView) findViewById(R.id.age)).getText().toString();
+        String petName = ((TextView) findViewById(R.id.pets_name)).getText().toString();
+
+        Integer parseAge = 0;
+        try {
+            parseAge = Integer.parseInt(personAge);
+        } catch (NumberFormatException ignored) {
+	        Log.d(TAG, "Age for a person invalid");
+	        return;
+        }
+
+        realm.beginTransaction();
+        Person person = realm.createObject(Person.class);
+        person.setName(personName);
+        person.setAge(parseAge);
+
+        int checkedId = ((RadioGroup) findViewById(R.id.petType)).getCheckedRadioButtonId();
+        if (checkedId == R.id.hasCat) {
+            Cat cat = realm.createObject(Cat.class);
+            cat.setName(petName);
+            RealmList<Cat> cats = person.getCats();
+            cats.add(cat);
+        } else if (checkedId == R.id.hasDog) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setName(petName);
+            person.setDog(dog);
+        }
+
+        realm.commitTransaction();
+
+    }
+
+    // The transaction tests are one IntentService running multiple Writes
+    // to a Realm in either a multiple transaction or single transaction loop
+    private void startTransactionTests() {
+        Intent serviceIntent = new Intent(this, TransactionService.class);
+        serviceIntent.putExtra(TransactionService.REALM_TESTTYPE_EXTRA,
+                TransactionService.TestType.MANY_TRANSACTIONS);
+        serviceIntent.putExtra(TransactionService.ITERATION_COUNT, 10000000);
+        this.startService(serviceIntent);
+    }
+
+    private void stopTransactionTests() {
+        Intent serviceIntent = new Intent(this, TransactionService.class);
+        this.stopService(serviceIntent);
+    }
+
+    // The Spawned tests create multiple threads of type Reader or Writer
+    // which loop for a specified count
+    private void startSpawnTests() {
+        Intent serviceIntent = new Intent(this, SpawningService.class);
+        serviceIntent.putExtra(SpawningService.REALM_INSERTCOUNT_EXTRA, 10000000);
+        serviceIntent.putExtra(SpawningService.REALM_READCOUNT_EXTRA, 10000000);
+        this.startService(serviceIntent);
+    }
+
+    private void stopSpawnTests() {
+        Intent serviceIntent = new Intent(this, SpawningService.class);
+        this.stopService(serviceIntent);
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    private void restartTests() {
+        stopTransactionTests();
+        startTransactionTests();
+    }
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
new file mode 100644
index 0000000000..d69f67b8ab
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.model;
+
+import io.realm.RealmObject;
+
+public class Cat extends RealmObject {
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
new file mode 100644
index 0000000000..b96bf70803
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.model;
+
+import io.realm.RealmObject;
+
+public class Dog extends RealmObject {
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
new file mode 100644
index 0000000000..406ae5d5c9
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.model;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class Person extends RealmObject {
+
+    private String name;
+    private int age;
+
+    private Dog dog;
+    private RealmList<Cat> cats;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public int getAge() {
+        return age;
+    }
+
+    public void setAge(int age) {
+        this.age = age;
+    }
+
+    public Dog getDog() {
+        return dog;
+    }
+
+    public void setDog(Dog dog) {
+        this.dog = dog;
+    }
+
+    public RealmList<Cat> getCats() {
+        return cats;
+    }
+
+    public void setCats(RealmList<Cat> cats) {
+        this.cats = cats;
+    }
+
+}
\ No newline at end of file
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java
new file mode 100644
index 0000000000..8d502ce5d3
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/SpawningService.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.services;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.examples.concurrency.threads.KillableThread;
+import io.realm.examples.concurrency.threads.RealmReader;
+import io.realm.examples.concurrency.threads.RealmWriter;
+
+public class SpawningService extends Service {
+
+    public static final String TAG = SpawningService.class.getName();
+
+    public static final String REALM_INSERTCOUNT_EXTRA = "RealmInsertCountExtra";
+    public static final String REALM_READCOUNT_EXTRA   = "RealmReadCountExtra";
+
+    private List<KillableThread> allThreads = null;
+
+    public void onCreate() {
+        super.onCreate();
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+
+        int insertCount = intent.getIntExtra(REALM_INSERTCOUNT_EXTRA, 0);
+        int readCount   = intent.getIntExtra(REALM_READCOUNT_EXTRA, 0);
+
+        try {
+            allThreads = new ArrayList<KillableThread>();
+            RealmWriter wT = new RealmWriter(this);
+            wT.setInsertCount(insertCount);
+            allThreads.add(wT);
+            wT.start();
+            RealmReader rT = new RealmReader(this);
+            rT.setReadCount(readCount);
+            allThreads.add(rT);
+            rT.start();
+        } catch (Exception e) {
+            e.printStackTrace();
+            quit();
+        }
+
+        //Service should stay active as long as Activity is active
+        return START_STICKY;
+    }
+
+    @Override
+    public void onDestroy() {
+        quit();
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    private void quit() {
+        for (KillableThread t : allThreads) {
+            t.terminate();
+        }
+    }
+
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java
new file mode 100644
index 0000000000..bca153d4f8
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/services/TransactionService.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.services;
+
+import android.app.IntentService;
+import android.content.Intent;
+import android.util.Log;
+
+import io.realm.Realm;
+import io.realm.examples.concurrency.model.Person;
+
+// Note that an IntentService operates in its own threadpool facilitated by Android
+public class TransactionService extends IntentService {
+
+    public static final String TAG = TransactionService.class.getName();
+
+    private Boolean mQuitting = false;
+
+    private int mInsertCount = 0;
+
+    public static final String REALM_TESTTYPE_EXTRA = "TestTypeExtra";
+    public static final String ITERATION_COUNT      = "TestIterationCount";
+
+    public enum TestType {
+        MANY_INSERTS_ONE_TRANSACTION,
+        MANY_TRANSACTIONS
+    }
+
+    private Realm realm = null;
+
+    public TransactionService() {
+        super(SpawningService.class.getName());
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        Log.d(TAG, TAG + " is starting");
+
+        realm = Realm.getInstance(this);
+
+        TestType type = (TestType)intent.getSerializableExtra(REALM_TESTTYPE_EXTRA);
+        mInsertCount = intent.getIntExtra(ITERATION_COUNT, 0);
+
+        switch(type) {
+            case MANY_INSERTS_ONE_TRANSACTION:
+                doSingleTransaction();
+                break;
+            case MANY_TRANSACTIONS:
+                doSeveralTransactions();
+                break;
+            default:
+        }
+
+        Log.d(TAG, TAG + " has quit");
+    }
+
+    @Override
+    public void onDestroy() {
+        this.mQuitting = true;
+    }
+
+    // This method creates mInsertCount injections into the Realm
+    // inside >>ONE transaction<<
+    private void doSingleTransaction() {
+        int iterCount = 0;
+
+        // NOTE:  If you attempt to make writes from the UI while this loop is running
+        // it will block because of the write transaction being open.
+        realm.beginTransaction();
+        while (iterCount < mInsertCount && !mQuitting) {
+            if ((iterCount % 1000) == 0) {
+                Log.d(TAG, "WriteOperation#: " + iterCount + "," + Thread.currentThread().getName());
+            }
+
+            Person person = realm.createObject(Person.class);
+            person.setName("Foo" + iterCount);
+            iterCount++;
+        }
+        realm.commitTransaction();
+    }
+
+    // This method creates mInsertCount injections into the Realm
+    // using >>one transaction for EACH insert<<
+    private void doSeveralTransactions() {
+        int iterCount = 0;
+
+        while (iterCount < mInsertCount && !mQuitting) {
+            if ((iterCount % 1000) == 0) {
+                Log.d(TAG, "WriteOperation#: " + iterCount + "," + Thread.currentThread().getName());
+            }
+            realm.beginTransaction();
+            Person person = realm.createObject(Person.class);
+            person.setName("Foo" + iterCount);
+            iterCount++;
+            realm.commitTransaction();
+        }
+    }
+
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/KillableThread.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/KillableThread.java
new file mode 100644
index 0000000000..a2b7fb43ef
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/KillableThread.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.threads;
+
+public interface KillableThread {
+
+    public void terminate();
+
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java
new file mode 100644
index 0000000000..9f7e738d05
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmReader.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.threads;
+
+import android.content.Context;
+import android.util.Log;
+
+import io.realm.Realm;
+import io.realm.examples.concurrency.model.Person;
+
+public class RealmReader extends Thread implements KillableThread {
+
+    public static final String TAG = RealmReader.class.getName();
+
+    private Context context = null;
+
+    private boolean mRunning = true;
+
+    private int mReadCount = 0;
+
+    public RealmReader(Context context) {
+        this.context = context;
+    }
+
+    public void run() {
+        Realm realm = Realm.getInstance(context);
+
+        int loopCount = 0;
+
+        while (loopCount < mReadCount && mRunning) {
+            Person person = realm.where(Person.class)
+                    .beginsWith("name", "Foo")
+                    .between("age", 20, 50).findFirst();
+
+            if (loopCount % 1000 == 0) {
+                Log.d(TAG, "Found: " + person);
+            }
+            loopCount++;
+        }
+    }
+
+    @Override
+    public void terminate() {
+        mRunning = false;
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    public int getReadCount() {
+        return mReadCount;
+    }
+
+    public void setReadCount(int mReadCount) {
+        this.mReadCount = mReadCount;
+    }
+}
diff --git a/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java
new file mode 100644
index 0000000000..53d7113a6a
--- /dev/null
+++ b/examples/concurrencyExample/src/main/java/io/realm/examples/concurrency/threads/RealmWriter.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.concurrency.threads;
+
+import android.content.Context;
+import android.util.Log;
+
+import io.realm.Realm;
+import io.realm.examples.concurrency.model.Dog;
+import io.realm.examples.concurrency.model.Person;
+
+public class RealmWriter extends Thread implements KillableThread {
+
+    public static final String TAG = RealmWriter.class.getName();
+
+    private Context context = null;
+
+    private boolean mRunning = true;
+
+    private int mInsertCount = 0;
+
+    public RealmWriter(Context context) {
+        this.context = context;
+    }
+
+    public void run() {
+        Realm realm = Realm.getInstance(context);
+
+        int iterCount = 0;
+
+        while (iterCount < mInsertCount && mRunning) {
+            realm.beginTransaction();
+
+            Person person = realm.createObject(Person.class);
+            person.setName("Foo" + iterCount);
+            person.setAge(iterCount % 20 + (50 - 20));
+
+            //Add a dog to every 50th person
+            if (iterCount % 50 == 0) {
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName("Foo" + iterCount + "Fido");
+                person.setDog(dog);
+            }
+
+            iterCount++;
+            realm.commitTransaction();
+
+            if ((iterCount % 1000) == 0) {
+                Log.d(TAG, "WriteOperation#: " + iterCount + "," + Thread.currentThread().getName());
+            }
+        }
+    }
+
+    @Override
+    public void terminate() {
+        mRunning = false;
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    public int getInsertCount() {
+        return mInsertCount;
+    }
+
+    public void setInsertCount(int count) {
+        this.mInsertCount = count;
+    }
+}
diff --git a/examples/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png b/examples/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..96a442e5b8
Binary files /dev/null and b/examples/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/examples/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png b/examples/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..359047dfa4
Binary files /dev/null and b/examples/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/examples/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png b/examples/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..71c6d760f0
Binary files /dev/null and b/examples/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/examples/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..4df1894644
Binary files /dev/null and b/examples/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/concurrencyExample/src/main/res/layout/activity_realm_example.xml b/examples/concurrencyExample/src/main/res/layout/activity_realm_example.xml
new file mode 100644
index 0000000000..aac15a8ebd
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/layout/activity_realm_example.xml
@@ -0,0 +1,112 @@
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="#ff797979"
+    android:orientation="vertical"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/update_message"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_margin="25dp"
+            android:gravity="center"
+            android:text="In the background there is a loop creating records."
+            android:textSize="24sp" />
+
+        <Button
+            android:id="@+id/quit_button"
+            android:text="Stop Background Loop"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" />
+
+        <View
+            android:layout_width="match_parent"
+            android:layout_height="1dp"
+            android:layout_margin="12dp"
+            android:background="#ffcfcfcf" />
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:background="#ff1144aa"
+            android:orientation="vertical"
+            android:padding="20dp">
+
+            <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_margin="7dp"
+                android:gravity="center"
+                android:text="You can also create records manually..."
+                android:textSize="22sp" />
+
+            <TextView
+                android:id="@+id/message_timestamp"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:gravity="center_horizontal"
+                android:text="Create a Record:"
+                android:textColor="#ffafafaf"
+                android:textSize="22sp" />
+
+            <View
+                android:layout_width="match_parent"
+                android:layout_height="1dp"
+                android:layout_margin="12dp"
+                android:background="#ffcfcfcf" />
+
+            <EditText
+                android:id="@+id/name"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Enter Person's Name" />
+
+            <EditText
+                android:id="@+id/age"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Enter Person's Age" />
+
+            <RadioGroup
+                android:id="@+id/petType"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content">
+
+                <RadioButton
+                    android:id="@+id/hasCat"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Cat" />
+
+                <RadioButton
+                    android:id="@+id/hasDog"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="Dog" />
+            </RadioGroup>
+
+            <EditText
+                android:id="@+id/pets_name"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Enter Pets Name" />
+
+            <Button
+                android:id="@+id/insert_record_button"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="Create Record" />
+
+        </LinearLayout>
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/concurrencyExample/src/main/res/menu/options_menu.xml b/examples/concurrencyExample/src/main/res/menu/options_menu.xml
new file mode 100644
index 0000000000..14c91e5706
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/menu/options_menu.xml
@@ -0,0 +1,9 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context=".RealmGridLayoutActivity">
+    <item
+        android:id="@+id/action_reload"
+        android:orderInCategory="100"
+        android:showAsAction="never"
+        android:title="@string/action_reset" />
+</menu>
diff --git a/examples/concurrencyExample/src/main/res/values-w820dp/dimens.xml b/examples/concurrencyExample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/examples/concurrencyExample/src/main/res/values/dimens.xml b/examples/concurrencyExample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/concurrencyExample/src/main/res/values/strings.xml b/examples/concurrencyExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..4bd17c1af8
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/values/strings.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Realm Example</string>
+    <string name="action_reset">Restart</string>
+
+</resources>
diff --git a/examples/concurrencyExample/src/main/res/values/styles.xml b/examples/concurrencyExample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ff6c9d2c0f
--- /dev/null
+++ b/examples/concurrencyExample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 8fa074b762..c0ec5ad567 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -1,14 +1,4 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 19
@@ -31,16 +21,10 @@ android {
     }
 }
 
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
 tasks.preBuild {
-    dependsOn buildApt
+    dependsOn ":realm:androidJar"
 }
 
 dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    compile project(':realm')
+    compile files("../../realm/build/libs/realm-${version}.jar")
 }
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index fc6a1e1177..9ed8237b33 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -1,14 +1,4 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 19
@@ -30,17 +20,11 @@ android {
     }
 }
 
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
 tasks.preBuild {
-    dependsOn buildApt
+    dependsOn ":realm:androidJar"
 }
 
 dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
     compile 'com.google.code.gson:gson:2.3'
-    compile project(':realm')
+    compile files("../../realm/build/libs/realm-${version}.jar")
 }
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index 8460630f57..0a5f840f47 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,14 +1,4 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 19
@@ -30,16 +20,10 @@ android {
     }
 }
 
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
 tasks.preBuild {
-    dependsOn buildApt
+    dependsOn ":realm:androidJar"
 }
 
 dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    compile project(':realm')
+    compile files("../../realm/build/libs/realm-${version}.jar")
 }
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index 051bedebe5..33dcc2f177 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -1,14 +1,4 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
 apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
 
 android {
     compileSdkVersion 19
@@ -29,16 +19,10 @@ android {
     }
 }
 
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
 tasks.preBuild {
-    dependsOn buildApt
+    dependsOn ":realm:androidJar"
 }
 
 dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    compile project(':realm')
+    compile files("../../realm/build/libs/realm-${version}.jar")
 }
diff --git a/realm-annotations-processor/build.gradle b/realm-annotations-processor/build.gradle
index ec37d36493..62307f5bfa 100644
--- a/realm-annotations-processor/build.gradle
+++ b/realm-annotations-processor/build.gradle
@@ -1,6 +1,8 @@
 apply plugin: 'java'
 
 version = new File("${projectDir}/../version.txt").text
+sourceCompatibility = '1.6'
+targetCompatibility = '1.6'
 
 repositories {
     mavenCentral()
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 9246f8c525..020bdf8205 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -17,12 +17,13 @@
 package io.realm.processor;
 
 import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
 import io.realm.annotations.RealmClass;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.*;
 import javax.tools.Diagnostic;
 import java.io.IOException;
@@ -32,12 +33,15 @@
 import java.util.Set;
 
 
-@SupportedAnnotationTypes({"io.realm.annotations.RealmClass", "io.realm.annotations.Ignore"})
-@SupportedSourceVersion(javax.lang.model.SourceVersion.RELEASE_6)
+@SupportedAnnotationTypes({"io.realm.annotations.RealmClass", "io.realm.annotations.Ignore", "io.realm.annotations.Index"})
 public class RealmProcessor extends AbstractProcessor {
     Set<String> classesToValidate = new HashSet<String>();
     boolean done = false;
 
+    @Override public SourceVersion getSupportedSourceVersion() {
+        return SourceVersion.latestSupported();
+    }
+
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
         RealmVersionChecker updateChecker = new RealmVersionChecker(processingEnv);
@@ -47,11 +51,14 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             String className;
             String packageName;
             List<VariableElement> fields = new ArrayList<VariableElement>();
+            List<VariableElement> indexedFields = new ArrayList<VariableElement>();
+            List<String> ignoredFields = new ArrayList<String>();
+            List<String> expectedGetters = new ArrayList<String>();
+            List<String> expectedSetters = new ArrayList<String>();
 
             // Check the annotation was applied to a Class
             if (!classElement.getKind().equals(ElementKind.CLASS)) {
-                error("The RealmClass annotation can only be applied to classes");
-                return true;
+                error("The RealmClass annotation can only be applied to classes", classElement);
             }
             TypeElement typeElement = (TypeElement) classElement;
             className = typeElement.getSimpleName().toString();
@@ -60,49 +67,112 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 continue;
             }
 
+            note("Processing class " + className);
+
             classesToValidate.add(typeElement.toString());
 
             // Get the package of the class
             Element enclosingElement = typeElement.getEnclosingElement();
             if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
-                error("The RealmClass annotation does not support nested classes");
-                return true;
+                error("The RealmClass annotation does not support nested classes", classElement);
             }
 
             TypeElement parentElement = (TypeElement) processingEnv.getTypeUtils().asElement(typeElement.getSuperclass());
             if (!parentElement.toString().endsWith(".RealmObject")) {
-                error("A RealmClass annotated object must be derived from RealmObject");
-                return true;
+                error("A RealmClass annotated object must be derived from RealmObject", classElement);
             }
 
             PackageElement packageElement = (PackageElement) enclosingElement;
             packageName = packageElement.getQualifiedName().toString();
 
             for (Element element : typeElement.getEnclosedElements()) {
-                if (element.getKind().equals(ElementKind.FIELD)) {
+                ElementKind elementKind = element.getKind();
+                if (elementKind.equals(ElementKind.FIELD)) {
                     VariableElement variableElement = (VariableElement) element;
+                    String fieldName = variableElement.getSimpleName().toString();
                     if (variableElement.getAnnotation(Ignore.class) != null) {
                         // The field has the @Ignore annotation. No need to go any further.
+                        ignoredFields.add(fieldName);
                         continue;
                     }
 
+                    if (variableElement.getAnnotation(Index.class) != null) {
+                        // The field has the @Index annotation. It's only valid for:
+                        // * String
+                        String elementTypeCanonicalName = variableElement.asType().toString();
+                        if (elementTypeCanonicalName.equals("java.lang.String")) {
+                            indexedFields.add(variableElement);
+                        } else {
+                            error("@Index is only appliable to String fields - got " + element);
+                            return true;
+                        }
+                    }
+
                     if (!variableElement.getModifiers().contains(Modifier.PRIVATE)) {
-                        error("The fields of the model must be private");
-                        return true;
+                        error("The fields of the model must be private", variableElement);
                     }
 
                     fields.add(variableElement);
+                    expectedGetters.add(fieldName);
+                    expectedSetters.add(fieldName);
+                } else if (elementKind.equals(ElementKind.METHOD)) {
+                    ExecutableElement executableElement = (ExecutableElement) element;
+
+                    if (!executableElement.getModifiers().contains(Modifier.PUBLIC)) {
+                        error("The methods of the model must be public", executableElement);
+                    }
+
+                    String methodName = executableElement.getSimpleName().toString();
+                    String computedFieldName = methodName.startsWith("is")?lowerFirstChar(methodName.substring(2)):lowerFirstChar(methodName.substring(3));
+                    if (methodName.startsWith("get") || methodName.startsWith("is")) {
+                        boolean found = false;
+                        for (VariableElement field : fields) {
+                            if (field.getSimpleName().toString().equals(computedFieldName)) {
+                                found = true;
+                            }
+                        }
+                        if (ignoredFields.contains(computedFieldName)) {
+                            found = true;
+                        }
+                        if (!found) {
+                            error(String.format("No field named %s for the getter %s", computedFieldName, methodName), executableElement);
+                        }
+                        expectedGetters.remove(computedFieldName);
+                    } else if (methodName.startsWith("set")) {
+                        boolean found = false;
+                        for (VariableElement field : fields) {
+                            if (field.getSimpleName().toString().equals(computedFieldName)) {
+                                found = true;
+                            }
+                        }
+                        if (ignoredFields.contains(computedFieldName)) {
+                            found = true;
+                        }
+                        if (!found) {
+                            error(String.format("No field named %s for the setter %s", computedFieldName, methodName), executableElement);
+                        }
+                        expectedSetters.remove(computedFieldName);
+                    } else {
+                        error("Only getters and setters should be defined in model classes", executableElement);
+                    }
                 }
             }
 
+            for (String expectedGetter : expectedGetters) {
+                error("No getter found for field " + expectedGetter);
+            }
+            for (String expectedSetter : expectedSetters) {
+                error("No setter found for field " + expectedSetter);
+            }
+
             RealmProxyClassGenerator sourceCodeGenerator =
-                    new RealmProxyClassGenerator(processingEnv, className, packageName, fields);
+                    new RealmProxyClassGenerator(processingEnv, className, packageName, fields, indexedFields);
             try {
                 sourceCodeGenerator.generate();
             } catch (IOException e) {
-                error(e.getMessage());
+                error(e.getMessage(), classElement);
             } catch (UnsupportedOperationException e) {
-                error(e.getMessage());
+                error(e.getMessage(), classElement);
             }
         }
 
@@ -119,7 +189,19 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         return true;
     }
 
+    private static String lowerFirstChar(String input) {
+        return input.substring(0, 1).toLowerCase() + input.substring(1);
+    }
+
+    private void error(String message, Element element) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
+    }
+
     private void error(String message) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
     }
+
+    private void note(String message) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
+    }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 23b920a0b0..0e15569362 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -36,15 +36,17 @@
     private String className;
     private String packageName;
     private List<VariableElement> fields;
+    private List<VariableElement> fieldsToIndex;
     private static final String REALM_PACKAGE_NAME = "io.realm";
     private static final String TABLE_PREFIX = "class_";
     private static final String PROXY_SUFFIX = "RealmProxy";
 
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, String className, String packageName, List<VariableElement> fields) {
+    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, String className, String packageName, List<VariableElement> fields, List<VariableElement> fieldsToIndex) {
         this.processingEnvironment = processingEnvironment;
         this.className = className;
         this.packageName = packageName;
         this.fields = fields;
+        this.fieldsToIndex = fieldsToIndex;
     }
 
     private static final Map<String, String> JAVA_TO_REALM_TYPES;
@@ -375,6 +377,12 @@ public void generate() throws IOException, UnsupportedOperationException {
                         fieldName, TABLE_PREFIX, genericType);
             }
         }
+
+        for (VariableElement field : fieldsToIndex) {
+            String fieldName = field.getSimpleName().toString();
+            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
+        }
+
         writer.emitStatement("return table");
         writer.endControlFlow();
         writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
index 918246e52c..0cbdfb0c1b 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmVersionChecker.java
@@ -29,7 +29,7 @@
     public static final String REALM_ANDROID_DOWNLOAD_URL = "http://static.realm.io/downloads/java/latest";
 
     private static final String VERSION_URL = "http://static.realm.io/update/java?";
-    private static final String REALM_VERSION = "0.70.1"; //TODO: The version value should be pulled from a build file
+    private static final String REALM_VERSION = "0.72.0"; //TODO: The version value should be pulled from a build file
     private static final int READ_TIMEOUT = 2000;
     private static final int CONNECT_TIMEOUT = 4000;
 
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index e6fa0611e2..e6d7d5345c 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -1,4 +1,4 @@
-ext.coreVersion = '0.83.1'
+ext.coreVersion = '0.84.0'
 
 buildscript {
     repositories {
@@ -44,6 +44,24 @@ task downloadCore(group: 'build setup', description: 'Download the latest versio
             from tarTree(new File(buildDir, "core-android-${project.coreVersion}.tar.gz"))
             into "../core-${project.coreVersion}"
         }
+        for (target in ['arm', 'arm-v7a', 'mips', 'x86']) {
+            exec {
+                commandLine = [
+                        'make',
+                        '-C', "${projectDir}/src",
+                        "BASE_DENOM=${target}",
+                        'LIB_SUFFIX_SHARED=.so',
+                        'clean'
+                ]
+            }
+        }
+        exec {
+            commandLine = [
+                    'rm',
+                    '-rf',
+                    "${projectDir}/build/*"
+            ]
+        }
     }
 }
 
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm-jni/src/io_realm_internal_SharedGroup.cpp
index 6da1941aea..da9127a878 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -151,21 +151,30 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-  (JNIEnv *, jobject, jlong native_ptr, jlong native_tansact_log_registry_ptr)
+  (JNIEnv *env, jobject, jlong native_ptr, jlong native_tansact_log_registry_ptr)
 {
-    LangBindHelper::advance_read( *SG(native_ptr), *reinterpret_cast<LangBindHelper::TransactLogRegistry*>(native_tansact_log_registry_ptr) );
+    try {
+        LangBindHelper::advance_read( *SG(native_ptr), *reinterpret_cast<LangBindHelper::TransactLogRegistry*>(native_tansact_log_registry_ptr) );
+    }
+    CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *, jobject, jlong native_ptr, jlong native_tansact_log_registry_ptr)
+  (JNIEnv *env, jobject, jlong native_ptr, jlong native_tansact_log_registry_ptr)
 {
-    LangBindHelper::promote_to_write( *SG(native_ptr), *reinterpret_cast<LangBindHelper::TransactLogRegistry*>(native_tansact_log_registry_ptr) );
+    try {
+        LangBindHelper::promote_to_write( *SG(native_ptr), *reinterpret_cast<LangBindHelper::TransactLogRegistry*>(native_tansact_log_registry_ptr) );
+    }
+    CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
-  (JNIEnv *, jobject, jlong native_ptr)
+  (JNIEnv *env, jobject, jlong native_ptr)
 {
-    LangBindHelper::commit_and_continue_as_read( *SG(native_ptr) );
+    try {
+        LangBindHelper::commit_and_continue_as_read( *SG(native_ptr) );
+    }
+    CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseTransactRegistryLog
diff --git a/realm-jni/src/io_realm_internal_table.cpp b/realm-jni/src/io_realm_internal_table.cpp
index cc385f1d92..80a0ad5224 100644
--- a/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm-jni/src/io_realm_internal_table.cpp
@@ -736,7 +736,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetIndex(
         return;
     }
     try {
-        pTable->set_index( S(columnIndex));
+        pTable->add_search_index( S(columnIndex));
     } CATCH_STD()
 }
 
@@ -746,7 +746,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasIndex(
     if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
         return false;
     try {
-        return TBL(nativeTablePtr)->has_index( S(columnIndex));
+        return TBL(nativeTablePtr)->has_search_index( S(columnIndex));
     } CATCH_STD()
     return false;
 }
@@ -985,21 +985,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountString(
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLookup(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jstring value)
-{
-    // Must have a string column as first column
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), 0, type_String))
-        return 0;
-
-    try {
-        JStringAccessor value2(env, value); // throws
-        return to_jlong_or_not_found( TBL(nativeTablePtr)->lookup(value2) );
-    } CATCH_STD()
-    return 0;
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
     JNIEnv *env, jobject, jlong nativeTablePtr)
 {
@@ -1199,7 +1184,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
         return 0;
-    if (!pTable->has_index(S(columnIndex))) {
+    if (!pTable->has_search_index(S(columnIndex))) {
         ThrowException(env, UnsupportedOperation, "The column must be indexed before distinct() can be used.");
         return 0;
     }
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm-jni/src/io_realm_internal_tableview.cpp
index 4c9b97bb63..e633cae281 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm-jni/src/io_realm_internal_tableview.cpp
@@ -926,13 +926,21 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
         return;
 
     int colType = TV(nativeViewPtr)->get_column_type( S(columnIndex) );
-    if (colType != type_Int && colType != type_Bool && colType != type_DateTime) {
-        ThrowException(env, IllegalArgument, "Sort is currently only supported on Integer, Boolean and Date columns.");
-        return;
+    switch (colType) {
+        case type_Bool:
+        case type_Int:
+        case type_DateTime:
+        case type_Float:
+        case type_Double:
+        case type_String:
+            try {
+                TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
+            } CATCH_STD()
+            break;
+        default:
+            ThrowException(env, IllegalArgument, "Sort is currently only supported on Integer, Float, Double, Boolean, Date, and String columns.");
+          return;
     }
-    try {
-        TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
-    } CATCH_STD()
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
@@ -999,7 +1007,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
 
     try {
         TableView* tv = TV(nativeViewPtr);
-        Query query = tv->get_parent().where().tableview(*tv);
+        Query query = tv->get_parent().where(tv);
         TableQuery* queryPtr = new TableQuery(query);
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
diff --git a/realm/build.gradle b/realm/build.gradle
index d4abfc893e..974787ed81 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,5 +1,7 @@
 apply plugin: 'com.android.library'
 apply plugin: 'com.neenbedankt.android-apt'
+apply plugin: 'maven-publish'
+apply plugin: 'com.jfrog.bintray'
 
 android {
     compileSdkVersion 20
@@ -47,6 +49,73 @@ android.libraryVariants.all { variant ->
     }
 }
 
+task androidJar(type: Jar, dependsOn: 'assemble') {
+    group 'Build'
+    description 'Generates a jar file continaining Realm and its annotation processor'
+    from zipTree('build/intermediates/bundles/release/classes.jar')
+    from zipTree("../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar").matching {
+        exclude 'io/realm/annotations/Ignore.class', 'io/realm/annotations/RealmClass.class', 'io/realm/annotations/Index.class' // Avoid duplicates
+    }
+    from(file('src/main/jniLibs')) {
+        into 'lib'
+    }
+}
+
+task androidSourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+}
+
+artifacts {
+    archives file("build/libs/realm-${version}.jar")
+    archives androidSourcesJar
+}
+
+publishing {
+    publications {
+        mavenAndroid(MavenPublication) {
+            groupId 'io.realm'
+            artifactId 'realm-android'
+            version version
+            artifact androidJar
+            artifact androidSourcesJar {
+                classifier "sources"
+            }
+            pom.withXml {
+                Node root = asNode()
+                root.appendNode('name', 'realm-android')
+                root.appendNode('description', 'Realm is a mobile database: a replacement for SQLite & ORMs.')
+                root.appendNode('url', 'http://realm.io')
+
+                def issues = root.appendNode('issueManagement')
+                issues.appendNode('system', 'github')
+                issues.appendNode('url', 'https://github.com/realm/realm-java/issues')
+
+                def scm = root.appendNode('scm')
+                scm.appendNode('url', 'scm:https://github.com/realm/realm-java')
+                scm.appendNode('connection', 'scm:git@github.com:realm/realm-java.git')
+                scm.appendNode('developerConnection', 'scm:git@github.com:realm/realm-java.git')
+
+                def license = root.appendNode('licenses').appendNode('license')
+                license.appendNode('name', 'The Apache Software License, Version 2.0')
+                license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
+                license.appendNode('distribution', 'repo')
+            }
+        }
+    }
+}
+
+bintray {
+    user = project.hasProperty('bintrayUser')?bintrayUser:'noUser' // this comes from the gradle.properties file in ~/.gradle
+    key = project.hasProperty('bintrayKey')?bintrayKey:'noKey' //this comes from the gradle.properties file in ~/.gradle
+    publications = ['mavenAndroid']
+    publish = false
+    pkg {
+        repo = 'maven'
+        name = 'realm-android'
+        licenses = ['Apache-2.0']
+    }
+}
+
 task buildApt(type: GradleBuild) {
     dir = file('../realm-annotations-processor')
     tasks = ['build']
diff --git a/realm/src/androidTest/java/io/realm/NotificationsTest.java b/realm/src/androidTest/java/io/realm/NotificationsTest.java
new file mode 100644
index 0000000000..6436da1ba5
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/NotificationsTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.test.AndroidTestCase;
+import android.util.Log;
+
+import io.realm.entities.Dog;
+import io.realm.internal.android.LooperThread;
+
+public class NotificationsTest extends AndroidTestCase {
+    public void testMessageToDeadThread() {
+        Realm realm = Realm.getInstance(getContext());
+
+        // Number of handlers before
+        final int handlersBefore = LooperThread.handlers.size();
+
+        // Make sure the Looper Thread is alive
+        LooperThread looperThread = LooperThread.getInstance();
+        assertTrue(looperThread.isAlive());
+
+        Thread thread = new Thread() {
+            @Override
+            public void run() {
+                Realm r = Realm.getInstance(getContext());
+                assertFalse(handlersBefore == LooperThread.handlers.size());
+                r.addChangeListener(new RealmChangeListener() {
+                    @Override
+                    public void onChange() {
+                        Log.i("Notification Test", "Notification Received");
+                    }
+                });
+            }
+        };
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail();
+        }
+        assertFalse(thread.isAlive()); // Make sure the thread is dead
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        dog.setName("Rex");
+        realm.commitTransaction();
+
+        // Give some time to log the exception
+        try {
+            Thread.sleep(500);
+        } catch (InterruptedException e) {
+            fail();
+        }
+
+        assertEquals(0, looperThread.exceptions.size());
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
new file mode 100644
index 0000000000..a061d5ed70
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.test.AndroidTestCase;
+
+import io.realm.entities.AnnotationTypes;
+import io.realm.internal.Table;
+
+public class RealmAnnotationTest extends AndroidTestCase {
+    protected Realm testRealm;
+
+    @Override
+    protected void setUp() throws Exception {
+        Realm.deleteRealmFile(getContext());
+        testRealm = Realm.getInstance(getContext());
+        testRealm.beginTransaction();
+        AnnotationTypes object = testRealm.createObject(AnnotationTypes.class);
+        object.setNotIndexString("String 1");
+        object.setIndexString("String 2");
+        object.setIgnoreString("String 3");
+        testRealm.commitTransaction();
+    }
+
+    public void testIgnore() {
+        Table table = testRealm.getTable(AnnotationTypes.class);
+        assertEquals(-1, table.getColumnIndex("ignoreString"));
+    }
+
+    public void testIndex() {
+        Table table = testRealm.getTable(AnnotationTypes.class);
+        assertTrue(table.hasIndex(table.getColumnIndex("indexString")));
+        assertFalse(table.hasIndex(table.getColumnIndex("notIndexString")));
+    }
+}
\ No newline at end of file
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
index 4bfbe71825..221f81c732 100644
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
@@ -17,6 +17,7 @@
 package io.realm;
 
 import android.test.AndroidTestCase;
+
 import io.realm.entities.AllTypes;
 import io.realm.internal.Row;
 
@@ -47,4 +48,25 @@ public void testRealmGetRowReturnsValidRow() {
         assertEquals("RealmObject.realmGetRow seems to return wrong row type: ", 8, row.getColumnCount());
     }
 
+    public void testStringEncoding() {
+        String[] strings = {"ABCD", "ÆØÅ", "Ö∫Ë", "ΠΑΟΚ", "Здравей"};
+
+        testRealm.beginTransaction();
+        testRealm.clear(AllTypes.class);
+
+        for (String str : strings) {
+            AllTypes obj1 = testRealm.createObject(AllTypes.class);
+            obj1.setColumnString(str);
+        }
+        testRealm.commitTransaction();
+
+        RealmResults<AllTypes> objects = testRealm.allObjects(AllTypes.class);
+        assertEquals(strings.length, objects.size());
+        int i = 0;
+        for (AllTypes obj : objects) {
+            String s = obj.getColumnString();
+            assertEquals(strings[i], s);
+            i++;
+        }
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsTest.java b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
index cc7992acc7..54b48870f4 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
@@ -29,8 +29,17 @@
 
     protected Realm testRealm;
 
+    private final static String FIELD_STRING = "columnString";
+    private final static String FIELD_LONG = "columnLong";
+    private final static String FIELD_FLOAT = "columnFloat";
+    private final static String FIELD_DOUBLE = "columnDouble";
+    private final static String FIELD_BOOLEAN = "columnBoolean";
+    private final static String FIELD_DATE = "columnDate";
+    private final static String FIELD_BYTE = "columnBinary";
+    private final static String FIELD_DOG = "columnRealmObject";
+
     @Override
-    protected void setUp() {
+    protected void setUp() throws InterruptedException {
         Realm.deleteRealmFile(getContext());
         testRealm = Realm.getInstance(getContext());
 
@@ -42,13 +51,14 @@ protected void setUp() {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date());
-            allTypes.setColumnDouble(3.1415);
+            allTypes.setColumnDate(new Date((long)i));
+            allTypes.setColumnDouble(3.1415 + i);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
         }
         testRealm.commitTransaction();
+
     }
 
 
@@ -103,21 +113,21 @@ public void testResultListLastIsLast() {
     public void testMinValueIsMinValue() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
 
-        Number minimum = resultList.min("columnLong");
+        Number minimum = resultList.min(FIELD_LONG);
         assertEquals("ResultList.min returned wrong value", 0, minimum.intValue());
     }
 
     public void testMaxValueIsMaxValue() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
 
-        Number maximum = resultList.max("columnLong");
-        assertEquals("ResultList.max returned wrong value", TEST_DATA_SIZE -1, maximum.intValue());
+        Number maximum = resultList.max(FIELD_LONG);
+        assertEquals("ResultList.max returned wrong value", TEST_DATA_SIZE-1, maximum.intValue());
     }
 
     public void testSumGivesCorrectValue() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
 
-        Number sum = resultList.sum("columnLong");
+        Number sum = resultList.sum(FIELD_LONG);
 
         int checkSum = 0;
         for (int i = 0; i < TEST_DATA_SIZE; ++i) {
@@ -129,9 +139,9 @@ public void testSumGivesCorrectValue() {
     public void testAvgGivesCorrectValue() {
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
 
-        Double avg = Math.round(resultList.average("columnDouble")*10000.0)/10000.0;
+        Double avg = Math.round(resultList.average(FIELD_DOUBLE)*10000.0)/10000.0;
 
-        assertEquals("ResultList.sum returned wrong sum", 3.1415 ,avg);
+        assertEquals("ResultList.sum returned wrong sum", 260.6415, avg);
     }
 
 
@@ -170,13 +180,119 @@ public void testIsResultRemoveLastListSizeOk() {
 
     }
 
-    public void testSort() {
+    public void testSortByLong() {
+
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
-        RealmResults<AllTypes> sortedList = resultList.sort("columnLong", RealmResults.SORT_ORDER_DECENDING);
+        RealmResults<AllTypes> sortedList = resultList.sort(FIELD_LONG, RealmResults.SORT_ORDER_DECENDING);
         assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getColumnLong(), sortedList.last().getColumnLong());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_LONG, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnLong(), reverseList.first().getColumnLong());
+        assertEquals("Last excepted to be last", resultList.last().getColumnLong(), reverseList.last().getColumnLong());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_LONG, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+    }
+
+    public void testSortByDate() {
+
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.sort(FIELD_DATE, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getColumnDate(), sortedList.last().getColumnDate());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_DATE, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnDate(), reverseList.first().getColumnDate());
+        assertEquals("Last excepted to be last", resultList.last().getColumnDate(), reverseList.last().getColumnDate());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_DATE, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+    }
+
+    public void testSortByBoolean(){
+
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("Last expected to be false", false, sortedList.last().isColumnBoolean());
+        assertEquals("First expected to be true", true, sortedList.first().isColumnBoolean());
+        assertEquals("Expected to be true", true, sortedList.get(147).isColumnBoolean());
+        assertEquals("Expected to be false", false, sortedList.get(368).isColumnBoolean());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("Last expected to be true", true, reverseList.last().isColumnBoolean());
+        assertEquals("First expected to be false", false, reverseList.first().isColumnBoolean());
+        assertEquals("Expected to be false", false, reverseList.get(147).isColumnBoolean());
+        assertEquals("Expected to be true", true, reverseList.get(368).isColumnBoolean());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_BOOLEAN, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+        assertEquals(reserveSortedList.first(), sortedList.first());
+    }
+
+    public void testSortByString() {
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.sort("columnString", RealmResults.SORT_ORDER_DECENDING);
+
+        for (int i = 0; i< sortedList.size();i++) {
+            System.out.println(sortedList.get(i).getColumnString());
+        }
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
         assertEquals("First excepted to be last", resultList.first().getColumnString(), sortedList.last().getColumnString());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_STRING, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnString(), reverseList.first().getColumnString());
+        assertEquals("Last excepted to be last", resultList.get(99).getColumnString(), reverseList.last().getColumnString());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_STRING, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+    }
+
+
+    public void testSortByDouble() {
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getColumnDouble(), sortedList.last().getColumnDouble());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnDouble(), reverseList.first().getColumnDouble());
+        assertEquals("Last excepted to be last", resultList.last().getColumnDouble(), reverseList.last().getColumnDouble());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_DOUBLE, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
+    }
+
+
+    public void testSortByFloat() {
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmResults<AllTypes> sortedList = resultList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_DATA_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getColumnFloat(), sortedList.last().getColumnFloat());
+
+        RealmResults<AllTypes> reverseList = sortedList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_ASCENDING);
+        assertEquals(TEST_DATA_SIZE, reverseList.size());
+        assertEquals("First excepted to be first", resultList.first().getColumnFloat(), reverseList.first().getColumnFloat());
+        assertEquals("Last excepted to be last", resultList.last().getColumnFloat(), reverseList.last().getColumnFloat());
+
+        RealmResults<AllTypes> reserveSortedList = reverseList.sort(FIELD_FLOAT, RealmResults.SORT_ORDER_DECENDING);
+        assertEquals(TEST_DATA_SIZE, reserveSortedList.size());
     }
 
+
+
     public void testCount() {
         assertEquals(TEST_DATA_SIZE, testRealm.where(AllTypes.class).count());
     }
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index 82558fe106..a781f9c84d 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -23,6 +23,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.Table;
 
 
@@ -619,6 +620,16 @@ public void testBeginTransaction() throws IOException {
         assertEquals("Change has not been committed", 1, resultList.size());
     }
 
+    public void testNestedTransaction() {
+        testRealm.beginTransaction();
+        try {
+            testRealm.beginTransaction();
+            fail();
+        } catch (RealmException e) {
+            assertEquals("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().", e.getMessage());
+        }
+        testRealm.commitTransaction();
+    }
     // void commitTransaction()
     public void testCommitTransaction() {
         testRealm.beginTransaction();
diff --git a/realm/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/src/androidTest/java/io/realm/entities/AllTypes.java
index 982ef0694c..14984fc9d0 100644
--- a/realm/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -21,7 +21,6 @@
 import io.realm.RealmObject;
 
 public class AllTypes extends RealmObject {
-
     private String columnString;
     private long columnLong;
     private float columnFloat;
diff --git a/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java b/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
new file mode 100644
index 0000000000..35b731e749
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/entities/AnnotationTypes.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+
+public class AnnotationTypes extends RealmObject {
+    @Index
+    private String indexString;
+    private String notIndexString;
+    @Ignore
+    private String ignoreString;
+
+    public String getIndexString() {
+        return indexString;
+    }
+
+    public void setIndexString(String indexString) {
+        this.indexString = indexString;
+    }
+
+    public String getNotIndexString() {
+        return notIndexString;
+    }
+
+    public void setNotIndexString(String notIndexString) {
+        this.notIndexString = notIndexString;
+    }
+
+    public String getIgnoreString() {
+        return ignoreString;
+    }
+
+    public void setIgnoreString(String ignoreString) {
+        this.ignoreString = ignoreString;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java b/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java
index 2c10aaeb94..a56d0718f0 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNISubtableTest.java
@@ -118,13 +118,6 @@ public void testSubtableSort() {
         assertEquals(10, subView.getLong(0, 0));
         assertEquals(100, subView.getLong(0, 1));
         assertEquals(1000, subView.getLong(0, 2));
-
-        try { 
-            subView.sort(subtableStringColIndex); 
-            fail("Sort not supported on String columns"); 
-        } catch (IllegalArgumentException e) {
-            assertNotNull(e);
-        }
     }
 
     public void testAddColumnsToSubtables() {
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
index 315ac317c2..8c29f07d51 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -117,47 +117,6 @@ public void testTableBinaryTest() {
     }
 
 
-    public void testLookupTable() {
-        Table t = new Table();
-
-        long STRING_COL_INDEX   = t.addColumn(ColumnType.STRING, "col0");
-        long INT_COL_INDEX      = t.addColumn(ColumnType.INTEGER, "col1");
-
-        t.add("s", 1);
-        t.add("s", 2);
-        t.add("ss",1);
-        t.add("ss", 2);
-        t.add("", 2);
-
-        assertEquals(0, t.lookup("s"));
-        assertEquals(2, t.lookup("ss"));
-        assertEquals(4, t.lookup(""));
-
-        assertEquals(false, t.hasIndex(STRING_COL_INDEX));
-
-        //try setting an index
-        t.setIndex(0);
-        assertEquals(0, t.lookup("s"));
-        assertEquals(2, t.lookup("ss"));
-        assertEquals(4, t.lookup(""));
-
-        // null lookup value
-        try {  t.lookup(null); fail("lookup value is null"); } catch (IllegalArgumentException r) { };
-
-        assertEquals(-1, t.lookup("I dont exist"));
-
-
-        // Try with non string column
-        Table t2 = new Table();
-        t2.addColumn(ColumnType.INTEGER, "col0");
-        t2.addColumn(ColumnType.INTEGER, "col1");
-        t2.add(1, 2);
-        t2.add(3, 4);
-
-        try {  t2.lookup("ss"); fail("Column not String"); } catch (UnsupportedOperationException r) { };
-    }
-
-
     public void testFindFirstNonExisting() {
         Table t = TestHelper.getTableWithAllColumnTypes();
         t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 6ed9fe8967..4b946403ee 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -26,17 +26,14 @@ public void setUp() {
         t.addColumn(ColumnType.DATE,   "Birthday");
 
         // Add unsupported column types
-        t.addColumn(ColumnType.STRING, "Unsupported0");
-        t.addColumn(ColumnType.FLOAT,  "Unsupported1");
-        t.addColumn(ColumnType.DOUBLE, "Unsupported2");
         t.addColumn(ColumnType.MIXED,  "Unsupported3");
         t.addColumn(ColumnType.TABLE,  "Unsupported4");
 
         //Add data
-        t.add("cc", true,  24, date1, "", 0.0f, 0.0, 0, null);
-        t.add("dd", false, 35, date2, "", 0.0f, 0.0, 0, null);
-        t.add("bb", true,  22, date3, "", 0.0f, 0.0, 0, null);
-        t.add("aa", false, 22, date4, "", 0.0f, 0.0, 0, null);
+        t.add("cc", true,  24, date1, 0, null);
+        t.add("dd", false, 35, date2, 0, null);
+        t.add("bb", true,  22, date3, 0, null);
+        t.add("aa", false, 22, date4, 0, null);
 
         assertEquals(date1, t.getDate(3, 0));
         assertEquals(date2, t.getDate(3, 1));
@@ -290,7 +287,7 @@ public void testShouldSortViewBool() {
     public void testShouldThrowExceptionForUnsupportedColumns() {
         TableView view = t.where().findAll();
         long colIndex;
-        for (colIndex = 4; colIndex <= 8; colIndex++) {
+        for (colIndex = 4; colIndex <= 5; colIndex++) {
             try {
                 view.sort(colIndex); // Must throw for invalid column types
                 fail("expected exception.");
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index b02ba2ebbc..813456f870 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -23,7 +23,6 @@
 import android.util.Log;
 
 import java.io.File;
-import java.lang.ref.SoftReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -34,6 +33,7 @@
 import java.util.Map;
 
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
@@ -43,13 +43,30 @@
 import io.realm.internal.android.LooperThread;
 
 
+/**
+ * The Realm class is the storage and transactional manager of your object persistent store. Objects
+ * are created. Objects within a Realm can be queried and read at any time. Creating,
+ * modifying, and deleting objects must be done through transactions.
+ * <p/>
+ * The transactions ensure that multiple instances (on multiple threads) can access the objects
+ * in a consistent state with full ACID guaranties.
+ * <p/>
+ * The instances of a Realm will be automatically updated when one instance commits a
+ * change (create, modify or delete an object).
+ */
 public class Realm {
     public static final String DEFAULT_REALM_NAME = "default.realm";
-    private static final Map<String, ThreadRealm> realms = new HashMap<String, ThreadRealm>();
 
     private static final String TAG = "REALM";
     private static final String TABLE_PREFIX = "class_";
+    private static final ThreadLocal<Map<String, Realm>> realmsCache = new ThreadLocal<Map<String, Realm>>() {
+        @Override
+        protected Map<String, Realm> initialValue() {
+            return new HashMap<String, Realm>();
+        }
+    };
 
+    @SuppressWarnings("UnusedDeclaration")
     private static SharedGroup.Durability defaultDurability = SharedGroup.Durability.FULL;
     private static boolean autoRefresh = true;
 
@@ -121,8 +138,13 @@ public Table getTable(Class<?> clazz) {
 
     /**
      * Realm static constructor for the default realm "default.realm"
+     *
      * @param context an Android context
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
     public static Realm getInstance(Context context) {
         return Realm.getInstance(context, DEFAULT_REALM_NAME, null);
@@ -130,30 +152,47 @@ public static Realm getInstance(Context context) {
 
     /**
      * Realm static constructor
-     * @param context an Android context
+     *
+     * @param context  an Android context
      * @param fileName the name of the file to save the Realm to
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
+    @SuppressWarnings("UnusedDeclaration")
     public static Realm getInstance(Context context, String fileName) {
         return Realm.create(context.getFilesDir(), fileName, null);
     }
 
     /**
      * Realm static constructor
+     *
      * @param context an Android context
-     * @param key a 32-byte encryption key
+     * @param key     a 32-byte encryption key
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
+    @SuppressWarnings("UnusedDeclaration")
     public static Realm getInstance(Context context, byte[] key) {
         return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
     }
 
     /**
      * Realm static constructor
-     * @param context an Android context
+     *
+     * @param context  an Android context
      * @param fileName the name of the file to save the Realm to
-     * @param key a 32-byte encryption key
+     * @param key      a 32-byte encryption key
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
     public static Realm getInstance(Context context, String fileName, byte[] key) {
         return Realm.create(context.getFilesDir(), fileName, key);
@@ -161,20 +200,31 @@ public static Realm getInstance(Context context, String fileName, byte[] key) {
 
     /**
      * Realm static constructor
+     *
      * @param writableFolder absolute path to a writable directory
-     * @param key a 32-byte encryption key
+     * @param key            a 32-byte encryption key
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
+    @SuppressWarnings("UnusedDeclaration")
     public static Realm getInstance(File writableFolder, byte[] key) {
         return Realm.create(writableFolder, DEFAULT_REALM_NAME, key);
     }
 
     /**
      * Realm static constructor
+     *
      * @param writableFolder absolute path to a writable directory
-     * @param filename the name of the file to save the Realm to
-     * @param key a 32-byte encryption key
+     * @param filename       the name of the file to save the Realm to
+     * @param key            a 32-byte encryption key
      * @return an instance of the Realm class
+     * @throws RealmMigrationNeededException The model classes have been changed and the Realm
+     *                                       must be migrated
+     * @throws RealmIOException              Error when accessing underlying file
+     * @throws RealmException                Other errors
      */
     public static Realm create(File writableFolder, String filename, byte[] key) {
         String absolutePath = new File(writableFolder, filename).getAbsolutePath();
@@ -182,20 +232,15 @@ public static Realm create(File writableFolder, String filename, byte[] key) {
     }
 
     private static Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema) {
-        ThreadRealm threadRealm = realms.get(absolutePath);
-        boolean needsValidation = (threadRealm == null);
-        if (threadRealm == null) {
-            threadRealm = new ThreadRealm(absolutePath, key);
-        }
-        SoftReference<Realm> realmSoftReference = threadRealm.get();
-        Realm realm = realmSoftReference.get();
+        Map<String, Realm> realms = realmsCache.get();
+        Realm realm = realms.get(absolutePath);
+
         if (realm == null) {
-            // The garbage collector decided to get rid of the realm instance
-            threadRealm = new ThreadRealm(absolutePath, key);
-            realmSoftReference = threadRealm.get();
-            realm = realmSoftReference.get();
+            realm = new Realm(absolutePath, key);
+            realms.put(absolutePath, realm);
+            realmsCache.set(realms);
         }
-        if (validateSchema && needsValidation) {
+        if (validateSchema) {
             Class<?> validationClass;
             try {
                 validationClass = Class.forName("io.realm.ValidationList");
@@ -210,6 +255,7 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
             }
             List<String> proxyClasses;
             try {
+                //noinspection unchecked
                 proxyClasses = (List<String>) getProxyClassesMethod.invoke(null);
             } catch (IllegalAccessException e) {
                 throw new RealmException("Could not execute the getProxyClasses method in the ValidationList class");
@@ -276,7 +322,8 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
                     }
                     List<String> fieldNames;
                     try {
-                        fieldNames = (List<String>)fieldNamesMethod.invoke(null);
+                        //noinspection unchecked
+                        fieldNames = (List<String>) fieldNamesMethod.invoke(null);
                     } catch (IllegalAccessException e) {
                         throw new RealmException("Could not execute the getFieldNames method in the generated " + generatedClassName + " class");
                     } catch (InvocationTargetException e) {
@@ -296,11 +343,7 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
                         columnIndices.put(modelClassName, innerMap);
                     }
                 }
-
-                // cache realm after validation
-                realms.put(absolutePath, threadRealm);
-            }
-            finally {
+            } finally {
                 realm.commitTransaction();
             }
         }
@@ -308,28 +351,12 @@ private static Realm createAndValidate(String absolutePath, byte[] key, boolean
         return realm;
     }
 
-    // This class stores soft-references to realm objects per thread per realm file
-    private static class ThreadRealm extends ThreadLocal<SoftReference<Realm>> {
-        private String absolutePath;
-        private byte[] key;
-
-        private ThreadRealm(String absolutePath, byte[] key) {
-            this.absolutePath = absolutePath;
-            this.key = key;
-        }
-
-        @Override
-        protected SoftReference<Realm> initialValue() {
-            Realm realm = new Realm(absolutePath, key);
-            key = null;
-            return new SoftReference<Realm>(realm);
-        }
-    }
-
     /**
      * Instantiates and adds a new object to the realm
-     * @return The new object
+     *
      * @param clazz The Class of the object to create
+     * @return The new object
+     * @throws RealmException An object could not be created
      */
     public <E extends RealmObject> E createObject(Class<E> clazz) {
         Table table;
@@ -453,13 +480,15 @@ boolean contains(Class<?> clazz) {
             simpleClassName = clazz.getSimpleName();
             simpleClassNames.put(clazz, simpleClassName);
         }
-        return transaction.hasTable(TABLE_PREFIX+simpleClassName);
+        return transaction.hasTable(TABLE_PREFIX + simpleClassName);
     }
 
     /**
      * Returns a typed RealmQuery, which can be used to query for specific objects of this type
+     *
      * @param clazz The class of the object which is to be queried for
      * @return A typed RealmQuery, which can be used to query for specific objects of this type
+     * @throws java.lang.RuntimeException Any other error
      * @see io.realm.RealmQuery
      */
     public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz) {
@@ -468,8 +497,10 @@ boolean contains(Class<?> clazz) {
 
     /**
      * Get all objects of a specific Class
+     *
      * @param clazz the Class to get objects of
      * @return A RealmResult list containing the objects
+     * @throws java.lang.RuntimeException Any other error
      * @see io.realm.RealmResults
      */
     public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz) {
@@ -480,6 +511,7 @@ boolean contains(Class<?> clazz) {
 
     /**
      * Add a change listener to the Realm
+     *
      * @param listener the change listener
      * @see io.realm.RealmChangeListener
      */
@@ -490,6 +522,7 @@ public void addChangeListener(RealmChangeListener listener) {
 
     /**
      * Remove the specified change listener
+     *
      * @param listener the change listener to be removed
      * @see io.realm.RealmChangeListener
      */
@@ -502,6 +535,7 @@ public void removeChangeListener(RealmChangeListener listener) {
 
     /**
      * Remove all user-defined change listeners
+     *
      * @see io.realm.RealmChangeListener
      */
     public void removeAllChangeListeners() {
@@ -510,11 +544,12 @@ public void removeAllChangeListeners() {
     }
 
     void sendNotifications() {
-        for(RealmChangeListener listener : changeListeners) {
+        for (RealmChangeListener listener : changeListeners) {
             listener.onChange();
         }
     }
 
+    @SuppressWarnings("UnusedDeclaration")
     boolean hasChanged() {
         return sharedGroup.hasChanged();
     }
@@ -528,7 +563,12 @@ boolean hasChanged() {
 //    }
 
     /**
-     * Starts a write transaction, this must be closed with commitTransaction()
+     * Starts a write transaction, this must be closed with commitTransaction().
+     * Notice: it is not possible to nest write transactions. If you start a write
+     * transaction within a write transaction an exception is thrown.
+     *
+     * @throws io.realm.exceptions.RealmException If already in a write transaction.
+     * @throws java.lang.RuntimeException         Any other error.
      */
     public void beginTransaction() {
         transaction.promoteToWrite();
@@ -536,6 +576,8 @@ public void beginTransaction() {
 
     /**
      * Commits a write transaction
+     *
+     * @throws java.lang.RuntimeException Any other error
      */
     public void commitTransaction() {
         transaction.commitAndContinueAsRead();
@@ -552,7 +594,9 @@ public void commitTransaction() {
 
     /**
      * Remove all objects of the specified class
+     *
      * @param classSpec The class which objects should be removed
+     * @throws java.lang.RuntimeException Any other error
      */
     public void clear(Class<?> classSpec) {
         getTable(classSpec).clear();
@@ -581,18 +625,25 @@ static public void migrateRealmAtPath(String realmPath, RealmMigration migration
         migrateRealmAtPath(realmPath, null, migration);
     }
 
-    static public void migrateRealmAtPath(String realmPath, byte [] key, RealmMigration migration) {
+    static public void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration) {
         Realm realm = Realm.createAndValidate(realmPath, key, false);
         realm.beginTransaction();
         realm.setVersion(migration.execute(realm, realm.getVersion()));
         realm.commitTransaction();
+
+        Map<String, Realm> realms = realmsCache.get();
+        realms.put(realmPath, new Realm(realmPath, key));
+        realmsCache.set(realms);
     }
 
     /**
      * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
      * The realm must be unused and closed before calling this method.
+     * WARNING: Your Realm must not be open (typically when your app launch).
+     *
      * @param context an Android context.
      * @return false if a file could not be deleted. The failing file will be logged.
+     * @see io.realm.Realm#clear(Class)
      */
     public static boolean deleteRealmFile(Context context) {
         return deleteRealmFile(context, DEFAULT_REALM_NAME);
@@ -601,7 +652,8 @@ public static boolean deleteRealmFile(Context context) {
     /**
      * Delete the Realm file from the filesystem for a custom named Realm.
      * The realm must be unused and closed before calling this method.
-     * @param context an Android context.
+     *
+     * @param context  an Android context.
      * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
      * @return false if a file could not be deleted. The failing file will be logged.
      */
diff --git a/realm/src/main/java/io/realm/RealmChangeListener.java b/realm/src/main/java/io/realm/RealmChangeListener.java
index 2ce644b4ff..54cc99eeae 100644
--- a/realm/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/src/main/java/io/realm/RealmChangeListener.java
@@ -16,6 +16,14 @@
 
 package io.realm;
 
+/**
+ * Using RealmChangeListener, it is possible to be notified when another instance of a Realm is
+ * changed.
+ *
+ * @see Realm#addChangeListener(RealmChangeListener)
+ * @see Realm#removeAllChangeListeners()
+ * @see Realm#removeChangeListener(RealmChangeListener)
+ */
 public interface RealmChangeListener {
 
     /**
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index a447e276df..ccf8523c07 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -20,13 +20,19 @@
 
 import io.realm.internal.LinkView;
 
+/**
+ * RealmList is used in one-to-many relationships.
+ *
+ * @param <E> The class of objects in this list
+ */
+
 public class RealmList<E extends RealmObject> extends AbstractList<E> {
 
     private Class<E> clazz;
     private LinkView view;
     private Realm realm;
 
-    public RealmList(Class<E> clazz, LinkView view, Realm realm) {
+    RealmList(Class<E> clazz, LinkView view, Realm realm) {
         this.clazz = clazz;
         this.view = view;
         this.realm = realm;
diff --git a/realm/src/main/java/io/realm/RealmMigration.java b/realm/src/main/java/io/realm/RealmMigration.java
index 352a8f2ab3..b61a3f6869 100644
--- a/realm/src/main/java/io/realm/RealmMigration.java
+++ b/realm/src/main/java/io/realm/RealmMigration.java
@@ -16,6 +16,12 @@
 
 package io.realm;
 
+/**
+ * RealmMigration is used to allow user defined migration of one model to a another.
+ *
+ * @see Realm#migrateRealmAtPath(String, byte[], RealmMigration)
+ * @see Realm#migrateRealmAtPath(String, RealmMigration)
+ */
 public interface RealmMigration {
 
     /**
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
index 735765abfd..85019d24ec 100644
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ b/realm/src/main/java/io/realm/RealmObject.java
@@ -19,6 +19,18 @@
 import io.realm.internal.Row;
 import io.realm.annotations.RealmClass;
 
+/**
+ * In Realm you define your model classes by subclassing RealmObject and adding fields to be
+ * persisted. You then create your objects within a Realm, and use your custom subclasses instead
+ * of using the RealmObject class directly.
+ *
+ * An annotation processor will create a proxy class for your RealmObject subclass. The getters and
+ * setters should not contain any custom code of logic as they are overridden as part of the annotation
+ * process.
+ *
+ * @see Realm#createObject(Class)
+ */
+
 @RealmClass
 public abstract class RealmObject {
 
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
index 4561e3549c..99a618588f 100644
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ b/realm/src/main/java/io/realm/RealmQuery.java
@@ -36,6 +36,12 @@
     private Map<String, Integer> columns = new HashMap<String, Integer>();
     private Class<E> clazz;
 
+    /**
+     * Creating a RealmQuery instance
+     * @param realm  The realm to query within
+     * @param clazz  The class to query
+     * @throws java.lang.RuntimeException Any other error
+     */
     public RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
@@ -48,6 +54,12 @@ public RealmQuery(Realm realm, Class<E> clazz) {
         }
     }
 
+    /**
+     * Create a RealmQuery instance from a RealmResults
+     * @param realmList   The RealmResults to query
+     * @param clazz       The class to query
+     * @throws java.lang.RuntimeException Any other error
+     */
     public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.realmList = realmList;
 
@@ -77,6 +89,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, String value) {
         int columnIndex = columns.get(fieldName);
@@ -89,6 +104,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -101,6 +119,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -113,6 +134,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -125,6 +149,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -137,6 +164,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, boolean value) {
         int columnIndex = columns.get(fieldName);
@@ -149,6 +179,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> equalTo(String fieldName, Date value) {
         
@@ -164,6 +197,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, String value) {
         int columnIndex = columns.get(fieldName);
@@ -176,6 +212,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -188,6 +227,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -200,6 +242,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -212,6 +257,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -224,6 +272,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, boolean value) {
         int columnIndex = columns.get(fieldName);
@@ -236,6 +287,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> notEqualTo(String fieldName, Date value) {
         int columnIndex = columns.get(fieldName);
@@ -250,6 +304,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -262,6 +319,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -274,6 +334,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -286,6 +349,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -298,6 +364,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         int columnIndex = columns.get(fieldName);
@@ -310,6 +379,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -322,6 +394,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -334,6 +409,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -346,6 +424,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -358,6 +439,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         int columnIndex = columns.get(fieldName);
@@ -372,6 +456,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -384,6 +471,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -396,6 +486,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -408,6 +501,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -420,6 +516,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         int columnIndex = columns.get(fieldName);
@@ -432,6 +531,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         int columnIndex = columns.get(fieldName);
@@ -444,6 +546,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         int columnIndex = columns.get(fieldName);
@@ -456,6 +561,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         int columnIndex = columns.get(fieldName);
@@ -468,6 +576,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         int columnIndex = columns.get(fieldName);
@@ -480,6 +591,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The value to compare with
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         int columnIndex = columns.get(fieldName);
@@ -495,6 +609,9 @@ TableOrView getTable() {
      * @param from       Lowest value (inclusive)
      * @param to         Highest value (inclusive)
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> between(String fieldName, int from, int to) {
         int columnIndex = columns.get(fieldName);
@@ -508,6 +625,9 @@ TableOrView getTable() {
      * @param from       Lowest value (inclusive)
      * @param to         Highest value (inclusive)
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> between(String fieldName, long from, long to) {
         int columnIndex = columns.get(fieldName);
@@ -521,6 +641,9 @@ TableOrView getTable() {
      * @param from       Lowest value (inclusive)
      * @param to         Highest value (inclusive)
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> between(String fieldName, double from, double to) {
         int columnIndex = columns.get(fieldName);
@@ -534,6 +657,9 @@ TableOrView getTable() {
      * @param from       Lowest value (inclusive)
      * @param to         Highest value (inclusive)
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> between(String fieldName, float from, float to) {
         int columnIndex = columns.get(fieldName);
@@ -547,6 +673,9 @@ TableOrView getTable() {
      * @param from       Lowest value (inclusive)
      * @param to         Highest value (inclusive)
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         int columnIndex = columns.get(fieldName);
@@ -562,6 +691,9 @@ TableOrView getTable() {
      * @param fieldName  The field to compare
      * @param value      The substring
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> contains(String fieldName, String value) {
         int columnIndex = columns.get(fieldName);
@@ -575,6 +707,9 @@ TableOrView getTable() {
      * @param value      The substring
      * @param caseSensitive if true, substring matching is case sensitive
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> contains(String fieldName, String value, boolean caseSensitive) {
         int columnIndex = columns.get(fieldName);
@@ -587,6 +722,9 @@ TableOrView getTable() {
      * @param fieldName The field to compare
      * @param value     The string
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> beginsWith(String fieldName, String value) {
         int columnIndex = columns.get(fieldName);
@@ -600,6 +738,9 @@ TableOrView getTable() {
      * @param value     The substring
      * @param caseSensitive if true, substring matching is case sensitive
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> beginsWith(String fieldName, String value, boolean caseSensitive) {
         int columnIndex = columns.get(fieldName);
@@ -612,6 +753,9 @@ TableOrView getTable() {
      * @param fieldName The field to compare
      * @param value     The string
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> endsWith(String fieldName, String value) {
         int columnIndex = columns.get(fieldName);
@@ -625,6 +769,9 @@ TableOrView getTable() {
      * @param value     The substring
      * @param caseSensitive if true, substring matching is case sensitive
      * @return The query object
+     * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
+     * field type
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> endsWith(String fieldName, String value, boolean caseSensitive) {
         int columnIndex = columns.get(fieldName);
@@ -637,6 +784,7 @@ TableOrView getTable() {
     /**
      * Begin grouping of conditions ("left parenthesis")
      * @return The query object
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> beginGroup() {
         this.query.group();
@@ -646,6 +794,7 @@ TableOrView getTable() {
     /**
      * End grouping of conditions ("right parenthesis")
      * @return The query object
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> endGroup() {
         this.query.endGroup();
@@ -655,6 +804,7 @@ TableOrView getTable() {
     /**
      * Logical-or two conditions
      * @return The query object
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmQuery<E> or() {
         this.query.or();
@@ -670,6 +820,7 @@ TableOrView getTable() {
      * Calculate the sum of a field
      * @param fieldName The field name
      * @return The sum
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public long sumInt(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -680,6 +831,7 @@ public long sumInt(String fieldName) {
      * Calculate the sum of a field
      * @param fieldName The field name
      * @return The sum
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double sumDouble(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -690,6 +842,7 @@ public double sumDouble(String fieldName) {
      * Calculate the sum of a field
      * @param fieldName The field name
      * @return The sum
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double sumFloat(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -702,6 +855,7 @@ public double sumFloat(String fieldName) {
      * Calculate the average of a field
      * @param fieldName The field name
      * @return The average
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double averageInt(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -712,6 +866,7 @@ public double averageInt(String fieldName) {
      * Calculate the average of a field
      * @param fieldName The field name
      * @return The average
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double averageDouble(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -722,6 +877,7 @@ public double averageDouble(String fieldName) {
      * Calculate the average of a field
      * @param fieldName The field name
      * @return The average
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double averageFloat(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -734,6 +890,7 @@ public double averageFloat(String fieldName) {
      * Find the minimum value of a field
      * @param fieldName  The field name
      * @return The minimum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public long minimumInt(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -744,6 +901,7 @@ public long minimumInt(String fieldName) {
      * Find the minimum value of a field
      * @param fieldName  The field name
      * @return The minimum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double minimumDouble(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -754,6 +912,7 @@ public double minimumDouble(String fieldName) {
      * Find the minimum value of a field
      * @param fieldName  The field name
      * @return The minimum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public float minimumFloat(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -764,6 +923,7 @@ public float minimumFloat(String fieldName) {
      * Find the minimum value of a field
      * @param fieldName  The field name
      * @return The minimum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public Date minimumDate(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -776,6 +936,7 @@ public Date minimumDate(String fieldName) {
      * Find the maximum value of a field
      * @param fieldName  The field name
      * @return The maximum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public long maximumInt(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -786,6 +947,7 @@ public long maximumInt(String fieldName) {
      * Find the maximum value of a field
      * @param fieldName  The field name
      * @return The maximum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public double maximuDouble(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -796,6 +958,7 @@ public double maximuDouble(String fieldName) {
      * Find the maximum value of a field
      * @param fieldName  The field name
      * @return The maximum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public float maximuFloat(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -806,6 +969,7 @@ public float maximuFloat(String fieldName) {
      * Find the maximum value of a field
      * @param fieldName  The field name
      * @return The maximum value
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public Date maximumDate(String fieldName) {
         int columnIndex = columns.get(fieldName);
@@ -816,6 +980,7 @@ public Date maximumDate(String fieldName) {
      * Count the number of matching objects
      *
      * @return The number of matching objects
+     * @throws java.lang.UnsupportedOperationException The query is not valid ("syntax error")
      */
     public long count() {
         return this.query.count();
@@ -827,6 +992,7 @@ public long count() {
      * Find all objects that fulfill the query condition
      * @return A list of objects
      * @see io.realm.RealmResults
+     * @throws java.lang.RuntimeException Any other error
      */
     public RealmResults<E> findAll() {
         return new RealmResults<E>(realm, query.findAll(), clazz);
@@ -836,6 +1002,7 @@ public long count() {
      * Find the first object that fulfills the query condition
      * @return An object
      * @see io.realm.RealmObject
+     * @throws java.lang.RuntimeException Any other error
      */
     public E findFirst() {
         RealmResults<E> result = findAll();
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
index b664a0d005..bf93ba6a96 100644
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ b/realm/src/main/java/io/realm/RealmResults.java
@@ -28,8 +28,17 @@
 import io.realm.internal.TableView;
 
 /**
+ * A RealmResults list contains a list of objects of a given type that matches the query.
+ * The objects are not copied from the Realm to the RealmResults list, but just references the original objects.
+ * This preserves memory and increase speed.
+ * It also implies that any modification to any object in a RealmResults is reflected in the objects in the 
+ * Realm that was queried.
+ * Updates to objects must be done within a transaction and the modified object is persisted to the backing
+ * Realm file during the commit of the transaction.
  *
  * @param <E> The class of objects in this list
+ * @see RealmQuery#findAll()
+ * @see Realm#allObjects(Class)
  */
 public class RealmResults<E extends RealmObject> extends AbstractList<E> {
 
@@ -54,9 +63,6 @@ Realm getRealm() {
         return realm;
     }
 
-    /**
-     * @hide
-     */
     TableOrView getTable() {
         if (table == null) {
             return realm.getTable(classSpec);
@@ -115,7 +121,8 @@ public E last() {
 
     /**
      * Get a sorted (ascending) RealmList from an existing RealmList.
-     *
+     * Only fields of type boolean, short, int, long, float, double, Date, and String are supported.
+     * 
      * @param fieldName  The field name to sort by.
      * @return           A sorted RealmResults list
      */
@@ -125,19 +132,20 @@ public E last() {
 
     /**
      * Get a sorted RealmList from an existing RealmList.
+     * Only fields of type boolean, short, int, long, float, double, Date, and String are supported.
      *
-     * @param fieldName  The field name to sort by.
-     * @param sortOrder  The direction to sort by; if true ascending, if false descending
-     *                   You can use the constants SORT_ORDER_ASCENDING and SORT_ORDER_DECENDING
-     *                   to write more readable code.
-     * @return           A sorted RealmResults list.
+     * @param fieldName      The field name to sort by.
+     * @param sortAscending  The direction to sort by; if true ascending, otherwise descending
+     *                       You can use the constants SORT_ORDER_ASCENDING and SORT_ORDER_DECENDING
+     *                       for readability.
+     * @return               A sorted RealmResults list.
      */
-    public RealmResults<E> sort(String fieldName, boolean sortOrder) {
+    public RealmResults<E> sort(String fieldName, boolean sortAscending) {
         TableView sorted;
 
         TableOrView table = getTable();
         long columnIndex = table.getColumnIndex(fieldName);
-        TableView.Order TVOrder = sortOrder? TableView.Order.ascending : TableView.Order.descending;
+        TableView.Order TVOrder = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
 
         if (table instanceof TableView) {
             TableView v = (TableView)table;
@@ -169,7 +177,7 @@ public int size() {
      * @param fieldName   The field to look for a minimum on. Only int, float, and double
      *                    are supported.
      * @return            The minimum value.
-     * @throws            java.lang.RuntimeException if field is not int, float or double.
+     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
      */
     public Number min(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
@@ -181,7 +189,7 @@ public Number min(String fieldName) {
             case DOUBLE:
                 return table.minimumDouble(columnIndex);
             default:
-                throw new RuntimeException("Wrong type of field. Expected int, float or double type.");
+                throw new IllegalArgumentException("Wrong type of field. Expected int, float or double type.");
         }
     }
 
@@ -191,7 +199,7 @@ public Number min(String fieldName) {
      * @param fieldName  The field to look for the minimum date. If fieldName is not of Date type,
      *                   an exception is thrown.
      * @return           The minimum date.
-     * @throws           java.lang.RuntimeException if fieldName is not a Date field.
+     * @throws           java.lang.IllegalArgumentException if fieldName is not a Date field.
      */
     public Date minDate(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
@@ -199,7 +207,7 @@ public Date minDate(String fieldName) {
             return table.minimumDate(columnIndex);
         }
         else {
-            throw new RuntimeException("Wrong type of field - Date type expected.");
+            throw new IllegalArgumentException("Wrong type of field - Date type expected.");
         }
     }
 
@@ -208,7 +216,7 @@ public Date minDate(String fieldName) {
      *
      * @param fieldName   The field to look for a maximum on. Only int, float, and double are supported.
      * @return            The maximum value.
-     * @throws            java.lang.RuntimeException if field is not int, float or double.
+     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
      */
     public Number max(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
@@ -220,7 +228,7 @@ public Number max(String fieldName) {
             case DOUBLE:
                 return table.maximumDouble(columnIndex);
             default:
-                throw new RuntimeException("Wrong type of field. Expected int, float or double type.");
+                throw new IllegalArgumentException("Wrong type of field. Expected int, float or double type.");
         }
     }
 
@@ -230,7 +238,7 @@ public Number max(String fieldName) {
      * @param fieldName  The field to look for the maximum date. If fieldName is not of Date type,
      *                   an exception is thrown.
      * @return           The maximum date.
-     * @throws           java.lang.RuntimeException if fieldName is not a Date field.
+     * @throws           java.lang.IllegalArgumentException if fieldName is not a Date field.
      */
     public Date maxDate(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
@@ -238,7 +246,7 @@ public Date maxDate(String fieldName) {
             return table.minimumDate(columnIndex);
         }
         else {
-            throw new RuntimeException("Wrong type of field - Date expected");
+            throw new IllegalArgumentException("Wrong type of field - Date expected");
         }
     }
 
@@ -248,7 +256,7 @@ public Date maxDate(String fieldName) {
      *
      * @param fieldName   The field to sum. Only int, float, and double are supported.
      * @return            The sum.
-     * @throws            java.lang.RuntimeException if field is not int, float or double.
+     * @throws            java.lang.IllegalArgumentException if field is not int, float or double.
      */
 
     public Number sum(String fieldName) {
@@ -261,7 +269,7 @@ public Number sum(String fieldName) {
             case DOUBLE:
                 return table.sumDouble(columnIndex);
             default:
-                throw new RuntimeException("Wrong type of field. Expected int, float or double type.");
+                throw new IllegalArgumentException("Wrong type of field. Expected int, float or double type.");
         }
     }
 
@@ -273,7 +281,7 @@ public Number sum(String fieldName) {
      *                   float and double are supported.
      * @return           The average for the given field amongst objects in an RealmList. This
      *                   will be of type double for both float and double field.
-     * @throws           java.lang.RuntimeException if field is not int, float or double.
+     * @throws           java.lang.IllegalArgumentException if field is not int, float or double.
      */
     public double average(String fieldName) {
         long columnIndex = table.getColumnIndex(fieldName);
@@ -285,7 +293,7 @@ public double average(String fieldName) {
             case FLOAT:
                 return table.averageFloat(columnIndex);
             default:
-                throw new RuntimeException("Wrong type of field. Expected int, float or double type.");
+                throw new IllegalArgumentException("Wrong type of field. Expected int, float or double type.");
         }
     }
 
diff --git a/realm/src/main/java/io/realm/annotations/Index.java b/realm/src/main/java/io/realm/annotations/Index.java
new file mode 100644
index 0000000000..a7e3475925
--- /dev/null
+++ b/realm/src/main/java/io/realm/annotations/Index.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+/**
+ * The @Index annotation will add a search index to the field. A search index will make the
+ * Realm file larger but search operations and queries will be faster.
+ * NOTICE: only String fields can be indexed.
+ */
+public @interface Index {
+
+}
diff --git a/realm/src/main/java/io/realm/exceptions/RealmException.java b/realm/src/main/java/io/realm/exceptions/RealmException.java
index 2012e1d954..04873de473 100644
--- a/realm/src/main/java/io/realm/exceptions/RealmException.java
+++ b/realm/src/main/java/io/realm/exceptions/RealmException.java
@@ -16,6 +16,9 @@
 
 package io.realm.exceptions;
 
+/**
+ * RealmException is Realm specific exceptions.
+ */
 public class RealmException extends RuntimeException {
     public RealmException(String detailMessage) {
         super(detailMessage);
diff --git a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
index 4f65915e85..88c7bdf5be 100644
--- a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal;
 
+import io.realm.exceptions.RealmException;
+
 public class ImplicitTransaction extends Group {
 
     private final SharedGroup parent;
@@ -30,8 +32,12 @@ public void advanceRead() {
     }
 
     public void promoteToWrite() {
-        immutable = false;
-        parent.promoteToWrite();
+        if (immutable) {
+            immutable = false;
+            parent.promoteToWrite();
+        } else {
+            throw new RealmException("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().");
+        }
     }
 
     public void commitAndContinueAsRead() {
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/src/main/java/io/realm/internal/Table.java
index 4c087b841a..c76dedb86e 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/src/main/java/io/realm/internal/Table.java
@@ -1351,19 +1351,6 @@ public TableView findAllString(long columnIndex, String value) {
 
     protected native long nativeFindAllString(long nativePtr, long columnIndex, String value);
 
-    // Requires that the first column is a string column with unique values. Index is not required, but will result in better performance
-    @Override
-    public long lookup(String value) {
-        if (value == null)
-            throw new IllegalArgumentException("String must not be null.");
-        if (this.getColumnType(0) != ColumnType.STRING)
-            throw new UnsupportedOperationException("lookup() requires column 0 is a String column.");
-        return nativeLookup(nativePtr, value);
-    }
-
-    protected native long nativeLookup(long nativeTablePtr, String value);
-
-
     // Experimental feature
     @Override
     public long lowerBoundLong(long columnIndex, long value) {
diff --git a/realm/src/main/java/io/realm/internal/TableOrView.java b/realm/src/main/java/io/realm/internal/TableOrView.java
index 298d371b9b..304168d1ba 100644
--- a/realm/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/src/main/java/io/realm/internal/TableOrView.java
@@ -308,8 +308,6 @@
 
     // Experimental:
 
-    long lookup(String value);
-
     long count(long columnIndex, String value);
 
     public enum PivotType {
diff --git a/realm/src/main/java/io/realm/internal/TableView.java b/realm/src/main/java/io/realm/internal/TableView.java
index 12de78c029..ed7b015e74 100644
--- a/realm/src/main/java/io/realm/internal/TableView.java
+++ b/realm/src/main/java/io/realm/internal/TableView.java
@@ -908,12 +908,6 @@ private void throwImmutable() {
     protected final Table parent;
     private final Context context;
 
-    @Override
-    public long lookup(String value) {
-        // TODO: implement
-        throw new RuntimeException("Not implemented yet.");
-    }
-
     @Override
     public long count(long columnIndex, String value) {
         // TODO: implement
diff --git a/realm/src/main/java/io/realm/internal/android/LooperThread.java b/realm/src/main/java/io/realm/internal/android/LooperThread.java
index c9692a1b68..7edd0d18c2 100644
--- a/realm/src/main/java/io/realm/internal/android/LooperThread.java
+++ b/realm/src/main/java/io/realm/internal/android/LooperThread.java
@@ -19,7 +19,10 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.util.Log;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
@@ -29,9 +32,12 @@
 public class LooperThread extends Thread {
     // Message types
     public static final int REALM_CHANGED  = 3;
-
     public static final Map<Handler, Integer> handlers = new ConcurrentHashMap<Handler, Integer>();
+
     public Handler handler;
+    public List<RuntimeException> exceptions = new ArrayList<RuntimeException>();
+
+    private static final String TAG = LooperThread.class.getName();
     private static LooperThread instance;
 
     // private because it's a singleton
@@ -59,8 +65,16 @@ public void handleMessage(Message message) {
                 if (message.arg1 == REALM_CHANGED) {
                     for (Map.Entry<Handler, Integer> entry : handlers.entrySet()) {
                         if (entry.getValue() == message.arg2) {
-                            if (!entry.getKey().hasMessages(REALM_CHANGED)) {
-                                entry.getKey().sendEmptyMessage(REALM_CHANGED);
+                            Handler currentHandler = entry.getKey();
+                            if (currentHandler.getLooper().getThread().isAlive() &&
+                                !currentHandler.hasMessages(REALM_CHANGED))
+                            {
+                                try {
+                                    currentHandler.sendEmptyMessage(REALM_CHANGED);
+                                } catch (RuntimeException e) {
+                                    exceptions.add(e);
+                                    Log.w(TAG, e.getMessage());
+                                }
                             }
                         }
                     }
diff --git a/version.txt b/version.txt
index d92356fdb8..67d5f802ff 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.70.1
\ No newline at end of file
+0.72.0
\ No newline at end of file
