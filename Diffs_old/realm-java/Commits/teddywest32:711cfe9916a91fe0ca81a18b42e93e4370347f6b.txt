diff --git a/CHANGELOG.md b/CHANGELOG.md
index 733550ade9..742b9df30c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,74 @@
+## 1.1.0
+
+### Enhancements
+
+* Enhanced `Table.toString()` to show a PrimaryKey field details (#2903).
+
+## 1.0.1
+
+### Bug fixes
+
+* Fixed a crash when calling `Table.toString()` in debugger (#2429).
+* Revised `RealmResults.isLoaded()` description (#2895).
+
+### Enhancements
+
+* Removes RxJava related APIs during bytecode transforming to make RealmObject plays well with reflection when rx.Observable doesn't exist.
+
+## 1.0.0
+
+No changes since 0.91.1.
+
+## 0.91.1
+
+* Updated Realm Core to 1.0.1.
+
+### Bug fixes
+
+* Fixed a bug when opening a Realm cause a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported". 
+
+## 0.91.0
+
+* Updated Realm Core to 1.0.0.
+
+### Breaking changes
+
+* Removed all `@Deprecated` methods.
+* Calling `Realm.setAutoRefresh()` or `DynamicRealm.setAutoRefresh()` from non-Looper thread throws `IllegalStateException` even if the `autoRefresh` is false (#2820).
+
+### Bug fixes
+
+* Calling RealmResults.deleteAllFromRealm() might lead to native crash (#2759).
+* The annotation processor now correctly reports an error if trying to reference interfaces in model classes (#2808).
+* Added null check to `addChangeListener` and `removeChangeListener` in `Realm` and `DynamicRealm` (#2772).
+* Calling `RealmObjectSchema.addPrimaryKey()` adds an index to the primary key field, and calling `RealmObjectSchema.removePrimaryKey()` removes the index from the field (#2832).
+* Log files are not deleted when calling `Realm.deleteRealm()` (#2834).
+
+### Enhancements
+
+* Upgrading to OpenSSL 1.0.1t. From July 11, 2016, Google Play only accept apps using OpenSSL 1.0.1r or later (https://support.google.com/faqs/answer/6376725, #2749).
+* Added support for automatically copying an initial database from assets using `RealmConfiguration.Builder.assetFile()`.
+* Better error messages when certain file operations fail.
+
+### Credits
+
+* Paweł Surówka (@thesurix) for adding the `RealmConfiguration.Builder.assetFile()`.
+
+## 0.90.1
+
+* Updated Realm Core to 0.100.2.
+
+### Bug fixes
+
+* Opening a Realm while closing a Realm in another thread could lead to a race condition.
+* Automatic migration to the new file format could in rare circumstances lead to a crash.
+* Fixing a race condition that may occur when using Async API (#2724).
+* Fixed CannotCompileException when related class definition in android.jar cannot be found (#2703).
+
+### Enhancements
+
+* Prints path when file related exceptions are thrown.
+
 ## 0.90.0
 
 * Updated Realm Core to 0.100.0.
@@ -255,7 +326,7 @@
 * BREAKING CHANGE: Realm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
 * BREAKING CHANGE: RealmQuery.isNull() and RealmQuery.isNotNull() now throw IllegalArgumentException instead of RealmError if the fieldname is a linked field and the last element is a link (#1693).
 * Added Realm.isEmpty().
-* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (standalone, removed, closed, from different Realm) object (#1749).
+* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (unmanaged, removed, closed, from different Realm) object (#1749).
 * Attempting to refresh a Realm while a transaction is in process will now throw an IllegalStateException (#1712).
 * The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle)
 * Updated Realm Core to 0.95.
@@ -350,7 +421,7 @@
 * Deprecated Realm.migrateRealmAtPath(). It has been replaced by Realm.migrateRealm(RealmConfiguration).
 * Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
 * Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
-* RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
+* RealmList.add(), RealmList.addAt() and RealmList.set() now copy unmanaged objects transparently into Realm.
 * Realm now works with Kotlin (M12+). (Thank you @cypressious)
 * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
 * Added a check to give a better error message when null is used as value for a primary key.
@@ -438,7 +509,7 @@
 * Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
 * Added more logging capabilities at the JNI level.
 * Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
-* Added support for standalone objects and custom constructors.
+* Added support for unmanaged objects and custom constructors.
 * Added more precise imports in proxy classes to avoid ambiguous references.
 * Added support for executing a transaction with a closure using Realm.executeTransaction().
 * Added RealmObject.isValid() to test if an object is still accessible.
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index ae1a793a9e..117abc2ef9 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -56,7 +56,7 @@ When writing unit tests, use the following guide lines:
 5) Use the `@RunInLooperThread` rule for any test that depends on Realms notification system. 
 
 6) Input-parameters should be boundary tested. Especially `Null/NotNull`, but also the state of Realm objects like
-   standalone objects, deleted objects, objects from other threads.
+   unmanaged objects, deleted objects, objects from other threads.
 
 7) Unit tests are not required to only have 1 test. It is acceptable to combine multiple tests into one unit test, but
    if it fails, it should be clear why it failed. E.g. you can group related tests with the same setup like negative 
diff --git a/README.md b/README.md
index 1638d47c8e..285431ba15 100644
--- a/README.md
+++ b/README.md
@@ -114,7 +114,7 @@ That command will generate:
  * `./gradlew monkeyExamples` will run the monkey tests on all the examples
  * `./gradlew installRealmJava` will install the Realm library and plugin to mavenLocal()
  * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This saves recompilation time a lot.
- * `./gradlew connectedCheck -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
+ * `./gradlew connectedUnitTests -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
 
 Generating the Javadoc using the command above will report a large number of warnings. The Javadoc is generated, and we will fix the issue in the near future.
 
@@ -137,6 +137,10 @@ so each sub-project must be opened in its own window.
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 
+This project adheres to the [Contributor Covenant Code of Conduct](https://realm.io/conduct).
+By participating, you are expected to uphold this code. Please report
+unacceptable behavior to [info@realm.io](mailto:info@realm.io).
+
 ## License
 
 Realm Java is published under the Apache 2.0 license.
diff --git a/build.gradle b/build.gradle
index 8f2e675aba..a5770bd504 100644
--- a/build.gradle
+++ b/build.gradle
@@ -69,12 +69,21 @@ task check(type:GradleBuild) {
     }
 }
 
-task connectedCheck(type:GradleBuild) {
+task integrationTestsConnectedCheck(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the integration tests of the Realm project'
+    dependsOn installTransformer
+    buildFile = file('integration-tests/build.gradle')
+    tasks = ['connectedCheck']
+}
+
+task connectedUnitTests(type:GradleBuild) {
     group = 'Test'
     description = 'Run the Android unit tests of the Realm project'
     dependsOn installTransformer
+    dependsOn integrationTestsConnectedCheck
     buildFile = file('realm/build.gradle')
-    tasks = ['connectedCheck']
+    tasks = ['connectedUnitTests']
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -172,10 +181,6 @@ task distributionPackage(type:Zip) {
     from('changelog.txt')
     from('LICENSE')
     from('version.txt')
-    from("${buildDir}/outputs/gradle") {
-        include "realm-android-${currentVersion}.jar"
-        into 'gradle'
-    }
     from('realm/realm-library/build/libs') {
         include 'realm-android-${currentVersion}-javadoc.jar'
         into 'docs'
@@ -192,6 +197,19 @@ task distributionPackage(type:Zip) {
     }
 }
 
+task distributionJniUnstrippedPackage(type:Zip) {
+    description = 'Generate native libs package with debug symbols'
+    dependsOn assembleRealm
+
+    group = 'Artifact'
+    archiveName = "realm-java-jni-libs-unstripped-${currentVersion}.zip"
+    destinationDir = file("${buildDir}/outputs/distribution")
+
+    from("realm/realm-jni/build/outputs/jniLibs-unstripped") {
+        include '**/*.so'
+    }
+}
+
 task cleanRealm(type:GradleBuild) {
     description = 'Clean the Realm project'
     group = 'Clean'
@@ -238,7 +256,9 @@ task uploadDistributionPackage(type: Exec) {
     group = 'Release'
     description = 'Upload the distribution package to S3'
     dependsOn distributionPackage
+    dependsOn distributionJniUnstrippedPackage
     commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-jni-libs-unstripped-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
 }
 
 task createEmptyFile(type: Exec) {
diff --git a/examples/build.gradle b/examples/build.gradle
index c1c2682d7a..f8e6fe2e64 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -13,11 +13,12 @@ allprojects {
         repositories {
             mavenLocal()
             jcenter()
+            maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:1.5.0'
+            classpath 'com.android.tools.build:gradle:2.1.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
             classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
index 7b70163cfe..edf66fdaef 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
@@ -53,13 +53,16 @@ protected void onCreate(Bundle savedInstanceState) {
         realm = Realm.getInstance(realmConfiguration);
 
         // Everything continues to work as normal except for that the file is encrypted on disk
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName("Happy Person");
-        person.setAge(14);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Person person = realm.createObject(Person.class);
+                person.setName("Happy Person");
+                person.setAge(14);
+            }
+        });
 
-        person = realm.where(Person.class).findFirst();
+        Person person = realm.where(Person.class).findFirst();
         Log.i(TAG, String.format("Person name: %s", person.getName()));
     }
 
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index c308278d72..759b451b8c 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -129,12 +129,15 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         City modifiedCity = (City)mAdapter.getItem(position);
 
         // Acquire the RealmObject matching the name of the clicked City.
-        City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
+        final City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
 
         // Create a transaction to increment the vote count for the selected City in the realm
-        realm.beginTransaction();
-        city.setVotes(city.getVotes() + 1);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                city.setVotes(city.getVotes() + 1);
+            }
+        });
 
         updateCities();
     }
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index 13f6b1be4c..668f954d24 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -92,37 +92,44 @@ private void basicCRUD(Realm realm) {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction();
-
-        // Add a person
-        Person person = realm.createObject(Person.class);
-        person.setId(1);
-        person.setName("Young Person");
-        person.setAge(14);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // Add a person
+                Person person = realm.createObject(Person.class);
+                person.setId(1);
+                person.setName("Young Person");
+                person.setAge(14);
 
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction();
+            }
+        });
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person.class).findFirst();
+        final Person person = realm.where(Person.class).findFirst();
         showStatus(person.getName() + ":" + person.getAge());
 
         // Update person in a transaction
-        realm.beginTransaction();
-        person.setName("Senior Person");
-        person.setAge(99);
-        showStatus(person.getName() + " got older: " + person.getAge());
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person.setName("Senior Person");
+                person.setAge(99);
+                showStatus(person.getName() + " got older: " + person.getAge());
+            }
+        });
 
         // Delete all persons
-        realm.beginTransaction();
-        realm.allObjects(Person.class).deleteAllFromRealm();
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
     }
 
     private void basicQuery(Realm realm) {
         showStatus("\nPerforming basic Query operation...");
-        showStatus("Number of persons: " + realm.allObjects(Person.class).size());
+        showStatus("Number of persons: " + realm.where(Person.class).count());
 
         RealmResults<Person> results = realm.where(Person.class).equalTo("age", 99).findAll();
 
@@ -131,7 +138,7 @@ private void basicQuery(Realm realm) {
 
     private void basicLinkQuery(Realm realm) {
         showStatus("\nPerforming basic Link Query operation...");
-        showStatus("Number of persons: " + realm.allObjects(Person.class).size());
+        showStatus("Number of persons: " + realm.where(Person.class).count());
 
         RealmResults<Person> results = realm.where(Person.class).equalTo("cats.name", "Tiger").findAll();
 
@@ -146,35 +153,38 @@ private String complexReadWrite() {
         Realm realm = Realm.getInstance(realmConfig);
 
         // Add ten persons in one transaction
-        realm.beginTransaction();
-        Dog fido = realm.createObject(Dog.class);
-        fido.name = "fido";
-        for (int i = 0; i < 10; i++) {
-            Person person = realm.createObject(Person.class);
-            person.setId(i);
-            person.setName("Person no. " + i);
-            person.setAge(i);
-            person.setDog(fido);
-
-            // The field tempReference is annotated with @Ignore.
-            // This means setTempReference sets the Person tempReference
-            // field directly. The tempReference is NOT saved as part of
-            // the RealmObject:
-            person.setTempReference(42);
-
-            for (int j = 0; j < i; j++) {
-                Cat cat = realm.createObject(Cat.class);
-                cat.name = "Cat_" + j;
-                person.getCats().add(cat);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Dog fido = realm.createObject(Dog.class);
+                fido.name = "fido";
+                for (int i = 0; i < 10; i++) {
+                    Person person = realm.createObject(Person.class);
+                    person.setId(i);
+                    person.setName("Person no. " + i);
+                    person.setAge(i);
+                    person.setDog(fido);
+
+                    // The field tempReference is annotated with @Ignore.
+                    // This means setTempReference sets the Person tempReference
+                    // field directly. The tempReference is NOT saved as part of
+                    // the RealmObject:
+                    person.setTempReference(42);
+
+                    for (int j = 0; j < i; j++) {
+                        Cat cat = realm.createObject(Cat.class);
+                        cat.name = "Cat_" + j;
+                        person.getCats().add(cat);
+                    }
+                }
             }
-        }
-        realm.commitTransaction();
+        });
 
         // Implicit read transactions allow you to access your objects
-        status += "\nNumber of persons: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Iterate over all objects
-        for (Person pers : realm.allObjects(Person.class)) {
+        for (Person pers : realm.where(Person.class).findAll()) {
             String dogName;
             if (pers.getDog() == null) {
                 dogName = "None";
@@ -185,9 +195,8 @@ private String complexReadWrite() {
         }
 
         // Sorting
-        RealmResults<Person> sortedPersons = realm.allObjects(Person.class);
-        sortedPersons.sort("age", Sort.DESCENDING);
-        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.allObjects(Person.class).first()
+        RealmResults<Person> sortedPersons = realm.where(Person.class).findAllSorted("age", Sort.DESCENDING);
+        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.where(Person.class).findFirst()
                 .getName();
 
         realm.close();
@@ -198,7 +207,7 @@ private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
         Realm realm = Realm.getInstance(realmConfig);
-        status += "\nNumber of persons: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Find all persons where age between 7 and 9 and name begins with "Person".
         RealmResults<Person> results = realm.where(Person.class)
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
index e2fbb7bfbd..233a563017 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
@@ -88,7 +88,7 @@ protected void onDestroy() {
         loadJsonFromJsonObject();
         loadJsonFromString();
 
-        return realm.allObjects(City.class);
+        return realm.where(City.class).findAll();
     }
 
     private void loadJsonFromStream() throws IOException {
@@ -115,18 +115,24 @@ private void loadJsonFromJsonObject() {
         Map<String, String> city = new HashMap<String, String>();
         city.put("name", "København");
         city.put("votes", "9");
-        JSONObject json = new JSONObject(city);
+        final JSONObject json = new JSONObject(city);
 
-        realm.beginTransaction();
-        realm.createObjectFromJson(City.class, json);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObjectFromJson(City.class, json);
+            }
+        });
     }
 
     private void loadJsonFromString() {
-        String json = "{ name: \"Aarhus\", votes: 99 }";
+        final String json = "{ name: \"Aarhus\", votes: 99 }";
 
-        realm.beginTransaction();
-        realm.createObjectFromJson(City.class, json);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObjectFromJson(City.class, json);
+            }
+        });
     }
 }
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 3e35bbf2e9..6a94f78e9f 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,7 +1,8 @@
 buildscript {
-    ext.kotlin_version = '1.0.1-2'
+    ext.kotlin_version = '1.0.2'
     repositories {
         jcenter()
+        mavenCentral()
     }
     dependencies {
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 37c16e37c0..5c6c37f1ec 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -66,7 +66,7 @@ class KotlinExampleActivity : Activity() {
         // Using executeTransaction with a lambda reduces code size and makes it impossible
         // to forget to commit the transaction.
         realm.executeTransaction {
-            realm.allObjects(Person::class.java).deleteAllFromRealm()
+            realm.delete(Person::class.java)
         }
 
         // More complex operations can be executed on another thread, for example using
@@ -98,32 +98,29 @@ class KotlinExampleActivity : Activity() {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...")
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction()
-
-        // Add a person
-        var person = realm.createObject(Person::class.java)
-        person.id = 1
-        person.name = "Young Person"
-        person.age = 14
-
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction()
+        realm.executeTransaction {
+            // Add a person
+            var person = realm.createObject(Person::class.java)
+            person.id = 1
+            person.name = "Young Person"
+            person.age = 14
+        }
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person::class.java).findFirst()
+        var person = realm.where(Person::class.java).findFirst()
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
-        realm.beginTransaction()
-        person.name = "Senior Person"
-        person.age = 99
-        showStatus(person.name + " got older: " + person.age)
-        realm.commitTransaction()
+        realm.executeTransaction {
+            person.name = "Senior Person"
+            person.age = 99
+            showStatus(person.name + " got older: " + person.age)
+        }
     }
 
     private fun basicQuery(realm: Realm) {
         showStatus("\nPerforming basic Query operation...")
-        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
 
         val results = realm.where(Person::class.java).equalTo("age", 99).findAll()
 
@@ -132,7 +129,7 @@ class KotlinExampleActivity : Activity() {
 
     private fun basicLinkQuery(realm: Realm) {
         showStatus("\nPerforming basic Link Query operation...")
-        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
 
         val results = realm.where(Person::class.java).equalTo("cats.name", "Tiger").findAll()
 
@@ -147,35 +144,35 @@ class KotlinExampleActivity : Activity() {
         val realm = Realm.getInstance(realmConfig)
 
         // Add ten persons in one transaction
-        realm.beginTransaction()
-        val fido = realm.createObject(Dog::class.java)
-        fido.name = "fido"
-        for (i in 0..9) {
-            val person = realm.createObject(Person::class.java)
-            person.id = i.toLong()
-            person.name = "Person no. $i"
-            person.age = i
-            person.dog = fido
-
-            // The field tempReference is annotated with @Ignore.
-            // This means setTempReference sets the Person tempReference
-            // field directly. The tempReference is NOT saved as part of
-            // the RealmObject:
-            person.tempReference = 42
-
-            for (j in 0..i - 1) {
-                val cat = realm.createObject(Cat::class.java)
-                cat.name = "Cat_$j"
-                person.cats.add(cat)
+        realm.executeTransaction {
+            val fido = realm.createObject(Dog::class.java)
+            fido.name = "fido"
+            for (i in 0..9) {
+                val person = realm.createObject(Person::class.java)
+                person.id = i.toLong()
+                person.name = "Person no. $i"
+                person.age = i
+                person.dog = fido
+
+                // The field tempReference is annotated with @Ignore.
+                // This means setTempReference sets the Person tempReference
+                // field directly. The tempReference is NOT saved as part of
+                // the RealmObject:
+                person.tempReference = 42
+
+                for (j in 0..i - 1) {
+                    val cat = realm.createObject(Cat::class.java)
+                    cat.name = "Cat_$j"
+                    person.cats.add(cat)
+                }
             }
         }
-        realm.commitTransaction()
 
         // Implicit read transactions allow you to access your objects
-        status += "\nNumber of persons: ${realm.allObjects(Person::class.java).size}"
+        status += "\nNumber of persons: ${realm.where(Person::class.java).count()}"
 
         // Iterate over all objects
-        for (person in realm.allObjects(Person::class.java)) {
+        for (person in realm.where(Person::class.java).findAll()) {
             val dogName: String = person?.dog?.name ?: "None"
 
             status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
@@ -187,10 +184,9 @@ class KotlinExampleActivity : Activity() {
         }
 
         // Sorting
-        val sortedPersons = realm.allObjects(Person::class.java)
-        sortedPersons.sort("age", Sort.DESCENDING)
-        check(realm.allObjects(Person::class.java).last().name == sortedPersons.first().name)
-        status += "\nSorting ${sortedPersons.last().name} == ${realm.allObjects(Person::class.java).first().name}"
+        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING);
+        check(realm.where(Person::class.java).findAll().last().name == sortedPersons.first().name)
+        status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
         realm.close()
         return status
@@ -203,7 +199,7 @@ class KotlinExampleActivity : Activity() {
         // extension method 'use' (pun intended).
         Realm.getInstance(realmConfig).use {
             // 'it' is the implicit lambda parameter of type Realm
-            status += "\nNumber of persons: ${it.allObjects(Person::class.java).size}"
+            status += "\nNumber of persons: ${it.where(Person::class.java).count()}"
 
             // Find all persons where age between 7 and 9 and name begins with "Person".
             val results = it
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index 32d9eb77f9..c96ccdabc4 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -121,7 +121,7 @@ private String copyBundledRealmFile(InputStream inputStream, String outFileName)
 
     private String realmString(Realm realm) {
         StringBuilder stringBuilder = new StringBuilder();
-        for (Person person : realm.allObjects(Person.class)) {
+        for (Person person : realm.where(Person.class).findAll()) {
             stringBuilder.append(person.toString()).append("\n");
         }
 
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 1d36960fda..12d4c014bb 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -78,7 +78,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // Multiple Realms can be open at the same time
         showStatus("Opening multiple Realms");
         Realm defaultRealm = Realm.getInstance(defaultConfig);
-        Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
+        final Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
         Realm exoticRealm = Realm.getInstance(exoticAnimalsConfig);
 
         // Objects can be added to each Realm independantly
@@ -120,10 +120,14 @@ public void execute(Realm realm) {
         showStatus("Copy objects between Realms");
         showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
         showStatus("Copy pig from defaultRealm to farmRealm");
-        Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
-        farmRealm.beginTransaction();
-        farmRealm.copyToRealm(defaultPig);
-        farmRealm.commitTransaction();
+        final Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
+        farmRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.copyToRealm(defaultPig);
+            }
+        });
+
         showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
 
         // Each Realm is restricted to only accept the classes in their schema.
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
index 9e19a30e2a..f33c90cbbd 100644
--- a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -52,13 +52,16 @@ public long getNoOfAnimals() {
         return realm.where(Cat.class).count();
     }
 
-    public void addAnimals(int count) {
-        realm.beginTransaction();
-        for (int i = 0; i < count; i++) {
-            Cat cat = realm.createObject(Cat.class);
-            cat.setName("Cat " + i);
-        }
-        realm.commitTransaction();
+    public void addAnimals(final int count) {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < count; i++) {
+                    Cat cat = realm.createObject(Cat.class);
+                    cat.setName("Cat " + i);
+                }
+            }
+        });
     }
 
     public void close() {
diff --git a/examples/newsreaderExample/src/release/AndroidManifest.xml b/examples/newsreaderExample/src/release/AndroidManifest.xml
index d044658dcf..815e4d18c1 100644
--- a/examples/newsreaderExample/src/release/AndroidManifest.xml
+++ b/examples/newsreaderExample/src/release/AndroidManifest.xml
@@ -2,5 +2,5 @@
 <manifest package="io.realm.examples.newsreader"
           xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <application android:name=".DebugNewsReaderApplication"/>
+    <application android:name=".ReleaseNewsReaderApplication"/>
 </manifest>
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
index 59e25bace0..fcfd43d85e 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -77,7 +77,7 @@ protected void onResume() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                realm.allObjectsSorted(Person.class, "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
+                realm.where(Person.class).findAllSorted( "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
             }
         });
 
@@ -144,7 +144,7 @@ public Person call(Realm realm) {
 
         // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
         // that all objects in the cache will contain the same data.
-        // Either avoid using buffer or copy data into an un-managed object.
+        // Either avoid using buffer or copy data into an unmanaged object.
         return personObserver
                 .buffer(2)
                 .subscribe(new Action1<List<Person>>() {
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index 73a177e8a3..c3b567d105 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -86,17 +86,20 @@ private void showStatus(String txt) {
         protected Integer doInBackground(Void... params) {
             Realm realm = Realm.getDefaultInstance();
 
-            realm.beginTransaction();
-            realm.clear(Score.class);
-            for (int i = 0; i < TEST_OBJECTS; i++) {
-                if (isCancelled()) break;
-                Score score = realm.createObject(Score.class);
-                score.setName("Name" + i);
-                score.setScore(i);
-            }
-            realm.commitTransaction();
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.delete(Score.class);
+                    for (int i = 0; i < TEST_OBJECTS; i++) {
+                        if (isCancelled()) break;
+                        Score score = realm.createObject(Score.class);
+                        score.setName("Name" + i);
+                        score.setScore(i);
+                    }
+                }
+            });
 
-            Number sum = realm.allObjects(Score.class).sum("score");
+            Number sum = realm.where(Score.class).sum("score");
             realm.close();
             return sum.intValue();
         }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
index 8ce4838613..8d50ca9919 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -97,13 +97,15 @@ public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
 
         realm = Realm.getDefaultInstance();
-        realm.beginTransaction();
-        person = realm.createObject(Person.class);
-        person.setName("Jane");
-        person.setAge(42);
-        person.setId(UUID.randomUUID().toString());
-        realm.commitTransaction();
-
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person = realm.createObject(Person.class);
+                person.setName("Jane");
+                person.setAge(42);
+                person.setId(UUID.randomUUID().toString());
+            }
+        });
         textContent.setText(person.toString());
     }
 
@@ -111,7 +113,7 @@ public void onActivityCreated(Bundle savedInstanceState) {
     public void onDestroy() {
         super.onDestroy();
         // Clear out all Person instances.
-        realm.clear(Person.class);
+        realm.delete(Person.class);
         realm.close();
     }
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index bc6396386a..43b9da847a 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -76,18 +76,24 @@ public boolean onOptionsItemSelected(MenuItem item) {
         switch(item.getItemId()) {
             case R.id.action_add_dot:
                 // Add blue dot from the UI thread
-                realm.beginTransaction();
-                Dot dot = realm.createObject(Dot.class);
-                dot.setX(random.nextInt(100));
-                dot.setY(random.nextInt(100));
-                dot.setColor(getResources().getColor(R.color.realm_blue));
-                realm.commitTransaction();
+                realm.executeTransaction(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        Dot dot = realm.createObject(Dot.class);
+                        dot.setX(random.nextInt(100));
+                        dot.setY(random.nextInt(100));
+                        dot.setColor(getResources().getColor(R.color.realm_blue));
+                    }
+                });
                 return true;
 
             case R.id.action_clear:
-                realm.beginTransaction();
-                realm.clear(Dot.class);
-                realm.commitTransaction();
+                realm.executeTransaction(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        realm.delete(Dot.class);
+                    }
+                });
                 return true;
 
             default:
@@ -108,7 +114,7 @@ public void onStart() {
         // Note that the query gets updated by rerunning it on the thread it was
         // created. This can negatively effect frame rates if it is a complicated query or a very
         // large data set.
-        dotsView.setRealmResults(realm.allObjects(Dot.class));
+        dotsView.setRealmResults(realm.where(Dot.class).findAll());
     }
 
     @Override
@@ -125,17 +131,19 @@ public void onResume() {
             public void run() {
                 // Realm instances cannot be shared between threads, so we need to create a new
                 // instance on the background thread.
-                int redColor = getResources().getColor(R.color.realm_red);
-                Realm backgroundThreadRealm = Realm.getDefaultInstance();
+                final int redColor = getResources().getColor(R.color.realm_red);
+                final Realm backgroundThreadRealm = Realm.getDefaultInstance();
                 while (!backgroundThread.isInterrupted()) {
-                    backgroundThreadRealm.beginTransaction();
-
-                    // Add red dot from the background thread
-                    Dot dot = backgroundThreadRealm.createObject(Dot.class);
-                    dot.setX(random.nextInt(100));
-                    dot.setY(random.nextInt(100));
-                    dot.setColor(redColor);
-                    backgroundThreadRealm.commitTransaction();
+                    backgroundThreadRealm.executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            // Add red dot from the background thread
+                            Dot dot = backgroundThreadRealm.createObject(Dot.class);
+                            dot.setX(random.nextInt(100));
+                            dot.setY(random.nextInt(100));
+                            dot.setColor(redColor);
+                        }
+                    });
 
                     // Wait 0.5 sec. before adding the next dot.
                     SystemClock.sleep(500);
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
index 757f0f5422..b918cdd6f4 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -85,9 +85,12 @@ public void onClick(View v) {
 
     private void cleanUp() {
         // Delete all persons
-        realm.beginTransaction();
-        realm.allObjects(Person.class).deleteAllFromRealm();
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
     }
 
     @Override
@@ -107,40 +110,45 @@ private void basicCRUD(Realm realm) {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction();
-
-        // Add a person
-        Person person = realm.createObject(Person.class);
-        person.setId(1);
-        person.setName("John Young");
-        person.setAge(14);
-
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // Add a person
+                Person person = realm.createObject(Person.class);
+                person.setId(1);
+                person.setName("John Young");
+                person.setAge(14);
+            }
+        });
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person.class).findFirst();
+        final Person person = realm.where(Person.class).findFirst();
         showStatus(person.getName() + ":" + person.getAge());
 
         // Update person in a transaction
-        realm.beginTransaction();
-        person.setName("John Senior");
-        person.setAge(89);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person.setName("John Senior");
+                person.setAge(89);
+            }
+        });
+
         showStatus(person.getName() + " got older: " + person.getAge());
-        realm.commitTransaction();
 
         // Add two more people
-        realm.beginTransaction();
-
-        Person jane = realm.createObject(Person.class);
-        jane.setName("Jane");
-        jane.setAge(27);
-
-        Person doug = realm.createObject(Person.class);
-        doug.setName("Robert");
-        doug.setAge(42);
-
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Person jane = realm.createObject(Person.class);
+                jane.setName("Jane");
+                jane.setAge(27);
+
+                Person doug = realm.createObject(Person.class);
+                doug.setName("Robert");
+                doug.setAge(42);
+            }
+        });
 
         RealmResults<Person> people = realm.where(Person.class).findAll();
         showStatus(String.format("Found %s people", people.size()));
@@ -153,7 +161,7 @@ private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
         Realm realm = Realm.getInstance(realmConfig);
-        status += "\nNumber of people in the DB: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of people in the DB: " + realm.where(Person.class).count();
 
         // Find all persons where age between 1 and 99 and name begins with "J".
         RealmResults<Person> results = realm.where(Person.class)
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
index d9ba05e744..60ff3b2eeb 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
@@ -22,12 +22,15 @@
 
 public class DogRepositoryImpl implements DogRepository {
     @Override
-    public void createDog(String name) {
+    public void createDog(final String name) {
         Realm realm = Realm.getDefaultInstance();
-        realm.beginTransaction();
-        Dog dog = realm.createObject(Dog.class);
-        dog.setName(name);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName(name);
+            }
+        });
         realm.close();
     }
 }
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 1abe5250b8..4e23a70df5 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -22,6 +22,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.modules.junit4.rule.PowerMockRule;
@@ -30,7 +31,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ActivityController;
 
-import java.lang.Exception;
 import java.util.Arrays;
 import java.util.List;
 
@@ -42,20 +42,20 @@
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
 
-
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doCallRealMethod;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.doNothing;
 import static org.powermock.api.mockito.PowerMockito.mock;
 import static org.powermock.api.mockito.PowerMockito.mockStatic;
 import static org.powermock.api.mockito.PowerMockito.verifyStatic;
 import static org.powermock.api.mockito.PowerMockito.when;
 import static org.powermock.api.mockito.PowerMockito.whenNew;
-import static org.powermock.api.mockito.PowerMockito.doNothing;
 
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
@@ -137,7 +137,7 @@ public void setup() throws Exception {
         RealmResults<Person> people = mockRealmResults();
 
         // When we ask Realm for all of the Person instances, return the mock RealmResults
-        when(mockRealm.allObjects(Person.class)).thenReturn(people);
+        when(mockRealm.where(Person.class).findAll()).thenReturn(people);
 
         // When a between query is performed with any string as the field and any int as the
         // value, then return the personQuery itself
@@ -167,6 +167,8 @@ public void setup() throws Exception {
 
     @Test
     public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
+        doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
+
         // Create activity
         ActivityController<ExampleActivity> controller =
                 Robolectric.buildActivity(ExampleActivity.class).setup();
@@ -179,24 +181,23 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         Realm.getInstance(any(RealmConfiguration.class));
 
         // verify that we have four begin and commit transaction calls
-        verify(mockRealm, times(4)).beginTransaction();
-        verify(mockRealm, times(4)).commitTransaction();
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        //verify(mockRealm, times(4)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Click the clean up button
         activity.findViewById(R.id.clean_up).performClick();
 
         // Verify that begin and commit transaction were called (been called a total of 5 times now)
-        verify(mockRealm, times(5)).beginTransaction();
-        verify(mockRealm, times(5)).commitTransaction();
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        //verify(mockRealm, times(5)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
-        // Verify that we queried for all Person instance two times in this run (in the original
-        // onCreate, and then again in the button click). Was called two times previously in the
-        // setup, therefore we need to check if it was called again.
-        verify(mockRealm, times(3)).allObjects(Person.class);
+        // Verify that we queried for Person instances five times in this run (2 in basicCrud(),
+        // 2 in complexQuery() and 1 in the button click)
+        verify(mockRealm, times(5)).where(Person.class);
 
-        // Verify that the clear method was called. Clear is also called in the start of the
+        // Verify that the delete method was called. Delete is also called in the start of the
         // activity to ensure we start with a clean db.
-        verify(people, times(2)).deleteAllFromRealm();
+        verify(mockRealm, times(2)).delete(Person.class);
 
         // Call the destroy method so we can verify that the .close() method was called (below)
         controller.destroy();
@@ -206,6 +207,44 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         verify(mockRealm, times(2)).close();
     }
 
+    /**
+     * Have to verify the transaction execution in a different test because
+     * of a problem with Powermock: https://github.com/jayway/powermock/issues/649
+     */
+    @Test
+    public void shouldBeAbleToVerifyTransactionCalls() {
+
+        // Create activity
+        ActivityController<ExampleActivity> controller =
+                Robolectric.buildActivity(ExampleActivity.class).setup();
+        ExampleActivity activity = controller.get();
+
+        assertThat(activity.getTitle().toString(), is("Unit Test Example"));
+
+        // Verify that two Realm.getInstance() calls took place.
+        verifyStatic(times(2));
+        Realm.getInstance(any(RealmConfiguration.class));
+
+        // verify that we have four begin and commit transaction calls
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        verify(mockRealm, times(4)).executeTransaction(Mockito.any(Realm.Transaction.class));
+
+        // Click the clean up button
+        activity.findViewById(R.id.clean_up).performClick();
+
+        // Verify that begin and commit transaction were called (been called a total of 5 times now)
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        verify(mockRealm, times(5)).executeTransaction(Mockito.any(Realm.Transaction.class));
+
+        // Call the destroy method so we can verify that the .close() method was called (below)
+        controller.destroy();
+
+        // Verify that the realm got closed 2 separate times. Once in the AsyncTask, once
+        // in onDestroy
+        verify(mockRealm, times(2)).close();
+    }
+
+
     @SuppressWarnings("unchecked")
     private <T extends RealmObject> RealmQuery<T> mockRealmQuery() {
         return mock(RealmQuery.class);
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
index 8aef6265e8..e7be410e33 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -38,6 +38,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.internal.verification.VerificationModeFactory.times;
+import static org.powermock.api.mockito.PowerMockito.doCallRealMethod;
 import static org.powermock.api.mockito.PowerMockito.mockStatic;
 import static org.powermock.api.mockito.PowerMockito.when;
 
@@ -91,7 +92,9 @@ public void shouldBeAbleToCreateARealmObject() {
      * This test verifies the behavior in the {@link DogRepositoryImpl} class.
      */
     @Test
-    public void shouldVerifyTransactionWasCreated() {
+    public void shouldVerifyThatDogWasCreated() {
+
+        doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         Dog dog = mock(Dog.class);
         when(mockRealm.createObject(Dog.class)).thenReturn(dog);
@@ -99,8 +102,12 @@ public void shouldVerifyTransactionWasCreated() {
         DogRepository dogRepo = new DogRepositoryImpl();
         dogRepo.createDog("Spot");
 
-        // Verify that the begin transaction was called only once
-        verify(mockRealm, times(1)).beginTransaction();
+        // Attempting to verify that a method was called (executeTransaction) on a partial
+        // mock will return unexpected resultes due to the partial mock. For example,
+        // verifying that `executeTransaction` was called only once will fail as Powermock
+        // actually calls the method 3 times for some reason. I cannot determine why at this
+        // point.
+
 
         // Verify that Realm#createObject was called only once
         verify(mockRealm, times(1)).createObject(Dog.class); // Verify that a Dog was in fact created.
@@ -108,8 +115,22 @@ public void shouldVerifyTransactionWasCreated() {
         // Verify that Dog#setName() is called only once
         verify(dog, times(1)).setName(Mockito.anyString()); // Any string will do
 
-        // Verify that the transaction was committed only once
-        verify(mockRealm, times(1)).commitTransaction();
+        // Verify that the Realm was closed only once.
+        verify(mockRealm, times(1)).close();
+    }
+
+    /**
+     * Have to verify the {@link Realm#executeTransaction(Realm.Transaction)} call in a different
+     * test because of a problem with Powermock: https://github.com/jayway/powermock/issues/649
+     */
+    @Test
+    public void shouldVerifyThatTransactionWasExecuted() {
+
+        DogRepository dogRepo = new DogRepositoryImpl();
+        dogRepo.createDog("Spot");
+
+        // Verify that the begin transaction was called only once
+        verify(mockRealm, times(1)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Verify that the Realm was closed only once.
         verify(mockRealm, times(1)).close();
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index dec61401ca..2bcb843bee 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -47,7 +47,7 @@ dependencies {
     compile localGroovy()
     compile "io.realm:realm-transformer:${version}"
     compile 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
 
     testCompile gradleTestKit()
     testCompile 'junit:junit:4.12'
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 2077c526da..7ecfe11eaf 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -19,6 +19,7 @@ package io.realm.gradle
 import com.android.build.gradle.AppPlugin
 import com.android.build.gradle.LibraryPlugin
 import com.neenbedankt.gradle.androidapt.AndroidAptPlugin
+import io.realm.transformer.RealmOptionalAPITransformer
 import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
@@ -47,7 +48,10 @@ class Realm implements Plugin<Project> {
             project.plugins.apply(AndroidAptPlugin)
         }
 
-        project.android.registerTransform(new RealmTransformer())
+        project.android.registerTransform(new RealmTransformer(project))
+        if (!isAndroidLib) {
+            project.android.registerTransform(new RealmOptionalAPITransformer())
+        }
         project.repositories.add(project.getRepositories().jcenter())
         project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index e7be7c0de8..b25f55bdb7 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -17,6 +17,8 @@
 package io.realm.gradle
 
 import com.android.build.api.transform.Transform
+import io.realm.transformer.RealmOptionalAPITransformer
+import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 import org.gradle.api.artifacts.Dependency
@@ -52,7 +54,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
@@ -67,6 +69,7 @@ class PluginTest {
         assertTrue(containsDependency(project.dependencies, 'io.realm', 'realm-annotations', currentVersion))
 
         assertTrue(containsTransform(project.android.transforms, RealmTransformer.class))
+        assertTrue(containsTransform(project.android.transforms, RealmOptionalAPITransformer.class))
     }
 
     @Test
@@ -77,7 +80,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
diff --git a/integration-tests/build.gradle b/integration-tests/build.gradle
new file mode 100644
index 0000000000..129dd076eb
--- /dev/null
+++ b/integration-tests/build.gradle
@@ -0,0 +1,34 @@
+project.ext.sdkVersion = 23
+project.ext.buildTools = '23.0.0'
+
+// Don't cache SNAPSHOT (changing) dependencies.
+configurations.all {
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+
+allprojects {
+    def currentVersion = file("${rootDir}/../version.txt").text.trim()
+
+    buildscript {
+        repositories {
+            mavenLocal()
+            jcenter()
+        }
+        dependencies {
+            classpath 'com.android.tools.build:gradle:2.1.0'
+            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
+            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+            classpath "io.realm:realm-gradle-plugin:${currentVersion}"
+        }
+    }
+
+    group = 'io.realm'
+    version = currentVersion
+
+    repositories {
+        mavenLocal()
+        jcenter()
+    }
+}
diff --git a/integration-tests/gradle/wrapper/gradle-wrapper.jar b/integration-tests/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..13372aef5e
Binary files /dev/null and b/integration-tests/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/integration-tests/gradle/wrapper/gradle-wrapper.properties b/integration-tests/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..122a0dca2e
--- /dev/null
+++ b/integration-tests/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Mon Dec 28 10:00:20 PST 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/integration-tests/gradlew b/integration-tests/gradlew
new file mode 100755
index 0000000000..9d82f78915
--- /dev/null
+++ b/integration-tests/gradlew
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/integration-tests/gradlew.bat b/integration-tests/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/integration-tests/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/integration-tests/optionalAPIExists/.gitignore b/integration-tests/optionalAPIExists/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/integration-tests/optionalAPIExists/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/integration-tests/optionalAPIExists/build.gradle b/integration-tests/optionalAPIExists/build.gradle
new file mode 100644
index 0000000000..fbf57a4759
--- /dev/null
+++ b/integration-tests/optionalAPIExists/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        applicationId "io.realm.tests.optionalapiexists"
+        minSdkVersion 9
+        targetSdkVersion 23
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'io.reactivex:rxjava:1.1.0'
+}
diff --git a/integration-tests/optionalAPIExists/proguard-rules.pro b/integration-tests/optionalAPIExists/proguard-rules.pro
new file mode 100644
index 0000000000..8456b3daec
--- /dev/null
+++ b/integration-tests/optionalAPIExists/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /home/cc/.android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java b/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java
new file mode 100644
index 0000000000..7553ce9c47
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.optionalapiexists;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+    private RealmConfiguration realmConfiguration;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        realmConfiguration = new RealmConfiguration.Builder(this.getContext()).build();
+
+        realm = Realm.getInstance(realmConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
+        // Open the dynamic Realm after transaction.
+        dynamicRealm = DynamicRealm.getInstance(realmConfiguration);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        realm.close();
+        dynamicRealm.close();
+        Realm.deleteRealm(realmConfiguration);
+        super.tearDown();
+    }
+
+    public void testRealmAsObservableRemoved() {
+        assertNotNull(realm.asObservable());
+    }
+
+    public void testRealmObjectAsObservableRemoved() {
+        Dog dog = realm.where(Dog.class).findFirst();
+        assertNotNull(dog.asObservable());
+    }
+
+    public void testDynamicRealmAsObservableRemoved() {
+        assertNotNull(dynamicRealm.asObservable());
+    }
+
+    public void testDynamicRealmObjectAsObservableRemoved() {
+        DynamicRealmObject dog = dynamicRealm.where("Dog").findFirst();
+        assertNotNull(dog.asObservable());
+    }
+
+    public void testRealmResultsAsObservableRemoved() {
+        RealmResults<Dog> results = realm.where(Dog.class).findAll();
+        assertNotNull(results.asObservable());
+    }
+}
diff --git a/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml b/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..d846ee6f5c
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.tests.optionalapiexists"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:label="optionalAPIExists"
+        android:supportsRtl="true" >
+        <activity android:name=".MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java
new file mode 100644
index 0000000000..84700f6b22
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.optionalapiexists;
+
+import io.realm.RealmObject;
+
+public class Dog extends RealmObject {
+    @SuppressWarnings("unused")
+    String name;
+}
diff --git a/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java
new file mode 100644
index 0000000000..7f92feee88
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.optionalapiexists;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class MainActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+}
diff --git a/integration-tests/optionalAPIRemoved/.gitignore b/integration-tests/optionalAPIRemoved/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/integration-tests/optionalAPIRemoved/build.gradle b/integration-tests/optionalAPIRemoved/build.gradle
new file mode 100644
index 0000000000..56863ce43f
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId "io.realm.tests.removeoptionalapitest"
+        minSdkVersion 9
+        targetSdkVersion rootProject.sdkVersion
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    androidTestCompile 'io.reactivex:rxjava:1.1.0'
+}
diff --git a/integration-tests/optionalAPIRemoved/proguard-rules.pro b/integration-tests/optionalAPIRemoved/proguard-rules.pro
new file mode 100644
index 0000000000..8456b3daec
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /home/cc/.android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java b/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java
new file mode 100644
index 0000000000..f248b97f01
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.removeoptionalapitest;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import rx.Observable;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+    private RealmConfiguration realmConfiguration;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        realmConfiguration = new RealmConfiguration.Builder(this.getContext()).build();
+
+        realm = Realm.getInstance(realmConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
+        // Open the dynamic Realm after transaction.
+        dynamicRealm = DynamicRealm.getInstance(realmConfiguration);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        realm.close();
+        dynamicRealm.close();
+        Realm.deleteRealm(realmConfiguration);
+        super.tearDown();
+    }
+
+    public void testRealmAsObservableRemoved() {
+        try {
+            @SuppressWarnings("unused")
+            Observable<Realm> observable = realm.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testRealmObjectAsObservableRemoved() {
+        Dog dog = realm.where(Dog.class).findFirst();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<Dog> observable = dog.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testDynamicRealmAsObservableRemoved() {
+        try {
+            @SuppressWarnings("unused")
+            Observable<DynamicRealm> observable = dynamicRealm.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testDynamicRealmObjectAsObservableRemoved() {
+        DynamicRealmObject dog = dynamicRealm.where("Dog").findFirst();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<DynamicRealmObject> observable = dog.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testRealmResultsAsObservableRemoved() {
+        RealmResults<Dog> results = realm.where(Dog.class).findAll();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<RealmResults<Dog>> observable = results.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+}
diff --git a/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml b/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9201846149
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.tests.removeoptionalapitest"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:label="optionalAPIRemoved"
+        android:supportsRtl="true" >
+        <activity
+            android:name=".MainActivity" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java
new file mode 100644
index 0000000000..e04ed805ae
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.removeoptionalapitest;
+
+import io.realm.RealmObject;
+
+public class Dog extends RealmObject {
+    @SuppressWarnings("unused")
+    String name;
+}
diff --git a/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java
new file mode 100644
index 0000000000..dec189185d
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.removeoptionalapitest;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class MainActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+}
diff --git a/integration-tests/settings.gradle b/integration-tests/settings.gradle
new file mode 100644
index 0000000000..f804c6689a
--- /dev/null
+++ b/integration-tests/settings.gradle
@@ -0,0 +1,4 @@
+include ':optionalAPIRemoved', ':optionalAPIExists'
+
+rootProject.name = 'integration-tests'
+
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
index 940a462ac9..f28f9eb835 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -34,6 +34,10 @@
  * {@code library = true}. Setting {@code library = true} is normally only relevant for library authors. See below for
  * further details.
  *
+ * <p>
+ * Currently, it is not possible to have multiple RealmModule declarations in a single file. If you have more than one
+ * RealmModule, you will have to use separate Java files for each module.
+ *
  *
  * <h2>RealmModules and libraries</h2>
  *
diff --git a/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java b/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java
new file mode 100644
index 0000000000..0b397d7671
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java
@@ -0,0 +1,16 @@
+package io.realm.annotations.internal;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark an API as optional with one or more class {@link #dependencies()}. The bytecode
+ * transformer will decide on build time to remove the corresponding API if it doesn't fulfill the dependencies.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.METHOD)
+public @interface OptionalAPI {
+    String[] dependencies();
+}
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index c9ee011571..e7ebc88668 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -1,14 +1,18 @@
 buildscript {
+    ext.kotlin_version = '1.0.1-2'
     repositories {
         jcenter()
+        mavenCentral()
     }
     dependencies {
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
 apply plugin: 'groovy'
+apply plugin: 'kotlin'
 apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
@@ -24,6 +28,7 @@ targetCompatibility = '1.6'
 repositories {
     mavenLocal()
     jcenter()
+    mavenCentral()
 }
 
 configurations {
@@ -39,18 +44,20 @@ sourceSets {
             srcDir 'build/generated-src/main/java'
         }
     }
+    main.java.srcDirs += 'src/main/kotlin'
 }
 
 dependencies {
     compile localGroovy()
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
     compile 'org.javassist:javassist:3.20.0-GA'
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
         exclude module: 'groovy-all'
     }
+    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 }
 
 // for Ant filter
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index 96a163bac1..d58fb39b7c 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -27,6 +27,7 @@ import io.realm.annotations.RealmClass
 import javassist.ClassPool
 import javassist.CtClass
 import javassist.LoaderClassPath
+import org.gradle.api.Project
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
 
@@ -43,6 +44,11 @@ import static com.android.build.api.transform.QualifiedContent.*
 class RealmTransformer extends Transform {
 
     private Logger logger = LoggerFactory.getLogger('realm-logger')
+    private Project project
+
+    public RealmTransformer(Project project) {
+        this.project = project
+    }
 
     @Override
     String getName() {
@@ -84,6 +90,9 @@ class RealmTransformer extends Transform {
 
         // Create and populate the Javassist class pool
         ClassPool classPool = createClassPool(inputs, referencedInputs)
+        // Append android.jar to class pool. We don't need the class names of them but only the class in the pool for
+        // javassist. See https://github.com/realm/realm-java/issues/2703.
+        addBootClassesToClassPool(classPool)
 
         logger.info "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
 
@@ -278,4 +287,19 @@ class RealmTransformer extends Transform {
         return merged;
     }
 
+    // There is no official way to get the path to android.jar for transform.
+    // See https://code.google.com/p/android/issues/detail?id=209426
+    private void addBootClassesToClassPool(ClassPool classPool) {
+        try {
+            project.android.bootClasspath.each {
+                String path = it.absolutePath
+                logger.info "Add boot class " + path + " to class pool."
+                classPool.appendClassPath(path)
+            }
+        } catch (Exception e) {
+            // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
+            // contain classes from android.jar.
+            logger.info("Cannot get bootClasspath caused by:", e)
+        }
+    }
 }
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt
new file mode 100644
index 0000000000..e17ccf978e
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.Context
+import com.android.build.api.transform.Transform
+import com.android.build.api.transform.QualifiedContent.ContentType
+import com.android.build.api.transform.QualifiedContent.Scope
+import com.android.build.api.transform.QualifiedContent.DefaultContentType
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformOutputProvider
+import com.google.common.collect.ImmutableSet
+import io.realm.annotations.internal.OptionalAPI
+import io.realm.transformer.util.appendThisToClassNames
+import io.realm.transformer.util.appendThisToClassPool
+import io.realm.transformer.util.createClassPool
+import org.slf4j.LoggerFactory
+import java.util.HashSet
+
+class RealmOptionalAPITransformer : Transform() {
+
+    private val logger = LoggerFactory.getLogger("realm-logger")
+    private val transformerName = "realm-optional-api"
+
+    override fun getName(): String? = "RealmOptionalAPITransformer"
+
+    override fun isIncremental(): Boolean = false
+
+    override fun getInputTypes(): MutableSet<ContentType>? = ImmutableSet.of(DefaultContentType.CLASSES)
+
+    override fun getScopes(): MutableSet<Scope>? = ImmutableSet.of(Scope.EXTERNAL_LIBRARIES)
+
+    override fun getReferencedScopes(): MutableSet<Scope>? = ImmutableSet.of(Scope.PROJECT, Scope.PROJECT_LOCAL_DEPS,
+            Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.EXTERNAL_LIBRARIES)
+
+    override fun transform(context: Context?,
+                           inputs: MutableCollection<TransformInput>?,
+                           referencedInputs: MutableCollection<TransformInput>?,
+                           outputProvider: TransformOutputProvider?,
+                           isIncremental: Boolean) {
+
+        val classNames = HashSet<String>()
+        inputs!!.appendThisToClassNames(classNames)
+        val refClassNames = HashSet<String>()
+        referencedInputs!!.appendThisToClassNames(refClassNames)
+        val classPool = createClassPool()
+        inputs.appendThisToClassPool(classPool)
+
+        classNames.filter { it.startsWith("io.realm.") }.forEach {
+            classPool.get(it).declaredMethods.forEach {
+                val optionalAPIAnnotation = it.getAnnotation(OptionalAPI::class.java) as? OptionalAPI
+                val dependenciesList = optionalAPIAnnotation?.dependencies?.toList()
+
+                if (optionalAPIAnnotation == null) {
+                    logger.debug("${it.declaringClass.name} ${it.name} doesn't have @OptionalAPI annotation.")
+                } else if (dependenciesList == null || dependenciesList.size == 0) {
+                    throw IllegalArgumentException("${it.name} doesn't have proper dependencies: " +
+                            "${optionalAPIAnnotation.dependencies}.")
+                } else if (!refClassNames.containsAll(dependenciesList)) {
+                    // Doesn't have enough dependencies, remove the API
+                    logger.debug("${it.declaringClass.name} ${it.name} will be removed since some of the dependencies " +
+                            "in $dependenciesList don't exist.")
+                    it.declaringClass.removeMethod(it)
+                } else {
+                    logger.debug("${it.declaringClass.name} ${it.name} has all dependencies in $dependenciesList.")
+                }
+            }
+        }
+
+        // Create outputs
+        classNames.forEach {
+            val ctClass = classPool.getCtClass(it)
+            ctClass.writeFile(
+                    outputProvider!!.getContentLocation(transformerName, inputTypes, scopes, Format.DIRECTORY).canonicalPath)
+        }
+    }
+}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt
new file mode 100644
index 0000000000..77ab24630e
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer.util
+
+import com.android.SdkConstants
+import com.android.build.api.transform.TransformInput
+import javassist.ClassPool
+import java.io.File
+import java.util.jar.JarFile
+
+// Find all classes and append their names to the given String collection
+fun MutableCollection<TransformInput>.appendThisToClassNames(classNames: MutableCollection<String>) {
+    for (item: TransformInput in this) {
+        for (input in item.directoryInputs) {
+            val dirPath = input.file.absolutePath
+            input.file.walkTopDown().filter { it.isFile && it.endsWith(SdkConstants.DOT_CLASS) }.forEach {
+                val qualifiedClassName = it.absolutePath.substring(
+                        dirPath.length + 1,
+                        input.file.absolutePath.length - SdkConstants.DOT_CLASS.length)
+                        .replace(File.separatorChar, '.')
+                classNames.add(qualifiedClassName)
+            }
+        }
+
+        for (input in item.jarInputs) {
+            val jarFile = JarFile(input.file)
+            jarFile.entries().asSequence().filter { it.name.endsWith(SdkConstants.DOT_CLASS) }.forEach {
+                val path = it.name
+                // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
+                // `/`. It depends on how the jar file was created.
+                // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
+                val qualifiedClassName = path.substring(0, path.length - SdkConstants.DOT_CLASS.length)
+                        .replace('/', '.')
+                        .replace('\\', '.')
+                classNames.add(qualifiedClassName)
+            }
+        }
+    }
+}
+
+// Add all the classes in this collection to the given ClassPool
+fun MutableCollection<TransformInput>.appendThisToClassPool(classPool: ClassPool) {
+    this.forEach {
+        it.directoryInputs.forEach { classPool.appendClassPath(it.file.absolutePath) }
+        it.jarInputs.forEach { classPool.appendClassPath(it.file.absolutePath) }
+    }
+}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt
new file mode 100644
index 0000000000..75f76d3594
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer.util
+
+import javassist.ClassPool
+import javassist.LoaderClassPath
+
+fun createClassPool() : ClassPool {
+    // Don't use ClassPool.getDefault(). Doing consecutive builds in the same run (e.g. debug+release)
+    // will use a cached object and all the classes will be frozen.
+    val classPool = ClassPool()
+    classPool.appendSystemPath()
+    classPool.appendClassPath(LoaderClassPath(ClassLoader.getSystemClassLoader()))
+
+    return classPool
+}
+
diff --git a/realm/build.gradle b/realm/build.gradle
index 589eb622a1..44d2ab9c3f 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -2,14 +2,15 @@ buildscript {
     repositories {
         mavenLocal()
         jcenter()
+        maven { url 'https://jitpack.io' }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
+        classpath 'com.android.tools.build:gradle:2.1.0'
         classpath 'de.undercouch:gradle-download-task:2.0.0'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+        classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 071ca3c6c6..93e9d7ac1a 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -58,5 +58,10 @@
         <Class name="~.*Tests?$"/>
         <Bug pattern="DM_GC"/>
     </Match>
+    <Match>
+        <Class name="io.realm.HandlerController" />
+        <Method name="completedAsyncRealmObject" />
+        <Bug pattern="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN" />
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 94586963b4..630e56eefe 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -31,8 +31,10 @@
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import io.realm.annotations.Ignore;
@@ -59,11 +61,13 @@
 
     private final List<TypeMirror> validPrimaryKeyTypes;
     private final Types typeUtils;
+    private final Elements elements;
 
     public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
+        elements = env.getElementUtils();
         TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
         validPrimaryKeyTypes = Arrays.asList(
                 stringType,
@@ -112,6 +116,7 @@ public boolean generate() {
 
         if (!categorizeClassElements()) return false;
         if (!checkListTypes()) return  false;
+        if (!checkReferenceTypes()) return  false;
         if (!checkDefaultConstructor()) return false;
         if (!checkForFinalFields()) return false;
         if (!checkForTransientFields()) return false;
@@ -156,15 +161,46 @@ private boolean checkForFinalFields() {
     private boolean checkListTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmList(field)) {
+                // Check for missing generic (default back to Object)
                 if (Utils.getGenericType(field) == null) {
                     Utils.error("No generic type supplied for field", field);
                     return false;
                 }
+
+                // Check that the referenced type is a concrete class and not an interface
+                TypeMirror fieldType = field.asType();
+                List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
+                String genericCanonicalType = typeArguments.get(0).toString();
+                TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes are allowed in RealmLists. Neither " +
+                            "interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
             }
         }
+
         return true;
     }
 
+    private boolean checkReferenceTypes() {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmModel(field)) {
+                // Check that the referenced type is a concrete class and not an interface
+                TypeElement typeElement = elements.getTypeElement(field.asType().toString());
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes can be referenced in model classes. " +
+                            "Neither interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+
+
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 92354116c2..4e5ecf260a 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -752,18 +752,18 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 .emitStatement("return null")
             .endControlFlow()
             .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s standaloneObject", className)
+            .emitStatement("%s unmanagedObject", className)
             .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
                     .emitStatement("return (%s)cachedObject.object", className)
                 .nextControlFlow("else")
-                    .emitStatement("standaloneObject = (%s)cachedObject.object", className)
+                    .emitStatement("unmanagedObject = (%s)cachedObject.object", className)
                     .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
             .nextControlFlow("else")
-                .emitStatement("standaloneObject = new %s()", className)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject))")
+                .emitStatement("unmanagedObject = new %s()", className)
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject))")
             .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
@@ -775,34 +775,34 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .emitStatement("((%s) standaloneObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
+                    .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
                                 interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
             } else if (Utils.isRealmList(field)) {
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
                     .beginControlFlow("if (currentDepth == maxDepth)")
-                        .emitStatement("((%s) standaloneObject).%s(null)", interfaceName, setter)
+                        .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
                     .nextControlFlow("else")
                         .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
                                 Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .emitStatement("RealmList<%1$s> standalone%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
-                        .emitStatement("((%s) standaloneObject).%s(standalone%sList)", interfaceName, setter, fieldName)
+                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
+                        .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
                             .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
                                     Utils.getGenericType(field), Utils.getProxyClassSimpleName(field), fieldName)
-                            .emitStatement("standalone%sList.add(item)", fieldName)
+                            .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                     .endControlFlow();
             } else {
-                writer.emitStatement("((%s) standaloneObject).%s(((%s) realmObject).%s())",
+                writer.emitStatement("((%s) unmanagedObject).%s(((%s) realmObject).%s())",
                         interfaceName, setter, interfaceName, getter);
             }
         }
 
-        writer.emitStatement("return standaloneObject");
+        writer.emitStatement("return unmanagedObject");
         writer.endMethod();
         writer.emitEmptyLine();
     }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 7bea9166ea..d7eff132bd 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -55,6 +55,7 @@
     private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
     private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
     private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
+    private JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
 
     @Test
     public void compileSimpleFile() {
@@ -443,4 +444,20 @@ public void compileWithRealmModelFieldInReamlModel() {
                 .processedWith(new RealmProcessor())
                 .compilesWithoutError();
     }
+
+    @Test
+    public void compileWithInterfaceForList() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceList.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileWithInterfaceForObject() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceObjectReference.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 5d28d96813..a9645b0ef2 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -661,45 +661,45 @@ public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        AllTypes standaloneObject;
+        AllTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (AllTypes)cachedObject.object;
             } else {
-                standaloneObject = (AllTypes)cachedObject.object;
+                unmanagedObject = (AllTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new AllTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
 
         // Deep copy of columnObject
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
 
         // Deep copy of columnRealmList
         if (currentDepth == maxDepth) {
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(null);
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(null);
         } else {
             RealmList<AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            RealmList<AllTypes> standalonecolumnRealmListList = new RealmList<AllTypes>();
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(standalonecolumnRealmListList);
+            RealmList<AllTypes> unmanagedcolumnRealmListList = new RealmList<AllTypes>();
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(unmanagedcolumnRealmListList);
             int nextDepth = currentDepth + 1;
             int size = managedcolumnRealmListList.size();
             for (int i = 0; i < size; i++) {
                 AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
-                standalonecolumnRealmListList.add(item);
+                unmanagedcolumnRealmListList.add(item);
             }
         }
-        return standaloneObject;
+        return unmanagedObject;
     }
 
     static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 468e4c1f51..0fe76e0cbe 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -294,24 +294,24 @@ public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Booleans standaloneObject;
+        Booleans unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (Booleans)cachedObject.object;
             } else {
-                standaloneObject = (Booleans)cachedObject.object;
+                unmanagedObject = (Booleans)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new Booleans();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
-        return standaloneObject;
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 2001284f7f..266dd5b234 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -1137,43 +1137,43 @@ public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDep
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        NullTypes standaloneObject;
+        NullTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (NullTypes)cachedObject.object;
             } else {
-                standaloneObject = (NullTypes)cachedObject.object;
+                unmanagedObject = (NullTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new NullTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
 
         // Deep copy of fieldObjectNull
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
-        return standaloneObject;
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 6cb7a3edc2..22dba1e930 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -216,22 +216,22 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Simple standaloneObject;
+        Simple unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
                 return (Simple)cachedObject.object;
             } else {
-                standaloneObject = (Simple)cachedObject.object;
+                unmanagedObject = (Simple)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new Simple();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
-        return standaloneObject;
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
new file mode 100644
index 0000000000..d700a10f8c
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmModel;
+
+// Any interface that extends RealmModel is still a RealmModel interface, so the annotation
+// processor should accept it.
+public interface CustomInterface extends RealmModel {
+}
+
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
new file mode 100644
index 0000000000..18417d5c58
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceList implements CustomInterface {
+    String name;
+    RealmList<CustomInterface> realmList;  // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
new file mode 100644
index 0000000000..1b133f59a5
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceObjectReference implements CustomInterface {
+    String name;
+    CustomInterface obj; // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
index 2389891e27..95650090c0 100644
--- a/realm/realm-jni/build.gradle
+++ b/realm/realm-jni/build.gradle
@@ -1,8 +1,8 @@
 import java.security.MessageDigest
 
-ext.coreVersion = '0.100.0'
+ext.coreVersion = '1.0.1'
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = 'f3bb8564a8bab7eca8dc85f1c508a35e125b93a104f964105558739bd1032d98'
+ext.coreSha256Hash = 'e132f5824dc31e683353fb0be91eb45cac702f88f8cee819499a1dfa7936aeac'
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // gcc is default for the NDK. It also produces smaller binaries
@@ -327,7 +327,7 @@ targets.each { target ->
         // Store the unstripped version
         copy {
             from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${projectDir}/../build/output/jniLibs-unstripped/${target.abi}"
+            into "${buildDir}/outputs/jniLibs-unstripped/${target.abi}"
             rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
         }
     }
@@ -347,7 +347,6 @@ task clean(type: Delete) {
     delete project.buildDir
 
     delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
-    delete fileTree(dir: "${projectDir}/../build/output/jniLibs-unstripped/", include: '**/librealm-jni*.so')
     delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
 
     doLast {
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
index 943c435968..b9ba053379 100644
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ b/realm/realm-jni/src/io_realm_internal_Table.h
@@ -797,22 +797,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeHasSameSchema
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
index 85c54e1420..2d6031919f 100644
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ b/realm/realm-jni/src/io_realm_internal_TableView.h
@@ -511,22 +511,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeWhere
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_table.cpp
index b5680bb491..4bab1930be 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_table.cpp
@@ -1512,36 +1512,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong maxRows)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->to_string(ss, S(maxRows));
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong rowIndex)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_ROW_INDEX_VALID(env, table, rowIndex))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->row_to_string(S(rowIndex), ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong nativeTableToComparePtr)
 {
diff --git a/realm/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-jni/src/io_realm_internal_tableview.cpp
index 7d5d6451af..516c0e5ee8 100644
--- a/realm/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-jni/src/io_realm_internal_tableview.cpp
@@ -1027,37 +1027,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong maxRows)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return NULL;
-
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        TV(nativeViewPtr)->to_string(ss, S(maxRows));
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return NULL;
-
-        std::ostringstream ss;
-        TV(nativeViewPtr)->row_to_string(S(rowIndex), ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     JNIEnv *env, jobject, jlong nativeViewPtr)
 {
diff --git a/realm/realm-jni/src/util.cpp b/realm/realm-jni/src/util.cpp
index a2daeaec90..df5762c93c 100644
--- a/realm/realm-jni/src/util.cpp
+++ b/realm/realm-jni/src/util.cpp
@@ -57,6 +57,10 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
+    catch (File::AccessError& e) {
+        ss << e.what() << " path: " << e.get_path() << " in " << file << " line " << line;
+        ThrowException(env, IllegalArgument, ss.str());
+    }
     catch (exception& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, FatalError, ss.str());
diff --git a/realm/realm-jni/src/util.hpp b/realm/realm-jni/src/util.hpp
index 8a7af2ad55..702b14be01 100644
--- a/realm/realm-jni/src/util.hpp
+++ b/realm/realm-jni/src/util.hpp
@@ -62,13 +62,16 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
         ThrowException(env, IllegalArgument, "Invalid format of Realm file."); \
     } \
     catch (util::File::PermissionDenied& e) { \
-        ThrowException(env, IOFailed, string(fileName), string("Permission denied. ") + e.what()); \
+        ThrowException(env, IOFailed, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path()); \
     } \
-    catch (util::File::NotFound&) { \
-        ThrowException(env, FileNotFound, string(fileName).data());    \
+    catch (util::File::NotFound& e) { \
+        ThrowException(env, FileNotFound, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path());    \
     } \
     catch (util::File::AccessError& e) { \
-        ThrowException(env, FileAccessError, string(fileName), e.what()); \
+        ThrowException(env, FileAccessError, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path()); \
     }
 
 #define CATCH_STD() \
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index dca876a290..42f14b4651 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -28,6 +28,17 @@ android {
         }
     }
 
+    sourceSets {
+        androidTest {
+            java.srcDirs += 'src/benchmarks/java'
+        }
+    }
+
+    packagingOptions {
+        exclude 'META-INF/NOTICE.txt'
+        exclude 'META-INF/LICENSE.txt'
+    }
+
     lintOptions {
         abortOnError false
     }
@@ -55,6 +66,8 @@ dependencies {
     androidTestCompile 'com.android.support.test:rules:0.4.1'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestCompile 'com.opencsv:opencsv:3.4'
+    androidTestCompile 'dk.ilios:spanner:0.6.0'
 
     androidTestApt project(':realm-annotations-processor')
 }
@@ -149,6 +162,24 @@ task checkstyle(type: Checkstyle) {
     classpath = files()
 }
 
+// Configuration options can be found here:
+// http://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html
+task connectedBenchmarks(type: GradleBuild) {
+    description =  'Run all benchmarks on connected devices'
+    group = 'Verification'
+    buildFile = file("${projectDir}/build.gradle")
+    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.package', 'io.realm.benchmarks')
+    tasks = ['connectedCheck']
+}
+
+task connectedUnitTests(type: GradleBuild) {
+    description =  'Run all unit tests on connected devices'
+    group = 'Verification'
+    buildFile = file("${projectDir}/build.gradle")
+    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.notPackage', 'io.realm.benchmarks')
+    tasks = ['connectedAndroidTest']
+}
+
 install {
     repositories.mavenInstaller {
         pom {
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index d7fa5a811c..357f8f7ef8 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -1,16 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm">
+<manifest package="io.realm"
+          xmlns:android="http://schemas.android.com/apk/res/android"
+          xmlns:tools="http://schemas.android.com/tools">
 
-    <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <uses-sdk tools:overrideLibrary="dk.ilios.spanner"/>
+    <uses-sdk
+        android:minSdkVersion="16"
+        android:targetSdkVersion="22"/>
 
     <application>
-        <uses-library android:name="android.test.runner" />
+        <uses-library android:name="android.test.runner"/>
         <service
             android:name=".services.RemoteProcessService"
             android:enabled="true"
             android:exported="true"
-            android:process=":remote" >
+            android:process=":remote">
         </service>
     </application>
 
diff --git a/realm/realm-library/src/androidTest/assets/asset_file.realm b/realm/realm-library/src/androidTest/assets/asset_file.realm
new file mode 100644
index 0000000000..1539f77dd2
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/asset_file.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 9898a360d7..d147fd591a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -37,7 +37,7 @@
         MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
     }
 
-    // Enumerate all current supported collections that can be in un-managed mode.
+    // Enumerate all current supported collections that can be in unmanaged mode.
     protected enum UnManagedCollection {
         UNMANAGED_REALMLIST
     }
@@ -138,7 +138,7 @@ private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
         realm.commitTransaction();
 
         OrderedRealmCollection<CyclicType> result;
-        switch(collectionClass) {
+        switch (collectionClass) {
             case MANAGED_REALMLIST:
                 result = parent.getObjects();
                 break;
@@ -190,16 +190,16 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
         realm.beginTransaction();
         realm.deleteAll();
         switch (collectionClass) {
-            case MANAGED_REALMLIST:
+            case REALMRESULTS:
                 int id = 0;
                 for (String arg : args) {
                     AllJavaTypes obj = realm.createObject(AllJavaTypes.class, id++);
                     obj.setFieldString(arg);
                 }
                 realm.commitTransaction();
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
 
-            case REALMRESULTS:
+            case MANAGED_REALMLIST:
                 AllJavaTypes first = realm.createObject(AllJavaTypes.class);
                 first.setFieldString(args[0]);
                 first.getFieldList().add(first);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index c26e039d4b..aaa191cd70 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -556,7 +556,7 @@ public void deleteAll() {
         realm.beginTransaction();
         realm.createObject(AllTypes.CLASS_NAME);
         DynamicRealmObject cat = realm.createObject(Cat.CLASS_NAME);
-        DynamicRealmObject owner =  realm.createObject(Owner.CLASS_NAME);
+        DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);
         owner.setObject("cat", cat);
         realm.getSchema().create("TestRemoveAll").addField("Field1", String.class);
         realm.createObject("TestRemoveAll");
@@ -591,4 +591,74 @@ public void realmListRemoveAllFromRealm() {
         assertEquals(0, list.size());
         assertEquals(0, realm.where(Dog.CLASS_NAME).count());
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            dynamicRealm.close();
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dynamicRealm.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    dynamicRealm.close();
+                }
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            dynamicRealm.close();
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dynamicRealm.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    dynamicRealm.close();
+                }
+            }
+        });
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
index 1ba7760203..507e7f8edf 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
@@ -19,8 +19,6 @@
 import android.os.Handler;
 import android.os.Message;
 
-import io.realm.HandlerController;
-
 /**
  * Handler decorator, to help intercept some messages before they are sent and received.
  */
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index cc45110462..87d1799643 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -79,7 +79,7 @@ public void iOSDataTypes() throws IOException {
             configFactory.copyRealmFromAssets(context,
                     "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
-            RealmResults<IOSAllTypes> result = realm.allObjectsSorted(IOSAllTypes.class, "id", Sort.ASCENDING);
+            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
             // Verify metadata
             Table table = realm.getTable(IOSAllTypes.class);
             assertTrue(table.hasPrimaryKey());
@@ -113,7 +113,7 @@ public void iOSDataTypesDefaultValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-default.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(0, obj.getShortCol());
             assertEquals(0, obj.getIntCol());
@@ -136,7 +136,7 @@ public void iOSDataTypesNullValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-null-value.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertEquals(null, obj.getByteCol());
             assertEquals(null, obj.getStringCol());
             assertEquals(null, obj.getDateCol());
@@ -152,7 +152,7 @@ public void iOSDataTypesMinimumValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-min.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(Short.MIN_VALUE, obj.getShortCol());
             assertEquals(Integer.MIN_VALUE, obj.getIntCol());
@@ -173,7 +173,7 @@ public void iOSDataTypesMaximumValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-max.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertEquals(Short.MAX_VALUE, obj.getShortCol());
             assertEquals(Integer.MAX_VALUE, obj.getIntCol());
             assertEquals(Integer.MAX_VALUE, obj.getLongCol());
@@ -198,7 +198,7 @@ public void iOSEncryptedRealm() throws IOException {
                     .build();
             realm = Realm.getInstance(realmConfig);
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(0, obj.getShortCol());
             assertEquals(0, obj.getIntCol());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 2b008949ac..bca324f3cc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -159,7 +159,7 @@ public void tearDown() {
                         .getFieldList();
 
             case REALMRESULTS:
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -181,7 +181,7 @@ public void tearDown() {
         throw new AssertionError("Unknown collection: " + collectionClass);
     }
 
-   @Test
+    @Test
     public void sort_twoFields() {
         OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
         AllJavaTypes obj = sortedList.first();
@@ -296,7 +296,7 @@ public void sort_rowsWithPartialNullValues() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                RealmResults<NullTypes> objects = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> objects = realm.where(NullTypes.class).findAll();
                 NullTypes parent = realm.createObject(NullTypes.class, 0);
                 for (int i = 0; i < objects.size(); i++) {
                     NullTypes object = objects.get(i);
@@ -310,8 +310,8 @@ public void sort_rowsWithPartialNullValues() {
                 break;
 
             case REALMRESULTS:
-                original = realm.allObjects(NullTypes.class);
-                copy = realm.allObjects(NullTypes.class);
+                original = realm.where(NullTypes.class).findAll();
+                copy = realm.where(NullTypes.class).findAll();
                 break;
 
             default:
@@ -594,7 +594,7 @@ public void deleteFirstFromRealm() {
                     dog.setName("Dog " + i);
                 }
                 realm.commitTransaction();
-                return realm.allObjects(Dog.class);
+                return realm.where(Dog.class).findAll();
 
             default:
                 throw new AssertionError("Unknown collection class: " + collectionClass);
@@ -674,11 +674,11 @@ public void mutableMethodsOutsideTransactions() {
     @Test
     public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
         for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
 
         for (ListMethod method : ListMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index cd1420bc98..0812e5f972 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -47,7 +47,7 @@
 /**
  * Test class for all methods part of the the {@link RealmCollection} interface.
  * This class only tests collections that are managed by Realm. See {@link UnManagedRealmCollectionTests} for
- * all tests targeting un-managed collections.
+ * all tests targeting unmanaged collections.
  *
  * Methods tested in this class:
  *
@@ -128,7 +128,7 @@ public void tearDown() {
                         .getFieldList();
 
             case REALMRESULTS:
-                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -152,9 +152,9 @@ public void tearDown() {
 
     private OrderedRealmCollection<NullTypes> createAllNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
-        switch(collectionClass) {
+        switch (collectionClass) {
             case MANAGED_REALMLIST:
-                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
                 realm.beginTransaction();
                 for (int i = 0; i < results.size(); i++) {
@@ -173,7 +173,7 @@ public void tearDown() {
         populatePartialNullRowsForNumericTesting(realm);
         switch (collectionClass) {
             case MANAGED_REALMLIST:
-                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
                 realm.beginTransaction();
                 int size = results.size();
@@ -195,7 +195,7 @@ public void tearDown() {
 
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                RealmResults<NonLatinFieldNames> results = realm.allObjects(NonLatinFieldNames.class);
+                RealmResults<NonLatinFieldNames> results = realm.where(NonLatinFieldNames.class).findAll();
                 RealmList<NonLatinFieldNames> list = results.get(0).getChildren();
                 for (int i = 0; i < results.size(); i++) {
                     list.add(results.get(i));
@@ -204,7 +204,7 @@ public void tearDown() {
                 return list;
 
             case REALMRESULTS:
-                return realm.allObjects(NonLatinFieldNames.class);
+                return realm.where(NonLatinFieldNames.class).findAll();
 
             default:
                 throw new AssertionError("Unknown collection: " + collectionClass);
@@ -398,7 +398,7 @@ public void max_partialNullRows() {
     public void sum() {
         Number sum = collection.sum(AllJavaTypes.FIELD_LONG);
         // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_SIZE - 1) * TEST_SIZE/ 2, sum.intValue());
+        assertEquals((TEST_SIZE - 1) * TEST_SIZE / 2, sum.intValue());
     }
 
     // Test sum on nullable rows with all null values
@@ -491,13 +491,13 @@ public void avg_partialNullRows() {
     @Test
     public void maxDate() {
         assertEquals(TEST_SIZE, collection.size());
-        assertEquals(new Date(YEAR_MILLIS * 20 * (TEST_SIZE/2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(new Date(YEAR_MILLIS * 20 * (TEST_SIZE / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
     public void minDate() {
         assertEquals(TEST_SIZE, collection.size());
-        assertEquals(new Date(- YEAR_MILLIS * 20 * TEST_SIZE/2), collection.minDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
@@ -693,10 +693,10 @@ public void mutableMethodsOutsideTransactions() {
     @Test
     public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
         for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
         for (CollectionMethod method : CollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 8ce41fc2fe..1fb67510d6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -267,7 +267,7 @@ public Boolean call() throws Exception {
                 Realm realm = null;
                 try {
                     realm = Realm.getInstance(realmConfig);
-                    final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                    final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                     assertEquals(0, dogs.size());
                     listener[0] = new RealmChangeListener<Realm>() {
                         @Override
@@ -302,7 +302,7 @@ public void onChange(Realm object) {
             dog.setName("Rex " + i);
         }
         realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.close();
 
         try {
@@ -341,7 +341,7 @@ public Boolean call() throws Exception {
                 backgroundLooperStarted.countDown();
 
                 // Random operation in the client code
-                final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                 if (dogs.size() != 0) {
                     return false;
                 }
@@ -384,7 +384,7 @@ public void run() {
             dog.setName("Rex " + i);
         }
         realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.close();
         addHandlerMessages.countDown();
 
@@ -1012,7 +1012,7 @@ public void onChange(Realm object) {
     @RunTestInLooperThread
     public void realmResultsListenerAddedAfterCommit() {
         Realm realm = looperThread.realm;
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 0539661a07..7fbed86aca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -94,14 +94,14 @@ public void tearDown() {
 
             case UNMANAGED_REALMLIST:
                 populateRealm(realm, sampleSize);
-                RealmResults<AllJavaTypes> objects = realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
                 RealmList<AllJavaTypes> inMemoryList = new RealmList<AllJavaTypes>();
                 inMemoryList.addAll(objects);
                 return inMemoryList;
 
             case REALMRESULTS:
                 populateRealm(realm, sampleSize);
-                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -263,7 +263,7 @@ public void iterator_remove() {
             return;
         }
 
-        // un-managed objects are always invalid, but cannot be GC'ed while we have a reference.
+        // Unmanaged objects are always invalid, but cannot be GC'ed while we have a reference.
         // managed objects should not be deleted (= invalid).
         assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
         assertTrue(obj.isValid());
@@ -286,7 +286,7 @@ public void iterator_deleteManagedObjectIndirectly() {
                 assertEquals(TEST_SIZE - 1, collection.size());
                 break;
 
-            // Un-managed collections are not affected by changes to Realm and RealmResult should maintain a stable
+            // Unmanaged collections are not affected by changes to Realm and RealmResult should maintain a stable
             // view until next time sync_if_needed is called.
             case UNMANAGED_REALMLIST:
             case REALMRESULTS:
@@ -313,99 +313,6 @@ public void iterator_removeCalledTwice() {
         it.remove();
     }
 
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void iterator_refreshWhileIterating_nonLooper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case UNMANAGED_REALMLIST:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            case MANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE + 1, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    @UiThreadTest
-    public void iterator_refreshWhileIterating_looper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case MANAGED_REALMLIST:
-            case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void iterator_refreshClearsDeletedObjects() {
-        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
-            return;
-        }
-
-        assertEquals(0, collection.iterator().next().getFieldLong());
-        realm.beginTransaction();
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next(); // First item is a cyclic reference, avoid deleting that
-        AllJavaTypes obj = it.next();
-        assertEquals(1, obj.getFieldLong());
-        obj.deleteFromRealm();
-        realm.commitTransaction();
-        realm.refresh(); // Force a refresh of all Collections
-
-        assertEquals(TEST_SIZE - 1, collection.size());
-
-        it = collection.iterator();
-        it.next();
-        obj = it.next(); // Iterator can no longer access the deleted object
-        assertTrue(obj.isValid());
-        assertEquals(2, obj.getFieldLong());
-    }
-
     @Test
     public void listIterator_empty() {
         collection = createCollection(realm, collectionClass, 0);
@@ -492,7 +399,7 @@ public void listIterator_defaultStartIndex() {
 
     @Test
     public void listIterator_startIndex() {
-        int i = TEST_SIZE/2;
+        int i = TEST_SIZE / 2;
         ListIterator<AllJavaTypes> it = collection.listIterator(i);
 
         assertTrue(it.hasPrevious());
@@ -556,31 +463,6 @@ public void listIterator_transactionBeforeNextItem() {
         }
     }
 
-    @Test
-    public void listIterator_refreshClearsDeletedObjects() {
-        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
-            return;
-        }
-
-        assertEquals(0, collection.iterator().next().getFieldLong());
-        realm.beginTransaction();
-        Iterator<AllJavaTypes> it = collection.listIterator();
-        it.next(); // First item is a cyclic reference, avoid deleting that
-        AllJavaTypes obj = it.next();
-        assertEquals(1, obj.getFieldLong());
-        obj.deleteFromRealm();
-        realm.commitTransaction();
-        realm.refresh(); // Refresh forces a refresh of all Collections
-
-        assertEquals(TEST_SIZE - 1, collection.size());
-
-        it = collection.iterator();
-        it.next();
-        obj = it.next(); // Iterator can no longer access the deleted object
-        assertTrue(obj.isValid());
-        assertEquals(2, obj.getFieldLong());
-    }
-
     @Test
     public void listIterator_closedRealm_methods() {
         if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
@@ -630,72 +512,6 @@ public void listIterator_closedRealm_methods() {
         }
     }
 
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void listIterator_refreshWhileIterating_nonLooper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case UNMANAGED_REALMLIST:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            case MANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE + 1, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    @UiThreadTest
-    public void listIterator_refreshWhileIterating_looper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case MANAGED_REALMLIST:
-            case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
     @Test
     public void listIterator_deleteManagedObjectIndirectly() {
         realm.beginTransaction();
@@ -962,11 +778,20 @@ public void iterator_realmResultsThrowConcurrentModification() {
 
         // Verify that ConcurrentModification is correctly detected on non-looper threads
         Iterator<AllJavaTypes> it = collection.iterator();
-        realm.beginTransaction();
-        realm.createObject(AllJavaTypes.class, TEST_SIZE);
-        realm.commitTransaction();
-        realm.refresh();
-
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(AllJavaTypes.class, TEST_SIZE);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+        realm.waitForChange();
         try {
             it.next();
             fail();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index e7c7235988..4d4665e4d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -37,7 +37,7 @@
 import static org.junit.Assert.fail;
 
 /**
- * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or un-managed.
+ * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or unmanaged.
  *
  * Methods tested in this class:
  *
@@ -151,7 +151,7 @@ public void tearDown() {
 
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -250,7 +250,7 @@ public void get_indexOutOfBounds() {
         for (Integer index : indexes) {
             try {
                 collection.get(index);
-                fail(index +  " did not throw the expected Exception.");
+                fail(index + " did not throw the expected Exception.");
             } catch (IndexOutOfBoundsException ignored) {
             }
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index f3d627702b..81c4938f31 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -241,7 +241,7 @@ public void namingConvention() {
         anc1.setObject(true);
         realm.commitTransaction();
 
-        AnnotationNameConventions anc2 = realm.allObjects(AnnotationNameConventions.class).first();
+        AnnotationNameConventions anc2 = realm.where(AnnotationNameConventions.class).findFirst();
         assertTrue(anc2.isHasObject());
         assertEquals(1, anc2.getId_object());
         assertEquals(2, anc2.getmObject());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 5f8f7a13b5..142bf015be 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -32,6 +32,7 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
@@ -41,6 +42,7 @@
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.instrumentation.MockActivityManager;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
@@ -75,7 +77,7 @@
     @RunTestInLooperThread
     public void executeTransactionAsync() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -86,7 +88,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
-                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals(1, realm.where(Owner.class).count());
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -103,7 +105,7 @@ public void onError(Throwable error) {
     @RunTestInLooperThread
     public void executeTransactionAsync_onSuccess() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -114,7 +116,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
-                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals(1, realm.where(Owner.class).count());
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -125,7 +127,7 @@ public void onSuccess() {
     @RunTestInLooperThread
     public void executeTransactionAsync_onError() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -135,7 +137,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnError() {
             @Override
             public void onError(Throwable error) {
-                assertEquals(0, realm.allObjects(Owner.class).size());
+                assertEquals(0, realm.where(Owner.class).count());
                 assertNull(realm.where(Owner.class).findFirst());
                 looperThread.testComplete();
             }
@@ -146,7 +148,7 @@ public void onError(Throwable error) {
     @RunTestInLooperThread
     public void executeTransactionAsync_NoCallbacks() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -173,7 +175,7 @@ public void executeTransactionAsync_exceptionHandling() throws Throwable {
 
         final Realm realm = looperThread.realm;
 
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -326,7 +328,7 @@ public void accessingRealmListOnUnloadedRealmObjectShouldThrow() {
     }
 
     @Test
-    public void standaloneObjectAsyncBehaviour() {
+    public void unmanagedObjectAsyncBehaviour() {
         Dog dog = new Dog();
         dog.setName("Akamaru");
         dog.setAge(10);
@@ -1495,10 +1497,10 @@ public void distinctAsync() throws Throwable {
         final long numberOfObjects = 10; // must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.distinctAsync(AnnotationIndexTypes.class, "indexBoolean");
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.distinctAsync(AnnotationIndexTypes.class, "indexLong");
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.distinctAsync(AnnotationIndexTypes.class, "indexDate");
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync("indexBoolean");
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync("indexLong");
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync("indexDate");
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -1569,7 +1571,7 @@ public void distinctAsync_notIndexedFields() throws Throwable {
 
         for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
             try {
-                realm.distinctAsync(AnnotationIndexTypes.class, "notIndex" + fieldName);
+                realm.where(AnnotationIndexTypes.class).distinctAsync("notIndex" + fieldName);
                 fail("notIndex" + fieldName);
             } catch (IllegalArgumentException ignored) {
             }
@@ -1581,12 +1583,13 @@ public void distinctAsync_notIndexedFields() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_noneExistingField() throws Throwable {
+        Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
             fail();
         } catch (IllegalArgumentException ignored) {
             looperThread.testComplete();
@@ -1596,26 +1599,27 @@ public void distinctAsync_noneExistingField() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void batchUpdateDifferentTypeOfQueries() {
-        looperThread.realm.beginTransaction();
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
         for (int i = 0; i < 5; ) {
-            AllTypes allTypes = looperThread.realm.createObject(AllTypes.class);
+            AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnLong(i);
             allTypes.setColumnString("data " + i % 3);
 
-            allTypes = looperThread.realm.createObject(AllTypes.class);
+            allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnLong(i);
             allTypes.setColumnString("data " + (++i % 3));
         }
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // must be greater than 1
-        looperThread.realm.commitTransaction();
-        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+        realm.commitTransaction();
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        RealmResults<AllTypes> findAllAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
-        RealmResults<AllTypes> findAllSorted = looperThread.realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
-        RealmResults<AllTypes> findAllSortedMulti = looperThread.realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
+        RealmResults<AllTypes> findAllAsync = realm.where(AllTypes.class).findAllAsync();
+        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
+        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
                 new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
-        RealmResults<AnnotationIndexTypes> findDistinct = looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
 
         looperThread.keepStrongReference.add(findAllAsync);
         looperThread.keepStrongReference.add(findAllSorted);
@@ -1709,7 +1713,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
             public void run() {
                 try {
                     queriesCompleted.await();
-                    Realm bgRealm = Realm.getInstance(looperThread.realm.getConfiguration());
+                    Realm bgRealm = Realm.getInstance(realm.getConfiguration());
 
                     bgRealm.beginTransaction();
                     bgRealm.createObject(AllTypes.class);
@@ -1758,8 +1762,8 @@ public void doInBackground(Realm realm) {
                         break;
 
                     case 2:
-                        assertEquals(1, realm.allObjects(Dog.class).size());
-                        assertEquals(1, realm.allObjects(Owner.class).size());
+                        assertEquals(1, realm.where(Dog.class).count());
+                        assertEquals(1, realm.where(Owner.class).count());
                         assertEquals(1, allAsync.size());
                         assertTrue(allAsync.isLoaded());
                         assertTrue(allAsync.isValid());
@@ -1822,7 +1826,7 @@ public void run() {
     @UiThreadTest
     public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
         TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
-        RealmConfiguration config  = configFactory.createConfiguration();
+        RealmConfiguration config = configFactory.createConfiguration();
         Realm realm = Realm.getInstance(config);
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -1947,6 +1951,102 @@ public void onChange(RealmResults<AllTypes> object) {
         result.load();
     }
 
+    // handlerController#emptyAsyncRealmObject is accessed from different threads
+    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    @Test
+    @UiThreadTest
+    public void concurrentModificationEmptyAsyncRealmObject() {
+        RealmConfiguration config  = configFactory.createConfiguration();
+        final Realm realm = Realm.getInstance(config);
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+
+        realm.beginTransaction();
+        dog1 = realm.copyToRealm(dog1);
+        dog2 = realm.copyToRealm(dog2);
+        realm.commitTransaction();
+
+        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
+        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
+
+        final RealmQuery<Dog> dummyQuery = RealmQuery.createQuery(realm, Dog.class);
+        // Initialize the emptyAsyncRealmObject map, to make sure that iterating is safe
+        // even if we modify the map from a background thread (in case of an empty findFirstAsync)
+        realm.handlerController.emptyAsyncRealmObject.put(weakReference1, dummyQuery);
+
+        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>> iterator = realm.handlerController.emptyAsyncRealmObject.entrySet().iterator();
+        AtomicBoolean fireOnce = new AtomicBoolean(true);
+        while (iterator.hasNext()) {
+            Dog next = (Dog) iterator.next().getKey().get();
+            // add a new Dog from a background thread
+            if (fireOnce.compareAndSet(true, false)) {
+                new Thread() {
+                    @Override
+                    public void run() {
+                        // add a WeakReference to simulate an empty row using a findFirstAsync
+                        // this is added on an Executor thread, hence the dedicated thread
+                        realm.handlerController.emptyAsyncRealmObject.put(weakReference2, dummyQuery);
+                        dogAddFromBg.countDown();
+                    }
+                }.start();
+                TestHelper.awaitOrFail(dogAddFromBg);
+            }
+            assertEquals("Dog 1", next.getName());
+            assertFalse(iterator.hasNext());
+        }
+        realm.close();
+    }
+
+    // handlerController#realmObjects is accessed from different threads
+    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    @Test
+    @UiThreadTest
+    public void concurrentModificationRealmObjects() {
+        RealmConfiguration config  = configFactory.createConfiguration();
+        final Realm realm = Realm.getInstance(config);
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+
+        realm.beginTransaction();
+        dog1 = realm.copyToRealm(dog1);
+        dog2 = realm.copyToRealm(dog2);
+        realm.commitTransaction();
+
+        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
+        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
+
+        realm.handlerController.realmObjects.put(weakReference1, Boolean.TRUE);
+
+        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, Object>> iterator = realm.handlerController.realmObjects.entrySet().iterator();
+        AtomicBoolean fireOnce = new AtomicBoolean(true);
+        while (iterator.hasNext()) {
+            Dog next = (Dog) iterator.next().getKey().get();
+            // add a new Dog from a background thread
+            if (fireOnce.compareAndSet(true, false)) {
+                new Thread() {
+                    @Override
+                    public void run() {
+                        realm.handlerController.realmObjects.put(weakReference2, Boolean.TRUE);
+                        dogAddFromBg.countDown();
+                    }
+                }.start();
+                TestHelper.awaitOrFail(dogAddFromBg);
+            }
+            assertEquals("Dog 1", next.getName());
+            assertFalse(iterator.hasNext());
+        }
+
+        realm.close();
+    }
+
     // *** Helper methods ***
 
     private void populateTestRealm(final Realm testRealm, int objects) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index b240f6caab..4daa4e751c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -126,7 +126,7 @@ public void tearDown() {
 
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index a9a8a11f40..d799572319 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,17 +16,17 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.test.MoreAsserts;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Field;
@@ -41,6 +41,8 @@
 import io.realm.entities.Dog;
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -57,10 +59,10 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmConfigurationTests {
@@ -764,14 +766,11 @@ public void initialDataTransactionAssetFile() throws IOException {
         Realm.deleteRealm(defaultConfig);
 
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
-        configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", Realm.DEFAULT_REALM_NAME);
         assertTrue(new File(configFactory.getRoot(), Realm.DEFAULT_REALM_NAME).exists());
 
         Realm.Transaction transaction = mock(Realm.Transaction.class);
         RealmConfiguration configuration = configFactory.createConfigurationBuilder()
-                // Just reuse existing file and set right schema
-                .schemaVersion(0)
-                .schema(AllTypes.class)
                 .initialData(transaction)
                 .build();
 
@@ -780,6 +779,83 @@ public void initialDataTransactionAssetFile() throws IOException {
         verify(transaction, never()).execute(realm);
     }
 
+    @Test
+    public void assetFileNullAndEmptyFileName() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "").build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileWithInMemoryConfig() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm").inMemory().build();
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileFakeFile() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "no_file").build();
+        try {
+            Realm.getInstance(configuration);
+            fail();
+        } catch (RealmIOException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileValidFile() throws IOException {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm")
+                .build();
+        Realm.deleteRealm(configuration);
+
+        File realmFile = new File(configuration.getPath());
+        assertFalse(realmFile.exists());
+
+        realm = Realm.getInstance(configuration);
+        assertTrue(realmFile.exists());
+
+        // Asset file has 10 Owners and 10 Cats, check if data is present
+        assertEquals(10, realm.where(Owner.class).count());
+        assertEquals(10, realm.where(Cat.class).count());
+
+        realm.close();
+
+        // Copy original file to another location
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", "asset_file_copy.realm");
+        File copyFromAsset = new File(configFactory.getRoot(), "asset_file_copy.realm");
+        assertTrue(copyFromAsset.exists());
+
+        Realm.deleteRealm(configuration);
+        assertFalse(realmFile.exists());
+    }
+
     private static class MigrationWithNoEquals implements RealmMigration {
         @Override
         public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index 4f48119fac..a2ed08b3e1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -73,14 +73,14 @@ public void testInMemoryRealm() {
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
+        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
 
         testRealm.close();
         // After all references to the in-mem-realm closed,
         // in-mem-realm with same identifier should create a fresh new instance.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+        assertEquals(testRealm.where(Dog.class).count(), 0);
 
         StrictMode.enableDefaults();
     }
@@ -103,10 +103,10 @@ public void testInMemoryRealmWithDifferentNames() {
         dog2.setName("UFODog");
         testRealm2.commitTransaction();
 
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
-        assertEquals(testRealm2.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm2.allObjects(Dog.class).first().getName(), "UFODog");
+        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
+        assertEquals(testRealm2.where(Dog.class).count(), 1);
+        assertEquals(testRealm2.where(Dog.class).findFirst().getName(), "UFODog");
 
         testRealm2.close();
     }
@@ -150,13 +150,13 @@ public void testWriteCopyTo() throws IOException {
         // Test a normal Realm file
         testRealm.writeCopyTo(new File(getContext().getFilesDir(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
-        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
 
         // Test a encrypted Realm file
         testRealm.writeEncryptedCopyTo(new File(getContext().getFilesDir(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
-        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
         // Test with a wrong key to see if it fails as expected.
         try {
@@ -178,8 +178,8 @@ public void testWriteCopyTo() throws IOException {
     // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
     //    specific name exists.
     public void testMultiThread() throws InterruptedException, ExecutionException {
-        final CountDownLatch workerReadyLatch = new CountDownLatch(1);
-        final CountDownLatch workerFinishedLatch = new CountDownLatch(1);
+        final CountDownLatch workerCommittedLatch = new CountDownLatch(1);
+        final CountDownLatch workerClosedLatch = new CountDownLatch(1);
         final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
         final AssertionFailedError threadError[] = new AssertionFailedError[1];
 
@@ -194,13 +194,13 @@ public void run() {
                 realm.commitTransaction();
 
                 try {
-                    assertEquals(realm.allObjects(Dog.class).size(), 1);
+                    assertEquals(realm.where(Dog.class).count(), 1);
                 } catch (AssertionFailedError afe) {
                     threadError[0] = afe;
                     realm.close();
                     return;
                 }
-                workerReadyLatch.countDown();
+                workerCommittedLatch.countDown();
 
                 // Wait until Realm instance closed in main thread
                 try {
@@ -212,19 +212,19 @@ public void run() {
                 }
 
                 realm.close();
-                workerFinishedLatch.countDown();
+                workerClosedLatch.countDown();
             }
         });
         workerThread.start();
 
 
         // Wait until the worker thread started
-        workerReadyLatch.await(3, TimeUnit.SECONDS);
+        workerCommittedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // refresh will be ran in the next loop, manually refresh it here.
-        testRealm.refresh();
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        testRealm.waitForChange();
+        assertEquals(testRealm.where(Dog.class).count(), 1);
 
         // Step 3.
         // Release the main thread Realm reference, and the worker thread hold the reference still
@@ -233,18 +233,18 @@ public void run() {
         // Step 4.
         // Create a new Realm reference in main thread and checking the data.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(testRealm.where(Dog.class).count(), 1);
         testRealm.close();
 
         // Let the worker thread continue.
         realmInMainClosedLatch.countDown();
 
         // Wait until the worker thread finished
-        workerFinishedLatch.await(3, TimeUnit.SECONDS);
+        workerClosedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+        assertEquals(testRealm.where(Dog.class).count(), 0);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index cb577ee748..1b80bb1b0f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -280,8 +280,8 @@ public void testCreateInitialRealm() throws InterruptedException {
             @Override
             public void run() {
                 // Step 1
-                testRealm = Realm.getInstance(getContext());
-                assertEquals(testRealm.allObjects(AllTypes.class).size(), 0);
+                testRealm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).build());
+                assertEquals(testRealm.where(AllTypes.class).count(), 0);
                 testRealm.beginTransaction();
                 testRealm.createObject(AllTypes.class);
                 testRealm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
index 81846cd202..c5482eb151 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -16,9 +16,6 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
@@ -64,24 +61,24 @@ public void tearDown() {
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
-             {"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
-            ,{"{ \"name\":null, \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
-            ,{"{ \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
+            {PrimaryKeyAsBoxedByte.class,    "OhThisIsNullKey?!", "{ \"id\":null, \"name\":\"OhThisIsNullKey?!\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "YouBetItIsNullKey", "{ \"id\":null, \"name\":\"YouBetItIsNullKey\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "Gosh Didnt KnowIt", "{ \"id\":null, \"name\":\"Gosh Didnt KnowIt\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "?YOUNOWKNOWRIGHT?", "{ \"id\":null, \"name\":\"?YOUNOWKNOWRIGHT?\" }"},
+            {PrimaryKeyAsBoxedByte.class,    "HaHaHaHaHaHaHaHaH", "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "KeyValueTestIsFun", "{ \"name\":\"KeyValueTestIsFun\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "FunValueTestIsKey", "{ \"name\":\"FunValueTestIsKey\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "NameAsBoxedLong-!", "{ \"name\":\"NameAsBoxedLong-!\" }"},
+            {PrimaryKeyAsString.class,       "4299121",           "{ \"name\":null, \"id\":4299121  }"},
+            {PrimaryKeyAsString.class,       "2429214",           "{ \"id\":2429214 }"}
         });
     }
 
-    final private String jsonString;
-    final private String secondaryFieldValue;
     final private Class<? extends RealmObject> clazz;
+    final private String secondaryFieldValue;
+    final private String jsonString;
 
-    public RealmJsonNullPrimaryKeyTests(String jsonString, String secondFieldValue, Class<? extends RealmObject> clazz) {
+    public RealmJsonNullPrimaryKeyTests(Class<? extends RealmObject> clazz, String secondFieldValue, String jsonString) {
         this.jsonString = jsonString;
         this.secondaryFieldValue = secondFieldValue;
         this.clazz = clazz;
@@ -96,14 +93,14 @@ public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() thro
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
@@ -119,14 +116,14 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObjec
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
@@ -143,14 +140,14 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJso
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 7183dcba20..fbcc2fdcf8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -84,8 +84,8 @@ private InputStream convertJsonObjectToStream(JSONObject obj) {
 
     // Assert that the list of AllTypesPrimaryKey objects where inserted and updated properly.
     private void assertAllTypesPrimaryKeyUpdated() {
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Bar", obj.getColumnString());
         assertEquals(2.23F, obj.getColumnFloat(), 0F);
         assertEquals(2.234D, obj.getColumnDouble(), 0D);
@@ -172,13 +172,13 @@ private void checkNullableValuesAreNotNull(NullTypes nullTypes2) {
     @Test
     public void createObject_fromJsonNullObject() {
         realm.createObjectFromJson(AllTypes.class, (JSONObject) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
     public void createAllFromJson_nullArray() {
         realm.createAllFromJson(AllTypes.class, (JSONArray) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
 
     }
 
@@ -195,13 +195,13 @@ public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
 
         // Check that all primitive types are imported correctly
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
-        assertEquals(1.23F, obj.getColumnFloat(),0F);
-        assertEquals(1.23D, obj.getColumnDouble(),0D);
+        assertEquals(1.23F, obj.getColumnFloat(), 0F);
+        assertEquals(1.23D, obj.getColumnDouble(), 0D);
         assertEquals(true, obj.isColumnBoolean());
         assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
     }
@@ -215,7 +215,7 @@ public void createObjectFromJson_dateAsLong() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -228,7 +228,7 @@ public void createObjectFromJson_dateAsString() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -242,7 +242,7 @@ public void createObjectFromJson_dateAsStringTimeZone() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         Calendar cal = GregorianCalendar.getInstance();
         cal.setTimeZone(TimeZone.getTimeZone("Australia/West"));
         cal.set(2015, Calendar.OCTOBER, 03, 14, 45, 33);
@@ -263,7 +263,7 @@ public void createObjectFromJson_childObject() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Fido", obj.getColumnRealmObject().getName());
     }
 
@@ -283,7 +283,7 @@ public void createObjectFromJson_childObjectList() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(3, obj.getColumnRealmList().size());
         assertEquals("Fido-3", obj.getColumnRealmList().get(2).getName());
     }
@@ -298,7 +298,7 @@ public void createObjectFromJson_emptyChildObjectList() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
@@ -306,10 +306,10 @@ public void createObjectFromJson_emptyChildObjectList() throws JSONException {
     public void createObjectFromJson_stringSimpleObject() {
         realm.beginTransaction();
         Dog dog = realm.createObjectFromJson(Dog.class, "{ name: \"Foo\" }");
-        realm. commitTransaction();
+        realm.commitTransaction();
 
         assertEquals("Foo", dog.getName());
-        assertEquals("Foo", realm.allObjects(Dog.class).first().getName());
+        assertEquals("Foo", realm.where(Dog.class).findFirst().getName());
     }
 
     @Test
@@ -332,7 +332,7 @@ public void createObjectFromJson_stringNull() {
 
         //noinspection ConstantConditions
         assertNull(dog);
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -342,7 +342,7 @@ public void createAllFromJson_jsonArrayEmpty() {
         realm.createAllFromJson(AllTypes.class, array);
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -359,7 +359,7 @@ public void createAllFromJson_jsonArray() throws JSONException {
         realm.createAllFromJson(Dog.class, dogList);
         realm.commitTransaction();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -374,7 +374,7 @@ public void createObjectFromJson_noValues() throws JSONException {
         realm.commitTransaction();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
         assertEquals(0F, obj.getColumnFloat(), 0F);
@@ -401,7 +401,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
             realm.commitTransaction();
         }
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Foo", obj.getColumnString());
         assertEquals(new Date(0), obj.getColumnDate());
     }
@@ -417,7 +417,7 @@ public void createObjectFromJson_respectIgnoredFields() throws JSONException {
         realm.createObjectFromJson(AnnotationTypes.class, json);
         realm.commitTransaction();
 
-        AnnotationTypes annotationsObject = realm.allObjects(AnnotationTypes.class).first();
+        AnnotationTypes annotationsObject = realm.where(AnnotationTypes.class).findFirst();
         assertEquals("Foo", annotationsObject.getIndexString());
         assertEquals(null, annotationsObject.getIgnoreString());
     }
@@ -428,7 +428,7 @@ public void createAllFromJson_stringArraySimpleArray() {
         realm.createAllFromJson(Dog.class, "[{ name: \"Foo\" }, { name: \"Bar\" }]");
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(Dog.class).size());
+        assertEquals(2, realm.where(Dog.class).count());
     }
 
     @Test
@@ -449,7 +449,7 @@ public void createAllFromJson_stringArrayNull() {
         realm.createAllFromJson(Dog.class, (String) null);
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -457,7 +457,7 @@ public void createAllFromJson_stringEmptyArray() {
         realm.beginTransaction();
         realm.createAllFromJson(Dog.class, "");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -466,14 +466,14 @@ public void createAllFromJson_stringNullClass() {
         realm.createAllFromJson(null, "[{ name: \"Foo\" }]");
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
 
     @Test
     public void createAllFromJson_streamNull() throws IOException {
         realm.createAllFromJson(AllTypes.class, (InputStream) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -485,7 +485,7 @@ public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1.23F, obj.getColumnFloat(), 0F);
@@ -503,7 +503,7 @@ public void createObjectFromJson_streamDateAsLong() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -516,7 +516,7 @@ public void createObjectFromJson_streamDateAsString() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -534,7 +534,7 @@ public void createObjectFromJson_streamDateAsISO8601String() throws IOException
         Date date = cal.getTime();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(date, obj.getColumnDate());
     }
 
@@ -546,7 +546,7 @@ public void createObjectFromJson_streamChildObject() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Fido", obj.getColumnRealmObject().getName());
     }
 
@@ -558,7 +558,7 @@ public void createObjectFromJson_streamEmptyChildObjectList() throws IOException
         realm.commitTransaction();
         in.close();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
@@ -570,7 +570,7 @@ public void createObjectFromJson_streamChildObjectList() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -581,7 +581,7 @@ public void createAllFromJson_streamArray() throws IOException {
         realm.createAllFromJson(Dog.class, in);
         realm.commitTransaction();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -596,7 +596,7 @@ public void createObjectFromJson_streamNoValues() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
         assertEquals(0F, obj.getColumnFloat(), 0F);
@@ -618,7 +618,7 @@ public void createObjectFromJson_streamNullClass() throws IOException {
     }
 
     @Test
-    public void createObjectFromJson_streamNullJson() throws IOException  {
+    public void createObjectFromJson_streamNullJson() throws IOException {
         InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_invalid.json");
         realm.beginTransaction();
         try {
@@ -632,7 +632,7 @@ public void createObjectFromJson_streamNullJson() throws IOException  {
     }
 
     @Test
-    public void createObjectFromJson_streamNullInputStream() throws IOException  {
+    public void createObjectFromJson_streamNullInputStream() throws IOException {
         realm.beginTransaction();
         assertNull(realm.createObjectFromJson(AnnotationTypes.class, (InputStream) null));
         realm.commitTransaction();
@@ -665,7 +665,7 @@ public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1F, obj.getColumnFloat(), 0F);
@@ -751,7 +751,7 @@ public void createOrUpdateObjectFromJson_inputStream() throws IOException {
         AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -797,7 +797,7 @@ public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
         realm.commitTransaction();
 
         // Check that all primitive types are imported correctly
-        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1F, obj.getColumnFloat(), 0F);
@@ -842,7 +842,7 @@ public void createOrUpdateObjectFromJson_inputString() throws IOException {
         AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -908,7 +908,7 @@ public void createOrUpdateObjectFromJson_withJsonObject() throws JSONException {
 
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -923,7 +923,7 @@ public void createOrUpdateObjectFromJson_jsonObjectNullClass() throws JSONExcept
         assertNull(realm.createOrUpdateObjectFromJson(null, json));
         realm.commitTransaction();
 
-        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj2 = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Foo", obj2.getColumnString());
     }
 
@@ -932,7 +932,7 @@ public void createOrUpdateObjectFromJson_nullJsonObject() throws JSONException {
         realm.beginTransaction();
         assertNull(realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, (JSONObject) null));
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -949,7 +949,7 @@ public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONExceptio
         } finally {
             realm.commitTransaction();
         }
-        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj2 = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Foo", obj2.getColumnString());
     }
 
@@ -983,13 +983,13 @@ public void createOrUpdateAllFromJson_jsonArrayNoPrimaryKeyThrows() {
     @Test
     public void createOrUpdateAllFromJson_jsonNullClass() {
         realm.createOrUpdateAllFromJson(null, new JSONArray());
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
     public void createOrUpdateAllFromJson_jsonNullJson() {
         realm.createOrUpdateAllFromJson(AllTypes.class, (JSONArray) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -1024,7 +1024,7 @@ public void createOrUpdateAllFromJson_inputStringNullClass() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson((Class<AllTypesPrimaryKey>) null, "{ \"columnLong\" : 1 }");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1032,7 +1032,7 @@ public void createOrUpdateAllFromJson_inputStringNullJson() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, (String) null);
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1040,7 +1040,7 @@ public void createOrUpdateAllFromJson_inputStringEmptyJson() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1094,7 +1094,7 @@ public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONE
         realm.createAllFromJson(NullTypes.class, array);
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
@@ -1111,7 +1111,7 @@ public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException
         realm.createAllFromJson(NullTypes.class, TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
@@ -1138,7 +1138,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
         realm.createObjectFromJson(NullTypes.class, jsonObject);
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(2, nullTypesRealmResults.size());
         checkNullableValuesAreNotNull(nullTypesRealmResults.first());
 
@@ -1148,7 +1148,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
         realm.createOrUpdateAllFromJson(NullTypes.class, array);
         realm.commitTransaction();
 
-        nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 1f8a17870f..9f72d7d348 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -82,7 +82,7 @@ protected void tearDown() throws Exception {
     }
 
     public void testObjects() {
-        RealmResults<Owner> owners = testRealm.allObjects(Owner.class);
+        RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         assertEquals(1, owners.size());
         assertEquals(2, owners.first().getDogs().size());
         assertEquals("Pluto", owners.first().getDogs().first().getName());
@@ -90,13 +90,13 @@ public void testObjects() {
         assertEquals("Blackie", owners.first().getCat().getName());
         assertEquals(12, owners.first().getCat().getAge());
 
-        RealmResults<Dog> dogs = testRealm.allObjects(Dog.class);
+        RealmResults<Dog> dogs = testRealm.where(Dog.class).findAll();
         assertEquals(2, dogs.size());
         for (Dog dog : dogs) {
             assertEquals("Tim", dog.getOwner().getName());
         }
 
-        RealmResults<Cat> cats = testRealm.allObjects(Cat.class);
+        RealmResults<Cat> cats = testRealm.where(Cat.class).findAll();
         assertEquals(1, cats.size());
         assertEquals("Tim", cats.first().getOwner().getName());
     }
@@ -223,8 +223,7 @@ public void testQuerySingleRelationFloat() {
 
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.height", 0.2f, 2.2f).findAll();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -256,8 +255,7 @@ public void testQuerySingleRelationDouble() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.weight", 0.2, 2.2).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -389,8 +387,7 @@ public void testQueryMultipleRelationsFloat() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.height", 0.2f, 2.2f).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -422,8 +419,7 @@ public void testQueryMultipleRelationsDouble() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.weight", 0.2, 12.2).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
@@ -475,7 +471,7 @@ public void testQueryShouldFail() {
     }
 
     public void testWhere() throws Exception {
-        RealmResults<Owner> owners = testRealm.allObjects(Owner.class);
+        RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         RealmResults<Dog> dogs = owners.first().getDogs().where().equalTo("name", "Pluto").findAll();
         assertEquals(1, dogs.size());
         assertEquals("Pluto", dogs.first().getName());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index d049d3dc8a..1230a7c761 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -86,7 +86,7 @@ public void tearDown() throws Exception {
         }
     }
 
-    private RealmList<Dog> createNonManagedDogList() {
+    private RealmList<Dog> createUnmanagedDogList() {
         RealmList<Dog> list = new RealmList<Dog>();
         for (int i = 0; i < TEST_SIZE; i++) {
             list.add(new Dog("Dog " + i));
@@ -106,25 +106,25 @@ public void tearDown() throws Exception {
 
             //noinspection TryWithIdenticalCatches
     /*********************************************************
-     * Un-managed mode tests                                *
+     * Unmanaged mode tests                                *
      *********************************************************/
 
     @Test(expected = IllegalArgumentException.class)
-    public void constructor_nonManaged_null() {
+    public void constructor_unmanaged_null() {
         AllTypes[] args = null;
         //noinspection ConstantConditions
         new RealmList<AllTypes>(args);
     }
 
     @Test
-    public void isValid_nonManagedMode() {
+    public void isValid_unmanagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         assertFalse(list.isValid());
     }
 
     @Test
-    public void add_nonManagedMode() {
+    public void add_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -134,12 +134,12 @@ public void add_nonManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullInNonManagedMode() {
+    public void add_nullInUnmanagedMode() {
         new RealmList<AllTypes>().add(null);
     }
 
     @Test
-    public void add_managedObjectInNonManagedMode() {
+    public void add_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         realm.beginTransaction();
         AllTypes managedAllTypes = realm.createObject(AllTypes.class);
@@ -150,7 +150,7 @@ public void add_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void add_standaloneObjectAtIndexInNonManagedMode() {
+    public void add_unmanagedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -160,7 +160,7 @@ public void add_standaloneObjectAtIndexInNonManagedMode() {
     }
 
     @Test
-    public void add_managedObjectAtIndexInNonManagedMode() {
+    public void add_managedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -182,12 +182,12 @@ public void add_objectAtIndexInManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullAtIndexInNonManagedMode() {
+    public void add_nullAtIndexInUnmanagedMode() {
         new RealmList<AllTypes>().add(0, null);
     }
 
     @Test
-    public void set_nonManagedMode() {
+    public void set_unmanagedMode() {
         RealmList<Dog> list = new RealmList<Dog>();
         Dog dog1 = new Dog("dog1");
         Dog dog2 = new Dog("dog2");
@@ -214,7 +214,7 @@ public void set_managedMode() {
     }
 
     @Test
-    public void set_nullInNonManagedMode() {
+    public void set_nullInUnmanagedMode() {
         @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
@@ -223,7 +223,7 @@ public void set_nullInNonManagedMode() {
     }
 
     @Test
-    public void set_managedObjectInNonManagedMode() {
+    public void set_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -235,7 +235,7 @@ public void set_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void clear_nonManagedMode() {
+    public void clear_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         assertEquals(1, list.size());
@@ -244,7 +244,7 @@ public void clear_nonManagedMode() {
     }
 
     @Test
-    public void remove_nonManagedMode() {
+    public void remove_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object1 = new AllTypes();
         list.add(object1);
@@ -281,8 +281,8 @@ public void move_up() {
 
     // Test move where oldPosition > newPosition
     @Test
-    public void move_downInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_downInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         Dog dog1 = dogs.get(1);
         dogs.move(1, 0);
 
@@ -291,8 +291,8 @@ public void move_downInNonManagedMode() {
 
     // Test move where oldPosition < newPosition
     @Test
-    public void move_upInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_upInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         int oldIndex = TEST_SIZE / 2;
         int newIndex = oldIndex + 1;
         Dog dog = dogs.get(oldIndex);
@@ -371,9 +371,9 @@ public void add_managedObjectToManagedList() {
         assertEquals(1, realm.where(Owner.class).findFirst().getDogs().size());
     }
 
-    // Test that add correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that add correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void add_nonManagedObjectToManagedList() {
+    public void add_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.createObject(CyclicType.class);
         RealmList<CyclicType> children = parent.getObjects();
@@ -382,9 +382,9 @@ public void add_nonManagedObjectToManagedList() {
         assertEquals(1, realm.where(CyclicType.class).findFirst().getObjects().size());
     }
 
-    // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
+    // Make sure that unmanaged objects with a primary key are added using copyToRealmOrUpdate
     @Test
-    public void add_nonManagedPrimaryKeyObjectToManagedList() {
+    public void add_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         realm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
         RealmList<CyclicTypePrimaryKey> children = realm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
@@ -395,9 +395,9 @@ public void add_nonManagedPrimaryKeyObjectToManagedList() {
         assertEquals("new", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
     }
 
-    // Test that set correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that set correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void set_nonManagedObjectToManagedList() {
+    public void set_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.copyToRealm(new CyclicType("Parent"));
         RealmList<CyclicType> children = parent.getObjects();
@@ -413,9 +413,9 @@ public void set_nonManagedObjectToManagedList() {
         assertEquals(5, realm.where(CyclicType.class).count());
     }
 
-    // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
+    // Test that set correctly uses Realm.copyToRealmOrUpdate() on unmanaged objects with a primary key.
     @Test
-    public void  set_nonManagedPrimaryKeyObjectToManagedList() {
+    public void set_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         CyclicTypePrimaryKey parent = realm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
         RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
@@ -594,7 +594,7 @@ public void removeAll_managedMode_wrongClass() {
 
     @Test
     public void removeAll_unmanaged_wrongClass() {
-        RealmList<Dog> list = createNonManagedDogList();
+        RealmList<Dog> list = createUnmanagedDogList();
         //noinspection SuspiciousMethodCalls
         assertFalse(list.removeAll(Collections.singletonList(new Cat())));
     }
@@ -689,9 +689,9 @@ public void clear() {
     public void clear_notDeleting() {
         Owner owner = realm.where(Owner.class).findFirst();
         realm.beginTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         owner.getDogs().clear();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.commitTransaction();
     }
 
@@ -876,14 +876,14 @@ public void run() {
                 }
 
                 try {
-                    list.add(0,dynDog);
+                    list.add(0, dynDog);
                     fail();
                 } catch (IllegalStateException expected) {
                     assertEquals(expectedMsg, expected.getMessage());
                 }
 
                 try {
-                    list.set(0,dynDog);
+                    list.set(0, dynDog);
                     fail();
                 } catch (IllegalStateException expected) {
                     assertEquals(expectedMsg, expected.getMessage());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index b90e014ccd..2c81d4fb9d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -226,6 +226,41 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
+    @Test
+    public void settingPrimaryKeyWithObjectSchema() {
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class)
+                        .addPrimaryKey("id")    // use addPrimaryKey() instead of adding FieldAttribute.PrimaryKey
+                        .addField("indexString", String.class)
+                        .addIndex("indexString") // use addIndex() instead of FieldAttribute.Index
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+
+        realm = Realm.getInstance(realmConfig);
+        RealmObjectSchema schema = realm.getSchema().get("AnnotationTypes");
+        assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.hasIndex("id"));
+        realm.close();
+    }
+
     // adding search index is idempotent
     @Test
     public void addingSearchIndexTwice() throws IOException {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index a3ce3221ab..5bf386836c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -33,8 +33,8 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.pojo.AllTypesRealmModel;
 import io.realm.entities.pojo.InvalidRealmModel;
-import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
 import io.realm.entities.pojo.PojoWithRealmListOfRealmObject;
+import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
 import io.realm.entities.pojo.RealmModelWithRealmModelField;
 import io.realm.entities.pojo.RealmObjectWithRealmListOfRealmModel;
 import io.realm.entities.pojo.RealmObjectWithRealmModelField;
@@ -106,15 +106,15 @@ public void createObject() {
             realm.commitTransaction();
         }
 
-        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
-        assertEquals("Realm.get is returning wrong result set", 42, resultList.size());
+        long size = realm.where(AllTypesRealmModel.class).count();
+        assertEquals("Realm.get is returning wrong result set", 42, size);
     }
 
     @Test
     public void copyToRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
-        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
+        long size = realm.where(AllTypesRealmModel.class).count();
+        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, size);
     }
 
 
@@ -123,15 +123,15 @@ public void copyFromRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
-        AllTypesRealmModel standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.columnBinary, standaloneObject.columnBinary);
-        assertEquals(realmObject.columnString, standaloneObject.columnString);
-        assertEquals(realmObject.columnLong, standaloneObject.columnLong);
-        assertEquals(realmObject.columnFloat, standaloneObject.columnFloat, 0.00000000001);
-        assertEquals(realmObject.columnDouble, standaloneObject.columnDouble, 0.00000000001);
-        assertEquals(realmObject.columnBoolean, standaloneObject.columnBoolean);
-        assertEquals(realmObject.columnDate, standaloneObject.columnDate);
-        assertEquals(realmObject.hashCode(), standaloneObject.hashCode());
+        AllTypesRealmModel unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.columnBinary, unmanagedObject.columnBinary);
+        assertEquals(realmObject.columnString, unmanagedObject.columnString);
+        assertEquals(realmObject.columnLong, unmanagedObject.columnLong);
+        assertEquals(realmObject.columnFloat, unmanagedObject.columnFloat, 0.00000000001);
+        assertEquals(realmObject.columnDouble, unmanagedObject.columnDouble, 0.00000000001);
+        assertEquals(realmObject.columnBoolean, unmanagedObject.columnBoolean);
+        assertEquals(realmObject.columnDate, unmanagedObject.columnDate);
+        assertEquals(realmObject.hashCode(), unmanagedObject.hashCode());
 
     }
 
@@ -151,9 +151,9 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
+        assertEquals(1, realm.where(AllTypesRealmModel.class).count());
 
-        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
         assertEquals("Foo", obj.columnString);
     }
 
@@ -163,8 +163,8 @@ public void createOrUpdateAllFromJson() throws IOException {
         realm.createOrUpdateAllFromJson(AllTypesRealmModel.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
-        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        assertEquals(1, realm.where(AllTypesRealmModel.class).count());
+        AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
         assertEquals("Bar", obj.columnString);
         assertEquals(2.23F, obj.columnFloat, 0.000000001);
         assertEquals(2.234D, obj.columnDouble, 0.000000001);
@@ -188,9 +188,10 @@ public void query() {
     @Test
     @RunTestInLooperThread
     public void async_query() {
-        populateTestRealm(looperThread.realm, TEST_DATA_SIZE);
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, TEST_DATA_SIZE);
 
-        final RealmResults<AllTypesRealmModel> allTypesRealmModels = looperThread.realm.distinctAsync(AllTypesRealmModel.class, AllTypesRealmModel.FIELD_STRING);
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
             public void onChange(RealmResults<AllTypesRealmModel> object) {
@@ -204,7 +205,7 @@ public void onChange(RealmResults<AllTypesRealmModel> object) {
     public void dynamicObject() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        AllTypesRealmModel typedObj = realm.allObjects(AllTypesRealmModel.class).first();
+        AllTypesRealmModel typedObj = realm.where(AllTypesRealmModel.class).findFirst();
         DynamicRealmObject dObj = new DynamicRealmObject(typedObj);
 
         realm.beginTransaction();
@@ -259,7 +260,7 @@ public void invalidModelDefinition() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of other RealmModel, in managed and un-managed mode
+    // of other RealmModel, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModels = new RealmList<AllTypesRealmModel>();
@@ -288,7 +289,7 @@ public void realmModelWithRealmListOfRealmModel() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of RealmObject, in managed and un-managed mode
+    // of RealmObject, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmObject() {
         RealmList<AllTypes> allTypes = new RealmList<AllTypes>();
@@ -317,7 +318,7 @@ public void realmModelWithRealmListOfRealmObject() {
     }
 
     // Test the behaviour of a RealmObject, containing a RealmList
-    // of RealmModel, in managed and un-managed mode
+    // of RealmModel, in managed and unmanaged mode
     @Test
     public void realmObjectWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModel = new RealmList<AllTypesRealmModel>();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
new file mode 100644
index 0000000000..91f85404b5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.objectid.NullPrimaryKey;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class RealmNullPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    /**
+     * Base parameters for testing null-primary key value. The parameters are aligned in an order of
+     * 1) a test target class, 2) a primary key field class, 3) a secondary field class, 4) a secondary
+     * field value, and 5) an update value, accommodating {@interface NullPrimaryKey} to condense unit tests.
+     */
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+            // 1) Test target class          2) PK Class    3) 2nd Class  4) 2nd field value   5) 2nd field value for update
+            {PrimaryKeyAsString.class,       String.class,  long.class,   Long.valueOf(492412), Long.valueOf(991241)},
+            {PrimaryKeyAsBoxedByte.class,    Byte.class,    String.class, "This-Is-Second-One", "Gosh Didnt KnowIt"},
+            {PrimaryKeyAsBoxedShort.class,   Short.class,   String.class, "AnyValueIsAccepted", "?YOUNOWKNOWRIGHT?"},
+            {PrimaryKeyAsBoxedInteger.class, Integer.class, String.class, "PlayWithSeondFied!", "HaHaHaHaHaHaHaHaH"},
+            {PrimaryKeyAsBoxedLong.class,    Long.class,    String.class, "Let's name a value", "KeyValueTestIsFun"}
+        });
+    }
+
+    final private Class<? extends RealmObject> testClazz;
+    final private Class primaryKeyFieldType;
+    final private Class secondaryFieldType;
+    final private Object secondaryFieldValue;
+    final private Object updatingFieldValue;
+
+    public RealmNullPrimaryKeyTests(Class<? extends RealmObject> testClazz, Class primaryKeyFieldType, Class secondaryFieldType, Object secondaryFieldValue, Object updatingFieldValue) {
+        this.testClazz = testClazz;
+        this.primaryKeyFieldType = primaryKeyFieldType;
+        this.secondaryFieldType = secondaryFieldType;
+        this.secondaryFieldValue = secondaryFieldValue;
+        this.updatingFieldValue = updatingFieldValue;
+    }
+
+    // Adds a PrimaryKey object to a realm with values for its PrimaryKey field and secondary field.
+    private RealmObject addPrimaryKeyObjectToTestRealm(Realm testRealm) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject) testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, secondaryFieldValue);
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    // create a RealmObject with null primarykey
+    private void createNullPrimaryKeyObjectFromTestRealm(Realm testRealm) {
+        testRealm.beginTransaction();
+
+        RealmObject obj = testRealm.createObject(testClazz, null);
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            ((PrimaryKeyAsString)obj).setId((long) secondaryFieldValue);
+        } else {
+            ((NullPrimaryKey)obj).setName(secondaryFieldValue);
+        }
+
+        testRealm.commitTransaction();
+    }
+
+    // update existing null PrimaryKey object with a new updating value.
+    private void updatePrimaryKeyObject(Realm testRealm, RealmObject realmObject) {
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            ((PrimaryKeyAsString) realmObject).setId((long) updatingFieldValue);
+        } else {
+            ((NullPrimaryKey) realmObject).setName(updatingFieldValue);
+        }
+
+        testRealm.beginTransaction();
+        testRealm.copyToRealmOrUpdate(realmObject);
+        testRealm.commitTransaction();
+    }
+
+    // @PrimaryKey annotation accept null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealm_primaryKeyIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        addPrimaryKeyObjectToTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation accept & update null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_primaryKeyFieldIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = addPrimaryKeyObjectToTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+
+        }
+
+        // commit to the Realm
+        updatePrimaryKeyObject(realm, obj);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            assertEquals(updatingFieldValue, realm.where(PrimaryKeyAsString.class).findFirst().getId());
+        } else {
+            assertEquals(updatingFieldValue, ((NullPrimaryKey) realm.where(testClazz).findFirst()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation creates null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_primaryKeyFieldIsNull() {
+        createNullPrimaryKeyObjectFromTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation checked duplicated null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_duplicatedNullPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        addPrimaryKeyObjectToTestRealm(realm);
+
+        realm.beginTransaction();
+        try {
+            realm.createObject(testClazz, null);
+            fail("Null value as primary key already exists.");
+        } catch (RealmPrimaryKeyConstraintException expected) {
+            assertEquals("Value already exists: null", expected.getMessage());
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 6963b7ff1a..cb9cf3f5c3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -17,8 +17,7 @@
 package io.realm;
 
 import android.support.test.runner.AndroidJUnit4;
-import io.realm.entities.AllJavaTypes;
-import io.realm.rule.TestRealmConfigurationFactory;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -29,6 +28,9 @@
 import java.util.Date;
 import java.util.Set;
 
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -180,7 +182,7 @@ public boolean isNullable() {
     public void addRemoveField() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
-            switch(fieldType) {
+            switch (fieldType) {
                 case OBJECT:
                     schema.addRealmObjectField(fieldName, DOG_SCHEMA);
                     checkAddedAndRemovable(fieldName);
@@ -512,9 +514,11 @@ public void setRemovePrimaryKey() {
             schema.addPrimaryKey(fieldName);
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.isPrimaryKey(fieldName));
+            assertTrue(schema.hasIndex(fieldName));
             schema.removePrimaryKey();
             assertFalse(schema.hasPrimaryKey());
             assertFalse(schema.isPrimaryKey(fieldName));
+            assertFalse(schema.hasIndex(fieldName));
             schema.removeField(fieldName);
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 76f4c16fc8..644d3caa34 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -31,8 +31,8 @@
 import java.lang.ref.WeakReference;
 import java.util.Calendar;
 import java.util.Date;
-import java.util.Map;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -48,7 +48,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
-import io.realm.entities.Thread;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
@@ -129,7 +128,7 @@ public void stringEncoding() {
         }
         realm.commitTransaction();
 
-        RealmResults<AllTypes> objects = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> objects = realm.where(AllTypes.class).findAll();
         assertEquals(strings.length, objects.size());
         int i = 0;
         for (AllTypes obj : objects) {
@@ -144,7 +143,7 @@ public void stringEncoding() {
     @Test
     public void invalidSurrogates() {
         String high = "Invalid high surrogate \uD83C\uD83C\uDF51";
-        String low  = "Invalid low surrogate \uD83C\uDF51\uDF51";
+        String low = "Invalid low surrogate \uD83C\uDF51\uDF51";
 
         realm.beginTransaction();
         realm.delete(AllTypes.class);
@@ -244,7 +243,7 @@ public void deleteFromRealm_removedFromResults() {
         dogToAdd.setName("Rex");
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(Dog.class).size());
+        assertEquals(1, realm.where(Dog.class).count());
 
         Dog dogToRemove = realm.where(Dog.class).findFirst();
         assertNotNull(dogToRemove);
@@ -252,7 +251,7 @@ public void deleteFromRealm_removedFromResults() {
         dogToRemove.deleteFromRealm();
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
         try {
             dogToAdd.getName();
             realm.close();
@@ -278,7 +277,7 @@ private void removeOneByOne(boolean removeFromFront) {
         realm.commitTransaction();
 
         // Check initial size
-        RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
         assertEquals(TEST_SIZE, dogs.size());
 
         // Check that calling deleteFromRealm doesn't remove the object from the RealmResult
@@ -315,7 +314,7 @@ public Boolean call() throws Exception {
                     switch (method) {
                         case METHOD_GETTER:
                             allTypes.getColumnFloat();
-                           break;
+                            break;
                         case METHOD_SETTER:
                             allTypes.setColumnFloat(1.0f);
                             break;
@@ -390,7 +389,7 @@ public void equals_afterModification() {
     }
 
     @Test
-    public void equals_standAloneObject() {
+    public void equals_unmanagedObject() {
         realm.beginTransaction();
         CyclicType ct1 = realm.createObject(CyclicType.class);
         ct1.setName("Foo");
@@ -577,7 +576,7 @@ public void dateType() {
         realm.commitTransaction();
 
         int i = 0;
-        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
+        for (AllTypes allTypes : realm.where(AllTypes.class).findAll()) {
             assertEquals("Item " + i, new Date(testDatesValid[i]), allTypes.getColumnDate());
             i++;
         }
@@ -626,15 +625,15 @@ public void setter_link_null() {
     }
 
     @Test
-    public void setter_link_standaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_link_unmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
             try {
-                target.setObject(standalone);
+                target.setObject(unmanaged);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -761,8 +760,8 @@ public void run() {
     }
 
     @Test
-    public void setter_list_withStandaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_list_withUnmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
@@ -770,7 +769,7 @@ public void setter_list_withStandaloneObject() {
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
-            list.add(standalone); // List contains a standalone object
+            list.add(unmanaged); // List contains an unmanaged object
             list.add(realm.createObject(CyclicType.class));
 
             try {
@@ -927,12 +926,12 @@ public void classNameConflictsWithFrameworkClass() {
         // The annotation process must be able to handle that.
         realm.beginTransaction();
         @SuppressWarnings("unused")
-        Thread thread = realm.createObject(Thread.class);
+        io.realm.entities.Thread thread = realm.createObject(io.realm.entities.Thread.class);
         realm.commitTransaction();
     }
 
     @Test
-    public void isValid_standaloneObject() {
+    public void isValid_unmanagedObject() {
         AllTypes allTypes = new AllTypes();
         assertFalse(allTypes.isValid());
     }
@@ -1137,8 +1136,7 @@ public void set_nullValuesToNonNullableFields() {
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
-        }
-        finally {
+        } finally {
             realm.cancelTransaction();
         }
     }
@@ -1185,29 +1183,32 @@ public void defaultValuesForNewObject() {
 
     @Test
     public void getter_afterDeleteFromOtherThreadThrows() {
+        final CountDownLatch bgRealmDone = new CountDownLatch(1);
         realm.beginTransaction();
-        AllTypes obj = realm.createObject(AllTypes.class);
+        final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        final CountDownLatch objectDeletedInBackground = new CountDownLatch(1);
-        new java.lang.Thread(new Runnable() {
+        new Thread(new Runnable() {
             @Override
             public void run() {
-                Realm realm = Realm.getInstance(realmConfig);
-                realm.beginTransaction();
-                realm.delete(AllTypes.class);
-                realm.commitTransaction();
-                realm.close();
-                objectDeletedInBackground.countDown();
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.delete(AllTypes.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+                bgRealmDone.countDown();
             }
         }).start();
-        TestHelper.awaitOrFail(objectDeletedInBackground);
-        realm.refresh(); // Move to version where underlying object is deleted.
+        TestHelper.awaitOrFail(bgRealmDone);
+        realm.waitForChange();
 
         // Object should no longer be available
         assertFalse(obj.isValid());
-        thrown.expect(IllegalStateException.class);
-        obj.getColumnLong();
+        try {
+            obj.getColumnLong();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
     }
 
     @Test
@@ -1380,18 +1381,18 @@ public void execute(Realm realm) {
 
     @Test
     public void conflictingFieldName_readAndUpdate() {
-        final ConflictingFieldName standalone = new ConflictingFieldName();
-        standalone.setRealm("realm");
-        standalone.setRow("row");
-        standalone.setIsCompleted("isCompleted");
-        standalone.setListeners("listeners");
-        standalone.setPendingQuery("pendingQuery");
-        standalone.setCurrentTableVersion("currentTableVersion");
+        final ConflictingFieldName unmanaged = new ConflictingFieldName();
+        unmanaged.setRealm("realm");
+        unmanaged.setRow("row");
+        unmanaged.setIsCompleted("isCompleted");
+        unmanaged.setListeners("listeners");
+        unmanaged.setPendingQuery("pendingQuery");
+        unmanaged.setCurrentTableVersion("currentTableVersion");
 
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                realm.copyToRealm(standalone);
+                realm.copyToRealm(unmanaged);
             }
         });
 
@@ -1430,7 +1431,7 @@ public void execute(Realm realm) {
     @Test
     public void setter_nullValueInRequiredField() {
         TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> list = realm.where(NullTypes.class).findAll();
 
         // 1 String
         try {
@@ -1510,66 +1511,87 @@ public void setter_nullValueInRequiredField() {
     @Test
     public void setter_nullValueInNullableField() {
         TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> list = realm.where(NullTypes.class).findAll();
 
         // 1 String
         realm.beginTransaction();
         list.first().setFieldStringNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldStringNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldStringNull());
 
         // 2 Bytes
         realm.beginTransaction();
         list.first().setFieldBytesNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBytesNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldBytesNull());
 
         // 3 Boolean
         realm.beginTransaction();
         list.first().setFieldBooleanNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBooleanNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldBooleanNull());
 
         // 4 Byte
         // 5 Short 6 Integer 7 Long are skipped
         realm.beginTransaction();
         list.first().setFieldByteNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldByteNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldByteNull());
 
         // 8 Float
         realm.beginTransaction();
         list.first().setFieldFloatNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldFloatNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldFloatNull());
 
         // 9 Double
         realm.beginTransaction();
         list.first().setFieldDoubleNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDoubleNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldDoubleNull());
 
         // 10 Date
         realm.beginTransaction();
         list.first().setFieldDateNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDateNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldDateNull());
     }
 
     @Test
     @RunTestInLooperThread
-    public void addChangeListener_throwOnAddingNullListener() {
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
         final Realm realm = looperThread.realm;
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.addChangeListener((RealmChangeListener) null);
-            fail("Failed on adding null change listener.");
+            dog.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dog.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnUnmanagedObject() {
@@ -1581,26 +1603,48 @@ public void addChangeListener_throwOnUnmanagedObject() {
                 public void onChange(Dog object) {
                 }
             });
-            fail("Failed on adding listener on null realm.");
+            fail("adding change listener on unmanaged object must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
     @Test
     @RunTestInLooperThread
-    public void removeChangeListener_throwOnRemovingNullListener() {
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
         final Realm realm = looperThread.realm;
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.removeChangeListener((RealmChangeListener) null);
-            fail("Failed on adding null change listener.");
+            dog.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dog.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     /**
      * This test is to see if RealmObject.removeChangeListeners() works as it is intended.
      */
@@ -1688,7 +1732,7 @@ public void addChangeListener_shouldAddTheObjectToHandlerRealmObjects() {
         realm.beginTransaction();
         AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
         realm.commitTransaction();
-        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
                 realm.handlerController.realmObjects;
 
         assertTrue(realmObjects.isEmpty());
@@ -1712,7 +1756,7 @@ public void addChangeListener_shouldNotAddDupEntriesToHandlerRealmObjects() {
         realm.beginTransaction();
         AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
         realm.commitTransaction();
-        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
                 realm.handlerController.realmObjects;
 
         for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
@@ -1745,7 +1789,7 @@ public void addChangeListener_checkHandlerRealmObjectsWhenCallingOnAsyncObject()
         realm.beginTransaction();
         realm.createObject(AllTypesPrimaryKey.class, 1);
         realm.commitTransaction();
-        final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
                 realm.handlerController.realmObjects;
 
         final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
@@ -1763,7 +1807,7 @@ public void onChange(AllTypesPrimaryKey element) {
             }
         });
         assertEquals(1, realmObjects.size());
-        for (RealmQuery<? extends RealmModel> query : realmObjects.values()) {
+        for (Object query : realmObjects.values()) {
             assertNotNull(query);
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
index d642764f0d..155607bbfe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
@@ -67,12 +67,12 @@ public void tearDown() {
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
-                // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
-                {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
-                {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
-                {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
-                {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
-                {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
+            // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
+            {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
+            {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
+            {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
+            {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
+            {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
         });
     }
 
@@ -107,9 +107,10 @@ public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodExceptio
     // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+
     @Test
     public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
+
+        realm.beginTransaction();
         try {
-            RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
-            realm.beginTransaction();
             realm.copyToRealmOrUpdate(obj);
             fail("@PrimaryKey + @Required field cannot be null");
         } catch (RuntimeException expected) {
@@ -123,4 +124,18 @@ public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodEx
             realm.cancelTransaction();
         }
     }
+
+    // @PrimaryKey + @Required annotation does not accept null as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_nullPrimaryKeyValueThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        realm.beginTransaction();
+        try {
+            realm.createObject(testClazz, null);
+            fail("@PrimaryKey + @Required field cannot be null");
+        } catch (RuntimeException expected) {
+            assertTrue(expected instanceof IllegalArgumentException);
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 52552402c5..9c50d7123c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -639,7 +639,7 @@ public void georgian() {
         RealmResults<StringOnly> stringOnlies1 = realm.where(StringOnly.class).contains("chars", "მთავარი").findAll();
         assertEquals(1, stringOnlies1.size());
 
-        RealmResults<StringOnly> stringOnlies2 = realm.allObjects(StringOnly.class);
+        RealmResults<StringOnly> stringOnlies2 = realm.where(StringOnly.class).findAll();
         stringOnlies2 = stringOnlies2.sort("chars");
         for (int i = 0; i < stringOnlies2.size(); i++) {
             assertEquals(sorted[i], stringOnlies2.get(i).getChars());
@@ -1722,7 +1722,7 @@ public void largeRealmMultipleThreads() throws InterruptedException {
                         public void run() {
                             RealmConfiguration realmConfig = configFactory.createConfiguration();
                             Realm realm = Realm.getInstance(realmConfig);
-                            RealmResults<StringOnly> realmResults = realm.allObjects(StringOnly.class);
+                            RealmResults<StringOnly> realmResults = realm.where(StringOnly.class).findAll();
                             int n = 0;
                             for (StringOnly ignored : realmResults) {
                                 n = n + 1;
@@ -2345,7 +2345,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     }
 
     @Test
-    public void distinctAsync_withNullValues () throws Throwable {
+    public void distinctAsync_withNullValues() throws Throwable {
         final CountDownLatch signalCallbackFinished = new CountDownLatch(2);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
         final Throwable[] threadAssertionError = new Throwable[1];
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 3e7c1e8085..ebc5546a4f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -40,6 +40,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -73,7 +74,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
-        collection = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_LONG, Sort.ASCENDING);
+        collection = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
     }
 
     @After
@@ -112,7 +113,7 @@ public void size_returns_Integer_MAX_VALUE_for_huge_results() {
 
     @Test
     public void subList() {
-        RealmResults<AllTypes> list = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> list = realm.where(AllTypes.class).findAll();
         list.sort("columnLong");
         List<AllTypes> sublist = list.subList(Math.max(list.size() - 20, 0), list.size());
         assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
@@ -348,12 +349,12 @@ public void changeListener_syncIfNeeded_updatedFromOtherThread() {
         assertEquals(10, results.size());
 
         // 1. Delete first object from another thread.
-        realm.executeTransaction(new Realm.Transaction() {
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-               realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 0).findFirst().removeFromRealm();
+                realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 0).findFirst().deleteFromRealm();
             }
-        }, new Realm.Transaction.Callback() {
+        }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
                 // 2. RealmResults are refreshed before onSuccess is called
@@ -853,7 +854,7 @@ public void max_resultsBuiltOnDeletedLinkView() {
     @RunTestInLooperThread
     public void addChangeListener() {
         Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -872,7 +873,7 @@ public void onChange(RealmResults<AllTypes> object) {
     public void addChangeListener_twice() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -923,7 +924,7 @@ public void addChangeListener_null() {
     public void removeChangeListener() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -967,7 +968,7 @@ public void removeChangeListener_null() {
     public void removeAllChangeListeners() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
         RealmChangeListener<RealmResults<AllTypes>> listenerA = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -1002,4 +1003,28 @@ public void run() {
             }
         });
     }
+
+    @Test
+    public void deleteAndDeleteAll() {
+        realm.beginTransaction();
+        for (int i = 0; i < 10; i++) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars("String " + i);
+        }
+        realm.commitTransaction();
+
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAll();
+
+        realm.beginTransaction();
+        // remove one object
+        stringOnlies.get(0).deleteFromRealm();
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        // remove the rest
+        stringOnlies.deleteAllFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(StringOnly.class).findAll().size());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index bef98fac91..018f063f37 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -31,7 +31,6 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsString;
-import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index c7322e0edc..3a31fc86b0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -267,64 +267,7 @@ public void internalRealmChangedHandlersRemoved() {
     @Test
     public void getInstance() {
         assertNotNull("Realm.getInstance unexpectedly returns null", realm);
-        assertTrue("Realm.getInstance does not contain expected table", realm.contains(AllTypes.class));
-    }
-
-    @Test
-    public void getInstance_context() {
-        RealmConfiguration config = new RealmConfiguration.Builder(context).build();
-        Realm.deleteRealm(config);
-
-        Realm testRealm = Realm.getInstance(context);
-        assertNotNull("Realm.getInstance unexpectedly returns null", testRealm);
-        assertTrue("Realm.getInstance does not contain expected table", testRealm.contains(AllTypes.class));
-        config = testRealm.getConfiguration();
-        config.getRealmFolder().equals(context.getFilesDir());
-        testRealm.close();
-        Realm.deleteRealm(config);
-    }
-
-    @Test
-    public void getInstance_nullContext() {
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance((Context) null); // throws when context.getFilesDir() is called;
-            // has nothing to do with Realm
-            fail("Should throw an exception");
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    // Private API
-    @Test
-    public void remove() {
-        populateTestRealm();
-        realm.beginTransaction();
-        realm.remove(AllTypes.class, 0);
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
-    }
-
-    // Private API
-    @Test
-    public void get() {
-        populateTestRealm();
-        AllTypes allTypes = realm.get(AllTypes.class, 0);
-        assertNotNull(allTypes);
-        assertEquals("test data 0", allTypes.getColumnString());
-    }
-
-    // Private API
-    @Test
-    public void contains() {
-        assertTrue("contains returns false for table that should exists", realm.contains(Dog.class));
-        assertFalse("contains returns true for non-existing table", realm.contains(null));
+        assertTrue("Realm.getInstance does not contain expected table", realm.getSchema().contains(AllTypes.CLASS_NAME));
     }
 
     @Test
@@ -1221,7 +1164,7 @@ public void copyToRealm_stringPrimaryKeyIsNull() {
         final long SECONDARY_FIELD_VALUE = 34992142L;
         TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+        RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
         assertEquals(1, results.size());
         assertEquals(null, results.first().getName());
         assertEquals(SECONDARY_FIELD_VALUE, results.first().getId());
@@ -1238,7 +1181,7 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
         TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    SECONDARY_FIELD_VALUE);
 
         for (Class clazz : CLASSES) {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey)results.first()).getName());
@@ -1294,7 +1237,7 @@ public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         childObj.setName("Child");
         childObj.setId(1);
 
-        // Parent object is a standalone object
+        // Parent object is an unmanaged object
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
         parentObj.setObject(childObj);
 
@@ -1365,7 +1308,7 @@ public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
         final long SECONDARY_FIELD_UPDATED = 44887612L;
         PrimaryKeyAsString nullPrimaryKeyObj = TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsString> result = realm.allObjects(PrimaryKeyAsString.class);
+        RealmResults<PrimaryKeyAsString> result = realm.where(PrimaryKeyAsString.class).findAll();
         assertEquals(1, result.size());
         assertEquals(null, result.first().getName());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getId());
@@ -1376,7 +1319,7 @@ public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsString.class).first().getId());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsString.class).findFirst().getId());
     }
 
     @Test
@@ -1385,7 +1328,7 @@ public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullBytePrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedByte nullPrimaryKeyObj = TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedByte> result = realm.allObjects(PrimaryKeyAsBoxedByte.class);
+        RealmResults<PrimaryKeyAsBoxedByte> result = realm.where(PrimaryKeyAsBoxedByte.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1396,7 +1339,7 @@ public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedByte.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedByte.class).findFirst().getName());
     }
 
     @Test
@@ -1405,7 +1348,7 @@ public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullShortPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedShort nullPrimaryKeyObj = TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedShort> result = realm.allObjects(PrimaryKeyAsBoxedShort.class);
+        RealmResults<PrimaryKeyAsBoxedShort> result = realm.where(PrimaryKeyAsBoxedShort.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1416,7 +1359,7 @@ public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedShort.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedShort.class).findFirst().getName());
     }
 
     @Test
@@ -1425,7 +1368,7 @@ public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullIntegerPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedInteger nullPrimaryKeyObj = TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedInteger> result = realm.allObjects(PrimaryKeyAsBoxedInteger.class);
+        RealmResults<PrimaryKeyAsBoxedInteger> result = realm.where(PrimaryKeyAsBoxedInteger.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1436,7 +1379,7 @@ public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedInteger.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedInteger.class).findFirst().getName());
     }
 
     @Test
@@ -1445,7 +1388,7 @@ public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullLongPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedLong nullPrimaryKeyObj = TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedLong> result = realm.allObjects(PrimaryKeyAsBoxedLong.class);
+        RealmResults<PrimaryKeyAsBoxedLong> result = realm.where(PrimaryKeyAsBoxedLong.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1456,7 +1399,7 @@ public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedLong.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedLong.class).findFirst().getName());
     }
 
     @Test
@@ -1560,7 +1503,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
     }
 
 
-    // Checks that a standalone object with only default values can override data
+    // Checks that an unmanaged object with only default values can override data
     @Test
     public void copyToRealmOrUpdate_defaultValuesOverrideExistingData() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -1941,20 +1884,9 @@ public void setter_updateField() throws Exception {
 
     @Test
     public void deleteRealm() throws InterruptedException {
-        File tempDir = new File(context.getFilesDir(), "delete_test_dir");
-        if (!tempDir.exists()) {
-            assertTrue(tempDir.mkdir());
-        }
-
-        assertTrue(tempDir.isDirectory());
-
-        // Delete all files in the directory
-        File[] files = tempDir.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                assertTrue(file.delete());
-            }
-        }
+        File tempDir = new File(configFactory.getRoot(), "delete_test_dir");
+        File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
+        assertTrue(tempDir.mkdir());
 
         final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
 
@@ -1979,14 +1911,15 @@ public void run() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
+        // A core upgrade might change the location of the files
+        assertTrue(tempDir.renameTo(tempDirRenamed));
         readyToCloseLatch.countDown();
+
         realm.close();
         closedLatch.await();
+        // Now we get log files back!
+        assertTrue(tempDirRenamed.renameTo(tempDir));
 
-        // ATTENTION: log, log_a, log_b will be deleted when the other thread close the Realm peacefully. And we force
-        // user to close all Realm instances before deleting. It would be difficult to simulate a case that log files
-        // exist before deletion. Let's keep the case like this for now, we might allow user to delete Realm even there
-        // are instances opened in the future.
         assertTrue(Realm.deleteRealm(configuration));
 
         // Directory should be empty now
@@ -1997,7 +1930,7 @@ public void run() {
     @Test
     public void callMutableMethodOutsideTransaction() throws JSONException, IOException {
 
-        // Prepare standalone object data
+        // Prepare unmanaged object data
         AllTypesPrimaryKey t = new AllTypesPrimaryKey();
         List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
 
@@ -2018,7 +1951,6 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
         try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
         try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
 
@@ -2151,7 +2083,7 @@ public void createObjectWithPrimaryKey_valueAlreadyExists() {
     public void createObjectWithPrimaryKey_null() {
         // Byte
         realm.beginTransaction();
-        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte= realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte = realm.createObject(PrimaryKeyAsBoxedByte.class, null);
         realm.commitTransaction();
         assertEquals(1, realm.where(PrimaryKeyAsBoxedByte.class).count());
         assertNull(primaryKeyAsBoxedByte.getId());
@@ -2384,85 +2316,6 @@ public void run() {
         }
     }
 
-    // This test assures that calling refresh will not trigger local listeners until after the Looper receives a
-    // REALM_CHANGE message
-    @Test
-    public void processRefreshLocalListenersAfterLooperQueueStart() throws Throwable {
-        // Used to validate the result
-        final AtomicBoolean listenerWasCalled = new AtomicBoolean(false);
-        final AtomicBoolean typeListenerWasCalled = new AtomicBoolean(false);
-
-        // Used by the background thread to wait for the main thread to do the write operation
-        final CountDownLatch bgThreadLatch = new CountDownLatch(1);
-        final CountDownLatch bgClosedLatch = new CountDownLatch(2);
-        final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
-        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-
-        final Looper[] looper = new Looper[1];
-        final Throwable[] throwable = new Throwable[1];
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        executorService.submit(new Runnable() {
-            @Override
-            public void run() {
-                // this will allow to register a listener.
-                // we don't start looping to prevent the callback to be invoked via
-                // the handler mechanism, the purpose of this test is to make sure refresh calls
-                // the listeners.
-                Looper.prepare();
-                looper[0] = Looper.myLooper();
-
-                Realm bgRealm = Realm.getInstance(realmConfig);
-                RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
-                try {
-                    bgRealm.addChangeListener(new RealmChangeListener<Realm>() {
-                        @Override
-                        public void onChange(Realm object) {
-                            listenerWasCalled.set(true);
-                            bgClosedLatch.countDown();
-                        }
-                    });
-                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
-                        @Override
-                        public void onChange(RealmResults<Dog> object) {
-                            typeListenerWasCalled.set(true);
-                            bgClosedLatch.countDown();
-                        }
-                    });
-
-                    bgThreadReadyLatch.countDown();
-                    bgThreadLatch.await(); // Wait for the main thread to do a write operation
-                    bgRealm.refresh(); // This should call the listener
-                    assertFalse(listenerWasCalled.get());
-                    assertFalse(typeListenerWasCalled.get());
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    throwable[0] = e;
-
-                } finally {
-                    bgRealm.close();
-                    signalClosedRealm.countDown();
-                }
-            }
-        });
-
-        // Wait until bgThread finishes adding listener to the RealmResults. Otherwise same TableView version won't
-        // trigger the listener.
-        bgThreadReadyLatch.await();
-        realm.beginTransaction();
-        realm.createObject(Dog.class);
-        realm.commitTransaction();
-        bgThreadLatch.countDown();
-        bgClosedLatch.await();
-
-        TestHelper.exitOrThrow(executorService, bgClosedLatch, signalClosedRealm, looper, throwable);
-
-        assertTrue(listenerWasCalled.get());
-        assertTrue(typeListenerWasCalled.get());
-    }
-
     @Test
     public void isInTransaction() {
         assertFalse(realm.isInTransaction());
@@ -2583,13 +2436,6 @@ public void run() {
         }
     }
 
-    @Test
-    public void refresh_insideTransactionThrows() {
-        realm.beginTransaction();
-        thrown.expect(IllegalStateException.class);
-        realm.refresh();
-    }
-
     @Test
     public void isEmpty() {
         RealmConfiguration realmConfig = configFactory.createConfiguration("empty_test.realm");
@@ -2652,24 +2498,24 @@ public void copyFromRealm_invalidDepthThrows() {
     public void copyFromRealm() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.getColumnBinary(), standaloneObject.getColumnBinary());
-        assertEquals(realmObject.getColumnString(), standaloneObject.getColumnString());
-        assertEquals(realmObject.getColumnLong(), standaloneObject.getColumnLong());
-        assertEquals(realmObject.getColumnFloat(), standaloneObject.getColumnFloat(), 0.00000000001);
-        assertEquals(realmObject.getColumnDouble(), standaloneObject.getColumnDouble(), 0.00000000001);
-        assertEquals(realmObject.isColumnBoolean(), standaloneObject.isColumnBoolean());
-        assertEquals(realmObject.getColumnDate(), standaloneObject.getColumnDate());
+        AllTypes unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.getColumnBinary(), unmanagedObject.getColumnBinary());
+        assertEquals(realmObject.getColumnString(), unmanagedObject.getColumnString());
+        assertEquals(realmObject.getColumnLong(), unmanagedObject.getColumnLong());
+        assertEquals(realmObject.getColumnFloat(), unmanagedObject.getColumnFloat(), 0.00000000001);
+        assertEquals(realmObject.getColumnDouble(), unmanagedObject.getColumnDouble(), 0.00000000001);
+        assertEquals(realmObject.isColumnBoolean(), unmanagedObject.isColumnBoolean());
+        assertEquals(realmObject.getColumnDate(), unmanagedObject.getColumnDate());
     }
 
     @Test
     public void copyFromRealm_newCopyEachTime() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject1 = realm.copyFromRealm(realmObject);
-        AllTypes standaloneObject2 = realm.copyFromRealm(realmObject);
-        assertFalse(standaloneObject1 == standaloneObject2);
-        assertNotSame(standaloneObject1, standaloneObject2);
+        AllTypes unmanagedObject1 = realm.copyFromRealm(realmObject);
+        AllTypes unmanagedObject2 = realm.copyFromRealm(realmObject);
+        assertFalse(unmanagedObject1 == unmanagedObject2);
+        assertNotSame(unmanagedObject1, unmanagedObject2);
     }
 
     // Test that the object graph is copied as it is and no extra copies are made
@@ -2995,6 +2841,72 @@ public void execute(Realm realm) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
+        final Realm realm = looperThread.realm;
+
+        try {
+            realm.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    realm.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
+        final Realm realm = looperThread.realm;
+
+        try {
+            realm.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    realm.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     @Test
     public void removeChangeListenerThrowExceptionOnNonLooperThread() {
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index ac2122a32d..bce5a2d917 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -187,7 +187,7 @@ public void call(AllTypes rxObject) {
     @UiThreadTest
     public void realmResults_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
             @Override
             public void call(RealmResults<AllTypes> rxResults) {
@@ -204,7 +204,7 @@ public void call(RealmResults<AllTypes> rxResults) {
     public void dynamicRealmResults_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
             @Override
             public void call(RealmResults<DynamicRealmObject> rxResults) {
@@ -222,7 +222,7 @@ public void realmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.realm;
         realm.beginTransaction();
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.commitTransaction();
 
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
@@ -245,7 +245,7 @@ public void dynamicRealmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         final DynamicRealm dynamicRealm = DynamicRealm.createInstance(looperThread.realmConfiguration);
         dynamicRealm.beginTransaction();
-        RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
 
         results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
@@ -491,7 +491,7 @@ public void call(DynamicRealm rxRealm) {
     @Test
     @UiThreadTest
     public void realmResults_closeInDoOnUnsubscribe() {
-        Observable<RealmResults<AllTypes>> observable = realm.allObjects(AllTypes.class).asObservable()
+        Observable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -514,7 +514,7 @@ public void call(RealmResults<AllTypes> allTypes) {
     public void dynamicRealmResults_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).asObservable()
+        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -539,7 +539,7 @@ public void realmObject_closeInDoOnUnsubscribe() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<AllTypes> observable = realm.allObjects(AllTypes.class).first().<AllTypes>asObservable()
+        Observable<AllTypes> observable = realm.where(AllTypes.class).findFirst().<AllTypes>asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -565,7 +565,7 @@ public void dynamicRealmObject_closeInDoOnUnsubscribe() {
         realm.commitTransaction();
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealmObject> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).first().<DynamicRealmObject>asObservable()
+        Observable<DynamicRealmObject> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index ce5f00c14c..4d44544c27 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -41,6 +41,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
@@ -77,7 +78,7 @@ public void onResult(int count) {
         }
     }
 
-    public static RealmFieldType getColumnType(Object o){
+    public static RealmFieldType getColumnType(Object o) {
         if (o instanceof Boolean)
             return RealmFieldType.BOOLEAN;
         if (o instanceof String)
@@ -97,9 +98,10 @@ public static RealmFieldType getColumnType(Object o){
 
     /**
      * Creates an empty table with 1 column of all our supported column types, currently 9 columns
+     *
      * @return
      */
-    public static Table getTableWithAllColumnTypes(){
+    public static Table getTableWithAllColumnTypes() {
         Table t = new Table();
 
         t.addColumn(RealmFieldType.BINARY, "binary");
@@ -316,7 +318,7 @@ public int read() throws IOException {
         if (garbageSize == 0) {
             long maxMemory = Runtime.getRuntime().maxMemory();
             long totalMemory = Runtime.getRuntime().totalMemory();
-            garbageSize = (int)(maxMemory - totalMemory)/10*9;
+            garbageSize = (int) (maxMemory - totalMemory) / 10 * 9;
         }
         byte garbage[] = new byte[0];
         try {
@@ -326,7 +328,7 @@ public int read() throws IOException {
                 garbage[garbage.length - 1] = 1;
             }
         } catch (OutOfMemoryError oom) {
-            return allocGarbage(garbageSize/10*9);
+            return allocGarbage(garbageSize / 10 * 9);
         }
 
         return garbage;
@@ -633,7 +635,7 @@ public static void populateTestRealmForNullTests(Realm testRealm) {
         testRealm.commitTransaction();
     }
 
-    public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
+    public static void populateAllNonNullRowsForNumericTesting(Realm realm) {
         NullTypes nullTypes1 = new NullTypes();
         nullTypes1.setId(1);
         nullTypes1.setFieldIntegerNull(3);
@@ -668,7 +670,7 @@ public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
         realm.commitTransaction();
     }
 
-    public static void populatePartialNullRowsForNumericTesting (Realm realm) {
+    public static void populatePartialNullRowsForNumericTesting(Realm realm) {
         // Id values are [1, 2, 3]
         // IntegerNull values are [3, null, 4]
         // FloatNull values are [4F, null, 5F]
@@ -796,7 +798,7 @@ public static void populateForMultiSort(Realm typedRealm) {
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(typedRealm.getConfiguration());
         populateForMultiSort(dynamicRealm);
         dynamicRealm.close();
-        typedRealm.refresh();
+        typedRealm.waitForChange();
     }
 
     public static void populateForMultiSort(DynamicRealm realm) {
@@ -976,4 +978,31 @@ public static void emulateRxJavaUnavailable(RealmConfiguration config) {
         }
     }
 
+    public static abstract class Task {
+        public abstract void run() throws Exception;
+    }
+
+    public static void executeOnNonLooperThread(final Task task) throws Throwable {
+        final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>();
+        final Thread thread = new Thread() {
+            @Override
+            public void run() {
+                try {
+                    task.run();
+                } catch (Throwable e) {
+                    thrown.set(e);
+                    if (e instanceof Error) {
+                        throw (Error) e;
+                    }
+                }
+            }
+        };
+        thread.start();
+        thread.join();
+
+        final Throwable throwable = thrown.get();
+        if (throwable != null) {
+            throw throwable;
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index ce0a655d32..ae3d2f8526 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -43,7 +43,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsLong;
-import io.realm.internal.RealmObjectProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -227,7 +226,7 @@ public void run() {
             public void onChange(PrimaryKeyAsLong object) {
                 assertEquals(1, primaryKeyAsLong.getId());
                 assertEquals("Bar", primaryKeyAsLong.getName());
-                assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
+                assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
                 typebasedCommitInvocations.incrementAndGet();
             }
         });
@@ -449,7 +448,7 @@ public void run() {
         newObj.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey object) {
-                assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+                assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
                 assertEquals("bar", newObj.getColumnString());
                 assertTrue(newObj.getColumnBoxedBoolean());
                 typebasedCommitInvocations.incrementAndGet();
@@ -1138,7 +1137,7 @@ public void onChange(Realm object) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(2,typebasedCommitInvocations.get());
+                            assertEquals(2, typebasedCommitInvocations.get());
                             looperThread.testComplete();
                         }
                     });
@@ -1202,7 +1201,7 @@ public void onChange(Realm object) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(typebasedCommitInvocations.get(),1);
+                            assertEquals(typebasedCommitInvocations.get(), 1);
                             looperThread.testComplete();
                         }
                     });
@@ -1256,7 +1255,7 @@ public void onChange(Realm object) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(2,typebasedCommitInvocations.get());
+                            assertEquals(2, typebasedCommitInvocations.get());
                             looperThread.testComplete();
                         }
                     });
@@ -1406,12 +1405,12 @@ public void change_realm_results_map_in_listener() throws InterruptedException {
 
         final Realm realm = looperThread.realm;
         // Two results needed to make sure list modification happen while iterating
-        RealmResults<Owner> results1 = realm.allObjects(Owner.class);
-        RealmResults<Cat> results2 = realm.allObjects(Cat.class);
+        RealmResults<Owner> results1 = realm.where(Owner.class).findAll();
+        RealmResults<Cat> results2 = realm.where(Cat.class).findAll();
         RealmChangeListener listener = new RealmChangeListener() {
             @Override
             public void onChange(Object object) {
-                RealmResults<Owner> results = realm.allObjects(Owner.class);
+                RealmResults<Owner> results = realm.where(Owner.class).findAll();
                 boolean foundKey = false;
                 // Check if the results has been added to the syncRealmResults in case of the behaviour of
                 // allObjects changes
@@ -1478,7 +1477,7 @@ public void onChange(RealmResults<Dog> object) {
             @Override
             public void run() {
                 realm.close();
-                assertEquals(1,typebasedCommitInvocations.get());
+                assertEquals(1, typebasedCommitInvocations.get());
                 looperThread.testComplete();
             }
         });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index cf0da4bd50..2a5308d913 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -24,7 +24,7 @@
 import io.realm.annotations.Index;
 import io.realm.annotations.PrimaryKey;
 
-public class AllJavaTypes extends RealmObject{
+public class AllJavaTypes extends RealmObject {
 
     public static final String CLASS_NAME = "AllJavaTypes";
     public static String FIELD_IGNORED = "fieldIgnored";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
index 5328afe314..ce08779c58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
@@ -19,7 +19,7 @@
 import io.realm.RealmList;
 import io.realm.RealmObject;
 
-public class NonLatinFieldNames extends RealmObject{
+public class NonLatinFieldNames extends RealmObject {
 
     public final static String FIELD_LONG_KOREAN_CHAR = "델타";
     public final static String FIELD_LONG_GREEK_CHAR = "Δέλτα";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
index dbd8689566..f244ea1cc3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedByte() {}
+    public PrimaryKeyAsBoxedByte(Byte id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Byte getId() {
         return id;
     }
 
+    @Override
     public void setId(Byte id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
index 5465f07de4..34179ca174 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedInteger() {}
+    public PrimaryKeyAsBoxedInteger(Integer id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Integer getId() {
         return id;
     }
 
+    @Override
     public void setId(Integer id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
index 53a0187607..6ad4929040 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedLong() {}
+    public PrimaryKeyAsBoxedLong(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Long getId() {
         return id;
     }
 
+    @Override
     public void setId(Long id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
index 402f4b6b58..14ce7656c2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedShort() {}
+    public PrimaryKeyAsBoxedShort(Short id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Short getId() {
         return id;
     }
 
+    @Override
     public void setId(Short id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index c64e9642de..5e70b431b8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -18,6 +18,7 @@
 
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
 
 public class PrimaryKeyAsString extends RealmObject {
 
@@ -29,7 +30,10 @@
 
     private long id;
 
-    public PrimaryKeyAsString() {
+    public PrimaryKeyAsString() {}
+    public PrimaryKeyAsString(String name, long id) {
+        this.name = name;
+        this.id = id;
     }
 
     public PrimaryKeyAsString(String name) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
index 20979c2518..88e1e7286b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
@@ -40,6 +40,7 @@ public Byte getId() {
         return id;
     }
 
+    @Override
     public void setId(Byte id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
index bb8ecfbf83..7f3756e23d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
@@ -40,6 +40,7 @@ public Integer getId() {
         return id;
     }
 
+    @Override
     public void setId(Integer id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
index fe526e125a..52092b7239 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
@@ -40,6 +40,7 @@ public Long getId() {
         return id;
     }
 
+    @Override
     public void setId(Long id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
index 3c14549a52..7c31a298b9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
@@ -40,6 +40,7 @@ public Short getId() {
         return id;
     }
 
+    @Override
     public void setId(Short id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
index 4daa2d8fe6..dc4aadd9a4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
@@ -40,6 +40,7 @@ public String getId() {
         return id;
     }
 
+    @Override
     public void setId(String id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
index 71be5a1a07..6b481e59ce 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
@@ -18,7 +18,7 @@
 
 import io.realm.RealmObject;
 
-public class RealmObjectWithRealmModelField extends RealmObject{
+public class RealmObjectWithRealmModelField extends RealmObject {
     private AllTypesRealmModel allTypesRealmModel;
 
     public AllTypesRealmModel getAllTypesRealmModel() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index ba83afb0b2..9bb296b348 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -49,11 +49,7 @@ public void testTableToString() {
         t.add("s1", 1, true);
         t.add("s2", 2, false);
 
-        String expected =
-"    stringCol  intCol  boolCol\n" +
-"0:  s1              1     true\n" +
-"1:  s2              2    false\n" ;
-
+        String expected = "The Table contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
         assertEquals(expected, t.toString());
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
index 0f0631baa2..7244f5f252 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -451,4 +451,17 @@ public void primaryKeyTableMigratedWithRightName() throws IOException {
         }
         db.close();
     }
+
+    // Test if toString() returns a correct PrimaryKey field description from a Table
+    public void testTableToStringWithPrimaryKey() {
+        Table t = getTableWithStringPrimaryKey();
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
+
+        t.add("s1", 1, true);
+        t.add("s2", 2, false);
+
+        String expected = "The Table has 'colName' field as a PrimaryKey, and contains 3 columns: colName, intCol, boolCol. And 2 rows.";
+        assertEquals(expected, t.toString());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index fb058944aa..30e75077a3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -375,10 +375,7 @@ public void testViewToString() {
 
         TableView view = t.where().findAll();
 
-        String expected =
-                "    stringCol  intCol  boolCol\n" +
-                        "0:  s1              1     true\n" +
-                        "1:  s2              2    false\n" ;
+        String expected = "The TableView contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
 
         assertEquals(expected, view.toString());
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
index 527825cedd..3ed5672410 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
@@ -20,5 +20,9 @@
 
     public P getId();
 
+    public void setId(P id);
+
     public S getName();
+
+    public void setName(S name);
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index d560e819f2..a29895fffb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.entities.AllTypes;
 
 /**
@@ -120,9 +121,9 @@ private static String currentLine() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
             int expected = 1;
-            int got = thiz.testRealm.allObjects(AllTypes.class).size();
+            long got = thiz.testRealm.where(AllTypes.class).count();
             if (expected == got) {
                 response(null);
             } else {
@@ -136,7 +137,7 @@ void run() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
             thiz.testRealm.close();
             response(null);
             Runtime.getRuntime().exit(0);
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
new file mode 100644
index 0000000000..dd23f1f917
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes readObject;
+    private RealmConfiguration coldConfig;
+
+    @BeforeExperiment
+    public void before() {
+        coldConfig = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).name("cold").build();
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(coldConfig);
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                readObject = realm.createObject(AllTypes.class);
+                readObject.setColumnString("Foo");
+                readObject.setColumnLong(42);
+                readObject.setColumnDouble(1.234D);
+            }
+        });
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void coldCreateAndClose(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Realm realm = Realm.getInstance(coldConfig);
+            realm.close();
+        }
+    }
+
+    @Benchmark
+    public void emptyTransaction(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.beginTransaction();
+            realm.commitTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
new file mode 100644
index 0000000000..e26c003cd4
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmObjectReadBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes readObject;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                readObject = realm.createObject(AllTypes.class);
+                readObject.setColumnString("Foo");
+                readObject.setColumnLong(42);
+                readObject.setColumnDouble(1.234D);
+            }
+        });
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void readString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            String value = readObject.getColumnString();
+        }
+    }
+
+    @Benchmark
+    public void readLong(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long value = readObject.getColumnLong();
+        }
+    }
+
+    @Benchmark
+    public void readDouble(long reps) {
+        for (long i = 0; i < reps; i++) {
+            double value = readObject.getColumnDouble();
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
new file mode 100644
index 0000000000..73df749ab6
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmObjectWriteBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes writeObject;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        writeObject = realm.createObject(AllTypes.class);
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Benchmark
+    public void writeString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnString("Foo");
+        }
+    }
+
+    @Benchmark
+    public void writeLong(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnLong(42);
+        }
+    }
+
+    @Benchmark
+    public void writeDouble(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnDouble(1.234D);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
new file mode 100644
index 0000000000..9117d55d0a
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.Sort;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmQueryBenchmarks {
+
+    private static final int DATA_SIZE = 1000;
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        for (int i = 0; i < DATA_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnLong(i);
+            obj.setColumnBoolean(i % 2 == 0);
+            obj.setColumnString("Foo " + i);
+            obj.setColumnDouble(i + 1.234D);
+        }
+        realm.commitTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void containsQuery(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, "Foo 1").findAll();
+        }
+    }
+
+    @Benchmark
+    public void count(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long size = realm.where(AllTypes.class).count();
+        }
+    }
+
+    @Benchmark
+    public void findAll(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        }
+    }
+
+    @Benchmark
+    public void findAllSortedOneField(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
new file mode 100644
index 0000000000..88010f9502
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmResultsBenchmarks {
+
+    private static final int DATA_SIZE = 1000;
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private RealmResults<AllTypes> results;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        for (int i = 0; i < DATA_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnLong(i);
+            obj.setColumnBoolean(i % 2 == 0);
+            obj.setColumnString("Foo " + i);
+            obj.setColumnDouble(i + 1.234D);
+        }
+        realm.commitTransaction();
+        results = realm.where(AllTypes.class).findAll();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void get(long reps) {
+        for (long i = 0; i < reps; i++) {
+            AllTypes item = results.get(0);
+        }
+    }
+
+    @Benchmark
+    public void size(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long size = results.size();
+        }
+    }
+
+    @Benchmark
+    public void min(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number min = results.min(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void max(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number max = results.max(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void average(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number average = results.average(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void sum(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number sum = results.sum(AllTypes.FIELD_LONG);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
new file mode 100644
index 0000000000..47a1136b30
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.config;
+
+import android.os.Environment;
+
+import java.io.File;
+import java.util.concurrent.TimeUnit;
+
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.config.RuntimeInstrumentConfig;
+import dk.ilios.spanner.output.ResultProcessor;
+
+/**
+ * Static helper class for creating benchmark configurations
+ * */
+public class BenchmarkConfig {
+
+    public static SpannerConfig getConfiguration(String className) {
+        // Document folder is located at: /sdcard/realm-benchmarks
+        // Benchmarks results should be saved in <documentFolder>/results/<className>.json
+        // Baseline data should be found in <documentFolder>/baselines/<className>.json
+        // Custom CSV files should be found in <documentFolder>/csv/<className>.csv
+        File externalDocuments = new File(Environment.getExternalStorageDirectory(), "realm-benchmarks");
+        if (!externalDocuments.exists() && !externalDocuments.mkdir()) {
+            throw new RuntimeException("Could not create benchmark folder: " + externalDocuments);
+        }
+        File resultsDir = new File(externalDocuments, "results");
+        File baselineDir = new File(externalDocuments, "baselines");
+        File baselineFile = new File(baselineDir, className + ".json");
+        File csvDir = new File(externalDocuments, "csv");
+        csvDir.mkdir();
+        File csvFile = new File(csvDir, className + ".csv");
+        ResultProcessor csvResultProcessor = new CSVResultProcessor(csvFile);
+
+        // General configuration for running benchmarks.
+        // Always save result files. CI will determine if it wants to store them.
+        SpannerConfig.Builder builder = new SpannerConfig.Builder()
+                .saveResults(resultsDir, className + ".json")
+                .trialsPrExperiment(1)
+                .maxBenchmarkThreads(1)
+                .addInstrument(new RuntimeInstrumentConfig.Builder()
+                                .gcBeforeEachMeasurement(true)
+                                .warmupTime(0, TimeUnit.SECONDS)
+                                .timingInterval(500, TimeUnit.MILLISECONDS)
+                                .measurements(9)
+                                .build()
+                )
+                .addResultProcessor(csvResultProcessor);
+
+        // Only use baseline file if it exists
+        if (baselineFile.exists()) {
+            builder.useBaseline(baselineFile);
+            // Test that 25. , 50. and 75. percentile don't change by more than 15%
+            builder.percentileFailureLimit(25f, 0.15f);
+            builder.percentileFailureLimit(50f, 0.15f);
+            builder.percentileFailureLimit(75f, 0.15f);
+        }
+
+        return builder.build();
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
new file mode 100644
index 0000000000..9a11c14fb2
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.config;
+
+import com.google.common.io.Files;
+import com.opencsv.CSVWriter;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.text.DecimalFormat;
+
+import dk.ilios.spanner.model.Trial;
+import dk.ilios.spanner.output.ResultProcessor;
+
+/**
+ * Converts the result of a benchmark to CSV for easier processing by other data/graph programs.
+ *
+ * Output is the following.
+ * methodname, trialNumber, params, measurements, min, max, average, 25pct, 50pct, 75pct
+ */
+public class CSVResultProcessor implements ResultProcessor {
+
+    private  static final boolean APPLY_QUOTES = true;
+    private static final DecimalFormat decimalFormater = new DecimalFormat("#.00");
+
+    private final File resultFile;
+    private final File workFile;
+    private final CSVWriter writer;
+
+    public CSVResultProcessor(File resultFile) {
+        this.resultFile = resultFile;
+        this.workFile = new File(resultFile.getPath() + ".tmp");
+        try {
+            writer = new CSVWriter(new FileWriter(resultFile));
+            addLabels();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void addLabels() {
+        String[] labels = new String[] {
+                "Method name",
+                "Trial",
+                "Measurements",
+                "Min.",
+                "Max.",
+                "Mean",
+                "25pct.",
+                "50pct.",
+                "75pct.",
+        };
+
+        writer.writeNext(labels, APPLY_QUOTES);
+    }
+
+    @Override
+    public void processTrial(Trial trial) {
+        String methodName = trial.experiment().instrumentation().benchmarkMethod().getName();
+        int trialNo = trial.getTrialNumber();
+        int measurements = trial.measurements().size();
+        double min = trial.getMin();
+        double max = trial.getMax();
+        double mean = trial.getMean();
+        double percentile25 = trial.getPercentile(25);
+        double percentile50 = trial.getMedian();
+        double percentile75 = trial.getPercentile(75);
+
+        String[] resultLine = new String[] {
+                methodName,
+                Integer.toString(trialNo),
+                Integer.toString(measurements),
+                decimalFormater.format(min),
+                decimalFormater.format(max),
+                decimalFormater.format(mean),
+                decimalFormater.format(percentile25),
+                decimalFormater.format(percentile50),
+                decimalFormater.format(percentile75)
+        };
+
+        writer.writeNext(resultLine);
+    }
+
+    @Override
+    public void close() throws IOException {
+        writer.close();
+        if (workFile.exists()) {
+            Files.move(workFile, resultFile);
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 074bc81e53..ebb39bcd37 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -19,6 +19,8 @@
 import android.os.Handler;
 import android.os.Looper;
 
+import com.getkeepsafe.relinker.BuildConfig;
+
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -28,6 +30,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
@@ -77,15 +80,21 @@ protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
         this.sharedGroupManager = new SharedGroupManager(configuration);
         this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
         this.handlerController = new HandlerController(this);
-        setAutoRefresh(autoRefresh);
+        if (Looper.myLooper() == null) {
+            if (autoRefresh) {
+                throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
+            }
+        } else {
+            setAutoRefresh(autoRefresh);
+        }
     }
 
     /**
      * Sets the auto-refresh status of the Realm instance.
      * <p>
      * Auto-refresh is a feature that enables automatic update of the current Realm instance and all its derived objects
-     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in
-     * another thread. This feature is only available if the Realm instance lives is a {@link android.os.Looper} enabled
+     * (RealmResults and RealmObject instances) when a commit is performed on a Realm acting on the same file in
+     * another thread. This feature is only available if the Realm instance lives on a {@link android.os.Looper} enabled
      * thread.
      *
      * @param autoRefresh {@code true} will turn auto-refresh on, {@code false} will turn it off.
@@ -93,7 +102,7 @@ protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
      */
     public void setAutoRefresh(boolean autoRefresh) {
         checkIfValid();
-        if (autoRefresh && Looper.myLooper() == null) {
+        if (Looper.myLooper() == null) {
             throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
         }
 
@@ -126,6 +135,9 @@ public boolean isInTransaction() {
     }
 
     protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
         checkIfValid();
         if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
@@ -137,10 +149,14 @@ protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
      * Removes the specified change listener.
      *
      * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
      */
     public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
         checkIfValid();
         if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't remove a listener from a non-Looper thread ");
@@ -152,8 +168,8 @@ public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listen
      * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
      * when subscribed to. Items will continually be emitted as the Realm is updated -
      * {@code onComplete} will never be called.
-     *
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * <p>
+     * If you would like the {@code asObservable()} to stop emitting items, you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
      * <pre>
@@ -166,6 +182,7 @@ public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listen
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public abstract Observable asObservable();
 
     /**
@@ -238,30 +255,6 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IO
         sharedGroupManager.copyToFile(destination, key);
     }
 
-    /**
-     * Refreshes the Realm instance and all the RealmResults and RealmObjects instances coming from it.
-     * It also calls the listeners associated to the Realm instance.
-     *
-     * @throws IllegalStateException if attempting to refresh from within a transaction.
-     * @deprecated Please use {@link #waitForChange()} instead.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    @Deprecated
-    public void refresh() {
-        checkIfValid();
-        if (isInTransaction()) {
-            throw new IllegalStateException(BaseRealm.CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE);
-        }
-        if (!handlerController.isAutoRefreshEnabled()) {
-            // non Looper Thread, just advance the Realm
-            // registering listeners is not allowed, hence nothing to notify
-            sharedGroupManager.advanceRead();
-            handlerController.refreshSynchronousTableViews();
-        } else {
-            handlerController.notifyCurrentThreadRealmChanged();
-        }
-    }
-
     /**
      * Blocks the current thread until new changes to the Realm are available or {@link #stopWaitForChange()}
      * is called from another thread. Once stopWaitForChange is called, all future calls to this method will
@@ -311,13 +304,13 @@ public void onCall() {
     }
 
     /**
-     * Starts a transaction, this must be closed with {@link io.realm.Realm#commitTransaction()} or aborted by
+     * Starts a transaction which must be closed by {@link io.realm.Realm#commitTransaction()} or aborted by
      * {@link io.realm.Realm#cancelTransaction()}. Transactions are used to atomically create, update and delete objects
      * within a Realm.
-     * <br>
-     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the realm in the case of
+     * <p>
+     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the Realm in the case of
      * pending updates from other threads.
-     * <br>
+     * <p>
      * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
      * thrown.
      */
@@ -329,7 +322,7 @@ public void beginTransaction() {
     /**
      * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the Realm reverts back to
      * being read-only. An event is sent to notify all other Realm instances that a change has occurred. When the event
-     * is received, the other Realms will get their objects and {@link io.realm.RealmResults} updated to reflect the
+     * is received, the other Realms will update their objects and {@link io.realm.RealmResults} to reflect the
      * changes from this commit.
      */
     public void commitTransaction() {
@@ -380,9 +373,9 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
     /**
      * Reverts all writes (created, updated, or deleted objects) made in the current write transaction and end the
      * transaction.
-     * <br>
+     * <p>
      * The Realm reverts back to read-only.
-     * <br>
+     * <p>
      * Calling this when not in a transaction will throw an exception.
      */
     public void cancelTransaction() {
@@ -602,6 +595,7 @@ static private boolean deletes(String canonicalPath, File rootFolder, String rea
         List<File> filesToDelete = Arrays.asList(
                 new File(rootFolder, realmFileName),
                 new File(rootFolder, realmFileName + ".lock"),
+                // Old core log file naming styles
                 new File(rootFolder, realmFileName + ".log_a"),
                 new File(rootFolder, realmFileName + ".log_b"),
                 new File(rootFolder, realmFileName + ".log"),
@@ -637,9 +631,19 @@ public void onResult(int count) {
                 File realmFolder = configuration.getRealmFolder();
                 String realmFileName = configuration.getRealmFileName();
                 File managementFolder = new File(realmFolder, realmFileName + management);
-                realmDeleted.set(deletes(realmFolder.getPath()+ "/" + realmFileName + management, managementFolder, realmFileName));
-                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
 
+                // delete files in management folder and the folder
+                // there is no subfolders in the management folder
+                File[] files = managementFolder.listFiles();
+                if (files != null) {
+                    for (File file : files) {
+                        realmDeleted.set(realmDeleted.get() && file.delete());
+                    }
+                }
+                realmDeleted.set(realmDeleted.get() && managementFolder.delete());
+
+                // delete specific files in root folder
+                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
             }
         });
 
@@ -648,6 +652,10 @@ public void onResult(int count) {
 
     /**
      * Compacts the Realm file defined by the given configuration.
+     *
+     * @param configuration configuration for the Realm to compact.
+     * @throw IllegalArgumentException if Realm is encrypted.
+     * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
         if (configuration.getEncryptionKey() != null) {
@@ -660,8 +668,8 @@ static boolean compactRealm(final RealmConfiguration configuration) {
     /**
      * Migrates the Realm file defined by the given configuration using the provided migration block.
      *
-     * @param configuration configuration for the Realm that should be migrated
-     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}
+     * @param configuration configuration for the Realm that should be migrated.
+     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 0a9436b15a..e1f2cd89df 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -18,27 +18,27 @@
 
 import android.os.Looper;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
 import io.realm.internal.log.RealmLog;
 import rx.Observable;
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
  * done using string based class names instead of class type references.
- *
+ * <p>
  * This is useful during migrations or when working with string-based data like CSV or XML files.
- *
+ * <p>
  * The same {@link io.realm.RealmConfiguration} can be used to open a Realm file in both dynamic and typed mode, but
  * modifying the schema while having both a typed and dynamic version open is highly discouraged and will most likely
  * crash the typed Realm. During migrations only a DynamicRealm will be open.
- *
+ * <p>
  * Dynamic Realms do not enforce schemas or schema versions and {@link RealmMigration} code is not used even if it has
  * been defined in the {@link RealmConfiguration}.
- *
- * This means that the schema is not created or validated until a Realm has been opened in typed mode, so if a Realm
+ * <p>
+ * This means that the schema is not created or validated until a Realm has been opened in typed mode. If a Realm
  * file is opened in dynamic mode first it will not contain any information about classes and fields, and any queries
  * for classes defined by the schema will fail.
  *
@@ -89,7 +89,7 @@ public DynamicRealmObject createObject(String className) {
      * @return the new object. All fields will have default values for their type, except for the
      * primary key field which will have the provided value.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expectd value.
      */
@@ -101,9 +101,9 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     }
 
     /**
-     * Returns a RealmQuery, which can be used to query for the provided class.
+     * Returns a RealmQuery, which can be used to query the provided class.
      *
-     * @param className The class of the object which is to be queried for.
+     * @param className the class of the object which is to be queried.
      * @return a RealmQuery, which can be used to query for specific objects of provided type.
      * @see io.realm.RealmQuery
      * @throws IllegalArgumentException if the class doesn't exist.
@@ -111,7 +111,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
         if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
-            throw new IllegalArgumentException("Class does not exist in the Realm so it cannot be queried: " + className);
+            throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
     }
@@ -120,17 +120,15 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     /**
      * Adds a change listener to the Realm.
      * <p>
-     * The listeners will be executed:
-     * <ul>
-     * <li>Immediately if a change was committed by the local thread</li>
-     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
-     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
-     * </ul>
-     *
-     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
-     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
+     * The listeners will be executed on every loop of a Handler thread if changes are committed by
+     * this or another thread.
+     * <p>
+     * Realm instances are cached per thread. For that reason it is important to
+     * remember to remove listeners again either using {@link #removeChangeListener(RealmChangeListener)}
+     * or {@link #removeAllChangeListeners()}. Not doing so can cause memory leaks.
      *
      * @param listener the change listener.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
      * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
      * @see #removeChangeListener(RealmChangeListener)
@@ -140,18 +138,6 @@ public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
         super.addListener(listener);
     }
 
-    /**
-     * Removes all objects of the specified class.
-     *
-     * DEPRECATED: Use {@link #delete(String)} instead.
-     *
-     * @param className the class for which all objects should be removed.
-     */
-    @Deprecated
-    public void clear(String className) {
-        delete(className);
-    }
-
     /**
      * Deletes all objects of the specified class from the Realm.
      *
@@ -189,55 +175,6 @@ public void executeTransaction(Transaction transaction) {
         }
     }
 
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll()} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjects(String className) {
-        return where(className).findAll();
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName, sortOrder)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName, Sort sortOrder) {
-        checkIfValid();
-        Table table = schema.getTable(className);
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        TableView tableView = table.getSortedView(columnIndex, sortOrder);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName1,
-                                                                    Sort sortOrder1, String fieldName2,
-                                                                    Sort sortOrder2) {
-        return allObjectsSorted(className, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
-                sortOrder2});
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldNames[], sortOrders[])} instead.
-     */
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldNames[], Sort sortOrders[]) {
-        checkAllObjectsSortedParameters(fieldNames, sortOrders);
-        Table table = schema.getTable(className);
-
-        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
     /**
      * Creates a {@link DynamicRealm} instance without checking the existence in the {@link RealmCache}.
      *
@@ -248,40 +185,11 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
         return new DynamicRealm(configuration, autoRefresh);
     }
 
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(fieldName)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinct(String className, String fieldName) {
-        checkIfValid();
-        Table table = schema.getTable(className);
-        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
-        TableView tableView = table.getDistinctView(columnIndex);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinctAsync(fieldName)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinctAsync(String className, String fieldName) {
-        checkIfValid();
-        return where(className).distinctAsync(fieldName);
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(firstFieldName, remainingFieldNames)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinct(String className, String firstFieldName, String... remainingFieldNames) {
-        checkIfValid();
-        return where(className).distinct(firstFieldName, remainingFieldNames);
-    }
-
     /**
      * {@inheritDoc}
      */
     @Override
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<DynamicRealm> asObservable() {
         return configuration.getRxFactory().from(this);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index e9bab17c59..773ad0894f 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -49,7 +49,7 @@ public DynamicRealmObject(RealmModel obj) {
 
         if (!RealmObject.isValid(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
-                    "is a standalone object or it was deleted.");
+                    "is an unmanaged object or it was deleted.");
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) obj;
@@ -102,12 +102,13 @@ public DynamicRealmObject(RealmModel obj) {
 
     /**
      * Returns the {@code boolean} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the boolean value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain booleans.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain booleans.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public boolean getBoolean(String fieldName) {
@@ -117,12 +118,13 @@ public boolean getBoolean(String fieldName) {
 
     /**
      * Returns the {@code int} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the int value. Integer values exceeding {@code Integer.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public int getInt(String fieldName) {
@@ -131,12 +133,13 @@ public int getInt(String fieldName) {
 
     /**
      * Returns the {@code short} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the short value. Integer values exceeding {@code Short.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public short getShort(String fieldName) {
@@ -145,12 +148,13 @@ public short getShort(String fieldName) {
 
     /**
      * Returns the {@code long} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the long value. Integer values exceeding {@code Long.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public long getLong(String fieldName) {
@@ -160,12 +164,13 @@ public long getLong(String fieldName) {
 
     /**
      * Returns the {@code byte} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the byte value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public byte getByte(String fieldName) {
@@ -175,12 +180,13 @@ public byte getByte(String fieldName) {
 
     /**
      * Returns the {@code float} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the float value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain floats.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain floats.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public float getFloat(String fieldName) {
@@ -190,12 +196,13 @@ public float getFloat(String fieldName) {
 
     /**
      * Returns the {@code double} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the double value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain doubles.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain doubles.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public double getDouble(String fieldName) {
@@ -208,7 +215,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the byte[] value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain binary data.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain binary data.
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -220,7 +227,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the String value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Strings.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Strings.
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -232,7 +239,7 @@ public String getString(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the Date value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Dates.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Dates.
      */
     public Date getDate(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -248,7 +255,7 @@ public Date getDate(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link DynamicRealmObject} representation of the linked object or {@code null} if no object is linked.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain links to other objects.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain links to other objects.
      */
     public DynamicRealmObject getObject(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -266,7 +273,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link RealmList} data for this field.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain a list of links.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -280,7 +287,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return {@code true} if field value is null, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exists.
+     * @throws IllegalArgumentException if field name doesn't exist.
      */
     public boolean isNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -332,13 +339,13 @@ public boolean hasField(String fieldName) {
     }
 
     /**
-     * Set the value for the given field. This method will automatically try to convert numbers and
-     * booleans that are given as {@code String} to their appropriate type. E.g. {@code "10"} will be
-     * converted to {@code 10} if the field type is {@code int}.
-     *
+     * Sets the value for the given field. This method will automatically try to convert numbers and
+     * booleans that are given as {@code String} to their appropriate type. For example {@code "10"} 
+     * will be converted to {@code 10} if the field type is {@code int}.
+     * <p>
      * Using the typed setters will be faster than using this method.
-     *
-     * @throws IllegalArgumentException if field name doesn't exists or if the input value cannot be converted
+     * 
+     * @throws IllegalArgumentException if field name doesn't exist or if the input value cannot be converted
      * to the appropriate input type.
      * @throws NumberFormatException if a String based number cannot be converted properly.
      */
@@ -410,7 +417,7 @@ private void setValue(String fieldName, Object value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a boolean field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a boolean field.
      */
     public void setBoolean(String fieldName, boolean value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -422,7 +429,7 @@ public void setBoolean(String fieldName, boolean value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setShort(String fieldName, short value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -434,7 +441,7 @@ public void setShort(String fieldName, short value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setInt(String fieldName, int value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -446,7 +453,7 @@ public void setInt(String fieldName, int value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setLong(String fieldName, long value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -458,7 +465,7 @@ public void setLong(String fieldName, long value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setByte(String fieldName, byte value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -470,7 +477,7 @@ public void setByte(String fieldName, byte value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a float field.
      */
     public void setFloat(String fieldName, float value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -482,7 +489,7 @@ public void setFloat(String fieldName, float value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a double field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a double field.
      */
     public void setDouble(String fieldName, double value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -494,7 +501,7 @@ public void setDouble(String fieldName, double value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a String field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
      */
     public void setString(String fieldName, String value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -506,7 +513,7 @@ public void setString(String fieldName, String value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a binary field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a binary field.
      */
     public void setBlob(String fieldName, byte[] value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -518,7 +525,7 @@ public void setBlob(String fieldName, byte[] value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a Date field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a Date field.
      */
     public void setDate(String fieldName, Date value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -534,7 +541,7 @@ public void setDate(String fieldName, Date value) {
      *
      * @param fieldName field name.
      * @param value object to link to.
-     * @throws IllegalArgumentException if field name doesn't exists, it doesn't link to other Realm objects, the type
+     * @throws IllegalArgumentException if field name doesn't exist, it doesn't link to other Realm objects, the type
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
     public void setObject(String fieldName, DynamicRealmObject value) {
@@ -575,7 +582,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
         String tableName = proxyState.getRow$realm().getTable().getName();
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
-            // Standalone lists don't know anything about the types they contain. They might even hold objects of
+            // Unmanaged lists don't know anything about the types they contain. They might even hold objects of
             // multiple types :(, so we have to check each item in the list.
             typeValidated = false;
         } else {
@@ -609,7 +616,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
      * Sets the value to {@code null} for the given field.
      *
      * @param fieldName field name.
-     * @throws IllegalArgumentException if field name doesn't exists, or the field isn't nullable.
+     * @throws IllegalArgumentException if field name doesn't exist, or the field isn't nullable.
      */
     public void setNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -622,7 +629,7 @@ public void setNull(String fieldName) {
     }
 
     /**
-     * Return the type of object. This will normally correspond to the name of a class that is extending
+     * Returns the type of object. This will normally correspond to the name of a class that is extending
      * {@link RealmObject}.
      *
      * @return this objects type.
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index fbce366d0e..d202599e34 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -29,6 +29,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
@@ -50,6 +51,7 @@
     static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
     static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
     static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+    private final static Boolean NO_REALM_QUERY = Boolean.TRUE;
 
     // Keep a strong reference to the registered RealmChangeListener
     // user should unregister those listeners
@@ -63,7 +65,7 @@
     final BaseRealm realm;
     private boolean autoRefresh; // Requires a Looper thread to be true.
 
-    // pending update of async queriess
+    // pending update of async queries
     private Future updateAsyncQueriesTask;
 
     private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueAsyncRealmResults =
@@ -81,15 +83,19 @@
     // Keep a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
     // the query in the background for each commit, until we got a valid Row (pointer)
     final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> emptyAsyncRealmObject =
-            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
+            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
 
-    // keep a reference to the list of sync RealmResults, we'll use it
+    // Keep a reference to the list of sync RealmResults, we'll use it
     // to deliver type based notification once the shared_group advance
     final IdentitySet<WeakReference<RealmResults<? extends RealmModel>>> syncRealmResults =
             new IdentitySet<WeakReference<RealmResults<? extends RealmModel>>>();
 
-    final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
-            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
+    // Since ConcurrentHashMap doesn't support null value, and since java.util.Optional are not
+    // yet an option (using Java 6) we use an Object with the dummy value Boolean.TRUE to indicate
+    // a null value (no RealmQuery<? extends RealmModel>) this is the same approach used in the JDK
+    // ex here https://android.googlesource.com/platform/libcore/+/refs/heads/master/luni/src/main/java/java/util/concurrent/ConcurrentSkipListSet.java#214
+    final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
+            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object>();
 
     public HandlerController(BaseRealm realm) {
         this.realm = realm;
@@ -143,7 +149,8 @@ void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
 
     /**
      * For internal use only.
-     * Sometimes we don't know when to unregister listeners (ex: {@link RealmBaseAdapter}). Using
+     * <p>
+     * Sometimes we don't know when to unregister listeners (e.g., {@code RealmBaseAdapter}). Using
      * a WeakReference the listener doesn't need to be explicitly unregistered.
      *
      * @param listener the change listener.
@@ -527,7 +534,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
                         // cleanup a previously empty async RealmObject
                         emptyAsyncRealmObject.remove(realmObjectWeakReference);
-                        realmObjects.put(realmObjectWeakReference, null);
+                        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
                     }
                     proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
                     proxy.realmGet$proxyState().notifyChangeListeners$realm();
@@ -541,11 +548,15 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                         proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT " + proxy + "] , realm:" + HandlerController.this
                                 + " RealmObject is not loaded yet. Rerun the query.");
-                        RealmQuery<?> realmQuery = realmObjects.get(realmObjectWeakReference);
-                        if (realmQuery == null) { // this is a retry of an empty RealmObject
+                        Object value = realmObjects.get(realmObjectWeakReference);
+                        RealmQuery<? extends RealmModel> realmQuery;
+                        if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
                             realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
+
+                        } else {
+                            realmQuery = (RealmQuery<? extends RealmModel>) value;
                         }
 
                         QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
@@ -590,10 +601,10 @@ private boolean threadContainsAsyncQueries() {
     }
 
     /**
-     * Indicate the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}
-     * empty means no pointer to a valid Row. This will help to caller to decice when to rerun the query.
+     * Indicates the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}.
+     * Empty means no pointer to a valid Row. This will help caller to decide when to rerun the query.
      *
-     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject} {@code false} otherwise.
+     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject}, {@code false} otherwise.
      */
     boolean threadContainsAsyncEmptyRealmObject() {
         boolean isEmpty = true;
@@ -647,7 +658,7 @@ void addToRealmResults(RealmResults<? extends RealmModel> realmResults) {
         }
         final WeakReference<RealmObjectProxy> realmObjectWeakReference =
                 new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
-        realmObjects.put(realmObjectWeakReference, null);
+        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
     }
 
     <E extends RealmObjectProxy> WeakReference<RealmObjectProxy> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmModel> realmQuery) {
@@ -665,11 +676,11 @@ void addToEmptyAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakR
     }
 
     /**
-     * Refreshes all synchronous RealmResults by calling `sync_if_needed` on them. This will cause any backing queries
-     * to be rerun and any deleted objects will be removed from the TableView.
-     *
+     * Refreshes all synchronous RealmResults by calling {@code sync_if_needed} on them. This will cause any backing queries
+     * to rerun and any deleted objects will be removed from the TableView.
+     * <p>
      * WARNING: This will _NOT_ refresh TableViews created from async queries.
-     *
+     * <p>
      * Note this will _not_ notify any registered listeners.
      */
     public void refreshSynchronousTableViews() {
@@ -697,7 +708,7 @@ public boolean isAutoRefreshEnabled() {
     }
 
     /**
-     * Notify the current thread that the Realm has changed. This will also trigger change listener asynchronously.
+     * Notifies the current thread that the Realm has changed. This will also trigger change listener asynchronously.
      */
     public void notifyCurrentThreadRealmChanged() {
         if (realm != null) {
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index f594bdd85a..29376bff76 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -50,7 +50,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or it has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName);
 
@@ -63,7 +63,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName, Sort sortOrder);
 
@@ -79,7 +79,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2);
 
@@ -92,7 +92,7 @@
      * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders);
 
@@ -102,7 +102,7 @@
      * @param location the array index identifying the object to be removed.
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     void deleteFromRealm(int location);
 
@@ -111,7 +111,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called on the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteFirstFromRealm();
 
@@ -120,7 +120,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteLastFromRealm();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index c8926b45f9..97ddcb253c 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -41,6 +41,7 @@
 import java.util.Set;
 import java.util.concurrent.Future;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -57,7 +58,7 @@
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
  * instances of your RealmObjects. Objects within a Realm can be queried and read at any time. Creating, modifying, and
- * deleting objects must be done while inside a transaction. See {@link #beginTransaction()}
+ * deleting objects must be done while inside a transaction. See {@link #executeTransaction(Transaction)}
  * <p>
  * The transactions ensure that multiple instances (on multiple threads) can access the same objects in a consistent
  * state with full ACID guarantees.
@@ -71,10 +72,10 @@
  * Realm and should be considered a lightweight operation.
  * <p>
  * For the UI thread this means that opening and closing Realms should occur in either onCreate/onDestroy or
- *  onStart/onStop.
+ * onStart/onStop.
  * <p>
  * Realm instances coordinate their state across threads using the {@link android.os.Handler} mechanism. This also means
- * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #refresh()}
+ * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #waitForChange()}
  * is manually called.
  * <p>
  * A standard pattern for working with Realm in Android activities can be seen below:
@@ -142,6 +143,7 @@
      * {@inheritDoc}
      */
     @Override
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<Realm> asObservable() {
         return configuration.getRxFactory().from(this);
     }
@@ -157,27 +159,6 @@ protected void finalize() throws Throwable {
         super.finalize();
     }
 
-    /**
-     * Realm static constructor for the default Realm file {@value io.realm.RealmConfiguration#DEFAULT_REALM_NAME}.
-     * This is equivalent to calling {@code Realm.getInstance(new RealmConfiguration(getContext()).build())}.
-     *
-     * This constructor is only provided for convenience. It is recommended to use
-     * {@link #getInstance(RealmConfiguration)} or {@link #getDefaultInstance()}.
-     *
-     * @param context a non-null Android {@link android.content.Context}
-     * @return an instance of the Realm class.
-     * @throws java.lang.IllegalArgumentException if no {@link Context} is provided.
-     * @throws RealmMigrationNeededException if the RealmObject classes no longer match the underlying Realm and it must
-     *         be migrated.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
-     * @deprecated use {@link #getDefaultInstance()} or {@link #getInstance(RealmConfiguration)} instead.
-     */
-    public static Realm getInstance(Context context) {
-        return Realm.getInstance(new RealmConfiguration.Builder(context)
-                .name(DEFAULT_REALM_NAME)
-                .build());
-    }
-
     /**
      * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
      * by {@link #setDefaultConfiguration(RealmConfiguration)}
@@ -239,7 +220,7 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be
+     * @param columnIndices if this is not  {@code null}, the {@link BaseRealm#schema#columnIndices} will be
      *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
      *                      the Realm file.
      * @return a {@link Realm} instance.
@@ -334,8 +315,9 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the RealmObject
+     * <p>
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject}
      * field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
@@ -386,7 +368,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -441,7 +423,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} value will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -509,13 +491,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
-     * @return created object or null if no json data was provided.
+     * @return created object or {@code null} if no JSON data was provided.
      * @throws RealmException if the mapping from JSON fails.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
@@ -560,13 +542,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if mapping to json failed.
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
@@ -617,15 +599,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} value will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if the mapping from JSON failed.
-     * @throws IOException if something was wrong with the input stream.
+     * @throws IOException if something went wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
@@ -706,9 +688,9 @@ private Scanner getFullStringScanner(InputStream in) {
     /**
      * Instantiates and adds a new object to the Realm.
      *
-     * @param clazz the Class of the object to create
-     * @return the new object
-     * @throws RealmException if an object could not be created
+     * @param clazz the Class of the object to create.
+     * @return the new object.
+     * @throws RealmException if an object cannot be created.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
@@ -719,7 +701,7 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Instantiates and adds a new object to the Realm with the primary key value already set.
-     *
+     * <p>
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
      *
@@ -727,7 +709,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expected value.
      */
@@ -737,16 +719,12 @@ private Scanner getFullStringScanner(InputStream in) {
         return get(clazz, rowIndex);
     }
 
-    void remove(Class<? extends RealmModel> clazz, long objectIndex) {
-        getTable(clazz).moveLastOver(objectIndex);
-    }
-
     /**
      * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
      * will not be reflected in the Realm copy. This is a deep copy, so all referenced objects will be copied. Objects
      * already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in this and child objects will be
      * set to their default value if not provided.
      *
      * @param object the {@link io.realm.RealmObject} to copy to the Realm.
@@ -761,10 +739,10 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
 
     /**
      * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or creates
-     * a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects will be
      * either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the object and child objects will be
      * set to their default value if not provided.
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
@@ -781,10 +759,10 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
 
     /**
      * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes to the
-     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy, so all referenced objects
+     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy i.e., all referenced objects
      * will be copied. Objects already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects the RealmObjects to copy to the Realm.
@@ -807,10 +785,10 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
 
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
-     * creates a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects
+     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects
      * will be either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects a list of objects to update or copy into Realm.
@@ -832,17 +810,17 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmModel)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects,
      * and can potentially override changes made by other threads.
      *
-     * @param realmObjects RealmObjects to copy
+     * @param realmObjects RealmObjects to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of managed RealmObjects.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -853,12 +831,12 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects up to the defined depth.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(Iterable)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects
      * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
@@ -879,28 +857,28 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
             return new ArrayList<E>(0);
         }
 
-        ArrayList<E> standaloneObjects = new ArrayList<E>();
+        ArrayList<E> unmanagedObjects = new ArrayList<E>();
         Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
-            standaloneObjects.add(createDetachedCopy(object, maxDepth, listCache));
+            unmanagedObjects.add(createDetachedCopy(object, maxDepth, listCache));
         }
 
-        return standaloneObjects;
+        return unmanagedObjects;
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -911,18 +889,18 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects up to the defined depth.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
      * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
      * reached. This can also potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
      * {@code 0}.
      * @param <E> type of object.
@@ -937,10 +915,6 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
         return createDetachedCopy(realmObject, maxDepth, new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>());
     }
 
-    boolean contains(Class<? extends RealmModel> clazz) {
-        return configuration.getSchemaMediator().getModelClasses().contains(clazz);
-    }
-
     /**
      * Returns a typed RealmQuery, which can be used to query for specific objects of this type
      *
@@ -956,17 +930,15 @@ boolean contains(Class<? extends RealmModel> clazz) {
     /**
      * Adds a change listener to the Realm.
      * <p>
-     * The listeners will be executed:
-     * <ul>
-     * <li>Immediately if a change was committed by the local thread</li>
-     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
-     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
-     * </ul>
-     *
-     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
-     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
+     * The listeners will be executed on every loop of a Handler thread if
+     * the current thread or other threads committed changes to the Realm.
+     * <p>
+     * Realm instances are per thread singletons and cached, so listeners should be
+     * removed manually even if calling {@link #close()}. Otherwise there is a
+     * risk of memory leaks.
      *
      * @param listener the change listener.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
      * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
      * @see #removeChangeListener(RealmChangeListener)
@@ -976,100 +948,6 @@ public void addChangeListener(RealmChangeListener<Realm> listener) {
         super.addListener(listener);
     }
 
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAll()} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjects(Class<E> clazz) {
-        return where(clazz).findAll();
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName, sortOrder)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
-                                                                    Sort sortOrder) {
-        checkIfValid();
-        Table table = getTable(clazz);
-        long columnIndex = schema.columnIndices.getColumnIndex(clazz, fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        TableView tableView = table.getSortedView(columnIndex, sortOrder);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                                    Sort sortOrder1, String fieldName2,
-                                                                    Sort sortOrder2) {
-        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
-                sortOrder2});
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2, fieldName3, sortOrder3)}
-     * instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                                    Sort sortOrder1,
-                                                                    String fieldName2, Sort sortOrder2,
-                                                                    String fieldName3, Sort sortOrder3) {
-        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldNames[], sortOrders[])} instead.
-     */
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
-                                                                    Sort sortOrders[]) {
-        checkAllObjectsSortedParameters(fieldNames, sortOrders);
-        Table table = this.getTable(clazz);
-
-        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinct(fieldName)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
-        checkIfValid();
-        Table table = schema.getTable(clazz);
-        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
-        TableView tableView = table.getDistinctView(columnIndex);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinctAsync(fieldName)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
-        checkIfValid();
-        return where(clazz).distinctAsync(fieldName);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinct(firstFieldName, remainingFieldNames)} instead.
-     */
-    @Deprecated
-    public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
-        checkIfValid();
-        return where(clazz).distinct(firstFieldName, remainingFieldNames);
-    }
-
     /**
      * Executes a given transaction on the Realm. {@link #beginTransaction()} and {@link #commitTransaction()} will be
      * called automatically. If any exception is thrown during the transaction {@link #cancelTransaction()} will be
@@ -1097,110 +975,12 @@ public void executeTransaction(Transaction transaction) {
         }
     }
 
-    /**
-     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
-     *
-     * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @param callback optional, to receive the result of this query.
-     * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
-     *         another thread.
-     * @deprecated replaced by {@link #executeTransactionAsync(Transaction)},
-     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess)},
-     * {@link #executeTransactionAsync(Transaction, io.realm.Realm.Transaction.OnError)} and
-     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess, Transaction.OnError)}.
-     */
-    @Deprecated
-    public RealmAsyncTask executeTransaction(final Transaction transaction, final Transaction.Callback callback) {
-        checkIfValid();
-        if (transaction == null) {
-            throw new IllegalArgumentException("Transaction should not be null");
-        }
-
-        // If the user provided a Callback then we make sure, the current Realm has a Handler
-        // we can use to deliver the result
-        if (callback != null && handler == null) {
-            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
-                    " and you provided a callback, we need a Handler to invoke your callback");
-        }
-
-        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
-        // to perform the transaction
-        final RealmConfiguration realmConfiguration = getConfiguration();
-
-        final Future<?> pendingTransaction = asyncTaskExecutor.submit(new Runnable() {
-            @Override
-            public void run() {
-                if (Thread.currentThread().isInterrupted()) {
-                    return;
-                }
-
-                boolean transactionCommitted = false;
-                final Exception[] exception = new Exception[1];
-                final Realm bgRealm = Realm.getInstance(realmConfiguration);
-                bgRealm.beginTransaction();
-                try {
-                    transaction.execute(bgRealm);
-
-                    if (!Thread.currentThread().isInterrupted()) {
-                        bgRealm.commitTransaction(false, new Runnable() {
-                            @Override
-                            public void run() {
-                                // The bgRealm needs to be closed before post event to caller's handler to avoid
-                                // concurrency problem. eg.: User wants to delete Realm in the callbacks.
-                                // This will close Realm before sending REALM_CHANGED.
-                                bgRealm.close();
-                            }
-                        });
-                        transactionCommitted = true;
-                    }
-                } catch (final Exception e) {
-                    exception[0] = e;
-                } finally {
-                    if (!bgRealm.isClosed()) {
-                        if (bgRealm.isInTransaction()) {
-                            bgRealm.cancelTransaction();
-                        } else if (exception[0] != null) {
-                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
-                        }
-                        bgRealm.close();
-                    }
-
-                    // Send response as the final step to ensure the bg thread quit before others get the response!
-                    if (callback != null
-                            && handler != null
-                            && !Thread.currentThread().isInterrupted()
-                            && handler.getLooper().getThread().isAlive()) {
-                        if (transactionCommitted) {
-                            handler.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    callback.onSuccess();
-                                }
-                            });
-                        } else if (exception[0] != null) {
-                            // transaction has not been canceled by there is a exception during transaction.
-                            handler.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    callback.onError(exception[0]);
-                                }
-                            });
-                        }
-                    }
-                }
-            }
-        });
-
-        return new RealmAsyncTask(pendingTransaction);
-    }
-
     /**
      * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the Realm is opened from
      *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
@@ -1228,7 +1008,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnError callback.
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1246,7 +1026,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param onSuccess callback invoked when the transaction succeeds.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1366,20 +1146,6 @@ public void run() {
         return new RealmAsyncTask(pendingTransaction);
     }
 
-
-    /**
-     * Removes all objects of the specified class.
-     *
-     * DEPRECATED: Use {@link #delete(Class)} instead.
-     *
-     * @param clazz the class which objects should be removed.
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public void clear(Class<? extends RealmModel> clazz) {
-        delete(clazz);
-    }
-
     /**
      * Deletes all objects of the specified class from the Realm.
      *
@@ -1463,7 +1229,7 @@ public void migrationComplete() {
 
     /**
      * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
-     * The Realm must be unused and closed before calling this method.
+     * All Realm instances must be closed before calling this method.
      *
      * @param configuration a {@link RealmConfiguration}.
      * @return {@code false} if a file could not be deleted. The failing file will be logged.
@@ -1513,7 +1279,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
      * from library or project dependencies. Realm classes in these should be exposed using their own module.
      *
-     * @return the default Realm module or null if no default module exists.
+     * @return the default Realm module or {@code null} if no default module exists.
      * @throws RealmException if unable to create an instance of the module.
      * @see io.realm.RealmConfiguration.Builder#modules(Object, Object...)
      */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 35b554dc21..824f7fb7ed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -15,11 +15,16 @@
  */
 package io.realm;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.Map;
 
+import io.realm.exceptions.RealmIOException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.log.RealmLog;
 
@@ -102,6 +107,8 @@ private RealmCache(RealmConfiguration config) {
             cache = new RealmCache(configuration);
             // The new cache should be added to the map later.
             isCacheInMap = false;
+
+            copyAssetFileIfNeeded(configuration);
         } else {
             // Throw the exception if validation failed.
             cache.validateConfiguration(configuration);
@@ -113,6 +120,7 @@ private RealmCache(RealmConfiguration config) {
             // Create a new local Realm instance
             BaseRealm realm;
 
+
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
                 realm = Realm.createInstance(configuration, cache.typedColumnIndices);
@@ -266,7 +274,7 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         callback.onResult(totalRefCount);
     }
 
-    /**
+   /**
      * Runs the callback function with synchronization on {@class RealmCache}.
      *
      * @param callback the callback will be executed.
@@ -274,4 +282,53 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
     static synchronized void invokeWithLock(Callback0 callback) {
         callback.onCall();
     }
+
+    /**
+     * Copies Realm database file from Android asset directory to the directory given in the {@link RealmConfiguration}.
+     * Copy is performed only at the first time when there is no Realm database file.
+     *
+     * @param configuration configuration object for Realm instance.
+     * @throws IOException if copying the file fails.
+     */
+    private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
+        if (configuration.hasAssetFile()) {
+            File realmFile = new File(configuration.getRealmFolder(), configuration.getRealmFileName());
+            if (realmFile.exists()) {
+                return;
+            }
+
+            InputStream inputStream = null;
+            FileOutputStream outputStream = null;
+            try {
+                inputStream = configuration.getAssetFile();
+                if (inputStream == null) {
+                    throw new RealmIOException("Invalid input stream to asset file.");
+                }
+
+                outputStream = new FileOutputStream(realmFile);
+                byte[] buf = new byte[4096];
+                int bytesRead;
+                while ((bytesRead = inputStream.read(buf)) > -1) {
+                    outputStream.write(buf, 0, bytesRead);
+                }
+            } catch (IOException e) {
+                throw new RealmIOException("Could not resolve the path to the Realm asset file.", e);
+            } finally {
+                if (inputStream != null) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException e) {
+                        // Ignore this exception because any significant errors should already have been handled
+                    }
+                }
+                if (outputStream != null) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException e) {
+                        throw new RealmIOException("Invalid output stream to " + realmFile.getPath(), e);
+                    }
+                }
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index f68e7f6be4..2e8e7ff7c1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -22,11 +22,8 @@
  * <p>
  * When registered against a {@code Realm} you'll get notified when a Realm instance has been updated.
  * Register against a {@code RealmResults} or {@code RealmObject} to only get notified about changes to them.
- *
  * <p>
- * Realm instances on a thread without an {@link android.os.Looper} (almost all background threads) don't get updated
- * automatically, but have to call {@link Realm#refresh()} manually. This will in turn trigger the RealmChangeListener
- * for that background thread.
+ * Realm instances on a thread without an {@link android.os.Looper} cannot register a RealmChangeListener.
  * <p>
  * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain their new values when
  * the {@link #onChange(Object)} method is called. Normally this means that it isn't necessary to query again for those
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 7c4328c8d8..6278272dc2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -24,7 +24,7 @@
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
  * collections and the behavior that they will have in all implementations of {@code RealmCollection}s.
- *
+ * <p>
  * Realm collections are "live" views to the underlying data. This means that they automatically will be kept up to
  * date. As a consequence, using methods like {@link Collections#unmodifiableCollection(Collection)} will not prevent
  * a collection from being modified.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 89d723eeb7..a398f90992 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -17,8 +17,12 @@
 package io.realm;
 
 import android.content.Context;
+import android.text.TextUtils;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
@@ -38,21 +42,23 @@
 
 /**
  * A RealmConfiguration is used to setup a specific Realm instance.
- *
+ * <p>
  * Instances of a RealmConfiguration can only created by using the {@link io.realm.RealmConfiguration.Builder} and calling
  * its {@link io.realm.RealmConfiguration.Builder#build()} method.
- *
+ * <p>
  * A commonly used RealmConfiguration can easily be accessed by first saving it as
  * {@link Realm#setDefaultConfiguration(RealmConfiguration)} and then using {@link io.realm.Realm#getDefaultInstance()}.
- *
+ * <p>
  * A minimal configuration can be created using:
- *
+ * <p>
  * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
- *
+ * <p>
  * This will create a RealmConfiguration with the following properties.
- * - Realm file is called "default.realm"
- * - It is saved in Context.getFilesDir()
- * - It has its schema version set to 0.
+ * <ul>
+ * <li>Realm file is called "default.realm"</li>
+ * <li>It is saved in Context.getFilesDir()</li>
+ * <li>It has its schema version set to 0.</li>
+ * </ul>
  */
 public final class RealmConfiguration {
 
@@ -81,6 +87,7 @@
     private final File realmFolder;
     private final String realmFileName;
     private final String canonicalPath;
+    private final String assetFilePath;
     private final byte[] key;
     private final long schemaVersion;
     private final RealmMigration migration;
@@ -89,11 +96,13 @@
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
+    private final WeakReference<Context> contextWeakRef;
 
     private RealmConfiguration(Builder builder) {
         this.realmFolder = builder.folder;
         this.realmFileName = builder.fileName;
         this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.assetFilePath = builder.assetFilePath;
         this.key = builder.key;
         this.schemaVersion = builder.schemaVersion;
         this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
@@ -102,6 +111,7 @@ private RealmConfiguration(Builder builder) {
         this.schemaMediator = createSchemaMediator(builder);
         this.rxObservableFactory = builder.rxFactory;
         this.initialDataTransaction = builder.initialDataTransaction;
+        this.contextWeakRef = builder.contextWeakRef;
     }
 
     public File getRealmFolder() {
@@ -150,6 +160,30 @@ RealmProxyMediator getSchemaMediator() {
         return initialDataTransaction;
     }
 
+    /**
+     * Indicates if there is available asset file for copy action.
+     *
+     * @return {@code true} if there is asset file, {@code false} otherwise.
+     */
+    boolean hasAssetFile() {
+        return !TextUtils.isEmpty(assetFilePath);
+    }
+
+    /**
+     * Returns input stream object to the Realm asset file.
+     *
+     * @return input stream to the asset file.
+     * @throws IOException if copying the file fails.
+     */
+    InputStream getAssetFile() throws IOException {
+        Context context = contextWeakRef.get();
+        if (context != null) {
+            return context.getAssets().open(assetFilePath);
+        } else {
+            throw new IllegalArgumentException("Context should not be null. Use Application Context instead of Activity Context.");
+        }
+    }
+
     /**
      * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
      *
@@ -294,7 +328,7 @@ public String toString() {
     /**
      * Checks if RxJava is can be loaded.
      *
-     * @return true if RxJava dependency exist.
+     * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
     private static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
@@ -314,6 +348,7 @@ private static synchronized boolean isRxJavaAvailable() {
     public static final class Builder {
         private File folder;
         private String fileName;
+        private String assetFilePath;
         private byte[] key;
         private long schemaVersion;
         private RealmMigration migration;
@@ -321,6 +356,7 @@ private static synchronized boolean isRxJavaAvailable() {
         private SharedGroup.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        private WeakReference<Context> contextWeakRef;
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
@@ -328,8 +364,8 @@ private static synchronized boolean isRxJavaAvailable() {
          * Creates an instance of the Builder for the RealmConfiguration.
          * The Realm file will be saved in the provided folder.
          *
-         * @param folder Folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exists or isn't writable.
+         * @param folder the folder to save Realm file in. Folder must be writable.
+         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
          */
         public Builder(File folder) {
             RealmCore.loadLibrary();
@@ -338,12 +374,12 @@ public Builder(File folder) {
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
-         *
-         * This will use the apps own internal directory for storing the Realm file. This does not require any
+         * <p>
+         * This will use the app's own internal directory for storing the Realm file. This does not require any
          * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
          * change depending on vendor implementations of Android.
          *
-         * @param context Android context.
+         * @param context an Android context.
          */
         public Builder(Context context) {
             if (context == null) {
@@ -405,7 +441,7 @@ public Builder encryptionKey(byte[] key) {
         /**
          * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
          * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
-         *
+         * <p>
          * If no migration code is provided, Realm will throw a
          * {@link io.realm.exceptions.RealmMigrationNeededException}.
          *
@@ -453,29 +489,25 @@ public Builder deleteRealmIfMigrationNeeded() {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
+            if (!TextUtils.isEmpty(assetFilePath)) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+
             this.durability = SharedGroup.Durability.MEM_ONLY;
-            return this;
-        }
 
-        /**
-         * DEPRECATED: Use {@link #modules(Object, Object...)} instead.
-         */
-        @Deprecated
-        public Builder setModules(Object baseModule, Object... additionalModules) {
-            modules(baseModule, additionalModules);
             return this;
         }
 
         /**
          * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
          * current schema for this Realm with the schema defined by the provided modules.
-         *
+         * <p>
          * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
          * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
          * dependency is thus done using the following code:
-         *
+         * <p>
          * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
-         *
+         * <p>
          * @param baseModule the first Realm module (required).
          * @param additionalModules the additional Realm modules
          * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
@@ -515,6 +547,34 @@ public Builder initialData(Realm.Transaction transaction) {
             return this;
         }
 
+        /**
+         * Copies the Realm file from the given asset file path.
+         * <p>
+         * When opening the Realm for the first time, instead of creating an empty file,
+         * the Realm file will be copied from the provided assets file and used instead.
+         * <p>
+         * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
+         *
+         * @param context Android application context.
+         * @param assetFile path to the asset database file.
+         */
+        public Builder assetFile(Context context, final String assetFile) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            if (TextUtils.isEmpty(assetFile)) {
+                throw new IllegalArgumentException("A non-empty asset file path must be provided");
+            }
+            if (durability == SharedGroup.Durability.MEM_ONLY) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+
+            this.contextWeakRef = new WeakReference<>(context);
+            this.assetFilePath = assetFile;
+
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index ac3f1e6af3..7bff1ed043 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -23,7 +23,7 @@
 
 /**
  * List of the types used by Realm's underlying storage engine.
- *
+ * <p>
  * Normally there is no reason to interact with the underlying Realm types as Realm will automatically
  * convert between normal Java types and the Realm types. However it is possible to access these
  * types through a {@link DynamicRealmObject}.
@@ -64,7 +64,7 @@
     /**
      * Returns the native value representing this type.
      *
-     * @return The value used by the underlying storage engine to represent this type.
+     * @return the value used by the underlying storage engine to represent this type.
      */
     public int getNativeValue() {
         return nativeValue;
@@ -72,7 +72,7 @@ public int getNativeValue() {
 
     /**
      * Checks if the given Java object can be converted to the underlying Realm type.
-     * @param obj Object to test compatibility on.
+     * @param obj object to test compatibility on.
      * @return {@code true} if object can be converted to the Realm type, {@code false} otherwise.
      */
     public boolean isValid(Object obj) {
@@ -104,8 +104,8 @@ public boolean isValid(Object obj) {
     /**
      * Converts the underlying value used by the storage engine to the proper Realm type.
      *
-     * @param value Value to convert
-     * @return The corresponding Realm type.
+     * @param value the value to convert
+     * @return the corresponding Realm type.
      * @throws IllegalArgumentException if value isn't valid.
      */
     public static RealmFieldType fromNativeValue(int value) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index c7d66424d0..ee9e96291a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -39,9 +39,9 @@
  * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the
  * underlying Realm is updated, and can only be accessed using the getter of a {@link io.realm.RealmObject}.
  * <p>
- * Non-managed RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
+ * Unmanaged RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
  * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
- * Non-managed elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
+ * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
  * <p>
  * {@link RealmList} can contain more elements than {@code Integer.MAX_VALUE}.
  * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
@@ -60,25 +60,25 @@
     protected String className;
     protected LinkView view;
     protected BaseRealm realm;
-    private List<E> nonManagedList;
+    private List<E> unmanagedList;
 
     /**
      * Creates a RealmList in non-managed mode, where the elements are not controlled by a Realm.
      * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
      * the objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist it's elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
         managedMode = false;
-        nonManagedList = new ArrayList<E>();
+        unmanagedList = new ArrayList<E>();
     }
 
     /**
      * Creates a RealmList in non-managed mode with an initial list of elements.
      * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not possible to query the
      * objects in this state.
-     *
+     * <p>
      * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements in Realm.
      *
      * @param objects initial objects in the list.
@@ -88,16 +88,16 @@ public RealmList(E... objects) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
         managedMode = false;
-        nonManagedList = new ArrayList<E>(objects.length);
-        Collections.addAll(nonManagedList, objects);
+        unmanagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(unmanagedList, objects);
     }
 
     /**
      * Creates a RealmList from a LinkView, so its elements are managed by Realm.
      *
-     * @param clazz type of elements in the Array
-     * @param linkView  backing LinkView
-     * @param realm reference to Realm containing the data
+     * @param clazz type of elements in the Array.
+     * @param linkView  backing LinkView.
+     * @param realm reference to Realm containing the data.
      */
     RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
         this.managedMode = true;
@@ -114,10 +114,10 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e. the {@link io.realm.Realm}
+     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e., the {@link io.realm.Realm}
      * instance hasn't been closed.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an un-managed list.
+     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an unmanaged list.
      */
     public boolean isValid() {
         //noinspection SimplifiableIfStatement
@@ -136,11 +136,11 @@ private boolean isAttached() {
      * element at the specified location. If the location is equal to the size of this List, the object is added at the
      * end.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -161,7 +161,7 @@ public void add(int location, E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.insert(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(location, object);
+            unmanagedList.add(location, object);
         }
         modCount++;
     }
@@ -169,17 +169,17 @@ public void add(int location, E object) {
     /**
      * Adds the specified object at the end of this List.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      *
      * @param object the object to add.
-     * @return always true
+     * @return always {@code true}.
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      */
     @Override
@@ -190,7 +190,7 @@ public boolean add(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(object);
+            unmanagedList.add(object);
         }
         modCount++;
         return true;
@@ -199,11 +199,11 @@ public boolean add(E object) {
     /**
      * Replaces the element at the specified location in this list with the specified object.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed.
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed.
      * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
      * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -224,12 +224,12 @@ public E set(int location, E object) {
             view.set(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
             return oldObject;
         } else {
-            oldObject = nonManagedList.set(location, object);
+            oldObject = unmanagedList.set(location, object);
         }
         return oldObject;
     }
 
-    // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
+    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
     private E copyToRealmIfNeeded(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
@@ -276,7 +276,7 @@ private E copyToRealmIfNeeded(E object) {
 
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
-     * RealmObjects will be shifted so no null values are introduced.
+     * RealmObjects will be shifted so no {@code null} values are introduced.
      *
      * @param oldPos index of RealmObject to move.
      * @param newPos target position. If newPos &lt; oldPos the object at the location will be shifted to the right. If
@@ -291,11 +291,11 @@ public void move(int oldPos, int newPos) {
         } else {
             checkIndex(oldPos);
             checkIndex(newPos);
-            E object = nonManagedList.remove(oldPos);
+            E object = unmanagedList.remove(oldPos);
             if (newPos > oldPos) {
-                nonManagedList.add(newPos - 1, object);
+                unmanagedList.add(newPos - 1, object);
             } else {
-                nonManagedList.add(newPos, object);
+                unmanagedList.add(newPos, object);
             }
         }
     }
@@ -314,7 +314,7 @@ public void clear() {
             checkValidView();
             view.clear();
         } else {
-            nonManagedList.clear();
+            unmanagedList.clear();
         }
         modCount++;
     }
@@ -335,7 +335,7 @@ public E remove(int location) {
             removedItem = get(location);
             view.remove(location);
         } else {
-            removedItem = nonManagedList.remove(location);
+            removedItem = unmanagedList.remove(location);
         }
         modCount++;
         return removedItem;
@@ -343,8 +343,8 @@ public E remove(int location) {
 
     /**
      * Removes one instance of the specified object from this {@code Collection} if one
-     * is contained . This implementation iterates over this
-     * {@code Collection} and tests for each element {@code e} returned by the iterator,
+     * is contained. This implementation iterates over this
+     * {@code Collection} and tests each element {@code e} returned by the iterator,
      * whether {@code e} is equal to the given object. If {@code object != null}
      * then this test is performed using {@code object.equals(e)}, otherwise
      * using {@code object == null}. If an element equal to the given object is
@@ -372,7 +372,7 @@ public boolean remove(Object object) {
      * elements in the passed {@code Collection} can be found in this {@code Collection}
      * anymore.
      * <p>
-     * This implementation iterates over this {@code Collection} and tests for each
+     * This implementation iterates over the {@code Collection} and tests each
      * element {@code e} returned by the iterator, whether it is contained in
      * the specified {@code Collection}. If this test is positive, then the {@code
      * remove} method is called on the iterator.
@@ -441,15 +441,12 @@ public E get(int location) {
             long rowIndex = view.getTargetRowIndex(location);
             return realm.get(clazz, className, rowIndex);
         } else {
-            return nonManagedList.get(location);
+            return unmanagedList.get(location);
         }
     }
 
     /**
-     * Finds the first object.
-     *
-     * @return the first object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E first() {
         if (managedMode) {
@@ -457,17 +454,14 @@ public E first() {
             if (!view.isEmpty()) {
                 return get(0);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(0);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(0);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
 
     /**
-     * Finds the last object.
-     *
-     * @return the last object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E last() {
         if (managedMode) {
@@ -475,8 +469,8 @@ public E last() {
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(nonManagedList.size() - 1);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(unmanagedList.size() - 1);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
@@ -548,7 +542,7 @@ public int size() {
             long size = view.size();
             return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
         } else {
-            return nonManagedList.size();
+            return unmanagedList.size();
         }
     }
 
@@ -664,7 +658,7 @@ public boolean deleteAllFromRealm() {
      */
     @Override
     public boolean isLoaded() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
@@ -672,14 +666,14 @@ public boolean isLoaded() {
      */
     @Override
     public boolean load() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
-     * Returns true if the list contains the specified element when attached to a Realm. This
+     * Returns {@code true} if the list contains the specified element when attached to a Realm. This
      * method will query the native Realm underlying storage engine to quickly find the specified element.
-     *
-     * If this list is not attached to a Realm the default {@link List#contains(Object)}
+     * <p>
+     * If the list is not attached to a Realm, the default {@link List#contains(Object)}
      * implementation will occur.
      *
      * @param object the element whose presence in this list is to be tested.
@@ -697,7 +691,7 @@ public boolean contains(Object object) {
                 }
             }
         } else {
-            contains = nonManagedList.contains(object);
+            contains = unmanagedList.contains(object);
         }
         return contains;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmMigration.java b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
index 70ec9df868..5140a3bf6a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmMigration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
@@ -18,12 +18,12 @@
 
 /**
  * The RealmMigration class is used to perform the migration of one Realm schema to another.
- * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}, so any
- * changes to these classes will require a migration.
- *
+ * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}
+ * or implement {@link io.realm.RealmModel}, so any changes to these classes will require a migration.
+ * <p>
  * To support migrations from any previous schemaVersion to the newest, the following pattern is recommended when
  * writing a migration:
- *
+ * <p>
  * <pre>
  * {@code
  * public class CustomMigration implements RealmMigration {
@@ -48,7 +48,7 @@
  * }
  * }
  * </pre>
- *
+ * <p>
  * During development when RealmObject classes can change frequently, it is possible to use
  * {@link io.realm.Realm#deleteRealm(RealmConfiguration)}. This will delete the database file and eliminate the need for
  * any migrations.
@@ -61,7 +61,7 @@
 
     /**
      * This method will be called if a migration is needed. The entire method is wrapped in a
-     * write transaction so it is possible to create/change or delete any existing objects
+     * write transaction so it is possible to create, update or delete any existing objects
      * without wrapping it in your own transaction.
      *
      * @param realm the Realm schema on which to perform the migration.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmModel.java b/realm/realm-library/src/main/java/io/realm/RealmModel.java
index 8fbf94f3ac..0c4c8a1046 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmModel.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmModel.java
@@ -21,7 +21,7 @@
 
 /**
  * Interface for marking classes as RealmObjects, it can be used instead of extending {@link RealmObject}.
- *
+ * <p>
  * All helper methods available to classes that extend RealmObject are instead available as static methods:
  *
  * <pre>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 141ad52292..4495b0757e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -19,13 +19,14 @@
 import java.util.List;
 
 import io.realm.annotations.RealmClass;
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import rx.Observable;
 
 /**
- * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then 
+ * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then
  * create your objects within a Realm, and use your custom subclasses instead of using the RealmObject class directly.
  * <p>
  * An annotation processor will create a proxy class for your RealmObject subclass.
@@ -49,7 +50,8 @@
  * within a Realm.
  * <p>
  * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
- * Any method as well as public fields are allowed.
+ * Any method as well as public fields are allowed. When providing custom constructors, a public constructor with
+ * no arguments must be declared and be empty.
  * <p>
  * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
  * getter or setter.
@@ -65,20 +67,6 @@
 
 @RealmClass
 public abstract class RealmObject implements RealmModel {
-    /**
-     * DEPRECATED: Use {@link #deleteFromRealm()} instead.
-     *
-     * Removes the object from the Realm it is currently associated to.
-     * <p>
-     * After this method is called the object will be invalid and any operation (read or write) performed on it will
-     * fail with an IllegalStateException
-     *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public final void removeFromRealm() {
-        deleteFromRealm();
-    }
 
     /**
      * Deletes the object from the Realm it is currently associated to.
@@ -92,7 +80,7 @@ public final void removeFromRealm() {
     public final void deleteFromRealm() {
         deleteFromRealm(this);
     }
-    
+
     /**
      * Deletes the object from the Realm it is currently associated with.
      * <p>
@@ -124,21 +112,32 @@ public final void deleteFromRealm() {
 
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * <p>
+     * Note that this can be used to check the validity of certain conditions such as being {@code null}
+     * when observed.
+     * <pre>
+     * {@code
+     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asObservable()
+     *      .filter(result.isLoaded() && result.isValid())
+     *      .first()
+     * }
+     * </pre>
      *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
     public final boolean isValid() {
         return RealmObject.isValid(this);
     }
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
      *
      * @param object RealmObject to check validity for.
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
      */
     public static <E extends RealmModel> boolean isValid(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -153,7 +152,7 @@ public final boolean isValid() {
     /**
      * Determines if the current RealmObject is obtained synchronously or asynchronously (from a worker thread).
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
      * progress.
@@ -165,7 +164,7 @@ public final boolean isLoaded() {
     /**
      * Determines if the RealmObject is obtained synchronously or asynchronously (from a worker thread).
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @param object RealmObject to check.
      * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
@@ -183,7 +182,8 @@ public final boolean isLoaded() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
@@ -193,7 +193,8 @@ public final boolean load() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @param object RealmObject to force load.
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
@@ -216,7 +217,8 @@ public final boolean load() {
      * Adds a change listener to this RealmObject.
      *
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
         RealmObject.addChangeListener((E) this, listener);
@@ -227,9 +229,14 @@ public final boolean load() {
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+        if (object == null) {
+            throw new IllegalArgumentException("Object should not be null");
+        }
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -260,6 +267,8 @@ public final boolean load() {
      * Removes a previously registered listener.
      *
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public final void removeChangeListener(RealmChangeListener listener) {
         RealmObject.removeChangeListener(this, listener);
@@ -270,8 +279,14 @@ public final void removeChangeListener(RealmChangeListener listener) {
      *
      * @param object RealmObject to remove listener from.
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
+        if (object == null) {
+            throw new IllegalArgumentException("Object should not be null");
+        }
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -303,7 +318,7 @@ public final void removeChangeListeners() {
             proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
             proxy.realmGet$proxyState().getListeners$realm().clear();
         } else {
-            throw new IllegalArgumentException("Cannot remove listeners from this un-managed RealmObject (created outside of Realm)");
+            throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
         }
     }
 
@@ -311,10 +326,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
@@ -327,12 +342,19 @@ public final void removeChangeListeners() {
      * }
      * </pre>
      *
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
      * @param <E> RealmObject class that is being observed. Must be this class or its super types.
      * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public final <E extends RealmObject> Observable<E> asObservable() {
         return (Observable<E>) RealmObject.asObservable(this);
     }
@@ -341,10 +363,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * emit only the first item by using the {@code first()} operator:
      *
@@ -380,7 +402,7 @@ public final void removeChangeListeners() {
             }
         } else {
             // TODO Is this true? Should we just return Observable.just(object) ?
-            throw new IllegalArgumentException("Cannot create Observables from un-managed RealmObjects");
+            throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 7a3d006452..3b592fccb4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -88,8 +88,10 @@
     /**
      * Returns the name of the RealmObject class being represented by this schema.
      * <p>
-     * When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.
-     * When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.
+     * <ul>
+     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
+     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
+     * </ul>
      *
      * @return the name of the RealmObject class represented by this schema.
      */
@@ -115,7 +117,7 @@ public RealmObjectSchema setClassName(String className) {
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See {@link RealmObject}
-     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.
+     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.,
      * {@code Integer.class} instead of {@code int.class}.
      * <p>
      * To add fields that reference other RealmObjects or RealmLists use {@link #addRealmObjectField(String, RealmObjectSchema)}
@@ -292,7 +294,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field.
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field as well.
      *
      * @param fieldName field to set as primary key.
      * @return the updated schema.
@@ -306,12 +308,17 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
             throw new IllegalStateException("A primary key is already defined");
         }
         table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
         return this;
     }
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class.
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from the field as well.
      *
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
@@ -320,13 +327,17 @@ public RealmObjectSchema removePrimaryKey() {
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
         table.setPrimaryKey("");
         return this;
     }
 
     /**
-     * Sets a field to be required, i.e. not allowed to hold {@code null values}. This is equivalent to switching
-     * between boxed types and their primitive variant e.g. {@code Integer} to {@code int}.
+     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
+     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
      *
      * @param fieldName name of field in the class.
      * @param required  {@code true} if field should be required, {@code false} otherwise.
@@ -362,8 +373,8 @@ public RealmObjectSchema setRequired(String fieldName, boolean required) {
     }
 
     /**
-     * Sets a field to be nullable, i.e. it should be able to hold {@code null values}. This is equivalent to switching
-     * between primitive types and their boxed variant e.g. {@code int} to {@code Integer}.
+     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
+     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
      *
      * @param fieldName name of field in the class.
      * @param nullable  {@code true} if field should be nullable, {@code false} otherwise.
@@ -376,7 +387,7 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
     }
 
     /**
-     * Checks if a given field is required, i.e. is not allowed to contain {@code null} values.
+     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -389,7 +400,7 @@ public boolean isRequired(String fieldName) {
     }
 
     /**
-     * Checks if a given field is nullable, i.e. is allowed to contain {@code null} values.
+     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -479,9 +490,9 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
                 }
 
                 if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
                     addPrimaryKey(fieldName);
+                    indexAdded = true;
                 }
 
                 // REQUIRED is being handled when adding the column using addField through the nullable parameter.
@@ -553,10 +564,10 @@ private void checkEmpty(String str) {
 
     /**
      * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned
+     * each field is returned.
      *
      * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes Legal field type for the last field in a linked field
+     * @param validColumnTypes valid field type for the last field in a linked field
      * @return list of column indices.
      */
     // TODO: consider another caching strategy so linked classes are included in the cache.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index a955dfdc42..da083799ed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -43,7 +43,7 @@
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
- * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}
+ * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}.
  * <p>
  * The input to many of the query functions take a field name as String. Note that this is not type safe. If a 
  * RealmObject class is refactored care has to be taken to not break any queries.
@@ -98,9 +98,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmResults}.
+     * Creates a query from an existing {@link RealmResults}.
      *
-     * @param queryResults   a existing @{link io.realm.RealmResults} to query against.
+     * @param queryResults   an existing @{link io.realm.RealmResults} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -115,9 +115,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmList}.
+     * Creates a query from an existing {@link RealmList}.
      *
-     * @param list   a existing @{link io.realm.RealmList} to query against.
+     * @param list   an existing @{link io.realm.RealmList} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -183,7 +183,7 @@ private RealmQuery(BaseRealm realm, LinkView view, String className) {
     }
 
     /**
-     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't been
+     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e., the {@link io.realm.Realm} instance hasn't been
      * closed and any parent {@link io.realm.RealmResults} is still valid.
      *
      * @return {@code true} if still valid to use, {@code false} otherwise.
@@ -201,9 +201,9 @@ public boolean isValid() {
 
     /**
      * Tests if a field is {@code null}. Only works for nullable fields.
-     *
+     * <p>
      * For link queries, if any part of the link path is {@code null} the whole path is considered to be {@code null}
-     * e.g. {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
+     * e.g., {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
      * {@code linkField.stringField} is {@code null}.
      *
      * @param fieldName the field name.
@@ -254,7 +254,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -422,7 +422,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How casing is handled. {@link Case#INSENSITIVE} works only for the English locale characters.
+     * @param casing     how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -960,7 +960,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return The query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -987,7 +987,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -1014,7 +1014,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or field type.
      */
@@ -1069,7 +1069,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "empty", i.e. an empty list, the 0-length string or byte array.
+     * Condition that finds values that are considered "empty" i.e., an empty list, the 0-length string or byte array.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1083,7 +1083,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "Not-empty", i.e. a list, a string or a byte array with not-empty values.
+     * Condition that finds values that are considered "Not-empty" i.e., a list, a string or a byte array with not-empty values.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1103,7 +1103,7 @@ public boolean isValid() {
      *
      * @param fieldName the field name.
      * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
@@ -1131,7 +1131,7 @@ public boolean isValid() {
      * @return immediately a {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
      * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
@@ -1283,8 +1283,9 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
      * Calculates the sum of a given field.
      *
      * @param fieldName the field to sum. Only number fields are supported.
-     * @return the sum if no objects exist or they all have {@code null} as the value for the given field, {@code 0}
-     * will be returned. When computing the sum, objects with {@code null} values are ignored.
+     * @return the sum of fields of the matching objects. If no objects exist or they all have {@code null} as the value
+     *         for the given field, {@code 0} will be returned. When computing the sum, objects with {@code null} values
+     *         are ignored.
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public Number sum(String fieldName) {
@@ -1648,7 +1649,8 @@ public Long call() throws Exception {
      * @param fieldName the field name to sort by.
      * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
      * objects is returned.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSorted(String fieldName) {
         return findAllSorted(fieldName, Sort.ASCENDING);
@@ -1660,7 +1662,8 @@ public Long call() throws Exception {
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(String fieldName) {
         return findAllSortedAsync(fieldName, Sort.ASCENDING);
@@ -1823,10 +1826,11 @@ public Long call() throws Exception {
      * @param sortOrder2 sort order for second field
      * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
      * objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
-                                   String fieldName2, Sort sortOrder2) {
+                                         String fieldName2, Sort sortOrder2) {
         return findAllSorted(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
@@ -1836,35 +1840,14 @@ public Long call() throws Exception {
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
                                               String fieldName2, Sort sortOrder2) {
         return findAllSortedAsync(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
-    /**
-     * DEPRECATED: Use {@link #findAllSorted(String[], Sort[])}  instead.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
-                                   String fieldName2, Sort sortOrder2,
-                                   String fieldName3, Sort sortOrder3) {
-        return findAllSorted(new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
-    /**
-     * DEPRECATED: Use {@link #findAllSortedAsync(String[], Sort[])}  instead.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
-                                              String fieldName2, Sort sortOrder2,
-                                              String fieldName3, Sort sortOrder3) {
-        return findAllSortedAsync(new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
     /**
      * Finds the first object that fulfills the query conditions.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index abeb92a9c0..42c8a5adf8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -29,6 +29,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
@@ -45,7 +46,7 @@
  * increases speed.
  * <p>
  * RealmResults are live views, which means that if it is on an {@link android.os.Looper} thread, it will automatically
- * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#refresh()}
+ * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#waitForChange()}
  * must be called to update the results.
  * <p>
  * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the modified objects are
@@ -54,7 +55,7 @@
  * A RealmResults object cannot be passed between different threads.
  * <p>
  * Notice that a RealmResults is never {@code null} not even in the case where it contains no objects. You should always
- * use the size() method to check if a RealmResults is empty or not.
+ * use the {@link RealmResults#size()} method to check if a RealmResults is empty or not.
  * <p>
  * If a RealmResults is built on RealmList through {@link RealmList#where()}, it will become empty when the source
  * RealmList gets deleted.
@@ -64,8 +65,7 @@
  *
  * @param <E> The class of objects in this list.
  * @see RealmQuery#findAll()
- * @see Realm#allObjects(Class)
- * @see io.realm.Realm#beginTransaction()
+ * @see io.realm.Realm#executeTransaction(Realm.Transaction)
  */
 public final class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
@@ -218,7 +218,7 @@ public E first() {
         if (size() > 0) {
             return get(0);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -231,7 +231,7 @@ public E last() {
         if (size > 0) {
             return get(size - 1);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -359,24 +359,6 @@ private long getColumnIndexForSort(String fieldName) {
         return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
-    /**
-     * Sorts existing {@link io.realm.RealmResults} using three fields.
-     *
-     * DEPRECATED: Use {@link #sort(String[], Sort[])} instead.
-     *
-     * @param fieldName1 first field name.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name.
-     * @param sortOrder2 sort order for second field.
-     * @param fieldName3 third field name.
-     * @param sortOrder3 sort order for third field.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    @Deprecated
-    public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2, String fieldName3, Sort sortOrder3) {
-        sort(new String[]{fieldName1, fieldName2, fieldName3}, new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
     // Aggregates
 
     /**
@@ -616,18 +598,6 @@ public boolean retainAll(Collection<?> collection) {
         throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
     }
 
-    /**
-     * Removes the last object in the list. This also deletes the object from the underlying Realm.
-     *
-     * DEPRECATED: Use {@link #deleteLastFromRealm()} instead.
-     *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public void removeLast() {
-        deleteLastFromRealm();
-    }
-
     /**
      * Removes the last object in the list. This also deletes the object from the underlying Realm.
      *
@@ -882,12 +852,11 @@ void setPendingQuery(Future<Long> pendingQuery) {
     }
 
     /**
-     * Returns {@code true} if the results are not yet loaded, {@code false} if they are still loading. Synchronous
+     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded. Synchronous
      * query methods like findAll() will always return {@code true}, while asynchronous query methods like
      * findAllAsync() will return {@code false} until the results are available.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is still
+     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
      * running.
      */
     public boolean isLoaded() {
@@ -900,7 +869,7 @@ public boolean isLoaded() {
      * the query completes.
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise. {@code true} will always
-     *         be returned for standalone objects.
+     *         be returned for unmanaged objects.
      */
     public boolean load() {
         //noinspection SimplifiableIfStatement
@@ -939,6 +908,8 @@ private boolean onAsyncQueryCompleted() {
      * Adds a change listener to this RealmResults.
      *
      * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper Thread.
      */
     public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         if (listener == null) {
@@ -957,11 +928,13 @@ public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
      * Removes a previously registered listener.
      *
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public void removeChangeListener(RealmChangeListener listener) {
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
-
+        }
         realm.checkIfValid();
         listeners.remove(listener);
     }
@@ -991,12 +964,19 @@ public void removeChangeListeners() {
      * }
      * </pre>
      *
+     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
      * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+
     @SuppressWarnings("unchecked")
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<RealmResults<E>> asObservable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index aca535075f..d7624d66f0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -30,8 +30,8 @@
 /**
  * Class for interacting with the Realm schema using a dynamic API. This makes it possible
  * to add, delete and change the classes in the Realm.
- *
- * All changes must happen inside a write transaction for that Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
  *
  * @see io.realm.RealmMigration
  */
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index 71329ed351..ae187baff1 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -19,7 +19,6 @@
 /**
  * This class describes the sorting order used in Realm queries.
  *
- * @see io.realm.Realm#allObjectsSorted(Class, String, Sort)
  * @see io.realm.RealmQuery#findAllSorted(String, Sort)
  */
 public enum Sort {
@@ -34,7 +33,7 @@
 
     /**
      * Returns the value for this setting that is used by the underlying query engine.
-     * @return The value used by the underlying query engine to indicate this value.
+     * @return the value used by the underlying query engine to indicate this value.
      */
     public boolean getValue() {
         return value;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index e2700ee8cd..a3e0778864 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -99,7 +99,7 @@
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
      * {@code false} otherwise.
-     * @param cache the cache for mapping between standalone objects and their {@link RealmObjectProxy} representation.
+     * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
@@ -129,13 +129,13 @@
     public abstract <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
 
     /**
-     * Creates a deep standalone copy of a RealmObject. This is a deep copy so all links will be copied as well.
+     * Creates a deep unmanaged copy of a RealmObject. This is a deep copy so all links will be copied as well.
      * The depth can be restricted to a maximum depth after which all links will be turned into null values instead.
      *
      * @param realmObject RealmObject to copy. It must be a valid object.
      * @param maxDepth restrict the depth of the copy to this level. The root object is depth {@code 0}.
-     * @param cache cache used to make sure standalone objects are reused correctly.
-     * @return a standalone copy of the given object.
+     * @param cache cache used to make sure unmanaged objects are reused correctly.
+     * @return an unmanaged copy of the given object.
      */
     public abstract <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index e5b32ae2df..4494e72783 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -1380,17 +1380,34 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, INFINITE);
-    }
+        long columnCount = getColumnCount();
+        String name = getName();
+        StringBuilder stringBuilder = new StringBuilder("The Table ");
+        if (name != null && !name.isEmpty()) {
+            stringBuilder.append(getName());
+            stringBuilder.append(" ");
+        }
+        if (hasPrimaryKey()) {
+            String pkFieldName = getColumnName(getPrimaryKey());
+            stringBuilder.append("has \'" + pkFieldName + "\' field as a PrimaryKey, and ");
+        }
+        stringBuilder.append("contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
+
+        return stringBuilder.toString();
     }
 
     @Override
@@ -1537,8 +1554,6 @@ public static String tableNameToClassName(String tableName) {
     private native String nativeGetName(long nativeTablePtr);
     private native void nativeOptimize(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
     private native long nativeVersion(long nativeTablePtr);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 32ebc23ed3..bcd596e6c2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -334,10 +334,6 @@
 
     String toString();
 
-    String toString(long maxRows);
-
-    String rowToString(long rowIndex);
-
     TableQuery where();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index 6928abda3a..efcf5ff2c0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -724,17 +724,24 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, 500);
-    }
+        long columnCount = getColumnCount();
+        StringBuilder stringBuilder = new StringBuilder("The TableView contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
+
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        return stringBuilder.toString();
     }
 
     @Override
@@ -896,8 +903,6 @@ public long syncIfNeeded() {
     private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
     private native long createNativeTableView(Table table, long nativeTablePtr);
     private native String nativeToJson(long nativeViewPtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
     private native long nativeWhere(long nativeViewPtr);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
     private native long nativeDistinct(long nativeViewPtr, long columnIndex);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index c2558fca93..179a839f1f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -211,7 +211,7 @@ private boolean isAliveHandler(Handler handler) {
 
         public static Result newRealmResultsResponse() {
             Result result = new Result();
-            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<?>>, Long>(1);
+            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long>(1);
             return result;
         }
 
diff --git a/version.txt b/version.txt
index 222360a331..5902d52cce 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.91.0-SNAPSHOT
+1.1.0-SNAPSHOT
