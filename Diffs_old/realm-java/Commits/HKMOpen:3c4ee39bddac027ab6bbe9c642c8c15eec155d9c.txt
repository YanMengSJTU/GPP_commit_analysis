diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 176f10ecb4..c0ed464344 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,5 +1,20 @@
 # Contributing
 
+## Filing Issues
+
+Whether you find a bug, typo or an API call that could be clarified, please [file an issue](https://github.com/realm/realm-java/issues) on our GitHub repository.
+
+When filing an issue, please provide as much of the following information as possible in order to help us fix it:
+
+1. **Goals**
+2. **Expected results**
+3. **Actual results**
+4. **Steps to reproduce**
+5. **Code sample that highlights the issue** (link to full Android Studio projects that we can compile ourselves are ideal)
+6. **Version of Realm/Android Studio/OS**
+
+If you'd like to send us sensitive sample code to help troubleshoot your issue, you can email <help@realm.io> directly.
+
 ## Contributing Enhancements
 
 We love contributions to Realm! If you'd like to contribute code, documentation, or any other improvements, please [file a Pull Request](https://github.com/realm/realm-java/pulls) on our GitHub repository. Make sure to accept our [CLA](#CLA)!
diff --git a/README.md b/README.md
index 9935aaeff7..2f96578272 100644
--- a/README.md
+++ b/README.md
@@ -21,11 +21,25 @@ The API reference is located at [realm.io/docs/java/api](http://realm.io/docs/ja
 
 ## Getting Help
 
-- **Reproducible Bugs & Feature Requests** should be filed directly against our [Github Issues](https://github.com/realm/realm-java/issues).
-- **Discussions & Support**: [realm-java@googlegroups.com](https://groups.google.com/d/forum/realm-java).
-- **StackOverflow**: look for previous questions under the tag [#realm](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [open a new one](http://stackoverflow.com/questions/ask?tags=realm).
+- **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We activtely monitor & answer questions on SO!
+- **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
+- **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
+- **Want to ask in-depth questions?** [Join our online office hours](https://attendee.gotowebinar.com/rt/1182038037080364033). We host these once a month, and you can join via chat, audio call, or video call.
 - Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
-- Attend our monthly [**Online Office Hours**](https://attendee.gotowebinar.com/rt/1182038037080364033) to ask questions directly to the team.
+
+## Using Snapshots
+
+If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [JFrog](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-android/)
+
+    repositories {
+        maven {
+            url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'
+        }
+    }
+
+    dependencies {
+      compile 'io.realm:realm-android:0.81.2-SNAPSHOT'
+    }
 
 ## Building Realm
 
@@ -36,7 +50,7 @@ Prerequisites:
 * Make sure `make` is available in your `$PATH`
 * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
 * Download & install the Android SDK, **Android 4.4W (API 20)** (for example through Android Studio’s **Android SDK Manager**)
-* _Also_ download & install the Android SDK, **Android 4.4.2 (API 20)** (for example through Android Studio’s **Android SDK Manager**)
+* _Also_ download & install the Android SDK, **Android 4.4.2 (API 19)** (for example through Android Studio’s **Android SDK Manager**)
 * Download the **Android NDK (= r10d)**. For example, on Mac OS you can do this with [Homebrew](http://brew.sh) with `brew install android-ndk`.
 * Add a `local.properties` file at the root of this folder with the correct paths for the Android SDK and NDK, for example:
 
@@ -59,21 +73,6 @@ That command will generate the .jar file containing the Realm runtime and the an
 Generating the Javadoc using the command above will report a failure (1 error, 30+ warnings). The Javadoc is generated, and we will fix 
 `realm/build.gradle` in the near future.
 
-## Filing Issues
-
-Whether you find a bug, typo or an API call that could be clarified, please [file an issue](https://github.com/realm/realm-java/issues) on our GitHub repository.
-
-When filing an issue, please provide as much of the following information as possible in order to help us fix it:
-
-1. **Goals**
-2. **Expected results**
-3. **Actual results**
-4. **Steps to reproduce**
-5. **Code sample that highlights the issue** (link to full Android Studio projects that we can compile ourselves are ideal)
-6. **Version of Realm/Android Studio/OS**
-
-If you'd like to send us sensitive sample code to help troubleshoot your issue, you can email <help@realm.io> directly.
-
 ## Contributing
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
diff --git a/build.gradle b/build.gradle
index f19347a12e..0ca1d69da1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,13 +3,13 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.android.tools.build:gradle:1.2.3'
         classpath 'de.undercouch:gradle-download-task:1.0'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:0.5' // Version 0.6 seems to require gradle 2.0+
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2'
         classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.0'
+        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
     }
 }
 
@@ -17,8 +17,7 @@ allprojects {
   apply plugin: 'android-sdk-manager'
 
   group = 'io.realm'
-  version = new File("${rootDir}/version.txt").text
-
+  version = new File("${rootDir}/version.txt").text.trim();
   repositories {
     jcenter()
   }
diff --git a/changelog.txt b/changelog.txt
index cc05a18b94..bc6ce1a7b9 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,4 +1,44 @@
+0.81.1
+ * Fixed memory leak causing Realm to never release Realm objects.
+
 0.81
+ * Introduced RealmModules for working with custom schemas in libraries and apps.
+ * Introduced Realm.getDefaultInstance(), Realm.setDefaultInstance(RealmConfiguration) and Realm.getInstance(RealmConfiguration).
+ * Deprecated most constructors. They have been been replaced by Realm.getInstance(RealmConfiguration) and Realm.getDefaultInstance().
+ * Deprecated Realm.migrateRealmAtPath(). It has been replaced by Realm.migrateRealm(RealmConfiguration).
+ * Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
+ * Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
+ * RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
+ * Realm now works with Kotlin (M12+). (thanks @cypressious)
+ * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
+ * Added a check to give a better error message when null is used as value for a primary key. 
+ * Fixed unchecked cast warnings when building with Realm.
+ * Cleaned up examples (remove old test project).
+ * Added checking for missing generic type in RealmList fields in annotation processor.
+
+0.80.3
+ * Calling Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+ * Fixed a bug making it impossible to open Realms created by Realm-Cocoa if a model had a primary key defined.
+ * Trying to using Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+ * RealmChangedListener now also gets called on the same thread that did the commit.
+ * Fixed bug where Realm.createOrUpdateWithJson() reset Date and Binary data to default values if not found in the JSON output.
+ * Fixed a memory leak when using RealmBaseAdapter.
+ * RealmBaseAdapter now allow RealmResults to be null (thanks @zaki50).
+ * Fixed a bug where a change to a model class (RealmList<A> to RealmList<B>) would not throw a RealmMigrationNeededException.
+ * Fixed a bug where where setting multiple RealmLists didn't remove the previously added objects.
+ * Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (thanks @beeender)
+ * Fixed duplicated listeners in the same realm instance. Trying to add duplicated listeners is ignored now. (thanks @beeender)
+
+0.80.2
+ * Trying to use Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
+ * RealmMigrationNeedException can now return the path to the Realm that needs to be migrated.
+ * Fixed bug where creating a Realm instance with a hashcode collision no longer returned the wrong Realm instance.
+ * Updated Realm Core to version 0.89.2
+   - fixed bug causing a crash when opening an encrypted Realm file on ARM64 devices.
+
+0.80.1
+ * Realm.createOrUpdateWithJson() no longer resets fields to their default value if they are not found in the JSON input.
+ * Realm.compactRealmFile() now uses Realm Core's compact() method which is more failure resilient.
  * Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
  * The ARM64 binary is now properly a part of the Eclipse distribution package.
  * A RealmMigrationExceptionNeeded is now properly thrown if @Index and @PrimaryKey are not set correctly during a migration.
@@ -6,6 +46,14 @@
  * Added Realm.deleteRealmFile(File) method.
  * Fixed bug causing queries to fail if multiple Realms has different field ordering.
  * Fixed bug when using Realm.copyToRealm() with a primary key could crash if default value was already used in the Realm.
+ * Updated Realm Core to version 0.89.0
+   - improved performance for sorting RealmResults.
+   - improved performance for refreshing a Realm after inserting or modifying strings or binary data.
+   - fixed bug causing incorrect result when querying indexed fields.
+   - fixed bug causing corruption of string index when deleting an object where there are duplicate values for the indexed field.
+   - fixed bug causing a crash after compacting the Realm file.
+ * Added RealmQuery.isNull() and RealmQuery.isNotNull() for querying relationships.
+ * Fixed a potential NPE in the RealmList constructor.
 
 0.80
 * Queries on relationships can be case sensitive.
diff --git a/distribution/RealmModuleExample/.gitignore b/distribution/RealmModuleExample/.gitignore
new file mode 100644
index 0000000000..afbdab33e9
--- /dev/null
+++ b/distribution/RealmModuleExample/.gitignore
@@ -0,0 +1,6 @@
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
diff --git a/distribution/RealmModuleExample/app/.gitignore b/distribution/RealmModuleExample/app/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/distribution/RealmModuleExample/app/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/distribution/RealmModuleExample/app/proguard-rules.pro b/distribution/RealmModuleExample/app/proguard-rules.pro
new file mode 100644
index 0000000000..bb65c6fe88
--- /dev/null
+++ b/distribution/RealmModuleExample/app/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/distribution/RealmModuleExample/build.gradle b/distribution/RealmModuleExample/build.gradle
new file mode 100644
index 0000000000..dfcb4bf4d1
--- /dev/null
+++ b/distribution/RealmModuleExample/build.gradle
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
+        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
diff --git a/distribution/RealmModuleExample/gradle.properties b/distribution/RealmModuleExample/gradle.properties
new file mode 100644
index 0000000000..5d08ba75bb
--- /dev/null
+++ b/distribution/RealmModuleExample/gradle.properties
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Settings specified in this file will override any Gradle settings
+# configured through the IDE.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
diff --git a/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.jar b/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.properties b/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c44860eea
--- /dev/null
+++ b/distribution/RealmModuleExample/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/distribution/RealmModuleExample/gradlew b/distribution/RealmModuleExample/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/distribution/RealmModuleExample/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/distribution/RealmModuleExample/gradlew.bat b/distribution/RealmModuleExample/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/distribution/RealmModuleExample/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/distribution/RealmModuleExample/library/.gitignore b/distribution/RealmModuleExample/library/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/distribution/RealmModuleExample/library/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/distribution/RealmModuleExample/library/proguard-rules.pro b/distribution/RealmModuleExample/library/proguard-rules.pro
new file mode 100644
index 0000000000..bb65c6fe88
--- /dev/null
+++ b/distribution/RealmModuleExample/library/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/distribution/RealmModuleExample/settings.gradle b/distribution/RealmModuleExample/settings.gradle
new file mode 100644
index 0000000000..33069973b2
--- /dev/null
+++ b/distribution/RealmModuleExample/settings.gradle
@@ -0,0 +1 @@
+include ':app', ':library'
diff --git a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
index 53f3e2496a..f2c8c5decc 100644
--- a/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
+++ b/examples/adapterExample/src/main/java/io/realm/examples/realmadapters/AdapterExampleActivity.java
@@ -26,6 +26,7 @@
 import android.widget.ListView;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.examples.realmadapters.models.TimeStamp;
 
@@ -40,9 +41,10 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_my);
 
-        Realm.deleteRealmFile(this);
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfig);
+        realm = Realm.getInstance(realmConfig);
 
-        realm = Realm.getInstance(this);
         RealmResults<TimeStamp> timeStamps = realm.where(TimeStamp.class).findAll();
         final MyAdapter adapter = new MyAdapter(this, R.id.listView, timeStamps, true);
         ListView listView = (ListView) findViewById(R.id.listView);
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
index eef86d7c32..7b70163cfe 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
@@ -20,9 +20,10 @@
 import android.os.Bundle;
 import android.util.Log;
 
-import java.util.Random;
+import java.security.SecureRandom;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 
 public class EncryptionExampleActivity extends Activity {
 
@@ -34,20 +35,22 @@
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        // Start with a clean slate every time
-        Realm.deleteRealmFile(this);
-
         // Generate a key
         // IMPORTANT! This is a silly way to generate a key. It is also never stored.
         // For proper key handling please consult:
         // * https://developer.android.com/training/articles/keystore.html
         // * http://nelenkov.blogspot.dk/2012/05/storing-application-secrets-in-androids.html
         byte[] key = new byte[64];
-        new Random(365762536).nextBytes(key);
+        new SecureRandom().nextBytes(key);
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this)
+                .encryptionKey(key)
+                .build();
 
-        // Open the Realm with encryption enabled
-        realm = Realm.getInstance(this, key);
+        // Start with a clean slate every time
+        Realm.deleteRealm(realmConfiguration);
 
+        // Open the Realm with encryption enabled
+        realm = Realm.getInstance(realmConfiguration);
 
         // Everything continues to work as normal except for that the file is encrypted on disk
         realm.beginTransaction();
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
index a94beadca5..2c61e50694 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/CityAdapter.java
@@ -33,8 +33,6 @@
 
 public class CityAdapter extends BaseAdapter {
 
-    public static final String TAG = GridViewExampleActivity.class.getName();
-
     private LayoutInflater inflater;
 
     private List<City> cities = null;
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index 3973193f83..e70eabd5c3 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -18,7 +18,6 @@
 
 import android.app.Activity;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.View;
 import android.widget.AdapterView;
 import android.widget.GridView;
@@ -27,7 +26,6 @@
 import com.google.gson.FieldAttributes;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import com.google.gson.reflect.TypeToken;
@@ -36,19 +34,16 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
-import io.realm.internal.Row;
 
 public class GridViewExampleActivity extends Activity implements AdapterView.OnItemClickListener {
 
-    public static final String TAG = GridViewExampleActivity.class.getName();
-
     private GridView mGridView;
     private CityAdapter mAdapter;
 
@@ -59,11 +54,13 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+
         // Clear the realm from last time
-        Realm.deleteRealmFile(this);
+        Realm.deleteRealm(realmConfiguration);
 
         // Create a new empty instance of Realm
-        realm = Realm.getInstance(this);
+        realm = Realm.getInstance(realmConfiguration);
     }
 
     @Override
@@ -96,7 +93,7 @@ protected void onDestroy() {
     private List<City> loadCities() {
         // In this case we're loading from local assets.
         // NOTE: could alternatively easily load from network
-        InputStream stream = null;
+        InputStream stream;
         try {
             stream = getAssets().open("cities.json");
         } catch (IOException e) {
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index 0dacbb9071..b9ad8685cc 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -11,12 +11,14 @@ android {
         versionCode 1
         versionName "1.0"
     }
+
     buildTypes {
         release {
             minifyEnabled false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+//            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
+
     productFlavors {
     }
 
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index f056fed0a9..3fa84764ca 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -47,7 +47,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // These operations are small enough that
         // we can generally safely run them on the UI thread.
 
-        // Open the default realm ones for the UI thread.
+        // Open the default realm for the UI thread.
         realm = Realm.getInstance(this);
 
         basicCRUD(realm);
@@ -58,7 +58,7 @@ protected void onCreate(Bundle savedInstanceState) {
         new AsyncTask<Void, Void, String>() {
             @Override
             protected String doInBackground(Void... voids) {
-                String info = null;
+                String info;
                 info = complexReadWrite();
                 info += complexQuery();
                 return info;
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
index 4bcae72e71..8c0db9d588 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 
 /**
  * This example demonstrates how to import RealmObjects as JSON. Realm supports JSON represented
@@ -36,8 +37,6 @@
  */
 public class JsonExampleActivity extends Activity {
 
-    public static final String TAG = JsonExampleActivity.class.getName();
-
     private GridView mGridView;
     private CityAdapter mAdapter;
     private Realm realm;
@@ -47,8 +46,9 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_realm_example);
 
-        Realm.deleteRealmFile(this);
-        realm = Realm.getInstance(this);
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfiguration);
+        realm = Realm.getInstance(realmConfiguration);
     }
 
     @Override
@@ -94,8 +94,7 @@ protected void onDestroy() {
     private void loadJsonFromStream() throws IOException {
         // Use streams if you are worried about the size of the JSON whether it was persisted on disk
         // or received from the network.
-        InputStream stream = null;
-        stream = getAssets().open("cities.json");
+        InputStream stream = getAssets().open("cities.json");
 
         // Open a transaction to store items into the realm
         realm.beginTransaction();
diff --git a/examples/kotlinExample/.gitignore b/examples/kotlinExample/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/examples/kotlinExample/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
new file mode 100644
index 0000000000..5b8238fcd1
--- /dev/null
+++ b/examples/kotlinExample/build.gradle
@@ -0,0 +1,47 @@
+apply plugin: 'com.android.application'
+apply plugin: 'kotlin-android'
+apply plugin: 'android-command'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+    defaultConfig {
+        applicationId 'io.realm.examples.kotlin'
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
+    compile 'org.jetbrains.anko:anko:0.6.2-19s'
+    compile files("../../realm/build/libs/realm-${version}.jar")
+
+    kapt files("../../realm/build/libs/realm-${version}.jar")
+}
+
+buildscript {
+    ext.kotlin_version = '0.12.213'
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+    }
+}
\ No newline at end of file
diff --git a/test/concurrencyExample/proguard-rules.pro b/examples/kotlinExample/proguard-rules.pro
similarity index 100%
rename from test/concurrencyExample/proguard-rules.pro
rename to examples/kotlinExample/proguard-rules.pro
diff --git a/examples/kotlinExample/src/main/AndroidManifest.xml b/examples/kotlinExample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..877e97864f
--- /dev/null
+++ b/examples/kotlinExample/src/main/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<manifest package="io.realm.examples.kotlin"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme">
+        <activity
+            android:name=".KotlinExampleActivity"
+            android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/KotlinExampleActivity.kt
new file mode 100644
index 0000000000..bbc7121eb9
--- /dev/null
+++ b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin
+
+import android.app.Activity
+import android.os.AsyncTask
+import android.os.Bundle
+import android.util.Log
+import android.widget.LinearLayout
+import android.widget.TextView
+import io.realm.Realm
+import io.realm.examples.kotlin.model.Cat
+import io.realm.examples.kotlin.model.Dog
+import io.realm.examples.kotlin.model.Person
+import org.jetbrains.anko.async
+import org.jetbrains.anko.uiThread
+import kotlin.properties.Delegates
+
+
+public class KotlinExampleActivity : Activity() {
+
+    companion object {
+        public val TAG: String = javaClass<KotlinExampleActivity>().getName()
+    }
+
+    private var rootLayout: LinearLayout by Delegates.notNull()
+    private var realm: Realm by Delegates.notNull()
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.activity_realm_basic_example)
+        rootLayout = findViewById(R.id.container) as LinearLayout
+        rootLayout.removeAllViews()
+
+        // These operations are small enough that
+        // we can generally safely run them on the UI thread.
+
+        // Open the default realm for the UI thread.
+        realm = Realm.getInstance(this)
+
+        basicCRUD(realm)
+        basicQuery(realm)
+        basicLinkQuery(realm)
+
+        // More complex operations can be executed on another thread, for example using
+        // Anko's async extension method.
+        async {
+            var info: String
+            info = complexReadWrite()
+            info += complexQuery()
+
+            uiThread {
+                showStatus(info)
+            }
+        }
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        realm.close() // Remember to close Realm when done.
+    }
+
+    private fun showStatus(txt: String) {
+        Log.i(TAG, txt)
+        val tv = TextView(this)
+        tv.setText(txt)
+        rootLayout.addView(tv)
+    }
+
+    private fun basicCRUD(realm: Realm) {
+        showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...")
+
+        // All writes must be wrapped in a transaction to facilitate safe multi threading
+        realm.beginTransaction()
+
+        // Add a person
+        var person = realm.createObject(javaClass<Person>())
+        person.id = 1
+        person.name = "Young Person"
+        person.age = 14
+
+        // When the write transaction is committed, all changes a synced to disk.
+        realm.commitTransaction()
+
+        // Find the first person (no query conditions) and read a field
+        person = realm.where(javaClass<Person>()).findFirst()
+        showStatus(person.name + ": " + person.age)
+
+        // Update person in a write transaction
+        realm.beginTransaction()
+        person.name = "Senior Person"
+        person.age = 99
+        showStatus(person.name + " got older: " + person.age)
+        realm.commitTransaction()
+
+        // Delete all persons
+        // Using executeTransaction with a lambda reduces code size and makes it impossible
+        // to forget to commit the transaction.
+        realm.executeTransaction {
+            realm.allObjects(javaClass<Person>()).clear()
+        }
+    }
+
+    private fun basicQuery(realm: Realm) {
+        showStatus("\nPerforming basic Query operation...")
+        showStatus("Number of persons: ${realm.allObjects(javaClass<Person>()).size()}")
+
+        val results = realm.where(javaClass<Person>()).equalTo("age", 99).findAll()
+
+        showStatus("Size of result set: " + results.size())
+    }
+
+    private fun basicLinkQuery(realm: Realm) {
+        showStatus("\nPerforming basic Link Query operation...")
+        showStatus("Number of persons: ${realm.allObjects(javaClass<Person>()).size()}")
+
+        val results = realm.where(javaClass<Person>()).equalTo("cats.name", "Tiger").findAll()
+
+        showStatus("Size of result set: ${results.size()}")
+    }
+
+    private fun complexReadWrite(): String {
+        var status = "\nPerforming complex Read/Write operation..."
+
+        // Open the default realm. All threads must use it's own reference to the realm.
+        // Those can not be transferred across threads.
+        val realm = Realm.getInstance(this)
+
+        // Add ten persons in one write transaction
+        realm.beginTransaction()
+        val fido = realm.createObject(javaClass<Dog>())
+        fido.name = "fido"
+        for (i in 0..9) {
+            val person = realm.createObject(javaClass<Person>())
+            person.id = i.toLong()
+            person.name = "Person no. $i"
+            person.age = i
+            person.dog = fido
+
+            // The field tempReference is annotated with @Ignore.
+            // This means setTempReference sets the Person tempReference
+            // field directly. The tempReference is NOT saved as part of
+            // the RealmObject:
+            person.tempReference = 42
+
+            for (j in 0..i - 1) {
+                val cat = realm.createObject(javaClass<Cat>())
+                cat.name = "Cat_$j"
+                person.cats.add(cat)
+            }
+        }
+        realm.commitTransaction()
+
+        // Implicit read transactions allow you to access your objects
+        status += "\nNumber of persons: ${realm.allObjects(javaClass<Person>()).size()}"
+
+        // Iterate over all objects
+        for (pers in realm.allObjects(javaClass<Person>())) {
+            val dogName: String = pers?.dog?.name ?: "None"
+
+            status += "\n${pers.name}: ${pers.age} : $dogName : ${pers.cats.size()}"
+
+            // The field tempReference is annotated with @Ignore
+            // Though we initially set its value to 42, it has
+            // not been saved as part of the Person RealmObject:
+            check(pers.tempReference == 0)
+        }
+
+        // Sorting
+        val sortedPersons = realm.allObjects(javaClass<Person>())
+        sortedPersons.sort("age", false)
+        check(realm.allObjects(javaClass<Person>()).last().name == sortedPersons.first().name)
+        status += "\nSorting ${sortedPersons.last().name} == ${realm.allObjects(javaClass<Person>()).first().name}"
+
+        realm.close()
+        return status
+    }
+
+    private fun complexQuery(): String {
+        var status = "\n\nPerforming complex Query operation..."
+
+        // Realm implements the Closable interface, therefore we can make use of Kotlin's built-in
+        // extension method 'use' (pun intended).
+        Realm.getInstance(this).use {
+            // 'it' is the implicit lambda parameter of type Realm
+            status += "\nNumber of persons: ${it.allObjects(javaClass<Person>()).size()}"
+
+            // Find all persons where age between 7 and 9 and name begins with "Person".
+            val results = it
+                    .where(javaClass<Person>())
+                    .between("age", 7, 9)       // Notice implicit "and" operation
+                    .beginsWith("name", "Person")
+                    .findAll()
+
+            status += "\nSize of result set: ${results.size()}"
+
+        }
+
+        return status
+    }
+
+
+}
diff --git a/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Cat.kt b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Cat.kt
new file mode 100644
index 0000000000..08c83ab7ca
--- /dev/null
+++ b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Cat.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmObject
+import io.realm.annotations.RealmClass
+
+@RealmClass
+public open class Cat : RealmObject() {
+    public open var name: String = ""
+}
diff --git a/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Dog.kt b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Dog.kt
new file mode 100644
index 0000000000..bd7e298b00
--- /dev/null
+++ b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Dog.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmObject
+import io.realm.annotations.RealmClass
+
+@RealmClass
+public open class Dog : RealmObject() {
+    public open var name: String = ""
+}
diff --git a/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Person.kt
new file mode 100644
index 0000000000..dcff04bbd2
--- /dev/null
+++ b/examples/kotlinExample/src/main/java/io/realm/examples/kotlin/model/Person.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.kotlin.model
+
+import io.realm.RealmList
+import io.realm.RealmObject
+import io.realm.annotations.Ignore
+import io.realm.annotations.PrimaryKey
+import io.realm.annotations.RealmClass
+
+// Your model has to extend RealmObject and must have the @RealmClass annotation set.
+// (Inherited annotations don't work for Kotlin 0.12.213, check
+// https://youtrack.jetbrains.com/issue/KT-7890 for progress on this issue. When this is resolved,
+// the @RealmClass annotation can be omitted)
+// Furthermore, the class and all of the properties must be annotated with open
+// (Kotlin classes and methods are final by default).
+@RealmClass
+public open class Person(
+        // You can put properties in the constructor as long as all of them are initialized with
+        // default values. This ensures that an empty constructor is generated.
+        // All properties are by default persisted.
+        // Properties can be annotated with PrimaryKey or Index.
+        // If you use non-nullable types, properties must be initialized with non-null values.
+
+        @PrimaryKey public open var name: String = "",
+
+        public open var age: Int = 0,
+
+        // Other objects in a one-to-one relation must also subclass RealmObject
+        public open var dog: Dog? = null,
+
+        // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
+        public open var cats: RealmList<Cat> = RealmList(),
+
+        // You can instruct Realm to ignore a field and not persist it.
+        @Ignore public open var tempReference: Int = 0,
+
+        public open var id: Long = 0
+) : RealmObject() {
+    // The Kotlin compiler generates standard getters and setters.
+    // Realm will overload them and code inside them is ignored.
+    // So if you prefer you can also just have empty abstract methods.
+}
diff --git a/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
new file mode 100644
index 0000000000..f7891e6991
--- /dev/null
+++ b/examples/kotlinExample/src/main/res/layout/activity_realm_basic_example.xml
@@ -0,0 +1,29 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:gravity="center_horizontal"
+            android:text="Status Output..."
+            android:textStyle="bold"
+            android:textSize="18sp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+        <LinearLayout
+            android:id="@+id/container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:paddingTop="10sp"
+            android:orientation="vertical"
+            tools:context=".RealmIntroExample"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/test/concurrencyExample/src/main/res/values-w820dp/dimens.xml b/examples/kotlinExample/src/main/res/values-w820dp/dimens.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values-w820dp/dimens.xml
rename to examples/kotlinExample/src/main/res/values-w820dp/dimens.xml
diff --git a/test/concurrencyExample/src/main/res/values/dimens.xml b/examples/kotlinExample/src/main/res/values/dimens.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values/dimens.xml
rename to examples/kotlinExample/src/main/res/values/dimens.xml
diff --git a/examples/kotlinExample/src/main/res/values/strings.xml b/examples/kotlinExample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..963831fd43
--- /dev/null
+++ b/examples/kotlinExample/src/main/res/values/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">Kotlin example</string>
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+
+</resources>
diff --git a/test/concurrencyExample/src/main/res/values/styles.xml b/examples/kotlinExample/src/main/res/values/styles.xml
similarity index 100%
rename from test/concurrencyExample/src/main/res/values/styles.xml
rename to examples/kotlinExample/src/main/res/values/styles.xml
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index e772d42ccd..a1f69e49e6 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -28,6 +28,7 @@
 import java.io.InputStream;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.examples.realmmigrationexample.model.Migration;
 import io.realm.examples.realmmigrationexample.model.Person;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -41,6 +42,7 @@
     public static final String TAG = MigrationExampleActivity.class.getName();
 
     private LinearLayout rootLayout = null;
+    private Realm realm;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -51,35 +53,47 @@ protected void onCreate(Bundle savedInstanceState) {
         rootLayout.removeAllViews();
 
         // 3 versions of the databases for testing. Normally you would only have one.
-        String path3 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0");
-        String path1 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1");
-        String path2 = copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2");
-
-        // If you try to open a file that doesn't match your model an exception is thrown:
-        try {
-            // should throw as migration is required
-            Realm.getInstance(this, "default1");
-        } catch (RealmMigrationNeededException ex) {
-            Log.i(TAG, "Excellent! This is expected.");
-        }
-
-        Realm realm;
-
-        // So you migrate your data
-        Realm.migrateRealmAtPath(path1, new Migration());
-        realm = Realm.getInstance(this, "default1");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default0), "default0");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default1), "default1");
+        copyBundledRealmFile(this.getResources().openRawResource(R.raw.default2), "default2");
+
+        // When you create a RealmConfiguration you can specify the version of the schema.
+        // If the schema does not have that version a RealmMigrationNeededException will be thrown.
+        RealmConfiguration config0 = new RealmConfiguration.Builder(this)
+                .name("default0")
+                .schemaVersion(3)
+                .build();
+
+        // You can then manually call Realm.migrateRealm().
+        Realm.migrateRealm(config0, new Migration());
+        realm = Realm.getInstance(config0);
+        showStatus("Default0");
         showStatus(realm);
         realm.close();
 
-        // Another migration test
-        Realm.migrateRealmAtPath(path2, new Migration());
-        realm = Realm.getInstance(this, "default2");
+        // Or you can add the migration code to the configuration. This will run the migration code without throwing
+        // a RealmMigrationNeededException.
+        RealmConfiguration config1 = new RealmConfiguration.Builder(this)
+                .name("default1")
+                .schemaVersion(3)
+                .migration(new Migration())
+                .build();
+
+        realm = Realm.getInstance(config1); // Automatically run migration if needed
+        showStatus("Default1");
         showStatus(realm);
         realm.close();
 
-        // and a third:
-        Realm.migrateRealmAtPath(path3, new Migration());
-        realm = Realm.getInstance(this, "default3");
+        // or you can set .deleteRealmIfMigrationNeeded() if you don't want to bother with migrations.
+        // WARNING: This will delete all data in the Realm though.
+        RealmConfiguration config2 = new RealmConfiguration.Builder(this)
+                .name("default2")
+                .schemaVersion(3)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+
+        realm = Realm.getInstance(config2);
+        showStatus("default2");
         showStatus(realm);
         realm.close();
     }
@@ -106,11 +120,15 @@ private String realmString(Realm realm) {
         for (Person person : realm.allObjects(Person.class)) {
             stringBuilder.append(person.toString()).append("\n");
         }
-        return stringBuilder.toString();
+
+        return (stringBuilder.length() == 0) ? "<empty>" : stringBuilder.toString();
     }
 
     private void showStatus(Realm realm) {
-        String txt = realmString(realm);
+        showStatus(realmString(realm));
+    }
+
+    private void showStatus(String txt) {
         Log.i(TAG, txt);
         TextView tv = new TextView(this);
         tv.setText(txt);
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
index bf9fdbd173..de64ca9cdc 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/model/Migration.java
@@ -85,7 +85,7 @@ public long execute(Realm realm, long version) {
 
             for (int i = 0; i < personTable.size(); i++) {
                 if (personTable.getString(fullNameIndex, i).equals("JP McDonald")) {
-                    personTable.getRow(i).getLinkList(petsIndex).add(petTable.add("Jimbo", "dog"));
+                    personTable.getUncheckedRow(i).getLinkList(petsIndex).add(petTable.add("Jimbo", "dog"));
                 }
             }
             version++;
diff --git a/examples/realmModuleExample/app/.gitignore b/examples/realmModuleExample/app/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/examples/realmModuleExample/app/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/examples/realmModuleExample/app/build.gradle b/examples/realmModuleExample/app/build.gradle
new file mode 100644
index 0000000000..ce7c1ec4d1
--- /dev/null
+++ b/examples/realmModuleExample/app/build.gradle
@@ -0,0 +1,46 @@
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+    defaultConfig {
+        applicationId 'io.realm.examples.appmodules'
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+
+    signingConfigs {
+        release {
+            storeFile file("keystore/release.keystore")
+            storePassword "realm1234"
+            keyAlias "realm-introexample"
+            keyPassword "realm1234"
+        }
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled true
+            signingConfig signingConfigs.release
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    productFlavors {
+    }
+
+    command {
+        events 2000
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile project(':realmModuleLibraryExample')
+}
\ No newline at end of file
diff --git a/examples/realmModuleExample/app/keystore/release.keystore b/examples/realmModuleExample/app/keystore/release.keystore
new file mode 100644
index 0000000000..939cfa830a
Binary files /dev/null and b/examples/realmModuleExample/app/keystore/release.keystore differ
diff --git a/examples/realmModuleExample/app/proguard-rules.pro b/examples/realmModuleExample/app/proguard-rules.pro
new file mode 100644
index 0000000000..fe49641ad9
--- /dev/null
+++ b/examples/realmModuleExample/app/proguard-rules.pro
@@ -0,0 +1,22 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/Cellar/android-sdk/22.6.2/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Realm ProGuard setup
+-keep @io.realm.annotations.RealmModule class *
+-dontwarn javax.**
+-dontwarn io.realm.**
diff --git a/examples/realmModuleExample/app/src/main/AndroidManifest.xml b/examples/realmModuleExample/app/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9d2160c44e
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.appmodules" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".ModulesExampleActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest>
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
new file mode 100644
index 0000000000..b472e6d0cf
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.examples.appmodules.model.Cow;
+import io.realm.examples.appmodules.model.Pig;
+import io.realm.examples.appmodules.model.Snake;
+import io.realm.examples.appmodules.model.Spider;
+import io.realm.examples.appmodules.modules.CreepyAnimalsModule;
+import io.realm.examples.librarymodules.Zoo;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.model.Dog;
+import io.realm.examples.librarymodules.model.Elephant;
+import io.realm.examples.librarymodules.model.Lion;
+import io.realm.examples.librarymodules.model.Zebra;
+import io.realm.examples.librarymodules.modules.DomesticAnimalsModule;
+import io.realm.examples.librarymodules.modules.ZooAnimalsModule;
+import io.realm.exceptions.RealmException;
+
+/**
+* This example demonstrates how you can use modules to control which classes belong to which Realms and how you can
+ * work with multiple Realms at the same time.
+*/
+public class ModulesExampleActivity extends Activity {
+
+    public static final String TAG = ModulesExampleActivity.class.getName();
+    private LinearLayout rootLayout = null;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_modules_example);
+        rootLayout = ((LinearLayout) findViewById(R.id.container));
+        rootLayout.removeAllViews();
+
+        // The default Realm instance implicitly knows about all classes in the realmModuleAppExample Android Studio
+        // module. This does not include the classes from the realmModuleLibraryExample AS module so a Realm using this
+        // configuration would know about the following classes: { Cow, Pig, Snake, Spider }
+        RealmConfiguration defaultConfig = new RealmConfiguration.Builder(this).build();
+
+        // It is possible to extend the default schema by adding additional Realm modules using setModule(). This can
+        // also be Realm modules from libraries. The below Realm contains the following classes: { Cow, Pig, Snake,
+        // Spider, Cat, Dog }
+        RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
+                .name("farm.realm")
+                .setModules(Realm.getDefaultModule(), new DomesticAnimalsModule())
+                .build();
+
+        // Or you can completely replace the default schema.
+        // This Realm contains the following classes: { Elephant, Lion, Zebra, Snake, Spider }
+        RealmConfiguration exoticAnimalsConfig = new RealmConfiguration.Builder(this)
+                .name("exotic.realm")
+                .setModules(new ZooAnimalsModule(), new CreepyAnimalsModule())
+                .build();
+
+        // Multiple Realms can be open at the same time
+        showStatus("Opening multiple Realms");
+        Realm defaultRealm = Realm.getInstance(defaultConfig);
+        Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
+        Realm exoticRealm = Realm.getInstance(exoticAnimalsConfig);
+
+        // Objects can be added to each Realm independantly
+        showStatus("Create objects in the default Realm");
+        defaultRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Cow.class);
+                realm.createObject(Pig.class);
+                realm.createObject(Snake.class);
+                realm.createObject(Spider.class);
+            }
+        });
+
+        showStatus("Create objects in the farm Realm");
+        farmRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Cow.class);
+                realm.createObject(Pig.class);
+                realm.createObject(Cat.class);
+                realm.createObject(Dog.class);
+            }
+        });
+
+        showStatus("Create objects in the exotic Realm");
+        exoticRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Elephant.class);
+                realm.createObject(Lion.class);
+                realm.createObject(Zebra.class);
+                realm.createObject(Snake.class);
+                realm.createObject(Spider.class);
+            }
+        });
+
+        // You can copy objects between Realms
+        showStatus("Copy objects between Realms");
+        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+        showStatus("Copy pig from defaultRealm to farmRealm");
+        Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
+        farmRealm.beginTransaction();
+        farmRealm.copyToRealm(defaultPig);
+        farmRealm.commitTransaction();
+        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+
+        // Each Realm is restricted to only accept the classes in their schema.
+        showStatus("Trying to add an unsupported class");
+        defaultRealm.beginTransaction();
+        try {
+            defaultRealm.createObject(Elephant.class);
+        } catch (RealmException expected) {
+            showStatus("This throws a :" + expected.toString());
+        } finally {
+            defaultRealm.cancelTransaction();
+        }
+
+        // And Realms in library projects are independent from Realms in the app code
+        showStatus("Interacting with library code that uses Realm internally");
+        int animals = 5;
+        Zoo libraryZoo = new Zoo(this);
+        libraryZoo.open();
+        showStatus("Adding animals: " + animals);
+        libraryZoo.addAnimals(5);
+        showStatus("Number of animals in the library Realm:" + libraryZoo.getNoOfAnimals());
+        libraryZoo.close();
+
+        // Remember to close all open Realms
+        defaultRealm.close();
+        farmRealm.close();
+        exoticRealm.close();
+    }
+
+    private void showStatus(String txt) {
+        Log.i(TAG, txt);
+        TextView tv = new TextView(this);
+        tv.setText(txt);
+        rootLayout.addView(tv);
+    }
+}
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java
new file mode 100644
index 0000000000..b3cbcc6cd4
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Cow.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Cow extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
new file mode 100644
index 0000000000..ef9e5ba860
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Pig.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Pig extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java
new file mode 100644
index 0000000000..21e885e26e
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Snake.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Snake extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java
new file mode 100644
index 0000000000..77255ba087
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/model/Spider.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.model;
+
+import io.realm.RealmObject;
+
+public class Spider extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
diff --git a/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java
new file mode 100644
index 0000000000..b3ebeb39a5
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/java/io/realm/examples/appmodules/modules/CreepyAnimalsModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.appmodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.appmodules.model.Snake;
+import io.realm.examples.appmodules.model.Spider;
+
+@RealmModule(classes = {Snake.class, Spider.class})
+public class CreepyAnimalsModule {
+}
diff --git a/examples/realmModuleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/realmModuleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/realmModuleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/realmModuleExample/app/src/main/res/layout/activity_modules_example.xml b/examples/realmModuleExample/app/src/main/res/layout/activity_modules_example.xml
new file mode 100644
index 0000000000..f7891e6991
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/res/layout/activity_modules_example.xml
@@ -0,0 +1,29 @@
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:paddingLeft="@dimen/activity_horizontal_margin"
+    android:paddingRight="@dimen/activity_horizontal_margin"
+    android:paddingTop="@dimen/activity_vertical_margin"
+    android:paddingBottom="@dimen/activity_vertical_margin"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:orientation="vertical"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        <TextView
+            android:gravity="center_horizontal"
+            android:text="Status Output..."
+            android:textStyle="bold"
+            android:textSize="18sp"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"/>
+        <LinearLayout
+            android:id="@+id/container"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:paddingTop="10sp"
+            android:orientation="vertical"
+            tools:context=".RealmIntroExample"/>
+    </LinearLayout>
+</ScrollView>
diff --git a/examples/realmModuleExample/app/src/main/res/values-w820dp/dimens.xml b/examples/realmModuleExample/app/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/examples/realmModuleExample/app/src/main/res/values/dimens.xml b/examples/realmModuleExample/app/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/examples/realmModuleExample/app/src/main/res/values/strings.xml b/examples/realmModuleExample/app/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..d6848f4045
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">RealmModule example</string>
+
+</resources>
diff --git a/examples/realmModuleExample/app/src/main/res/values/styles.xml b/examples/realmModuleExample/app/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..ff6c9d2c0f
--- /dev/null
+++ b/examples/realmModuleExample/app/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/examples/realmModuleExample/library/.gitignore b/examples/realmModuleExample/library/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/examples/realmModuleExample/library/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/examples/realmModuleExample/library/build.gradle b/examples/realmModuleExample/library/build.gradle
new file mode 100644
index 0000000000..df299508dc
--- /dev/null
+++ b/examples/realmModuleExample/library/build.gradle
@@ -0,0 +1,29 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+    defaultConfig {
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    productFlavors {
+    }
+}
+
+tasks.preBuild {
+    dependsOn ":realm:androidJar"
+}
+
+dependencies {
+    compile files("../../../realm/build/libs/realm-${version}.jar")
+}
diff --git a/examples/realmModuleExample/library/src/main/AndroidManifest.xml b/examples/realmModuleExample/library/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..2e3d315067
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/AndroidManifest.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.examples.librarymodules" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@drawable/ic_launcher"
+        android:label="@string/app_name" >
+    </application>
+
+</manifest>
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
new file mode 100644
index 0000000000..bddcffaaa3
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules;
+
+import android.content.Context;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.modules.AllAnimalsModule;
+
+/**
+ * Library projects can also use Realms, but some configuration options are mandatory to avoid clashing with Realms used
+ * in the app code.
+ */
+public class Zoo {
+
+    private final RealmConfiguration realmConfig;
+    private Realm realm;
+
+    public Zoo(Context context) {
+        realmConfig = new RealmConfiguration.Builder(context) // Beware this is the app context
+                .name("library.zoo.realm")                    // So always use a unique name
+                .setModules(new AllAnimalsModule())           // Always use explicit modules in library projects
+                .build();
+
+        // Reset Realm
+        Realm.deleteRealm(realmConfig);
+    }
+
+    public void open() {
+        // Don't use Realm.setDefaultInstance() in library projects. It is unsafe as app developers can override the
+        // default configuration. So always use explicit configurations in library projects.
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    public long getNoOfAnimals() {
+        return realm.where(Cat.class).count();
+    }
+
+    public void addAnimals(int count) {
+        realm.beginTransaction();
+        for (int i = 0; i < count; i++) {
+            Cat cat = realm.createObject(Cat.class);
+            cat.setName("Cat " + i);
+        }
+        realm.commitTransaction();
+    }
+
+    public void close() {
+        realm.close();
+    }
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
similarity index 79%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
rename to examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
index d497d08f68..fd3a999540 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Cat.java
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Cat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service.model;
+package io.realm.examples.librarymodules.model;
 
 import io.realm.RealmObject;
 
 public class Cat extends RealmObject {
+
     private String name;
 
     public String getName() {
@@ -28,11 +29,4 @@ public String getName() {
     public void setName(String name) {
         this.name = name;
     }
-
-    @Override
-    public String toString() {
-        return "Cat{" +
-                "name='" + name + '\'' +
-                '}';
-    }
 }
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
similarity index 79%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
rename to examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
index 209e0ee885..92587f3c84 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Dog.java
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Dog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service.model;
+package io.realm.examples.librarymodules.model;
 
 import io.realm.RealmObject;
 
 public class Dog extends RealmObject {
+
     private String name;
 
     public String getName() {
@@ -28,11 +29,4 @@ public String getName() {
     public void setName(String name) {
         this.name = name;
     }
-
-    @Override
-    public String toString() {
-        return "Dog{" +
-                "name='" + name + '\'' +
-                '}';
-    }
 }
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java
new file mode 100644
index 0000000000..4635b94417
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Elephant.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Elephant extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java
new file mode 100644
index 0000000000..89f75ba5f8
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Lion.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Lion extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java
new file mode 100644
index 0000000000..3bb7da92cd
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/model/Zebra.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.model;
+
+import io.realm.RealmObject;
+
+public class Zebra extends RealmObject {
+
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java
similarity index 73%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java
rename to examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java
index c8e90b18a3..a1b1dd1f0f 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/KillableThread.java
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/AllAnimalsModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package io.realm.examples.service;
+package io.realm.examples.librarymodules.modules;
 
-public interface KillableThread {
-
-    public void terminate();
+import io.realm.annotations.RealmModule;
 
+@RealmModule(library = true, allClasses = true)
+public class AllAnimalsModule {
 }
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java
new file mode 100644
index 0000000000..bd50adbe90
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/DomesticAnimalsModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.librarymodules.model.Cat;
+import io.realm.examples.librarymodules.model.Dog;
+
+@RealmModule(library = true, classes = {Cat.class, Dog.class})
+public class DomesticAnimalsModule {
+}
diff --git a/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java
new file mode 100644
index 0000000000..e572e86a9e
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/java/io/realm/examples/librarymodules/modules/ZooAnimalsModule.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.librarymodules.modules;
+
+import io.realm.annotations.RealmModule;
+import io.realm.examples.librarymodules.model.Elephant;
+import io.realm.examples.librarymodules.model.Lion;
+import io.realm.examples.librarymodules.model.Zebra;
+
+@RealmModule(library = true, classes = {Elephant.class, Lion.class, Zebra.class})
+public class ZooAnimalsModule {
+}
diff --git a/examples/realmModuleExample/library/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/realmModuleExample/library/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..433021180b
Binary files /dev/null and b/examples/realmModuleExample/library/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/examples/realmModuleExample/library/src/main/res/values/strings.xml b/examples/realmModuleExample/library/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..051a90f592
--- /dev/null
+++ b/examples/realmModuleExample/library/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+
+    <string name="app_name">RealmModule Library Example</string>
+
+</resources>
diff --git a/examples/threadExample/src/main/AndroidManifest.xml b/examples/threadExample/src/main/AndroidManifest.xml
index 44b5bfca94..2ec0c776ea 100644
--- a/examples/threadExample/src/main/AndroidManifest.xml
+++ b/examples/threadExample/src/main/AndroidManifest.xml
@@ -6,6 +6,7 @@
         android:allowBackup="true"
         android:icon="@drawable/ic_launcher"
         android:label="@string/app_name"
+        android:name=".MyApplication"
         android:theme="@style/AppTheme" >
         <activity
             android:name=".ThreadExampleActivity"
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index 43d469227d..73a177e8a3 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -84,7 +84,7 @@ private void showStatus(String txt) {
 
         @Override
         protected Integer doInBackground(Void... params) {
-            Realm realm = Realm.getInstance(getActivity());
+            Realm realm = Realm.getDefaultInstance();
 
             realm.beginTransaction();
             realm.clear(Score.class);
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
new file mode 100644
index 0000000000..7ced58b6c8
--- /dev/null
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/MyApplication.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.examples.threads;
+
+import android.app.Application;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+public class MyApplication extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        // Configure Realm for the application
+        RealmConfiguration realmConfiguration = new RealmConfiguration.Builder(this).build();
+        Realm.deleteRealm(realmConfiguration); // Clean slate
+        Realm.setDefaultConfiguration(realmConfiguration); // Make this Realm the default
+    }
+}
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index 109213b972..ab20e28764 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -63,7 +63,7 @@ public void onAttach(Activity activity) {
         super.onAttach(activity);
 
         // Create Realm instance for the UI thread
-        realm = Realm.getInstance(getActivity());
+        realm = Realm.getDefaultInstance();
     }
 
     @Override
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/gradle-plugin/buildSrc/build.gradle b/gradle-plugin/buildSrc/build.gradle
new file mode 100644
index 0000000000..362a110e65
--- /dev/null
+++ b/gradle-plugin/buildSrc/build.gradle
@@ -0,0 +1,7 @@
+repositories {
+    mavenCentral()
+}
+
+rootProject.dependencies {
+    compile project(':plugin')
+}
diff --git a/gradle-plugin/buildSrc/settings.gradle b/gradle-plugin/buildSrc/settings.gradle
new file mode 100644
index 0000000000..adade62679
--- /dev/null
+++ b/gradle-plugin/buildSrc/settings.gradle
@@ -0,0 +1,2 @@
+include ':plugin'
+project(':plugin').projectDir = new File('../plugin')
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..b761216703
Binary files /dev/null and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..81dec0a9e0
--- /dev/null
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Mon May 04 12:41:37 CEST 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/gradle-plugin/gradlew b/gradle-plugin/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/gradle-plugin/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradle-plugin/gradlew.bat b/gradle-plugin/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/gradle-plugin/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/gradle-plugin/plugin/build.gradle b/gradle-plugin/plugin/build.gradle
new file mode 100644
index 0000000000..129a80f1d3
--- /dev/null
+++ b/gradle-plugin/plugin/build.gradle
@@ -0,0 +1,6 @@
+apply plugin: 'groovy'
+
+dependencies {
+    compile gradleApi()
+    compile localGroovy()
+}
diff --git a/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
new file mode 100644
index 0000000000..ae0629396e
--- /dev/null
+++ b/gradle-plugin/plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -0,0 +1,13 @@
+package io.realm.gradle
+
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+
+class Realm implements Plugin<Project> {
+
+    @Override
+    void apply(Project project) {
+    	project.repositories.add(project.repositories.jcenter())
+        project.dependencies.add('compile', 'io.realm:realm-android:0.80.3') // TODO: make version dynamic
+    }
+}
diff --git a/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties b/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties
new file mode 100644
index 0000000000..ff071ff56f
--- /dev/null
+++ b/gradle-plugin/plugin/src/main/resources/META-INF/gradle-plugins/realm.properties
@@ -0,0 +1 @@
+implementation-class=io.realm.gradle.Realm
diff --git a/gradle-plugin/sample/.gitignore b/gradle-plugin/sample/.gitignore
new file mode 100644
index 0000000000..9c4de5825b
--- /dev/null
+++ b/gradle-plugin/sample/.gitignore
@@ -0,0 +1,7 @@
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
+/captures
diff --git a/gradle-plugin/sample/build.gradle b/gradle-plugin/sample/build.gradle
new file mode 100644
index 0000000000..051982e69f
--- /dev/null
+++ b/gradle-plugin/sample/build.gradle
@@ -0,0 +1,37 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.1.0'
+        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.+'
+    }
+}
+
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'realm'
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "io.realm.example.sample"
+        minSdkVersion 15
+        targetSdkVersion 22
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    compile 'com.android.support:appcompat-v7:22.0.0'
+}
diff --git a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c71e760dc
--- /dev/null
+++ b/gradle-plugin/sample/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java b/gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java
new file mode 100644
index 0000000000..4c3e5e42d7
--- /dev/null
+++ b/gradle-plugin/sample/src/androidTest/java/io/realm/example/sample/ApplicationTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.example.sample;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
diff --git a/gradle-plugin/sample/src/main/AndroidManifest.xml b/gradle-plugin/sample/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..7ace7f5483
--- /dev/null
+++ b/gradle-plugin/sample/src/main/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="io.realm.example.sample" >
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:theme="@style/AppTheme" >
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java b/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java
new file mode 100644
index 0000000000..cc30e9f85b
--- /dev/null
+++ b/gradle-plugin/sample/src/main/java/io/realm/example/sample/MainActivity.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.example.sample;
+
+import android.os.Bundle;
+import android.support.v7.app.ActionBarActivity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.Toast;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.example.sample.models.Person;
+
+
+public class MainActivity extends ActionBarActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+
+        Realm realm = Realm.getInstance(this);
+        RealmResults<Person> persons = realm.allObjects(Person.class);
+        if (persons.isEmpty()) {
+            Toast toast = Toast.makeText(this, "No persons in the Realm file", Toast.LENGTH_SHORT);
+            toast.show();
+        }
+        realm.close();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        // Inflate the menu; this adds items to the action bar if it is present.
+        getMenuInflater().inflate(R.menu.menu_main, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle action bar item clicks here. The action bar will
+        // automatically handle clicks on the Home/Up button, so long
+        // as you specify a parent activity in AndroidManifest.xml.
+        int id = item.getItemId();
+
+        //noinspection SimplifiableIfStatement
+        if (id == R.id.action_settings) {
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java b/gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java
similarity index 56%
rename from test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
rename to gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java
index 4fae6d0053..f3f7b9505f 100644
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/model/Person.java
+++ b/gradle-plugin/sample/src/main/java/io/realm/example/sample/models/Person.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package io.realm.example.sample.models;
 
-package io.realm.examples.service.model;
-
-import io.realm.RealmList;
 import io.realm.RealmObject;
 
 public class Person extends RealmObject {
-
     private String name;
     private int age;
-//    private Dog dog;
-//    private RealmList<Cat> cats;
 
     public String getName() {
         return name;
@@ -41,30 +36,4 @@ public int getAge() {
     public void setAge(int age) {
         this.age = age;
     }
-
-//    public Dog getDog() {
-//        return dog;
-//    }
-//
-//    public void setDog(Dog dog) {
-//        this.dog = dog;
-//    }
-//
-//    public RealmList<Cat> getCats() {
-//        return cats;
-//    }
-//
-//    public void setCats(RealmList<Cat> cats) {
-//        this.cats = cats;
-//    }
-
-//    @Override
-//    public String toString() {
-//        return "Person{" +
-//                "name='" + name + '\'' +
-//                ", age=" + age +
-//                ", dog=" + dog +
-//                ", cats=" + cats +
-//                '}';
-//    }
-}
\ No newline at end of file
+}
diff --git a/gradle-plugin/sample/src/main/res/layout/activity_main.xml b/gradle-plugin/sample/src/main/res/layout/activity_main.xml
new file mode 100644
index 0000000000..53ce5577b5
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/layout/activity_main.xml
@@ -0,0 +1,16 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+                xmlns:tools="http://schemas.android.com/tools"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:paddingLeft="@dimen/activity_horizontal_margin"
+                android:paddingRight="@dimen/activity_horizontal_margin"
+                android:paddingTop="@dimen/activity_vertical_margin"
+                android:paddingBottom="@dimen/activity_vertical_margin"
+                tools:context=".MainActivity">
+
+    <TextView
+        android:text="@string/hello_world"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
+
+</RelativeLayout>
diff --git a/gradle-plugin/sample/src/main/res/menu/menu_main.xml b/gradle-plugin/sample/src/main/res/menu/menu_main.xml
new file mode 100644
index 0000000000..a459e0a540
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/menu/menu_main.xml
@@ -0,0 +1,9 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto"
+      xmlns:tools="http://schemas.android.com/tools"
+      tools:context=".MainActivity">
+    <item android:id="@+id/action_settings"
+          android:title="@string/action_settings"
+          android:orderInCategory="100"
+          app:showAsAction="never"/>
+</menu>
diff --git a/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..284223f4b4
Binary files /dev/null and b/gradle-plugin/sample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..701b3e88df
Binary files /dev/null and b/gradle-plugin/sample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..cf218ff34c
Binary files /dev/null and b/gradle-plugin/sample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..1713efc4e5
Binary files /dev/null and b/gradle-plugin/sample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..c66b37ef61
Binary files /dev/null and b/gradle-plugin/sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/gradle-plugin/sample/src/main/res/values-w820dp/dimens.xml b/gradle-plugin/sample/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000000..63fc816444
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/gradle-plugin/sample/src/main/res/values/dimens.xml b/gradle-plugin/sample/src/main/res/values/dimens.xml
new file mode 100644
index 0000000000..47c8224673
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/values/dimens.xml
@@ -0,0 +1,5 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/gradle-plugin/sample/src/main/res/values/strings.xml b/gradle-plugin/sample/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..e0d4f68746
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/values/strings.xml
@@ -0,0 +1,6 @@
+<resources>
+    <string name="app_name">sample</string>
+
+    <string name="hello_world">Hello world!</string>
+    <string name="action_settings">Settings</string>
+</resources>
diff --git a/gradle-plugin/sample/src/main/res/values/styles.xml b/gradle-plugin/sample/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..766ab99304
--- /dev/null
+++ b/gradle-plugin/sample/src/main/res/values/styles.xml
@@ -0,0 +1,8 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+    </style>
+
+</resources>
diff --git a/gradle-plugin/settings.gradle b/gradle-plugin/settings.gradle
new file mode 100644
index 0000000000..0e9d5443e0
--- /dev/null
+++ b/gradle-plugin/settings.gradle
@@ -0,0 +1,4 @@
+rootProject.name = 'gradle-plugin'
+include 'plugin'
+include 'sample'
+
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 642465bfea..1312095105 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -19,4 +19,5 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
+org.gradle.daemon=true
diff --git a/realm-annotations-processor/build.gradle b/realm-annotations-processor/build.gradle
index 1fa45c1104..710ac6ef5a 100644
--- a/realm-annotations-processor/build.gradle
+++ b/realm-annotations-processor/build.gradle
@@ -10,7 +10,7 @@ buildscript {
 apply plugin: 'java'
 apply plugin: 'com.github.johnrengelman.shadow'
 
-version = new File("${projectDir}/../version.txt").text
+version = new File("${projectDir}/../version.txt").text.trim();
 sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
diff --git a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties b/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties
index fb7aebcbf7..35b8fa2d3c 100644
--- a/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations-processor/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 545013b592..896e1423ee 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -33,6 +33,7 @@
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -63,12 +64,14 @@
 
     private final List<TypeMirror> validPrimaryKeyTypes;
     private final Types typeUtils;
+    private DeclaredType realmList;
 
     public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
         TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
+        realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
         validPrimaryKeyTypes = Arrays.asList(
                 stringType,
                 typeUtils.getPrimitiveType(TypeKind.SHORT),
@@ -83,7 +86,7 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
      *
      * @return True if meta data was correctly created and processing can continue, false otherwise.
      */
-    public boolean generateMetaData(Messager messager) {
+    public boolean generate() {
 
         // Get the package of the class
         Element enclosingElement = classType.getEnclosingElement();
@@ -102,6 +105,7 @@ public boolean generateMetaData(Messager messager) {
         packageName = packageElement.getQualifiedName().toString();
 
         if (!categorizeClassElements()) return false;
+        if (!checkListTypes()) return  false;
         if (!checkMethods()) return false;
         if (!checkDefaultConstructor()) return false;
         if (!checkRequiredGetters()) return false;
@@ -144,6 +148,18 @@ private boolean checkMethods() {
         return true;
     }
 
+    private boolean checkListTypes() {
+        for (VariableElement field : fields) {
+            if (typeUtils.isAssignable(field.asType(), realmList)) {
+                if (Utils.getGenericType(field) == null) {
+                    Utils.error("No generic type supplied for field", field);
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
     // Verify that a setter is used to set a field in the model class.
     // Note: This is done heuristically by comparing the name of setter with the name of the field.
     // Annotation processors does not allow us to inspect individual statements.
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index ae37a0e4f3..2e689afbf1 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -20,4 +20,5 @@
     public static final String REALM_PACKAGE_NAME = "io.realm";
     public static final String PROXY_SUFFIX = "RealmProxy";
     public static final String TABLE_PREFIX = "class_";
+    public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
new file mode 100644
index 0000000000..7e546127d7
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.tools.JavaFileObject;
+
+import io.realm.annotations.RealmModule;
+
+/**
+ * This class is responsible for creating the DefaultRealmModule that contains all known
+ * {@link io.realm.annotations.RealmClass}' known at compile time.
+ */
+public class DefaultModuleGenerator {
+
+    private final ProcessingEnvironment env;
+
+    public DefaultModuleGenerator(ProcessingEnvironment env) {
+        this.env = env;
+    }
+
+    public void generate() throws IOException {
+        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
+        JavaFileObject sourceFile = env.getFiler().createSourceFile(qualifiedGeneratedClassName);
+        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
+        writer.setIndent("    ");
+
+        writer.emitPackage(Constants.REALM_PACKAGE_NAME);
+        writer.emitEmptyLine();
+
+        Map<String, Boolean> attributes = new HashMap<String, Boolean>();
+        attributes.put("allClasses", Boolean.TRUE);
+        writer.emitAnnotation(RealmModule.class, attributes);
+        writer.beginType(
+                qualifiedGeneratedClassName,        // full qualified name of the item to generate
+                "class",                            // the type of the item
+                Collections.<Modifier>emptySet(),   // modifiers to apply
+                null);                              // class to extend
+        writer.emitEmptyLine();
+
+        writer.endType();
+        writer.close();
+    }
+}
+
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
new file mode 100644
index 0000000000..2433fc7b8d
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/ModuleMetaData.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import io.realm.annotations.RealmModule;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.*;
+import java.util.*;
+
+/**
+ * Utility class for holding metadata for the Realm modules.
+ */
+public class ModuleMetaData {
+
+    private final Set<ClassMetaData> availableClasses;
+    private final RoundEnvironment env;
+    private Map<String, Set<ClassMetaData>> modules = new HashMap<String, Set<ClassMetaData>>();
+    private Map<String, Set<ClassMetaData>> libraryModules = new HashMap<String, Set<ClassMetaData>>();
+    private Map<String, ClassMetaData> classMetaData = new HashMap<String, ClassMetaData>(); // <FullyQualifiedClassName, ClassMetaData>
+    private boolean shouldCreateDefaultModule;
+
+    public ModuleMetaData(RoundEnvironment env, Set<ClassMetaData> availableClasses) {
+        this.env = env;
+        this.availableClasses = availableClasses;
+        for (ClassMetaData classMetaData : availableClasses) {
+            this.classMetaData.put(classMetaData.getFullyQualifiedClassName(), classMetaData);
+        }
+    }
+
+    /**
+     * Build the meta data structures for this class. Any errors or messages will be posted on the provided Messager.
+     *
+     * @return True if meta data was correctly created and processing can continue, false otherwise.
+     */
+    public boolean generate(ProcessingEnvironment processingEnv) {
+
+        // Check that modules are setup correctly
+        for (Element classElement : env.getElementsAnnotatedWith(RealmModule.class)) {
+            String classSimpleName = classElement.getSimpleName().toString();
+
+            // Check that the annotation is only applied to a class
+            if (!classElement.getKind().equals(ElementKind.CLASS)) {
+                Utils.error("The RealmModule annotation can only be applied to classes", classElement);
+                return false;
+            }
+
+            // Check that allClasses and classes are not set at the same time
+            RealmModule module = classElement.getAnnotation(RealmModule.class);
+            Utils.note("Processing module " + classSimpleName);
+            if (module.allClasses() && hasCustomClassList(classElement)) {
+                Utils.error("Setting @RealmModule(allClasses=true) will override @RealmModule(classes={...}) in " + classSimpleName);
+                return false;
+            }
+
+            // Check that classes added are proper Realm model classes
+            String qualifiedName = ((TypeElement) classElement).getQualifiedName().toString();
+            Set<ClassMetaData> classes;
+            if (module.allClasses()) {
+                classes = availableClasses;
+            } else {
+                classes = new HashSet<ClassMetaData>();
+                Set<String> classNames = getClassMetaDataFromModule(classElement);
+                for (String fullyQualifiedClassName : classNames) {
+                    ClassMetaData metadata = classMetaData.get(fullyQualifiedClassName);
+                    if (metadata == null) {
+                        Utils.error(Utils.stripPackage(fullyQualifiedClassName) + " could not be added to the module. " +
+                                "Only classes extending RealmObject, which are part of this project, can be added.");
+                        return false;
+                    }
+                    classes.add(metadata);
+                }
+            }
+
+            // Create either a Library or App module
+            if (module.library()) {
+                libraryModules.put(qualifiedName, classes);
+            } else {
+                modules.put(qualifiedName, classes);
+            }
+        }
+
+        // Check that app and library modules are not mixed
+        if (modules.size() > 0 && libraryModules.size() > 0) {
+            Utils.error("Normal modules and library modules cannot be mixed in the same project");
+            return false;
+        }
+
+        // Add default realm module if needed.
+        if (libraryModules.size() == 0) {
+            shouldCreateDefaultModule = true;
+            String defautModuleName = Constants.REALM_PACKAGE_NAME + "." + Constants.DEFAULT_MODULE_CLASS_NAME;
+            modules.put(defautModuleName, availableClasses);
+        }
+
+        return true;
+    }
+
+    // Detour needed to access the class elements in the array
+    // See http://blog.retep.org/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/
+    private Set<String> getClassMetaDataFromModule(Element classElement) {
+        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
+        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
+        Set<String> classes = new HashSet<String>();
+        List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
+        for (AnnotationValue classMirror : moduleClasses) {
+            String fullyQualifiedClassName = classMirror.getValue().toString();
+            classes.add(fullyQualifiedClassName);
+        }
+        return classes;
+    }
+
+    // Work around for asking for a Class primitive array which would otherwise throw a TypeMirrorException
+    // https://community.oracle.com/thread/1184190
+    private boolean hasCustomClassList(Element classElement) {
+        AnnotationMirror annotationMirror = getAnnotationMirror(classElement);
+        AnnotationValue annotationValue = getAnnotationValue(annotationMirror);
+        if (annotationValue == null) {
+            return false;
+        } else {
+            List<? extends AnnotationValue> moduleClasses = (List<? extends AnnotationValue>) annotationValue.getValue();
+            return moduleClasses.size() > 0;
+        }
+    }
+
+    private AnnotationMirror getAnnotationMirror(Element classElement) {
+        AnnotationMirror annotationMirror = null;
+        for (AnnotationMirror am : classElement.getAnnotationMirrors()) {
+            if (am.getAnnotationType().toString().equals(RealmModule.class.getCanonicalName())) {
+                annotationMirror = am;
+                break;
+            }
+        }
+        return annotationMirror;
+    }
+
+    private AnnotationValue getAnnotationValue(AnnotationMirror annotationMirror) {
+        if (annotationMirror == null) {
+            return null;
+        }
+        AnnotationValue annotationValue = null;
+        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {
+            if (entry.getKey().getSimpleName().toString().equals("classes")) {
+                annotationValue = entry.getValue();
+                break;
+            }
+        }
+        return annotationValue;
+    }
+
+    /**
+     * Returns all module classes and the RealmObjects they know of.
+     */
+    public Map<String, Set<ClassMetaData>> getAllModules() {
+        Map<String, Set<ClassMetaData>> allModules = new HashMap<String, Set<ClassMetaData>>();
+        allModules.putAll(modules);
+        allModules.putAll(libraryModules);
+        return allModules;
+    }
+
+    /**
+     * Returns {@code true} if the DefaultRealmModule.java file should be created.
+     */
+    public boolean shouldCreateDefaultModule() {
+        return shouldCreateDefaultModule;
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
deleted file mode 100644
index 74b6f452cd..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Set;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.tools.JavaFileObject;
-
-/**
- * This class generates the RealmJsonImpl class which is responsible for importing json data into either standalone
- * objects or RealmObjects.
- */
-public class RealmJSonImplGenerator {
-
-    private final ProcessingEnvironment processingEnvironment;
-    private List<String> qualifiedModelClasses = new ArrayList<String>();
-    private List<String> simpleModelClasses = new ArrayList<String>();
-    private List<String> proxyClasses = new ArrayList<String>();
-
-    private static final String REALM_PACKAGE_NAME = "io.realm";
-    private static final String CLASS_NAME = "RealmJsonImpl";
-    private static final String EXCEPTION_MSG = "\"Could not find the generated proxy class for \" + classQualifiedName";
-
-    public RealmJSonImplGenerator(ProcessingEnvironment processingEnv, Set<ClassMetaData> classesToValidate) {
-        this.processingEnvironment = processingEnv;
-        for (ClassMetaData metadata: classesToValidate) {
-            qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
-            simpleModelClasses.add(metadata.getSimpleClassName());
-            proxyClasses.add(Utils.getProxyClassName(metadata.getSimpleClassName()));
-        }
-    }
-
-    public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", REALM_PACKAGE_NAME, CLASS_NAME);
-        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-        writer.setIndent("    ");
-
-        writer.emitPackage(REALM_PACKAGE_NAME);
-        writer.emitEmptyLine();
-
-        writer.emitImports(
-                "android.util.JsonReader",
-                "io.realm.exceptions.RealmException",
-                "io.realm.internal.RealmJson",
-                "java.io.IOException",
-                "java.util.ArrayList",
-                "java.util.Collections",
-                "java.util.List",
-                "org.json.JSONException",
-                "org.json.JSONObject"
-        );
-        writer.emitImports(qualifiedModelClasses);
-        writer.emitEmptyLine();
-        writer.beginType(
-                qualifiedGeneratedClassName,    // full qualified name of the item to generate
-                "class",                        // the type of the item
-                Collections.<Modifier>emptySet(),      // modifiers to apply
-                null,                           // class to extend
-                "RealmJson");                   // Interfaces to implement
-        writer.emitEmptyLine();
-
-        emitPopulateUsingJsonObject(writer);
-        emitPopulateUsingJsonStream(writer);
-
-        writer.endType();
-        writer.close();
-    }
-
-    private void emitPopulateUsingJsonObject(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmObject> void",
-                "populateUsingJsonObject",
-                EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("E", "obj", "JSONObject", "json"),
-                Arrays.asList("JSONException")
-        );
-        emitProxySwitch("%s.populateUsingJsonObject((%s) obj, json)", writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    private void emitPopulateUsingJsonStream(JavaWriter writer) throws IOException {
-        writer.emitAnnotation("Override");
-        writer.beginMethod(
-                "<E extends RealmObject> void",
-                "populateUsingJsonStream",
-                EnumSet.of(Modifier.PUBLIC),
-                Arrays.asList("E", "obj", "JsonReader", "reader"),
-                Arrays.asList("IOException")
-        );
-        emitProxySwitch("%s.populateUsingJsonStream((%s) obj, reader)", writer);
-        writer.endMethod();
-        writer.emitEmptyLine();
-    }
-
-    // Emits the control flow for selecting the appropriate proxy class based on the model class
-    // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
-    // Consider switching to HashMap or similar.
-    private void emitProxySwitch(String proxyStatement, JavaWriter writer) throws IOException {
-        writer.emitStatement("String classQualifiedName = (obj.realm != null) ? obj.getClass().getSuperclass().getName() : obj.getClass().getName()");
-        if (simpleModelClasses.size() == 0) {
-            writer.emitStatement("throw new RealmException(%s)", EXCEPTION_MSG);
-        } else {
-            writer.beginControlFlow("if (classQualifiedName.equals(%s.class.getName()))", simpleModelClasses.get(0));
-            writer.emitStatement(proxyStatement, proxyClasses.get(0), simpleModelClasses.get(0));
-            for (int i = 1; i < simpleModelClasses.size(); i++) {
-                writer.nextControlFlow("else if (classQualifiedName.equals(%s.class.getName()))", simpleModelClasses.get(i));
-                writer.emitStatement(proxyStatement, proxyClasses.get(i), simpleModelClasses.get(i));
-            }
-            writer.nextControlFlow("else");
-            writer.emitStatement("throw new RealmException(%s)", EXCEPTION_MSG);
-            writer.endControlFlow();
-        }
-    }
-}
\ No newline at end of file
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index b559fc1a23..c04722c74d 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -56,8 +56,6 @@ public void emitTypeConversion(String setter, String fieldName, String fieldType
                         .nextControlFlow("else")
                             .emitStatement("obj.%s(new Date(json.getLong(\"%s\")))", setter, fieldName)
                         .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("obj.%s(new Date(0))", setter)
                     .endControlFlow();
             }
 
@@ -77,7 +75,10 @@ public void emitStreamTypeConversion(String setter, String fieldName, String fie
         JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmTypeConverter() {
             @Override
             public void emitTypeConversion(String setter, String fieldName, String fieldType, JavaWriter writer) throws IOException {
-                writer.emitStatement("obj.%s(JsonUtils.stringToBytes(json.isNull(\"%s\") ? null : json.getString(\"%s\")))", setter, fieldName, fieldName);
+                writer
+                    .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("obj.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", setter, fieldName)
+                    .endControlFlow();
             }
 
             @Override
@@ -98,11 +99,9 @@ public static void emitFillRealmObjectWithJsonValue(String setter, String fieldN
                                                         String proxyClass, JavaWriter writer) throws IOException {
         writer
             .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .emitStatement("%s %s = standalone ? new %s() : obj.realm.createObject(%s.class)",
-                        qualifiedFieldType, fieldName, qualifiedFieldType, qualifiedFieldType)
-                .emitStatement("%s.populateUsingJsonObject(%s, json.getJSONObject(\"%s\"))",
-                        proxyClass, fieldName, fieldName)
-                .emitStatement("obj.%s(%s)", setter, fieldName)
+                .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                        qualifiedFieldType, fieldName, proxyClass, fieldName)
+                .emitStatement("obj.%s(%sObj)", setter, fieldName)
             .endControlFlow();
     }
 
@@ -111,13 +110,11 @@ public static void emitFillRealmListWithJsonValue(String getter, String setter,
                                                       JavaWriter writer) throws IOException {
         writer
             .beginControlFlow("if (!json.isNull(\"%s\"))", fieldName)
-                .beginControlFlow("if (standalone)")
-                    .emitStatement("obj.%s(new RealmList<%s>())", setter, fieldTypeCanonicalName)
-                .endControlFlow()
+                .emitStatement("obj.%s().clear()", getter)
                 .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
                 .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                    .emitStatement("%s item = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-                    .emitStatement("%s.populateUsingJsonObject(item, array.getJSONObject(i))", proxyClass)
+                    .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
+                            fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
                     .emitStatement("obj.%s().add(item)", getter)
                 .endControlFlow()
             .endControlFlow();
@@ -132,20 +129,15 @@ public static void emitFillJavaTypeFromStream(String setter, String fieldName, S
 
     public static void emitFillRealmObjectFromStream(String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
         writer
-            .emitStatement("%s %sObj = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-            .emitStatement("%s.populateUsingJsonStream(%sObj, reader)", proxyClass, fieldName)
+            .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName, proxyClass)
             .emitStatement("obj.%s(%sObj)", setter, fieldName);
     }
 
     public static void emitFillRealmListFromStream(String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
         writer
             .emitStatement("reader.beginArray()")
-            .beginControlFlow("if (standalone)")
-                .emitStatement("obj.%s(new RealmList<%s>())", setter, fieldTypeCanonicalName)
-            .endControlFlow()
             .beginControlFlow("while (reader.hasNext())")
-                .emitStatement("%s item = standalone ? new %s() : obj.realm.createObject(%s.class)", fieldTypeCanonicalName, fieldTypeCanonicalName, fieldTypeCanonicalName)
-                .emitStatement("%s.populateUsingJsonStream(item, reader)", proxyClass)
+                .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
                 .emitStatement("obj.%s().add(item)", getter)
             .endControlFlow()
             .emitStatement("reader.endArray()");
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index 1221d83168..f7dd18c9c7 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
@@ -30,15 +31,76 @@
 
 import io.realm.annotations.RealmClass;
 
+/**
+ * The RealmProcessor is responsible for creating the plumbing that connects the RealmObjects to a Realm. The process
+ * for doing so is summarized below and then described in more detail.
+ * <p>
+ *
+ * <h1>DESIGN GOALS</h1>
+ *
+ * The processor should support the following design goals:
+ * <ul>
+ *  <li>Minimize reflection.</li>
+ *  <li>Realm code can be obfuscated as much as possible.</li>
+ *  <li>Library projects must be able to use Realm without interfering with app code.</li>
+ *  <li>App code must be able to use model classes provided by library code.</li>
+ *  <li>It should work for app developers out of the box (ie. put the burden on the library developer)</li>
+ * </ul>
+ *
+ * <h1>SUMMARY</h1>
+ *
+ * <ol>
+ *  <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;modelClass&gt;RealmProxy.java</li>
+ *  <li>Create a DefaultRealmModule containing all model classes (if needed).</li>
+ *  <li>Create a RealmProxyMediator class for all classes marked with @RealmModule. They are named <moduleName>Mediator.java</li>
+ * </ol>
+ *
+ * <h1>WHY</h1>
+ *
+ * <ol>
+ * <li>A RealmObjectProxy object is created for each class annotated with {@link io.realm.annotations.RealmClass}. This
+ * proxy extends the original model class and rewires all field access to point to the native Realm memory instead of
+ * Java memory. It also adds some static helper methods to the class.</li>
+ *
+ * <li>The annotation processor is either in "library" mode or in "app" mode. This is defined by having a class
+ * annotated with @RealmModule(library = true). It is not allowed to have both a class with library = true and
+ * library = false in the same IntelliJ module and it will cause the annotation processor to throw an exception. If no
+ * library modules are defined, we will create a DefaultRealmModule containing all known RealmObjects and with the
+ * @RealmModule annotation. Realm automatically knows about this module, but it is still possible for users to create
+ * their own modules with a subset of model classes.</li>
+ *
+ * <li>For each class annotated with @RealmModule a matching Mediator class is created (including the default one). This
+ * class has an interface that matches the static helper methods for the proxy classes. All access to these static
+ * helper methods should be done through this Mediator.</li>
+ * </ol>
+ *
+ * This allows ProGuard to obfuscate all model and proxy classes as all access to the static methods now happens through
+ * the Mediator, and the only requirement is now that only RealmModule and Mediator class names cannot be obfuscated.
+ *
+ *
+ * <h1>CREATING A REALM</h1>
+ *
+ * This means the workflow when instantiating a Realm on runtime is the following:
+ *
+ * <ol>
+ *  <li>Open a Realm.</li>
+ *  <li>Assign one or more modules (that are allowed to overlap). If no module is assigned, the default module is used.</li>
+ *  <li>The Realm schema is now defined as all model classes known by these modules.</li>
+ *  <li>Each time a static helper method is needed, Realm can now delegate these method calls to the appropriate
+ *    Mediator which in turn will delegate the method call to the appropriate RealmObjectProxy class.</li>
+ * </ol>
+ */
 @SupportedAnnotationTypes({
         "io.realm.annotations.RealmClass",
         "io.realm.annotations.Ignore",
         "io.realm.annotations.Index",
-        "io.realm.annotations.PrimaryKey"
+        "io.realm.annotations.PrimaryKey",
+        "io.realm.annotations.internal.RealmModule"
 })
 public class RealmProcessor extends AbstractProcessor {
+
     Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
-    boolean done = false;
+    private boolean hasProcessedModules = false;
 
     @Override public SourceVersion getSupportedSourceVersion() {
         return SourceVersion.latestSupported();
@@ -46,10 +108,14 @@
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        if (hasProcessedModules) {
+            return true;
+        }
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
         Utils.initialize(processingEnv);
 
+        // Create all proxy classes
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
             // Check the annotation was applied to a Class
@@ -61,9 +127,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 continue;
             }
             Utils.note("Processing class " + metadata.getSimpleClassName());
-            boolean success = metadata.generateMetaData(processingEnv.getMessager());
+            boolean success = metadata.generate();
             if (!success) {
-                done = true;
                 return true; // Abort processing by claiming all annotations
             }
             classesToValidate.add(metadata);
@@ -76,20 +141,60 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
             } catch (UnsupportedOperationException e) {
                 Utils.error(e.getMessage(), classElement);
             }
+	    }
+
+        hasProcessedModules = true;
+        return processModules(roundEnv);
+    }
+
+    // Returns true if modules was processed successfully, false otherwise
+    private boolean processModules(RoundEnvironment roundEnv) {
+
+        ModuleMetaData moduleMetaData = new ModuleMetaData(roundEnv, classesToValidate);
+        if (!moduleMetaData.generate(processingEnv)) {
+            return false;
         }
 
-        if (!done) {
-            RealmValidationListGenerator validationGenerator = new RealmValidationListGenerator(processingEnv, classesToValidate);
-            RealmJSonImplGenerator jsonGenerator = new RealmJSonImplGenerator(processingEnv, classesToValidate);
-            try {
-                validationGenerator.generate();
-                jsonGenerator.generate();
-                done = true;
-            } catch (IOException e) {
-                Utils.error(e.getMessage());
+        // Create default module if needed
+        if (moduleMetaData.shouldCreateDefaultModule()) {
+            if (!createDefaultModule()) {
+                return false;
+            };
+        }
+
+        // Create RealmProxyMediators for all Realm modules
+        for (Map.Entry<String, Set<ClassMetaData>> module : moduleMetaData.getAllModules().entrySet()) {
+            if (!createMediator(Utils.stripPackage(module.getKey()), module.getValue())) {
+                return false;
             }
         }
 
         return true;
     }
+
+    private boolean createDefaultModule() {
+        Utils.note("Creating DefaultRealmModule");
+        DefaultModuleGenerator defaultModuleGenerator = new DefaultModuleGenerator(processingEnv);
+        try {
+            defaultModuleGenerator.generate();
+        } catch (IOException e) {
+            Utils.error(e.getMessage());
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean createMediator(String simpleModuleName, Set<ClassMetaData> moduleClasses) {
+        RealmProxyMediatorGenerator mediatorImplGenerator = new RealmProxyMediatorGenerator(processingEnv,
+                simpleModuleName, moduleClasses);
+        try {
+            mediatorImplGenerator.generate();
+        } catch (IOException e) {
+            Utils.error(e.getMessage());
+            return false;
+        }
+
+        return true;
+    }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index dcdef8da83..6fba13992c 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -146,6 +146,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.exceptions.RealmException");
         imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnType");
+        imports.add("io.realm.internal.RealmObjectProxy");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
         imports.add("io.realm.internal.ImplicitTransaction");
@@ -184,17 +185,19 @@ public void generate() throws IOException, UnsupportedOperationException {
                 qualifiedGeneratedClassName, // full qualified name of the item to generate
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                className)                   // class to extend
+                className,                   // class to extend
+                "RealmObjectProxy")          // interfaces to implement
                 .emitEmptyLine();
 
         emitClassFields(writer);
         emitAccessors(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
+        emitGetTableNameMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitGetColumnIndicesMethod(writer);
-        emitPopulateUsingJsonObjectMethod(writer);
-        emitPopulateUsingJsonStreamMethod(writer);
+        emitCreateOrUpdateUsingJsonObject(writer);
+        emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
         emitUpdateMethod(writer);
@@ -305,6 +308,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.beginControlFlow("if (value == null)");
                 writer.emitStatement("return"); // TODO: delete all the links instead
                 writer.endControlFlow();
+                writer.emitStatement("links.clear()");
                 writer.beginControlFlow("for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value)");
                 writer.emitStatement("links.add(linkedObject.row.getIndex())");
                 writer.endControlFlow();
@@ -324,7 +328,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if(!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
+        writer.beginControlFlow("if (!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
         writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
 
         // For each field generate corresponding table index constant
@@ -355,7 +359,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
         for (VariableElement field : metadata.getIndexedFields()) {
             String fieldName = field.getSimpleName().toString();
-            writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
+            writer.emitStatement("table.addSearchIndex(table.getColumnIndex(\"%s\"))", fieldName);
         }
 
         if (metadata.hasPrimaryKey()) {
@@ -379,21 +383,39 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if(transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
+        writer.beginControlFlow("if (transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
         writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
 
         // verify number of columns
-        writer.beginControlFlow("if(table.getColumnCount() != " + metadata.getFields().size() + ")");
-        writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
+        writer.beginControlFlow("if (table.getColumnCount() != " + metadata.getFields().size() + ")");
+        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field count does not match - expected %d but was \" + table.getColumnCount())",
+                metadata.getFields().size());
         writer.endControlFlow();
 
         // create type dictionary for lookup
         writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
-        writer.beginControlFlow("for(long i = 0; i < " + metadata.getFields().size() + "; i++)");
+        writer.beginControlFlow("for (long i = 0; i < " + metadata.getFields().size() + "; i++)");
         writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
         writer.endControlFlow();
 
-        // For each field verify there is a corresponding column
+        // Populate column indices
+        writer.emitEmptyLine();
+        writer.emitStatement("columnIndices = new HashMap<String, Long>()");
+        writer
+                .beginControlFlow("for (String fieldName : getFieldNames())")
+                    .emitStatement("long index = table.getColumnIndex(fieldName)")
+                    .beginControlFlow("if (index == -1)")
+                        .emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field '\" + fieldName + \"' not found for type %s\")", metadata.getSimpleClassName())
+                    .endControlFlow()
+                    .emitStatement("columnIndices.put(fieldName, index)")
+                .endControlFlow();
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement("%s = table.getColumnIndex(\"%s\")", staticFieldIndexVarName(field), field.getSimpleName().toString());
+        }
+        writer.emitEmptyLine();
+
+        // For each field verify there is a corresponding
+        long fieldIndex = 0;
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldTypeCanonicalName = field.asType().toString();
@@ -402,88 +424,84 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
             if (JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 // make sure types align
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
-                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
                 // Validate @PrimaryKey
                 if (field.equals(metadata.getPrimaryKey())) {
                     writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
-                    writer.emitStatement("throw new IllegalStateException(\"Primary key not defined for field '%s'\")", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Primary key not defined for field '%s'\")", fieldName);
                     writer.endControlFlow();
                 }
 
                 // Validate @Index
                 if (metadata.getIndexedFields().contains(field)) {
-                    writer.beginControlFlow("if (!table.hasIndex(table.getColumnIndex(\"%s\")))", fieldName);
-                    writer.emitStatement("throw new IllegalStateException(\"Index not defined for field '%s'\")", fieldName);
+                    writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Index not defined for field '%s'\")", fieldName);
                     writer.endControlFlow();
                 }
 
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK)", fieldName);
-                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
                         Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                // TODO: Replace with a proper comparison
-//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
-//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
-//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link tables for column '%s'\")",
-//                        fieldName);
-//                writer.endControlFlow();
+
+                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+                        staticFieldIndexVarName(field), fieldIndex);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                        fieldName, staticFieldIndexVarName(field), fieldIndex);
+                writer.endControlFlow();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) { // Link Lists
                 String genericType = Utils.getGenericType(field);
-                writer.beginControlFlow("if(!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
+                writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if(columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
-                writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
+                writer.beginControlFlow("if (columnTypes.get(\"%s\") != ColumnType.LINK_LIST)", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
                         genericType, fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
-                writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
                         Constants.TABLE_PREFIX, genericType, fieldName);
                 writer.endControlFlow();
-                // TODO: Replace with a proper comparison
-//                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
-//                writer.beginControlFlow("if (table.getLinkTarget(%d).equals(table_%d))", columnNumber, columnNumber);
-//                writer.emitStatement("throw new IllegalStateException(\"Mismatching link list tables for column '%s'\")",
-//                        fieldName);
-//                writer.endControlFlow();
+
+                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericType);
+                writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
+                        staticFieldIndexVarName(field), fieldIndex);
+                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                        fieldName, staticFieldIndexVarName(field), fieldIndex);
+                writer.endControlFlow();
             }
+            fieldIndex++;
         }
 
-        // Populate column indices
-        writer.emitEmptyLine();
-        writer.emitStatement("columnIndices = new HashMap<String, Long>()");
-        writer
-            .beginControlFlow("for (String fieldName : getFieldNames())")
-                .emitStatement("long index = table.getColumnIndex(fieldName)")
-                .beginControlFlow("if (index == -1)")
-                    .emitStatement("throw new RealmMigrationNeededException(\"Field '\" + fieldName + \"' not found for type %s\")", metadata.getSimpleClassName())
-                .endControlFlow()
-                .emitStatement("columnIndices.put(fieldName, index)")
-            .endControlFlow();
-        for (VariableElement field : metadata.getFields()) {
-            writer.emitStatement("%s = table.getColumnIndex(\"%s\")", staticFieldIndexVarName(field), field.getSimpleName().toString());
-        }
         writer.nextControlFlow("else");
-        writer.emitStatement("throw new RealmMigrationNeededException(\"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
+        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
+    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
+        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, className);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
         writer.emitStatement("return FIELD_NAMES");
@@ -503,12 +521,12 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObject>", "cache" // Argument type & argument name
+                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
         // If object is already in the Realm there is nothing to update
         writer
-            .beginControlFlow("if (object.realm != null && object.realm.getId() == realm.getId())")
+            .beginControlFlow("if (object.realm != null && object.realm.getPath().equals(realm.getPath()))")
                 .emitStatement("return object")
             .endControlFlow();
 
@@ -523,7 +541,11 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
 
             if (Utils.isString(metadata.getPrimaryKey())) {
-                writer.emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
+                writer
+                    .beginControlFlow("if (object.%s() == null)", metadata.getPrimaryKeyGetter())
+                        .emitStatement("throw new IllegalArgumentException(\"Primary key value must not be null.\")")
+                    .endControlFlow()
+                    .emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
             } else {
                 writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
             }
@@ -532,8 +554,8 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
                     .emitStatement("realmObject = new %s()", Utils.getProxyClassName(className))
                     .emitStatement("realmObject.realm = realm")
-                    .emitStatement("realmObject.row = table.getRow(rowIndex)")
-                    .emitStatement("cache.put(object, realmObject)")
+                    .emitStatement("realmObject.row = table.getUncheckedRow(rowIndex)")
+                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                 .nextControlFlow("else")
                     .emitStatement("canUpdate = false")
                 .endControlFlow();
@@ -558,14 +580,14 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "copy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObject>", "cache"); // Argument type & argument name
+                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObjectProxy>", "cache"); // Argument type & argument name
 
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("%s realmObject = realm.createObject(%s.class, newObject.%s())", className, className, metadata.getPrimaryKeyGetter());
         } else {
             writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
         }
-        writer.emitStatement("cache.put(newObject, realmObject)");
+        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
@@ -626,7 +648,7 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 className, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmObject, RealmObject>", "cache"); // Argument type & argument name
+                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmObject, RealmObjectProxy>", "cache"); // Argument type & argument name
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -768,15 +790,39 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOException {
+
+    private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "void",
-                "populateUsingJsonObject",
+                className,
+                "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList(className, "obj", "JSONObject", "json"),
+                Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Arrays.asList("JSONException"));
 
-        writer.emitStatement("boolean standalone = obj.realm == null");
+        if (!metadata.hasPrimaryKey()) {
+            writer.emitStatement("%s obj = realm.createObject(%s.class)", className, className);
+        } else {
+            String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+            writer
+                .emitStatement("%s obj = null", className)
+                .beginControlFlow("if (update)")
+                    .emitStatement("Table table = realm.getTable(%s.class)", className)
+                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
+                    .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                        .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                            .emitStatement("obj = new %s()", Utils.getProxyClassName(className))
+                            .emitStatement("obj.realm = realm")
+                            .emitStatement("obj.row = table.getUncheckedRow(rowIndex)")
+                        .endControlFlow()
+                    .endControlFlow()
+                .endControlFlow()
+                .beginControlFlow("if (obj == null)")
+                    .emitStatement("obj = realm.createObject(%s.class)", className)
+                .endControlFlow();
+        }
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
@@ -806,19 +852,20 @@ private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOExcep
             }
         }
 
+        writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOException {
+    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "void",
-                "populateUsingJsonStream",
+                className,
+                "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
-                Arrays.asList(className, "obj", "JsonReader", "reader"),
+                Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                 Arrays.asList("IOException"));
 
-        writer.emitStatement("boolean standalone = obj.realm == null");
+        writer.emitStatement("%s obj = realm.createObject(%s.class)",className, className);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
@@ -866,6 +913,7 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
         }
         writer.endControlFlow();
         writer.emitStatement("reader.endObject()");
+        writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
     }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
new file mode 100644
index 0000000000..37ed7b096c
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -0,0 +1,333 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Modifier;
+import javax.tools.JavaFileObject;
+
+import io.realm.annotations.RealmModule;
+
+public class RealmProxyMediatorGenerator {
+    private final String className;
+    private ProcessingEnvironment processingEnvironment;
+    private List<String> qualifiedModelClasses = new ArrayList<String>();
+    private List<String> simpleModelClasses = new ArrayList<String>();
+    private List<String> proxyClasses = new ArrayList<String>();
+
+    private static final String REALM_PACKAGE_NAME = "io.realm";
+
+    public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
+                                       String className, Set<ClassMetaData> classesToValidate) {
+        this.processingEnvironment = processingEnvironment;
+        this.className = className;
+
+        for (ClassMetaData metadata : classesToValidate) {
+            String simpleName = metadata.getSimpleClassName();
+            qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
+            simpleModelClasses.add(simpleName);
+            proxyClasses.add(getProxyClassName(simpleName));
+        }
+    }
+
+    public void generate() throws IOException {
+        String qualifiedGeneratedClassName = String.format("%s.%sMediator", REALM_PACKAGE_NAME, className);
+        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
+        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
+        writer.setIndent("    ");
+
+        writer.emitPackage(REALM_PACKAGE_NAME);
+        writer.emitEmptyLine();
+
+        writer.emitImports(
+                "android.util.JsonReader",
+                "java.io.IOException",
+                "java.util.ArrayList",
+                "java.util.Collections",
+                "java.util.List",
+                "java.util.Map",
+                "io.realm.exceptions.RealmException",
+                "io.realm.internal.ImplicitTransaction",
+                "io.realm.internal.RealmObjectProxy",
+                "io.realm.internal.RealmProxyMediator",
+                "io.realm.internal.Table",
+                "org.json.JSONException",
+                "org.json.JSONObject"
+        );
+        writer.emitImports(qualifiedModelClasses);
+
+        writer.emitEmptyLine();
+
+        writer.emitAnnotation(RealmModule.class);
+        writer.beginType(
+                qualifiedGeneratedClassName,        // full qualified name of the item to generate
+                "class",                            // the type of the item
+                Collections.<Modifier>emptySet(),   // modifiers to apply
+                "RealmProxyMediator");               // class to extend
+        writer.emitEmptyLine();
+
+        emitFields(writer);
+        emitCreateTableMethod(writer);
+        emitValidateTableMethod(writer);
+        emitGetFieldNamesMethod(writer);
+        emitGetTableNameMethod(writer);
+        emitNewInstanceMethod(writer);
+        emitGetClassModelList(writer);
+        emitGetColumnIndices(writer);
+        emitCopyToRealmMethod(writer);
+        emitCreteOrUpdateUsingJsonObject(writer);
+        emitCreateUsingJsonStream(writer);
+
+        writer.endType();
+        writer.close();
+    }
+
+    private void emitFields(JavaWriter writer) throws IOException {
+        writer.emitField("List<Class<? extends RealmObject>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.beginInitializer(true);
+        writer.emitStatement("List<Class<? extends RealmObject>> modelClasses = new ArrayList<Class<? extends RealmObject>>()");
+        for (String clazz : simpleModelClasses) {
+            writer.emitStatement("modelClasses.add(%s.class)", clazz);
+        }
+        writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableList(modelClasses)");
+        writer.endInitializer();
+        writer.emitEmptyLine();
+    }
+
+    private void emitCreateTableMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "Table",
+                "createTable",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmObject>", "clazz", "ImplicitTransaction", "transaction"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.initTable(transaction)", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "validateTable",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmObject>", "clazz", "ImplicitTransaction", "transaction"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.validateTable(transaction)", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "List<String>",
+                "getFieldNames",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmObject>", "clazz"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.getFieldNames()", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "String",
+                "getTableName",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmObject>", "clazz"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.getTableName()", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmObject> E",
+                "newInstance",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<E>", "clazz"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(new %s())", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetClassModelList(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod("List<Class<? extends RealmObject>>", "getModelClasses", EnumSet.of(Modifier.PUBLIC));
+        writer.emitStatement("return MODEL_CLASSES");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetColumnIndices(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "Map<String, Long>",
+                "getColumnIndices",
+                EnumSet.of(Modifier.PUBLIC),
+                "Class<? extends RealmObject>", "clazz"
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return %s.getColumnIndices()", proxyClasses.get(i));
+            }
+        }, writer, true);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmObject> E",
+                "copyOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "E", "obj", "boolean", "update", "Map<RealmObject, RealmObjectProxy>",  "cache"
+        );
+        writer.emitSingleLineComment("This cast is correct because obj is either ");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", proxyClasses.get(i), simpleModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmObject> E",
+                "createOrUpdateUsingJsonObject",
+                EnumSet.of(Modifier.PUBLIC),
+                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JSONObject", "json", "boolean", "update"),
+                Arrays.asList("JSONException")
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "<E extends RealmObject> E",
+                "createUsingJsonStream",
+                EnumSet.of(Modifier.PUBLIC),
+                Arrays.asList("Class<E>", "clazz", "Realm", "realm", "JsonReader", "reader"),
+                Arrays.asList("java.io.IOException")
+        );
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", proxyClasses.get(i));
+            }
+        }, writer);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    // Emits the control flow for selecting the appropriate proxy class based on the model class
+    // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
+    // Consider switching to HashMap or similar.
+    private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
+        emitMediatorSwitch(statement, writer, true);
+    }
+
+    private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
+            throws IOException {
+        if (nullPointerCheck) {
+            writer.emitStatement("checkClass(clazz)");
+            writer.emitEmptyLine();
+        }
+        if (simpleModelClasses.size() == 0) {
+            writer.emitStatement("throw getMissingProxyClassException(clazz)");
+        } else {
+            writer.beginControlFlow("if (clazz.equals(%s.class))", simpleModelClasses.get(0));
+            statement.emitStatement(0, writer);
+            for (int i = 1; i < simpleModelClasses.size(); i++) {
+                writer.nextControlFlow("else if (clazz.equals(%s.class))", simpleModelClasses.get(i));
+                statement.emitStatement(i, writer);
+            }
+            writer.nextControlFlow("else");
+            writer.emitStatement("throw getMissingProxyClassException(clazz)");
+            writer.endControlFlow();
+        }
+    }
+
+    private String getProxyClassName(String clazz) {
+        return clazz + Constants.PROXY_SUFFIX;
+    }
+
+    private interface ProxySwitchStatement {
+        public void emitStatement(int i, JavaWriter writer) throws IOException;
+    }
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java
deleted file mode 100644
index 651f73a082..0000000000
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.Modifier;
-import javax.tools.JavaFileObject;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.util.*;
-
-public class RealmValidationListGenerator {
-    private ProcessingEnvironment processingEnvironment;
-    private Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
-
-    private static final String CLASS_NAME = "ValidationList";
-
-    public RealmValidationListGenerator(ProcessingEnvironment processingEnvironment, Set<ClassMetaData> classesToValidate) {
-        this.processingEnvironment = processingEnvironment;
-        this.classesToValidate = classesToValidate;
-    }
-
-    public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, CLASS_NAME);
-        JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
-        JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
-        writer.setIndent("    ");
-
-        writer.emitPackage(Constants.REALM_PACKAGE_NAME);
-        writer.emitEmptyLine();
-
-        writer.emitImports("java.util.Arrays", "java.util.List");
-        writer.emitEmptyLine();
-
-        // Begin the class definition
-        writer.beginType(
-                qualifiedGeneratedClassName, // full qualified name of the item to generate
-                "class",                     // the type of the item
-                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                null);                       // class to extend
-        writer.emitEmptyLine();
-
-        writer.beginMethod("List<String>", "getProxyClasses", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        List<String> entries = new ArrayList<String>();
-        for (ClassMetaData classToValidate : classesToValidate) {
-            entries.add(String.format("\"%s\"", classToValidate.getSimpleClassName()));
-        }
-        String statementSection = joinStringList(entries, ", ");
-        writer.emitStatement("return Arrays.asList(%s)", statementSection);
-        writer.endMethod();
-        writer.emitEmptyLine();
-
-        writer.endType();
-        writer.close();
-    }
-
-    public static String joinStringList(List<String> strings, String separator) {
-        StringBuilder stringBuilder = new StringBuilder();
-        ListIterator<String> iterator = strings.listIterator();
-        while (iterator.hasNext()) {
-            int index = iterator.nextIndex();
-            String item = iterator.next();
-
-            if (index > 0) {
-                stringBuilder.append(separator);
-            }
-            stringBuilder.append(item);
-        }
-        return stringBuilder.toString();
-    }
-}
\ No newline at end of file
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index d9a0d5cdcd..b2ba192cf3 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -1,5 +1,8 @@
 package io.realm.processor;
 
+import java.lang.reflect.ParameterizedType;
+import java.util.List;
+
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;
@@ -8,6 +11,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -83,7 +87,12 @@ public static String getFieldTypeSimpleName(VariableElement field) {
      * Returns the generic type for Lists of the form {@code List<type>}
      */
     public static String getGenericType(VariableElement field) {
-        String genericCanonicalType = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
+        TypeMirror fieldType = field.asType();
+        List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
+        if (typeArguments.size() == 0) {
+            return null;
+        }
+        String genericCanonicalType = (String) typeArguments.get(0).toString();
         String genericType;
         if (genericCanonicalType.contains(".")) {
             genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
@@ -93,6 +102,17 @@ public static String getGenericType(VariableElement field) {
         return genericType;
     }
 
+    /**
+     * Strips the package name from a fully qualified class name.
+     */
+    public static String stripPackage(String fullyQualifiedClassName) {
+        String[] parts = fullyQualifiedClassName.split("\\.");
+        if (parts.length > 0) {
+            return parts[parts.length - 1];
+        } else {
+            return fullyQualifiedClassName;
+        }
+    }
 
     public static void error(String message, Element element) {
         messager.printMessage(Diagnostic.Kind.ERROR, message, element);
diff --git a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 988eb05639..76811e09f4 100644
--- a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -21,7 +21,10 @@
 
 import javax.tools.JavaFileObject;
 
+import java.util.Arrays;
+
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static org.truth0.Truth.ASSERT;
 
 public class RealmProcessorTest {
@@ -30,12 +33,15 @@
     private JavaFileObject simpleProxy = JavaFileObjects.forResource("io/realm/SimpleRealmProxy.java");
     private JavaFileObject allTypesModel = JavaFileObjects.forResource("some/test/AllTypes.java");
     private JavaFileObject allTypesProxy = JavaFileObjects.forResource("io/realm/AllTypesRealmProxy.java");
+    private JavaFileObject allTypesDefaultModule = JavaFileObjects.forResource("io/realm/RealmDefaultModule.java");
+    private JavaFileObject allTypesDefaultMediator = JavaFileObjects.forResource("io/realm/RealmDefaultModuleMediator.java");
     private JavaFileObject booleansModel = JavaFileObjects.forResource("some/test/Booleans.java");
     private JavaFileObject booleansProxy = JavaFileObjects.forResource("io/realm/BooleansRealmProxy.java");
     private JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
     private JavaFileObject noAccessorsModel = JavaFileObjects.forResource("some/test/NoAccessors.java");
     private JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
     private JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
+    private JavaFileObject missingGenericTypeModel = JavaFileObjects.forResource("some/test/MissingGenericType.java");
 
     @Test
     public void compileSimpleFile() {
@@ -106,7 +112,71 @@ public void compareProcessedAllTypesFile() throws Exception {
                 .processedWith(new RealmProcessor())
                 .compilesWithoutError()
                 .and()
-                .generatesSources(allTypesProxy);
+                .generatesSources(allTypesProxy, allTypesDefaultMediator, allTypesDefaultModule, allTypesDefaultMediator);
+    }
+
+    @Test
+    public void compileAppModuleCustomClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleCustomClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileAppModuleAllClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleAllClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileLibraryModulesAllClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleAllClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileLibraryModulesCustomClasses() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleCustomClasses.java")))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileAppModuleMixedParametersFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleMixedParameters.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileAppModuleWrongTypeFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidAppModuleWrongType.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileLibraryModuleMixedParametersFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleMixedParameters.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileLibraryModuleWrongTypeFail() throws Exception {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleWrongType.java")))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
     }
 
     @Test
@@ -149,6 +219,14 @@ public void compileNoAccessorsFile() {
                 .failsToCompile();
     }
 
+    @Test
+    public void compileMissingGenericType() {
+        ASSERT.about(javaSource())
+                .that(missingGenericTypeModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
     @Test
     public void compileFieldNamesFiles() {
         ASSERT.about(javaSource())
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 2b4d80f86f..e67115e4c3 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -25,7 +26,8 @@
 import org.json.JSONObject;
 import some.test.AllTypes;
 
-public class AllTypesRealmProxy extends AllTypes {
+public class AllTypesRealmProxy extends AllTypes
+        implements RealmObjectProxy {
 
     private static long INDEX_COLUMNSTRING;
     private static long INDEX_COLUMNLONG;
@@ -164,13 +166,14 @@ public void setColumnRealmList(RealmList<AllTypes> value) {
         if (value == null) {
             return;
         }
+        links.clear();
         for (RealmObject linkedObject : (RealmList<? extends RealmObject>) value) {
             links.add(linkedObject.row.getIndex());
         }
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
-        if(!transaction.hasTable("class_AllTypes")) {
+        if (!transaction.hasTable("class_AllTypes")) {
             Table table = transaction.getTable("class_AllTypes");
             table.addColumn(ColumnType.STRING, "columnString");
             table.addColumn(ColumnType.INTEGER, "columnLong");
@@ -187,7 +190,7 @@ public static Table initTable(ImplicitTransaction transaction) {
                 AllTypesRealmProxy.initTable(transaction);
             }
             table.addColumnLink(ColumnType.LINK_LIST, "columnRealmList", transaction.getTable("class_AllTypes"));
-            table.setIndex(table.getColumnIndex("columnString"));
+            table.addSearchIndex(table.getColumnIndex("columnString"));
             table.setPrimaryKey("columnString");
             return table;
         }
@@ -195,104 +198,117 @@ public static Table initTable(ImplicitTransaction transaction) {
     }
 
     public static void validateTable(ImplicitTransaction transaction) {
-        if(transaction.hasTable("class_AllTypes")) {
+        if (transaction.hasTable("class_AllTypes")) {
             Table table = transaction.getTable("class_AllTypes");
-            if(table.getColumnCount() != 9) {
-                throw new IllegalStateException("Column count does not match");
+            if (table.getColumnCount() != 9) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 9 but was " + table.getColumnCount());
             }
             Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for(long i = 0; i < 9; i++) {
+            for (long i = 0; i < 9; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type AllTypes");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_COLUMNSTRING = table.getColumnIndex("columnString");
+            INDEX_COLUMNLONG = table.getColumnIndex("columnLong");
+            INDEX_COLUMNFLOAT = table.getColumnIndex("columnFloat");
+            INDEX_COLUMNDOUBLE = table.getColumnIndex("columnDouble");
+            INDEX_COLUMNBOOLEAN = table.getColumnIndex("columnBoolean");
+            INDEX_COLUMNDATE = table.getColumnIndex("columnDate");
+            INDEX_COLUMNBINARY = table.getColumnIndex("columnBinary");
+            INDEX_COLUMNOBJECT = table.getColumnIndex("columnObject");
+            INDEX_COLUMNREALMLIST = table.getColumnIndex("columnRealmList");
+
             if (!columnTypes.containsKey("columnString")) {
-                throw new IllegalStateException("Missing column 'columnString'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnString'");
             }
             if (columnTypes.get("columnString") != ColumnType.STRING) {
-                throw new IllegalStateException("Invalid type 'String' for column 'columnString'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString'");
             }
             if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
-                throw new IllegalStateException("Primary key not defined for field 'columnString'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString'");
             }
-            if (!table.hasIndex(table.getColumnIndex("columnString"))) {
-                throw new IllegalStateException("Index not defined for field 'columnString'");
+            if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Index not defined for field 'columnString'");
             }
             if (!columnTypes.containsKey("columnLong")) {
-                throw new IllegalStateException("Missing column 'columnLong'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnLong'");
             }
             if (columnTypes.get("columnLong") != ColumnType.INTEGER) {
-                throw new IllegalStateException("Invalid type 'long' for column 'columnLong'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong'");
             }
             if (!columnTypes.containsKey("columnFloat")) {
-                throw new IllegalStateException("Missing column 'columnFloat'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat'");
             }
             if (columnTypes.get("columnFloat") != ColumnType.FLOAT) {
-                throw new IllegalStateException("Invalid type 'float' for column 'columnFloat'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat'");
             }
             if (!columnTypes.containsKey("columnDouble")) {
-                throw new IllegalStateException("Missing column 'columnDouble'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble'");
             }
             if (columnTypes.get("columnDouble") != ColumnType.DOUBLE) {
-                throw new IllegalStateException("Invalid type 'double' for column 'columnDouble'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble'");
             }
             if (!columnTypes.containsKey("columnBoolean")) {
-                throw new IllegalStateException("Missing column 'columnBoolean'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean'");
             }
             if (columnTypes.get("columnBoolean") != ColumnType.BOOLEAN) {
-                throw new IllegalStateException("Invalid type 'boolean' for column 'columnBoolean'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean'");
             }
             if (!columnTypes.containsKey("columnDate")) {
-                throw new IllegalStateException("Missing column 'columnDate'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate'");
             }
             if (columnTypes.get("columnDate") != ColumnType.DATE) {
-                throw new IllegalStateException("Invalid type 'Date' for column 'columnDate'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate'");
             }
             if (!columnTypes.containsKey("columnBinary")) {
-                throw new IllegalStateException("Missing column 'columnBinary'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary'");
             }
             if (columnTypes.get("columnBinary") != ColumnType.BINARY) {
-                throw new IllegalStateException("Invalid type 'byte[]' for column 'columnBinary'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary'");
             }
             if (!columnTypes.containsKey("columnObject")) {
-                throw new IllegalStateException("Missing column 'columnObject'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject'");
             }
             if (columnTypes.get("columnObject") != ColumnType.LINK) {
-                throw new IllegalStateException("Invalid type 'AllTypes' for column 'columnObject'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
             }
             if (!transaction.hasTable("class_AllTypes")) {
-                throw new IllegalStateException("Missing table 'class_AllTypes' for column 'columnObject'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
             }
-            if(!columnTypes.containsKey("columnRealmList")) {
-                throw new IllegalStateException("Missing column 'columnRealmList'");
+            Table table_7 = transaction.getTable("class_AllTypes");
+            if (!table.getLinkTarget(INDEX_COLUMNOBJECT).hasSameSchema(table_7)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(INDEX_COLUMNOBJECT).getName() + "' expected - was '" + table_7.getName() + "'");
             }
-            if(columnTypes.get("columnRealmList") != ColumnType.LINK_LIST) {
-                throw new IllegalStateException("Invalid type 'AllTypes' for column 'columnRealmList'");
+            if (!columnTypes.containsKey("columnRealmList")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
+            }
+            if (columnTypes.get("columnRealmList") != ColumnType.LINK_LIST) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
             }
             if (!transaction.hasTable("class_AllTypes")) {
-                throw new IllegalStateException("Missing table 'class_AllTypes' for column 'columnRealmList'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
             }
-
-            columnIndices = new HashMap<String, Long>();
-            for (String fieldName : getFieldNames()) {
-                long index = table.getColumnIndex(fieldName);
-                if (index == -1) {
-                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type AllTypes");
-                }
-                columnIndices.put(fieldName, index);
+            Table table_8 = transaction.getTable("class_AllTypes");
+            if (!table.getLinkTarget(INDEX_COLUMNREALMLIST).hasSameSchema(table_8)) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(INDEX_COLUMNREALMLIST).getName() + "' expected - was '" + table_8.getName() + "'");
             }
-            INDEX_COLUMNSTRING = table.getColumnIndex("columnString");
-            INDEX_COLUMNLONG = table.getColumnIndex("columnLong");
-            INDEX_COLUMNFLOAT = table.getColumnIndex("columnFloat");
-            INDEX_COLUMNDOUBLE = table.getColumnIndex("columnDouble");
-            INDEX_COLUMNBOOLEAN = table.getColumnIndex("columnBoolean");
-            INDEX_COLUMNDATE = table.getColumnIndex("columnDate");
-            INDEX_COLUMNBINARY = table.getColumnIndex("columnBinary");
-            INDEX_COLUMNOBJECT = table.getColumnIndex("columnObject");
-            INDEX_COLUMNREALMLIST = table.getColumnIndex("columnRealmList");
         } else {
-            throw new RealmMigrationNeededException("The AllTypes class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The AllTypes class is missing from the schema for this Realm.");
         }
     }
 
+    public static String getTableName() {
+        return "class_AllTypes";
+    }
+
     public static List<String> getFieldNames() {
         return FIELD_NAMES;
     }
@@ -301,9 +317,24 @@ public static void validateTable(ImplicitTransaction transaction) {
         return columnIndices;
     }
 
-    public static void populateUsingJsonObject(AllTypes obj, JSONObject json)
+    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        AllTypes obj = null;
+        if (update) {
+            Table table = realm.getTable(AllTypes.class);
+            long pkColumnIndex = table.getPrimaryKey();
+            if (!json.isNull("columnString")) {
+                long rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
+                if (rowIndex != TableOrView.NO_MATCH) {
+                    obj = new AllTypesRealmProxy();
+                    obj.realm = realm;
+                    obj.row = table.getUncheckedRow(rowIndex);
+                }
+            }
+        }
+        if (obj == null) {
+            obj = realm.createObject(AllTypes.class);
+        }
         if (!json.isNull("columnString")) {
             obj.setColumnString((String) json.getString("columnString"));
         }
@@ -326,31 +357,28 @@ public static void populateUsingJsonObject(AllTypes obj, JSONObject json)
             } else {
                 obj.setColumnDate(new Date(json.getLong("columnDate")));
             }
-        } else {
-            obj.setColumnDate(new Date(0));
         }
-        obj.setColumnBinary(JsonUtils.stringToBytes(json.isNull("columnBinary") ? null : json.getString("columnBinary")));
+        if (!json.isNull("columnBinary")) {
+            obj.setColumnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
+        }
         if (!json.isNull("columnObject")) {
-            some.test.AllTypes columnObject = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-            AllTypesRealmProxy.populateUsingJsonObject(columnObject, json.getJSONObject("columnObject"));
-            obj.setColumnObject(columnObject);
+            some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
+            obj.setColumnObject(columnObjectObj);
         }
         if (!json.isNull("columnRealmList")) {
-            if (standalone) {
-                obj.setColumnRealmList(new RealmList<some.test.AllTypes>());
-            }
+            obj.getColumnRealmList().clear();
             JSONArray array = json.getJSONArray("columnRealmList");
             for (int i = 0; i < array.length(); i++) {
-                some.test.AllTypes item = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                AllTypesRealmProxy.populateUsingJsonObject(item, array.getJSONObject(i));
+                some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
                 obj.getColumnRealmList().add(item);
             }
         }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
+    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        AllTypes obj = realm.createObject(AllTypes.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -376,17 +404,12 @@ public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
             } else if (name.equals("columnBinary")  && reader.peek() != JsonToken.NULL) {
                 obj.setColumnBinary(JsonUtils.stringToBytes(reader.nextString()));
             } else if (name.equals("columnObject")  && reader.peek() != JsonToken.NULL) {
-                some.test.AllTypes columnObjectObj = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                AllTypesRealmProxy.populateUsingJsonStream(columnObjectObj, reader);
+                some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                 obj.setColumnObject(columnObjectObj);
             } else if (name.equals("columnRealmList")  && reader.peek() != JsonToken.NULL) {
                 reader.beginArray();
-                if (standalone) {
-                    obj.setColumnRealmList(new RealmList<some.test.AllTypes>());
-                }
                 while (reader.hasNext()) {
-                    some.test.AllTypes item = standalone ? new some.test.AllTypes() : obj.realm.createObject(some.test.AllTypes.class);
-                    AllTypesRealmProxy.populateUsingJsonStream(item, reader);
+                    some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
                     obj.getColumnRealmList().add(item);
                 }
                 reader.endArray();
@@ -395,10 +418,11 @@ public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
             }
         }
         reader.endObject();
+        return obj;
     }
 
-    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
-        if (object.realm != null && object.realm.getId() == realm.getId()) {
+    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
             return object;
         }
         AllTypes realmObject = null;
@@ -406,12 +430,15 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
         if (canUpdate) {
             Table table = realm.getTable(AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
+            if (object.getColumnString() == null) {
+                throw new IllegalArgumentException("Primary key value must not be null.");
+            }
             long rowIndex = table.findFirstString(pkColumnIndex, object.getColumnString());
             if (rowIndex != TableOrView.NO_MATCH) {
                 realmObject = new AllTypesRealmProxy();
                 realmObject.realm = realm;
-                realmObject.row = table.getRow(rowIndex);
-                cache.put(object, realmObject);
+                realmObject.row = table.getUncheckedRow(rowIndex);
+                cache.put(object, (RealmObjectProxy) realmObject);
             } else {
                 canUpdate = false;
             }
@@ -424,9 +451,9 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
         }
     }
 
-    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObject> cache) {
+    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
         AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
-        cache.put(newObject, realmObject);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
         realmObject.setColumnString(newObject.getColumnString() != null ? newObject.getColumnString() : "");
         realmObject.setColumnLong(newObject.getColumnLong());
         realmObject.setColumnFloat(newObject.getColumnFloat());
@@ -462,7 +489,7 @@ public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map
         return realmObject;
     }
 
-    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmObject, RealmObject> cache) {
+    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmObject, RealmObjectProxy> cache) {
         realmObject.setColumnLong(newObject.getColumnLong());
         realmObject.setColumnFloat(newObject.getColumnFloat());
         realmObject.setColumnDouble(newObject.getColumnDouble());
diff --git a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 207d0e81fa..bc386b5c37 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -25,11 +26,12 @@
 import org.json.JSONObject;
 import some.test.Booleans;
 
-public class BooleansRealmProxy extends Booleans {
+public class BooleansRealmProxy extends Booleans implements RealmObjectProxy {
 
     private static long INDEX_DONE;
     private static long INDEX_ISREADY;
     private static long INDEX_MCOMPLETED;
+    private static long INDEX_ANOTHERBOOLEAN;
     private static Map<String, Long> columnIndices;
     private static final List<String> FIELD_NAMES;
     static {
@@ -37,6 +39,7 @@
         fieldNames.add("done");
         fieldNames.add("isReady");
         fieldNames.add("mCompleted");
+        fieldNames.add("anotherBoolean");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
@@ -76,12 +79,25 @@ public void setmCompleted(boolean value) {
         row.setBoolean(INDEX_MCOMPLETED, (boolean) value);
     }
 
+    @Override
+    public boolean getAnotherBoolean() {
+        realm.checkIfValid();
+        return (boolean) row.getBoolean(INDEX_ANOTHERBOOLEAN);
+    }
+
+    @Override
+    public void setAnotherBoolean(boolean value) {
+        realm.checkIfValid();
+        row.setBoolean(INDEX_ANOTHERBOOLEAN, (boolean) value);
+    }
+
     public static Table initTable(ImplicitTransaction transaction) {
-        if(!transaction.hasTable("class_Booleans")) {
+        if (!transaction.hasTable("class_Booleans")) {
             Table table = transaction.getTable("class_Booleans");
             table.addColumn(ColumnType.BOOLEAN, "done");
             table.addColumn(ColumnType.BOOLEAN, "isReady");
             table.addColumn(ColumnType.BOOLEAN, "mCompleted");
+            table.addColumn(ColumnType.BOOLEAN, "anotherBoolean");
             table.setPrimaryKey("");
             return table;
         }
@@ -89,50 +105,64 @@ public static Table initTable(ImplicitTransaction transaction) {
     }
 
     public static void validateTable(ImplicitTransaction transaction) {
-        if(transaction.hasTable("class_Booleans")) {
+        if (transaction.hasTable("class_Booleans")) {
             Table table = transaction.getTable("class_Booleans");
-            if(table.getColumnCount() != 3) {
-                throw new IllegalStateException("Column count does not match");
+
+            if (table.getColumnCount() != 4) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 4 but was " + table.getColumnCount());
             }
+
             Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for(long i = 0; i < 3; i++) {
+            for (long i = 0; i < 4; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type Booleans");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_DONE = table.getColumnIndex("done");
+            INDEX_ISREADY = table.getColumnIndex("isReady");
+            INDEX_MCOMPLETED = table.getColumnIndex("mCompleted");
+            INDEX_ANOTHERBOOLEAN = table.getColumnIndex("anotherBoolean")
+
             if (!columnTypes.containsKey("done")) {
-                throw new IllegalStateException("Missing column 'done'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'done'");
             }
             if (columnTypes.get("done") != ColumnType.BOOLEAN) {
-                throw new IllegalStateException("Invalid type 'boolean' for column 'done'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done'");
             }
             if (!columnTypes.containsKey("isReady")) {
-                throw new IllegalStateException("Missing column 'isReady'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady'");
             }
             if (columnTypes.get("isReady") != ColumnType.BOOLEAN) {
-                throw new IllegalStateException("Invalid type 'boolean' for column 'isReady'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady'");
             }
             if (!columnTypes.containsKey("mCompleted")) {
-                throw new IllegalStateException("Missing column 'mCompleted'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted'");
             }
             if (columnTypes.get("mCompleted") != ColumnType.BOOLEAN) {
-                throw new IllegalStateException("Invalid type 'boolean' for column 'mCompleted'");
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted'");
             }
-
-            columnIndices = new HashMap<String, Long>();
-            for (String fieldName : getFieldNames()) {
-                long index = table.getColumnIndex(fieldName);
-                if (index == -1) {
-                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Booleans");
-                }
-                columnIndices.put(fieldName, index);
+            if (!columnTypes.containsKey("anotherBoolean")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean'");
+            }
+            if (columnTypes.get("anotherBoolean") != ColumnType.BOOLEAN) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean'");
             }
-            INDEX_DONE = table.getColumnIndex("done");
-            INDEX_ISREADY = table.getColumnIndex("isReady");
-            INDEX_MCOMPLETED = table.getColumnIndex("mCompleted");
         } else {
-            throw new RealmMigrationNeededException("The Booleans class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The Booleans class is missing from the schema for this Realm.");
         }
     }
 
+    public static String getTableName() {
+        return "class_Booleans";
+    }
+
     public static List<String> getFieldNames() {
         return FIELD_NAMES;
     }
@@ -141,9 +171,9 @@ public static void validateTable(ImplicitTransaction transaction) {
         return columnIndices;
     }
 
-    public static void populateUsingJsonObject(Booleans obj, JSONObject json)
+    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        Booleans obj = realm.createObject(Booleans.class);
         if (!json.isNull("done")) {
             obj.setDone((boolean) json.getBoolean("done"));
         }
@@ -153,11 +183,15 @@ public static void populateUsingJsonObject(Booleans obj, JSONObject json)
         if (!json.isNull("mCompleted")) {
             obj.setmCompleted((boolean) json.getBoolean("mCompleted"));
         }
+        if (!json.isNull("anotherBoolean")) {
+            obj.setAnotherBoolean((boolean) json.getBoolean("anotherBoolean"));
+        }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(Booleans obj, JsonReader reader)
+    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        Booleans obj = realm.createObject(Booleans.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -167,33 +201,38 @@ public static void populateUsingJsonStream(Booleans obj, JsonReader reader)
                 obj.setReady((boolean) reader.nextBoolean());
             } else if (name.equals("mCompleted")  && reader.peek() != JsonToken.NULL) {
                 obj.setmCompleted((boolean) reader.nextBoolean());
+            } else if (name.equals("anotherBoolean")  && reader.peek() != JsonToken.NULL) {
+                obj.setAnotherBoolean((boolean) reader.nextBoolean());
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
+        return obj;
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
-        if (object.realm != null && object.realm.getId() == realm.getId()) {
+    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
             return object;
         }
         return copy(realm, object, update, cache);
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObject> cache) {
+    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
         Booleans realmObject = realm.createObject(Booleans.class);
-        cache.put(newObject, realmObject);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
         realmObject.setDone(newObject.isDone());
         realmObject.setReady(newObject.isReady());
         realmObject.setmCompleted(newObject.ismCompleted());
+        realmObject.setAnotherBoolean(newObject.getAnotherBoolean());
         return realmObject;
     }
 
-    static Booleans update(Realm realm, Booleans realmObject, Booleans newObject, Map<RealmObject, RealmObject> cache) {
+    static Booleans update(Realm realm, Booleans realmObject, Booleans newObject, Map<RealmObject, RealmObjectProxy> cache) {
         realmObject.setDone(newObject.isDone());
         realmObject.setReady(newObject.isReady());
         realmObject.setmCompleted(newObject.ismCompleted());
+        realmObject.setAnotherBoolean(newObject.getAnotherBoolean());
         return realmObject;
     }
 
@@ -214,6 +253,10 @@ public String toString() {
         stringBuilder.append("{mCompleted:");
         stringBuilder.append(ismCompleted());
         stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{anotherBoolean:");
+        stringBuilder.append(getAnotherBoolean());
+        stringBuilder.append("}");
         stringBuilder.append("]");
         return stringBuilder.toString();
     }
diff --git a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java b/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
new file mode 100644
index 0000000000..3763538ddc
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModule.java
@@ -0,0 +1,7 @@
+package io.realm;
+
+
+@io.realm.annotations.RealmModule(allClasses = true)
+class DefaultRealmModule {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
new file mode 100644
index 0000000000..9ff6441073
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -0,0 +1,137 @@
+package io.realm;
+
+
+import android.util.JsonReader;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import org.json.JSONException;
+import org.json.JSONObject;
+import some.test.AllTypes;
+
+@io.realm.annotations.RealmModule
+class DefaultRealmModuleMediator extends RealmProxyMediator {
+
+    private static final List<Class<? extends RealmObject>> MODEL_CLASSES;
+    static {
+        List<Class<? extends RealmObject>> modelClasses = new ArrayList<Class<? extends RealmObject>>();
+        modelClasses.add(AllTypes.class);
+        MODEL_CLASSES = Collections.unmodifiableList(modelClasses);
+    }
+
+    @Override
+    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return AllTypesRealmProxy.initTable(transaction);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            AllTypesRealmProxy.validateTable(transaction);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return AllTypesRealmProxy.getFieldNames();
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public String getTableName(Class<? extends RealmObject> clazz) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return AllTypesRealmProxy.getTableName();
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return clazz.cast(new AllTypesRealmProxy());
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public List<Class<? extends RealmObject>> getModelClasses() {
+        return MODEL_CLASSES;
+    }
+
+    @Override
+    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return AllTypesRealmProxy.getColumnIndices();
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public <E extends RealmObject> E copyOrUpdate(Realm realm, E obj, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
+
+        if (clazz.equals(AllTypes.class)) {
+            return clazz.cast(AllTypesRealmProxy.copyOrUpdate(realm, (AllTypes) obj, update, cache));
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
+            throws JSONException {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return clazz.cast(AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader)
+            throws IOException {
+        checkClass(clazz);
+
+        if (clazz.equals(AllTypes.class)) {
+            return clazz.cast(AllTypesRealmProxy.createUsingJsonStream(realm, reader));
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+}
diff --git a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 3c675c2eec..4c54eb3c62 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -9,6 +9,7 @@
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -25,7 +26,8 @@
 import org.json.JSONObject;
 import some.test.Simple;
 
-public class SimpleRealmProxy extends Simple {
+public class SimpleRealmProxy extends Simple
+        implements RealmObjectProxy {
 
     private static long INDEX_NAME;
     private static long INDEX_AGE;
@@ -63,7 +65,7 @@ public void setAge(int value) {
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
-        if(!transaction.hasTable("class_Simple")) {
+        if (!transaction.hasTable("class_Simple")) {
             Table table = transaction.getTable("class_Simple");
             table.addColumn(ColumnType.STRING, "name");
             table.addColumn(ColumnType.INTEGER, "age");
@@ -74,43 +76,50 @@ public static Table initTable(ImplicitTransaction transaction) {
     }
 
     public static void validateTable(ImplicitTransaction transaction) {
-        if(transaction.hasTable("class_Simple")) {
+        if (transaction.hasTable("class_Simple")) {
             Table table = transaction.getTable("class_Simple");
-            if(table.getColumnCount() != 2) {
-                throw new IllegalStateException("Column count does not match");
+
+            if (table.getColumnCount() != 2) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 2 but was " + table.getColumnCount());
             }
+
             Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>();
-            for(long i = 0; i < 2; i++) {
+            for (long i = 0; i < 2; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
-            if (!columnTypes.containsKey("name")) {
-                throw new IllegalStateException("Missing column 'name'");
-            }
-            if (columnTypes.get("name") != ColumnType.STRING) {
-                throw new IllegalStateException("Invalid type 'String' for column 'name'");
-            }
-            if (!columnTypes.containsKey("age")) {
-                throw new IllegalStateException("Missing column 'age'");
-            }
-            if (columnTypes.get("age") != ColumnType.INTEGER) {
-                throw new IllegalStateException("Invalid type 'int' for column 'age'");
-            }
 
             columnIndices = new HashMap<String, Long>();
             for (String fieldName : getFieldNames()) {
                 long index = table.getColumnIndex(fieldName);
                 if (index == -1) {
-                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Simple");
+                    throw new RealmMigrationNeededException(transaction.getPath(), "Field '" + fieldName + "' not found for type Simple");
                 }
                 columnIndices.put(fieldName, index);
             }
             INDEX_NAME = table.getColumnIndex("name");
             INDEX_AGE = table.getColumnIndex("age");
+
+            if (!columnTypes.containsKey("name")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'name'");
+            }
+            if (columnTypes.get("name") != ColumnType.STRING) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name'");
+            }
+            if (!columnTypes.containsKey("age")) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age'");
+            }
+            if (columnTypes.get("age") != ColumnType.INTEGER) {
+                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age'");
+            }
         } else {
-            throw new RealmMigrationNeededException("The Simple class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The Simple class is missing from the schema for this Realm.");
         }
     }
 
+    public static String getTableName() {
+        return "class_Simple";
+    }
+
     public static List<String> getFieldNames() {
         return FIELD_NAMES;
     }
@@ -119,20 +128,21 @@ public static void validateTable(ImplicitTransaction transaction) {
         return columnIndices;
     }
 
-    public static void populateUsingJsonObject(Simple obj, JSONObject json)
+    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        boolean standalone = obj.realm == null;
+        Simple obj = realm.createObject(Simple.class);
         if (!json.isNull("name")) {
             obj.setName((String) json.getString("name"));
         }
         if (!json.isNull("age")) {
             obj.setAge((int) json.getInt("age"));
         }
+        return obj;
     }
 
-    public static void populateUsingJsonStream(Simple obj, JsonReader reader)
+    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        boolean standalone = obj.realm == null;
+        Simple obj = realm.createObject(Simple.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -145,24 +155,25 @@ public static void populateUsingJsonStream(Simple obj, JsonReader reader)
             }
         }
         reader.endObject();
+        return obj;
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
-        if (object.realm != null && object.realm.getId() == realm.getId()) {
+    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
+        if (object.realm != null && object.realm.getPath().equals(realm.getPath())) {
             return object;
         }
         return copy(realm, object, update, cache);
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObject> cache) {
+    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObjectProxy> cache) {
         Simple realmObject = realm.createObject(Simple.class);
-        cache.put(newObject, realmObject);
+        cache.put(newObject, (RealmObjectProxy) realmObject);
         realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
         realmObject.setAge(newObject.getAge());
         return realmObject;
     }
 
-    static Simple update(Realm realm, Simple realmObject, Simple newObject, Map<RealmObject, RealmObject> cache) {
+    static Simple update(Realm realm, Simple realmObject, Simple newObject, Map<RealmObject, RealmObjectProxy> cache) {
         realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
         realmObject.setAge(newObject.getAge());
         return realmObject;
diff --git a/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java b/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java
new file mode 100644
index 0000000000..3b19a4905a
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/AppModuleAllClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(allClasses = true)
+public class AppModuleAllClasses {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java b/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java
new file mode 100644
index 0000000000..ab933a0a23
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/AppModuleCustomClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = { AllTypes.class })
+public class AppModuleCustomClasses {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/Booleans.java b/realm-annotations-processor/src/test/resources/some/test/Booleans.java
index 562bd239e6..4db137c1dd 100644
--- a/realm-annotations-processor/src/test/resources/some/test/Booleans.java
+++ b/realm-annotations-processor/src/test/resources/some/test/Booleans.java
@@ -22,6 +22,7 @@
     private boolean done;
     private boolean isReady;
     private boolean mCompleted;
+    private boolean anotherBoolean;
 
     public boolean isDone() {
         return done;
@@ -46,4 +47,12 @@ public boolean ismCompleted() {
     public void setmCompleted(boolean mCompleted) {
         this.mCompleted = mCompleted;
     }
+
+    public boolean getAnotherBoolean() {
+        return anotherBoolean;
+    }
+
+    public void setAnotherBoolean(boolean anotherBoolean) {
+        this.anotherBoolean = anotherBoolean;
+    }
 }
diff --git a/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java b/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java
new file mode 100644
index 0000000000..af99786ac1
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleMixedParameters.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Setting both allClasses and classes is not allowed at the same time
+@RealmModule(allClasses = true, classes = { AllTypes.class })
+public class InvalidAllTypesModuleMixedParameters {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java b/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java
new file mode 100644
index 0000000000..f8ed03eac8
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/InvalidAppModuleWrongType.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Object is not a RealmObject which the Annotation Processor should be able to detect.
+@RealmModule(classes = { Object.class, AllTypes.class })
+public class InvalidAllTypesModuleWrongType {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java b/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java
new file mode 100644
index 0000000000..a3e66aec5d
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleMixedParameters.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Setting both allClasses and classes is not allowed at the same time
+@RealmModule(library = true, allClasses = true, classes = { AllTypes.class })
+public class InvalidLibraryModuleMixedParameters {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java b/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java
new file mode 100644
index 0000000000..727d0dbd84
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/InvalidLibraryModuleWrongType.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+// Object is not a RealmObject which the Annotation Processor should be able to detect.
+@RealmModule(library = true, classes = { Object.class, AllTypes.class })
+public class InvalidLibraryModuleWrongType {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java b/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java
new file mode 100644
index 0000000000..5ece7f99cc
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/LibraryModuleAllClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, allClasses = true)
+public class LibraryModuleAllClasses {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java b/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java
new file mode 100644
index 0000000000..5863353cd4
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/LibraryModuleCustomClasses.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmModule;
+
+@RealmModule(library = true, classes = { AllTypes.class })
+public class LibraryModuleCustomClasses {
+
+}
diff --git a/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java b/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java
new file mode 100644
index 0000000000..4636c06159
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/MissingGenericType.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmObject;
+import io.realm.RealmList;
+
+class MissingGenericType extends RealmObject {
+    private RealmList list; // this is an error!
+
+    public RealmList getList() {
+        return list;
+    }
+
+    public void setList(RealmList list) {
+        this.list = list;
+    }
+}
\ No newline at end of file
diff --git a/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java b/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
index 4b52b53766..6c703e830e 100644
--- a/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
+++ b/realm-annotations-processor/src/test/resources/some/test/NoAccessors.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package io.realm.entities;
 
 import java.util.Date;
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 283ea3e6ba..2076503aa4 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -1,6 +1,6 @@
 apply plugin: 'java'
 
-version = new File("${projectDir}/../version.txt").text
+version = new File("${projectDir}/../version.txt").text.trim()
 sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index 4fe133742e..3462ee85eb 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
index 518b9a0975..784f6c7676 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
@@ -16,6 +16,13 @@
 
 package io.realm.annotations;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.FIELD)
 public @interface Ignore {
 
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Index.java b/realm-annotations/src/main/java/io/realm/annotations/Index.java
index be50d1c6bc..6776d9d707 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Index.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Index.java
@@ -16,12 +16,19 @@
 
 package io.realm.annotations;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
 /**
  * This annotation will add a search index to the field. A search index will make the
  * Realm file larger and inserts slower but queries will be faster. 
  *
  * NOTICE: only String fields can be indexed.
  */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.FIELD)
 public @interface Index {
 
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index 708b039f9e..a547f1ab83 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -31,7 +31,7 @@
  * Only one field pr. model class can have this annotation and it is only allowed on the following
  * types: String, short, int, long
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.CLASS)
 @Target(ElementType.FIELD)
 public @interface PrimaryKey {
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
new file mode 100644
index 0000000000..5d0b9da04a
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * By default a Realm can stores all classes extending RealmObject in a project. However, if you want to restrict a
+ * Realm to only contain a subset of classes or want to share them between a library project and an app project you must
+ * use a RealmModule.
+ * <p>
+ * A RealmModule is a collection of classes extending RealmObject that can be combined with other RealmModules to create
+ * the schema for a Realm. This makes it easier to control versioning and migration of those Realms.
+ * <p>
+ * A RealmModule can either be a library module or an app module. The distinction is made by setting
+ * {@code library = true}. Setting {@code library = true} is normally only relevant for library authors. See below for
+ * futher details.
+ *
+ *
+ * <h2>RealmModules and libraries</h2>
+ *
+ * Realms default behavior is to automatically create a RealmModule called {@code DefaultRealmModule} which contains all
+ * classes extending RealmObject in a project. This module is automatically known by Realm.
+ * <p>
+ * This behavior is problematic when combining a library project and an app project that both uses Realm. This is
+ * because the {@code DefaultRealmModule} will be created for both the library project and the app project, which will
+ * cause the project to fail with duplicate class definition errors.
+ * <p>
+ * Library authors are responsible for avoiding this conflict by using explicit modules where {@code library = true} is
+ * set. This disables the generation of the DefaultRealmModule for the library project and allows the library to be
+ * included in the app project that also uses Realm. This means that library projects that uses Realm internally are
+ * required to specify a specific module using {@code RealmConfiguration.setModules()}.
+ * <p>
+ * App developers are not required to specify any modules, as they implicitely use the {@code DefaultRealmModule}, but
+ * they now has the option of adding the library project classes to their schema using
+ * {@code RealmConfiguration.addModule()}.
+ *
+ * @see <a href="https://github.com/realm/realm-java/tree/master/examples/realmModuleAppExample">Example of a project using modules</a>
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Inherited
+public @interface RealmModule {
+
+    /**
+     * Setting this to true will mark this module as a library module. This will prevent Realm from generating the
+     * {@code DefaultRealmModule} containing all classes. This is required by libraries so they do notintefer with
+     * Realms running in app code, but it also means that all libraries using Realm must explicitly use a module and
+     * cannot  rely on the default module being present.
+     *
+     * Creating library modules and normal modules in the same project is not allowed and will result in the annotation
+     * processor throwing an exception.
+     */
+    boolean library() default false;
+
+    /**
+     * Instead of adding all Realm classes manually to a module, set this boolean to true to automatically include all
+     * Realm classes in this project. This does not include classes from other libraries which must be exposed using
+     * their own module.
+     *
+     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
+     * an exception.
+     */
+    boolean allClasses() default false;
+
+    /**
+     * Specifies the classes extending RealmObject that should be part of this module. Only classes in this project can
+     * be included. Classes from other libraries must be exposed using their own module.
+     *
+     * Setting both {@code allClasses = true} and {@code classes()} will result in the annotation processor throwing
+     * an exception.
+     */
+    Class<?>[] classes() default {};
+}
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index 66aaa91caf..2f764dd7ed 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -1,4 +1,4 @@
-ext.coreVersion = '0.89.0'
+ext.coreVersion = '0.89.5'
 ext.clang = false // gcc is default for the NDK. It also produces smaller binaries
 
 def commonCflags = [ '-std=c++11', '-ffunction-sections', '-fdata-sections', '-flto' ]
diff --git a/realm-jni/gradle/wrapper/gradle-wrapper.properties b/realm-jni/gradle/wrapper/gradle-wrapper.properties
index fb7aebcbf7..35b8fa2d3c 100644
--- a/realm-jni/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-jni/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.4-all.zip
diff --git a/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm-jni/src/io_realm_internal_CheckedRow.cpp
new file mode 100644
index 0000000000..4374a1d835
--- /dev/null
+++ b/realm-jni/src/io_realm_internal_CheckedRow.cpp
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_CheckedRow.h"
+#include "io_realm_internal_UncheckedRow.h"
+
+#include "util.hpp"
+#include "mixedutil.hpp"
+#include "tablebase_tpl.hpp"
+
+using namespace realm;
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr)
+{
+    if (!ROW(nativeRowPtr)->is_attached())
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnCount(env, obj, nativeRowPtr);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+        return NULL;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnName(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jstring columnName)
+{
+    if (!ROW(nativeRowPtr)->is_attached())
+        return 0;
+
+    jlong ndx = Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex(env, obj, nativeRowPtr, columnName);
+    if (ndx == to_jlong_or_not_found(realm::not_found)) {
+        JStringAccessor column_name(env, columnName);
+        ThrowException(env, IllegalArgument, concat_stringdata("Field not found: ", column_name));
+        return 0;
+    }
+    else {
+        return ndx;
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetColumnType(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLong(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetBoolean(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetFloat(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetDouble(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetDateTime(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetString(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetMixedType(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return NULL;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetMixed(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLink(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
+        return 0;
+
+    return Java_io_realm_internal_UncheckedRow_nativeGetLinkView(env, obj, nativeRowPtr, columnIndex);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetLong(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jboolean value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetBoolean(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jfloat value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetFloat(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jdouble value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetDouble(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetDate(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jstring value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
+        return;
+
+    Java_io_realm_internal_CheckedRow_nativeSetString(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetByteArray(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetMixed(env, obj, nativeRowPtr, columnIndex, jMixedValue);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeSetLink(env, obj, nativeRowPtr, columnIndex, value);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
+  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+{
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
+        return;
+
+    Java_io_realm_internal_UncheckedRow_nativeNullifyLink(env, obj, nativeRowPtr, columnIndex);
+}
\ No newline at end of file
diff --git a/realm-jni/src/io_realm_internal_CheckedRow.h b/realm-jni/src/io_realm_internal_CheckedRow.h
new file mode 100644
index 0000000000..4a4f874ed0
--- /dev/null
+++ b/realm-jni/src/io_realm_internal_CheckedRow.h
@@ -0,0 +1,237 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class io_realm_internal_CheckedRow */
+
+#ifndef _Included_io_realm_internal_CheckedRow
+#define _Included_io_realm_internal_CheckedRow
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnCount
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnName
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnIndex
+ * Signature: (JLjava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetColumnType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLong
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetBoolean
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetFloat
+ * Signature: (JJ)F
+ */
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetDouble
+ * Signature: (JJ)D
+ */
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetDateTime
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetString
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetByteArray
+ * Signature: (JJ)[B
+ */
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetMixedType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetMixed
+ * Signature: (JJ)Lio/realm/internal/Mixed;
+ */
+JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLink
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeIsNullLink
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeGetLinkView
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetLong
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetBoolean
+ * Signature: (JJZ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
+  (JNIEnv *, jobject, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetFloat
+ * Signature: (JJF)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
+  (JNIEnv *, jobject, jlong, jlong, jfloat);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetDouble
+ * Signature: (JJD)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
+  (JNIEnv *, jobject, jlong, jlong, jdouble);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetDate
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetString
+ * Signature: (JJLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
+  (JNIEnv *, jobject, jlong, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetByteArray
+ * Signature: (JJ[B)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
+  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetMixed
+ * Signature: (JJLio/realm/internal/Mixed;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
+  (JNIEnv *, jobject, jlong, jlong, jobject);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeSetLink
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeNullifyLink
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeClose
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeClose
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     io_realm_internal_CheckedRow
+ * Method:    nativeIsAttached
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsAttached
+  (JNIEnv *, jobject, jlong);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/realm-jni/src/io_realm_internal_Group.h b/realm-jni/src/io_realm_internal_Group.h
index 46ee4e75fb..5e95a00a07 100644
--- a/realm-jni/src/io_realm_internal_Group.h
+++ b/realm-jni/src/io_realm_internal_Group.h
@@ -127,14 +127,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeEquals
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeEquals
-  (JNIEnv *, jobject, jlong, jlong);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_Row.h b/realm-jni/src/io_realm_internal_Row.h
deleted file mode 100644
index 1e4db7d73d..0000000000
--- a/realm-jni/src/io_realm_internal_Row.h
+++ /dev/null
@@ -1,245 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Row */
-
-#ifndef _Included_io_realm_internal_Row
-#define _Included_io_realm_internal_Row
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetIndex
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetDateTime
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetDate
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Row
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm-jni/src/io_realm_internal_SharedGroup.cpp
index 7013c5e571..97734cb3f5 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -268,3 +268,15 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultRep
     return 0;
 #endif
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
+    JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        return SG(native_ptr)->compact(); // throws
+    }
+    CATCH_FILE()
+    CATCH_STD()
+    return false;
+}
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.h b/realm-jni/src/io_realm_internal_SharedGroup.h
index 8c4ebcd3b6..d92f6bb9cd 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -69,7 +69,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
  * Signature: ()Ljava/lang/String;
  */
 JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName
-  (JNIEnv *, jclass);
+  (JNIEnv *, jobject);
 
 /*
  * Class:     io_realm_internal_SharedGroup
@@ -135,6 +135,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate
   (JNIEnv *, jobject, jstring, jint, jboolean, jboolean, jbyteArray);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeCompact
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
+  (JNIEnv *, jobject, jlong);
+
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeClose
diff --git a/realm-jni/src/io_realm_internal_Table.h b/realm-jni/src/io_realm_internal_Table.h
index c5212e7ba7..53c1e873d9 100644
--- a/realm-jni/src/io_realm_internal_Table.h
+++ b/realm-jni/src/io_realm_internal_Table.h
@@ -41,14 +41,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeEquals
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeIsRootTable
@@ -507,18 +499,34 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeSetIndex
+ * Method:    nativeMigratePrimaryKeyTableIfNeeded
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeAddSearchIndex
  * Signature: (JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetIndex
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeHasIndex
+ * Method:    nativeRemoveSearchIndex
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeHasSearchIndex
  * Signature: (JJ)Z
  */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasIndex
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -857,6 +865,14 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeHasSameSchema
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
+  (JNIEnv *, jobject, jlong, jlong);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index ca9e0384db..bb26d54e11 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -22,10 +22,12 @@ using namespace realm;
 
 #if 1
 #define COL_TYPE_VALID(env,ptr,col, type)           TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)
+#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
 #define QUERY_VALID(env, pQuery)                    query_valid(env, pQuery)
 #else
 #define COL_TYPE_VALID(env,ptr,col, type)           (true)
+#define COL_TYPE_LINK_OR_LINKLIST(env,ptr,col)      (true)
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
 #define QUERY_VALID(env, pQuery)                    (true)
 #endif
@@ -1157,3 +1159,18 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
     } CATCH_STD()
     return 0;
 }
+
+// isNull and isNotNull
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
+    JNIEnv *env, jobject, jlong nativeQueryPtr, jlong columnIndex)
+{
+    Query* pQuery = Q(nativeQueryPtr);
+    try {
+        Table* pTable = pQuery->get_table().get();
+        if (!COL_TYPE_LINK_OR_LINKLIST(env, pTable, columnIndex))
+            return;
+        Query query = pTable->column<Link>(S(columnIndex)).is_null();
+        pQuery->and_query(query);
+    } CATCH_STD()
+}
diff --git a/realm-jni/src/io_realm_internal_TableQuery.h b/realm-jni/src/io_realm_internal_TableQuery.h
index 2c3e708b7e..5ccb9eeb7e 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm-jni/src/io_realm_internal_TableQuery.h
@@ -479,6 +479,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeIsNull
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeCount
diff --git a/realm-jni/src/io_realm_internal_Row.cpp b/realm-jni/src/io_realm_internal_UncheckedRow.cpp
similarity index 56%
rename from realm-jni/src/io_realm_internal_Row.cpp
rename to realm-jni/src/io_realm_internal_UncheckedRow.cpp
index 44140a7886..a8be51a9aa 100644
--- a/realm-jni/src/io_realm_internal_Row.cpp
+++ b/realm-jni/src/io_realm_internal_UncheckedRow.cpp
@@ -14,14 +14,14 @@
  * limitations under the License.
  */
 
-#include "io_realm_internal_Row.h"
+#include "io_realm_internal_UncheckedRow.h"
 #include "util.hpp"
 #include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
 
 using namespace realm;
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
   (JNIEnv *, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -30,19 +30,17 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
     return ROW(nativeRowPtr)->get_column_count(); // noexcept
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetColumnName
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
-        return NULL;
     try {
         return to_jstring(env, ROW(nativeRowPtr)->get_column_name( S(columnIndex)));
     } CATCH_STD();
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr, jstring columnName)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -55,17 +53,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnIndex
     return 0;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetColumnType
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_VALID(env, ROW(nativeRowPtr), columnIndex))
-        return 0;
-
     return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -75,57 +70,42 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetIndex
     return ROW(nativeRowPtr)->get_index();
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLong
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
-        return 0;
-
     return ROW(nativeRowPtr)->get_int( S(columnIndex) );
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeGetBoolean
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
-        return 0;
-
     return ROW(nativeRowPtr)->get_bool( S(columnIndex) );
 }
 
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Row_nativeGetFloat
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
-        return 0;
-
     return ROW(nativeRowPtr)->get_float( S(columnIndex) );
 }
 
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Row_nativeGetDouble
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
-        return 0;
-
     return ROW(nativeRowPtr)->get_double( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetDateTime
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
-        return 0;
-
     return ROW(nativeRowPtr)->get_datetime( S(columnIndex) ).get_datetime();
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -138,13 +118,10 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Row_nativeGetString
     return NULL;
 }
 
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
-        return 0;
-
     BinaryData bin = ROW(nativeRowPtr)->get_binary( S(columnIndex) );
     if (bin.size() <= MAX_JSIZE) {
         jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
@@ -158,24 +135,18 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Row_nativeGetByteArray
     }
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Row_nativeGetMixedType
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return 0;
-
     DataType mixedType = ROW(nativeRowPtr)->get_mixed_type( S(columnIndex) );  // noexcept
     return static_cast<jint>(mixedType);
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
+JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return NULL;
-
     Mixed value = ROW(nativeRowPtr)->get_mixed( S(columnIndex) );  // noexcept
     try {
         return CreateJMixedFromMixed(env, value);
@@ -183,119 +154,90 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Row_nativeGetMixed
     return NULL;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
-        return 0;
-    if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) )) {
+    if (ROW(nativeRowPtr)->is_null_link( S(columnIndex) ))
         return jlong(-1);
-    }
+
     return ROW(nativeRowPtr)->get_link( S(columnIndex) );
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsNullLink
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
-        return 0;
-
     return ROW(nativeRowPtr)->is_null_link( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetLinkView
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
+  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
-        return 0;
-
     LinkView* link_view_ptr = LangBindHelper::get_linklist_ptr( *ROW( nativeRowPtr ), S( columnIndex) );
     return reinterpret_cast<jlong>(link_view_ptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLong
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Int))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_int( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetBoolean
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Bool))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_bool( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetFloat
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Float))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_float( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDouble
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Double))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_double( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if(!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_datetime( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetString
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_String))
-        return;
-
     try {
         JStringAccessor value2(env, value); // throws
         ROW(nativeRowPtr)->set_string( S(columnIndex), value2);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Binary))
-        return;
-
     jbyte* bytePtr = env->GetByteArrayElements(value, NULL);
     if (!bytePtr) {
         ThrowException(env, IllegalArgument, "doByteArray");
@@ -306,52 +248,43 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetByteArray
     env->ReleaseByteArrayElements(value, bytePtr, 0);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetMixed
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return;
     try {
         row_nativeSetMixed(ROW(nativeRowPtr), env, columnIndex, jMixedValue);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeSetLink
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
-        return;
-
     try {
         ROW(nativeRowPtr)->set_link( S(columnIndex), value);
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeNullifyLink
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Link))
-        return;
-
     try {
         ROW(nativeRowPtr)->nullify_link( S(columnIndex) );
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Row_nativeClose
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
   (JNIEnv *, jclass, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     delete ROW(nativeRowPtr);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Row_nativeIsAttached
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
   (JNIEnv *, jobject, jlong nativeRowPtr)
 {
     TR_ENTER_PTR(nativeRowPtr)
     return ROW(nativeRowPtr)->is_attached();
 }
-
diff --git a/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm-jni/src/io_realm_internal_UncheckedRow.h
new file mode 100644
index 0000000000..236fae2341
--- /dev/null
+++ b/realm-jni/src/io_realm_internal_UncheckedRow.h
@@ -0,0 +1,245 @@
+/* DO NOT EDIT THIS FILE - it is machine generated */
+#include <jni.h>
+/* Header for class io_realm_internal_UncheckedRow */
+
+#ifndef _Included_io_realm_internal_UncheckedRow
+#define _Included_io_realm_internal_UncheckedRow
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnCount
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnName
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnIndex
+ * Signature: (JLjava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetColumnType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetIndex
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLong
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetBoolean
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetFloat
+ * Signature: (JJ)F
+ */
+JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetDouble
+ * Signature: (JJ)D
+ */
+JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetDateTime
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetString
+ * Signature: (JJ)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetByteArray
+ * Signature: (JJ)[B
+ */
+JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetMixedType
+ * Signature: (JJ)I
+ */
+JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetMixed
+ * Signature: (JJ)Lio/realm/internal/Mixed;
+ */
+JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLink
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeIsNullLink
+ * Signature: (JJ)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeGetLinkView
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetLong
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetBoolean
+ * Signature: (JJZ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
+  (JNIEnv *, jobject, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetFloat
+ * Signature: (JJF)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
+  (JNIEnv *, jobject, jlong, jlong, jfloat);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetDouble
+ * Signature: (JJD)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
+  (JNIEnv *, jobject, jlong, jlong, jdouble);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetDate
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetString
+ * Signature: (JJLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
+  (JNIEnv *, jobject, jlong, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetByteArray
+ * Signature: (JJ[B)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
+  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetMixed
+ * Signature: (JJLio/realm/internal/Mixed;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
+  (JNIEnv *, jobject, jlong, jlong, jobject);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeSetLink
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeNullifyLink
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeClose
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
+  (JNIEnv *, jclass, jlong);
+
+/*
+ * Class:     io_realm_internal_UncheckedRow
+ * Method:    nativeIsAttached
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
+  (JNIEnv *, jobject, jlong);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/realm-jni/src/io_realm_internal_table.cpp b/realm-jni/src/io_realm_internal_table.cpp
index ee3b28bfdb..688b8a9058 100644
--- a/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm-jni/src/io_realm_internal_table.cpp
@@ -725,7 +725,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
 
 //--------------------- Indexing methods:
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetIndex(
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
@@ -740,7 +740,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetIndex(
     } CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasIndex(
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex(
+    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+{
+    Table* pTable = TBL(nativeTablePtr);
+    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
+        return;
+    if (pTable->get_column_type (S(columnIndex)) != type_String) {
+        ThrowException(env, IllegalArgument, "Invalid columntype - only string columns are supported at the moment.");
+        return;
+    }
+    try {
+        pTable->remove_search_index( S(columnIndex));
+    } CATCH_STD()
+}
+
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
     if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
@@ -1389,9 +1405,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, j
 
 // Checks if the primary key column contains any duplicate values, making it ineligible as a
 // primary key.
-bool check_valid_primary_key_column(JNIEnv* env, Table* table, size_t column_index) // throws
+bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
 {
-    int column_type = table->get_column_type(column_index);
+    size_t column_index = table->get_column_index(column_name);
+    if (column_index == realm::not_found) {
+        std::ostringstream error_msg;
+        error_msg << table->get_name() << " does not contain the field \"" << column_name << "\"";
+        ThrowException(env, IllegalArgument, error_msg.str());
+    }
+    DataType column_type = table->get_column_type(column_index);
     TableView results = table->get_sorted_view(column_index);
 
     switch(column_type) {
@@ -1448,33 +1470,32 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
         const char* table_name = table->get_name().data();
         size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
-        // I
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
-            // No primary key set. Remove any previous set keys
+            // No primary key provided => remove previous set keys
             if (row_index != realm::not_found) {
                 pk_table->remove(row_index);
             }
             return jlong(io_realm_internal_Table_NO_PRIMARY_KEY);
         }
         else {
-            JStringAccessor columnName2(env, columnName);
-            size_t primary_key_column_index = table->get_column_index(columnName2);
+            JStringAccessor new_primary_key_column_name(env, columnName);
+            size_t primary_key_column_index = table->get_column_index(new_primary_key_column_name);
             if (row_index == realm::not_found) {
                 // No primary key is currently set
-                if (check_valid_primary_key_column(env, table, primary_key_column_index)) {
+                if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
                     row_index = pk_table->add_empty_row();
                     pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index, table_name);
-                    pk_table->set_int(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, primary_key_column_index);
+                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
                 }
             }
             else {
                 // Primary key already exists
                 // We only wish to check for duplicate values if a column isn't already a primary key
                 Row* row = new Row((*pk_table)[row_index]);
-                size_t current_primary_key = row->get_int(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX);
-                if (primary_key_column_index != current_primary_key) {
-                    if (check_valid_primary_key_column(env, table, primary_key_column_index)) {
-                        pk_table->set_int(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, primary_key_column_index);
+                StringData current_primary_key = row->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                if (new_primary_key_column_name != current_primary_key) {
+                    if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
+                        pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index, new_primary_key_column_name);
                     }
                 }
             }
@@ -1484,3 +1505,40 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     } CATCH_STD()
     return 0;
 }
+
+// Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
+// This affects:
+// - All Realms created by Cocoa and used by Realm-android up to 0.80.1
+// - All Realms created by Realm-Android 0.80.1 and below
+// See https://github.com/realm/realm-java/issues/1059
+// This methods converts the old (wrong) table format (string, integer) to the right (string,string) format.
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
+    (JNIEnv*, jobject, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+{
+    Group* group = G(groupNativePtr);
+    Table* pk_table = TBL(privateKeyTableNativePtr);
+    if (pk_table->get_column_type(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX) == type_Int) {
+        StringData tmp_col_name = StringData("tmp_field_name");
+        size_t tmp_col_ndx = pk_table->add_column(DataType(type_String), tmp_col_name);
+
+        // Create tmp string column with field name instead of column index
+        size_t number_of_rows = pk_table->size();
+        for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+            StringData table_name = pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_ndx);
+            size_t col_ndx = static_cast<size_t>(pk_table->get_int(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_ndx));
+            StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
+            pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
+        }
+
+        // Delete old int column, and rename tmp column to same name
+        // The column index for the renamed column will then be the same as the deleted old column
+        pk_table->remove_column(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX);
+        pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
+    }
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
+  (JNIEnv *, jobject, jlong thisTablePtr, jlong otherTablePtr)
+{
+    return *TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor();
+}
diff --git a/realm-jni/src/tablequery.hpp b/realm-jni/src/tablequery.hpp
index 0c79b7d3d1..80279bbbf9 100644
--- a/realm-jni/src/tablequery.hpp
+++ b/realm-jni/src/tablequery.hpp
@@ -23,9 +23,9 @@
 
 class TableQuery : public realm::Query {
     // 'subtables' is used to figure out which subtable the query
-    // is currectly working on, so that we can lookup the correct
+    // is currently working on, so that we can lookup the correct
     // table and verify the parameters related to that table.
-    std::vector<size_t> subtables;  // holds subtable column indeces 
+    std::vector<size_t> subtables;  // holds subtable column indices
 
 public:
     TableQuery(const Query& copy) : realm::Query(copy, realm::Query::TCopyExpressionTag{}) {};
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index aec219593d..5589ecb50c 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -58,7 +58,7 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 
 #define CATCH_FILE(fileName) \
     catch (InvalidDatabase&) { \
-        ThrowException(env, IllegalArgument, "Invalid Group file format."); \
+        ThrowException(env, IllegalArgument, "Invalid format of Realm file."); \
     } \
     catch (util::File::PermissionDenied& e) { \
         ThrowException(env, IOFailed, string(fileName), string("Permission denied. ") + e.what()); \
@@ -173,6 +173,7 @@ extern const char *log_tag;
 #define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    TblColIndexValid(env, ptr, col)
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              ColIndexAndTypeValid(env, ptr, col, type)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     TblColIndexAndTypeValid(env, ptr, col, type)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     TblColIndexAndLinkOrLinkList(env, ptr, col)
 #define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
@@ -189,13 +190,14 @@ extern const char *log_tag;
 
 #define ROW_INDEXES_VALID(env,ptr,start,end, range)             (true)
 #define ROW_INDEX_VALID(env,ptr,row)                            (true)
-#defibe ROW_INDEX_VALID_OFFSET(env,ptr,row)                     (true)
+#define ROW_INDEX_VALID_OFFSET(env,ptr,row)                     (true)
 #define TBL_AND_ROW_INDEX_VALID(env,ptr,row)                    (true)
 #define TBL_AND_ROW_INDEX_VALID_OFFSET(env,ptr,row, offset)     (true)
 #define COL_INDEX_VALID(env,ptr,col)                            (true)
 #define TBL_AND_COL_INDEX_VALID(env,ptr,col)                    (true)
 #define COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)              (true)
 #define TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
+#define TBL_AND_COL_INDEX_AND_LINK_OR_LINKLIST(env,ptr,col)     (true)
 #define INDEX_VALID(env,ptr,col,row)                            (true)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    (true)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
@@ -390,6 +392,20 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex,
     return true;
 }
 
+template <class T>
+inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
+{
+    size_t col = static_cast<size_t>(columnIndex);
+    int colType = pTable->get_column_type(col);
+    if (colType == type_Link || colType == type_LinkList) {
+        return true;
+    }
+
+    TR_ERR("Expected columnType %d or %d, but got %d", type_Link, type_LinkList, colType)
+    ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
+    return false;
+}
+
 template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
@@ -403,13 +419,18 @@ inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, i
         && ColIndexAndTypeValid(env, pTable, columnIndex, expectColType);
 }
 
+template <class T>
+inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnIndex) {
+    return TableIsValid(env, pTable)
+        && TypeIsLinkLike(env, pTable, columnIndex);
+}
+
 inline bool RowColIndexAndTypeValid(JNIEnv* env, Row* pRow, jlong columnIndex, int expectColType)
 {
     return RowIsValid(env, pRow)
         && ColIndexAndTypeValid(env, pRow->get_table(), columnIndex, expectColType);
 }
 
-
 template <class T>
 inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
 {
@@ -419,11 +440,9 @@ inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong r
 template <class T>
 inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
 {
-    return TableIsValid(env, pTable)
-        && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
 }
 
-
 template <class T>
 inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
diff --git a/realm/build.gradle b/realm/build.gradle
index 197ae8ac85..1e4998e2ac 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -44,7 +44,7 @@ android.libraryVariants.all { variant ->
         group 'Docs'
         source = variant.javaCompile.source
         source "../realm-annotations/src/main/java"
-        ext.androidJar = files(plugins.findPlugin("com.android.library").getBootClasspath())
+        ext.androidJar = files(project.android.getBootClasspath())
         classpath = files(variant.javaCompile.classpath.files) + ext.androidJar
         exclude '**/internal/**'
         exclude '**/BuildConfig.java'
@@ -160,14 +160,20 @@ project.afterEvaluate {
     preBuild.dependsOn(['compileJni', 'compileAnnotations', 'buildApt'])
 }
 
+// exampleDir : [distributionDir, [ exampleSrcParentDir, distibutionSrcParentDir], ...]
+// exampleDir -> Name of example dir
+// distributionDir -> Name of distribution dir
+// [ exampleModuleDir, distModuleDir ] -> where to find module dir to copy. Add one for each submodule.
+// First sub module must be the app module
 def examples = [
-    introExample: "RealmIntroExample",
-    gridViewExample: "RealmGridViewExample",
-    migrationExample: "RealmMigrationExample",
-    adapterExample: "RealmAdapterExample",
-    threadExample: "RealmThreadExample",
-    jsonExample: "RealmJsonExample",
-    encryptionExample: "RealmEncryptionExample"
+    introExample: ["RealmIntroExample", ["" : "app"]],
+    gridViewExample: ["RealmGridViewExample", ["" : "app"]],
+    migrationExample: ["RealmMigrationExample", ["" : "app"]],
+    adapterExample: ["RealmAdapterExample", ["" : "app"]],
+    threadExample: ["RealmThreadExample", ["" : "app"]],
+    jsonExample: ["RealmJsonExample", ["" : "app"]],
+    encryptionExample: ["RealmEncryptionExample", ["" : "app"]],
+    realmModuleExample: ["RealmModuleExample", [ app : "app"], [ library : "library"]]
 ]
 
 def abi = [ 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86' ]
@@ -175,12 +181,27 @@ def abi = [ 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86' ]
 //for Ant filter
 import org.apache.tools.ant.filters.ReplaceTokens
 
+def private copyGradleBuildFile(String fromDir, String toDir) {
+    println "copy ${fromDir}"
+    println "to ${toDir}"
+    copy {
+        from "${fromDir}/build.gradle"
+        into "${toDir}"
+        filter(ReplaceTokens, tokens: [version: version])
+    }
+}
+
+// Copy build.gradle (if present) from all configured folders
 task generateDistributionExamplesBuildFiles << {
-    examples.each() { src, dest ->
-        copy {
-            from "${rootDir}/tools/templates/${dest}/build.gradle"
-            into "${rootDir}/distribution/${dest}/app"
-            filter(ReplaceTokens, tokens: [version: version])
+    examples.each() { exampleDir, params ->
+        String distDir = params[0];
+        String baseFromDir = "${rootDir}/tools/templates/${distDir}"
+        String baseToDir = "${rootDir}/distribution/${distDir}"
+        copyGradleBuildFile(baseFromDir, baseToDir)
+        for (int i = 1; i < params.size(); i++) {
+            params[i].each() { moduleFolder, destFolder ->
+                copyGradleBuildFile("${baseFromDir}/${destFolder}", "${baseToDir}/${destFolder}")
+            }
         }
     }
 }
@@ -196,10 +217,16 @@ task populateDistributionFolder(dependsOn: ['androidJar', 'bundleJavadocRelease'
         from 'build/docs/javadoc'
         into '../distribution/javadoc'
     }
-    examples.each() { src, dest ->
-        copy {
-            from "../examples/${src}/src"
-            into "../distribution/${dest}/app/src"
+    examples.each() { exampleDir, params ->
+        String distributionDir = params[0];
+        for (int i = 1; i < params.size(); i++) {
+            params[i].each() { moduleFolder, destFolder ->
+                String src = moduleFolder.isEmpty() ? "src" : moduleFolder + "/src"
+                copy {
+                    from "../examples/${exampleDir}/${src}"
+                    into "../distribution/${distributionDir}/${destFolder}/src"
+                }
+            }
         }
     }
 }
@@ -212,7 +239,7 @@ task copyLibrariesToEclipseFolder(dependsOn: 'androidJar') << {
     abi.each() { abiName ->
         copy {
             from "build/intermediates/eclipse/lib/${abiName}/librealm-jni.so"
-            into "../distribution/eclipse/lib/${abiName}"
+            into "../distribution/eclipse/${abiName}"
         }
     }
 }
@@ -241,42 +268,42 @@ task createDistributionPackage(type: Zip) {
     archiveName = "realm-java-${version}.zip"
 }
 
-examples.each() { src, dest ->
-    task "distributionMonkey${dest}"(type: GradleBuild) {
+examples.each() { exampleDir, params ->
+    String distDir = params[0];
+    String appModule = params[1][1]
+    task "distributionMonkey${distDir}"(type: GradleBuild) {
         dependsOn createDistributionPackage
         //dependsOn bintrayUpload
-        dir = file("${rootDir}/distribution/${dest}")
+        dir = file("${rootDir}/distribution/${distDir}/${appModule}")
         tasks = ['monkeyRelease']
     }
 }
 
-apply plugin: 's3'
+task uploadDistributionPackage(type: Exec) {
+    examples.each { exampleDir, params ->
+        dependsOn "distributionMonkey${params[0]}"
+    }
+    commandLine 's3cmd', 'put', "${rootDir}/realm-java-${version}.zip", 's3://static.realm.io/downloads/java/'
+}
 
-import com.github.skhatri.s3aws.plugin.S3UploadTask
+task createEmptyFile(type: Exec) {
+    dependsOn uploadDistributionPackage
+    commandLine 'touch', 'latest'
+}
 
-// This is an ugly hack because we have two links to the latest version.
-// The right solution here would be to contribute a change to the S3 Gradle plugin
-// to allow link to be a list of strings.
 ['java', 'android'].each() { link ->
-    task "upload${link.capitalize()}DistributionPackage"(type: S3UploadTask) {
-        examples.each { src, dest ->
-            dependsOn "distributionMonkey${dest}"
-        }
-        bucket = 'static.realm.io'
-        file = "${rootDir}/realm-java-${version}.zip"
-        key = 'downloads/java/realm-java-${version}.zip'
-        link = "downloads/${link}/latest"
+    task "upload${link.capitalize()}LatestLink"(type: Exec) {
+        dependsOn createEmptyFile
+        commandLine 's3cmd', 'put', 'latest', "--add-header=x-amz-website-redirect-location:/downloads/java/realm-java-${version}.zip", "s3://static.realm.io/downloads/${link}/latest"
     }
 }
 
-task uploadUpdateVersion(type: S3UploadTask) {
+
+task uploadUpdateVersion(type: Exec) {
     ['java', 'android'].each() { link ->
-        dependsOn "upload${link.capitalize()}DistributionPackage"
+        dependsOn "upload${link.capitalize()}LatestLink"
     }
-    bucket = 'static.realm.io'
-    file = "${rootDir}/version.txt"
-    key = 'update/java'
-    link = 'downloads/temp/update-java'
+    commandLine 's3cmd', 'put', "${rootDir}/version.txt", 's3://static.realm.io/update/java'
 }
 
 task tagRepo(type: Exec) {
@@ -296,3 +323,26 @@ task release {
     description 'Release realm-java'
     dependsOn pushTag
 }
+
+apply plugin: 'findbugs'
+
+task findbugs(type: FindBugs) {
+    dependsOn assemble
+    ignoreFailures = false
+    effort = "default"
+    reportLevel = "medium"
+    excludeFilter = new File("${projectDir}/findbugs-filter.xml")
+    classes = files("${projectDir}/build/intermediates/classes")
+    source = fileTree('src/main/java/')
+    classpath = files()
+    reports {
+        xml.enabled = false
+        html.enabled = true
+        xml {
+            destination "$project.buildDir/findbugs/findbugs-output.xml"
+        }
+        html {
+            destination "$project.buildDir/findbugs/findbugs-output.html"
+        }
+    }
+}
diff --git a/realm/findbugs-filter.xml b/realm/findbugs-filter.xml
new file mode 100644
index 0000000000..6c8187969e
--- /dev/null
+++ b/realm/findbugs-filter.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<FindBugsFilter>
+    <Match>
+        <!-- ignore all issues in resource generation -->
+        <Class name="~.*\.R\$.*"/>
+    </Match>
+    <Match>
+        <Class name="~.*\.Manifest\$.*"/>
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.ImplicitTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.ReadTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.WriteTransaction" />
+        <Method name="finalize" />
+        <Bug pattern="FI_NULLIFY_SUPER" />
+    </Match>
+    <Match>
+        <Class name="io.realm.Realm" />
+        <Method name="checkHasPrimaryKey" />
+        <Bug pattern="UPM_UNCALLED_PRIVATE_METHOD" />
+    </Match>
+    <Match>
+        <Class name="io.realm.RealmBaseAdapter" />
+        <Field name="context" />
+        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
+    </Match>
+    <Match>
+        <Class name="io.realm.RealmBaseAdapter" />
+        <Field name="inflater" />
+        <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
+    </Match>
+</FindBugsFilter>
diff --git a/realm/src/androidTest/assets/080_annotationtypes.realm b/realm/src/androidTest/assets/080_annotationtypes.realm
new file mode 100644
index 0000000000..1252c79172
Binary files /dev/null and b/realm/src/androidTest/assets/080_annotationtypes.realm differ
diff --git a/realm/src/androidTest/assets/default-before-migration.realm b/realm/src/androidTest/assets/default-before-migration.realm
new file mode 100644
index 0000000000..7a9ae6075f
Binary files /dev/null and b/realm/src/androidTest/assets/default-before-migration.realm differ
diff --git a/realm/src/androidTest/assets/list_alltypes_primarykey.json b/realm/src/androidTest/assets/list_alltypes_primarykey.json
index 75dc393edb..a7d233f23f 100644
--- a/realm/src/androidTest/assets/list_alltypes_primarykey.json
+++ b/realm/src/androidTest/assets/list_alltypes_primarykey.json
@@ -4,7 +4,7 @@
         "columnLong" : 1,
         "columnFloat" : 1.23,
         "columnDouble" : 1.234,
-        "columnBoolean" : true,
+        "columnBoolean" : false,
         "columnBinary" : "AQID",
         "columnDate" : 1000,
         "columnRealmObject" : {
@@ -27,7 +27,7 @@
         "columnLong" : 1,
         "columnFloat" : 2.23,
         "columnDouble" : 2.234,
-        "columnBoolean" : false,
+        "columnBoolean" : true,
         "columnBinary" : "AQID",
         "columnDate" : 2000,
         "columnRealmObject" : {
diff --git a/realm/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/src/androidTest/java/io/realm/IOSRealmTests.java
index ce4d4ac057..86e6ab24a8 100644
--- a/realm/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package io.realm;
 
 import android.test.AndroidTestCase;
@@ -21,13 +36,17 @@
     @Override
     protected void setUp() throws Exception {
         super.setUp();
-        Realm.setSchema(IOSAllTypes.class, IOSChild.class);
+        RealmConfiguration defaultConfiguration = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .schema(IOSAllTypes.class, IOSChild.class)
+                .build();
+        Realm.setDefaultConfiguration(defaultConfiguration);
     }
 
     @Override
     protected void tearDown() throws Exception {
         super.tearDown();
-        Realm.setSchema(null);
+        Realm.removeDefaultConfiguration();
         if (realm != null) {
             realm.close();
         }
@@ -36,7 +55,7 @@ protected void tearDown() throws Exception {
     // Test relationships and that data in general can be retrieved from an iOS realm
     public void testIOSDatatypes() throws IOException {
         TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm = Realm.getDefaultInstance();
         RealmResults<IOSAllTypes> result = realm.allObjectsSorted(IOSAllTypes.class, "longCol", RealmResults.SORT_ORDER_ASCENDING);
 
         IOSAllTypes obj = result.get(1);
@@ -57,7 +76,7 @@ public void testIOSDatatypes() throws IOException {
 
     public void testIOSDatatypesDefaultValues() throws IOException {
         TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-default.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm = Realm.getDefaultInstance();
 
         IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
         assertFalse(obj.isBoolCol());
@@ -75,7 +94,7 @@ public void testIOSDatatypesDefaultValues() throws IOException {
 
     public void testIOSDatatypesMinimumValues() throws IOException {
         TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-min.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm = Realm.getDefaultInstance();
 
         IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
         assertEquals(Short.MIN_VALUE, obj.getShortCol());
@@ -87,7 +106,7 @@ public void testIOSDatatypesMinimumValues() throws IOException {
 
     public void testIOSDatatypesMaximumValues() throws IOException {
         TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.4-alltypes-max.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm = Realm.getDefaultInstance();
 
         IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
         assertEquals(Short.MAX_VALUE, obj.getShortCol());
@@ -99,7 +118,12 @@ public void testIOSDatatypesMaximumValues() throws IOException {
 
     public void testIOSEncryptedRealm() throws IOException {
         TestHelper.prepareDatabaseFromAssets(getContext(),  "ios/0.90.5-alltypes-default-encrypted.realm", REALM_NAME);
-        realm = Realm.getInstance(getContext(), REALM_NAME, getIOSKey());
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .name(REALM_NAME)
+                .encryptionKey(getIOSKey())
+                .schema(IOSAllTypes.class, IOSChild.class)
+                .build();
+        realm = Realm.getInstance(realmConfig);
 
         IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
         assertFalse(obj.isBoolCol());
diff --git a/realm/src/androidTest/java/io/realm/NotificationsTest.java b/realm/src/androidTest/java/io/realm/NotificationsTest.java
index a567c3d181..de93d906d8 100644
--- a/realm/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/src/androidTest/java/io/realm/NotificationsTest.java
@@ -19,6 +19,7 @@
 import android.os.Looper;
 import android.test.AndroidTestCase;
 
+import java.lang.ref.WeakReference;
 import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
@@ -32,15 +33,26 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 
 public class NotificationsTest extends AndroidTestCase {
 
+    private Realm realm;
+
     @Override
     protected void setUp() throws Exception {
         Realm.deleteRealmFile(getContext());
     }
 
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
     public void testFailingSetAutoRefreshOnNonLooperThread() throws ExecutionException, InterruptedException {
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -83,11 +95,57 @@ public Boolean call() throws Exception {
         assertTrue(Realm.realmsCache.get().isEmpty());
     }
 
-    public void testNotificationsNumber () throws InterruptedException, ExecutionException {
+    public void testRemoveNotifications () throws InterruptedException, ExecutionException {
+        final AtomicInteger counter= new AtomicInteger(0);
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+
+        realm = Realm.getInstance(getContext());
+        realm.addChangeListener(listener);
+        realm.removeChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertEquals(0, counter.get());
+    }
+
+    public void testAddDuplicatedListener() {
+        final AtomicInteger counter= new AtomicInteger(0);
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+
+        realm = Realm.getInstance(getContext());
+        realm.addChangeListener(listener);
+        realm.addChangeListener(listener);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertEquals(1, counter.get());
+    }
+
+    public void testNotificationsNumber() throws InterruptedException, ExecutionException {
         final AtomicInteger counter = new AtomicInteger(0);
         final AtomicBoolean isReady = new AtomicBoolean(false);
         final Looper[] looper = new Looper[1];
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
 
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -98,12 +156,7 @@ public Boolean call() throws Exception {
                     Looper.prepare();
                     looper[0] = Looper.myLooper();
                     realm = Realm.getInstance(getContext());
-                    realm.addChangeListener(new RealmChangeListener() {
-                        @Override
-                        public void onChange() {
-                            counter.incrementAndGet();
-                        }
-                    });
+                    realm.addChangeListener(listener);
                     isReady.set(true);
                     Looper.loop();
                 } finally {
@@ -116,13 +169,14 @@ public void onChange() {
             }
         });
 
-        // Wait until the looper is started
+        // Wait until the looper in the background thread is started
         while (!isReady.get()) {
             Thread.sleep(5);
         }
-        Thread.sleep(100); 
+        Thread.sleep(100);
 
-        Realm realm = Realm.getInstance(getContext());
+        // Trigger OnRealmChanged on background thread
+        realm = Realm.getInstance(getContext());
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
         dog.setName("Rex");
@@ -152,6 +206,7 @@ public void testAutoUpdateRealmResults() throws InterruptedException, ExecutionE
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
         final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
         final Looper[] looper = new Looper[1];
+        final RealmChangeListener listener[] = new RealmChangeListener[1];
 
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -165,13 +220,14 @@ public Boolean call() throws Exception {
                     realm = Realm.getInstance(getContext());
                     final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
                     assertEquals(0, dogs.size());
-                    realm.addChangeListener(new RealmChangeListener() {
+                    listener[0] = new RealmChangeListener() {
                         @Override
                         public void onChange() {
                             int c = counter.incrementAndGet();
                             results.put(c, dogs.size());
                         }
-                    });
+                    };
+                    realm.addChangeListener(listener[0]);
                     isReady.set(true);
                     Looper.loop();
                 } finally {
@@ -294,7 +350,7 @@ public void testHandlerNotRemovedToSoon() {
         Realm.deleteRealmFile(getContext(), "private-realm");
         Realm instance1 = Realm.getInstance(getContext(), "private-realm");
         Realm instance2 = Realm.getInstance(getContext(), "private-realm");
-        assertEquals(instance1.getId(), instance2.getId());
+        assertEquals(instance1.getPath(), instance2.getPath());
         assertNotNull(instance1.getHandler());
 
         // If multiple instances are open on the same thread, don't remove handler on that thread
@@ -304,4 +360,126 @@ public void testHandlerNotRemovedToSoon() {
         instance1.close();
         assertNull(instance1.getHandler());
     }
+
+    public void testImmediateNotificationsOnSameThread() {
+        final AtomicBoolean success = new AtomicBoolean(false);
+        final RealmChangeListener listener[] = new RealmChangeListener[1];
+        realm = Realm.getInstance(getContext());
+        listener[0] = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                // Listener should only be called once
+                assertFalse(success.get());
+                success.set(true);
+            }
+        };
+        realm.addChangeListener(listener[0]);
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        assertTrue(success.get());
+    }
+
+    public void testEmptyCommitTriggerChangeListener() {
+        final AtomicBoolean success = new AtomicBoolean(false);
+        final RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                success.set(true);
+            }
+        };
+        realm = Realm.getInstance(getContext());
+        realm.addChangeListener(listener);
+        realm.beginTransaction();
+        realm.commitTransaction();
+        assertTrue(success.get());
+    }
+
+    public void testAddRemoveListenerConcurrency() {
+        final AtomicInteger counter1 = new AtomicInteger(0);
+        final AtomicInteger counter2 = new AtomicInteger(0);
+        final AtomicInteger counter3 = new AtomicInteger(0);
+
+        // At least we need 2 listeners existing in the list to make sure
+        // the iterator.next get called
+
+        // This one will be added when listener2's onChange called
+        final RealmChangeListener listener1 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter1.incrementAndGet();
+            }
+        };
+
+        // This one will be existing in the list all the time
+        final RealmChangeListener listener2 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter2.incrementAndGet();
+                realm.addChangeListener(listener1);
+            }
+        };
+
+        // This one will be removed after first transaction
+        RealmChangeListener listener3 = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter3.incrementAndGet();
+                realm.removeChangeListener(this);
+            }
+        };
+
+        realm = Realm.getInstance(getContext());
+        realm.addChangeListener(listener2);
+        realm.addChangeListener(listener3);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        // [listener2, listener3]
+        realm.commitTransaction();
+        // after listener2.onChange
+        // [listener2, listener3, listener1]
+        // after listener3.onChange
+        // [listener2, listener1]
+        assertEquals(0, counter1.get());
+        assertEquals(1, counter2.get());
+        assertEquals(1, counter3.get());
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        // [listener2, listener1]
+        realm.commitTransaction();
+        // after listener2.onChange
+        // Since duplicated entries will be ignored, we still have:
+        // [listener2, listener1]
+
+        assertEquals(1, counter1.get());
+        assertEquals(2, counter2.get());
+        assertEquals(1, counter3.get());
+    }
+
+    public void testWeakReferenceListener() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger(0);
+        realm = Realm.getInstance(getContext());
+        RealmChangeListener listener = new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                counter.incrementAndGet();
+            }
+        };
+        realm.addChangeListener(listener);
+
+        // There is no guaranteed way to release the WeakReference,
+        // just clear it.
+        for (WeakReference<RealmChangeListener> weakRef: realm.getChangeListeners()) {
+            weakRef.clear();
+        }
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertEquals(0, counter.get());
+        assertEquals(0, realm.getChangeListeners().size());
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java b/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
index ee9e78d56b..75020fa36e 100644
--- a/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmAdapterTest.java
@@ -58,12 +58,6 @@ public void testAdapterParameterExceptions() {
             fail("Should throw exception if context is null");
         } catch (IllegalArgumentException ignore) {
         }
-
-        try {
-            RealmAdapter realmAdapter = new RealmAdapter(getContext(), null, automaticUpdate);
-            fail("Should throw exception if RealmResult is null");
-        } catch (IllegalArgumentException ignore) {
-        }
     }
 
     public void testUpdateRealmResultInAdapter() {
@@ -165,4 +159,26 @@ public void testGetView() {
         assertNotNull(name);
         assertEquals(resultList.get(0).getColumnString(), name.getText());
     }
+
+    public void testNullResults() {
+        RealmAdapter realmAdapter = new RealmAdapter(getContext(), null, automaticUpdate);
+
+        assertEquals(0, realmAdapter.getCount());
+    }
+
+    public void testNonNullToNullResults() {
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmAdapter realmAdapter = new RealmAdapter(getContext(), resultList, automaticUpdate);
+        realmAdapter.updateRealmResults(null);
+
+        assertEquals(0, realmAdapter.getCount());
+    }
+
+    public void testNullToNonNullResults() {
+        RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).findAll();
+        RealmAdapter realmAdapter = new RealmAdapter(getContext(), null, automaticUpdate);
+        realmAdapter.updateRealmResults(resultList);
+
+        assertEquals(TEST_DATA_SIZE, realmAdapter.getCount());
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
index 205d0d5efd..445465ec90 100644
--- a/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmAnnotationTest.java
@@ -52,20 +52,20 @@ public void testIgnore() {
 
     public void testIndex() {
         Table table = testRealm.getTable(AnnotationTypes.class);
-        assertTrue(table.hasIndex(table.getColumnIndex("indexString")));
-        assertFalse(table.hasIndex(table.getColumnIndex("notIndexString")));
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexString")));
     }
 
     public void testHasPrimaryKeyNoIntIndex() {
         Table table = testRealm.getTable(AnnotationTypes.class);
         assertTrue(table.hasPrimaryKey());
-        assertFalse(table.hasIndex(table.getColumnIndex("id")));
+        assertFalse(table.hasSearchIndex(table.getColumnIndex("id")));
     }
 
     public void testHasPrimaryKeyStringIndex() {
         Table table = testRealm.getTable(PrimaryKeyAsString.class);
         assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasIndex(table.getColumnIndex("name")));
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("name")));
     }
 
     // Test migrating primary key from string to long with existing data
@@ -182,7 +182,7 @@ public void testPrimaryKey_errorOnInsertingSameObject() {
     public void testPrimaryKeyIsIndexed() {
         Table table = testRealm.getTable(PrimaryKeyAsString.class);
         assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasIndex(0));
+        assertTrue(table.hasSearchIndex(0));
     }
 
     // Annotation processor honors common naming conventions
diff --git a/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java b/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java
new file mode 100644
index 0000000000..3ceb491892
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/RealmConfigurationTest.java
@@ -0,0 +1,346 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.test.AndroidTestCase;
+
+import java.io.File;
+import java.util.Random;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.CyclicType;
+import io.realm.entities.Dog;
+import io.realm.entities.Owner;
+import io.realm.exceptions.RealmMigrationNeededException;
+
+public class RealmConfigurationTest extends AndroidTestCase {
+
+    RealmConfiguration defaultConfig;
+    Realm realm;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        defaultConfig = new RealmConfiguration.Builder(getContext()).build();
+        Realm.deleteRealm(defaultConfig);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    public void testSetNullDefaultConfigurationThrows() {
+        try {
+            Realm.setDefaultConfiguration(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testGetNullDefaultInstanceThrows() {
+        try {
+            Realm.getDefaultInstance();
+            fail();
+        } catch (NullPointerException expected) {
+        }
+    }
+
+    public void testGetNullInstance() {
+        try {
+            Realm.getInstance((RealmConfiguration) null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testNullDirThrows() {
+        try {
+            new RealmConfiguration.Builder((File) null).build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testNullNameThrows() {
+        try {
+            new RealmConfiguration.Builder(getContext()).name(null).build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testEmptyNameThrows() {
+        try {
+            new RealmConfiguration.Builder(getContext()).name("").build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testNullKeyThrows() {
+        try {
+            new RealmConfiguration.Builder(getContext()).encryptionKey(null).build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testWrongKeyLengthThrows() {
+        byte[][] wrongKeys = new byte[][] {
+                new byte[0],
+                new byte[RealmConfiguration.KEY_LENGTH - 1],
+                new byte[RealmConfiguration.KEY_LENGTH + 1]
+        };
+        for (byte[] key : wrongKeys) {
+            try {
+                new RealmConfiguration.Builder(getContext()).encryptionKey(key).build();
+                fail("Key with length " + key.length + " should throw an exception");
+            } catch (IllegalArgumentException expected) {
+            }
+        }
+    }
+
+    public void testNegativeVersionThrows() {
+        try {
+            new RealmConfiguration.Builder(getContext()).schemaVersion(-1).build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testVersionLessThanDiscVersionThrows() {
+        realm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).schemaVersion(42).build());
+        realm.close();
+
+        int[] wrongVersions = new int[] { 0, 1, 41 };
+        for (int version : wrongVersions) {
+            try {
+                Realm.getInstance(new RealmConfiguration.Builder(getContext()).schemaVersion(version).build());
+                fail("Version " + version + " should throw an exception");
+            } catch (IllegalArgumentException expected) {
+            }
+        }
+    }
+
+    public void testVersionEqualWhenSchemaChangesThrows() {
+        // Create initial Realm
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext()).schemaVersion(42).schema(Dog.class).build();
+        Realm.getInstance(config).close();
+
+        // Create new instance with a configuration containing another schema
+        try {
+            config = new RealmConfiguration.Builder(getContext()).schemaVersion(42).schema(AllTypesPrimaryKey.class).build();
+            Realm.getInstance(config);
+            fail("A migration should be required");
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testCustomSchemaDontIncludeLinkedClasses() {
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext()).schema(Dog.class).build();
+        realm = Realm.getInstance(config);
+        try {
+            assertEquals(3, realm.getTable(Owner.class).getColumnCount());
+            fail("Owner should to be part of the schema");
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testNullMigrationThrows() {
+        try {
+            new RealmConfiguration.Builder(getContext()).migration(null).build();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testSetModulesNullThrows() {
+        // Test first argument
+        try {
+            new RealmConfiguration.Builder(getContext()).setModules(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+
+        // Test second argument
+        try {
+            new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule(), null, null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testSetModulesNonRealmModulesThrows() {
+        // Test first argument
+        try {
+            new RealmConfiguration.Builder(getContext()).setModules(new Object());
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+
+        // Test second argument
+        try {
+            new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule(), new Object());
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testSetModules() {
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).setModules(Realm.getDefaultModule()).build();
+        realm = Realm.getInstance(realmConfig);
+        assertNotNull(realm.getTable(AllTypes.class));
+    }
+
+    public void testSetDefaultConfiguration() {
+        Realm.setDefaultConfiguration(defaultConfig);
+        realm = Realm.getDefaultInstance();
+        assertEquals(realm.getPath(), defaultConfig.getPath());
+    }
+
+    public void testGetInstance() {
+        realm = Realm.getInstance(defaultConfig);
+        assertEquals(realm.getPath(), defaultConfig.getPath());
+    }
+
+    public void testStandardSetup() {
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext())
+                .name("foo.realm")
+                .encryptionKey(TestHelper.getRandomKey())
+                .schemaVersion(42)
+                .migration(new RealmMigration() {
+                    @Override
+                    public long execute(Realm realm, long version) {
+                        return 0; // no-op
+                    }
+                })
+                .deleteRealmIfMigrationNeeded()
+                .build();
+
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        assertTrue(realm.getPath().endsWith("foo.realm"));
+        assertEquals(42, realm.getVersion());
+    }
+
+    public void testDeleteRealmIfMigration() {
+        // Populate v0 of a Realm with an object
+        RealmConfiguration config = new RealmConfiguration.Builder(getContext())
+                .schema(Dog.class)
+                .schemaVersion(0)
+                .build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.copyToRealm(new Dog("Foo"));
+        realm.commitTransaction();
+        assertEquals(1, realm.where(Dog.class).count());
+        realm.close();
+
+        // Change schema and verify that Realm has been cleared
+        config = new RealmConfiguration.Builder(getContext())
+                .schema(Owner.class, Dog.class)
+                .schemaVersion(1)
+                .deleteRealmIfMigrationNeeded()
+                .build();
+        realm = Realm.getInstance(config);
+        assertEquals(0, realm.where(Dog.class).count());
+    }
+
+    public void testUpgradeVersionWithNoMigration() {
+        realm = Realm.getInstance(defaultConfig);
+        assertEquals(0, realm.getVersion());
+        realm.close();
+
+        // Version upgrades should always require a migration.
+        try {
+            realm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).schemaVersion(42).build());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testEquals() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(getContext()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(getContext()).build();
+        assertTrue(config1.equals(config2));
+    }
+
+    public void testHashCode() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(getContext()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(getContext()).build();
+        assertEquals(config1.hashCode(), config2.hashCode());
+    }
+
+    public void testEqualConfigurationsReturnCachedRealm() {
+        Realm realm1 = Realm.getInstance(getContext());
+        Realm realm2 = Realm.getInstance(getContext());
+        try {
+            assertEquals(realm1, realm2);
+        } finally {
+            realm1.close();
+            realm2.close();
+        }
+    }
+
+    public void testDifferentVersionsThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(getContext()).schemaVersion(1).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(getContext()).schemaVersion(2).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    public void testDifferentEncryptionKeysThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(getContext()).encryptionKey(TestHelper.getRandomKey()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(getContext()).encryptionKey(TestHelper.getRandomKey()).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        } finally {
+            realm1.close();
+        }
+    }
+
+    public void testDifferentSchemasThrows() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(getContext()).schema(AllTypes.class).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(getContext()).schema(CyclicType.class).build();
+
+        Realm realm1 = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        } finally {
+            realm1.close();
+        }
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmJsonTest.java b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
index fe8d542c4e..754ea23aa1 100644
--- a/realm/src/androidTest/java/io/realm/RealmJsonTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmJsonTest.java
@@ -23,7 +23,6 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Date;
@@ -326,7 +325,7 @@ public void testCreateAllFromJsonStringArray_null() {
    public void testCreateAllFromJsonStream_null() throws IOException {
         testRealm.createAllFromJson(AllTypes.class, (InputStream) null);
         assertEquals(0, testRealm.allObjects(AllTypes.class).size());
-    }
+   }
 
     public void testCreateObjectFromJsonStream_allSimpleTypes() throws IOException {
         InputStream in = loadJsonFromAssets("all_simple_types.json");
@@ -452,6 +451,15 @@ public void testCreateOrUpdateObjectStream_noPrimaryKeyThrows() throws IOExcepti
         fail();
     }
 
+    public void testCreateOrUpdateObjectStream_invalidJSonThrows() throws IOException {
+        try {
+            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{"));
+        } catch (RealmException expected) {
+            return;
+        }
+        fail();
+    }
+
     public void testCreateOrUpdateObjectString_noPrimaryKeyThrows() throws IOException {
         try {
             testRealm.createOrUpdateObjectFromJson(AllTypes.class, "{}");
@@ -479,6 +487,33 @@ public void testCreateOrUpdateJsonObject() throws JSONException {
         assertEquals("bar", newObj.getColumnString());
     }
 
+    public void testCreateOrUpdateJsonObject_ignoreUnsetProperties() throws IOException {
+        String json = TestHelper.streamToString(loadJsonFromAssets("list_alltypes_primarykey.json"));
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, json);
+        testRealm.commitTransaction();
+
+        // No-op as no properties should be updated
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\":1 }");
+        testRealm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
+    public void testCreateOrUpdateJsonStream_ignoreUnsetProperties() throws IOException {
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, loadJsonFromAssets("list_alltypes_primarykey.json"));
+        testRealm.commitTransaction();
+
+        // No-op as no properties should be updated
+        testRealm.beginTransaction();
+        testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("{ \"columnLong\":1 }"));
+        testRealm.commitTransaction();
+
+        assertAllTypesPrimaryKeyUpdated();
+    }
+
     public void testCreateOrUpdateInputStream() throws IOException {
         testRealm.beginTransaction();
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
@@ -486,7 +521,7 @@ public void testCreateOrUpdateInputStream() throws IOException {
         obj.setColumnString("Foo");
         testRealm.copyToRealm(obj);
 
-        ByteArrayInputStream in = new ByteArrayInputStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }".getBytes());
+        InputStream in = TestHelper.stringToStream("{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
         AllTypesPrimaryKey newObj = testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
         testRealm.commitTransaction();
 
@@ -527,6 +562,15 @@ public void testCreateOrUpdateAllStream_noPrimaryKeyThrows() throws IOException
         fail();
     }
 
+    public void testCreateOrUpdateAllStream_invalidJSonThrows() throws IOException {
+        try {
+            testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, TestHelper.stringToStream("["));
+        } catch (RealmException expected) {
+            return;
+        }
+        fail();
+    }
+
     public void testCreateOrUpdateAllString_noPrimaryKeyThrows() throws IOException {
         try {
             testRealm.createOrUpdateAllFromJson(AllTypes.class, "{}");
@@ -570,7 +614,7 @@ private void assertAllTypesPrimaryKeyUpdated() {
         assertEquals("Bar", obj.getColumnString());
         assertEquals(2.23F, obj.getColumnFloat());
         assertEquals(2.234D, obj.getColumnDouble());
-        assertEquals(false, obj.isColumnBoolean());
+        assertEquals(true, obj.isColumnBoolean());
         assertArrayEquals(new byte[] {1,2,3}, obj.getColumnBinary());
         assertEquals(new Date(2000), obj.getColumnDate());
         assertEquals("Dog4", obj.getColumnRealmObject().getName());
diff --git a/realm/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
index 48aa43c7ed..81d8d04d85 100644
--- a/realm/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -463,4 +463,61 @@ public void testSubquery() {
         RealmResults<Owner> subOwners = owners.where().equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, subOwners.size());
     }
+
+    public void testLinkIsNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("cat").findAll();
+        assertEquals(0, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Cat.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("cat").findAll();
+        assertEquals(1, owners2.size());
+    }
+
+    public void testLinkListIsNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("dogs").findAll();
+        assertEquals(0, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Dog.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("dogs").findAll();
+        assertEquals(1, owners2.size());
+    }
+
+    public void testLinkIsNotNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("cat").findAll();
+        assertEquals(1, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Cat.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("cat").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    public void testLinkListIsNotNull() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
+        assertEquals(1, owners1.size());
+
+        testRealm.beginTransaction();
+        testRealm.clear(Dog.class);
+        testRealm.commitTransaction();
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("dogs").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    public void testIsNullWrongType() {
+        try {
+            // Owner.name is a String
+            RealmResults<Owner> owners = testRealm.where(Owner.class).isNull("name").findAll();
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmListTest.java b/realm/src/androidTest/java/io/realm/RealmListTest.java
index e162b5f0da..1de11546c7 100644
--- a/realm/src/androidTest/java/io/realm/RealmListTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmListTest.java
@@ -18,9 +18,12 @@
 
 import android.test.AndroidTestCase;
 
+import io.realm.entities.AllTypes;
+import io.realm.entities.CyclicType;
+import io.realm.entities.CyclicTypePrimaryKey;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
-import io.realm.entities.AllTypes;
+import io.realm.entities.OwnerPrimaryKey;
 import io.realm.exceptions.RealmException;
 
 public class RealmListTest extends AndroidTestCase {
@@ -53,7 +56,8 @@ protected void setUp() throws Exception {
     }
 
     // Check that all methods work correctly on a empty RealmList
-    private void testMethodsOnEmptyList(RealmList<Dog> list) {
+    private void checkMethodsOnEmptyList(Realm realm, RealmList<Dog> list) {
+        realm.beginTransaction();
         for (int i = 0; i < 4; i++) {
             try {
                 switch(i) {
@@ -67,6 +71,7 @@ private void testMethodsOnEmptyList(RealmList<Dog> list) {
             } catch (RealmException expected) {
             }
         }
+        realm.cancelTransaction();
 
         assertEquals(0, list.size());
         assertNull(list.first());
@@ -212,21 +217,25 @@ public void testSize_nonManagedMode() {
     }
 
     // Test move where oldPosition > newPosition
-    public void testMoveDown_nonManagedMode() {
+    public void testMoveDown() {
         Owner owner = testRealm.where(Owner.class).findFirst();
         Dog dog1 = owner.getDogs().get(1);
+        testRealm.beginTransaction();
         owner.getDogs().move(1, 0);
+        testRealm.commitTransaction();
 
         assertEquals(0, owner.getDogs().indexOf(dog1));
     }
 
     // Test move where oldPosition < newPosition
-    public void testMoveUp_nonManagedMode() {
+    public void testMoveUp() {
         Owner owner = testRealm.where(Owner.class).findFirst();
         int oldIndex = TEST_OBJECTS / 2;
         int newIndex = oldIndex + 1;
         Dog dog = owner.getDogs().get(oldIndex);
+        testRealm.beginTransaction();
         owner.getDogs().move(oldIndex, newIndex); // This doesn't do anything as oldIndex is now empty so the index's above gets shifted to the left.
+        testRealm.commitTransaction();
 
         assertEquals(TEST_OBJECTS, owner.getDogs().size());
         assertEquals(oldIndex, owner.getDogs().indexOf(dog));
@@ -245,7 +254,7 @@ public void testFirstAndLast_nonManagedMode() {
 
     public void testEmptyList_nonManagedMode() {
         RealmList<Dog> list = new RealmList<Dog>();
-        testMethodsOnEmptyList(list);
+        checkMethodsOnEmptyList(testRealm, list);
     }
 
     /*********************************************************
@@ -253,7 +262,7 @@ public void testEmptyList_nonManagedMode() {
      *********************************************************/
 
     // Test move where oldPosition > newPosition
-    public void testMoveDown() {
+    public void testMoveDown_nonManagedMode() {
         RealmList<Dog> dogs = createNonManagedDogList();
         Dog dog1 = dogs.get(1);
         dogs.move(1, 0);
@@ -262,7 +271,7 @@ public void testMoveDown() {
     }
 
     // Test move where oldPosition < newPosition
-    public void testMoveUp() {
+    public void testMoveUp_nonManagedMode() {
         RealmList<Dog> dogs = createNonManagedDogList();
         int oldIndex = TEST_OBJECTS / 2;
         int newIndex = oldIndex + 1;
@@ -275,15 +284,19 @@ public void testMoveUp() {
 
     public void testMoveOutOfBoundsLowerThrows() {
         Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
         try {
             owner.getDogs().move(0, -1);
             fail("Indexes < 0 should throw an exception");
         } catch (IndexOutOfBoundsException ignored) {
+        } finally {
+            testRealm.cancelTransaction();
         }
     }
 
     public void testMoveOutOfBoundsHigherThrows() {
         Owner owner = testRealm.where(Owner.class).findFirst();
+        testRealm.beginTransaction();
         try {
             int lastIndex = TEST_OBJECTS - 1;
             int outOfBoundsIndex = TEST_OBJECTS;
@@ -291,6 +304,8 @@ public void testMoveOutOfBoundsHigherThrows() {
             fail("Indexes >= size() should throw an exception");
         } catch (IndexOutOfBoundsException ignored) {
             ignored.printStackTrace();
+        } finally {
+            testRealm.cancelTransaction();
         }
     }
 
@@ -305,6 +320,61 @@ public void testAddObject() {
         assertEquals(1, testRealm.where(Owner.class).findFirst().getDogs().size());
     }
 
+    // Test that add correctly uses Realm.copyToRealm() on standalone objects.
+    public void testAddUnmanagedObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicType parent = testRealm.createObject(CyclicType.class);
+        RealmList<CyclicType> children = parent.getObjects();
+        children.add(new CyclicType());
+        testRealm.commitTransaction();
+        assertEquals(1, testRealm.where(CyclicType.class).findFirst().getObjects().size());
+    }
+
+    // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
+    public void testAddUnmanagedPrimaryKeyObjectToManagedList() {
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
+        RealmList<CyclicTypePrimaryKey> children = testRealm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
+        children.add(new CyclicTypePrimaryKey(2, "new"));
+        testRealm.commitTransaction();
+
+        assertEquals(1, testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 1).findFirst().getObjects().size());
+        assertEquals("new", testRealm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
+    }
+
+    // Test that set correctly uses Realm.copyToRealm() on standalone objects.
+    public void testSetUnmanagedObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicType parent = testRealm.copyToRealm(new CyclicType("Parent"));
+        RealmList<CyclicType> children = parent.getObjects();
+        children.add(new CyclicType());
+        children.add(new CyclicType("original"));
+        children.add(new CyclicType());
+        children.set(1, new CyclicType("updated"));
+        testRealm.commitTransaction();
+
+        RealmList<CyclicType> list = testRealm.where(CyclicType.class).findFirst().getObjects();
+        assertEquals(3, list.size());
+        assertEquals("updated", list.get(1).getName());
+        assertEquals(5, testRealm.where(CyclicType.class).count());
+    }
+
+    // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
+    public void testSetUnmanagedPrimaryKeyObjectToManagedList() {
+        testRealm.beginTransaction();
+        CyclicTypePrimaryKey parent = testRealm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
+        RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
+        children.add(new CyclicTypePrimaryKey(2));
+        children.add(new CyclicTypePrimaryKey(3, "original"));
+        children.add(new CyclicTypePrimaryKey(4));
+        children.set(1, new CyclicTypePrimaryKey(3, "updated"));
+        testRealm.commitTransaction();
+
+        RealmList<CyclicTypePrimaryKey> list = testRealm.where(CyclicTypePrimaryKey.class).findFirst().getObjects();
+        assertEquals(3, list.size());
+        assertEquals("updated", list.get(1).getName());
+    }
+
     public void testAddObjectNullThrows() {
         testRealm.beginTransaction();
         Owner owner = testRealm.createObject(Owner.class);
@@ -405,7 +475,7 @@ public void testEmptyListMethods() {
         owner.getDogs().clear();
         testRealm.commitTransaction();
 
-        testMethodsOnEmptyList(owner.getDogs());
+        checkMethodsOnEmptyList(testRealm, owner.getDogs());
     }
 
     public void testClear() {
@@ -425,4 +495,31 @@ public void testClearNotDeleting() {
         assertEquals(TEST_OBJECTS, testRealm.allObjects(Dog.class).size());
         testRealm.commitTransaction();
     }
+
+    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
+    public void testMutableMethodsOutsideWriteTransactions() {
+        testRealm.beginTransaction();
+        RealmList<Dog> list = testRealm.createObject(AllTypes.class).getColumnRealmList();
+        Dog dog = testRealm.createObject(Dog.class);
+        list.add(dog);
+        testRealm.commitTransaction();
+
+        try { list.add(dog);    fail(); } catch (IllegalStateException expected) {}
+        try { list.add(0, dog); fail(); } catch (IllegalStateException expected) {}
+        try { list.clear();     fail(); } catch (IllegalStateException expected) {}
+        try { list.move(0, 1);  fail(); } catch (IllegalStateException expected) {}
+        try { list.remove(0);   fail(); } catch (IllegalStateException expected) {}
+        try { list.set(0, dog); fail(); } catch (IllegalStateException expected) {}
+    }
+
+    public void testSettingListClearsOldItems() {
+        testRealm.beginTransaction();
+        CyclicType one = testRealm.copyToRealm(new CyclicType());
+        CyclicType two = testRealm.copyToRealm(new CyclicType());
+        two.setObjects(new RealmList<CyclicType>(one));
+        two.setObjects(new RealmList<CyclicType>(one));
+        testRealm.commitTransaction();
+
+        assertEquals(1, two.getObjects().size());
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
index c8debea8ed..651b01f1c2 100644
--- a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -16,19 +16,12 @@
 
     public Realm realm;
 
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        Realm.deleteRealmFile(getContext());
-    }
-
     @Override
     protected void tearDown() throws Exception {
         super.tearDown();
         if (realm != null) {
             realm.close();
         }
-        Realm.setSchema(null);
     }
 
     public void testRealmClosedAfterMigrationException() throws IOException {
@@ -55,11 +48,19 @@ public void testLocalColumnIndices() throws IOException {
         String NEW_REALM = "new.realm";
 
         // Migrate old Realm to proper schema
-        Realm.deleteRealmFile(getContext(), MIGRATED_REALM);
-        Realm.setSchema(AllTypes.class);
-        Realm migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
-        migratedRealm.close();
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), MIGRATED_REALM).getAbsolutePath(), new RealmMigration() {
+
+        // V1 config
+        RealmConfiguration v1Config = new RealmConfiguration.Builder(getContext())
+                .name(MIGRATED_REALM)
+                .schema(AllTypes.class)
+                .schemaVersion(1)
+                .build();
+        Realm.deleteRealm(v1Config);
+        Realm oldRealm = Realm.getInstance(v1Config);
+        oldRealm.close();
+
+        // V2 config
+        RealmMigration migration = new RealmMigration() {
             @Override
             public long execute(Realm realm, long version) {
                 Table languageTable = realm.getTable(FieldOrder.class);
@@ -70,25 +71,34 @@ public long execute(Realm realm, long version) {
 
                 return version + 1;
             }
-        });
+        };
 
-        // Open migrated Realm and populate column indices based on migration ordering.
-        Realm.setSchema(AllTypes.class, FieldOrder.class);
-        migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
+        RealmConfiguration v2Config = new RealmConfiguration.Builder(getContext())
+                .name(MIGRATED_REALM)
+                .schema(AllTypes.class, FieldOrder.class)
+                .schemaVersion(2)
+                .migration(migration)
+                .build();
+        oldRealm = Realm.getInstance(v2Config);
 
         // Create new Realm which will cause column indices to be recalculated based on the order in the java file
         // instead of the migration
-        Realm.deleteRealmFile(getContext(), NEW_REALM);
-        Realm newRealm = Realm.getInstance(getContext(), NEW_REALM);
+        RealmConfiguration newConfig = new RealmConfiguration.Builder(getContext())
+                .name(NEW_REALM)
+                .schemaVersion(2)
+                .schema(AllTypes.class, FieldOrder.class)
+                .build();
+        Realm.deleteRealm(newConfig);
+        Realm newRealm = Realm.getInstance(newConfig);
         newRealm.close();
 
         // Try to query migrated realm. With local column indices this will work. With global it will fail.
-        assertEquals(0, migratedRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
+        assertEquals(0, oldRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
+        oldRealm.close();
     }
 
     public void testNotSettingIndexThrows() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+        RealmMigration migration = new RealmMigration() {
             @Override
             public long execute(Realm realm, long version) {
                 Table table = realm.getTable(AnnotationTypes.class);
@@ -99,56 +109,98 @@ public long execute(Realm realm, long version) {
                 // Forget to set @Index
                 return 1;
             }
-        });
+        };
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .schemaVersion(1)
+                .schema(AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        Realm.deleteRealm(realmConfig);
+        Realm.migrateRealm(realmConfig);
 
         try {
-            realm = Realm.getInstance(getContext());
+            realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException expected) {
         }
     }
 
     public void testNotSettingPrimaryKeyThrows() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+        RealmMigration migration = new RealmMigration() {
             @Override
             public long execute(Realm realm, long version) {
                 Table table = realm.getTable(AnnotationTypes.class);
                 table.addColumn(ColumnType.INTEGER, "id");
                 // Forget to set @PrimaryKey
                 long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
-                table.setIndex(columnIndex);
+                table.addSearchIndex(columnIndex);
                 table.addColumn(ColumnType.STRING, "notIndexString");
                 return 1;
             }
-        });
+        };
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .schemaVersion(1)
+                .schema(AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        Realm.deleteRealm(realmConfig);
+        Realm.migrateRealm(realmConfig);
 
         try {
-            realm = Realm.getInstance(getContext());
+            realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException expected) {
         }
     }
 
     public void testSetAnnotations() {
-        Realm.setSchema(AnnotationTypes.class);
-        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+        RealmMigration migration = new RealmMigration() {
             @Override
             public long execute(Realm realm, long version) {
                 Table table = realm.getTable(AnnotationTypes.class);
                 table.addColumn(ColumnType.INTEGER, "id");
                 table.setPrimaryKey("id");
                 long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
-                table.setIndex(columnIndex);
+                table.addSearchIndex(columnIndex);
                 table.addColumn(ColumnType.STRING, "notIndexString");
                 return 1;
             }
-        });
+        };
+
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .schemaVersion(1)
+                .schema(AnnotationTypes.class)
+                .migration(migration)
+                .build();
+        Realm.deleteRealm(realmConfig);
+        Realm.migrateRealm(realmConfig);
 
-        realm = Realm.getInstance(getContext());
+        realm = Realm.getInstance(realmConfig);
         Table table = realm.getTable(AnnotationTypes.class);
         assertEquals(3, table.getColumnCount());
         assertTrue(table.hasPrimaryKey());
-        assertTrue(table.hasIndex(table.getColumnIndex("indexString")));
+        assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
+    }
+
+    public void testGetPathFromMigrationException() throws IOException {
+        TestHelper.copyRealmFromAssets(getContext(), "default0.realm", Realm.DEFAULT_REALM_NAME);
+        File realm = new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME);
+        try {
+            Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+            assertEquals(expected.getPath(), realm.getCanonicalPath());
+        }
+    }
+
+    // In default-before-migration.realm, CatOwner has a RealmList<Dog> field.
+    // This is changed to RealmList<Cat> and getInstance() must throw an exception.
+    public void testRealmListChanged() throws IOException {
+        TestHelper.copyRealmFromAssets(getContext(), "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        try {
+            realm = Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmObjectTest.java b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
index b1d07dc5dd..d9fd1de984 100644
--- a/realm/src/androidTest/java/io/realm/RealmObjectTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmObjectTest.java
@@ -45,8 +45,9 @@
 
     @Override
     protected void setUp() throws Exception {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).build();
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
     }
 
     @Override
@@ -91,73 +92,73 @@ public void testStringEncoding() {
 
     // removing original object and see if has been removed
     public void testRemoveFromRealm() {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        Dog rex = realm.createObject(Dog.class);
+        testRealm = Realm.getInstance(getContext());
+        testRealm.beginTransaction();
+        Dog rex = testRealm.createObject(Dog.class);
         rex.setName("Rex");
-        Dog fido = realm.createObject(Dog.class);
+        Dog fido = testRealm.createObject(Dog.class);
         fido.setName("Fido");
-        realm.commitTransaction();
+        testRealm.commitTransaction();
 
-        RealmResults<Dog> allDogsBefore = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        RealmResults<Dog> allDogsBefore = testRealm.where(Dog.class).equalTo("name", "Rex").findAll();
         assertEquals(1, allDogsBefore.size());
 
-        realm.beginTransaction();
+        testRealm.beginTransaction();
         rex.removeFromRealm();
-        realm.commitTransaction();
+        testRealm.commitTransaction();
 
-        RealmResults<Dog> allDogsAfter = realm.where(Dog.class).equalTo("name", "Rex").findAll();
+        RealmResults<Dog> allDogsAfter = testRealm.where(Dog.class).equalTo("name", "Rex").findAll();
         assertEquals(0  , allDogsAfter.size());
 
         fido.getName();
         try {
             rex.getName();
-            realm.close();
+            testRealm.close();
             fail();
         } catch (IllegalStateException ignored) {}
 
         // deleting rex twice should fail
-        realm.beginTransaction();
+        testRealm.beginTransaction();
         try {
             rex.removeFromRealm();
-            realm.close();
+            testRealm.close();
             fail();
         } catch (IllegalStateException ignored) {}
-        realm.commitTransaction();
-        realm.close();
+        testRealm.commitTransaction();
+        testRealm.close();
     }
 
     // query for an object, remove it and see it has been removed from realm
     public void testRemoveResultFromRealm() {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        realm.clear(Dog.class);
-        Dog dogToAdd = realm.createObject(Dog.class);
+        testRealm = Realm.getInstance(getContext());
+        testRealm.beginTransaction();
+        testRealm.clear(Dog.class);
+        Dog dogToAdd = testRealm.createObject(Dog.class);
         dogToAdd.setName("Rex");
-        realm.commitTransaction();
+        testRealm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(Dog.class).size());
+        assertEquals(1, testRealm.allObjects(Dog.class).size());
 
-        Dog dogToRemove = realm.where(Dog.class).findFirst();
+        Dog dogToRemove = testRealm.where(Dog.class).findFirst();
         assertNotNull(dogToRemove);
-        realm.beginTransaction();
+        testRealm.beginTransaction();
         dogToRemove.removeFromRealm();
-        realm.commitTransaction();
+        testRealm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, testRealm.allObjects(Dog.class).size());
         try {
             dogToAdd.getName();
-            realm.close();
+            testRealm.close();
             fail();
         }
         catch (IllegalStateException ignored) {}
         try {
             dogToRemove.getName();
-            realm.close();
+            testRealm.close();
             fail();
         }
         catch (IllegalStateException ignored) {}
-        realm.close();
+        testRealm.close();
     }
 
     public void removeOneByOne(boolean atFirst) {
@@ -209,11 +210,11 @@ public void testRemoveFromRealmAtPosition() {
     }
 
     public boolean methodWrongThread(final boolean callGetter) throws ExecutionException, InterruptedException {
-        Realm realm = Realm.getInstance(getContext());
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-        final AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+        testRealm = Realm.getInstance(getContext());
+        testRealm.beginTransaction();
+        testRealm.createObject(AllTypes.class);
+        testRealm.commitTransaction();
+        final AllTypes allTypes = testRealm.where(AllTypes.class).findFirst();
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
             @Override
@@ -232,7 +233,7 @@ public Boolean call() throws Exception {
         });
 
         Boolean result = future.get();
-        realm.close();
+        testRealm.close();
         return result;
     }
 
@@ -484,8 +485,9 @@ public void testIsValidUnManagedObject() {
     }
 
     public void testIsValidClosedRealm() {
-        Realm.deleteRealmFile(getContext(), "other-realm");
-        Realm testRealm = Realm.getInstance(getContext(), "other-realm");
+        RealmConfiguration otherConfig = new RealmConfiguration.Builder(getContext()).name("other-realm").build();
+        Realm.deleteRealm(otherConfig);
+        Realm testRealm = Realm.getInstance(otherConfig);
         testRealm.beginTransaction();
         AllTypes allTypes = testRealm.createObject(AllTypes.class);
         assertTrue(allTypes.isValid());
diff --git a/realm/src/androidTest/java/io/realm/RealmResultsTest.java b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
index 8ea98c3267..b247fb8857 100644
--- a/realm/src/androidTest/java/io/realm/RealmResultsTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmResultsTest.java
@@ -28,6 +28,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
+import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 
@@ -50,8 +51,9 @@
 
     @Override
     protected void setUp() throws InterruptedException {
-        Realm.deleteRealmFile(getContext());
-        testRealm = Realm.getInstance(getContext());
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext()).build();
+        Realm.deleteRealm(realmConfig);
+        testRealm = Realm.getInstance(realmConfig);
         populateTestRealm();
     }
 
@@ -64,11 +66,15 @@ private void populateTestRealm(int objects) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 2) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date((long) 1000*i));
+            allTypes.setColumnDate(new Date((long) 1000 * i));
             allTypes.setColumnDouble(3.1415 + i);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
+            Dog d = testRealm.createObject(Dog.class);
+            d.setName("Foo " + i);
+            allTypes.setColumnRealmObject(d);
+            allTypes.getColumnRealmList().add(d);
             NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set델타(i);
             nonLatinFieldNames.setΔέλτα(i);
@@ -700,6 +706,22 @@ public void testSubList() {
         assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
     }
 
+    public void testUnsupportedMethods() {
+        RealmResults<AllTypes> result = testRealm.where(AllTypes.class).findAll();
+
+        try { result.add(null);     fail(); } catch (UnsupportedOperationException expected) {}
+        try { result.set(0, null);  fail(); } catch (UnsupportedOperationException expected) {}
+    }
+
+
+    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
+    public void testMutableMethodsOutsideWriteTransactions() {
+        RealmResults<AllTypes> result = testRealm.where(AllTypes.class).findAll();
+
+        try { result.clear();       fail(); } catch (IllegalStateException expected) {}
+        try { result.remove(0);     fail(); } catch (IllegalStateException expected) {}
+        try { result.removeLast();  fail(); } catch (IllegalStateException expected) {}
+    }
 
     // TODO: More extended tests of querying all types must be done.
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index c7393dc931..0d61561cea 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -16,17 +16,23 @@
 package io.realm;
 
 import android.content.Context;
+import android.os.SystemClock;
 import android.test.AndroidTestCase;
 
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.nio.channels.FileChannel;
+import java.io.InputStream;
+import java.lang.ref.Reference;
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Scanner;
 import java.util.concurrent.Callable;
@@ -34,12 +40,13 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
-import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
 import io.realm.entities.NonLatinFieldNames;
@@ -51,6 +58,7 @@
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
+import io.realm.internal.FinalizerRunnable;
 import io.realm.internal.Table;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -92,12 +100,12 @@ protected void tearDown() throws Exception {
         }
     }
 
-    private void populateTestRealm(int objects) {
-        testRealm.beginTransaction();
-        testRealm.allObjects(AllTypes.class).clear();
-        testRealm.allObjects(NonLatinFieldNames.class).clear();
+    private void populateTestRealm(Realm realm, int objects) {
+        realm.beginTransaction();
+        realm.allObjects(AllTypes.class).clear();
+        realm.allObjects(NonLatinFieldNames.class).clear();
         for (int i = 0; i < objects; ++i) {
-            AllTypes allTypes = testRealm.createObject(AllTypes.class);
+            AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
             allTypes.setColumnDate(new Date());
@@ -105,23 +113,23 @@ private void populateTestRealm(int objects) {
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
-            NonLatinFieldNames nonLatinFieldNames = testRealm.createObject(NonLatinFieldNames.class);
+            NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set델타(i);
             nonLatinFieldNames.setΔέλτα(i);
             nonLatinFieldNames.set베타(1.234567f + i);
             nonLatinFieldNames.setΒήτα(1.234567f + i);
         }
-        testRealm.commitTransaction();
+        realm.commitTransaction();
     }
 
     private void populateTestRealm() {
-        populateTestRealm(TEST_DATA_SIZE);
+        populateTestRealm(testRealm, TEST_DATA_SIZE);
     }
 
 
     public void testGetInstanceNullFolderThrows() {
         try {
-            Realm.getInstance((File) null);
+            Realm.getInstance(new RealmConfiguration.Builder((File) null).build());
             fail("Parsing null as folder should throw an error");
         } catch (IllegalArgumentException expected) {
         }
@@ -147,9 +155,9 @@ public void testGetInstanceCreateSubFoldersThrows() {
     public void testGetInstanceFolderNoWritePermissionThrows() {
         File folder = new File("/");
         try {
-            Realm realm = Realm.getInstance(folder);
-            fail("Pointing to a folder with no write permission should throw an error");
-        } catch (RealmIOException expected) {
+            Realm realm = Realm.getInstance(new RealmConfiguration.Builder(folder).build());
+            fail("Pointing to a folder with no write permission should throw an IllegalArgumentException");
+        } catch (IllegalArgumentException expected) {
         }
     }
 
@@ -165,22 +173,20 @@ public void testGetInstanceFileNoWritePermissionThrows() throws IOException {
         assertTrue(realmFile.setWritable(false));
 
         try {
-            Realm.getInstance(folder, REALM_FILE);
+            Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
             fail("Trying to open a read-only file should fail");
         } catch (RealmIOException expected) {
         }
     }
 
-    // TODO Disabled due to the build phone keep crashing on this. It might be related to https://github.com/realm/realm-java/issues/1008
-    public void DISABLEtestGetInstanceClearsCacheWhenFailed() {
+    public void testGetInstanceClearsCacheWhenFailed() {
         String REALM_NAME = "invalid_cache.realm";
         Realm.deleteRealmFile(getContext(), REALM_NAME);
         Random random = new Random();
-        byte[] key = new byte[64];
-        random.nextBytes(key);
+        byte[] key = TestHelper.getRandomKey();
         Realm realm = Realm.getInstance(getContext(), REALM_NAME, key); // Create starting Realm with key1
         realm.close();
-        random.nextBytes(key);
+        key = TestHelper.getRandomKey();
         try {
             Realm.getInstance(getContext(), REALM_NAME, key); // Try to open with key 2
         } catch (IllegalArgumentException expected) {
@@ -192,6 +198,15 @@ public void DISABLEtestGetInstanceClearsCacheWhenFailed() {
         }
     }
 
+    public void testInstanceIdForHashCollision() {
+        // Ea.hashCode() == FB.hashCode()
+        Realm.deleteRealmFile(getContext(), "Ea");
+        Realm.deleteRealmFile(getContext(), "FB");
+        Realm r1 = Realm.getInstance(getContext(), "Ea");
+        Realm r2 = Realm.getInstance(getContext(), "FB");
+        assertNotSame(r1, r2);
+    }
+
     public void testRealmCache() {
         Realm newRealm = Realm.getInstance(getContext());
         assertEquals(testRealm, newRealm);
@@ -236,7 +251,7 @@ public void testShouldNotFailCreateRealmWithNullContext() {
             realm = Realm.getInstance((Context) null); // throws when c.getDirectory() is called;
             // has nothing to do with Realm
             fail("Should throw an exception");
-        } catch (NullPointerException ignore) {
+        } catch (IllegalArgumentException ignore) {
         } finally {
             if (realm != null) {
                 realm.close();
@@ -275,7 +290,7 @@ public void testShouldContainTable() {
         testRealm.createObject(Dog.class);
         testRealm.commitTransaction();
         assertTrue("contains returns false for newly created table", testRealm.contains(Dog.class));
-        assertFalse("contains returns true for non-existing table", testRealm.contains(RealmTest.class));
+        assertFalse("contains returns true for non-existing table", testRealm.contains(null));
     }
 
     // <E extends RealmObject> RealmQuery<E> where(Class<E> clazz)
@@ -287,7 +302,7 @@ public void testShouldReturnResultSet() {
 
     // Note that this test is relying on the values set while initializing the test dataset
     public void testQueriesResults() throws IOException {
-        populateTestRealm(159);
+        populateTestRealm(testRealm, 159);
         RealmResults<AllTypes> resultList = testRealm.where(AllTypes.class).equalTo(FIELD_LONG, 33).findAll();
         assertEquals(1, resultList.size());
 
@@ -937,14 +952,69 @@ public void testWriteCopyTo() throws IOException {
         }
     }
 
-    public void testCompactRealmFile() throws IOException {
-        final String copyRealm = "copy.realm";
-        fileCopy(
-                new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME),
-                new File(getContext().getFilesDir(), copyRealm));
-        long before = new File(getContext().getFilesDir(), copyRealm).length();
-        assertTrue(Realm.compactRealmFile(getContext()));
-        long after = new File(getContext().getFilesDir(), copyRealm).length();
+
+    public void testCompactRealmFileThrowsIfOpen() throws IOException {
+        try {
+            Realm.compactRealmFile(getContext());
+            fail();
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    public void testCompactEncryptedEmptyRealmFile() {
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .name("enc.realm")
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+        Realm.deleteRealm(realmConfig);
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealm(realmConfig));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testCompactEncryptedPopulatedRealmFile() {
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(getContext())
+                .name("enc.realm")
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+        Realm.deleteRealm(realmConfig);
+        Realm realm = Realm.getInstance(realmConfig);
+
+        populateTestRealm(realm, 100);
+        realm.close();
+        // TODO: remove try/catch block when compacting encrypted Realms is supported
+        try {
+            assertTrue(Realm.compactRealm(realmConfig));
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    public void testCompactEmptyRealmFile() throws IOException {
+        final String REALM_NAME = "test.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        realm.close();
+        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(before >= after);
+    }
+
+    public void testCompactPopulateRealmFile() throws IOException {
+        final String REALM_NAME = "test.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME);
+        populateTestRealm(realm, 100);
+        realm.close();
+        long before = new File(getContext().getFilesDir(), REALM_NAME).length();
+        assertTrue(Realm.compactRealmFile(getContext(), REALM_NAME));
+        long after = new File(getContext().getFilesDir(), REALM_NAME).length();
         assertTrue(before >= after);
     }
 
@@ -991,7 +1061,7 @@ public void testCopManagedObjectToOtherRealm() {
 
     public void testCopyToRealmObject() {
         Date date = new Date();
-        date.setTime(1000); // Remove ms. precission as Realm doesn't support it yet.
+        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
         Dog dog = new Dog();
         dog.setName("Fido");
         RealmList<Dog> list = new RealmList<Dog>();
@@ -1084,7 +1154,7 @@ public void testCopyToRealmWithPrimaryAsNullThrows() {
         try {
             testRealm.copyToRealm(new PrimaryKeyAsString());
             fail();
-        } catch (RealmException expected) {
+        } catch (IllegalArgumentException expected) {
         } finally {
             testRealm.cancelTransaction();
         }
@@ -1130,6 +1200,15 @@ public void testCopyToRealmOrUpdateNullThrows() {
         fail();
     }
 
+    public void testCopyToRealmOrUpdateNullPrimaryKeyThrows() {
+        testRealm.beginTransaction();
+        try {
+            testRealm.copyToRealmOrUpdate(new PrimaryKeyAsString());
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
     public void testCopyOrUpdateNoPrimaryKeyThrows() {
         try {
             testRealm.copyToRealmOrUpdate(new AllTypes());
@@ -1180,7 +1259,7 @@ public void execute(Realm realm) {
                 obj2.setColumnFloat(2.23F);
                 obj2.setColumnDouble(2.234D);
                 obj2.setColumnBoolean(true);
-                obj2.setColumnBinary(new byte[] {2, 3, 4});
+                obj2.setColumnBinary(new byte[]{2, 3, 4});
                 obj2.setColumnDate(new Date(2000));
                 obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
                 obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
@@ -1360,21 +1439,9 @@ public void testCopyOrUpdateIterableChildObjects() {
         assertEquals(1, testRealm.allObjects(DogPrimaryKey.class).size());
     }
 
-    private void fileCopy(File src, File dst) throws IOException {
-        FileInputStream inStream = new FileInputStream(src);
-        FileOutputStream outStream = new FileOutputStream(dst);
-        FileChannel inChannel = inStream.getChannel();
-        FileChannel outChannel = outStream.getChannel();
-        inChannel.transferTo(0, inChannel.size(), outChannel);
-        inStream.close();
-        outStream.close();
-    }
-
     public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
-        byte[] key1 = new byte[64];
-        byte[] key2 = new byte[64];
-        new Random(42).nextBytes(key1);
-        new Random(42).nextBytes(key2);
+        byte[] key1 = TestHelper.getRandomKey(42);
+        byte[] key2 = TestHelper.getRandomKey(42);
 
         // Make sure the key is the same, but in two different instances
         assertArrayEquals(key1, key2);
@@ -1385,9 +1452,17 @@ public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
         Realm realm1 = null;
         Realm realm2 = null;
         try {
-            realm1 = Realm.getInstance(getContext(), ENCRYPTED_REALM, key1);
+            realm1 = Realm.getInstance(new RealmConfiguration.Builder(getContext())
+                    .name(ENCRYPTED_REALM)
+                    .encryptionKey(key1)
+                    .build()
+            );
             try {
-                realm2 = Realm.getInstance(getContext(), ENCRYPTED_REALM, key2);
+                realm2 = Realm.getInstance(new RealmConfiguration.Builder(getContext())
+                        .name(ENCRYPTED_REALM)
+                        .encryptionKey(key2)
+                        .build()
+                );
             } catch (Exception e) {
                 fail();
             } finally {
@@ -1407,73 +1482,85 @@ public void testWriteEncryptedCopy() throws Exception {
         long before = testRealm.where(AllTypes.class).count();
         assertEquals(TEST_DATA_SIZE, before);
 
+        // Configure test realms
         final String ENCRYPTED_REALM_FILE_NAME = "encryptedTestRealm.realm";
         final String RE_ENCRYPTED_REALM_FILE_NAME = "reEncryptedTestRealm.realm";
         final String DECRYPTED_REALM_FILE_NAME = "decryptedTestRealm.realm";
 
-        // Delete files if present
-        for (String fileName : Arrays.asList(ENCRYPTED_REALM_FILE_NAME, RE_ENCRYPTED_REALM_FILE_NAME, DECRYPTED_REALM_FILE_NAME)) {
-            File fileToDelete = new File(getContext().getFilesDir(), fileName);
-            if (fileToDelete.exists() && !fileToDelete.delete()) {
+        RealmConfiguration encryptedRealmConfig = new RealmConfiguration.Builder(getContext())
+                .name(ENCRYPTED_REALM_FILE_NAME)
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+
+        RealmConfiguration reEncryptedRealmConfig = new RealmConfiguration.Builder(getContext())
+                .name(RE_ENCRYPTED_REALM_FILE_NAME)
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+
+        RealmConfiguration decryptedRealmConfig = new RealmConfiguration.Builder(getContext())
+                .name(DECRYPTED_REALM_FILE_NAME)
+                .build();
+
+        // Delete old test Realms if present
+        for (RealmConfiguration realmConfig : Arrays.asList(encryptedRealmConfig, reEncryptedRealmConfig, decryptedRealmConfig)) {
+            if (!Realm.deleteRealm(realmConfig)) {
                 fail();
             }
         }
 
+        // Write encrypted copy from a unencrypted Realm
         File destination = new File(getContext().getFilesDir(), ENCRYPTED_REALM_FILE_NAME);
-        byte[] key = new byte[64];
-        new Random(42).nextBytes(key);
         try {
-            // Unencrypted to encrypted
-            testRealm.writeEncryptedCopyTo(destination, key);
+            testRealm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
         } catch(Exception e) {
-            e.printStackTrace();
-            fail();
+            fail(e.getMessage());
         }
 
         Realm encryptedRealm = null;
         try {
-            encryptedRealm = Realm.getInstance(getContext(), ENCRYPTED_REALM_FILE_NAME, key);
+
+            // Verify encrypted Realm and write new encrypted copy with a new key
+            encryptedRealm = Realm.getInstance(encryptedRealmConfig);
             assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
 
-            destination = new File(getContext().getFilesDir(), RE_ENCRYPTED_REALM_FILE_NAME);
-            new Random(1234321).nextBytes(key);
+            destination = new File(reEncryptedRealmConfig.getPath());
             try {
-                // Encrypted to encrypted
-                encryptedRealm.writeEncryptedCopyTo(destination, key);
+                encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
             } catch (Exception e) {
-                e.printStackTrace();
-                fail();
+                fail(e.getMessage());
             }
+
+            // Verify re-encrypted copy
             Realm reEncryptedRealm = null;
             try {
-                reEncryptedRealm = Realm.getInstance(getContext(), RE_ENCRYPTED_REALM_FILE_NAME, key);
+                reEncryptedRealm = Realm.getInstance(reEncryptedRealmConfig);
                 assertEquals(TEST_DATA_SIZE, reEncryptedRealm.where(AllTypes.class).count());
             } finally {
                 if (reEncryptedRealm != null) {
                     reEncryptedRealm.close();
-                    boolean isDeleted = new File(reEncryptedRealm.getPath()).delete();
-                    if (!isDeleted) {
+                    if (!Realm.deleteRealm(reEncryptedRealmConfig)) {
                         fail();
                     }
                 }
             }
 
-            destination = new File(getContext().getFilesDir(), DECRYPTED_REALM_FILE_NAME);
+            // Write non-encrypted copy from the encrypted version
+            destination = new File(decryptedRealmConfig.getPath());
             try {
-                // Encrypted to decrypted
                 encryptedRealm.writeEncryptedCopyTo(destination, null);
             } catch (Exception e) {
-                fail();
+                fail(e.getMessage());
             }
+
+            // Verify decrypted Realm and cleanup
             Realm decryptedRealm = null;
             try {
-                decryptedRealm = Realm.getInstance(getContext(), DECRYPTED_REALM_FILE_NAME);
+                decryptedRealm = Realm.getInstance(decryptedRealmConfig);
                 assertEquals(TEST_DATA_SIZE, decryptedRealm.where(AllTypes.class).count());
             } finally {
                 if (decryptedRealm != null) {
                     decryptedRealm.close();
-                    boolean isDeleted = new File(decryptedRealm.getPath()).delete();
-                    if (!isDeleted) {
+                    if (!Realm.deleteRealm(decryptedRealmConfig)) {
                         fail();
                     }
                 }
@@ -1481,8 +1568,7 @@ public void testWriteEncryptedCopy() throws Exception {
         } finally {
             if (encryptedRealm != null) {
                 encryptedRealm.close();
-                boolean isDeleted = new File(encryptedRealm.getPath()).delete();
-                if (!isDeleted) {
+                if (!Realm.deleteRealm(encryptedRealmConfig)) {
                     fail();
                 }
             }
@@ -1518,26 +1604,6 @@ public void testOpenRealmFileDeletionShouldThrow() {
         }
     }
 
-    public void testWrongKeyShouldThrow() {
-        final String WRONG_KEY_REALM = "wrong-key-realm.realm";
-        Realm.deleteRealmFile(getContext(), WRONG_KEY_REALM);
-
-        // Wrong key size
-        try {
-            Realm.getInstance(getContext(), WRONG_KEY_REALM, new byte[63]);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-
-        Realm.getInstance(getContext(), WRONG_KEY_REALM);
-
-        try {
-            Realm.getInstance(getContext(), WRONG_KEY_REALM, new byte[64]);
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
-    }
-
     public void testUpdateObjectWithLinks() throws Exception {
         testRealm.beginTransaction();
 
@@ -1569,6 +1635,88 @@ public void testDeleteNonRealmFile() throws IOException {
         File tmpFile = new File(getContext().getFilesDir(), "tmp");
         tmpFile.delete();
         assertTrue(tmpFile.createNewFile());
-        assertTrue(Realm.deleteRealmFile(tmpFile));
+    }
+
+    // Test that all methods that require a write transaction (ie. any function that mutates Realm data)
+    public void testMutableMethodsOutsideWriteTransactions() throws JSONException, IOException {
+
+        // Prepare standalone object data
+        AllTypesPrimaryKey t = new AllTypesPrimaryKey();
+        List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
+
+        // Prepare JSON data
+        String jsonObjStr = "{ \"columnLong\" : 1 }";
+        JSONObject jsonObj = new JSONObject(jsonObjStr);
+        InputStream jsonObjStream = TestHelper.stringToStream(jsonObjStr);
+        InputStream jsonObjStream2 = TestHelper.stringToStream(jsonObjStr);
+
+        String jsonArrStr = " [{ \"columnLong\" : 1 }] ";
+        JSONArray jsonArr = new JSONArray(jsonArrStr);
+        InputStream jsonArrStream = TestHelper.stringToStream(jsonArrStr);
+        InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
+
+        // Test all methods that should require a write transaction
+        try { testRealm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.clear(AllTypes.class);          fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.setVersion(42);                 fail(); } catch (IllegalStateException expected) {}
+
+        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (RealmException expected) {}
+        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (RealmException expected) {}
+        try { testRealm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream);          fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+
+        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (RealmException expected) {}
+        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (RealmException expected) {}
+        try { testRealm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStream);             fail(); } catch (IllegalStateException expected) {}
+        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (RealmException expected) {}
+        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (RealmException expected) {}
+        try { testRealm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);    fail(); } catch (IllegalStateException expected) {}
+    }
+
+    // Check that FinalizerRunnable can free native resources (phantom refs)
+    public void testFinalizerThread() throws NoSuchFieldException, IllegalAccessException {
+        Field fieldReferences = FinalizerRunnable.class.getDeclaredField("references");
+        fieldReferences.setAccessible(true);
+        Map<Reference<?>, Boolean> references = (Map<Reference<?>, Boolean>) fieldReferences.get(null);
+        assertNotNull(references);
+
+        Field fieldIsFinalizerStarted = Realm.class.getDeclaredField("isFinalizerStarted");
+        fieldIsFinalizerStarted.setAccessible(true);
+        boolean isFinalizerStarted = fieldIsFinalizerStarted.getBoolean(null);
+        assertTrue(isFinalizerStarted);
+
+        //insert some rows, then give the FinalizerRunnable some time to cleanup
+        // we have 8 reference so far let's add more
+        final int numberOfPopulateTest = 10000;
+        final int totalNumberOfReferences = 8 + 20 * 2 * numberOfPopulateTest;
+
+        for (int i = 0; i < numberOfPopulateTest; i++) {
+            populateTestRealm(testRealm, 20);
+        }
+
+        final int MAX_GC_RETRIES = 5;
+        int numberOfRetries = 0;
+        while (references.size() > 0 && numberOfRetries < MAX_GC_RETRIES) {
+            SystemClock.sleep(TimeUnit.SECONDS.toMillis(1)); //1s
+            numberOfRetries++;
+            System.gc();
+        }
+
+        // we can't guarantee that all references have been GC'd but we should detect a decrease
+        boolean isDecreasing = references.size() < totalNumberOfReferences;
+        if (!isDecreasing) {
+            fail("FinalizerRunnable is not closing all native resources");
+
+        } else {
+            android.util.Log.d(RealmTest.class.getName(), "FinalizerRunnable freed : "
+                    + (totalNumberOfReferences - references.size()) + " out of " + totalNumberOfReferences);
+        }
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/TestHelper.java b/realm/src/androidTest/java/io/realm/TestHelper.java
index be2d833474..26d6d85785 100644
--- a/realm/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/src/androidTest/java/io/realm/TestHelper.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.res.AssetManager;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.BufferedReader;
@@ -26,6 +27,8 @@
 import java.io.InputStream;
 
 import java.io.InputStreamReader;
+import java.util.Random;
+import java.nio.charset.Charset;
 
 public class TestHelper {
 
@@ -47,6 +50,10 @@ public static String streamToString(InputStream in) throws IOException {
         return sb.toString();
     }
 
+    public static InputStream stringToStream(String str) {
+        return new ByteArrayInputStream(str.getBytes(Charset.forName("UTF-8")));
+    }
+
     // Copies a Realm file from assets to app files dir
     public static void copyRealmFromAssets(Context context, String realmPath, String newName) throws IOException {
         AssetManager assetManager = context.getAssets();
@@ -68,6 +75,20 @@ public static void prepareDatabaseFromAssets(Context context, String realmPath,
         TestHelper.copyRealmFromAssets(context, realmPath, newName);
     }
 
+    // Returns a random key used by encrypted Realms.
+    public static byte[] getRandomKey() {
+        byte[] key = new byte[64];
+        new Random().nextBytes(key);
+        return key;
+    }
+
+    // Returns a random key from the given seed. Used by encrypted Realms.
+    public static byte[] getRandomKey(long seed) {
+        byte[] key = new byte[64];
+        new Random(seed).nextBytes(key);
+        return key;
+    }
+
     public static class StubInputStream extends InputStream {
         @Override
         public int read() throws IOException {
diff --git a/realm/src/androidTest/java/io/realm/entities/CatOwner.java b/realm/src/androidTest/java/io/realm/entities/CatOwner.java
new file mode 100644
index 0000000000..9596e0ee22
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/entities/CatOwner.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.entities;
+
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class CatOwner extends RealmObject {
+    private String name;
+    private RealmList<Cat> cats;
+
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public RealmList<Cat> getCats() {
+        return cats;
+    }
+
+    public void setCats(RealmList<Cat> cats) {
+        this.cats = cats;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/CyclicType.java b/realm/src/androidTest/java/io/realm/entities/CyclicType.java
index f9e771bd02..3d9694ce64 100644
--- a/realm/src/androidTest/java/io/realm/entities/CyclicType.java
+++ b/realm/src/androidTest/java/io/realm/entities/CyclicType.java
@@ -9,6 +9,13 @@
     private CyclicType object;
     private RealmList<CyclicType> objects;
 
+    public CyclicType() {
+    }
+
+    public CyclicType(String name) {
+        this.name = name;
+    }
+
     public String getName() {
         return name;
     }
diff --git a/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java b/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
index 25941ca5d7..d7a6d139be 100644
--- a/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
+++ b/realm/src/androidTest/java/io/realm/entities/CyclicTypePrimaryKey.java
@@ -19,6 +19,11 @@ public CyclicTypePrimaryKey(long id) {
         this.id = id;
     }
 
+    public CyclicTypePrimaryKey(long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     public long getId() {
         return id;
     }
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java b/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
index 481f9ab0b3..4e85a4e073 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
@@ -28,8 +28,8 @@ public void testShouldTestDistinct() {
         init();
 
         // Must set index before using distinct()
-        table.setIndex(1);
-        assertEquals(true, table.hasIndex(1));
+        table.addSearchIndex(1);
+        assertEquals(true, table.hasSearchIndex(1));
 
         TableView view = table.getDistinctView(1);
         assertEquals(4, view.size());
@@ -61,7 +61,7 @@ public void testShouldTestDistinctErrorWhenIndexOutOfBounds() {
 
     public void testShouldTestDistinctErrorWhenWrongColumnType() {
         init();
-        table.setIndex(1);
+        table.addSearchIndex(1);
         try {
             TableView view = table.getDistinctView(0);
             fail();
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java b/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
index 9a4e97bdbb..6202f2a2f4 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
@@ -57,6 +57,7 @@ public void testImplicitTransactions() {
     }
 
     public void testCannotUseClosedImplicitTransaction() {
+        deleteFile();
         SharedGroup sg = new SharedGroup(testFile, true, null);
         WriteTransaction wt = sg.beginWrite();
         if (!wt.hasTable("test")) {
diff --git a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
index aa47ed5672..74b4c85a2d 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -59,7 +59,7 @@ public void testLinkList() {
 
         table2.insertLinkList(0,0);
 
-        LinkView links = table2.getRow(0).getLinkList(0);
+        LinkView links = table2.getUncheckedRow(0).getLinkList(0);
 
         assertEquals(links.isEmpty(), true);
         assertEquals(links.size(), 0);
@@ -70,17 +70,17 @@ public void testLinkList() {
         assertEquals(links.isEmpty(), false);
         assertEquals(links.size(), 2);
 
-        assertEquals(links.get(0).getColumnName(1), "string");
+        assertEquals(links.getUncheckedRow(0).getColumnName(1), "string");
 
-        assertEquals(links.get(0).getString(1), "a");
+        assertEquals(links.getUncheckedRow(0).getString(1), "a");
 
         links.move(1, 0);
 
-        assertEquals(links.get(0).getString(1), "b");
+        assertEquals(links.getUncheckedRow(0).getString(1), "b");
 
         links.remove(0);
 
-        assertEquals(links.get(0).getString(1), "a");
+        assertEquals(links.getUncheckedRow(0).getString(1), "a");
         assertEquals(links.size(), 1);
 
 
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java b/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
index 7a17a4de91..07c7e571b0 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
@@ -49,8 +49,8 @@
         );
     }
 
-    public JNIMixedTypeTest(ArrayList mixedDataList) {
-        this.mixedDataList = mixedDataList;
+    public JNIMixedTypeTest(ArrayList<MixedData> mixedDataList) {
+        JNIMixedTypeTest.mixedDataList = mixedDataList;
 
     }
 
@@ -78,49 +78,49 @@ public void testShouldFailOnWrongTypeRetrieval() {
                     try {
                         mixed.getBinaryByteArray();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case DATE:
                     try {
                         mixed.getDateValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case BOOLEAN:
                     try {
                         mixed.getBooleanValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case INTEGER:
                     try {
                         mixed.getLongValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case FLOAT:
                     try {
                         mixed.getFloatValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case DOUBLE:
                     try {
                         mixed.getDoubleValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 case STRING:
                     try {
                         mixed.getStringValue();
                         fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException e) {
+                    } catch (IllegalMixedTypeException ignored) {
                     }
                     break;
                 default:
@@ -163,8 +163,7 @@ private void checkMixedCell(Table table, long col, long row, ColumnType columnTy
         if (columnType == ColumnType.BINARY) {
             if (mixed.getBinaryType() == Mixed.BINARY_TYPE_BYTE_ARRAY) {
                 // NOTE: We never get here because we always "get" a ByteBuffer.
-                byte[] bin = mixed.getBinaryByteArray();
-                assertEquals(Mixed.mixedValue(value), bin);
+                assertEquals(Mixed.mixedValue(value), mixed);
             } else {
                 ByteBuffer binBuf = mixed.getBinaryValue();
                 // TODO: Below is sort of hack to compare the content of the
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 0124afd7ac..7fac06aff1 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -26,7 +26,7 @@ public void testRow() {
         table.add("abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
 
 
-        Row row = table.getRow(0);
+        UncheckedRow row = table.getUncheckedRow(0);
 
         assertEquals("abc", row.getString(0));
         assertEquals(3, row.getLong(1));
@@ -63,12 +63,12 @@ public void testMixed() {
 
         table.addEmptyRows(2);
 
-        Row row = table.getRow(0);
+        UncheckedRow row = table.getUncheckedRow(0);
         row.setMixed(0, new Mixed(1.5));
 
         assertEquals(1.5, row.getMixed(0).getDoubleValue());
 
-        Row row2 = table.getRow(1);
+        UncheckedRow row2 = table.getUncheckedRow(1);
         row2.setMixed(0, new Mixed("test"));
 
         assertEquals("test", row2.getMixed(0).getStringValue());
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
index 1443562677..7d54042b97 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -49,14 +49,6 @@ public void testTableToString() {
         assertEquals(expected, t.toString());
     }
 
-    public void testGroupEquals() {
-        Table t2 = createTestTable();
-        assertEquals(true, t.equals(t2));
-        t.addEmptyRow();
-        assertEquals(false, t.equals(t2));
-    }
-
-
     public void testRowOperationsOnZeroRow(){
 
         Table t = new Table();
@@ -129,6 +121,36 @@ public void testFindFirstNonExisting() {
         assertEquals(-1, t.findFirstString(7, "other string"));
     }
 
+    public void testFindFirst() {
+        final int TEST_SIZE = 10;
+        Table t = TestHelper.getTableWithAllColumnTypes();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            t.add(new byte[]{1,2,3}, true, new Date(1000*i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
+        }
+        t.add(new byte[]{1,2,3}, true, new Date(1000*TEST_SIZE), (double)TEST_SIZE, (float)TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
+
+        assertEquals(0, t.findFirstBoolean(1, true));
+        for (int i = 0; i < TEST_SIZE; i++) {
+            assertEquals(i, t.findFirstDate(2, new Date(1000*i)));
+            assertEquals(i, t.findFirstDouble(3, (double) i));
+            assertEquals(i, t.findFirstFloat(4, (float) i));
+            assertEquals(i, t.findFirstLong(5, i));
+            assertEquals(i, t.findFirstString(7, "string " + i));
+        }
+
+        assertEquals(TEST_SIZE, t.findFirstString(7, ""));
+
+        try {
+            t.findFirstString(7, null);
+            fail();
+        } catch (IllegalArgumentException expected) {}
+
+        try {
+            t.findFirstDate(2, null);
+            fail();
+        } catch (IllegalArgumentException expected) {}
+    }
+
 
     public void testGetValuesFromNonExistingColumn() {
         Table t = TestHelper.getTableWithAllColumnTypes();
@@ -349,19 +371,19 @@ public void testGetName() {
     public void testShouldThrowWhenSetIndexOnWrongColumnType() {
         for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
 
-            // Check all other column types than String throws exception when using setIndex()/hasIndex()
+            // Check all other column types than String throws exception when using addSearchIndex()/hasSearchIndex()
             boolean exceptionExpected = (t.getColumnType(colIndex) != ColumnType.STRING);
 
-            // Try to setIndex()
+            // Try to addSearchIndex()
             try {
-                t.setIndex(colIndex);
+                t.addSearchIndex(colIndex);
                 if (exceptionExpected)
                     fail("expected exception for colIndex " + colIndex);
             } catch (IllegalArgumentException e) {
             }
 
-            // Try to hasIndex() for all columnTypes
-            t.hasIndex(colIndex);
+            // Try to hasSearchIndex() for all columnTypes
+            t.hasSearchIndex(colIndex);
         }
     }
 
@@ -381,17 +403,6 @@ private Table getTableWithSimpleData(){
         return table;
     }
 
-    public void testTableEquals() {
-
-        Table table1 = getTableWithSimpleData();
-        Table table2 = getTableWithSimpleData();
-
-        assertEquals(true, table1.equals(table2));
-        assertEquals(true, table1.equals(table1)); // Same table
-        assertEquals(false, table1.equals(null)); // Null object
-        assertEquals(false, table1.equals("String")); // Other object
-    }
-
     public void testColumnName() {
         Table t = new Table();
         try { t.addColumn(ColumnType.STRING, "I am 64 chracters..............................................."); fail("Only 63 chracters supported"); } catch (IllegalArgumentException e) { }
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
index 3106ea9625..a406446225 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -8,6 +8,8 @@
 import java.util.Arrays;
 import java.util.Date;
 
+import io.realm.Realm;
+import io.realm.TestHelper;
 import io.realm.exceptions.RealmException;
 
 public class JNITransactions extends AndroidTestCase {
@@ -255,7 +257,7 @@ public void testMustFailOnWriteInReadTransactions() {
         try { table.setBinaryByteArray(0,0,null);   fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setBoolean(0,0,false);          fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setDate(0,0,new Date(0));       fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setIndex(0);                    fail();} catch (IllegalStateException e) {assertNotNull(e);}
+        try { table.addSearchIndex(0);              fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setLong(0,0,0);                 fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setMixed(0,0,null);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setString(0,0,"");              fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -367,13 +369,23 @@ public void testAddEmptyRowWithPrimaryKeyString() {
         Table t = getTableWithStringPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
         assertEquals(1, t.size());
-        assertEquals("Foo", t.getRow(rowIndex).getString(0));
+        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
     }
 
     public void testAddEmptyRowWithPrimaryKeyLong() {
         Table t = getTableWithIntegerPrimaryKey();
         long rowIndex = t.addEmptyRowWithPrimaryKey(42);
         assertEquals(1, t.size());
-        assertEquals(42, t.getRow(rowIndex).getLong(0));
+        assertEquals(42, t.getUncheckedRow(rowIndex).getLong(0));
+    }
+
+    public void testPrimaryKeyTableMigration() throws IOException {
+        TestHelper.copyRealmFromAssets(getContext(), "080_annotationtypes.realm", "default.realm");
+        SharedGroup db = new SharedGroup(new File(getContext().getFilesDir(), Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
+        ImplicitTransaction tr = db.beginImplicitTransaction();
+        Table t = tr.getTable("class_AnnotationTypes");
+        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertTrue(t.hasPrimaryKey());
+        db.close();
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index 1c7a798993..5401792e45 100644
--- a/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -2,13 +2,6 @@
 
 import junit.framework.TestCase;
 
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-import io.realm.internal.test.DataProviderUtil;
-import io.realm.internal.test.TestHelper;
-
 public class TableIndexAndDistinctTest extends TestCase {
     Table table;
 
@@ -32,8 +25,8 @@ public void testShouldTestDistinct() {
         init();
 
         // Must set index before using distinct()
-        table.setIndex(1);
-        assertEquals(true, table.hasIndex(1));
+        table.addSearchIndex(1);
+        assertEquals(true, table.hasSearchIndex(1));
 
         TableView view = table.getDistinctView(1);
         assertEquals(4, view.size());
@@ -89,8 +82,8 @@ public void testShouldTestSettingIndexOnMultipleColumns() {
         t.add("row1", "row2", "row3", "row4", "row5");
 
         for (long c=0;c<t.getColumnCount();c++){
-            t.setIndex(c);
-            assertEquals(true, t.hasIndex(c));
+            t.addSearchIndex(c);
+            assertEquals(true, t.hasSearchIndex(c));
         }
     }
 
@@ -112,17 +105,17 @@ public void shouldTestIndexOnWrongColumnType(Long index) {
             throw new IllegalArgumentException();
         }
 
-        t.setIndex(index);
+        t.addSearchIndex(index);
     }*/
 
     public void testShouldCheckIndexIsOkOnColumn() {
         init();
-        table.setIndex(1);
+        table.addSearchIndex(1);
     }
 
     public void testShouldThrowDistinctErrorWhenWrongColumnType() {
         init();
-        table.setIndex(1);
+        table.addSearchIndex(1);
         try {
             TableView view = table.getDistinctView(0);
             fail();
@@ -148,5 +141,23 @@ public void testShouldThrowDistinctErrorWhenWrongColumnType() {
         List<?> mixedValues = Arrays.asList(values);
         return DataProviderUtil.allCombinations(mixedValues);
     }*/
+
+    public void testRemoveSearchIndex() {
+        init();
+        table.addSearchIndex(1);
+        assertEquals(true, table.hasSearchIndex(1));
+
+        table.removeSearchIndex(1);
+        assertEquals(false, table.hasSearchIndex(1));
+    }
+
+    public void testRemoveSearchIndexNoop() {
+        init();
+        assertEquals(false, table.hasSearchIndex(1));
+
+        // remove index from non-indexed column is a no-op
+        table.removeSearchIndex(1);
+        assertEquals(false, table.hasSearchIndex(1));
+    }
 }
 
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index 944fa3eacd..60c446fcee 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -16,7 +16,6 @@
 
 package io.realm;
 
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.os.Build;
@@ -24,7 +23,6 @@
 import android.os.Looper;
 import android.os.Message;
 import android.util.JsonReader;
-import android.util.Log;
 
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -35,19 +33,20 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.UUID;
+import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.exceptions.RealmException;
@@ -55,17 +54,19 @@
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnType;
+import io.realm.internal.FinalizerRunnable;
 import io.realm.internal.ImplicitTransaction;
-import io.realm.internal.RealmJson;
-import io.realm.internal.Row;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.UncheckedRow;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.Table;
 import io.realm.internal.TableView;
+import io.realm.internal.Util;
 import io.realm.internal.android.DebugAndroidLogger;
 import io.realm.internal.android.ReleaseAndroidLogger;
 import io.realm.internal.log.RealmLog;
 
-
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It
  * is in charge of creating instances of your RealmObjects. Objects within a Realm can be queried
@@ -122,34 +123,48 @@
 public final class Realm implements Closeable {
     public static final String DEFAULT_REALM_NAME = "default.realm";
 
-    private static final String TAG = "REALM";
-    private static final String TABLE_PREFIX = "class_";
-    protected static final ThreadLocal<Map<Integer, Realm>> realmsCache = new ThreadLocal<Map<Integer, Realm>>() {
-        @SuppressLint("UseSparseArrays")
+    // This single thread executor ensures that only one finalizer thread ever exists
+    private static final ExecutorService executorService = Executors.newSingleThreadExecutor();
+
+    // This does not need to be thread safe since it's only used in a synchronized method
+    private static volatile boolean isFinalizerStarted = false;
+
+    protected static final ThreadLocal<Map<RealmConfiguration, Realm>> realmsCache =
+            new ThreadLocal<Map<RealmConfiguration, Realm>>() {
         @Override
-        protected Map<Integer, Realm> initialValue() {
-            return new HashMap<Integer, Realm>(); // On Android we could use SparseArray<Realm> which is faster,
-                                                  // but incompatible with Java
+        protected Map<RealmConfiguration, Realm> initialValue() {
+            return new HashMap<RealmConfiguration, Realm>();
         }
     };
-    private static final ThreadLocal<Map<Integer, Integer>> referenceCount
-            = new ThreadLocal<Map<Integer,Integer>>() {
-        @SuppressLint("UseSparseArrays")
+
+    private static final ThreadLocal<Map<RealmConfiguration, Integer>> referenceCount =
+            new ThreadLocal<Map<RealmConfiguration,Integer>>() {
         @Override
-        protected Map<Integer, Integer> initialValue() {
-            return new HashMap<Integer, Integer>();
+        protected Map<RealmConfiguration, Integer> initialValue() {
+            return new HashMap<RealmConfiguration, Integer>();
         }
     };
+
+    // Map between all Realm file paths and all known configurations pointing to that file.
+    private static final Map<String, List<RealmConfiguration>> globalPathConfigurationCache =
+            new HashMap<String, List<RealmConfiguration>>();
+
+    // Map how many times a Realm path has been opened across all threads.
+    // This is only needed by deleteRealmFile.
+    private static final Map<String, AtomicInteger> globalOpenInstanceCounter =
+            new ConcurrentHashMap<String, AtomicInteger>();
+
+    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
     private static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
-    protected static final Map<Handler, Integer> handlers = new ConcurrentHashMap<Handler, Integer>();
 
-    // Maps ids to a boolean set to true if the Realm is open. This is only needed by deleteRealmFile
-    private static final Map<Integer, AtomicInteger> openRealms = new ConcurrentHashMap<Integer, AtomicInteger>();
-    private static final String APT_NOT_EXECUTED_MESSAGE = "Annotation processor may not have been executed.";
-    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they where created.";
+    private static RealmConfiguration defaultConfiguration;
+
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmObject>, Table> classToTable =
+            new HashMap<Class<? extends RealmObject>, Table>();
+
+    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
     private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
-    private static final String INVALID_KEY_MESSAGE = "The provided key is invalid. It should either be null or be 64" +
-            " bytes long.";
     private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
 
     @SuppressWarnings("UnusedDeclaration")
@@ -157,24 +172,14 @@
     private boolean autoRefresh;
     private Handler handler;
 
-    private final byte[] key;
-    private final int id;
-    private final String path;
+    private long threadId;
+    private RealmConfiguration configuration;
     private SharedGroup sharedGroup;
     private final ImplicitTransaction transaction;
-    private final RealmJson realmJson = getRealmJson();
-    private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>(); // Map between original class and their class name
-    private final Map<String, Class<?>> generatedClasses = new HashMap<String, Class<?>>(); // Map between generated class names and their implementation
-    private final Map<Class<?>, Constructor> constructors = new HashMap<Class<?>, Constructor>();
-    private final Map<Class<?>, Method> initTableMethods = new HashMap<Class<?>, Method>();
-    private final Map<Class<?>, Method> insertOrUpdateMethods = new HashMap<Class<?>, Method>();
-    private final Map<Class<?>, Constructor> generatedConstructors = new HashMap<Class<?>, Constructor>();
-
-    // Maps classes to the name of the proxied class. Examples: Dog.class -> Dog, DogRealmProxy -> Dog
-    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
-    private final List<RealmChangeListener> changeListeners = new ArrayList<RealmChangeListener>();
-    private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
-    private static final Set<Class<? extends RealmObject>> customSchema = new HashSet<Class<? extends RealmObject>>();
+
+    private final List<WeakReference<RealmChangeListener>> changeListeners =
+            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
+
     private static final long UNVERSIONED = -1;
 
     final ColumnIndices columnIndices = new ColumnIndices();
@@ -190,22 +195,17 @@ protected void checkIfValid() {
         }
 
         // Check if we are in the right thread
-        Realm currentRealm = realmsCache.get().get(this.id);
-        if (currentRealm != this) {
+        if (threadId != Thread.currentThread().getId()) {
             throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
         }
     }
 
     // The constructor in private to enforce the use of the static one
-    private Realm(String absolutePath, byte[] key, boolean autoRefresh) {
-        if (key != null && key.length != 64) {
-            throw new IllegalArgumentException(INVALID_KEY_MESSAGE);
-        }
-        this.sharedGroup = new SharedGroup(absolutePath, true, key);
+    private Realm(RealmConfiguration configuration, boolean autoRefresh) {
+        this.threadId = Thread.currentThread().getId();
+        this.configuration = configuration;
+        this.sharedGroup = new SharedGroup(configuration.getPath(), true, configuration.getEncryptionKey());
         this.transaction = sharedGroup.beginImplicitTransaction();
-        this.path = absolutePath;
-        this.key = key;
-        this.id = absolutePath.hashCode();
         setAutoRefresh(autoRefresh);
     }
 
@@ -213,7 +213,7 @@ private Realm(String absolutePath, byte[] key, boolean autoRefresh) {
     protected void finalize() throws Throwable {
         if (sharedGroup != null) {
             RealmLog.w("Remember to call close() on all Realm instances. " +
-                            "Realm " + path + " is being finalized without being closed, " +
+                            "Realm " + configuration.getPath() + " is being finalized without being closed, " +
                             "this can lead to running out of native memory."
             );
         }
@@ -223,29 +223,33 @@ protected void finalize() throws Throwable {
     /**
      * Closes the Realm instance and all its resources.
      * <p>
-     * It's important to always remember to close Realm instances when you're done with it in order 
+     * It's important to always remember to close Realm instances when you're done with it in order
      * not to leak memory, file descriptors or grow the size of Realm file out of measure.
      */
     @Override
     public void close() {
-        Map<Integer, Integer> localRefCount = referenceCount.get();
-        Integer references = localRefCount.get(id);
+        Map<RealmConfiguration, Integer> localRefCount = referenceCount.get();
+        String canonicalPath = configuration.getPath();
+        Integer references = localRefCount.get(configuration);
         if (references == null) {
             references = 0;
         }
         if (sharedGroup != null && references == 1) {
-            realmsCache.get().remove(id);
+            realmsCache.get().remove(configuration);
+            globalPathConfigurationCache.get(canonicalPath).remove(configuration);
             sharedGroup.close();
             sharedGroup = null;
-            AtomicInteger counter = openRealms.get(id);
-            counter.decrementAndGet();
+            AtomicInteger counter = globalOpenInstanceCounter.get(canonicalPath);
+            if (counter.decrementAndGet() == 0) {
+                globalOpenInstanceCounter.remove(canonicalPath);
+            }
         }
 
         int refCount = references - 1;
         if (refCount < 0) {
-            RealmLog.w("Calling close() on a Realm that is already closed: " + getPath());
+            RealmLog.w("Calling close() on a Realm that is already closed: " + canonicalPath);
         }
-        localRefCount.put(id, Math.max(0, refCount));
+        localRefCount.put(configuration, Math.max(0, refCount));
 
         if (handler != null && refCount <= 0) {
             removeHandler(handler);
@@ -257,24 +261,6 @@ private void removeHandler(Handler handler) {
         handlers.remove(handler);
     }
 
-    public RealmJson getRealmJson() {
-        Class<?> clazz;
-        try {
-            clazz = Class.forName("io.realm.RealmJsonImpl");
-            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
-            constructor.setAccessible(true);
-            return (RealmJson) constructor.newInstance();
-        } catch (ClassNotFoundException e) {
-            throw new RealmException("Could not find io.realm.RealmJsonImpl", e);
-        } catch (InvocationTargetException e) {
-            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
-        } catch (InstantiationException e) {
-            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
-        }
-    }
-
     private class RealmCallback implements Handler.Callback {
         @Override
         public boolean handleMessage(Message message) {
@@ -297,9 +283,9 @@ public boolean isAutoRefresh() {
     /**
      * Set the auto-refresh status of the Realm instance.
      * <p>
-     * Auto-refresh is a feature that enables automatic update of the current realm instance and all its derived objects
+     * Auto-refresh is a feature that enables automatic update of the current Realm instance and all its derived objects
      * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in another thread.
-     * This feature is only available if the realm instance lives is a {@link android.os.Looper} enabled thread.
+     * This feature is only available if the Realm instance lives is a {@link android.os.Looper} enabled thread.
      *
      * @param autoRefresh true will turn auto-refresh on, false will turn it off.
      * @throws java.lang.IllegalStateException if trying to enable auto-refresh in a thread without Looper.
@@ -311,7 +297,7 @@ public void setAutoRefresh(boolean autoRefresh) {
 
         if (autoRefresh && !this.autoRefresh) { // Switch it on
             handler = new Handler(new RealmCallback());
-            handlers.put(handler, id);
+            handlers.put(handler, configuration.getPath());
         } else if (!autoRefresh && this.autoRefresh && handler != null) { // Switch it off
             removeHandler(handler);
         }
@@ -319,23 +305,24 @@ public void setAutoRefresh(boolean autoRefresh) {
     }
 
     // Public because of migrations
-    public Table getTable(Class<?> clazz) {
-        final String proxySuffix = "RealmProxy";
-        String proxiedClassName = proxiedClassNames.get(clazz);
-        if (proxiedClassName == null) {
-            String classSimpleName = clazz.getSimpleName();
-            proxiedClassName = classSimpleName.replace(proxySuffix, "");
-            proxiedClassNames.put(clazz, proxiedClassName);
+    public Table getTable(Class<? extends RealmObject> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table == null) {
+            clazz = Util.getOriginalModelClass(clazz);
+            table = transaction.getTable(configuration.getSchemaMediator().getTableName(clazz));
+            classToTable.put(clazz, table);
         }
-        return transaction.getTable(TABLE_PREFIX + proxiedClassName);
+        return table;
     }
 
     /**
-     * Realm static constructor for the default realm "default.realm".
+     * Realm static constructor for the default Realm "default.realm".
      * {@link #close()} must be called when you are done using the Realm instance.
      * <p>
      * It sets auto-refresh on if the current thread has a Looper, off otherwise.
      *
+     * This is equivalent to calling {@code Realm.getInstance(new RealmConfiguration(getContext()).build()) }.
+
      * @param context an Android {@link android.content.Context}
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
@@ -361,7 +348,7 @@ public static Realm getInstance(Context context) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
-    @SuppressWarnings("UnusedDeclaration")
+    @Deprecated
     public static Realm getInstance(Context context, String fileName) {
         return Realm.getInstance(context, fileName, null);
     }
@@ -380,7 +367,7 @@ public static Realm getInstance(Context context, String fileName) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
-    @SuppressWarnings("UnusedDeclaration")
+    @Deprecated
     public static Realm getInstance(Context context, byte[] key) {
         return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
     }
@@ -399,9 +386,14 @@ public static Realm getInstance(Context context, byte[] key) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
-    @SuppressWarnings("UnusedDeclaration")
+    @Deprecated
     public static Realm getInstance(Context context, String fileName, byte[] key) {
-        return Realm.create(context.getFilesDir(), fileName, key);
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context).name(fileName);
+        if (key != null) {
+            builder.encryptionKey(key);
+        }
+
+        return create(builder.build());
     }
 
     /**
@@ -410,16 +402,20 @@ public static Realm getInstance(Context context, String fileName, byte[] key) {
      * <p>
      * It sets auto-refresh on if the current thread has a Looper, off otherwise.
      *
-     * @param writeableFolder a File object representing a writeable folder
+     * @param writableFolder a File object representing a writable folder
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
      *                                       must be migrated
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
+    @Deprecated
     @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder) {
-        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, null);
+    public static Realm getInstance(File writableFolder) {
+        return create(new RealmConfiguration.Builder(writableFolder)
+                        .name(DEFAULT_REALM_NAME)
+                        .build()
+        );
     }
 
     /**
@@ -427,7 +423,7 @@ public static Realm getInstance(File writeableFolder) {
      * {@link #close()}
      * It sets auto-refresh on if the current thread has a Looper, off otherwise.
      *
-     * @param writeableFolder a File object representing a writeable folder
+     * @param writableFolder a File object representing a writable folder
      * @param fileName the name of the Realm file
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
@@ -435,9 +431,13 @@ public static Realm getInstance(File writeableFolder) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
+    @Deprecated
     @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, String fileName) {
-        return Realm.create(writeableFolder, fileName, null);
+    public static Realm getInstance(File writableFolder, String fileName) {
+        return create(new RealmConfiguration.Builder(writableFolder)
+                        .name(fileName)
+                        .build()
+        );
     }
 
     /**
@@ -446,7 +446,7 @@ public static Realm getInstance(File writeableFolder, String fileName) {
      * <p>
      * It sets auto-refresh on if the current thread has a Looper, off otherwise.
      *
-     * @param writeableFolder a File object representing a writeable folder
+     * @param writableFolder a File object representing a writable folder
      * @param key     a 64-byte encryption key
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException The model classes have been changed and the Realm
@@ -454,9 +454,14 @@ public static Realm getInstance(File writeableFolder, String fileName) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
+    @Deprecated
     @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, byte[] key) {
-        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, key);
+    public static Realm getInstance(File writableFolder, byte[] key) {
+        return create(new RealmConfiguration.Builder(writableFolder)
+                        .name(DEFAULT_REALM_NAME)
+                        .encryptionKey(key)
+                        .build()
+        );
     }
 
     /**
@@ -465,7 +470,7 @@ public static Realm getInstance(File writeableFolder, byte[] key) {
      * <p>
      * It sets auto-refresh on if the current thread has a Looper, off otherwise.
      *
-     * @param writeableFolder a File object representing a writeable folder
+     * @param writableFolder a File object representing a writable folder
      * @param fileName the name of the Realm file
      * @param key     a 64-byte encryption key
      * @return an instance of the Realm class
@@ -474,57 +479,136 @@ public static Realm getInstance(File writeableFolder, byte[] key) {
      * @throws RealmIOException              Error when accessing underlying file
      * @throws RealmException                Other errors
      */
+    @Deprecated
     @SuppressWarnings("UnusedDeclaration")
-    public static Realm getInstance(File writeableFolder, String fileName, byte[] key) {
-        return Realm.create(writeableFolder, fileName, key);
+    public static Realm getInstance(File writableFolder, String fileName, byte[] key) {
+        return create(new RealmConfiguration.Builder(writableFolder)
+                        .name(fileName)
+                        .encryptionKey(key)
+                        .build()
+        );
     }
 
-    private static Realm create(File writableFolder, String filename, byte[] key) {
-        checkValidRealmPath(writableFolder, filename);
-        String absolutePath = new File(writableFolder, filename).getAbsolutePath();
-        if (Looper.myLooper() != null) {
-            return createAndValidate(absolutePath, key, true, true);
-        } else {
-            return createAndValidate(absolutePath, key, true, false);
+    /**
+     * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
+     * by {@link #setDefaultConfiguration(RealmConfiguration)}
+     *
+     * @return an instance of the Realm class
+     *
+     * @throws java.lang.NullPointerException If no default configuration has been defined.
+     * @throws RealmMigrationNeededException If no migration has been provided by the default configuration and the
+     * model classes or version has has changed so a migration is required.
+     */
+    public static Realm getDefaultInstance() {
+        if (defaultConfiguration == null) {
+            throw new NullPointerException("No default RealmConfiguration was found. Call setDefaultConfiguration() first");
+        }
+        return create(defaultConfiguration);
+    }
+
+    /**
+     * Realm static constructor that returns the Realm instance defined by provided {@link io.realm.RealmConfiguration}
+     *
+     * @return an instance of the Realm class
+     *
+     * @throws RealmMigrationNeededException If no migration has been provided by the configuration and the
+     * model classes or version has has changed so a migration is required.
+     * @see RealmConfiguration for details on how to configure a Realm.
+     */
+    public static Realm getInstance(RealmConfiguration configuration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
         }
+        return create(configuration);
     }
 
-    private static synchronized Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema,
-                                                        boolean autoRefresh) {
-        // Check thread local cache for existing Realm
-        int id = absolutePath.hashCode();
-        Map<Integer, Integer> localRefCount = referenceCount.get();
-        Integer references = localRefCount.get(id);
+    /**
+     * Sets the {@link io.realm.RealmConfiguration} used when calling {@link #getDefaultInstance()}.
+     *
+     * @param configuration RealmConfiguration to use as the default configuration.
+     * @see RealmConfiguration for details on how to configure a Realm.
+     */
+    public static void setDefaultConfiguration(RealmConfiguration configuration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+        }
+        defaultConfiguration = configuration;
+    }
+
+    /**
+     * Removes the current default configuration (if any). Any further calls to {@link #getDefaultInstance()} will
+     * fail until a new default configuration has been set using {@link #setDefaultConfiguration(RealmConfiguration)}.
+     */
+    public static void removeDefaultConfiguration() {
+        defaultConfiguration = null;
+    }
+
+    private static Realm create(RealmConfiguration configuration) {
+        boolean autoRefresh = Looper.myLooper() != null;
+        try {
+            return createAndValidate(configuration, true, autoRefresh);
+        } catch (RealmMigrationNeededException e) {
+            if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
+                deleteRealm(configuration);
+            } else {
+                migrateRealm(configuration);
+            }
+
+            return createAndValidate(configuration, true, autoRefresh);
+        }
+    }
+
+    private static synchronized Realm createAndValidate(RealmConfiguration configuration, boolean validateSchema, boolean autoRefresh) {
+        // Start the finalizer thread if needed
+        if (!isFinalizerStarted) {
+            executorService.submit(new FinalizerRunnable());
+            isFinalizerStarted = true;
+        }
+
+        // Check if a cached instance already exists for this thread
+        String canonicalPath = configuration.getPath();
+        Map<RealmConfiguration, Integer> localRefCount = referenceCount.get();
+        Integer references = localRefCount.get(configuration);
         if (references == null) {
             references = 0;
         }
-        Map<Integer, Realm> realms = realmsCache.get();
-        Realm realm = realms.get(absolutePath.hashCode());
+        Map<RealmConfiguration, Realm> realms = realmsCache.get();
+        Realm realm = realms.get(configuration);
         if (realm != null) {
-            if (!Arrays.equals(realm.key, key)) {
-                throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
-            }
-            localRefCount.put(id, references + 1);
+            localRefCount.put(configuration, references + 1);
             return realm;
         }
 
-        // Create new Realm and cache it. All exception code paths must close the Realm otherwise
-        // we risk serving faulty cache data.
-        realm = new Realm(absolutePath, key, autoRefresh);
-        realms.put(absolutePath.hashCode(), realm);
-        realmsCache.set(realms);
-        localRefCount.put(id, references + 1);
+
+        // Create new Realm and cache it. All exception code paths must close the Realm otherwise we risk serving
+        // faulty cache data.
+        validateAgainstExistingConfigurations(configuration);
+        realm = new Realm(configuration, autoRefresh);
+        realms.put(configuration, realm);
+        localRefCount.put(configuration, references + 1);
 
         // Increment global reference counter
         if (references == 0) {
-            AtomicInteger counter = openRealms.get(id);
+            AtomicInteger counter = globalOpenInstanceCounter.get(canonicalPath);
             if (counter == null) {
-                openRealms.put(id, new AtomicInteger(1));
+                globalOpenInstanceCounter.put(canonicalPath, new AtomicInteger(1));
             } else {
                 counter.incrementAndGet();
             }
         }
 
+        // Check versions of Realm
+        long currentVersion = realm.getVersion();
+        long requiredVersion = configuration.getSchemaVersion();
+        if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && validateSchema) {
+            realm.close();
+            throw new RealmMigrationNeededException(canonicalPath, String.format("Realm on disc need to migrate from v%s to v%s", currentVersion, requiredVersion));
+        }
+        if (currentVersion != UNVERSIONED && requiredVersion < currentVersion && validateSchema) {
+            realm.close();
+            throw new IllegalArgumentException(String.format("Realm on disc is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
+		}
+
         // Initialize Realm schema if needed
         if (validateSchema) {
             try {
@@ -538,116 +622,66 @@ private static synchronized Realm createAndValidate(String absolutePath, byte[]
         return realm;
     }
 
-    private static void checkValidRealmPath(File writableFolder, String filename) {
-        if (filename == null || filename.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty filename must be provided");
-        }
-        if (writableFolder == null || !writableFolder.isDirectory()) {
-            throw new IllegalArgumentException(("An existing folder must be provided. Yours was " + (writableFolder != null ? writableFolder.getAbsolutePath() : "null")));
-        }
-    }
+    // Make sure that the new configuration doesn't clash with any existing configurations for the Realm
+    private static void validateAgainstExistingConfigurations(RealmConfiguration newConfiguration) {
 
-    @SuppressWarnings("unchecked")
-    private static void initializeRealm(Realm realm) {
-        Class<?> validationClass;
-        try {
-            validationClass = Class.forName("io.realm.ValidationList");
-        } catch (ClassNotFoundException e) {
-            throw new RealmException("Could not find the generated ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
-        }
-        Method getProxyClassesMethod;
-        try {
-            getProxyClassesMethod = validationClass.getMethod("getProxyClasses");
-        } catch (NoSuchMethodException e) {
-            throw new RealmException("Could not find the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
-        }
-        List<String> proxyClasses;
-        try {
-            proxyClasses = (List<String>) getProxyClassesMethod.invoke(null);
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not execute the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
-        } catch (InvocationTargetException e) {
-            throw new RealmException("An exception was thrown in the getProxyClasses method in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
+        // Ensure cache state
+        String realmPath = newConfiguration.getPath();
+        List<RealmConfiguration> pathConfigurationCache = globalPathConfigurationCache.get(realmPath);
+        if (pathConfigurationCache == null) {
+            pathConfigurationCache = new CopyOnWriteArrayList<RealmConfiguration>();
+            globalPathConfigurationCache.put(realmPath, pathConfigurationCache);
         }
 
-        // Custom schema overrides any schema already defined
-        if (customSchema.size() > 0) {
-            proxyClasses = new ArrayList<String>();
-            for (Class<? extends RealmObject> clazz : customSchema) {
-                proxyClasses.add(clazz.getName());
+        if (pathConfigurationCache.size() > 0) {
+
+            // For the current restrictions, it is enough to just check one of the existing configurations.
+            RealmConfiguration cachedConfiguration = pathConfigurationCache.get(0);
+
+            // Check that encryption keys aren't different
+            if (!Arrays.equals(cachedConfiguration.getEncryptionKey(), newConfiguration.getEncryptionKey())) {
+                throw new IllegalArgumentException(DIFFERENT_KEY_MESSAGE);
+            }
+
+            // Check schema versions are the same
+            if (cachedConfiguration.getSchemaVersion() != newConfiguration.getSchemaVersion()) {
+                throw new IllegalArgumentException(String.format("Configurations cannot have different schema versions " +
+                                "if used to open the same file. %d vs. %d", cachedConfiguration.getSchemaVersion(),
+                        newConfiguration.getSchemaVersion()));
+            }
+
+            // Check that schema is the same
+            RealmProxyMediator cachedSchema = cachedConfiguration.getSchemaMediator();
+            RealmProxyMediator schema = newConfiguration.getSchemaMediator();
+            if (!cachedSchema.equals(schema)) {
+                throw new IllegalArgumentException("Two configurations with different schemas are trying to open " +
+                        "the same Realm file. Their schema must be the same: " + newConfiguration.getPath());
             }
         }
 
+        // The new configuration doesn't violate existing configurations. Cache it.
+        pathConfigurationCache.add(newConfiguration);
+    }
+
+    @SuppressWarnings("unchecked")
+    private static void initializeRealm(Realm realm) {
         long version = realm.getVersion();
         boolean commitNeeded = false;
         try {
             realm.beginTransaction();
             if (version == UNVERSIONED) {
-                realm.setVersion(0);
                 commitNeeded = true;
+                realm.setVersion(realm.configuration.getSchemaVersion());
             }
 
-            for (String className : proxyClasses) {
-                String[] splitted = className.split("\\.");
-                String modelClassName = splitted[splitted.length - 1];
-                String generatedClassName = getProxyClassName(modelClassName);
-                Class<?> generatedClass;
-                try {
-                    generatedClass = Class.forName(generatedClassName);
-                } catch (ClassNotFoundException e) {
-                    throw new RealmException("Could not find the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-
-                // if not versioned, create table
+            RealmProxyMediator mediator = realm.configuration.getSchemaMediator();
+            for (Class<? extends RealmObject> modelClass : mediator.getModelClasses()) {
+                // Create and validate table
                 if (version == UNVERSIONED) {
-                    Method initTableMethod;
-                    try {
-                        initTableMethod = generatedClass.getMethod("initTable", new Class[]{ImplicitTransaction.class});
-                    } catch (NoSuchMethodException e) {
-                        throw new RealmException("Could not find the initTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                    }
-                    try {
-                        initTableMethod.invoke(null, realm.transaction);
-                        commitNeeded = true;
-                    } catch (IllegalAccessException e) {
-                        throw new RealmException("Could not execute the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                    } catch (InvocationTargetException e) {
-                        throw new RealmException("An exception was thrown in the initTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                    }
-                }
-
-                // validate created table
-                Method validateMethod;
-                try {
-                    validateMethod = generatedClass.getMethod("validateTable", new Class[]{ImplicitTransaction.class});
-                } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the validateTable method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                try {
-                    validateMethod.invoke(null, realm.transaction);
-                } catch (IllegalAccessException e) {
-                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                } catch (InvocationTargetException e) {
-                    throw new RealmMigrationNeededException(e.getMessage(), e);
+                    mediator.createTable(modelClass, realm.transaction);
                 }
-
-                // Populate the columnIndices table
-                Method columnIndiciesMethod;
-                try {
-                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
-                } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                Map<String,Long> indices;
-                try {
-                    //noinspection unchecked
-                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
-                } catch (IllegalAccessException e) {
-                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
-                } catch (InvocationTargetException e) {
-                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
-                }
-                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
+                mediator.validateTable(modelClass, realm.transaction);
+                realm.columnIndices.addClass(modelClass, mediator.getColumnIndices(modelClass));
             }
         } finally {
             if (commitNeeded) {
@@ -674,9 +708,8 @@ private static void initializeRealm(Realm realm) {
         }
 
         for (int i = 0; i < json.length(); i++) {
-            E obj = createObject(clazz);
             try {
-                realmJson.populateUsingJsonObject(obj, json.getJSONObject(i));
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
             } catch (Exception e) {
                 throw new RealmException("Could not map Json", e);
             }
@@ -699,12 +732,9 @@ private static void initializeRealm(Realm realm) {
             return;
         }
         checkHasPrimaryKey(clazz);
-
         for (int i = 0; i < json.length(); i++) {
-            E obj = createStandaloneRealmObjectInstance(clazz);
             try {
-                realmJson.populateUsingJsonObject(obj, json.getJSONObject(i));
-                copyToRealmOrUpdate(obj);
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
             } catch (Exception e) {
                 throw new RealmException("Could not map Json", e);
             }
@@ -785,8 +815,7 @@ private static void initializeRealm(Realm realm) {
         try {
             reader.beginArray();
             while (reader.hasNext()) {
-                E obj = createObject(clazz);
-                realmJson.populateUsingJsonStream(obj, reader);
+                configuration.getSchemaMediator().createUsingJsonStream(clazz, this, reader);
             }
             reader.endArray();
         } finally {
@@ -812,22 +841,26 @@ private static void initializeRealm(Realm realm) {
         }
         checkHasPrimaryKey(clazz);
 
-        JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
         try {
-            reader.beginArray();
-            while (reader.hasNext()) {
-                E obj = createStandaloneRealmObjectInstance(clazz);
-                realmJson.populateUsingJsonStream(obj, reader);
-                copyToRealmOrUpdate(obj);
+            scanner = getFullStringScanner(in);
+            JSONArray json = new JSONArray(scanner.next());
+            for (int i = 0; i < json.length(); i++) {
+                configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
             }
-            reader.endArray();
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
         } finally {
-            reader.close();
+            if (scanner != null) {
+                scanner.close();
+            }
         }
     }
 
     /**
-     * Create a Realm object prefilled with data from a JSON object. This must be done inside a
+     * Create a Realm object pre-filled with data from a JSON object. This must be done inside a
      * transaction. JSON properties with a null value will map to the default value for the data
      * type in Realm and unknown properties will be ignored.
      *
@@ -843,14 +876,11 @@ private static void initializeRealm(Realm realm) {
             return null;
         }
 
-        E obj = createObject(clazz);
         try {
-            realmJson.populateUsingJsonObject(obj, json);
+            return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, false);
         } catch (Exception e) {
             throw new RealmException("Could not map Json", e);
         }
-
-        return obj;
     }
 
     /**
@@ -869,21 +899,15 @@ private static void initializeRealm(Realm realm) {
             return null;
         }
         checkHasPrimaryKey(clazz);
-
-        E obj = createStandaloneRealmObjectInstance(clazz);
-
         try {
-            realmJson.populateUsingJsonObject(obj, json);
-            copyToRealmOrUpdate(obj);
+            return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
         } catch (JSONException e) {
             throw new RealmException("Could not map Json", e);
         }
-
-        return obj;
     }
 
     /**
-     * Create a Realm object prefilled with data from a JSON object. This must be done inside a
+     * Create a Realm object pre-filled with data from a JSON object. This must be done inside a
      * transaction. JSON properties with a null value will map to the default value for the data
      * type in Realm and unknown properties will be ignored.
      *
@@ -918,7 +942,7 @@ private static void initializeRealm(Realm realm) {
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
      * {@link io.realm.annotations.PrimaryKey}.
      *
-     * @see #createObjectFromJson(Class, String) 
+     * @see #createObjectFromJson(Class, String)
      */
     public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
@@ -956,9 +980,7 @@ private static void initializeRealm(Realm realm) {
 
         JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
         try {
-            E obj = createObject(clazz);
-            realmJson.populateUsingJsonStream(obj, reader);
-            return obj;
+            return configuration.getSchemaMediator().createUsingJsonStream(clazz, this, reader);
         } finally {
             reader.close();
         }
@@ -969,7 +991,7 @@ private static void initializeRealm(Realm realm) {
      * found a new object will be saved in the Realm. This must happen within a transaction.
      *
      * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
-     * @param in    Inputstream with object data in JSON format.
+     * @param in    {@link InputStream} with object data in JSON format.
      * @return Created or updated {@link io.realm.RealmObject}.
      * @throws java.lang.IllegalArgumentException if trying to update a class without a
      * {@link io.realm.annotations.PrimaryKey}.
@@ -982,26 +1004,24 @@ private static void initializeRealm(Realm realm) {
         }
         checkHasPrimaryKey(clazz);
 
-        E obj = createStandaloneRealmObjectInstance(clazz);
-        JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+        // As we need the primary key value we have to first parse the entire input stream as in the general
+        // case that value might be the last property :(
+        Scanner scanner = null;
         try {
-            realmJson.populateUsingJsonStream(obj, reader);
-            copyToRealmOrUpdate(obj);
-        } catch (RuntimeException e) {
-            throw new RealmException("Could not create Json object from string", e);
+            scanner = getFullStringScanner(in);
+            JSONObject json = new JSONObject(scanner.next());
+            return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
+        } catch (JSONException e) {
+            throw new RealmException("Failed to read JSON", e);
+        } finally {
+            if (scanner != null) {
+                scanner.close();
+            }
         }
-
-        return obj;
     }
 
-    private <E extends RealmObject> E createStandaloneRealmObjectInstance(Class<E> clazz) {
-        try {
-            return clazz.newInstance();
-        } catch (InstantiationException e) {
-            throw new RealmException("Could not create an object of class: " + clazz, e);
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not create an object of class: " + clazz, e);
-        }
+    private Scanner getFullStringScanner(InputStream in) {
+        return new Scanner(in, "UTF-8").useDelimiter("\\A");
     }
 
     /**
@@ -1040,14 +1060,14 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
 
     /**
-     * Instantiates and adds a new object to the realm
+     * Instantiates and adds a new object to the Realm.
      *
      * @param clazz The Class of the object to create
      * @return The new object
      * @throws RealmException An object could not be created
      */
     public <E extends RealmObject> E createObject(Class<E> clazz) {
-        Table table = initTable(clazz);
+        Table table = getTable(clazz);
         long rowIndex = table.addEmptyRow();
         return get(clazz, rowIndex);
     }
@@ -1063,113 +1083,19 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      * @throws {@link RealmException} if object could not be created.
      */
     <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
-        Table table = initTable(clazz);
+        Table table = getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         return get(clazz, rowIndex);
     }
 
-    private <E extends RealmObject> Table initTable(Class<E> clazz) {
-        Table table = tables.get(clazz);
-        if (table == null) {
-            Class<?> generatedClass = getProxyClass(clazz);
-
-            Method method = initTableMethods.get(generatedClass);
-            if (method == null) {
-                try {
-                    method = generatedClass.getMethod("initTable", new Class[]{ImplicitTransaction.class});
-                } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the initTable() method in generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                initTableMethods.put(generatedClass, method);
-            }
-
-            try {
-                table = (Table) method.invoke(null, transaction);
-                tables.put(clazz, table);
-            } catch (IllegalAccessException e) {
-                throw new RealmException("Could not launch the initTable method: " + APT_NOT_EXECUTED_MESSAGE);
-            } catch (InvocationTargetException e) {
-                e.printStackTrace();
-                throw new RealmException("An exception occurred while running the initTable method: " + APT_NOT_EXECUTED_MESSAGE);
-            }
-        }
-
-        return table;
-    }
-
-    private Class<?> getProxyClass(Class<?> clazz) {
-
-        String simpleClassName = getClassSimpleName(clazz);
-        String generatedClassName = getProxyClassName(simpleClassName);
-
-        Class<?> generatedClass = generatedClasses.get(generatedClassName);
-        if (generatedClass == null) {
-            try {
-                generatedClass = Class.forName(generatedClassName);
-            } catch (ClassNotFoundException e) {
-                throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
-            }
-            generatedClasses.put(generatedClassName, generatedClass);
-        }
-
-        return generatedClass;
-    }
-
-    <E> void remove(Class<E> clazz, long objectIndex) {
+    void remove(Class<? extends RealmObject> clazz, long objectIndex) {
         getTable(clazz).moveLastOver(objectIndex);
     }
 
-    @SuppressWarnings("unchecked")
     <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
-        E result;
-
-        Table table = tables.get(clazz);
-        if (table == null) {
-            String simpleClassName = getClassSimpleName(clazz);
-            table = transaction.getTable(TABLE_PREFIX + simpleClassName);
-            tables.put(clazz, table);
-        }
-
-        Row row = table.getRow(rowIndex);
-
-        Constructor constructor = generatedConstructors.get(clazz);
-        if (constructor == null) {
-            String simpleClassName = getClassSimpleName(clazz);
-            String generatedClassName = getProxyClassName(simpleClassName);
-
-            Class<?> generatedClass = generatedClasses.get(generatedClassName);
-            if (generatedClass == null) {
-                try {
-                    generatedClass = Class.forName(generatedClassName);
-                } catch (ClassNotFoundException e) {
-                    throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                generatedClasses.put(generatedClassName, generatedClass);
-            }
-
-            constructor = constructors.get(generatedClass);
-            if (constructor == null) {
-                try {
-                    constructor = generatedClass.getConstructor();
-                } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the constructor in generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                constructors.put(generatedClass, constructor);
-                generatedConstructors.put(clazz, constructor);
-            }
-        }
-
-        try {
-            // We are know the casted type since we generated the class
-            result = (E) constructor.newInstance();
-        } catch (InstantiationException e) {
-            throw new RealmException("Could not instantiate the proxy class");
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not run the constructor of the proxy class");
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-            throw new RealmException("An exception occurred while instantiating the proxy class");
-        }
+        Table table = getTable(clazz);
+        UncheckedRow row = table.getUncheckedRow(rowIndex);
+        E result = configuration.getSchemaMediator().newInstance(clazz);
         result.row = row;
         result.realm = this;
         return result;
@@ -1177,7 +1103,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
     /**
      * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
-     * will not be reflected in the Realm copy.
+     * will not be reflected in the Realm copy. This is a deep copy, so all referenced objects will be copied. Objects
+     * already in this Realm will be ignored.
      *
      * @param object {@link io.realm.RealmObject} to copy to the Realm.
      * @return A managed RealmObject with its properties backed by the Realm.
@@ -1191,7 +1118,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
     /**
      * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or create
-     * a new copy if no existing object could be found.
+     * a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * either copied or updated.
      *
      * @param object    {@link io.realm.RealmObject} to copy or update.
      * @return The new or updated RealmObject with all its properties backed by the Realm.
@@ -1201,13 +1129,14 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      */
     public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
-        checkHasPrimaryKey(object);
+        checkHasPrimaryKey(object.getClass());
         return copyOrUpdate(object, true);
     }
 
     /**
      * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes
-     * to the original RealmObjects will not be reflected in the Realm copies.
+     * to the original RealmObjects will not be reflected in the Realm copies. This is a deep copy, so all referenced
+     * objects will be copied. Objects already in this Realm will be ignored.
      *
      * @param objects RealmObjects to copy to the Realm.
      * @return A list of the the converted RealmObjects that all has their properties managed by the Realm.
@@ -1230,7 +1159,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or create a
-     * new copy if no existing object could be found.
+     * new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * either copied or updated.
      *
      * @param objects   List of objects to update or copy into Realm.
      * @return A list of all the new or updated RealmObjects.
@@ -1251,12 +1181,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
         return realmObjects;
     }
 
-    private static String getProxyClassName(String simpleClassName) {
-        return "io.realm." + simpleClassName + "RealmProxy";
-    }
-
-    boolean contains(Class<?> clazz) {
-        return transaction.hasTable(TABLE_PREFIX + getClassSimpleName(clazz));
+    boolean contains(Class<? extends RealmObject> clazz) {
+        return configuration.getSchemaMediator().getModelClasses().contains(clazz);
     }
 
     /**
@@ -1296,7 +1222,7 @@ boolean contains(Class<?> clazz) {
      * @throws java.lang.IllegalArgumentException if field name does not exist.
      */
     public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
-                                                               boolean sortAscending) {
+                                                                    boolean sortAscending) {
         checkIfValid();
         Table table = getTable(clazz);
         TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
@@ -1325,8 +1251,8 @@ boolean contains(Class<?> clazz) {
      */
     public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                boolean sortAscending1, String fieldName2,
-                                                               boolean sortAscending2) {
-        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2}, new boolean[] {sortAscending1,
+                                                                    boolean sortAscending2) {
+        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new boolean[]{sortAscending1,
                 sortAscending2});
     }
 
@@ -1346,11 +1272,11 @@ boolean contains(Class<?> clazz) {
      * @throws java.lang.IllegalArgumentException if a field name does not exist.
      */
     public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                               boolean sortAscending1,
-                                                              String fieldName2, boolean sortAscending2,
-                                                              String fieldName3, boolean sortAscending3) {
-        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2, fieldName3},
-                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
+                                                                    boolean sortAscending1,
+                                                                    String fieldName2, boolean sortAscending2,
+                                                                    String fieldName3, boolean sortAscending3) {
+        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2, fieldName3},
+                new boolean[]{sortAscending1, sortAscending2, sortAscending3});
     }
 
     /**
@@ -1360,14 +1286,14 @@ boolean contains(Class<?> clazz) {
      *
      * @param clazz the Class to get objects of.
      * @param sortAscending sort ascending if SORT_ORDER_ASCENDING, sort descending if SORT_ORDER_DESCENDING.
-     * @param fieldNames an array of fieldnames to sort objects by.
+     * @param fieldNames an array of field names to sort objects by.
      *        The objects are first sorted by fieldNames[0], then by fieldNames[1] and so forth.
      * @return A sorted RealmResults containing the objects.
      * @throws java.lang.IllegalArgumentException if a field name does not exist.
      */
     @SuppressWarnings("unchecked")
     public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
-                                                               boolean sortAscending[]) {
+                                                                    boolean sortAscending[]) {
         if (fieldNames == null) {
             throw new IllegalArgumentException("fieldNames must be provided.");
         } else if (sortAscending == null) {
@@ -1385,7 +1311,7 @@ boolean contains(Class<?> clazz) {
             }
             columnIndices[i] = columnIndex;
         }
-        
+
         // Perform sort
         TableView tableView = table.getSortedView(columnIndices, sortAscending);
         return new RealmResults(this, tableView, clazz);
@@ -1401,7 +1327,14 @@ boolean contains(Class<?> clazz) {
      */
     public void addChangeListener(RealmChangeListener listener) {
         checkIfValid();
-        changeListeners.add(listener);
+        for (WeakReference<RealmChangeListener> ref : changeListeners) {
+            if (ref.get() == listener) {
+                // It has already been added before
+                return;
+            }
+        }
+
+        changeListeners.add(new WeakReference<RealmChangeListener>(listener));
     }
 
     /**
@@ -1412,7 +1345,17 @@ public void addChangeListener(RealmChangeListener listener) {
      */
     public void removeChangeListener(RealmChangeListener listener) {
         checkIfValid();
-        changeListeners.remove(listener);
+        WeakReference<RealmChangeListener> weakRefToRemove = null;
+        for (WeakReference<RealmChangeListener> weakRef : changeListeners) {
+            if (listener == weakRef.get()) {
+                weakRefToRemove = weakRef;
+                // There won't be duplicated entries, checking is done when adding
+                break;
+            }
+        }
+        if (weakRefToRemove != null) {
+            changeListeners.remove(weakRefToRemove);
+        }
     }
 
     /**
@@ -1425,10 +1368,33 @@ public void removeAllChangeListeners() {
         changeListeners.clear();
     }
 
-    void sendNotifications() {
-        List<RealmChangeListener> defensiveCopy = new ArrayList<RealmChangeListener>(changeListeners);
-        for (RealmChangeListener listener : defensiveCopy) {
-            listener.onChange();
+    /**
+     * Return change listeners
+     * For internal testing purpose only
+     *
+     * @return changeListeners list of this realm instance
+     */
+    protected List<WeakReference<RealmChangeListener>> getChangeListeners() {
+        return changeListeners;
+    }
+
+    private void sendNotifications() {
+        Iterator<WeakReference<RealmChangeListener>> iterator = changeListeners.iterator();
+        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+        while (iterator.hasNext()) {
+            WeakReference<RealmChangeListener> weakRef = iterator.next();
+            RealmChangeListener listener = weakRef.get();
+            if (listener == null) {
+                if (toRemoveList == null) {
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(changeListeners.size());
+                }
+                toRemoveList.add(weakRef);
+            } else {
+                listener.onChange();
+            }
+        }
+        if (toRemoveList != null) {
+            changeListeners.removeAll(toRemoveList);
         }
     }
 
@@ -1471,47 +1437,53 @@ public void beginTransaction() {
 
     /**
      * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the
-     * realm reverts back to being read-only. An event is sent to notify all other realm instances
-     * that a change has occurred. When the event is received, the other realms will get their
+     * Realm reverts back to being read-only. An event is sent to notify all other realm instances
+     * that a change has occurred. When the event is received, the other Realms will get their
      * objects and {@link io.realm.RealmResults} updated to reflect
      * the changes from this commit.
-     * 
+     *
      * @throws java.lang.IllegalStateException If the write transaction is in an invalid state or incorrect thread.
      */
     public void commitTransaction() {
         checkIfValid();
         transaction.commitAndContinueAsRead();
 
-        for (Map.Entry<Handler, Integer> handlerIntegerEntry : handlers.entrySet()) {
+        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
             Handler handler = handlerIntegerEntry.getKey();
-            int realmId = handlerIntegerEntry.getValue();
+            String realmPath = handlerIntegerEntry.getValue();
+
+            // Notify at once on thread doing the commit
+            if (handler.equals(this.handler)) {
+                sendNotifications();
+                continue;
+            }
+
+            // For all other threads, use the Handler
             if (
-                    realmId == id                                // It's the right realm
+                    realmPath.equals(configuration.getPath())    // It's the right realm
                     && !handler.hasMessages(REALM_CHANGED)       // The right message
                     && handler.getLooper().getThread().isAlive() // The receiving thread is alive
-                    && !handler.equals(this.handler)             // Don't notify yourself
             ) {
                 handler.sendEmptyMessage(REALM_CHANGED);
             }
         }
-        sendNotifications();
     }
 
     /**
      * Revert all writes (created, updated, or deleted objects) made in the current write
      * transaction and end the transaction.
      * <br>
-     * The realm reverts back to read-only.
+     * The Realm reverts back to read-only.
      * <br>
      * Calling this when not in a write transaction will throw an exception.
      *
      * @throws java.lang.IllegalStateException    If the write transaction is an invalid state,
-    *                                             not in a write transaction or incorrect thread.
-    */
-     public void cancelTransaction() {
-         checkIfValid();
-         transaction.rollbackAndContinueAsRead();
-     }
+     *                                             not in a write transaction or incorrect thread.
+     */
+    public void cancelTransaction() {
+        checkIfValid();
+        transaction.rollbackAndContinueAsRead();
+    }
 
     /**
      * Executes a given transaction on the Realm. {@link #beginTransaction()} and
@@ -1540,21 +1512,18 @@ public void executeTransaction(Transaction transaction) {
     /**
      * Remove all objects of the specified class.
      *
-     * @param classSpec The class which objects should be removed
+     * @param clazz The class which objects should be removed
      * @throws java.lang.RuntimeException Any other error
      */
-    public void clear(Class<?> classSpec) {
-        getTable(classSpec).clear();
-    }
-
-    int getId() {
-        return id;
+    public void clear(Class<? extends RealmObject> clazz) {
+        getTable(clazz).clear();
     }
 
     // Returns the Handler for this Realm on the calling thread
     Handler getHandler() {
-        for (Map.Entry<Handler, Integer> entry : handlers.entrySet()) {
-            if (entry.getValue() == id) {
+        String realmPath = configuration.getPath();
+        for (Map.Entry<Handler, String> entry : handlers.entrySet()) {
+            if (entry.getValue().equals(realmPath)) {
                 return entry.getKey();
             }
         }
@@ -1593,25 +1562,7 @@ void setVersion(long version) {
 
     @SuppressWarnings("unchecked")
     private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
-        Class<? extends RealmObject> realmClass = getRealmClassFromObject(object);
-        Class<?> proxyClass = getProxyClass(realmClass);
-        Method method = insertOrUpdateMethods.get(realmClass);
-        if (method == null) {
-            try {
-                method = proxyClass.getMethod("copyOrUpdate", new Class[]{Realm.class, realmClass, boolean.class, Map.class});
-            } catch (NoSuchMethodException e) {
-                throw new RealmException("Could not find the copyOrUpdate() method in generated proxy class for " + proxyClass.getName() + ": " + APT_NOT_EXECUTED_MESSAGE, e);
-            }
-            insertOrUpdateMethods.put(proxyClass, method);
-        }
-        try {
-            Object result = method.invoke(null, this, object, update, new HashMap<RealmObject,RealmObject>());
-            return (E) result;
-        } catch (IllegalAccessException e) {
-            throw new RealmException("Could not execute the copyToRealm method : " + APT_NOT_EXECUTED_MESSAGE, e);
-        } catch (InvocationTargetException e) {
-            throw new RealmException("An exception was thrown in the copyToRealm method in the proxy class  " + proxyClass.getName() + ": " + APT_NOT_EXECUTED_MESSAGE, e);
-        }
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmObject, RealmObjectProxy>());
     }
 
     private <E extends RealmObject> void checkNotNullObject(E object) {
@@ -1623,41 +1574,86 @@ void setVersion(long version) {
     private <E extends RealmObject> void checkHasPrimaryKey(E object) {
         Class<? extends RealmObject> objectClass = object.getClass();
         if (!getTable(objectClass).hasPrimaryKey()) {
-            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + getClassSimpleName(objectClass));
+            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + objectClass.getSimpleName());
         }
     }
 
-    private <E extends RealmObject> void checkHasPrimaryKey(Class<E> clazz) {
+    private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
         if (!getTable(clazz).hasPrimaryKey()) {
             throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
         }
     }
 
-    @SuppressWarnings("UnusedDeclaration")
+    @Deprecated
     public static void migrateRealmAtPath(String realmPath, RealmMigration migration) {
         migrateRealmAtPath(realmPath, null, migration, true);
     }
 
+    @Deprecated
     public static void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration) {
         migrateRealmAtPath(realmPath, key, migration, true);
     }
 
+    @Deprecated
     public static void migrateRealmAtPath(String realmPath, RealmMigration migration, boolean autoRefresh) {
         migrateRealmAtPath(realmPath, null, migration, autoRefresh);
     }
 
+    @Deprecated
     public static synchronized void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration,
-                                            boolean autoUpdate) {
-        Realm realm = Realm.createAndValidate(realmPath, key, false, autoUpdate);
-        realm.beginTransaction();
-        realm.setVersion(migration.execute(realm, realm.getVersion()));
-        realm.commitTransaction();
-        realm.close();
+                                                       boolean autoUpdate) {
+        File file = new File(realmPath);
+        RealmConfiguration.Builder configuration = new RealmConfiguration.Builder(file.getParentFile())
+                .name(file.getName())
+                .migration(migration);
+        if (key != null) {
+            configuration.encryptionKey(key);
+        }
+        migrateRealm(configuration.build());
+    }
 
-        realmsCache.remove();
+    /**
+     * Manually trigger the migration associated with a given RealmConfiguration. If Realm is already at the
+     * latest version, nothing will happen.
+     * @param configuration
+     */
+    public static synchronized void migrateRealm(RealmConfiguration configuration) {
+        migrateRealm(configuration, null);
     }
 
     /**
+     * Manually trigger a migration on a RealmMigration.
+     *
+     * @param configuration {@link RealmConfiguration}
+     * @param migration {@link RealmMigration} to run on the Realm. This will override any migration set on the
+     * configuration.
+     */
+    public static void migrateRealm(RealmConfiguration configuration, RealmMigration migration) {
+        if (configuration == null) {
+            throw new IllegalArgumentException("RealmConfiguration must be provided");
+        }
+        if (migration == null && configuration.getMigration() == null) {
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided");
+        }
+
+        RealmMigration realmMigration = (migration == null) ? configuration.getMigration() : migration;
+        Realm realm = null;
+        try {
+            realm = Realm.createAndValidate(configuration, false, Looper.myLooper() != null);
+            realm.beginTransaction();
+            realm.setVersion(realmMigration.execute(realm, realm.getVersion()));
+            realm.commitTransaction();
+        } finally {
+            if (realm != null) {
+                realm.close();
+                realmsCache.remove();
+            }
+        }
+    }
+
+    /**
+     * Deprecated: Use {@link #deleteRealm(RealmConfiguration)} instead.
+     *
      * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
      * The Realm must be unused and closed before calling this method.
      * WARNING: Your Realm must not be open (typically when your app launch).
@@ -1665,138 +1661,204 @@ public static synchronized void migrateRealmAtPath(String realmPath, byte[] key,
      * @param context an Android {@link android.content.Context}.
      * @return false if a file could not be deleted. The failing file will be logged.
      * @see io.realm.Realm#clear(Class)
+     *
+     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
      */
+    @Deprecated
     public static boolean deleteRealmFile(Context context) {
         return deleteRealmFile(context, DEFAULT_REALM_NAME);
     }
 
     /**
+     * Deprecated: Use {@link #deleteRealm(RealmConfiguration)} instead.
+     *
      * Delete the Realm file from the filesystem for a custom named Realm.
      * The Realm must be unused and closed before calling this method.
      *
      * @param context  an Android {@link android.content.Context}.
      * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
      * @return false if a file could not be deleted. The failing file will be logged.
+     *
+     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
      */
+    @Deprecated
     public static boolean deleteRealmFile(Context context, String fileName) {
-        return deleteRealmFile(new File(context.getFilesDir(), fileName));
+        return deleteRealm(new RealmConfiguration.Builder(context)
+                        .name(fileName)
+                        .build()
+        );
     }
 
     /**
-     * Delete the Realm file from the filesystem for a custom named Realm.
+     * Delete the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
      * The Realm must be unused and closed before calling this method.
      *
-     * @param realmFile The reference to the Realm file.
+     * @param configuration A {@link RealmConfiguration}
      * @return false if a file could not be deleted. The failing file will be logged.
+     *
+     * @throws java.lang.IllegalStateException if trying to delete a Realm that is already open.
      */
-    public static synchronized boolean deleteRealmFile(File realmFile) {
+    public static synchronized boolean deleteRealm(RealmConfiguration configuration) {
         boolean result = true;
-        File realmFolder = realmFile.getParentFile();
-        String fileName = realmFile.getName();
 
-        int realmId = realmFile.getAbsolutePath().hashCode();
-        AtomicInteger counter = openRealms.get(realmId);
+        String id = configuration.getPath();
+        AtomicInteger counter = globalOpenInstanceCounter.get(id);
         if (counter != null && counter.get() > 0) {
             throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
                     "Remember to close() all the instances of the Realm before deleting its file.");
         }
 
-        List<File> filesToDelete = Arrays.asList(realmFile,
-                new File(realmFolder, fileName + ".lock"),
-                new File(realmFolder, fileName + ".lock_a"),
-                new File(realmFolder, fileName + ".lock_b"),
-                new File(realmFolder, fileName + ".log"));
+        File realmFolder = configuration.getRealmFolder();
+        String realmFileName = configuration.getRealmFileName();
+        List<File> filesToDelete = Arrays.asList(new File(configuration.getPath()),
+                new File(realmFolder, realmFileName + ".lock"),
+                new File(realmFolder, realmFileName + ".lock_a"),
+                new File(realmFolder, realmFileName + ".lock_b"),
+                new File(realmFolder, realmFileName + ".log"));
         for (File fileToDelete : filesToDelete) {
             if (fileToDelete.exists()) {
                 boolean deleteResult = fileToDelete.delete();
                 if (!deleteResult) {
                     result = false;
-                    Log.w(TAG, "Could not delete the file " + fileToDelete);
+                    RealmLog.w("Could not delete the file " + fileToDelete);
                 }
             }
         }
         return result;
     }
 
+
     /**
-     * Compact a realm file. A realm file usually contain free/unused space.
+     * Deprecated: Use {@link #compactRealm(RealmConfiguration)} instead.
+      *
+     * Compact a Realm file. A Realm file usually contain free/unused space.
      * This method removes this free space and the file size is thereby reduced.
-     * Objects within the realm files are untouched.
+     * Objects within the Realm files are untouched.
      * <p>
      * The file must be closed before this method is called.<br>
-     * The file system should have free space for at least a copy of the realm file.<br>
-     * The realm file is left untouched if any file operation fails.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
+     * Currently it is not possible to compact an encrypted Realm.<br>
      *
      * @param context an Android {@link android.content.Context}
      * @param fileName the name of the file to compact
      * @return true if successful, false if any file operation failed
+     *
+     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
      */
+    @Deprecated
     public static synchronized boolean compactRealmFile(Context context, String fileName) {
-        File realmFile = new File(context.getFilesDir(), fileName);
-        File tmpFile = new File(
-                context.getFilesDir(),
-                String.valueOf(System.currentTimeMillis()) + UUID.randomUUID() + ".realm");
-
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(context, fileName);
-            realm.writeCopyTo(tmpFile);
-            if (!realmFile.delete()) {
-                return false;
-            }
-            if (!tmpFile.renameTo(realmFile)) {
-                return false;
-            }
-        } catch (IOException e) {
-            return false;
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-        return true;
+        return compactRealm(new RealmConfiguration.Builder(context).name(fileName).build());
     }
 
     /**
-     * Compact a realm file. A realm file usually contain free/unused space.
+     * Deprecated: Use {@link #compactRealm(RealmConfiguration)} instead.
+     *
+     * Compact a Realm file. A Realm file usually contain free/unused space.
      * This method removes this free space and the file size is thereby reduced.
-     * Objects within the realm files are untouched.
+     * Objects within the Realm files are untouched.
      * <p>
      * The file must be closed before this method is called.<br>
      * The file system should have free space for at least a copy of the realm file.<br>
-     * The realm file is left untouched if any file operation fails.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
      *
      * @param context an Android {@link android.content.Context}
      * @return true if successful, false if any file operation failed
+     *
+     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
      */
+    @Deprecated
     public static boolean compactRealmFile(Context context) {
-        return compactRealmFile(context, DEFAULT_REALM_NAME);
+        return compactRealm(new RealmConfiguration.Builder(context).build());
     }
 
     /**
-     * Returns the absolute path to where this Realm is persisted on disk.
+     * Compact a Realm file. A Realm file usually contain free/unused space.
+     * This method removes this free space and the file size is thereby reduced.
+     * Objects within the Realm files are untouched.
+     * <p>
+     * The file must be closed before this method is called.<br>
+     * The file system should have free space for at least a copy of the Realm file.<br>
+     * The Realm file is left untouched if any file operation fails.<br>
+     *
+     * @param configuration a {@link RealmConfiguration} pointing to a Realm file.
+     * @return true if successful, false if any file operation failed
      *
-     * @return The absolute path to the realm file.
+     * @throws java.lang.IllegalStateException if trying to compact a Realm that is already open.
+     */
+    public static boolean compactRealm(RealmConfiguration configuration) {
+        if (configuration.getEncryptionKey() != null) {
+            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
+        }
+
+        String canonicalPath = configuration.getPath();
+        AtomicInteger openInstances = globalOpenInstanceCounter.get(canonicalPath);
+        if (openInstances != null && openInstances.get() > 0) {
+            throw new IllegalStateException("Cannot compact an open Realm");
+        }
+        SharedGroup sharedGroup = null;
+        boolean result = false;
+        try {
+            sharedGroup = new SharedGroup(canonicalPath, false, configuration.getEncryptionKey());
+            result = sharedGroup.compact();
+        } finally {
+            if (sharedGroup != null) {
+                sharedGroup.close();
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Returns the canonical path to where this Realm is persisted on disk.
+     *
+     * @return The canonical path to the Realm file.
+     * @see File#getCanonicalPath()
      */
     public String getPath() {
-        return path;
+        return configuration.getPath();
+    }
+
+    /**
+     * Returns the {@link RealmConfiguration} for this Realm.
+     * @return {@link RealmConfiguration} for this Realm.
+     */
+    public RealmConfiguration getConfiguration() {
+        return configuration;
     }
 
+    // Get the canonical path for a given file
+    static String getCanonicalPath(File realmFile) {
+        try {
+            return realmFile.getCanonicalPath();
+        } catch (IOException e) {
+            throw new RealmException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+        }
+    }
 
     /**
-     * Override the standard behavior of all classes extended RealmObject being part of the schema.
-     * Use this method to define the schema as only the classes given here.
-     *
-     * This class must be called before calling {@link #getInstance(android.content.Context)}
-     *
-     * If {@code null} is given as parameter, the Schema is reset to use all known classes.
+     * Returns the default Realm module. This module contains all Realm classes in the current project, but not
+     * those from library or project dependencies. Realm classes in these should be exposed using their own module.
      *
+     * @return The default Realm module or null if no default module exists.
+     * @see io.realm.RealmConfiguration.Builder#setModules(Object, Object...)
      */
-    @SafeVarargs
-    static void setSchema(Class<? extends RealmObject>... schemaClass) {
-        customSchema.clear();
-        if (schemaClass != null) {
-            Collections.addAll(customSchema, schemaClass);
+    public static Object getDefaultModule() {
+        String moduleName = "io.realm.DefaultRealmModule";
+        Class<?> clazz;
+        try {
+            clazz = Class.forName(moduleName);
+            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
+            constructor.setAccessible(true);
+            return constructor.newInstance();
+        } catch (ClassNotFoundException e) {
+            return null;
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
+        } catch (InstantiationException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not create an instance of " + moduleName, e);
         }
     }
 
@@ -1808,15 +1870,7 @@ static void setSchema(Class<? extends RealmObject>... schemaClass) {
      * instead of {@link #commitTransaction()}.
      */
     public interface Transaction {
-        public void execute(Realm realm);
+        void execute(Realm realm);
     }
 
-    private String getClassSimpleName(Class<?> clazz) {
-        String simpleName = simpleClassNames.get(clazz);
-        if (simpleName == null) {
-            simpleName = clazz.getSimpleName();
-            simpleClassNames.put(clazz, simpleName);
-        }
-        return simpleName;
-    }
 }
diff --git a/realm/src/main/java/io/realm/RealmBaseAdapter.java b/realm/src/main/java/io/realm/RealmBaseAdapter.java
index bf4804834c..531c95422c 100644
--- a/realm/src/main/java/io/realm/RealmBaseAdapter.java
+++ b/realm/src/main/java/io/realm/RealmBaseAdapter.java
@@ -36,35 +36,40 @@
     protected LayoutInflater inflater;
     protected RealmResults<T> realmResults;
     protected Context context;
+    private final RealmChangeListener listener;
 
     public RealmBaseAdapter(Context context, RealmResults<T> realmResults, boolean automaticUpdate) {
         if (context == null) {
             throw new IllegalArgumentException("Context cannot be null");
         }
-        if (realmResults == null) {
-            throw new IllegalArgumentException("RealmResults cannot be null");
-        }
-
         this.context = context;
         this.realmResults = realmResults;
         this.inflater = LayoutInflater.from(context);
-        if (automaticUpdate) {
-            realmResults.getRealm().addChangeListener(new RealmChangeListener() {
-                @Override
-                public void onChange() {
-                    notifyDataSetChanged();
-                }
-            });
+        this.listener = (!automaticUpdate) ? null : new RealmChangeListener() {
+            @Override
+            public void onChange() {
+                notifyDataSetChanged();
+            }
+        };
+
+        if (listener != null && realmResults != null) {
+            realmResults.getRealm().addChangeListener(listener);
         }
     }
 
     @Override
     public int getCount() {
+        if (realmResults == null) {
+            return 0;
+        }
         return realmResults.size();
     }
 
     @Override
     public T getItem(int i) {
+        if (realmResults == null) {
+            return null;
+        }
         return realmResults.get(i);
     }
 
@@ -86,10 +91,20 @@ public long getItemId(int i) {
      * Update the RealmResults associated to the Adapter. Useful when the query has been changed.
      * If the query does not change you might consider using the automaticUpdate feature
      *
-     * @param realmResults the new RealmResults coming from the new query.
+     * @param queryResults the new RealmResults coming from the new query.
      */
-    public void updateRealmResults(RealmResults<T> realmResults) {
-        this.realmResults = realmResults;
+    public void updateRealmResults(RealmResults<T> queryResults) {
+        if (listener != null) {
+            // Making sure that Adapter is refreshed correctly if new RealmResults come from another Realm
+            if (this.realmResults != null) {
+                this.realmResults.getRealm().removeChangeListener(listener);
+            }
+            if (queryResults != null) {
+                queryResults.getRealm().addChangeListener(listener);
+            }
+        }
+
+        this.realmResults = queryResults;
         notifyDataSetChanged();
     }
 }
diff --git a/realm/src/main/java/io/realm/RealmConfiguration.java b/realm/src/main/java/io/realm/RealmConfiguration.java
new file mode 100644
index 0000000000..c2f558e6b8
--- /dev/null
+++ b/realm/src/main/java/io/realm/RealmConfiguration.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import io.realm.annotations.RealmModule;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+
+/**
+ * A RealmConfiguration is used to setup a specific Realm instance.
+ *
+ * Instances of a RealmConfiguration can only created by using the {@link io.realm.RealmConfiguration.Builder} and calling
+ * its {@link io.realm.RealmConfiguration.Builder#build()} method.
+ *
+ * A commonly used RealmConfiguration can easily be accessed by first saving it as
+ * {@link Realm#setDefaultConfiguration(RealmConfiguration)} and then using {@link io.realm.Realm#getDefaultInstance()}.
+ *
+ * A minimal configuration can be created using:
+ *
+ * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
+ *
+ * This will create a RealmConfiguration with the following properties
+ * - Realm file is called "default.realm"
+ * - It is saved in Context.getFilesDir()
+ * - It has its schema version set to 0.
+ */
+public class RealmConfiguration {
+
+    public static final int KEY_LENGTH = 64;
+
+    private static final Object DEFAULT_MODULE;
+    private static final RealmProxyMediator DEFAULT_MODULE_MEDIATOR;
+    static {
+        DEFAULT_MODULE = Realm.getDefaultModule();
+        if (DEFAULT_MODULE != null) {
+            DEFAULT_MODULE_MEDIATOR = getModuleMediator(DEFAULT_MODULE.getClass().getCanonicalName());
+        } else {
+            DEFAULT_MODULE_MEDIATOR = null;
+        }
+    }
+
+    private final File realmFolder;
+    private final String realmFileName;
+    private final String canonicalPath;
+    private final byte[] key;
+    private final int schemaVersion;
+    private final RealmMigration migration;
+    private final boolean deleteRealmIfMigrationNeeded;
+    private final RealmProxyMediator schemaMediator;
+
+    private RealmConfiguration(Builder builder) {
+        this.realmFolder = builder.folder;
+        this.realmFileName = builder.fileName;
+        this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.key = builder.key;
+        this.schemaVersion = builder.schemaVersion;
+        this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
+        this.migration = builder.migration;
+        this.schemaMediator = createSchemaMediator(builder);
+    }
+
+    public File getRealmFolder() {
+        return realmFolder;
+    }
+
+    public String getRealmFileName() {
+        return realmFileName;
+    }
+
+    public byte[] getEncryptionKey() {
+        return key;
+    }
+
+    public int getSchemaVersion() {
+        return schemaVersion;
+    }
+
+    public RealmMigration getMigration() {
+        return migration;
+    }
+
+    public boolean shouldDeleteRealmIfMigrationNeeded() {
+        return deleteRealmIfMigrationNeeded;
+    }
+
+    public RealmProxyMediator getSchemaMediator() {
+        return schemaMediator;
+    }
+
+    public String getPath() {
+        return canonicalPath;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null || getClass() != obj.getClass()) return false;
+
+        RealmConfiguration that = (RealmConfiguration) obj;
+
+        if (schemaVersion != that.schemaVersion) return false;
+        if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) return false;
+        if (!realmFolder.equals(that.realmFolder)) return false;
+        if (!realmFileName.equals(that.realmFileName)) return false;
+        if (!canonicalPath.equals(that.canonicalPath)) return false;
+        if (!Arrays.equals(key, that.key)) return false;
+        if (migration != null ? !migration.equals(that.migration) : that.migration != null) return false;
+        return schemaMediator.equals(that.schemaMediator);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = realmFolder.hashCode();
+        result = 31 * result + realmFileName.hashCode();
+        result = 31 * result + canonicalPath.hashCode();
+        result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
+        result = 31 * result + schemaVersion;
+        result = 31 * result + (migration != null ? migration.hashCode() : 0);
+        result = 31 * result + (deleteRealmIfMigrationNeeded ? 1 : 0);
+        result = 31 * result + schemaMediator.hashCode();
+        return result;
+    }
+
+    // Creates the mediator that defines the current schema
+    private RealmProxyMediator createSchemaMediator(Builder builder) {
+
+        Set<Object> modules = builder.modules;
+        Set<Class<? extends RealmObject>> debugSchema = builder.debugSchema;
+
+        // If using debug schema, use special mediator
+        if (debugSchema.size() > 0) {
+            return new FilterableMediator(DEFAULT_MODULE_MEDIATOR, debugSchema);
+        }
+
+        // If only one module, use that mediator directly
+        if (modules.size() == 1) {
+            return getModuleMediator(modules.iterator().next().getClass().getCanonicalName());
+        }
+
+        // Otherwise combine all mediators
+        CompositeMediator mediator = new CompositeMediator();
+        for (Object module : modules) {
+            mediator.addMediator(getModuleMediator(module.getClass().getCanonicalName()));
+        }
+        return mediator;
+    }
+
+    // Finds the mediator associated with a given module
+    private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleClassName) {
+        String[] moduleNameParts = fullyQualifiedModuleClassName.split("\\.");
+        String moduleSimpleName = moduleNameParts[moduleNameParts.length - 1];
+        String mediatorName = String.format("io.realm.%s%s", moduleSimpleName, "Mediator");
+        Class<?> clazz;
+        try {
+            clazz = Class.forName(mediatorName);
+            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
+            constructor.setAccessible(true);
+            return (RealmProxyMediator) constructor.newInstance();
+        } catch (ClassNotFoundException e) {
+            throw new RealmException("Could not find " + mediatorName, e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        } catch (InstantiationException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not create an instance of " + mediatorName, e);
+        }
+    }
+
+    /**
+     * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
+     */
+    public static class Builder {
+        private File folder;
+        private String fileName;
+        private byte[] key;
+        private int schemaVersion;
+        private RealmMigration migration;
+        private boolean deleteRealmIfMigrationNeeded;
+        private HashSet<Object> modules = new HashSet<Object>();
+        private HashSet<Class<? extends RealmObject>> debugSchema = new HashSet<Class<? extends RealmObject>>();
+
+        /**
+         * Creates an instance of the Builder for the RealmConfiguration.
+         * The Realm file will be saved in the provided folder.
+         *
+         * @param folder Folder to save Realm file in. Folder must be writable.
+         *
+         * @throws IllegalArgumentException if folder doesn't exists or isn't writable.
+         */
+        public Builder(File folder) {
+            initializeBuilder(folder);
+        }
+
+        /**
+         * Creates an instance of the Builder for the RealmConfiguration.
+         *
+         * This will use the apps own internal directory for storing the Realm file. This does not require any
+         * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
+         * change depending on vendor implementations of Android.
+         *
+         * @param context Android context.
+         */
+        public Builder(Context context) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            initializeBuilder(context.getFilesDir());
+        }
+
+        // Setup builder in its initial state
+        private void initializeBuilder(File folder) {
+            if (folder == null || !folder.isDirectory()) {
+                throw new IllegalArgumentException(("An existing folder must be provided. " +
+                        "Yours was " + (folder != null ? folder.getAbsolutePath() : "null")));
+            }
+            if (!folder.canWrite()) {
+                throw new IllegalArgumentException("Folder is not writable: " + folder.getAbsolutePath());
+            }
+
+            this.folder = folder;
+            this.fileName = Realm.DEFAULT_REALM_NAME;
+            this.key = null;
+            this.schemaVersion = 0;
+            this.migration = null;
+            this.deleteRealmIfMigrationNeeded = false;
+            if (DEFAULT_MODULE != null) {
+                this.modules.add(DEFAULT_MODULE);
+            }
+        }
+
+        /**
+         * Sets the filename for the Realm.
+         */
+        public Builder name(String filename) {
+            if (filename == null || filename.isEmpty()) {
+                throw new IllegalArgumentException("A non-empty filename must be provided");
+            }
+
+            this.fileName = filename;
+            return this;
+        }
+
+        /**
+         * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         */
+        public Builder encryptionKey(byte[] key) {
+            if (key == null) {
+                throw new IllegalArgumentException("A non-null key must be provided");
+            }
+            if (key.length != KEY_LENGTH) {
+                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                        KEY_LENGTH, key.length));
+            }
+            this.key = key;
+            return this;
+        }
+
+        /**
+         * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
+         * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
+         *
+         * If no migration code is provided, Realm will throw a {@link io.realm.exceptions.RealmMigrationNeededException}.
+         *
+         * @see #migration(RealmMigration)
+         */
+        public Builder schemaVersion(int schemaVersion) {
+            if (schemaVersion < 0) {
+                throw new IllegalArgumentException("Realm schema version numbers must be 0 (zero) or higher. Yours was: " + schemaVersion);
+            }
+            this.schemaVersion = schemaVersion;
+            return this;
+        }
+
+        /**
+         * Sets the {@link io.realm.RealmMigration} to be run if a migration is needed. If this migration fails to
+         * upgrade the on-disc schema to the runtime schema, a
+         * {@link io.realm.exceptions.RealmMigrationNeededException} will be thrown.
+         */
+        public Builder migration(RealmMigration migration) {
+            if (migration == null) {
+                throw new IllegalArgumentException("A non-null migration must be provided");
+            }
+            this.migration = migration;
+            return this;
+        }
+
+        /**
+         * Setting this will change the behavior of how migration exceptions are handled. Instead of throwing a
+         * {@link io.realm.exceptions.RealmMigrationNeededException} the on-disc Realm will be cleared and recreated
+         * with the new Realm schema.
+         *
+         * <b>WARNING!</b> This will result in loss of data.
+         */
+        public Builder deleteRealmIfMigrationNeeded() {
+            this.deleteRealmIfMigrationNeeded = true;
+            return this;
+        }
+
+        /**
+         * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
+         * current schema for this Realm with the schema defined by the provided modules.
+         *
+         * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
+         * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
+         * dependency is thus done using the following code:
+         *
+         * {@code builder.setModules(Realm.getDefaultMode(), new MyLibraryModule()); }
+         *
+         * @param baseModule        First Realm module (required).
+         * @param additionalModules Additional Realm modules
+         *
+         * @throws IllegalArgumentException if any of the modules are {@code null} or doesn't have the
+         * {@link RealmModule} annotation.
+         * @see Realm#getDefaultModule()
+         */
+        public Builder setModules(Object baseModule, Object... additionalModules) {
+            modules.clear();
+            addModule(baseModule);
+            if (additionalModules != null) {
+                for (int i = 0; i < additionalModules.length; i++) {
+                    Object module = additionalModules[i];
+                    checkModule(module);
+                    addModule(module);
+                }
+            }
+            return this;
+        }
+
+        private void addModule(Object module) {
+            checkModule(module);
+            modules.add(module);
+        }
+
+        /**
+         * DEBUG method. This restricts the Realm schema to only consist of the provided classes without having to
+         * create a module. These classes must be available in the default module. Calling this will remove any
+         * previously configured modules.
+         */
+        Builder schema(Class<? extends RealmObject> firstClass, Class<? extends RealmObject>... additionalClasses) {
+            if (firstClass == null) {
+                throw new IllegalArgumentException("A non-null class must be provided");
+            }
+            modules.clear();
+            modules.add(DEFAULT_MODULE_MEDIATOR);
+            debugSchema.add(firstClass);
+            if (additionalClasses != null) {
+                Collections.addAll(debugSchema, additionalClasses);
+            }
+
+            return this;
+        }
+
+        /**
+         * Creates the RealmConfiguration based on the builder parameters.
+         *
+         * @return The created RealmConfiguration.
+         */
+        public RealmConfiguration build() {
+            return new RealmConfiguration(this);
+        }
+
+        private void checkModule(Object module) {
+            if (module == null) {
+                throw new IllegalArgumentException("Provided RealmModule must not be null.");
+            }
+            if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                        "Add @RealmModule to the class definition.");
+            }
+        }
+    }
+}
diff --git a/realm/src/main/java/io/realm/RealmList.java b/realm/src/main/java/io/realm/RealmList.java
index 429c9d33d6..30f921ce76 100644
--- a/realm/src/main/java/io/realm/RealmList.java
+++ b/realm/src/main/java/io/realm/RealmList.java
@@ -18,6 +18,7 @@
 
 import java.util.AbstractList;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import io.realm.exceptions.RealmException;
@@ -44,7 +45,6 @@
 
     private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
     private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
-    public static final String MANAGED_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmObjects already managed by Realm cannot be added to RealmList in non-managed mode.";
 
     private final boolean managedMode;
     private Class<E> clazz;
@@ -76,11 +76,12 @@ public RealmList() {
      * @param objects Initial objects in the list.
      */
     public RealmList(E... objects) {
-        managedMode = false;
-        nonManagedList = new ArrayList<E>(objects != null ? objects.length : 0);
-        for (int i = 0; i < objects.length; i++) {
-            nonManagedList.add(objects[i]);
+        if (objects == null) {
+            throw new IllegalArgumentException("The objects argument cannot be null");
         }
+        managedMode = false;
+        nonManagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(nonManagedList, objects);
     }
 
     /**
@@ -98,12 +99,27 @@ public RealmList(E... objects) {
     }
 
     /**
-     * {@inheritDoc}
+     * Inserts the specified object into this List at the specified location. The object is inserted before any previous
+     * element at the specified location. If the location is equal to the size of this List, the object is added at the
+     * end.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     * @param location the index at which to insert.
+     * @param object the object to add.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}
      */
     @Override
     public void add(int location, E object) {
         checkValidObject(object);
         if (managedMode) {
+            object = copyToRealmIfNeeded(object);
             view.insert(location, object.row.getIndex());
         } else {
             nonManagedList.add(location, object);
@@ -111,12 +127,24 @@ public void add(int location, E object) {
     }
 
     /**
-     * {@inheritDoc}
+     * Adds the specified object at the end of this List.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     * @param object the object to add.
+     * @return true
      */
     @Override
     public boolean add(E object) {
         checkValidObject(object);
         if (managedMode) {
+            object = copyToRealmIfNeeded(object);
             view.add(object.row.getIndex());
         } else {
             nonManagedList.add(object);
@@ -125,15 +153,27 @@ public boolean add(E object) {
     }
 
     /**
-     * {@inheritDoc}
+     * Replaces the element at the specified location in this list with the
+     * specified object.
+     * <ol>
+     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
+     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * {@link Realm#copyToRealm(RealmObject)} afterwards.</li>
+     *
+     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmObject)}
+     * or {@link Realm#copyToRealmOrUpdate(RealmObject)} if it has a primary key.</li>
+     * </ol>
+     * @param location the index at which to put the specified object.
+     * @param object the object to add.
+     * @return the previous element at the index.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}
      */
     @Override
     public E set(int location, E object) {
         checkValidObject(object);
         if (managedMode) {
-            if (object.row == null) {
-                throw new RealmException(ONLY_IN_MANAGED_MODE_MESSAGE);
-            }
+            object = copyToRealmIfNeeded(object);
             view.set(location, object.row.getIndex());
         } else {
             nonManagedList.set(location, object);
@@ -141,6 +181,18 @@ public E set(int location, E object) {
         return object;
     }
 
+    // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
+    private E copyToRealmIfNeeded(E object) {
+        if (object.row != null && object.realm.getPath().equals(realm.getPath())) {
+            return object;
+        }
+        if (realm.getTable(object.getClass()).hasPrimaryKey()) {
+            return realm.copyToRealmOrUpdate(object);
+        } else {
+            return realm.copyToRealm(object);
+        }
+    }
+
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
      * RealmObjects will be shifted so no null values are introduced.
@@ -239,7 +291,8 @@ public E last() {
     @Override
     public int size() {
         if (managedMode) {
-            return ((Long)view.size()).intValue();
+            long size = view.size();
+            return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
         } else {
             return nonManagedList.size();
         }
diff --git a/realm/src/main/java/io/realm/RealmMigration.java b/realm/src/main/java/io/realm/RealmMigration.java
index 5e1843acff..214aa2f002 100644
--- a/realm/src/main/java/io/realm/RealmMigration.java
+++ b/realm/src/main/java/io/realm/RealmMigration.java
@@ -21,24 +21,24 @@
  * The schema for a Realm is defined by all classes in a project that extend
  * {@link io.realm.RealmObject}, so any changes to these classes will require a migration.
  *
- * To support migrations from any previous version to the newest, the following pattern is
+ * To support migrations from any previous schemaVersion to the newest, the following pattern is
  * recommended when writing a migration:
  *
  * <pre>
  * public class CustomMigration implements RealmMigration {
  *   \@Override
- *   public long execute(Realm realm, long version) {
- *     if (version == 0) {
+ *   public long execute(Realm realm, long schemaVersion) {
+ *     if (schemaVersion == 0) {
  *       // Migrate from v0 to v1
- *       version++;
+ *       schemaVersion++;
  *     }
  *
- *     if (version == 0) {
+ *     if (schemaVersion == 0) {
  *       // Migrate from v0 to v1
- *       version++;
+ *       schemaVersion++;
  *     }
  *
- *     return version;
+ *     return schemaVersion;
  *   }
  * }
  * </pre>
@@ -56,8 +56,8 @@
      * Implement this method in your subclass to perform migration.
      *
      * @param realm The Realm on which to perform the migration.
-     * @param version The version of the Realm at the start of the migration.
-     * @return The version of the Realm after executing the migration.
+     * @param version The schemaVersion of the Realm at the start of the migration.
+     * @return The schemaVersion of the Realm after executing the migration.
      */
     public long execute(Realm realm, long version);
 }
diff --git a/realm/src/main/java/io/realm/RealmObject.java b/realm/src/main/java/io/realm/RealmObject.java
index f65e78633a..e7f30d4706 100644
--- a/realm/src/main/java/io/realm/RealmObject.java
+++ b/realm/src/main/java/io/realm/RealmObject.java
@@ -18,6 +18,7 @@
 
 import io.realm.annotations.RealmClass;
 import io.realm.internal.Row;
+import io.realm.internal.InvalidRow;
 
 /**
  * In Realm you define your model classes by sub-classing RealmObject and adding fields to be
@@ -91,6 +92,7 @@ public void removeFromRealm() {
             throw new IllegalStateException("Object malformed: missing Realm. Make sure to instantiate RealmObjects with Realm.createObject()");
         }
         row.getTable().moveLastOver(row.getIndex());
+        row = InvalidRow.INSTANCE;
     }
 
     /**
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
index d7f4f064f0..df847f5e69 100644
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ b/realm/src/main/java/io/realm/RealmQuery.java
@@ -169,6 +169,35 @@ private boolean containsDot(String s) {
         }
     }
 
+    /**
+     * Test if a field is null. Only works for relationships and RealmLists.
+     *
+     * @param fieldName - the field name
+     * @return The query object
+     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
+     */
+    public RealmQuery<E> isNull(String fieldName) {
+        // Currently we only support querying top-level
+        if (containsDot(fieldName)) {
+            throw new IllegalArgumentException("Checking for null in nested objects is not supported.");
+        }
+
+        // checking that fieldName has the correct type is done in C++
+        this.query.isNull(columns.get(fieldName));
+        return this;
+    }
+
+    /**
+     * Test if a field is not null. Only works for relationships and RealmLists.
+     *
+     * @param fieldName - the field name
+     * @return The query object
+     * @throws java.lang.IllegalArgumentException if field is not a RealmObject or RealmList
+     */
+    public RealmQuery<E> isNotNull(String fieldName) {
+        return this.beginGroup().not().isNull(fieldName).endGroup();
+    }
+
     // Equal
 
     /**
@@ -188,7 +217,8 @@ private boolean containsDot(String s) {
      * Equal-to comparison
      * @param fieldName   The field to compare
      * @param value       The value to compare with
-     * @param caseSensitive if true, substring matching is case sensitive
+     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+     *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
      * field type
@@ -310,7 +340,8 @@ private boolean containsDot(String s) {
      * Not-equal-to comparison
      * @param fieldName  The field to compare
      * @param value      The value to compare with
-     * @param caseSensitive if true, substring matching is case sensitive
+     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+     *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
      * field type
@@ -821,7 +852,8 @@ private boolean containsDot(String s) {
      * Condition that value of field contains the specified substring
      * @param fieldName  The field to compare
      * @param value      The substring
-     * @param caseSensitive if true, substring matching is case sensitive
+     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+     *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
      * field type
@@ -850,7 +882,8 @@ private boolean containsDot(String s) {
      * Condition that the value of field begins with the specified substring
      * @param fieldName The field to compare
      * @param value     The substring
-     * @param caseSensitive if true, substring matching is case sensitive
+     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+     *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
      * field type
@@ -879,7 +912,8 @@ private boolean containsDot(String s) {
      * Condition that the value of field ends with the specified substring
      * @param fieldName The field to compare
      * @param value     The substring
-     * @param caseSensitive if true, substring matching is case sensitive
+     * @param caseSensitive if true, substring matching is case sensitive. Setting this to false only works for English
+     *                      locale characters.
      * @return The query object
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or
      * field type
@@ -1124,6 +1158,9 @@ public long count() {
     /**
      * Find all objects that fulfill the query conditions and sorted by specific field name.
      *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
      * @param fieldName the field name to sort by.
      * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
      *                      if <code>SORT_ORDER_DESCENDING</code>
@@ -1147,6 +1184,9 @@ public long count() {
      * Find all objects that fulfill the query conditions and sorted by specific field name in
      * ascending order.
      *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
      * @param fieldName the field name to sort by.
      * @return A {@link io.realm.RealmResults} containing objects. If no objects match the condition,
      * a list with zero objects is returned.
@@ -1159,6 +1199,9 @@ public long count() {
     /**
      * Find all objects that fulfill the query conditions and sorted by specific field names.
      *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
      * @param fieldNames an array of field names to sort by.
      * @param sortAscending sort ascending if <code>SORT_ORDER_ASCENDING</code>, sort descending
      *                      if <code>SORT_ORDER_DESCENDING</code>.
@@ -1203,6 +1246,9 @@ public long count() {
      * Find all objects that fulfill the query conditions and sorted by specific field names in
      * ascending order.
      *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
      * @param fieldName1 first field name
      * @param sortAscending1 sort order for first field
      * @param fieldName2 second field name
@@ -1221,6 +1267,9 @@ public long count() {
      * Find all objects that fulfill the query conditions and sorted by specific field names in
      * ascending order.
      *
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
      * @param fieldName1 first field name
      * @param sortAscending1 sort order for first field
      * @param fieldName2 second field name
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
index 6a9c49988e..7b5fb85707 100644
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ b/realm/src/main/java/io/realm/RealmResults.java
@@ -514,7 +514,6 @@ private void assertRealmIsStable() {
     private class RealmResultsIterator implements Iterator<E> {
 
         int pos = -1;
-        boolean removeUsed = false;
 
         RealmResultsIterator() {
             currentTableViewVersion = table.sync();
@@ -528,7 +527,6 @@ public boolean hasNext() {
         public E next() {
             assertRealmIsStable();
             pos++;
-            removeUsed = false;
             if (pos >= size()) {
                 throw new IndexOutOfBoundsException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
             }
diff --git a/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index 20f1db4a2e..0ac92a4bbc 100644
--- a/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -15,12 +15,39 @@
  */
 package io.realm.exceptions;
 
+import java.io.File;
+
 public class RealmMigrationNeededException extends RuntimeException {
-    public RealmMigrationNeededException(String detailMessage) {
+
+    private final String canonicalRealmPath;
+
+    public RealmMigrationNeededException(String canonicalRealmPath, String detailMessage) {
         super(detailMessage);
+        this.canonicalRealmPath = canonicalRealmPath;
     }
 
-    public RealmMigrationNeededException(String detailMessage, Throwable throwable) {
+    public RealmMigrationNeededException(String canonicalRealmPath, String detailMessage, Throwable throwable) {
         super(detailMessage, throwable);
+        this.canonicalRealmPath = canonicalRealmPath;
+    }
+
+    /**
+     * Returns the canonical path to the Realm file that needs to be migrated.
+     *
+     * This can be used for easy reference during a migration:
+     *
+     * <pre>
+     * try {
+     *   Realm.getInstance(context);
+     * } catch (RealmMigrationNeededException e) {
+     *   Realm.migrateRealmAtPath(e.getRealmPath(), new CustomMigration());
+     * }
+     * </pre>
+     *
+     * @return Canonical path to the Realm file.
+     * @see File#getCanonicalPath()
+     */
+    public String getPath() {
+        return canonicalRealmPath;
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/CheckedRow.java b/realm/src/main/java/io/realm/internal/CheckedRow.java
new file mode 100644
index 0000000000..d493542bcd
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/CheckedRow.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package io.realm.internal;
+
+/**
+ * Checked wrapper for Row data in Realm Core. All methods called through this will check that input parameters are
+ * valid or throw an appropriate exception.
+ * <p>
+ * For low-level access to a Realm where safety checks were already performed, use {@link UncheckedRow} instead for
+ * improved performance.
+ */
+public class CheckedRow extends UncheckedRow {
+
+    // Used if created from other row. This keeps a strong reference to avoid GC'ing the original object, and it's
+    // underlying native data.
+    @SuppressWarnings("unused")
+    private UncheckedRow originalRow;
+
+    private CheckedRow(Context context, Table parent, long nativePtr) {
+        super(context, parent, nativePtr);
+    }
+
+    private CheckedRow(UncheckedRow row) {
+        super(row.context, row.parent, row.nativePointer);
+        this.originalRow = row;
+    }
+
+    /**
+     * Get the row object associated to an index in a Table.
+     * @param context the Realm context.
+     * @param table the Table that holds the row.
+     * @param index the index of the row.
+     * @return an instance of Row for the table and index specified.
+     */
+    public static CheckedRow get(Context context, Table table, long index) {
+        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        CheckedRow row = new CheckedRow(context, table, nativeRowPointer);
+        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        return row;
+    }
+
+    /**
+     * Get the row object associated to an index in a LinkView.
+     * @param context the Realm context.
+     * @param linkView the LinkView holding the row.
+     * @param index the index of the row.
+     * @return a checked instance of Row for the LinkView and index specified.
+     */
+    public static CheckedRow get(Context context, LinkView linkView, long index) {
+        long nativeRowPointer = linkView.nativeGetRow(linkView.nativeLinkViewPtr, index);
+        CheckedRow row = new CheckedRow(context, linkView.parent.getLinkTarget(linkView.columnIndexInParent), nativeRowPointer);
+        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        return row;
+    }
+
+    /**
+     * Convert a unchecked row to a checked row.
+     * @return an checked instance of Row.
+     */
+    public static CheckedRow getFromRow(UncheckedRow row) {
+        return new CheckedRow(row);
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        ColumnType columnType = getColumnType(columnIndex);
+        if (columnType == ColumnType.LINK || columnType == ColumnType.LINK_LIST) {
+            return super.isNullLink(columnIndex);
+        } else {
+            return false; // Unsupported types are never null
+        }
+    }
+
+    protected native long nativeGetColumnCount(long nativeTablePtr);
+    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
+    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
+    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
+    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native String nativeGetString(long nativePtr, long columnIndex);
+    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
+    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
+    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
+    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
+    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
+    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
+}
diff --git a/realm/src/main/java/io/realm/internal/Context.java b/realm/src/main/java/io/realm/internal/Context.java
index 29ccb9122b..b2a785840f 100644
--- a/realm/src/main/java/io/realm/internal/Context.java
+++ b/realm/src/main/java/io/realm/internal/Context.java
@@ -30,28 +30,25 @@
     private List<Long> abandonedTables = new ArrayList<Long>();
     private List<Long> abandonedTableViews = new ArrayList<Long>();
     private List<Long> abandonedQueries = new ArrayList<Long>();
-    private List<Long> abandonedRows = new ArrayList<Long>();
 
     private boolean isFinalized = false;
 
     public void executeDelayedDisposal() {
         synchronized (this) {
-            for (long nativePointer: abandonedTables) {
+            for (int i = 0; i < abandonedTables.size(); i++) {
+                long nativePointer = abandonedTables.get(i);
                 Table.nativeClose(nativePointer);
             }
             abandonedTables.clear();
 
-            for (long nativePointer: abandonedRows) {
-                Row.nativeClose(nativePointer);
-            }
-            abandonedRows.clear();
-
-            for (long nativePointer: abandonedTableViews) {
+            for (int i = 0; i < abandonedTableViews.size(); i++) {
+                long nativePointer = abandonedTableViews.get(i);
                 TableView.nativeClose(nativePointer);
             }
             abandonedTableViews.clear();
 
-            for (long nativePointer: abandonedQueries) {
+            for (int i = 0; i < abandonedQueries.size(); i++) {
+                long nativePointer = abandonedQueries.get(i);
                 TableQuery.nativeClose(nativePointer);
             }
             abandonedQueries.clear();
@@ -67,15 +64,6 @@ public void asyncDisposeTable(long nativePointer, boolean isRoot) {
         }
     }
 
-    public void asyncDisposeRow(long nativePointer) {
-        if (isFinalized) {
-            Row.nativeClose(nativePointer);
-        }
-        else {
-            abandonedRows.add(nativePointer);
-        }
-    }
-
     public void asyncDisposeTableView(long nativePointer) {
         if (isFinalized) {
             TableView.nativeClose(nativePointer);
diff --git a/realm/src/main/java/io/realm/internal/FinalizerRunnable.java b/realm/src/main/java/io/realm/internal/FinalizerRunnable.java
new file mode 100644
index 0000000000..c5e92c5c91
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/FinalizerRunnable.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+/**
+ * This runnable performs the garbage collection of the references stored in the reference queue
+ */
+public class FinalizerRunnable implements Runnable {
+
+    // Store the row references. Without this, objects would be garbage collected immediately so don't remove this! ;)
+    // A ConcurrentHashMap is used in lack of a ConcurrentHashSet in the Java API.
+    // ConcurrentLinkedQueue was tried instead, but the removal operation turned out to be too slow.
+    static final Map<Reference<?>, Boolean> references = new ConcurrentHashMap<Reference<?>, Boolean>();
+
+    // This is the actual reference queue in which the garbage collector will insert the row instances ready to be
+    // cleaned up
+    static final ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+
+
+    @Override
+    public void run() {
+
+        NativeObjectReference reference;
+        while (true) {
+            try {
+                reference = (NativeObjectReference) referenceQueue.remove();
+                references.remove(reference);
+                UncheckedRow.nativeClose(reference.nativePointer);
+            } catch (InterruptedException e) {
+                //restore interrupted exception
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/Group.java b/realm/src/main/java/io/realm/internal/Group.java
index 20d724562c..1bb6fa0fac 100644
--- a/realm/src/main/java/io/realm/internal/Group.java
+++ b/realm/src/main/java/io/realm/internal/Group.java
@@ -69,10 +69,7 @@ private OpenMode(int value) {
     };
 
     public Group(String filepath, OpenMode mode) {
-        if (mode.equals(OpenMode.READ_ONLY))
-            this.immutable = true;
-        else
-            this.immutable = false;
+        this.immutable = mode.equals(OpenMode.READ_ONLY);
         
         this.context = new Context();
         this.nativePtr = createNative(filepath, mode.value);
@@ -183,10 +180,7 @@ public boolean isEmpty(){
      */
     public boolean hasTable(String name) {
         verifyGroupIsValid();
-        if (name == null) {
-            return false;
-        }
-        return nativeHasTable(nativePtr, name);
+        return name != null && nativeHasTable(nativePtr, name);
     }
 
     protected native boolean nativeHasTable(long nativeGroupPtr, String name);
@@ -303,20 +297,6 @@ public String toString() {
 
     protected native String nativeToString(long nativeGroupPtr);
 
-    public boolean equals(Object other) {
-        if (other == null)
-            return false;
-        if (other == this)
-            return true;
-        if (!(other instanceof Group))
-            return false;
-
-        Group otherGroup = (Group) other;
-        return nativeEquals(nativePtr, otherGroup.nativePtr);
-    }
-
-    protected native boolean nativeEquals(long nativeGroupPtr, long nativeGroupToComparePtr);
-
     private void throwImmutable() {
         throw new IllegalStateException("Objects cannot be changed outside a transaction; see beginTransaction() for details.");
     }
diff --git a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
index 90f223db34..0ea882996e 100644
--- a/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ b/realm/src/main/java/io/realm/internal/ImplicitTransaction.java
@@ -67,5 +67,12 @@ private void assertNotClosed() {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    public String getPath() {
+        return parent.getPath();
+    }
+
     protected void finalize() {} // Nullify the actions of Group.finalize()
 }
diff --git a/realm/src/main/java/io/realm/internal/InvalidRow.java b/realm/src/main/java/io/realm/internal/InvalidRow.java
new file mode 100644
index 0000000000..059a236cb9
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/InvalidRow.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package io.realm.internal;
+
+import java.util.Date;
+
+/**
+ * Row wrapper that stubs all access with IllegalStateExceptions. This can be used instead of adding null checks
+ * everywhere when the underlying Row accessor in Realm Core is no longer available.
+ */
+public enum InvalidRow implements Row {
+    INSTANCE;
+
+    @Override
+    public long getColumnCount() {
+        throw getStubException();
+    }
+
+    @Override
+    public String getColumnName(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public long getColumnIndex(String columnName) {
+        throw getStubException();
+    }
+
+    @Override
+    public ColumnType getColumnType(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Table getTable() {
+        throw getStubException();
+    }
+
+    @Override
+    public long getIndex() {
+        throw getStubException();
+    }
+
+    @Override
+    public long getLong(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean getBoolean(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public float getFloat(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public double getDouble(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Date getDate(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public String getString(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public byte[] getBinaryByteArray(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public Mixed getMixed(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public ColumnType getMixedType(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public long getLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public LinkView getLinkList(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setLong(long columnIndex, long value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setBoolean(long columnIndex, boolean value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setFloat(long columnIndex, float value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setDouble(long columnIndex, double value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setDate(long columnIndex, Date date) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setString(long columnIndex, String value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setBinaryByteArray(long columnIndex, byte[] data) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setMixed(long columnIndex, Mixed data) {
+        throw getStubException();
+    }
+
+    @Override
+    public void setLink(long columnIndex, long value) {
+        throw getStubException();
+    }
+
+    @Override
+    public void nullifyLink(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public boolean isAttached() {
+        throw getStubException();
+    }
+
+    private RuntimeException getStubException() {
+        return new IllegalStateException("Object is no longer managed by Realm. Has it been deleted?");
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/LinkView.java b/realm/src/main/java/io/realm/internal/LinkView.java
index 4b45a0427a..f7375d246d 100644
--- a/realm/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/src/main/java/io/realm/internal/LinkView.java
@@ -16,12 +16,15 @@
 
 package io.realm.internal;
 
+/**
+ * The LinkView class represent a core {@link ColumnType#LINK_LIST}.
+ */
 public class LinkView {
 
     private final Context context;
-    private final long nativeLinkViewPtr;
-    private final Table parent;
-    private final long columnIndexInParent;
+    final long nativeLinkViewPtr;
+    final Table parent;
+    final long columnIndexInParent;
 
     public LinkView(Context context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
         this.context = context;
@@ -30,58 +33,72 @@ public LinkView(Context context, Table parent, long columnIndexInParent, long na
         this.nativeLinkViewPtr = nativeLinkViewPtr;
     }
 
-    protected static native void nativeClose(long nativeLinkViewPtr);
+    /**
+     * Returns a non-checking Row. Incorrect use of this Row will cause a hard Realm Core crash (SIGSEGV).
+     * Only use this method if you are sure that input parameters are valid, otherwise use {@link #getCheckedRow(long)}
+     * which will throw appropriate exceptions if used incorrectly.
+     *
+     * @param index Index of row to fetch.
+     * @return Unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRow(long index) {
+        return UncheckedRow.get(context, this, index);
+    }
 
-    public Row get(long pos) {
-        long nativeRowPtr = nativeGetRow(nativeLinkViewPtr, pos);
-        return new Row(context, parent.getLinkTarget(columnIndexInParent), nativeRowPtr);
+    /**
+     * Returns a wrapper for Row access. All access will be error checked at the JNI layer and will throw an
+     * appropriate {@link RuntimeException} if used incorrectly.
+     *
+     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
+     *
+     * @param index Index of row to fetch.
+     * @return Safe row wrapper object.
+     */
+    public CheckedRow getCheckedRow(long index) {
+        return CheckedRow.get(context, this, index);
     }
-    private native long nativeGetRow(long nativeLinkViewPtr, long pos);
 
     public long getTargetRowIndex(long pos) {
         return nativeGetTargetRowIndex(nativeLinkViewPtr, pos);
     }
-    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
 
     public void add(long rowIndex) {
+        checkImmutable();
         nativeAdd(nativeLinkViewPtr, rowIndex);
     }
-    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
 
     public void insert(long pos, long rowIndex) {
+        checkImmutable();
         nativeInsert(nativeLinkViewPtr, pos, rowIndex);
     }
-    private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
 
     public void set(long pos, long rowIndex) {
+        checkImmutable();
         nativeSet(nativeLinkViewPtr, pos, rowIndex);
     }
-    private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
 
     public void move(long oldPos, long newPos) {
+        checkImmutable();
         nativeMove(nativeLinkViewPtr, oldPos, newPos);
     }
-    private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
 
     public void remove(long pos) {
+        checkImmutable();
         nativeRemove(nativeLinkViewPtr, pos);
     }
-    private native void nativeRemove(long nativeLinkViewPtr, long pos);
 
     public void clear() {
+        checkImmutable();
         nativeClear(nativeLinkViewPtr);
     }
-    private native void nativeClear(long nativeLinkViewPtr);
 
     public long size() {
         return nativeSize(nativeLinkViewPtr);
     }
-    private native long nativeSize(long nativeLinkViewPtr);
 
     public boolean isEmpty() {
         return nativeIsEmpty(nativeLinkViewPtr);
     }
-    private native boolean nativeIsEmpty(long nativeLinkViewPtr);
 
     public TableQuery where() {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -95,5 +112,29 @@ public TableQuery where() {
         }
     }
 
+    /**
+     * Returns the Table which all links point to.
+     */
+    public Table getTable() {
+        return parent;
+    }
+
+    private void checkImmutable() {
+        if (parent.isImmutable()) {
+            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+        }
+    }
+
+    protected static native void nativeClose(long nativeLinkViewPtr);
+    native long nativeGetRow(long nativeLinkViewPtr, long pos);
+    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
+    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
+    private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
+    private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
+    private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
+    private native void nativeRemove(long nativeLinkViewPtr, long pos);
+    private native void nativeClear(long nativeLinkViewPtr);
+    private native long nativeSize(long nativeLinkViewPtr);
+    private native boolean nativeIsEmpty(long nativeLinkViewPtr);
     protected native long nativeWhere(long nativeLinkViewPtr);
 }
diff --git a/realm/src/main/java/io/realm/internal/Mixed.java b/realm/src/main/java/io/realm/internal/Mixed.java
index 4e795c6106..6e9172b654 100644
--- a/realm/src/main/java/io/realm/internal/Mixed.java
+++ b/realm/src/main/java/io/realm/internal/Mixed.java
@@ -17,6 +17,7 @@
 package io.realm.internal;
 
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Date;
 
 public class Mixed {
@@ -24,6 +25,8 @@
     public static final int BINARY_TYPE_BYTE_ARRAY = 0;
     public static final int BINARY_TYPE_BYTE_BUFFER = 1;
 
+    private Object value;
+
     public Mixed(long value) {
         this.value = value;
     }
@@ -68,51 +71,36 @@ public Mixed(byte[] value) {
         this.value = value;
     }
 
-    public boolean equals(Object second) {
-        if (second == null)
-            return false;
-        if (!(second instanceof Mixed))
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
             return false;
-        Mixed secondMixed = (Mixed) second;
-        if (value == null) {
-            if (secondMixed.value == null) {
-                return true;
-            } else {
-                return false;
-            }
         }
-        if (!getType().equals(secondMixed.getType())) {
+
+        Mixed mixed = (Mixed) obj;
+
+        if (value.getClass() != mixed.value.getClass()) {
             return false;
         }
+
         if (value instanceof byte[]) {
-            if (!(secondMixed.value instanceof byte[])) {
-                return false;
-            }
-            byte[] firstBytes = (byte[]) value;
-            byte[] secondBytes = (byte[]) secondMixed.value;
-            if (firstBytes.length != secondBytes.length) {
-                return false;
-            }
-            for (int i = 0; i < firstBytes.length; i++) {
-                if (firstBytes[i] != secondBytes[i]) {
-                    return false;
-                }
-            }
-            return true;
+            return Arrays.equals((byte[]) value, (byte[]) mixed.value);
         }
         if (value instanceof ByteBuffer) {
-            ByteBuffer firstByteBuffer = (ByteBuffer) value;
-            ByteBuffer secondByteBuffer = (ByteBuffer) secondMixed.value;
-            if (firstByteBuffer.capacity() != secondByteBuffer.capacity()) {
-                return false;
-            }
-            for (int i = 0; i < firstByteBuffer.capacity(); i++) {
-                if (firstByteBuffer.get(i) != secondByteBuffer.get(i))
-                    return false;
-            }
-            return true;
+            return ((ByteBuffer) value).compareTo((ByteBuffer) mixed.value) == 0;
         }
-        return this.value.equals(secondMixed.value);
+        return value.equals(mixed.value);
+    }
+
+    @Override
+    public int hashCode() {
+        if (value instanceof byte[]) {
+            return Arrays.hashCode((byte[]) value);
+        }
+        return value.hashCode();
     }
 
     public ColumnType getType() {
@@ -167,38 +155,38 @@ public static Mixed mixedValue(Object value) {
 
     public long getLongValue() {
         if (!(value instanceof Long)) {
-            throw new IllegalMixedTypeException("Can't get a long from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a long from a Mixed containing a " + getType());
         }
-        return ((Long)value).longValue();
+        return (Long) value;
     }
 
     public boolean getBooleanValue() {
         if (!(value instanceof Boolean))
-            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containg a " + getType());
-        return ((Boolean) value).booleanValue();
+            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containing a " + getType());
+        return (Boolean) value;
     }
 
     public float getFloatValue() {
         if (!(value instanceof Float))
-            throw new IllegalMixedTypeException("Can't get a float from a Mixed containg a " + getType());
-        return ((Float) value).floatValue();
+            throw new IllegalMixedTypeException("Can't get a float from a Mixed containing a " + getType());
+        return (Float) value;
     }
 
     public double getDoubleValue() {
         if (!(value instanceof Double))
-            throw new IllegalMixedTypeException("Can't get a double from a Mixed containg a " + getType());
-        return ((Double) value).doubleValue();
+            throw new IllegalMixedTypeException("Can't get a double from a Mixed containing a " + getType());
+        return (Double) value;
     }
 
     public String getStringValue() {
         if (!(value instanceof String))
-            throw new IllegalMixedTypeException("Can't get a String from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a String from a Mixed containing a " + getType());
         return (String) value;
     }
 
     public Date getDateValue() {
         if (!(value instanceof Date)) {
-            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containing a " + getType());
         }
         return (Date) value;
     }
@@ -209,14 +197,14 @@ protected long getDateTimeValue() {
 
     public ByteBuffer getBinaryValue() {
         if (!(value instanceof ByteBuffer)) {
-            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containing a " + getType());
         }
         return (ByteBuffer) value;
     }
 
     public byte[] getBinaryByteArray() {
         if (!(value instanceof byte[])) {
-            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containg a " + getType());
+            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containing a " + getType());
         }
         return (byte[]) value;
     }
@@ -231,8 +219,6 @@ public int getBinaryType() {
         return -1;
     }
 
-    private Object value;
-
     public Object getValue() {
         return value;
     }
diff --git a/realm/src/main/java/io/realm/internal/NativeObject.java b/realm/src/main/java/io/realm/internal/NativeObject.java
new file mode 100644
index 0000000000..609bffb3c8
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/NativeObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+/**
+ * This abstract class represents a native object from core.
+ * It specifies the operations common to all such objects.
+ * All Java classes wrapping a core class should extend NativeObject.
+ */
+public abstract class NativeObject {
+    long nativePointer;
+}
diff --git a/realm/src/main/java/io/realm/internal/NativeObjectReference.java b/realm/src/main/java/io/realm/internal/NativeObjectReference.java
new file mode 100644
index 0000000000..06738174b2
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/NativeObjectReference.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+
+/**
+ * This class is used for holding the reference to the native pointers present in NativeObjects.
+ * This is required as phantom references cannot access the original objects for this value.
+ */
+public class NativeObjectReference extends PhantomReference<NativeObject> {
+
+    // The pointer to the native object to be handled
+    final long nativePointer;
+
+    public NativeObjectReference(NativeObject referent, ReferenceQueue<? super NativeObject> referenceQueue) {
+        super(referent, referenceQueue);
+        nativePointer = referent.nativePointer;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/RealmCore.java b/realm/src/main/java/io/realm/internal/RealmCore.java
index 6c02c63a75..d60c0758a0 100644
--- a/realm/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/src/main/java/io/realm/internal/RealmCore.java
@@ -59,7 +59,7 @@ private static String getJniFileName()
     public static boolean osIsWindows()
     {
         String os = System.getProperty("os.name").toLowerCase(Locale.getDefault());
-        return (os.indexOf("win") >= 0);
+        return (os.contains("win"));
     }
 
     public static byte[] serialize(Serializable value) {
@@ -129,11 +129,11 @@ public static void loadLibrary() {
 
         init();
 
-        String jnilib;
         if (osIsWindows()) {
-            jnilib = loadLibraryWindows();
+            loadLibraryWindows();
         }
         else {
+            String jnilib;
             String debug = System.getenv("REALM_JAVA_DEBUG");
             if (debug == null || debug.isEmpty()) {
                 jnilib = "realm-jni";
diff --git a/realm/src/main/java/io/realm/internal/RealmJson.java b/realm/src/main/java/io/realm/internal/RealmJson.java
deleted file mode 100644
index 7972b44616..0000000000
--- a/realm/src/main/java/io/realm/internal/RealmJson.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package io.realm.internal;
-
-import android.util.JsonReader;
-
-import java.io.IOException;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import io.realm.RealmObject;
-
-/**
- * Interface for classes capable of adding JSON data to both mananged and non-managed RealmObjects.
- */
-public interface RealmJson {
-    public <E extends RealmObject> void populateUsingJsonObject(E obj, JSONObject json) throws JSONException;
-    public <E extends RealmObject> void populateUsingJsonStream(E obj, JsonReader reader) throws IOException;
-}
\ No newline at end of file
diff --git a/realm/src/main/java/io/realm/internal/RealmObjectProxy.java b/realm/src/main/java/io/realm/internal/RealmObjectProxy.java
new file mode 100644
index 0000000000..a2b2dccb97
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/RealmObjectProxy.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * Empty interface making it easy to determine if an object is the generated RealmProxy class or the original
+ * class.
+ *
+ * Ideally all the static methods was also present here, but that is not supported before Java 8.
+ */
+public interface RealmObjectProxy {
+}
diff --git a/realm/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/src/main/java/io/realm/internal/RealmProxyMediator.java
new file mode 100644
index 0000000000..6e94013142
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.util.JsonReader;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.List;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.RealmObject;
+import io.realm.exceptions.RealmException;
+
+/**
+ * Superclass for the RealmProxyMediator class'. This class contain all static methods introduced by the
+ * annotation processor as part of the RealmProxy classes.
+ *
+ * Classes extending this class act as binders between the static methods inside each RealmProxy and the code
+ * at runtime. We cannot rely on using reflection as the RealmProxies are generated by the annotation processor
+ * before ProGuard is run. So after ProGuard has run there is a mismatch between the name of the RealmProxy and
+ * the original RealmObject class.
+ */
+public abstract class RealmProxyMediator {
+
+    /**
+     * Creates the backing table in Realm for the given model class.
+     *
+     * @param clazz         RealmObject model class to create backing table for.
+     * @param transaction   Read transaction for the Realm to create table in.
+     */
+    public abstract Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+
+    /**
+     * Validate the backing table in Realm for the given model class.
+     *
+     * @param clazz         RealmObject model class to validate.
+     * @param transaction   Read transaction for the Realm to validate against.
+     */
+    public abstract void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction);
+
+    /**
+     * Returns a map of non-obfuscated object field names to their internal realm name.
+     *
+     * @param clazz  RealmObject model class reference.
+     * @return The simple name of an model class (before it has been obfuscated)
+     */
+    public abstract List<String> getFieldNames(Class<? extends RealmObject> clazz);
+
+    /**
+     * Returns name that Realm should use for all it's internal tables. This is normally the unobfuscated named of a
+     * class.
+     *
+     * @param clazz  RealmObject model class reference.
+     * @return The simple name of an model class (before it has been obfuscated)
+     *
+     * @throws java.lang.NullPointerException if null is given as argument.
+     */
+    public abstract String getTableName(Class<? extends RealmObject> clazz);
+
+    /**
+     * Creates a new instance of an RealmProxy for the given model class.
+     *
+     * @param clazz RealmObject to create RealmProxy for.
+     * @return Created RealmProxy object.
+     */
+    public abstract <E extends RealmObject> E newInstance(Class<E> clazz);
+
+    /**
+     * Returns the list of model classes that Realm supports in this application.
+     *
+     * @return List of class references to model classes. Empty list if no models are supported.
+     */
+    public abstract List<Class<? extends RealmObject>> getModelClasses();
+
+    /**
+     * Returns a map of the column indices for all Realm fields in the model class.
+     *
+     * @return Map from field name to column indices for all Realm fields in the model class.
+     */
+    public abstract  Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz);
+
+    /**
+     * Copy a non-manged RealmObject or a RealmObject from another Realm to this Realm. After being
+     * copied any changes to the original object will not be persisted.
+     *
+     * @param object Object to copy properties from.
+     * @param update True if object has a primary key and should try to update already existing data, false otherwise.
+     * @param cache Cache for mapping between standalone objects and their RealmProxy representation.
+     * @return Managed Realm object.
+     */
+    public abstract <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache);
+
+    /**
+     * Creates or updates a RealmObject using the provided JSON data.
+     *
+     * @param clazz     Type of RealmObject
+     * @param realm     Reference to Realm where to create the object.
+     * @param json      JSON data
+     * @param update    True if Realm should try to update a existing object. This requires that the model has a @PrimaryKey
+     * @return RealmObject that has been created or updated.
+     * @throws JSONException If the JSON mapping doesn't match the expected class.
+     */
+    public abstract <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException;
+
+    /**
+     * Creates new RealmObjects based on a JSON input stream.
+     *
+     * @param clazz     Type of RealmObject
+     * @param realm     Reference to Realm where to create the object.
+     * @param reader    Reference to the InputStream containg the JSON data.
+     * @return The created RealmObject
+     * @throws IOException if an error occurs with the inputstream.
+     */
+    public abstract <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
+
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof RealmProxyMediator)) {
+            return false;
+        }
+        RealmProxyMediator other = (RealmProxyMediator) o;
+        return getModelClasses().equals(other.getModelClasses());
+    }
+
+    @Override
+    public int hashCode() {
+        return getModelClasses().hashCode();
+    }
+
+    protected static void checkClass(Class<? extends RealmObject> clazz) {
+        if (clazz == null) {
+            throw new NullPointerException("A class extending RealmObject must be provided");
+        }
+    }
+
+    protected static RealmException getMissingProxyClassException(Class<? extends RealmObject> clazz) {
+        return new RealmException(clazz + " is not part of the schema for this Realm.");
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/Row.java b/realm/src/main/java/io/realm/internal/Row.java
index badb6b05ee..ee700cf7b5 100644
--- a/realm/src/main/java/io/realm/internal/Row.java
+++ b/realm/src/main/java/io/realm/internal/Row.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2015 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -12,29 +12,19 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
  */
 
 package io.realm.internal;
 
 import java.util.Date;
 
-public class Row {
-
-    private final Context context;
-    private final Table parent;
-    protected long nativePtr;
-
-    Row(Context context, Table parent, long nativePtr) {
-        this.context = context;
-        this.parent = parent;
-        this.nativePtr = nativePtr;
-    }
-
-    public long getColumnCount() {
-        return nativeGetColumnCount(nativePtr);
-    }
+/**
+ * Interface for Row objects that act as wrappers around the Realm Core Row object.
+ */
+public interface Row {
 
-    protected native long nativeGetColumnCount(long nativeTablePtr);
+    long getColumnCount();
 
     /**
      * Returns the name of a column identified by columnIndex. Notice that the
@@ -43,11 +33,7 @@ public long getColumnCount() {
      * @param columnIndex the column index
      * @return the name of the column
      */
-    public String getColumnName(long columnIndex) {
-        return nativeGetColumnName(nativePtr, columnIndex);
-    }
-
-    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    String getColumnName(long columnIndex);
 
     /**
      * Returns the 0-based index of a column based on the name.
@@ -55,227 +41,68 @@ public String getColumnName(long columnIndex) {
      * @param columnName column name
      * @return the index, -1 if not found
      */
-    public long getColumnIndex(String columnName) {
-        if (columnName == null) {
-            throw new IllegalArgumentException("Column name can not be null.");
-        }
-        return nativeGetColumnIndex(nativePtr, columnName);
-    }
-
-    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
-
+    long getColumnIndex(String columnName);
 
     /**
-     * Get the type of a column identified by the columnIdex.
+     * Get the type of a column identified by the columnIndex.
      *
      * @param columnIndex index of the column.
      * @return Type of the particular column.
      */
-    public ColumnType getColumnType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
-    }
-
-    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
-
-    // Getters
-
-    public Table getTable() {
-        return parent;
-    }
-
-    public long getIndex() {
-        return nativeGetIndex(nativePtr);
-    }
-
-    protected native long nativeGetIndex(long nativeRowPtr);
-
-    public long getLong(long columnIndex) {
-        return nativeGetLong(nativePtr, columnIndex);
-    }
-
-    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
-
-    public boolean getBoolean(long columnIndex) {
-        return nativeGetBoolean(nativePtr, columnIndex);
-    }
-
-    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
-
-    public float getFloat(long columnIndex) {
-        return nativeGetFloat(nativePtr, columnIndex);
-    }
-
-    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
-
-    public double getDouble(long columnIndex) {
-        return nativeGetDouble(nativePtr, columnIndex);
-    }
-
-    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-
-    public Date getDate(long columnIndex) {
-        return new Date(nativeGetDateTime(nativePtr, columnIndex)*1000);
-    }
-
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
-
-
-    public String getString(long columnIndex) {
-        return nativeGetString(nativePtr, columnIndex);
-    }
-
-    protected native String nativeGetString(long nativePtr, long columnIndex);
-
-
-    public byte[] getBinaryByteArray(long columnIndex) {
-        return nativeGetByteArray(nativePtr, columnIndex);
-    }
-
-    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-
-
-    public Mixed getMixed(long columnIndex) {
-        return nativeGetMixed(nativePtr, columnIndex);
-    }
-
-    public ColumnType getMixedType(long columnIndex) {
-        return ColumnType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex));
-    }
-
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-
-    public long getLink(long columnIndex) {
-        return nativeGetLink(nativePtr, columnIndex);
-    }
-
-    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
-
-    public boolean isNullLink(long columnIndex) {
-        return nativeIsNullLink(nativePtr, columnIndex);
-    }
-
-    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
-
-    public LinkView getLinkList(long columnIndex) {
-        long nativeLinkViewPtr = nativeGetLinkView(nativePtr, columnIndex);
-        return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
-    }
-
-    private native long nativeGetLinkView(long nativePtr, long columnIndex);
+    ColumnType getColumnType(long columnIndex);
 
+    Table getTable();
 
-    // Setters
+    long getIndex();
 
-    public void setLong(long columnIndex, long value) {
-        parent.checkImmutable();
-        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetLong(nativePtr, columnIndex, value);
-    }
+    long getLong(long columnIndex);
 
-    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    boolean getBoolean(long columnIndex);
 
-    public void setBoolean(long columnIndex, boolean value) {
-        parent.checkImmutable();
-        nativeSetBoolean(nativePtr, columnIndex, value);
-    }
+    float getFloat(long columnIndex);
 
-    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    double getDouble(long columnIndex);
 
-    public void setFloat(long columnIndex, float value) {
-        parent.checkImmutable();
-        nativeSetFloat(nativePtr, columnIndex, value);
-    }
+    Date getDate(long columnIndex);
 
-    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    String getString(long columnIndex);
 
-    public void setDouble(long columnIndex, double value) {
-        parent.checkImmutable();
-        nativeSetDouble(nativePtr, columnIndex, value);
-    }
+    byte[] getBinaryByteArray(long columnIndex);
 
-    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    Mixed getMixed(long columnIndex);
 
-    public void setDate(long columnIndex, Date date) {
-        parent.checkImmutable();
-        if (date == null) {
-            throw new IllegalArgumentException("Null Date is not allowed.");
-        }
-        long timestamp = date.getTime() / 1000;
-        if (timestamp >= Integer.MAX_VALUE || timestamp <= Integer.MIN_VALUE) {
-            throw new IllegalArgumentException("Date/timestamp is outside valid range");
-        }
-        nativeSetDate(nativePtr, columnIndex, timestamp);
-    }
+    ColumnType getMixedType(long columnIndex);
 
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    long getLink(long columnIndex);
 
-    public void setString(long columnIndex, String value) {
-        parent.checkImmutable();
-        getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
-        nativeSetString(nativePtr, columnIndex, value);
-    }
+    boolean isNullLink(long columnIndex);
 
-    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    LinkView getLinkList(long columnIndex);
 
-    public void setBinaryByteArray(long columnIndex, byte[] data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null array is not allowed");
-        }
-        nativeSetByteArray(nativePtr, columnIndex, data);
-    }
+    void setLong(long columnIndex, long value);
 
-    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    void setBoolean(long columnIndex, boolean value);
 
+    void setFloat(long columnIndex, float value);
 
-    public void setMixed(long columnIndex, Mixed data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null data is not allowed");
-        }
-        nativeSetMixed(nativePtr, columnIndex, data);
-    }
+    void setDouble(long columnIndex, double value);
 
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
+    void setDate(long columnIndex, Date date);
 
-    public void setLink(long columnIndex, long value) {
-        parent.checkImmutable();
-        nativeSetLink(nativePtr, columnIndex, value);
-    }
+    void setString(long columnIndex, String value);
 
-    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    void setBinaryByteArray(long columnIndex, byte[] data);
 
-    public void nullifyLink(long columnIndex) {
-        parent.checkImmutable();
-        nativeNullifyLink(nativePtr, columnIndex);
-    }
+    void setMixed(long columnIndex, Mixed data);
 
-    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
+    void setLink(long columnIndex, long value);
 
-    protected static native void nativeClose(long nativeRowPtr);
+    void nullifyLink(long columnIndex);
 
     /**
      * Checks if the row is still valid.
      * @return Returns true {@code true} if the row is still valid and attached to the underlying
      * data. {@code false} otherwise.
      */
-    public boolean isAttached() {
-        return nativePtr != 0 && nativeIsAttached(nativePtr);
-    }
-
-    protected native boolean nativeIsAttached(long nativeRowPtr);
-
-    @Override
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeRow(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
-        nativeClose(nativePtr);
-        nativePtr = 0;
-    }
+    boolean isAttached();
 }
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/src/main/java/io/realm/internal/SharedGroup.java
index dbff0bb48a..fc21040721 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroup.java
@@ -24,6 +24,7 @@
 
 public class SharedGroup implements Closeable {
 
+    private final String path;
     private long nativePtr;
     private long nativeReplicationPtr;
     private boolean implicitTransactionsEnabled = false;
@@ -48,7 +49,8 @@ private Durability(int value) {
 
     public SharedGroup(String databaseFile) {
         context = new Context();
-        this.nativePtr = nativeCreate(databaseFile, Durability.FULL.value, false, false, null);
+        path = databaseFile;
+        nativePtr = nativeCreate(databaseFile, Durability.FULL.value, false, false, null);
         checkNativePtrNotZero();
     }
 
@@ -61,32 +63,28 @@ public SharedGroup(String databaseFile, boolean enableImplicitTransactions, byte
             nativePtr = nativeCreate(databaseFile, Durability.FULL.value, false, false, key);
         }
         context = new Context();
+        path = databaseFile;
         checkNativePtrNotZero();
     }
 
-    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, byte[] key);
-
-    private native long nativeCreateReplication(String databaseFile, byte[] key);
-
     public SharedGroup(String databaseFile, Durability durability, byte[] key) {
+        path = databaseFile;
         context = new Context();
-        this.nativePtr = nativeCreate(databaseFile, durability.value, false, false, key);
+        nativePtr = nativeCreate(databaseFile, durability.value, false, false, key);
         checkNativePtrNotZero();
     }
 
     public SharedGroup(String databaseFile, Durability durability, boolean fileMustExist) {
+        path = databaseFile;
         context = new Context();
-        this.nativePtr = nativeCreate(databaseFile, durability.value, fileMustExist, false, null);
+        nativePtr = nativeCreate(databaseFile, durability.value, fileMustExist, false, null);
         checkNativePtrNotZero();
     }
 
-    /*
-        SharedGroup(String databaseFile, Durability durability, boolean no_create, boolean enableReplication) {
-            context = new Context();
-            this.nativePtr = nativeCreate(databaseFile, durability.value, no_create, enableReplication);
-            checkNativePtr();
-        }
-    */
+    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr, byte[] key);
+
+    private native long nativeCreateReplication(String databaseFile, byte[] key);
+
     void advanceRead() {
         nativeAdvanceRead(nativePtr);
     }
@@ -213,8 +211,6 @@ boolean isClosed() {
         return nativePtr == 0;
     }
 
-    static native String nativeGetDefaultReplicationDatabaseFileName();
-
     public boolean hasChanged() {
         return nativeHasChanged(nativePtr);
     }
@@ -223,6 +219,28 @@ public void reserve(long bytes) {
         nativeReserve(nativePtr, bytes);
     }
 
+    /**
+     * Compacts a shared group. This will block access to the shared group until done.
+     *
+     * @return True if compaction succeeded, false otherwise.
+     * @throws RuntimeException if using this within either a read or or write transaction.
+     */
+    public boolean compact() {
+        return nativeCompact(nativePtr);
+    }
+
+
+    /**
+     * Returns the absolute path to the file backing this SharedGroup.
+     *
+     * @return Absolute path to the Realm file.
+     */
+    public String getPath() {
+        return path;
+    }
+
+    private native String nativeGetDefaultReplicationDatabaseFileName();
+
     private native void nativeReserve(long nativePtr, long bytes);
 
     private native boolean nativeHasChanged(long nativePtr);
@@ -243,6 +261,8 @@ private native long nativeCreate(String databaseFile,
                                      boolean enableReplication,
                                      byte[] key);
 
+    private native boolean nativeCompact(long nativePtr);
+
     private void checkNativePtrNotZero() {
         if (this.nativePtr == 0) {
             throw new IOError(new RealmIOException("Realm could not be opened"));
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/src/main/java/io/realm/internal/Table.java
index 7a0065d51d..2978b26e0d 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/src/main/java/io/realm/internal/Table.java
@@ -18,6 +18,7 @@
 
 import java.io.Closeable;
 import java.util.Date;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.exceptions.RealmException;
 
@@ -49,7 +50,7 @@
     // test:
     protected int tableNo;
     protected boolean DEBUG = false;
-    protected static int TableCount = 0;
+    static AtomicInteger tableCount = new AtomicInteger(0);
 
     static {
         RealmCore.loadLibrary();
@@ -72,7 +73,7 @@ public Table() {
             throw new java.lang.OutOfMemoryError("Out of native memory.");
         }
         if (DEBUG) {
-            tableNo = ++TableCount;
+            tableNo = tableCount.incrementAndGet();
             System.err.println("====== New Tablebase " + tableNo + " : ptr = " + nativePtr);
         }
     }
@@ -85,7 +86,7 @@ public Table() {
         this.nativePtr = nativePointer;
 
         if (DEBUG) {
-            tableNo = ++TableCount;
+            tableNo = tableCount.incrementAndGet();
             System.err.println("===== New Tablebase(ptr) " + tableNo + " : ptr = " + nativePtr);
         }
     }
@@ -103,8 +104,8 @@ public void close() {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
                 if (DEBUG) {
-                    TableCount--;
-                    System.err.println("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + TableCount);
+                    tableCount.decrementAndGet();
+                    System.err.println("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + tableCount.get());
                 }
                 
                 nativePtr = 0;
@@ -136,31 +137,11 @@ protected void finalize() {
      */
 
     public boolean isValid() {
-        if (nativePtr == 0)
-            return false;
-        return nativeIsValid(nativePtr);
+        return nativePtr != 0 && nativeIsValid(nativePtr);
     }
 
     protected native boolean nativeIsValid(long nativeTablePtr);
 
-    @Override
-    public boolean equals(Object other) {
-        if (this == other) {
-            return true;
-        }
-        if (other == null) {
-            return false;
-        }
-        if (!(other instanceof Table)) {
-            return false; // Has to work for all the typed tables as well
-        }
-
-        Table otherTable = (Table) other;
-        return nativeEquals(nativePtr, otherTable.nativePtr);
-    }
-
-    protected native boolean nativeEquals(long nativeTablePtr, long nativeTableToComparePtr);
-
     private void verifyColumnName(String name) {
         if (name.length() > 63) {
             throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
@@ -169,7 +150,7 @@ private void verifyColumnName(String name) {
 
     @Override
     public TableSchema getSubtableSchema(long columnIndex) {
-        if(nativeIsRootTable(nativePtr) == false) {
+        if(!nativeIsRootTable(nativePtr)) {
             throw new UnsupportedOperationException("This is a subtable. Can only be called on root table.");
         }
 
@@ -396,7 +377,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
         long primaryKeyColumnIndex = getPrimaryKey();
         ColumnType type = getColumnType(primaryKeyColumnIndex);
         long rowIndex;
-        Row row;
+        UncheckedRow row;
 
         // Add with primary key initially set
         switch (type) {
@@ -408,14 +389,14 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(primaryKeyValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getRow(rowIndex);
+                row = getUncheckedRow(rowIndex);
                 row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
                 break;
 
             case INTEGER:
                 long pkValue;
                 try {
-                    pkValue = new Long(primaryKeyValue.toString());
+                    pkValue = Long.parseLong(primaryKeyValue.toString());
                 } catch (RuntimeException e) {
                     throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
                 }
@@ -423,7 +404,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     throwDuplicatePrimaryKeyException(pkValue);
                 }
                 rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                row = getRow(rowIndex);
+                row = getUncheckedRow(rowIndex);
                 row.setLong(primaryKeyColumnIndex, pkValue);
                 break;
 
@@ -517,10 +498,10 @@ public void addAt(long rowIndex, Object... values) {
                 nativeInsertLong(nativePtr, columnIndex, rowIndex, intValue);
                 break;
             case FLOAT:
-                nativeInsertFloat(nativePtr, columnIndex, rowIndex, ((Float)value).floatValue());
+                nativeInsertFloat(nativePtr, columnIndex, rowIndex, (Float) value);
                 break;
             case DOUBLE:
-                nativeInsertDouble(nativePtr, columnIndex, rowIndex, ((Double)value).doubleValue());
+                nativeInsertDouble(nativePtr, columnIndex, rowIndex, (Double) value);
                 break;
             case STRING:
                 String stringValue = (String) value;
@@ -638,12 +619,11 @@ public void set(long rowIndex, Object... values) {
                     ") does not match the number of columns in the table (" +
                     String.valueOf(columns) + ").");
         }
+
         // Verify type of 'values'
-        ColumnType colTypes[] = new ColumnType[columns];
         for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
             Object value = values[columnIndex];
             ColumnType colType = getColumnType(columnIndex);
-            colTypes[columnIndex] = colType;
             if (!colType.matchObject(value)) {
                 throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
                         ". Expected a value compatible with column type " + colType + ", but got " + value.getClass() + ".");
@@ -674,10 +654,13 @@ public long getPrimaryKey() {
             return cachedPrimaryKeyColumnIndex;
         } else {
             Table pkTable = getPrimaryKeyTable();
-            if (pkTable == null) return NO_PRIMARY_KEY; // Free table = No primary key
+            if (pkTable == null) {
+                return NO_PRIMARY_KEY; // Free table = No primary key
+            }
             long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, getName());
             if (rowIndex != NO_MATCH) {
-                cachedPrimaryKeyColumnIndex = pkTable.getRow(rowIndex).getLong(PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
+                cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
             } else {
                 cachedPrimaryKeyColumnIndex = NO_PRIMARY_KEY;
             }
@@ -692,10 +675,7 @@ public long getPrimaryKey() {
      * @return              True if column is a primary key, false otherwise.
      */
     public boolean isPrimaryKey(long columnIndex) {
-        if (columnIndex < 0) {
-            return false;
-        }
-        return columnIndex == getPrimaryKey();
+        return columnIndex >= 0 && columnIndex == getPrimaryKey();
     }
 
     /**
@@ -1009,10 +989,28 @@ public void clearSubtable(long columnIndex, long rowIndex) {
 
     protected native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
 
+    /**
+     * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
+     * If error checking is required, use {@link #getCheckedRow(long)} instead.
+     *
+     * @param index Index of row to fetch.
+     * @return Unsafe row wrapper object.
+     */
+    public UncheckedRow getUncheckedRow(long index) {
+        return UncheckedRow.get(context, this, index);
+    }
 
-    public Row getRow(long index) {
-        long nativeRowPtr = nativeGetRowPtr(nativePtr, index);
-        return new Row(context, this, nativeRowPtr);
+    /**
+     * Returns a wrapper around Row access. All access will be error checked in JNI and will throw an
+     * appropriate {@link RuntimeException} if used incorrectly.
+     *
+     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
+     *
+     * @param index Index of row to fetch./
+     * @return Safe row wrapper object.
+     */
+    public CheckedRow getCheckedRow(long index) {
+        return CheckedRow.get(context, this, index);
     }
 
     protected native long nativeGetRowPtr(long nativePtr, long index);
@@ -1152,13 +1150,14 @@ public void adjust(long columnIndex, long value) {
 
     protected native void nativeAddInt(long nativeViewPtr, long columnIndex, long value);
 
+    public void addSearchIndex(long columnIndex) {
+        checkImmutable();
+        nativeAddSearchIndex(nativePtr, columnIndex);
+    }
 
-    public void setIndex(long columnIndex) {
+    public void removeSearchIndex(long columnIndex) {
         checkImmutable();
-        if (getColumnType(columnIndex) != ColumnType.STRING) {
-            throw new IllegalArgumentException("Index is only supported on string columns.");
-        }
-        nativeSetIndex(nativePtr, columnIndex);
+        nativeRemoveSearchIndex(nativePtr, columnIndex);
     }
 
     /**
@@ -1177,8 +1176,7 @@ public void setPrimaryKey(String columnName) {
         if (pkTable == null) {
             throw new RealmException("Primary keys are only supported if Table is part of a Group");
         }
-        long index = nativeSetPrimaryKey(pkTable.nativePtr, nativePtr, columnName);
-        cachedPrimaryKeyColumnIndex = index;
+        cachedPrimaryKeyColumnIndex = nativeSetPrimaryKey(pkTable.nativePtr, nativePtr, columnName);
     }
 
     private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
@@ -1192,12 +1190,23 @@ private Table getPrimaryKeyTable() {
         Table pkTable = group.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
             pkTable.addColumn(ColumnType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
-            pkTable.addColumn(ColumnType.INTEGER, PRIMARY_KEY_FIELD_COLUMN_NAME);
+            pkTable.addColumn(ColumnType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
+        } else {
+            migratePrimaryKeyTableIfNeeded(group, pkTable);
         }
 
         return pkTable;
     }
 
+    // Migration required to fix https://github.com/realm/realm-java/issues/1059
+    // This will convert INTEGER column to the corresponding STRING column if needed.
+    // Any database created on Realm-Java 0.80.1 and below will have this error.
+    private void migratePrimaryKeyTableIfNeeded(Group group, Table pkTable) {
+        nativeMigratePrimaryKeyTableIfNeeded(group.nativePtr, pkTable.nativePtr);
+    }
+
+    private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
+
     // Recursively look at parents until either a Group or null is found
     Group getTableGroup() {
         if (parent instanceof Group)  {
@@ -1209,14 +1218,15 @@ Group getTableGroup() {
         }
     }
 
-    protected native void nativeSetIndex(long nativePtr, long columnIndex);
+    protected native void nativeAddSearchIndex(long nativePtr, long columnIndex);
 
+    protected native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
 
-    public boolean hasIndex(long columnIndex) {
-        return nativeHasIndex(nativePtr, columnIndex);
+    public boolean hasSearchIndex(long columnIndex) {
+        return nativeHasSearchIndex(nativePtr, columnIndex);
     }
 
-    protected native boolean nativeHasIndex(long nativePtr, long columnIndex);
+    protected native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
 
 
     public boolean isNullLink(long columnIndex, long rowIndex) {
@@ -1441,6 +1451,9 @@ public long findFirstDouble(long columnIndex, double value) {
 
     @Override
     public long findFirstDate(long columnIndex, Date date) {
+        if (date == null) {
+            throw new IllegalArgumentException("null is not supported");
+        }
         return nativeFindFirstDate(nativePtr, columnIndex, date.getTime() / 1000);
     }
 
@@ -1448,6 +1461,9 @@ public long findFirstDate(long columnIndex, Date date) {
 
     @Override
     public long findFirstString(long columnIndex, String value) {
+        if (value == null) {
+            throw new IllegalArgumentException("null is not supported");
+        }
         return nativeFindFirstString(nativePtr, columnIndex, value);
     }
 
@@ -1636,6 +1652,20 @@ public long sync() {
     }
 
     private void throwImmutable() {
-        throw new IllegalStateException("Mutable method call during read transaction.");
+        throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
     }
+
+    /**
+     * Compares the schema of the current instance of Table with another instance.
+     * @param table The instance to compare with. It cannot be null.
+     * @return true if the two instances have the same schema (column names and types)
+     */
+    public boolean hasSameSchema(Table table) {
+        if (table == null) {
+            throw new IllegalArgumentException("The argument cannot be null");
+        }
+        return nativeHasSameSchema(this.nativePtr, table.nativePtr);
+    }
+
+    protected native boolean nativeHasSameSchema(long thisTable, long otherTable);
 }
diff --git a/realm/src/main/java/io/realm/internal/TableQuery.java b/realm/src/main/java/io/realm/internal/TableQuery.java
index 1090e6797e..e82eaa7c63 100644
--- a/realm/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/src/main/java/io/realm/internal/TableQuery.java
@@ -660,6 +660,14 @@ public Date minimumDate(long columnIndex) {
     protected native long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
 
+    // isNull and isNotNull
+    public TableQuery isNull(long columnIndex) {
+        nativeIsNull(nativePtr, columnIndex);
+        return this;
+    }
+
+    protected native void nativeIsNull(long nativePtr, long columnIndex);
+
     // count
 
     // TODO: Rename all start, end parameter names to firstRow, lastRow
diff --git a/realm/src/main/java/io/realm/internal/UncheckedRow.java b/realm/src/main/java/io/realm/internal/UncheckedRow.java
new file mode 100644
index 0000000000..2153dc6d36
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/UncheckedRow.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.Date;
+
+/**
+ * Wrapper around a Row in Realm Core.
+ *
+ * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the annotation
+ * processor and {@link RealmProxyMediator#validateTable(Class, ImplicitTransaction)} which is called before the typed
+ * API can be used.
+ *
+ * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
+ */
+public class UncheckedRow extends NativeObject implements Row {
+
+    final Context context; // This is only kept because for now it's needed by the constructor of LinkView
+    final Table parent;
+
+    protected UncheckedRow(Context context, Table parent, long nativePtr) {
+        this.context = context;
+        this.parent = parent;
+        this.nativePointer = nativePtr;
+    }
+
+    /**
+     * Get the row object associated to an index in a Table
+     * @param context the Realm context
+     * @param table the Table that holds the row
+     * @param index the index of the row
+     * @return an instance of Row for the table and index specified
+     */
+    public static UncheckedRow get(Context context, Table table, long index) {
+        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        UncheckedRow row = new UncheckedRow(context, table, nativeRowPointer);
+        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        return row;
+    }
+
+    /**
+     * Get the row object associated to an index in a LinkView
+     * @param context the Realm context
+     * @param linkView the LinkView holding the row
+     * @param index the index of the row
+     * @return an instance of Row for the LinkView and index specified
+     */
+    public static UncheckedRow get(Context context, LinkView linkView, long index) {
+        long nativeRowPointer = linkView.nativeGetRow(linkView.nativeLinkViewPtr, index);
+        UncheckedRow row = new UncheckedRow(context, linkView.parent.getLinkTarget(linkView.columnIndexInParent), nativeRowPointer);
+        FinalizerRunnable.references.put(new NativeObjectReference(row, FinalizerRunnable.referenceQueue), Boolean.TRUE);
+        return row;
+    }
+
+    @Override
+    public long getColumnCount() {
+        return nativeGetColumnCount(nativePointer);
+    }
+
+    @Override
+    public String getColumnName(long columnIndex) {
+        return nativeGetColumnName(nativePointer, columnIndex);
+    }
+
+
+    @Override
+    public long getColumnIndex(String columnName) {
+        if (columnName == null) {
+            throw new IllegalArgumentException("Column name can not be null.");
+        }
+        return nativeGetColumnIndex(nativePointer, columnName);
+    }
+
+    @Override
+    public ColumnType getColumnType(long columnIndex) {
+        return ColumnType.fromNativeValue(nativeGetColumnType(nativePointer, columnIndex));
+    }
+
+    // Getters
+
+    @Override
+    public Table getTable() {
+        return parent;
+    }
+
+    @Override
+    public long getIndex() {
+        return nativeGetIndex(nativePointer);
+    }
+
+    @Override
+    public long getLong(long columnIndex) {
+        return nativeGetLong(nativePointer, columnIndex);
+    }
+
+    @Override
+    public boolean getBoolean(long columnIndex) {
+        return nativeGetBoolean(nativePointer, columnIndex);
+    }
+
+    @Override
+    public float getFloat(long columnIndex) {
+        return nativeGetFloat(nativePointer, columnIndex);
+    }
+
+    @Override
+    public double getDouble(long columnIndex) {
+        return nativeGetDouble(nativePointer, columnIndex);
+    }
+
+    @Override
+    public Date getDate(long columnIndex) {
+        return new Date(nativeGetDateTime(nativePointer, columnIndex)*1000);
+    }
+
+    @Override
+    public String getString(long columnIndex) {
+        return nativeGetString(nativePointer, columnIndex);
+    }
+
+    @Override
+    public byte[] getBinaryByteArray(long columnIndex) {
+        return nativeGetByteArray(nativePointer, columnIndex);
+    }
+
+    @Override
+    public Mixed getMixed(long columnIndex) {
+        return nativeGetMixed(nativePointer, columnIndex);
+    }
+
+    @Override
+    public ColumnType getMixedType(long columnIndex) {
+        return ColumnType.fromNativeValue(nativeGetMixedType(nativePointer, columnIndex));
+    }
+
+    @Override
+    public long getLink(long columnIndex) {
+        return nativeGetLink(nativePointer, columnIndex);
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        return nativeIsNullLink(nativePointer, columnIndex);
+    }
+
+    @Override
+    public LinkView getLinkList(long columnIndex) {
+        long nativeLinkViewPtr = nativeGetLinkView(nativePointer, columnIndex);
+        return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
+    }
+
+    // Setters
+
+    @Override
+    public void setLong(long columnIndex, long value) {
+        parent.checkImmutable();
+        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
+        nativeSetLong(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setBoolean(long columnIndex, boolean value) {
+        parent.checkImmutable();
+        nativeSetBoolean(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setFloat(long columnIndex, float value) {
+        parent.checkImmutable();
+        nativeSetFloat(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setDouble(long columnIndex, double value) {
+        parent.checkImmutable();
+        nativeSetDouble(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setDate(long columnIndex, Date date) {
+        parent.checkImmutable();
+        if (date == null) {
+            throw new IllegalArgumentException("Null Date is not allowed.");
+        }
+        long timestamp = date.getTime() / 1000;
+        if (timestamp >= Integer.MAX_VALUE || timestamp <= Integer.MIN_VALUE) {
+            throw new IllegalArgumentException("Date/timestamp is outside valid range");
+        }
+        nativeSetDate(nativePointer, columnIndex, timestamp);
+    }
+
+    @Override
+    public void setString(long columnIndex, String value) {
+        parent.checkImmutable();
+        getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
+        nativeSetString(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void setBinaryByteArray(long columnIndex, byte[] data) {
+        parent.checkImmutable();
+        if (data == null) {
+            throw new IllegalArgumentException("Null array is not allowed");
+        }
+        nativeSetByteArray(nativePointer, columnIndex, data);
+    }
+
+    @Override
+    public void setMixed(long columnIndex, Mixed data) {
+        parent.checkImmutable();
+        if (data == null) {
+            throw new IllegalArgumentException("Null data is not allowed");
+        }
+        nativeSetMixed(nativePointer, columnIndex, data);
+    }
+
+    @Override
+    public void setLink(long columnIndex, long value) {
+        parent.checkImmutable();
+        nativeSetLink(nativePointer, columnIndex, value);
+    }
+
+    @Override
+    public void nullifyLink(long columnIndex) {
+        parent.checkImmutable();
+        nativeNullifyLink(nativePointer, columnIndex);
+    }
+
+    /**
+     * Converts the unchecked Row to a checked variant.
+     *
+     * @return CheckedRow wrapping the same Realm data as the original Row.
+     */
+    public CheckedRow convertToChecked() {
+        return CheckedRow.getFromRow(this);
+    }
+
+    @Override
+    public boolean isAttached() {
+        return nativePointer != 0 && nativeIsAttached(nativePointer);
+    }
+
+    protected native long nativeGetColumnCount(long nativeTablePtr);
+    protected native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
+    protected native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
+    protected native long nativeGetIndex(long nativeRowPtr);
+    protected native long nativeGetLong(long nativeRowPtr, long columnIndex);
+    protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
+    protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
+    protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native String nativeGetString(long nativePtr, long columnIndex);
+    protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
+    protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
+    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
+    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
+    protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
+    protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
+    protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
+    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
+    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
+    protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
+    protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
+    protected static native void nativeClose(long nativeRowPtr);
+    protected native boolean nativeIsAttached(long nativeRowPtr);
+}
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/src/main/java/io/realm/internal/Util.java
index 3e0110f75b..8ea8172f01 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/src/main/java/io/realm/internal/Util.java
@@ -16,7 +16,7 @@
 
 package io.realm.internal;
 
-import java.util.Scanner;
+import io.realm.RealmObject;
 
 public class Util {
 
@@ -40,12 +40,6 @@ static void javaPrint(String txt) {
         System.out.print(txt);
     }
 
-    public static void waitForEnter() {
-        System.out.println("Press Enter to continue...");
-        Scanner sc = new Scanner(System.in);
-           while(!sc.nextLine().equals(""));
-        sc.close();
-    }
 
     // Testcases run in nativeCode
     public enum Testcase {
@@ -80,4 +74,20 @@ public String execute(long parm1) {
 
     static native String nativeTestcase(int testcase, boolean dotest, long parm1);
 
+    /**
+     * Normalize a input class to it's original model class so it is transparent whether or not the input class
+     * was a RealmProxy class.
+     */
+    public static Class<? extends RealmObject> getOriginalModelClass(Class<? extends RealmObject> clazz) {
+        //This cast is correct because 'clazz' is either the type
+        //generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked")
+        Class<? extends RealmObject> superclass = (Class<? extends RealmObject>) clazz.getSuperclass();
+
+        if (!superclass.equals(RealmObject.class)) {
+            clazz = superclass;
+        }
+
+        return clazz;
+    }
 }
diff --git a/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java b/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
index 0008b9085e..cc898ffac2 100644
--- a/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
+++ b/realm/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
@@ -8,6 +8,6 @@
 public class DebugAndroidLogger extends AndroidLogger {
 
     public DebugAndroidLogger() {
-        setMinimumLogLevel(RealmLog.WARN);
+        setMinimumLogLevel(RealmLog.VERBOSE);
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java b/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
index 9620df711a..4d76cd8947 100644
--- a/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
+++ b/realm/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
@@ -9,6 +9,6 @@
 public class ReleaseAndroidLogger extends AndroidLogger {
 
     public ReleaseAndroidLogger() {
-        setMinimumLogLevel(RealmLog.VERBOSE);
+        setMinimumLogLevel(RealmLog.WARN);
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/log/RealmLog.java b/realm/src/main/java/io/realm/internal/log/RealmLog.java
index 3b82a72e6e..cbb411b381 100644
--- a/realm/src/main/java/io/realm/internal/log/RealmLog.java
+++ b/realm/src/main/java/io/realm/internal/log/RealmLog.java
@@ -47,61 +47,61 @@ public static void remove(Logger logger) {
 
     public static void v(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message);
+            LOGGERS.get(i).v(message);
         }
     }
 
     public static void v(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message, t);
+            LOGGERS.get(i).v(message, t);
         }
     }
 
     public static void d(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).d(message);
+            LOGGERS.get(i).d(message);
         }
     }
 
     public static void d(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).d(message, t);
+            LOGGERS.get(i).d(message, t);
         }
     }
 
     public static void i(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).i(message);
+            LOGGERS.get(i).i(message);
         }
     }
 
     public static void i(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).i(message, t);
+            LOGGERS.get(i).i(message, t);
         }
     }
 
     public static void w(String message) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).w(message);
+            LOGGERS.get(i).w(message);
         }
     }
 
     public static void w(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).w(message, null);
+            LOGGERS.get(i).w(message, null);
         }
     }
 
     public static void e(String message)  {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).e(message);
+            LOGGERS.get(i).e(message);
         }
     }
 
     public static void e(String message, Throwable t) {
         for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(0).v(message, t);
+            LOGGERS.get(i).v(message, t);
         }
     }
 }
diff --git a/realm/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/src/main/java/io/realm/internal/modules/CompositeMediator.java
new file mode 100644
index 0000000000..f977110c6d
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.modules;
+
+import android.util.JsonReader;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.RealmObject;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+import io.realm.internal.Util;
+
+/**
+ * This class is able to merge different RealmProxyMediators, so they look like one.
+ */
+public class CompositeMediator extends RealmProxyMediator {
+
+    Map<Class<? extends RealmObject>, RealmProxyMediator> mediators = new HashMap<Class<? extends RealmObject>, RealmProxyMediator>();
+
+    public void addMediator(RealmProxyMediator mediator) {
+        for (Class<? extends RealmObject> realmClass : mediator.getModelClasses()) {
+            mediators.put(realmClass, mediator);
+        }
+    }
+
+    @Override
+    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.createTable(clazz, transaction);
+    }
+
+    @Override
+    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        mediator.validateTable(clazz, transaction);
+    }
+
+    @Override
+    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.getFieldNames(clazz);
+    }
+
+    @Override
+    public String getTableName(Class<? extends RealmObject> clazz) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.getTableName(clazz);
+    }
+
+    @Override
+    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.newInstance(clazz);
+    }
+
+    @Override
+    public List<Class<? extends RealmObject>> getModelClasses() {
+        List<Class<? extends RealmObject>> list = new ArrayList<Class<? extends RealmObject>>();
+        for (RealmProxyMediator mediator : mediators.values()) {
+            list.addAll(mediator.getModelClasses());
+        }
+        return list;
+    }
+
+    @Override
+    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.getColumnIndices(clazz);
+    }
+
+    @Override
+    public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        return mediator.copyOrUpdate(realm, object, update, cache);
+    }
+
+    @Override
+    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.createOrUpdateUsingJsonObject(clazz, realm, json, update);
+    }
+
+    @Override
+    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
+        RealmProxyMediator mediator = getMediator(clazz);
+        return mediator.createUsingJsonStream(clazz, realm, reader);
+    }
+
+    // Returns the mediator for a given model class (not RealmProxy) or throws exception
+    private RealmProxyMediator getMediator(Class<? extends RealmObject> clazz) {
+        RealmProxyMediator mediator = mediators.get(clazz);
+        if (mediator == null) {
+            throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
+        }
+        return mediator;
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/src/main/java/io/realm/internal/modules/FilterableMediator.java
new file mode 100644
index 0000000000..7666fd8762
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2015 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.modules;
+
+import android.util.JsonReader;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.Realm;
+import io.realm.RealmObject;
+import io.realm.internal.ImplicitTransaction;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Table;
+import io.realm.internal.Util;
+
+/**
+ * Specialized version of a RealmProxyMediator that can further filter the available classes based on provided filter
+ */
+public class FilterableMediator extends RealmProxyMediator {
+
+    private RealmProxyMediator originalMediator;
+    private Set<Class<? extends RealmObject>> allowedClasses = new HashSet<Class<? extends RealmObject>>();
+
+    /**
+     * Creates a filterable Mediator.
+     *
+     * @param originalMediator      Original auto generated mediator.
+     * @param allowedClasses                Subset of classes from original mediator to allow.
+     */
+    public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<? extends RealmObject>> allowedClasses) {
+        this.originalMediator = originalMediator;
+        if (originalMediator != null) {
+            List<Class<? extends RealmObject>> originalClasses = originalMediator.getModelClasses();
+            for (Class<? extends RealmObject> clazz : allowedClasses) {
+                if (originalClasses.contains(clazz)) {
+                    this.allowedClasses.add(clazz);
+                }
+            }
+        }
+    }
+
+    public RealmProxyMediator getOriginalMediator() {
+        return originalMediator;
+    }
+
+    @Override
+    public Table createTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.createTable(clazz, transaction);
+    }
+
+    @Override
+    public void validateTable(Class<? extends RealmObject> clazz, ImplicitTransaction transaction) {
+        checkSchemaHasClass(clazz);
+        originalMediator.validateTable(clazz, transaction);
+    }
+
+    @Override
+    public List<String> getFieldNames(Class<? extends RealmObject> clazz) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.getFieldNames(clazz);
+    }
+
+    @Override
+    public String getTableName(Class<? extends RealmObject> clazz) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.getTableName(clazz);
+    }
+
+    @Override
+    public <E extends RealmObject> E newInstance(Class<E> clazz) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.newInstance(clazz);
+    }
+
+    @Override
+    public List<Class<? extends RealmObject>> getModelClasses() {
+        return new ArrayList<Class<? extends RealmObject>>(allowedClasses);
+    }
+
+    @Override
+    public Map<String, Long> getColumnIndices(Class<? extends RealmObject> clazz) {
+        checkSchemaHasClass(clazz);
+        return originalMediator.getColumnIndices(clazz);
+    }
+
+    @Override
+    public <E extends RealmObject> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmObject, RealmObjectProxy> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        return originalMediator.copyOrUpdate(realm, object, update, cache);
+    }
+
+    @Override
+    public <E extends RealmObject> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
+        checkSchemaHasClass(clazz);
+        return originalMediator.createOrUpdateUsingJsonObject(clazz, realm, json, update);
+    }
+
+    @Override
+    public <E extends RealmObject> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws IOException {
+        checkSchemaHasClass(clazz);
+        return originalMediator.createUsingJsonStream(clazz, realm, reader);
+    }
+
+    // Validate if a model class (not RealmProxy) is part of this Schema.
+    private void checkSchemaHasClass(Class<? extends RealmObject> clazz) {
+        if (!allowedClasses.contains(clazz)) {
+            throw new IllegalArgumentException(clazz.getSimpleName() + " is not part of the schema for this Realm");
+        }
+    }
+}
diff --git a/settings.gradle b/settings.gradle
index d0eb92858e..c5554d3fc0 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -8,8 +8,10 @@ include ':introExample',
         ':migrationExample',
         ':adapterExample',
         ':threadExample',
-		':jsonExample'
-
+        ':jsonExample',
+        ':realmModuleAppExample',
+        ':realmModuleLibraryExample',
+        ':kotlinExample'
 
 project(':introExample').projectDir = new File('examples/introExample')
 project(':gridViewExample').projectDir = new File('examples/gridViewExample')
@@ -18,6 +20,9 @@ project(':migrationExample').projectDir = new File('examples/migrationExample')
 project(':adapterExample').projectDir = new File('examples/adapterExample')
 project(':threadExample').projectDir = new File('examples/threadExample')
 project(':jsonExample').projectDir = new File('examples/jsonExample')
+project(':realmModuleAppExample').projectDir = new File('examples/realmModuleExample/app')
+project(':realmModuleLibraryExample').projectDir = new File('examples/realmModuleExample/library')
+project(':kotlinExample').projectDir = new File('examples/kotlinExample')
 
 // Experimental projects
 include ':pathExperiment'
diff --git a/test/concurrencyExample/build.gradle b/test/concurrencyExample/build.gradle
deleted file mode 100644
index 7d080b3f8b..0000000000
--- a/test/concurrencyExample/build.gradle
+++ /dev/null
@@ -1,46 +0,0 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.1'
-    }
-}
-
-apply plugin: 'com.android.application'
-apply plugin: 'android-apt'
-
-android {
-    compileSdkVersion 19
-    buildToolsVersion "20.0.0"
-    defaultConfig {
-        applicationId 'examples.realm.io.concurrencyExample'
-        minSdkVersion 15
-        targetSdkVersion 19
-        versionCode 1
-        versionName "1.0"
-    }
-    buildTypes {
-        release {
-            runProguard false
-            //proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
-    productFlavors {
-    }
-}
-
-task buildApt(type: GradleBuild) {
-    dir = file('../../realm-annotations-processor')
-    tasks = ['build']
-}
-
-tasks.preBuild {
-    dependsOn buildApt
-}
-
-dependencies {
-    apt files("../../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
-    compile 'com.google.code.gson:gson:2.3'
-    compile project(':realm')
-}
diff --git a/test/concurrencyExample/src/main/AndroidManifest.xml b/test/concurrencyExample/src/main/AndroidManifest.xml
deleted file mode 100644
index cbd2562cf0..0000000000
--- a/test/concurrencyExample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm.examples.concurrency">
-
-    <application
-        android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
-        android:label="@string/app_name"
-        android:theme="@style/AppTheme">
-        <activity
-            android:name=".RealmExampleActivity"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:label="@string/app_name">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-
-        <service
-            android:name=".BgSpawningService"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:enabled="true"
-            android:exported="false"
-            android:label="Realm Service" />
-
-        <service
-            android:name=".BgService"
-            android:configChanges="keyboardHidden|orientation|screenSize"
-            android:enabled="true"
-            android:exported="false"
-            android:label="Realm Service" />
-    </application>
-
-</manifest>
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java
deleted file mode 100644
index 0c2edeecf4..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgReaderThread.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.content.Context;
-import android.util.Log;
-
-import java.util.List;
-
-import io.realm.Realm;
-import io.realm.RealmQuery;
-import io.realm.examples.service.model.Person;
-
-public class BgReaderThread extends Thread implements KillableThread {
-
-    public static final String TAG = BgReaderThread.class.getName();
-
-    private Context context = null;
-    private Realm realm = null;
-
-    public BgReaderThread(Context context) {
-        this.context = context;
-    }
-
-    public void run() {
-        realm = Realm.getInstance(context);
-
-        while (running) {
-            try {
-                RealmQuery realmQuery = realm.where(Person.class);
-                List<Person> list = realmQuery.findAll();
-                Log.d(TAG, "First item: " + realmQuery.findFirst());
-            } catch (Exception e) {
-                e.printStackTrace();
-                terminate();
-            }
-        }
-    }
-
-    private boolean running = true;
-
-    @Override
-    public void terminate() {
-        running = false;
-    }
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java
deleted file mode 100644
index 38e75625d3..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgService.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.IntentService;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.util.Log;
-
-import io.realm.Realm;
-import io.realm.RealmChangeListener;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class BgService extends IntentService {
-
-    public static final String TAG = BgService.class.getName();
-
-    private Boolean serviceQuitting = false;
-
-    public static final String REALM_FILE_EXTRA = "RealmFileExtra";
-
-    private Realm realm = null;
-
-    public BgService() {
-        super(BgSpawningService.class.getName());
-    }
-
-    @Override
-    protected void onHandleIntent(Intent intent) {
-        Log.d(TAG, "Starting intent...");
-
-        realm = Realm.getInstance(this);
-        realm.addChangeListener(new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                Log.d(TAG, "RECEIVED_NOTIFICATION: " + Thread.currentThread().toString());
-            }
-        });
-
-        while(!serviceQuitting) {
-            int iterCount = 0;
-            realm.beginTransaction();
-            while (iterCount < 20 && serviceQuitting == false) {
-                if ((iterCount % 1000) == 0) {
-                    Log.d(TAG, "WR_OPERATION#: " + iterCount + "," + Thread.currentThread().getName());
-                }
-
-                Person person = realm.createObject(Person.class);
-                person.setName("New person");
-                iterCount++;
-            }
-            realm.commitTransaction();
-        }
-
-        Log.d(TAG, "Service has quit");
-    }
-
-    @Override
-    public void onDestroy() {
-        this.serviceQuitting = true;
-    }
-
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java
deleted file mode 100644
index 3563305603..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgSpawningService.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-import android.util.Log;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
-public class BgSpawningService extends Service {
-
-    public static final String TAG = BgSpawningService.class.getName();
-
-    private Boolean serviceQuitting = false;
-
-    public static final String REALM_FILE_EXTRA = "RealmFileExtra";
-
-    private File realmPath = null;
-
-    private List<KillableThread> allThreads = null;
-
-    BgWriterThread wT = null;
-    BgReaderThread rT = null;
-
-    public void onCreate() {
-        super.onCreate();
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        this.realmPath = (File)intent.getSerializableExtra(REALM_FILE_EXTRA);
-        try {
-            allThreads = new ArrayList<KillableThread>();
-            wT = new BgWriterThread(this);
-            allThreads.add(wT);
-            wT.start();
-            rT = new BgReaderThread(this);
-            allThreads.add(rT);
-            rT.start();
-        } catch (Exception e) {
-            e.printStackTrace();
-            quit();
-        }
-        return START_STICKY;
-    }
-
-    @Override
-    public void onDestroy() {
-        quit();
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    private void quit() {
-        this.serviceQuitting = true;
-        for (KillableThread t : allThreads) {
-            t.terminate();
-        }
-    }
-
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java
deleted file mode 100644
index 1060bb582e..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/BgWriterThread.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.content.Context;
-import android.util.Log;
-
-import io.realm.Realm;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class BgWriterThread extends Thread implements KillableThread {
-
-    public static final String TAG = BgWriterThread.class.getName();
-
-    private Realm   realm   = null;
-    private Context context = null;
-
-    public BgWriterThread(Context context) {
-        this.context = context;
-    }
-
-    public void run() {
-        realm = Realm.getInstance(context);
-        int iterCount = 0;
-
-        realm.beginTransaction();
-        while (iterCount < 1000000 && running == true) {
-            if ((iterCount % 1000) == 0) {
-                Log.d(TAG, "WR_OPERATION#: " + iterCount + "," + Thread.currentThread().getName());
-            }
-
-            Person person = realm.createObject(Person.class);
-            person.setName("New person");
-//            person.setDog(realm.createObject(Dog.class));
-            iterCount++;
-        }
-        realm.commitTransaction();
-    }
-
-    private boolean running = true;
-
-    @Override
-    public void terminate() {
-        running = false;
-    }
-}
diff --git a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java b/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
deleted file mode 100644
index d7b924935d..0000000000
--- a/test/concurrencyExample/src/main/java/io/realm/examples/concurrency/RealmExampleActivity.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.examples.service;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.RadioGroup;
-import android.widget.TextView;
-
-import io.realm.Realm;
-import io.realm.RealmList;
-import io.realm.examples.service.model.Cat;
-import io.realm.examples.service.model.Dog;
-import io.realm.examples.service.model.Person;
-
-public class RealmExampleActivity extends Activity implements View.OnClickListener {
-
-    public static final String TAG = RealmExampleActivity.class.getName();
-
-    private Realm realm = null;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_realm_example);
-
-        findViewById(R.id.add_record_button).setOnClickListener(this);
-
-        realm = Realm.getInstance(getFilesDir());
-        initDb();
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        start();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-
-        stop();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.options_menu, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int id = item.getItemId();
-        if (id == R.id.action_reload) {
-            restart();
-            return true;
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public void onClick(View v) {
-        String personName = ((TextView) findViewById(R.id.name)).getText().toString();
-        String personAge = ((TextView) findViewById(R.id.age)).getText().toString();
-        String petName = ((TextView) findViewById(R.id.pets_name)).getText().toString();
-
-        Integer parseAge = 0;
-        try {
-            parseAge = Integer.parseInt(personAge);
-        } catch (NumberFormatException e) {
-
-        }
-
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName(personName);
-        person.setAge(parseAge);
-
-//        int checkedId = ((RadioGroup) findViewById(R.id.petType)).getCheckedRadioButtonId();
-//        if (checkedId == R.id.hasCat) {
-//            Cat cat = realm.createObject(Cat.class);
-//            cat.setName(petName);
-//            RealmList<Cat> cats = person.getCats();
-//            cats.add(cat);
-//        } else if (checkedId == R.id.hasDog) {
-//            Dog dog = realm.createObject(Dog.class);
-//            dog.setName(petName);
-//            person.setDog(dog);
-//        }
-
-        realm.commitTransaction();
-
-    }
-
-    //This is just to create the tables in Realm so that subsequent R/W operations do not fail
-    private void initDb() {
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName("Human Being");
-        person.setAge(32);
-//        Dog dog = realm.createObject(Dog.class);
-//        dog.setName("Fido");
-        realm.commitTransaction();
-    }
-
-    private void start() {
-        Intent serviceIntent = new Intent(this, BgService.class);
-        serviceIntent.putExtra(BgService.REALM_FILE_EXTRA, getFilesDir());
-        Log.d(TAG, "Starting service...");
-        this.startService(serviceIntent);
-    }
-
-    private void stop() {
-        Intent serviceIntent = new Intent(this, BgService.class);
-        Log.d(TAG, "Stopping service...");
-        this.stopService(serviceIntent);
-    }
-
-    private void restart() {
-        stop();
-        start();
-    }
-}
diff --git a/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 96a442e5b8..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index 359047dfa4..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 71c6d760f0..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 4df1894644..0000000000
Binary files a/test/concurrencyExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml b/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml
deleted file mode 100644
index 8f998c487e..0000000000
--- a/test/concurrencyExample/src/main/res/layout/activity_realm_example.xml
+++ /dev/null
@@ -1,106 +0,0 @@
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="#ff797979"
-    android:orientation="vertical"
-    android:paddingBottom="@dimen/activity_vertical_margin"
-    android:paddingLeft="@dimen/activity_horizontal_margin"
-    android:paddingRight="@dimen/activity_horizontal_margin"
-    android:paddingTop="@dimen/activity_vertical_margin">
-
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-
-        <TextView
-            android:id="@+id/update_message"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_margin="25dp"
-            android:gravity="center"
-            android:text="In the background there is a loop creating records."
-            android:textSize="24sp" />
-
-        <View
-            android:layout_width="match_parent"
-            android:layout_height="1dp"
-            android:layout_margin="12dp"
-            android:background="#ffcfcfcf" />
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:background="#ff1144aa"
-            android:orientation="vertical"
-            android:padding="20dp">
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_margin="7dp"
-                android:gravity="center"
-                android:text="You can also create records manually..."
-                android:textSize="22sp" />
-
-            <TextView
-                android:id="@+id/message_timestamp"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:gravity="center_horizontal"
-                android:text="Create a Record:"
-                android:textColor="#ffafafaf"
-                android:textSize="22sp" />
-
-            <View
-                android:layout_width="match_parent"
-                android:layout_height="1dp"
-                android:layout_margin="12dp"
-                android:background="#ffcfcfcf" />
-
-            <EditText
-                android:id="@+id/name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Name" />
-
-            <EditText
-                android:id="@+id/age"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Person's Age" />
-
-            <RadioGroup
-                android:id="@+id/petType"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-                <RadioButton
-                    android:id="@+id/hasCat"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Cat" />
-
-                <RadioButton
-                    android:id="@+id/hasDog"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:text="Dog" />
-            </RadioGroup>
-
-            <EditText
-                android:id="@+id/pets_name"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Enter Pets Name" />
-
-            <Button
-                android:id="@+id/add_record_button"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:text="Create Record" />
-
-        </LinearLayout>
-    </LinearLayout>
-</ScrollView>
diff --git a/test/concurrencyExample/src/main/res/menu/options_menu.xml b/test/concurrencyExample/src/main/res/menu/options_menu.xml
deleted file mode 100644
index 14c91e5706..0000000000
--- a/test/concurrencyExample/src/main/res/menu/options_menu.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<menu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    tools:context=".RealmGridLayoutActivity">
-    <item
-        android:id="@+id/action_reload"
-        android:orderInCategory="100"
-        android:showAsAction="never"
-        android:title="@string/action_reset" />
-</menu>
diff --git a/test/concurrencyExample/src/main/res/values/strings.xml b/test/concurrencyExample/src/main/res/values/strings.xml
deleted file mode 100644
index 4bd17c1af8..0000000000
--- a/test/concurrencyExample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-
-    <string name="app_name">Realm Example</string>
-    <string name="action_reset">Restart</string>
-
-</resources>
diff --git a/tools/templates/RealmAdapterExample/build.gradle b/tools/templates/RealmAdapterExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmAdapterExample/build.gradle
rename to tools/templates/RealmAdapterExample/app/build.gradle
diff --git a/tools/templates/RealmEncryptionExample/build.gradle b/tools/templates/RealmEncryptionExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmEncryptionExample/build.gradle
rename to tools/templates/RealmEncryptionExample/app/build.gradle
diff --git a/tools/templates/RealmGridViewExample/build.gradle b/tools/templates/RealmGridViewExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmGridViewExample/build.gradle
rename to tools/templates/RealmGridViewExample/app/build.gradle
diff --git a/tools/templates/RealmIntroExample/build.gradle b/tools/templates/RealmIntroExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmIntroExample/build.gradle
rename to tools/templates/RealmIntroExample/app/build.gradle
diff --git a/tools/templates/RealmJsonExample/build.gradle b/tools/templates/RealmJsonExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmJsonExample/build.gradle
rename to tools/templates/RealmJsonExample/app/build.gradle
diff --git a/tools/templates/RealmMigrationExample/build.gradle b/tools/templates/RealmMigrationExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmMigrationExample/build.gradle
rename to tools/templates/RealmMigrationExample/app/build.gradle
diff --git a/tools/templates/RealmModuleExample/app/build.gradle b/tools/templates/RealmModuleExample/app/build.gradle
new file mode 100644
index 0000000000..a58ef8b37e
--- /dev/null
+++ b/tools/templates/RealmModuleExample/app/build.gradle
@@ -0,0 +1,42 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.application'
+apply plugin: 'android-command'
+
+android {
+    compileSdkVersion 20
+    buildToolsVersion "20.0.0"
+
+    defaultConfig {
+        applicationId 'io.realm.examples.appmodules'
+        minSdkVersion 14
+        targetSdkVersion 20
+        versionCode 1
+        versionName "1.0"
+    }
+
+    signingConfigs {
+        release {
+            storeFile file("keystore/release.keystore")
+            storePassword "realm1234"
+            keyAlias "realm-introexample"
+            keyPassword "realm1234"
+        }
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled true
+            signingConfig signingConfigs.release
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+
+    command {
+        events 2000
+    }
+}
+
+dependencies {
+    compile 'io.realm:realm-android:@version@'
+    compile project(':library')
+}
\ No newline at end of file
diff --git a/tools/templates/RealmModuleExample/library/build.gradle b/tools/templates/RealmModuleExample/library/build.gradle
new file mode 100644
index 0000000000..1668e776a4
--- /dev/null
+++ b/tools/templates/RealmModuleExample/library/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'android-sdk-manager'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "20.0.0"
+    defaultConfig {
+        minSdkVersion 15
+        targetSdkVersion 19
+        versionCode 1
+        versionName "1.0"
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+
+    productFlavors {
+    }
+}
+
+dependencies {
+    compile 'io.realm:realm-android:@version@'
+}
diff --git a/tools/templates/RealmThreadExample/build.gradle b/tools/templates/RealmThreadExample/app/build.gradle
similarity index 100%
rename from tools/templates/RealmThreadExample/build.gradle
rename to tools/templates/RealmThreadExample/app/build.gradle
diff --git a/version.txt b/version.txt
index 525aef9080..cd90f32ac6 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.80.1-SNAPSHOT
\ No newline at end of file
+0.81.2-SNAPSHOT
