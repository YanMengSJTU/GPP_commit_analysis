diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3924864ea4..1bce63b83f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,35 +1,29 @@
-## 5.11.0(YYYY-MM-DD)
+## 5.11.0(2019-05-01)
 
-### Enhancements 
+### Enhancements
+* [ObjectServer] Added `RealmQuery.includeLinkingObjects()`. This is only relevant for Query-based Realms and tells subscriptions to include objects linked through `@LinkingObjects` fields as part of the subscription as well. Objects referenced through objects and lists are always included as a default. (Issue [#6426](https://github.com/realm/realm-java/issues/6426))
+* Encryption now uses hardware optimized functions, which significantly improves the performance of encrypted Realms. ([Realm Core PR #3241](https://github.com/realm/realm-core/pull/3241))
+* Improved query performance when using `RealmQuery.in()` queries. ([Realm Core PR #3250](https://github.com/realm/realm-core/pull/3250)).
+* Improved query performance when querying Integer fields with indexes, e.g. primary key fields. ([Realm Core PR #3272](https://github.com/realm/realm-core/pull/3272)).
+* Improved write performance when writing changes to disk ([Realm Core PR #2927](https://github.com/realm/realm-sync/issues/2927))
 * Added support for incremental annotation processing added in Gradle 4.7. (Issue [#5906](https://github.com/realm/realm-java/issues/5906)).
 
 ### Fixed
-* None.
-
-### Compatibility
-* Realm Object Server: 3.11.0 or later.
-* File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
-* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
-
-### Internal
-* None.
-
-
-## 5.10.1(YYYY-MM-DD)
-
-###Enhancements 
-*  None.
-
-### Fixed
+* [ObjectServer] Fix an error in the calculation of the `downloadableBytes` value sent by `ProgressListeners`. 
+* [ObjectServer] HTTP requests made by the Sync client now always include a Host: header, as required by HTTP/1.1, although its value will be empty if no value is specified by the application.
+* [ObjectServer] The server no longer rejects subscriptions based on queries with distinct and/or limit clauses.
+* [ObjectServer] If a user had `canCreate` but not `canUpdate` privileges on a class, the user would be able to create the object, but not actually set any meaningful values on that object, despite the rule that objects created within the same transaction can always be modified.
 *  Native crash happening if bulk updating a field in a `RealmResult` would cause the object to no longer be part of the query result. (Issue [#6478](https://github.com/realm/realm-java/issues/6478), since 5.8.0).
 
 ### Compatibility
-* Realm Object Server: 3.11.0 or later.
-* File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
+* Realm Object Server: 3.21.0-rc1 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats)
 * APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
 
 ### Internal
-* Updated to Object Store commit: cc3db611b1c10d2b890a92fa0f4b8291bc0f3ba2
+* Updated to Realm Core 5.19.1.
+* Updated to Relm Sync 4.4.2.
+* Updated to Object Store commit e4b1314d21b521fd604af7f1aacf3ca94272c19a
 
 
 ## 5.10.0(2019-03-22)
diff --git a/dependencies.list b/dependencies.list
index cfc6079634..48b5b292ce 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,14 +1,14 @@
-# Realm Sync Core release used by Realm Java
+# Realm Sync release used by Realm Java (This includes Realm Core)
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=3.14.13
-REALM_SYNC_SHA256=7e8934a471fa714bf672a9575cd3112470c3294d55e7a13688d04569e707b8cd
+REALM_SYNC_VERSION=4.4.2
+REALM_SYNC_SHA256=7f3386bc9e590788afc6fd61744dd187148862513ddbd7e65c32d1d9c371e1ce
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_VERSION=3.18.5
+REALM_OBJECT_SERVER_VERSION=3.21.0-rc1
 
 # Common Android settings across projects
-GRADLE_BUILD_TOOLS=3.3.1
+GRADLE_BUILD_TOOLS=3.3.2
 ANDROID_BUILD_TOOLS=28.0.3
 
 # Common classpath dependencies
diff --git a/examples/build.gradle b/examples/build.gradle
index 5e91e876da..4b3907a7d9 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -65,10 +65,9 @@ allprojects {
                     process.waitFor()
 
                     if (process.exitValue() != 0
-                            || serr?.toString()?.trim()?.size() > 0
                             || !sout?.toString()?.trim()?.contains("Events injected: ${numberOfEvents}")) {
                         // fail Gradle build
-                        throw new GradleException("monkey failed for AppID: ${appId} \nStd out:  ${sout}\nStd err:  ${serr}")
+                        throw new GradleException("monkey failed for AppID: ${appId} \nExit code: ${process.exitValue()}\nStd out:  ${sout}\nStd err:  ${serr}")
                     }
                 }
             }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index e0bf51bfbc..511cc0f518 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -44,6 +44,8 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunTestInLooperThread;
 
 import static org.junit.Assert.assertEquals;
@@ -2993,6 +2995,15 @@ private void populateForDistinctInvalidTypesLinked(Realm realm) {
         realm.commitTransaction();
     }
 
+    @Test
+    public void includeLinkingObjects_throwsForNonQueryBasedRealms() {
+        try {
+            realm.where(AllJavaTypes.class).includeLinkingObjects(AllJavaTypes.FIELD_STRING);
+            fail();
+        } catch (IllegalStateException ignore) {
+        }
+    }
+
     @Test
     public void distinct() {
         final long numberOfBlocks = 3;
diff --git a/realm/realm-library/src/androidTest/res/xml/network_security_config.xml b/realm/realm-library/src/androidTest/res/xml/network_security_config.xml
index 40f1d9a749..9f14d34442 100644
--- a/realm/realm-library/src/androidTest/res/xml/network_security_config.xml
+++ b/realm/realm-library/src/androidTest/res/xml/network_security_config.xml
@@ -6,4 +6,8 @@
             <certificates src="system" />
         </trust-anchors>
     </base-config>
-</network-security-config>
\ No newline at end of file
+    <domain-config cleartextTrafficPermitted="true">
+        <domain includeSubdomains="false">localhost</domain>
+        <domain includeSubdomains="false">127.0.0.1</domain>
+    </domain-config>
+</network-security-config>
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 70311a5dc4..035b359150 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -80,7 +80,7 @@ set(classes_LIST
     io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
     io.realm.internal.OsObjectStore io.realm.internal.sync.OsSubscription
-    io.realm.internal.core.DescriptorOrdering
+    io.realm.internal.core.DescriptorOrdering io.realm.internal.core.IncludeDescriptor
     io.realm.internal.objectstore.OsObjectBuilder
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
index d1671d404c..67faf4e526 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmQuery.cpp
@@ -33,8 +33,14 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmQuery_nativeSerializeQuery(JNIEnv*
     try {
         auto query = reinterpret_cast<Query*>(table_query_ptr);
         auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
-        std::string serialized_query = query->get_description() + " " + descriptor->get_description(query->get_table());
-        return to_jstring(env, serialized_query);
+        std::string serialized_query = query->get_description();
+        std::string serialized_descriptor = descriptor->get_description(query->get_table());
+        if (serialized_descriptor.empty()) {
+            return to_jstring(env, serialized_query);
+        } else {
+            std::string result = serialized_query + " " + serialized_descriptor;
+            return to_jstring(env, result);
+        }
     }
     CATCH_STD()
     return to_jstring(env, "");
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp
index 062074fd93..5dcf6bc849 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp
@@ -56,7 +56,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppe
     try {
         auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
         if (j_sort_descriptor) {
-                descriptor->append_sort(JavaQueryDescriptor(env, j_sort_descriptor).sort_descriptor());
+            descriptor->append_sort(JavaQueryDescriptor(env, j_sort_descriptor).sort_descriptor());
         }
     }
     CATCH_STD()
@@ -88,6 +88,19 @@ JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppe
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppendInclude(JNIEnv* env, jclass,
+                                                                            jlong descriptor_ptr,
+                                                                            jlong include_descriptor_ptr)
+{
+    TR_ENTER()
+    try {
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        auto include_descriptor = reinterpret_cast<IncludeDescriptor*>(include_descriptor_ptr);
+        descriptor->append_include(*include_descriptor);
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeIsEmpty(JNIEnv* env, jclass,
                                                                              jlong descriptor_ptr)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_core_IncludeDescriptor.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_core_IncludeDescriptor.cpp
new file mode 100644
index 0000000000..19f23577e2
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_core_IncludeDescriptor.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_core_IncludeDescriptor.h"
+
+#include <realm/parser/parser.hpp>
+#include <realm/parser/query_builder.hpp>
+#include <realm/views.hpp>
+#include <object_schema.hpp>
+#include <object_store.hpp>
+#include <property.hpp>
+#include <schema.hpp>
+#include <shared_realm.hpp>
+
+#include "java_accessor.hpp"
+#include "java_query_descriptor.hpp"
+#include "util.hpp"
+
+
+using namespace realm;
+using namespace realm::util;
+using namespace realm::_impl;
+
+static void finalize_descriptor(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete reinterpret_cast<IncludeDescriptor*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_core_IncludeDescriptor_nativeGetFinalizerMethodPtr(JNIEnv* env, jclass)
+{
+    TR_ENTER()
+    try {
+        return reinterpret_cast<jlong>(&finalize_descriptor);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_core_IncludeDescriptor_nativeCreate(JNIEnv* env, jclass, jlong starting_table_ptr, jlongArray column_indexes, jlongArray table_pointers)
+{
+    TR_ENTER()
+    try {
+        JLongArrayAccessor table_arr(env, table_pointers);
+        JLongArrayAccessor index_arr(env, column_indexes);
+        auto starting_table = reinterpret_cast<Table*>(starting_table_ptr);
+        std::vector<LinkPathPart> parts;
+        parts.reserve(index_arr.size());
+        for (int i = 0; i < index_arr.size(); ++i) {
+            auto col_index = static_cast<size_t>(index_arr[i]);
+            auto table_ptr = reinterpret_cast<Table *>(table_arr[i]);
+            if (table_ptr == nullptr) {
+                parts.emplace_back(LinkPathPart(col_index));
+            }
+            else {
+                const ConstTableRef ref = table_ptr->get_table_ref();
+                parts.emplace_back(LinkPathPart(col_index, ref));
+            }
+        }
+
+        std::vector<std::vector<LinkPathPart>> include_path;
+        include_path.reserve(1);
+        include_path.emplace_back(parts);
+        return reinterpret_cast<jlong>(new IncludeDescriptor(*starting_table, include_path));
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
index d41e02f5c2..963e53e770 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_sync_OsSubscription.cpp
@@ -21,6 +21,7 @@
 #include "subscription_wrapper.hpp"
 #include "jni_util/java_class.hpp"
 #include "jni_util/java_method.hpp"
+#include "object-store/src/sync/partial_sync.hpp"
 
 #include <results.hpp>
 #include <sync/partial_sync.hpp>
@@ -46,7 +47,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_sync_OsSubscription_nativeCreateO
         const auto results = reinterpret_cast<ResultsWrapper*>(results_ptr);
         JStringAccessor subscription_name(env, j_subscription_name);
         auto key = subscription_name.is_null_or_empty() ? util::none : util::Optional<std::string>(subscription_name);
-        auto subscription = partial_sync::subscribe(results->collection(), key, util::Optional<int64_t>(time_to_live), update);
+        partial_sync::SubscriptionOptions options;
+        options.user_provided_name = key;
+        options.time_to_live_ms = util::Optional<int64_t>(time_to_live);
+        options.update = update;
+        auto subscription = partial_sync::subscribe(results->collection(), options);
         auto wrapper = new SubscriptionWrapper(std::move(subscription));
         return reinterpret_cast<jlong>(wrapper);
     }
diff --git a/realm/realm-library/src/main/cpp/java_query_descriptor.cpp b/realm/realm-library/src/main/cpp/java_query_descriptor.cpp
index 0c85d29728..d20fd9609f 100644
--- a/realm/realm-library/src/main/cpp/java_query_descriptor.cpp
+++ b/realm/realm-library/src/main/cpp/java_query_descriptor.cpp
@@ -95,4 +95,3 @@ JavaClass const& JavaQueryDescriptor::get_sort_desc_class() const noexcept
     static JavaClass sort_desc_class(m_env, "io/realm/internal/core/QueryDescriptor");
     return sort_desc_class;
 }
-
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 56ffd089e7..e4b1314d21 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 56ffd089e78dc6cd299b0234a71b2b9b9dca5957
+Subproject commit e4b1314d21b521fd604af7f1aacf3ca94272c19a
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index fd76c6de25..dc1188dc0d 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -63,6 +63,10 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
     }
+    catch(InvalidPathError& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, IllegalArgument, ss.str());
+    }
     catch (SharedGroup::BadVersion& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, BadVersion, ss.str());
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index b1adcbf10c..c18ff2dcc5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -33,8 +33,8 @@
 import io.realm.internal.OsList;
 import io.realm.internal.OsResults;
 import io.realm.internal.PendingRow;
-import io.realm.internal.UncheckedRow;
 import io.realm.internal.annotations.ObjectServer;
+import io.realm.internal.core.IncludeDescriptor;
 import io.realm.internal.core.QueryDescriptor;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -2054,6 +2054,42 @@ private OsResults lazyFindAll() {
         return this;
     }
 
+    /**
+     * This predicate is only relevant for Query-based Realms.
+     * <p>
+     * Objects referenced through fields marked with {@link io.realm.annotations.LinkingObjects} are normally not downloaded
+     * as part of the subscription in Query-based Realms, but by using this predicate, it is possible to specify which linking
+     * objects relationships should also be included in the subscription as well.
+     * <p>
+     * Note, that all "forward" object references like object references and lists are always downloaded as part of the
+     * subscription by default.
+     * <p>
+     * This predicate can be called multiple times, in which case all fields will be added to the subscription.
+     * 
+     * @param firstIncludePath the first {@link io.realm.annotations.LinkingObjects} field to add.
+     * @param remainingFieldPaths any remaining {@link io.realm.annotations.LinkingObjects} fields to add.
+     * @throws IllegalStateException if called on a non-query-based Realm.
+     * @throws IllegalArgumentException if the path does not end with a field marked with {@link io.realm.annotations.LinkingObjects}.
+     */
+    @ObjectServer
+    public RealmQuery<E> includeLinkingObjects(String firstIncludePath, @Nullable String... remainingFieldPaths) {
+        realm.checkIfValid();
+        if (!ObjectServerFacade.getSyncFacadeIfPossible().isPartialRealm(realm.getConfiguration())) {
+            throw new IllegalStateException("This method is only available for Query-based Realms.");
+        }
+        if (Util.isEmptyString(firstIncludePath)) {
+            throw new IllegalArgumentException("Non-empty 'firstIncludePath' required.");
+        }
+        queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, firstIncludePath));
+        if (remainingFieldPaths != null) {
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < remainingFieldPaths.length; i++) {
+                queryDescriptors.appendIncludes(IncludeDescriptor.createInstance(getSchemaConnector(), table, remainingFieldPaths[i]));
+            }
+        }
+        return this;
+    }
+
     /**
      * This predicate will always match.
      */
@@ -2255,7 +2291,7 @@ public String getDescription() {
      * @return the internal name of the Realm model class being queried.
      */
     public String getTypeQueried() {
-        // TODO Revisit this when primitve list queries are implemented.
+        // TODO Revisit this when primitive list queries are implemented.
         return table.getClassName();
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java b/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java
index 2777a63a08..604b4efdb6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java
@@ -17,8 +17,11 @@
 package io.realm.internal.core;
 
 import io.realm.internal.NativeObject;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.OsSharedRealm;
+import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
+import io.realm.internal.fields.FieldDescriptor;
 
 /**
  * Java class wrapping the native {@code realm::DescriptorOrdering} class. This class
@@ -96,6 +99,15 @@ public void setLimit(long limit) {
         limitDefined = true;
     }
 
+    /**
+     * Add a linkingObject reference that should be fetched from the server.
+     * This only makes sense for Query-based Realms. It is up to callers of this method
+     * to ensure this.
+     */
+    public void appendIncludes(IncludeDescriptor descriptor) {
+        nativeAppendInclude(nativePtr, descriptor.getNativePtr());
+    }
+
     /**
      * Returns true if no descriptors or limits have been added.
      */
@@ -106,9 +118,10 @@ public boolean isEmpty() {
 
     private static native long nativeGetFinalizerMethodPtr();
     private static native long nativeCreate();
-    private static native void nativeAppendSort(long descriptorPtr, QueryDescriptor sortDesc);
-    private static native void nativeAppendDistinct(long descriptorPtr, QueryDescriptor sortDesc);
+    private static native void nativeAppendSort(long descriptorPtr, QueryDescriptor includeDescriptor);
+    private static native void nativeAppendDistinct(long descriptorPtr, QueryDescriptor includeDescriptor);
     private static native void nativeAppendLimit(long descriptorPtr, long limit);
+    private static native void nativeAppendInclude(long descriptorPtr, long includeDescriptorPtr);
     private static native boolean nativeIsEmpty(long descriptorPtr);
 
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/core/IncludeDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/core/IncludeDescriptor.java
new file mode 100644
index 0000000000..8c97f20e33
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/core/IncludeDescriptor.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2019 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.core;
+
+import java.util.EnumSet;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.NativeObject;
+import io.realm.internal.Table;
+import io.realm.internal.fields.FieldDescriptor;
+
+/**
+ * Creates the Java wrapper for a `realm::IncludeDescriptor`.
+ */
+public class IncludeDescriptor implements NativeObject {
+
+    private static final long nativeFinalizerMethodPtr = nativeGetFinalizerMethodPtr();
+    private final long nativePtr;
+
+    public static IncludeDescriptor createInstance(FieldDescriptor.SchemaProxy schemaConnector, Table table, String includePath) {
+            EnumSet<RealmFieldType> supportedIntermediateColumnTypes = EnumSet.of(RealmFieldType.OBJECT, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
+            EnumSet<RealmFieldType> supportedFinalColumnType = EnumSet.of(RealmFieldType.LINKING_OBJECTS);
+            FieldDescriptor fieldDescriptor = FieldDescriptor.createFieldDescriptor(
+                    schemaConnector,
+                    table,
+                    includePath,
+                    supportedIntermediateColumnTypes,
+                    supportedFinalColumnType);
+            return new IncludeDescriptor(table, fieldDescriptor.getColumnIndices(), fieldDescriptor.getNativeTablePointers());
+    }
+
+    private IncludeDescriptor(Table table, long[] columnIndices, long[] nativeTablePointers) {
+        nativePtr = nativeCreate(table.getNativePtr(), columnIndices, nativeTablePointers);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerMethodPtr;
+    }
+
+    private static native long nativeGetFinalizerMethodPtr();
+    private static native long nativeCreate(long tablePtr, long[] columnIndices, long[] tablePtrIndices);
+}
+
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
index a9f1b9cbe4..81cb17d36d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
@@ -244,7 +244,7 @@ protected final void verifyInternalColumnType(String tableName, String columnNam
 
     /**
      * Store the results of compiling the field description.
-     * Subclasses call this as the last action in
+     * Subclasses call this as the last action after `compileFieldDescription` is called.
      *
      * @param finalClassName the name of the final table in the field description.
      * @param finalColumnName the name of the final column in the field description.
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
index a6e4203a55..6f2e8c0d20 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
@@ -3,16 +3,18 @@
 import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
+import java.util.HashSet;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import io.realm.DynamicRealm;
 import io.realm.OrderedCollectionChangeSet;
-import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmList;
@@ -22,10 +24,13 @@
 import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncTestUtils;
 import io.realm.SyncUser;
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
 import io.realm.entities.Dog;
 import io.realm.log.RealmLog;
 import io.realm.objectserver.model.PartialSyncModule;
@@ -592,6 +597,146 @@ public void deletingSubscriptionObjectUnsubscribes() throws InterruptedException
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void includeLinkingObjects_throwsOnInvalidTypes() {
+        SyncUser user1 = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        Realm realm = getPartialRealm(user1);
+        realm.executeTransaction(r -> {
+            RealmQuery<AllJavaTypes> query = r.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_STRING, "child");
+
+            Set<String> invalidFields = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
+                    AllJavaTypes.FIELD_IGNORED, AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT,
+                    AllJavaTypes.FIELD_LONG, AllJavaTypes.FIELD_ID, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT, AllJavaTypes.FIELD_DOUBLE,
+                    AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE, AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT,
+                    AllJavaTypes.FIELD_LIST, AllJavaTypes.FIELD_STRING_LIST, AllJavaTypes.FIELD_BINARY_LIST, AllJavaTypes.FIELD_BOOLEAN_LIST,
+                    AllJavaTypes.FIELD_LONG_LIST, AllJavaTypes.FIELD_INTEGER_LIST, AllJavaTypes.FIELD_SHORT_LIST, AllJavaTypes.FIELD_BYTE_LIST,
+                    AllJavaTypes.FIELD_DOUBLE_LIST, AllJavaTypes.FIELD_FLOAT_LIST, AllJavaTypes.FIELD_DATE_LIST)));
+
+            for (String field : invalidFields) {
+                try {
+                    query.includeLinkingObjects(field);
+                    fail(field + " failed.");
+                } catch (IllegalArgumentException ignore) {
+                }
+            }
+        });
+        realm.close();
+        looperThread.postRunnable(() -> {
+            looperThread.testComplete();
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void includeLinkingObjects_differentTable() throws InterruptedException {
+        // Upload data
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        Realm realm1 = getPartialRealm(admin);
+        realm1.executeTransaction(realm -> {
+            BacklinksTarget child1 = new BacklinksTarget();
+            child1.setId(1);
+            BacklinksTarget child2 = new BacklinksTarget();
+            child2.setId(2);
+
+            BacklinksSource parent1 = new BacklinksSource();
+            parent1.setName("parent-1");
+            parent1.setChild(child1);
+            BacklinksSource parent2 = new BacklinksSource();
+            parent2.setName("parent-2");
+
+            realm.insert(parent1);
+            realm.insert(parent2);
+            realm.insert(child2);
+        });
+        SyncManager.getSession((SyncConfiguration) realm1.getConfiguration()).uploadAllLocalChanges();
+        realm1.close();
+
+        // Create subscription with includes
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        Realm realm2 = getPartialRealm(admin);
+        SyncSession session = SyncManager.getSession((SyncConfiguration) realm2.getConfiguration());
+        assertEquals(0, realm2.where(AllJavaTypes.class).count());
+        realm2.executeTransaction(realm -> {
+            Subscription sub = realm.where(BacklinksTarget.class)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1)
+                    .subscribe("my-sub");
+            assertEquals("id == 1", sub.getQueryDescription());
+        });
+        session.uploadAllLocalChanges();
+        session.downloadAllServerChanges();
+        realm2.refresh();
+        assertEquals(1, realm2.where(BacklinksTarget.class).count());
+        assertEquals(0, realm2.where(BacklinksSource.class).count());
+
+        // Update subscription to include parent objects
+        realm2.executeTransaction(realm -> {
+            Subscription sub = realm.where(BacklinksTarget.class)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1)
+                    .includeLinkingObjects(BacklinksTarget.FIELD_PARENTS)
+                    .subscribeOrUpdate("my-sub");
+            assertEquals("id == 1 INCLUDE(@links.class_BacklinksSource.child)", sub.getQueryDescription());
+        });
+        session.uploadAllLocalChanges();
+        session.downloadAllServerChanges();
+        realm2.refresh();
+        assertEquals(1, realm2.where(BacklinksTarget.class).count());
+        assertEquals(1, realm2.where(BacklinksSource.class).count());
+        realm2.close();
+        looperThread.postRunnable(() -> {
+            looperThread.testComplete();
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void includeLinkingObjects_sameTable() throws InterruptedException {
+        // Upload data
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        Realm realm1 = getPartialRealm(admin);
+        realm1.executeTransaction(realm -> {
+            AllJavaTypes obj1 = new AllJavaTypes(1);
+            obj1.setFieldString("parent");
+            AllJavaTypes obj2 = new AllJavaTypes(2);
+            obj2.setFieldString("child");
+            obj1.setFieldObject(obj2);
+            realm.insert(obj1);
+        });
+        SyncManager.getSession((SyncConfiguration) realm1.getConfiguration()).uploadAllLocalChanges();
+        realm1.close();
+
+        // Create subscription with includes
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        Realm realm2 = getPartialRealm(admin);
+        SyncSession session = SyncManager.getSession((SyncConfiguration) realm2.getConfiguration());
+        assertEquals(0, realm2.where(AllJavaTypes.class).count());
+        realm2.executeTransaction(realm -> {
+            realm.where(AllJavaTypes.class)
+                    .equalTo(AllJavaTypes.FIELD_STRING, "child")
+                    .subscribe("my-sub");
+        });
+        session.uploadAllLocalChanges();
+        session.downloadAllServerChanges();
+        realm2.refresh();
+        assertEquals(1, realm2.where(AllJavaTypes.class).count());
+
+        // Update subscription to include parent objects
+        realm2.executeTransaction(realm -> {
+            realm.where(AllJavaTypes.class)
+                    .equalTo(AllJavaTypes.FIELD_STRING, "child")
+                    .includeLinkingObjects(AllJavaTypes.FIELD_LO_OBJECT)
+                    .subscribeOrUpdate("my-sub");
+        });
+        session.uploadAllLocalChanges();
+        session.downloadAllServerChanges();
+        realm2.refresh();
+        assertEquals(2, realm2.where(AllJavaTypes.class).count());
+        realm2.close();
+        looperThread.postRunnable(() -> {
+            looperThread.testComplete();
+        });
+    }
 
     private Realm getPartialRealm(SyncUser user) {
         final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
index 6552293cf7..103a256d21 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
@@ -17,7 +17,10 @@
 package io.realm.objectserver.model;
 
 import io.realm.annotations.RealmModule;
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
 
-@RealmModule(classes = {PartialSyncObjectA.class, PartialSyncObjectB.class})
+@RealmModule(classes = {PartialSyncObjectA.class, PartialSyncObjectB.class, AllJavaTypes.class, BacklinksSource.class, BacklinksTarget.class})
 public class PartialSyncModule {
 }
diff --git a/tools/sync_test_server/ros/package.json b/tools/sync_test_server/ros/package.json
index 777423ed70..a661d3f5de 100644
--- a/tools/sync_test_server/ros/package.json
+++ b/tools/sync_test_server/ros/package.json
@@ -9,7 +9,7 @@
         "start": "npm run build && NODE_TLS_REJECT_UNAUTHORIZED=0 node dist/index.js"
     },
     "devDependencies": {
-        "typescript": "2.5.3"
+        "typescript": "3.4.3"
     },
     "dependencies": {
         "realm-object-server": "%ROS_VERSION%"
diff --git a/version.txt b/version.txt
index 48092a8f91..647e7292a9 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.11.0-SNAPSHOT
\ No newline at end of file
+5.12.0-SNAPSHOT
\ No newline at end of file
