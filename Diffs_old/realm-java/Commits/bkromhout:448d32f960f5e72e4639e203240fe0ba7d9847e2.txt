diff --git a/CHANGELOG.md b/CHANGELOG.md
index e91f1840d4..0467c037cb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,14 +1,147 @@
+## 1.2.0
+
+### Enhancements
+
+* Added `RealmQuery.in()` for a comparison against multiple values.
+
+## 1.1.1
+
+### Enhancements
+
+* The Realm Annotation processor no longer consumes the Realm annotations. Allowing other annotation processors to run.
+
+### Bug fixes
+
+* Fixed a wrong JNI method declaration which might cause "method not found" crash on some devices.
+* Fixed a bug that `Error` in the background async thread is not forwarded to the caller thread.
+* Fixed a crash when an empty `Collection` is passed to `insert()`/`insertOrUpdate()` (#3103).
+* Fixed a bug that does not transfer the primary key when `RealmSchemaObject.setClassName()` is called to rename a class (#3118).
+* Fixed a concurrency allocation bug in storage engine which might lead to some random crashes.
+* Bulk insertion now throws if it is not called in a transaction (#3173).
+* The IllegalStateException thrown when accessing an empty RealmObject is now more meaningful (#3200).
+* `insert()` now correctly throws an exception if two different objects have the same primary key (#3212).
+* Blackberry Z10 throwing "Function not implemented" (#3178).
+* Reduced the number of file descriptors used by Realm Core (#3197).
+* Throw a proper `IllegalStateException` if a `RealmChangeListener` is used inside an IntentService (#2875).
+
+### Internal
+
+* Updated Realm Core to 1.4.2.
+
+## 1.1.0
+
+### Bug fixes
+
+* A number of bug fixes in the storage engine related to memory management in rare cases when a Realm has been compacted.
+* Disabled the optional API transformer since it has problems with DexGuard (#3022).
+* `OnSuccess.OnSuccess()` might not be called with the correct Realm version for async transaction (#1893).
+* Fixed a bug in `copyToRealm()` causing a cyclic dependency objects being duplicated.
+* Fixed a build failure when model class has a conflicting name such as `Map`, `List`, `String`, ... (#3077).
+
+### Enhancements
+
+* Added `insert(RealmModel obj)`, `insertOrUpdate(RealmModel obj)`, `insert(Collection<RealmModel> collection)` and `insertOrUpdate(Collection<RealmModel> collection)` to perform batch inserts (#1684).
+* Enhanced `Table.toString()` to show a PrimaryKey field details (#2903).
+* Enabled ReLinker when loading a Realm from a custom path by adding a `RealmConfiguration.Builder(Context, File)` constructor (#2900).
+* Changed `targetSdkVersion` of `realm-library` to 24.
+* Logs warning if `DynamicRealm` is not closed when GC happens as it does for `Realm`.
+
+### Deprecated
+
+* `RealmConfiguration.Builder(File)`. Use `RealmConfiguration.Builder(Context, File)` instead.
+
+### Internal
+
+* Updated Realm Core to 1.2.0.
+
+## 1.0.1
+
+### Bug fixes
+
+* Fixed a crash when calling `Table.toString()` in debugger (#2429).
+* Fixed a race condition which would cause some `RealmResults` to not be properly updated inside a `RealmChangeListener`. This could result in crashes when accessing items from those results (#2926/#2951).
+* Revised `RealmResults.isLoaded()` description (#2895).
+* Fixed a bug that could cause Realm to lose track of primary key when using `RealmObjectSchema.removeField()` and `RealmObjectSchema.renameField()` (#2829/#2926).
+* Fixed a bug that prevented some devices from finding async related JNI methods correctly.
+* Updated ProGuard configuration in order not to depend on Android's default configuration (#2972).
+* Fixed a race condition between Realms notifications and other UI events. This could e.g. cause ListView to crash (#2990).
+* Fixed a bug that allowed both `RealmConfiguration.Builder.assetFile()`/`deleteRealmIfMigrationNeeded()` to be configured at the same time, which leads to the asset file accidentally being deleted in migrations (#2933).
+* Realm crashed outright when the same Realm file was opened in two processes. Realm will now optimistically retry opening for 1 second before throwing an Error (#2459).
+
+### Enhancements
+
+* Removes RxJava related APIs during bytecode transforming to make RealmObject plays well with reflection when rx.Observable doesn't exist.
+
+## 1.0.0
+
+No changes since 0.91.1.
+
+## 0.91.1
+
+* Updated Realm Core to 1.0.1.
+
+### Bug fixes
+
+* Fixed a bug when opening a Realm causes a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported".
+
+## 0.91.0
+
+* Updated Realm Core to 1.0.0.
+
+### Breaking changes
+
+* Removed all `@Deprecated` methods.
+* Calling `Realm.setAutoRefresh()` or `DynamicRealm.setAutoRefresh()` from non-Looper thread throws `IllegalStateException` even if the `autoRefresh` is false (#2820).
+
+### Bug fixes
+
+* Calling RealmResults.deleteAllFromRealm() might lead to native crash (#2759).
+* The annotation processor now correctly reports an error if trying to reference interfaces in model classes (#2808).
+* Added null check to `addChangeListener` and `removeChangeListener` in `Realm` and `DynamicRealm` (#2772).
+* Calling `RealmObjectSchema.addPrimaryKey()` adds an index to the primary key field, and calling `RealmObjectSchema.removePrimaryKey()` removes the index from the field (#2832).
+* Log files are not deleted when calling `Realm.deleteRealm()` (#2834).
+
+### Enhancements
+
+* Upgrading to OpenSSL 1.0.1t. From July 11, 2016, Google Play only accept apps using OpenSSL 1.0.1r or later (https://support.google.com/faqs/answer/6376725, #2749).
+* Added support for automatically copying an initial database from assets using `RealmConfiguration.Builder.assetFile()`.
+* Better error messages when certain file operations fail.
+
+### Credits
+
+* Paweł Surówka (@thesurix) for adding the `RealmConfiguration.Builder.assetFile()`.
+
+## 0.90.1
+
+* Updated Realm Core to 0.100.2.
+
+### Bug fixes
+
+* Opening a Realm while closing a Realm in another thread could lead to a race condition.
+* Automatic migration to the new file format could in rare circumstances lead to a crash.
+* Fixing a race condition that may occur when using Async API (#2724).
+* Fixed CannotCompileException when related class definition in android.jar cannot be found (#2703).
+
+### Enhancements
+
+* Prints path when file related exceptions are thrown.
+
 ## 0.90.0
 
+* Updated Realm Core to 0.100.0.
+
 ### Breaking changes
 
+* RealmChangeListener provides the changed object/Realm/collection as well (#1594).
 * All JSON methods on Realm now only wraps JSONException in RealmException. All other Exceptions are thrown as they are.
 * Marked all methods on `RealmObject` and all public classes final (#1594).
 * Removed `BaseRealm` from the public API.
 * Removed `HandlerController` from the public API.
-* Removed constructor of `RealmAsyncTask` from the public API8 (#1594).
+* Removed constructor of `RealmAsyncTask` from the public API (#1594).
 * `RealmBaseAdapter` has been moved to its own GitHub repository: https://github.com/realm/realm-android-adapters
   See https://github.com/realm/realm-android-adapters/README.md for further info on how to include it.
+* File format of Realm files is changed. Files will be automatically upgraded but opening a Realm file with older
+  versions of Realm is not possible.
 
 ### Deprecated
 
@@ -20,12 +153,20 @@
 * `RealmQuery.findAllSorted(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSorted(field[], sort[])`` instead.
 * `RealmQuery.findAllSortedAsync(field, sort, field, sort, field, sort)`. Use `RealmQuery.findAllSortedAsync(field[], sort[])`` instead.
 * `RealmConfiguration.setModules()`. Use `RealmConfiguration.modules()` instead.
+* `Realm.refresh()` and `DynamicRealm.refresh()`. Use `Realm.waitForChange()`/`stopWaitForChange()` or `DynamicRealm.waitForChange()`/`stopWaitForChange()` instead.
 
 ### Enhancements
 
-* `RealmObjectSchema.getPrimaryKey()`. (#2636)
+* `RealmObjectSchema.getPrimaryKey()` (#2636).
 * `Realm.createObject(Class, Object)` for creating objects with a primary key directly.
 * Unit tests in Android library projects now detect Realm model classes.
+* Better error message if `equals()` and `hashCode()` are not properly overridden in custom Migration classes.
+* Expanding the precision of `Date` fields to cover full range (#833).
+* `Realm.waitForChange()`/`stopWaitForChange()` and `DynamicRealm.waitForChange()`/`stopWaitForChange()` (#2386).
+
+### Bug fixes
+
+* `RealmChangeListener` on `RealmObject` is not triggered when adding listener on returned `RealmObject` of `copyToRealmOrUpdate()` (#2569).
 
 ### Credits
 
@@ -49,6 +190,7 @@
 * `RealmResults.sort()` and `RealmList.sort()` now return the sorted result instead of sorting in-place.
 * `RealmList.first()` and `RealmList.last()` now throw `ArrayIndexOutOfBoundsException` if `RealmList` is empty.
 * Removed deprecated method `Realm.getTable()` from public API.
+* `Realm.refresh()` and `DynamicRealm.refresh()` on a Looper no longer have any effect. `RealmObject` and `RealmResults` are always updated on the next event loop.
 
 ### Deprecated
 
@@ -241,7 +383,7 @@
 * BREAKING CHANGE: Realm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
 * BREAKING CHANGE: RealmQuery.isNull() and RealmQuery.isNotNull() now throw IllegalArgumentException instead of RealmError if the fieldname is a linked field and the last element is a link (#1693).
 * Added Realm.isEmpty().
-* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (standalone, removed, closed, from different Realm) object (#1749).
+* Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (unmanaged, removed, closed, from different Realm) object (#1749).
 * Attempting to refresh a Realm while a transaction is in process will now throw an IllegalStateException (#1712).
 * The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle)
 * Updated Realm Core to 0.95.
@@ -336,7 +478,7 @@
 * Deprecated Realm.migrateRealmAtPath(). It has been replaced by Realm.migrateRealm(RealmConfiguration).
 * Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
 * Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
-* RealmList.add(), RealmList.addAt() and RealmList.set() now copy standalone objects transparently into Realm.
+* RealmList.add(), RealmList.addAt() and RealmList.set() now copy unmanaged objects transparently into Realm.
 * Realm now works with Kotlin (M12+). (Thank you @cypressious)
 * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
 * Added a check to give a better error message when null is used as value for a primary key.
@@ -424,7 +566,7 @@
 * Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
 * Added more logging capabilities at the JNI level.
 * Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
-* Added support for standalone objects and custom constructors.
+* Added support for unmanaged objects and custom constructors.
 * Added more precise imports in proxy classes to avoid ambiguous references.
 * Added support for executing a transaction with a closure using Realm.executeTransaction().
 * Added RealmObject.isValid() to test if an object is still accessible.
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index ae1a793a9e..117abc2ef9 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -56,7 +56,7 @@ When writing unit tests, use the following guide lines:
 5) Use the `@RunInLooperThread` rule for any test that depends on Realms notification system. 
 
 6) Input-parameters should be boundary tested. Especially `Null/NotNull`, but also the state of Realm objects like
-   standalone objects, deleted objects, objects from other threads.
+   unmanaged objects, deleted objects, objects from other threads.
 
 7) Unit tests are not required to only have 1 test. It is acceptable to combine multiple tests into one unit test, but
    if it fails, it should be clear why it failed. E.g. you can group related tests with the same setup like negative 
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000000..0029aaebbf
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,46 @@
+FROM ubuntu:16.04
+
+# Locales
+RUN locale-gen en_US.UTF-8
+ENV LANG "en_US.UTF-8"
+ENV LANGUAGE "en_US.UTF-8"
+ENV LC_ALL "en_US.UTF-8"
+
+# Set the environment variables
+ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64
+ENV ANDROID_HOME /opt/android-sdk-linux
+ENV NDK_HOME /opt/android-ndk
+ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+ENV PATH ${PATH}:${NDK_HOME}
+
+# Install the JDK
+# We are going to need some 32 bit binaries because aapt requires it
+# file is need by the script that creates NDK toolchains
+RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 \
+    && apt-get update -qq \
+    && apt-get install -y file git curl wget zip unzip \
+                       bsdmainutils \
+                       build-essential \
+                       openjdk-8-jdk-headless \
+                       libc6:i386 libstdc++6:i386 libgcc1:i386 libncurses5:i386 libz1:i386 \
+    && apt-get clean
+
+# Install the Android SDK
+RUN cd /opt && wget -q https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz -O android-sdk.tgz
+RUN cd /opt && tar -xvzf android-sdk.tgz
+RUN cd /opt && rm -f android-sdk.tgz
+
+# Grab what's needed in the SDK
+# ↓ updates tools to at least 25.1.7, but that prints 'Nothing was installed' (so I don't check the outputs).
+RUN echo y | android update sdk --no-ui --all --filter tools > /dev/null
+RUN echo y | android update sdk --no-ui --all --filter platform-tools | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter build-tools-24.0.0 | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repository | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter android-24 | grep 'package installed'
+
+# Install the NDK
+RUN mkdir /opt/android-ndk-tmp
+RUN cd /opt/android-ndk-tmp && wget -q http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin -O android-ndk.bin
+RUN cd /opt/android-ndk-tmp && chmod a+x ./android-ndk.bin && ./android-ndk.bin
+RUN cd /opt/android-ndk-tmp && mv ./android-ndk-r10e /opt/android-ndk
+RUN rm -rf /opt/android-ndk-tmp
diff --git a/Jenkinsfile b/Jenkinsfile
new file mode 100644
index 0000000000..be329c01d2
--- /dev/null
+++ b/Jenkinsfile
@@ -0,0 +1,161 @@
+#!groovy
+
+import groovy.json.JsonOutput
+
+def buildSuccess = false
+try {
+  node('android') {
+    // Allocate a custom workspace to avoid having % in the path (it breaks ld)
+    ws('/tmp/realm-java') {
+      stage 'SCM'
+      checkout scm
+      // Make sure not to delete the folder that Jenkins allocates to store scripts
+      sh 'git clean -ffdx -e .????????'
+
+      stage 'Docker build'
+      def buildEnv = docker.build 'realm-java:snapshot'
+      buildEnv.inside("--privileged -v /dev/bus/usb:/dev/bus/usb -v ${env.HOME}/gradle-cache:/root/.gradle -v /root/adbkeys:/root/.android") {
+        stage 'JVM tests'
+        try {
+          gradle 'assemble check javadoc'
+        } finally {
+          storeJunitResults 'realm/realm-annotations-processor/build/test-results/TEST-*.xml'
+          storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+          step([$class: 'LintPublisher'])
+        }
+
+        stage 'Static code analysis'
+        try {
+          gradle('realm', 'findbugs pmd checkstyle')
+        } finally {
+          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+          step([$class: 'CheckStylePublisher',
+          canComputeNew: false,
+          defaultEncoding: '',
+          healthy: '',
+          pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+          unHealthy: ''
+          ])
+        }
+
+        stage 'Run instrumented tests'
+        boolean archiveLog = true
+        String backgroundPid
+        try {
+          backgroundPid = startLogCatCollector()
+          gradle('realm', 'connectedUnitTests')
+          archiveLog = false;
+        } finally {
+          stopLogCatCollector(backgroundPid, archiveLog)
+          storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/TEST-*.xml'
+        }
+
+        // TODO: add support for running monkey on the example apps
+
+        if (env.BRANCH_NAME == 'master') {
+          stage 'Collect metrics'
+          collectAarMetrics()
+
+          stage 'Publish to OJO'
+          withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+            sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+          }
+        }
+      }
+    }
+  }
+  currentBuild.rawBuild.setResult(Result.SUCCESS)
+  buildSuccess = true
+} catch(Exception e) {
+  currentBuild.rawBuild.setResult(Result.FAILURE)
+  buildSuccess = false
+  throw e
+} finally {
+  if (['master', 'releases'].contains(env.BRANCH_NAME)) {
+    node {
+      withCredentials([[$class: 'StringBinding', credentialsId: 'slack-java-url', variable: 'SLACK_URL']]) {
+        def payload = JsonOutput.toJson([
+          username: 'Mr. Jenkins',
+          icon_emoji: ':jenkins:',
+          attachments: [[
+            'title': "The ${env.BRANCH_NAME} branch is ${buildSuccess?'healthy.':'broken!'}",
+            'text': "<${env.BUILD_URL}|Click here> to check the build.",
+            'color': "${buildSuccess?'good':'danger'}"
+          ]]
+        ])
+        sh "curl -X POST --data-urlencode \'payload=${payload}\' ${env.SLACK_URL}"
+      }
+    }
+  }
+}
+
+
+def String startLogCatCollector() {
+  sh '''adb logcat -c
+  adb logcat -v time > "logcat.txt" &
+  echo $! > pid
+  '''
+  return readFile("pid").trim()
+}
+
+def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
+  sh "kill ${backgroundPid}"
+  if (archiveLog) {
+    zip([
+      'zipFile': 'logcat.zip',
+      'archive': true,
+      'glob' : 'logcat.txt'
+    ])
+  }
+  sh 'rm logcat.txt '
+}
+
+def sendMetrics(String metric, String value) {
+  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+  }
+}
+
+def sendTaggedMetric(String metric, String value, String tagName, String tagValue) {
+  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric},${tagName}=${tagValue} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+  }
+}
+
+def storeJunitResults(String path) {
+  step([
+    $class: 'JUnitResultArchiver',
+    testResults: path
+  ])
+}
+
+def collectAarMetrics() {
+  sh '''set -xe
+  cd realm/realm-library/build/outputs/aar
+  unzip realm-android-library-release.aar -d unzipped
+  find $ANDROID_HOME -name dx | sort -r | head -n 1 > dx
+  $(cat dx) --dex --output=temp.dex unzipped/classes.jar
+  cat temp.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 "%d"' > methods
+  '''
+
+  sendMetrics('methods', readFile('realm/realm-library/build/outputs/aar/methods'))
+
+  def aarFile = findFiles(glob: 'realm/realm-library/build/outputs/aar/realm-android-library-release.aar')[0]
+  sendMetrics('aar_size', aarFile.length as String)
+
+  def soFiles = findFiles(glob: 'realm/realm-library/build/outputs/aar/unzipped/jni/*/librealm-jni.so')
+  for (int i = 0; i < soFiles.length; i++) {
+      def abiName = soFiles[i].path.tokenize('/')[-2]
+      def libSize = soFiles[i].length as String
+      sendTaggedMetric('abi_size', libSize, 'type', abiName)
+  }
+}
+
+def gradle(String commands) {
+  sh "chmod +x gradlew && ./gradlew ${commands} --stacktrace"
+}
+
+def gradle(String relativePath, String commands) {
+  sh "cd ${relativePath} && chmod +x gradlew && ./gradlew ${commands} --stacktrace"
+}
diff --git a/README.md b/README.md
index 1638d47c8e..6a24fa16f7 100644
--- a/README.md
+++ b/README.md
@@ -59,7 +59,7 @@ Prerequisites:
 
  * Make sure `make` is available in your `$PATH`
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK, **Android 4.4.2 (API 19)**, **Android 4.4W (API 20)** and **Android 5.0 (API 21)** (for example through Android Studio’s **Android SDK Manager**)
+ * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studio’s **Android SDK Manager**)
  * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
  * Or you can use [Hombrew-versions](https://github.com/Homebrew/homebrew-versions) to install Android NDK for Mac:
 
@@ -114,7 +114,7 @@ That command will generate:
  * `./gradlew monkeyExamples` will run the monkey tests on all the examples
  * `./gradlew installRealmJava` will install the Realm library and plugin to mavenLocal()
  * `./gradlew clean -PdontCleanJniFiles` will remove all generated files except for JNI related files. This saves recompilation time a lot.
- * `./gradlew connectedCheck -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
+ * `./gradlew connectedUnitTests -PbuildTargetABIs=$(adb shell getprop ro.product.cpu.abi)` will build JNI files only for the ABI which corresponds to the connected device.
 
 Generating the Javadoc using the command above will report a large number of warnings. The Javadoc is generated, and we will fix the issue in the near future.
 
@@ -133,10 +133,20 @@ This means that `./gradlew clean` and `./gradlew cleanExamples` will fail if `as
 Note that IntelliJ [does not support multiple projects in the same window](https://youtrack.jetbrains.com/issue/IDEABKL-6118#)
 so each sub-project must be opened in its own window.
 
+## Examples
+
+The `./examples` folder contain a number of example projects showing how Realm can be used. If this is the first time you checkout or pull a new version of this repository to try the examples, you must call `./gradlew installRealmJava` from the top-level directory first. Otherwise the examples will not compile as they depend on all Realm artifacts being installed in `mavenLocal()`.
+
+Standalone examples can be [downloaded from website](https://realm.io/docs/java/latest/#getting-started).
+
 ## Contributing
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
 
+This project adheres to the [Contributor Covenant Code of Conduct](https://realm.io/conduct).
+By participating, you are expected to uphold this code. Please report
+unacceptable behavior to [info@realm.io](mailto:info@realm.io).
+
 ## License
 
 Realm Java is published under the Apache 2.0 license.
diff --git a/build.gradle b/build.gradle
index 8f2e675aba..fe532a9f65 100644
--- a/build.gradle
+++ b/build.gradle
@@ -59,7 +59,17 @@ task assembleRealm(type:GradleBuild) {
     }
 }
 
-task check(type:GradleBuild) {
+task checkExamples(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the JVM tests and checks the examples'
+    buildFile = file('examples/build.gradle')
+    tasks = ['check']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
+task checkRealm(type:GradleBuild) {
     group = 'Test'
     description = 'Run the JVM tests and checks Realm project'
     buildFile = file('realm/build.gradle')
@@ -69,12 +79,28 @@ task check(type:GradleBuild) {
     }
 }
 
-task connectedCheck(type:GradleBuild) {
+task check {
+    group = 'Test'
+    description = 'Run the JVM tests and checks in the realm and examples projects'
+    dependsOn checkRealm
+    dependsOn checkExamples
+}
+
+task integrationTestsConnectedCheck(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the integration tests of the Realm project'
+    dependsOn installTransformer
+    buildFile = file('integration-tests/build.gradle')
+    tasks = ['connectedCheck']
+}
+
+task connectedUnitTests(type:GradleBuild) {
     group = 'Test'
     description = 'Run the Android unit tests of the Realm project'
     dependsOn installTransformer
+    dependsOn integrationTestsConnectedCheck
     buildFile = file('realm/build.gradle')
-    tasks = ['connectedCheck']
+    tasks = ['connectedUnitTests']
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -172,10 +198,6 @@ task distributionPackage(type:Zip) {
     from('changelog.txt')
     from('LICENSE')
     from('version.txt')
-    from("${buildDir}/outputs/gradle") {
-        include "realm-android-${currentVersion}.jar"
-        into 'gradle'
-    }
     from('realm/realm-library/build/libs') {
         include 'realm-android-${currentVersion}-javadoc.jar'
         into 'docs'
@@ -192,6 +214,19 @@ task distributionPackage(type:Zip) {
     }
 }
 
+task distributionJniUnstrippedPackage(type:Zip) {
+    description = 'Generate native libs package with debug symbols'
+    dependsOn assembleRealm
+
+    group = 'Artifact'
+    archiveName = "realm-java-jni-libs-unstripped-${currentVersion}.zip"
+    destinationDir = file("${buildDir}/outputs/distribution")
+
+    from("realm/realm-jni/build/outputs/jniLibs-unstripped") {
+        include '**/*.so'
+    }
+}
+
 task cleanRealm(type:GradleBuild) {
     description = 'Clean the Realm project'
     group = 'Clean'
@@ -238,7 +273,9 @@ task uploadDistributionPackage(type: Exec) {
     group = 'Release'
     description = 'Upload the distribution package to S3'
     dependsOn distributionPackage
+    dependsOn distributionJniUnstrippedPackage
     commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
+    commandLine 's3cmd', 'put', "${buildDir}/outputs/distribution/realm-java-jni-libs-unstripped-${currentVersion}.zip", 's3://static.realm.io/downloads/java/'
 }
 
 task createEmptyFile(type: Exec) {
@@ -277,6 +314,7 @@ task bintrayRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['bintrayUpload']
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -286,6 +324,7 @@ task bintrayAnnotations(type: GradleBuild) {
     description = 'Publish the Realm Annotations to Bintray'
     group = 'Publishing'
     buildFile = file('realm-annotations/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -293,6 +332,7 @@ task bintrayGradlePlugin(type: GradleBuild) {
     description = 'Publish the Realm Gradle Plugin to Bintray'
     group = 'Publishing'
     buildFile = file('gradle-plugin/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -300,6 +340,7 @@ task bintrayTransformer(type: GradleBuild) {
     description = 'Publish the Realm Transformer to Bintray'
     group = 'Publishing'
     buildFile = file('realm-transformer/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -317,6 +358,7 @@ task ojoRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['artifactoryPublish']
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -326,6 +368,7 @@ task ojoAnnotations(type: GradleBuild) {
     description = 'Publish the Realm Annotations SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm-annotations/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
@@ -333,6 +376,7 @@ task ojoGradlePlugin(type: GradleBuild) {
     description = 'Publish the Realm Gradle Plugin SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('gradle-plugin/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
@@ -340,6 +384,7 @@ task ojoTransformer(type: GradleBuild) {
     description = 'Publish the Realm Transformer SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm-transformer/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
diff --git a/examples/build.gradle b/examples/build.gradle
index c1c2682d7a..47be4e4ca1 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,5 @@
-project.ext.sdkVersion = 23
-project.ext.buildTools = '23.0.0'
+project.ext.sdkVersion = 24
+project.ext.buildTools = '24.0.0'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -13,11 +13,12 @@ allprojects {
         repositories {
             mavenLocal()
             jcenter()
+            maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:1.5.0'
+            classpath 'com.android.tools.build:gradle:2.1.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
             classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 60181889d3..c58427e952 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/encryptionExample/lint.xml b/examples/encryptionExample/lint.xml
index 3e72f2f79a..0666c5455c 100644
--- a/examples/encryptionExample/lint.xml
+++ b/examples/encryptionExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="TrulyRandom" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/encryptionExample/src/main/AndroidManifest.xml b/examples/encryptionExample/src/main/AndroidManifest.xml
index 28d1c607d0..b3bb0e1028 100644
--- a/examples/encryptionExample/src/main/AndroidManifest.xml
+++ b/examples/encryptionExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
index 7b70163cfe..edf66fdaef 100644
--- a/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
+++ b/examples/encryptionExample/src/main/java/io/realm/examples/encryptionexample/EncryptionExampleActivity.java
@@ -53,13 +53,16 @@ protected void onCreate(Bundle savedInstanceState) {
         realm = Realm.getInstance(realmConfiguration);
 
         // Everything continues to work as normal except for that the file is encrypted on disk
-        realm.beginTransaction();
-        Person person = realm.createObject(Person.class);
-        person.setName("Happy Person");
-        person.setAge(14);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Person person = realm.createObject(Person.class);
+                person.setName("Happy Person");
+                person.setAge(14);
+            }
+        });
 
-        person = realm.where(Person.class).findFirst();
+        Person person = realm.where(Person.class).findFirst();
         Log.i(TAG, String.format("Person name: %s", person.getName()));
     }
 
diff --git a/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 049cf16cbf..474e8611e1 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/gridViewExample/lint.xml b/examples/gridViewExample/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/gridViewExample/lint.xml
+++ b/examples/gridViewExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/gridViewExample/src/main/AndroidManifest.xml b/examples/gridViewExample/src/main/AndroidManifest.xml
index d7f791e888..1bf1d8752c 100644
--- a/examples/gridViewExample/src/main/AndroidManifest.xml
+++ b/examples/gridViewExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
index c308278d72..759b451b8c 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/GridViewExampleActivity.java
@@ -129,12 +129,15 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         City modifiedCity = (City)mAdapter.getItem(position);
 
         // Acquire the RealmObject matching the name of the clicked City.
-        City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
+        final City city = realm.where(City.class).equalTo("name", modifiedCity.getName()).findFirst();
 
         // Create a transaction to increment the vote count for the selected City in the realm
-        realm.beginTransaction();
-        city.setVotes(city.getVotes() + 1);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                city.setVotes(city.getVotes() + 1);
+            }
+        });
 
         updateCities();
     }
diff --git a/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index b253559d33..d61e93b5a3 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'com.neenbedankt.android-apt'
diff --git a/examples/introExample/lint.xml b/examples/introExample/lint.xml
index 3b74cb97d0..3af2534ba6 100644
--- a/examples/introExample/lint.xml
+++ b/examples/introExample/lint.xml
@@ -5,5 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
-    
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/introExample/src/main/AndroidManifest.xml b/examples/introExample/src/main/AndroidManifest.xml
index 9263488282..f23c433da2 100644
--- a/examples/introExample/src/main/AndroidManifest.xml
+++ b/examples/introExample/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
     package="io.realm.examples.intro" >
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
index 13f6b1be4c..668f954d24 100644
--- a/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
+++ b/examples/introExample/src/main/java/io/realm/examples/intro/IntroExampleActivity.java
@@ -92,37 +92,44 @@ private void basicCRUD(Realm realm) {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction();
-
-        // Add a person
-        Person person = realm.createObject(Person.class);
-        person.setId(1);
-        person.setName("Young Person");
-        person.setAge(14);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // Add a person
+                Person person = realm.createObject(Person.class);
+                person.setId(1);
+                person.setName("Young Person");
+                person.setAge(14);
 
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction();
+            }
+        });
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person.class).findFirst();
+        final Person person = realm.where(Person.class).findFirst();
         showStatus(person.getName() + ":" + person.getAge());
 
         // Update person in a transaction
-        realm.beginTransaction();
-        person.setName("Senior Person");
-        person.setAge(99);
-        showStatus(person.getName() + " got older: " + person.getAge());
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person.setName("Senior Person");
+                person.setAge(99);
+                showStatus(person.getName() + " got older: " + person.getAge());
+            }
+        });
 
         // Delete all persons
-        realm.beginTransaction();
-        realm.allObjects(Person.class).deleteAllFromRealm();
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
     }
 
     private void basicQuery(Realm realm) {
         showStatus("\nPerforming basic Query operation...");
-        showStatus("Number of persons: " + realm.allObjects(Person.class).size());
+        showStatus("Number of persons: " + realm.where(Person.class).count());
 
         RealmResults<Person> results = realm.where(Person.class).equalTo("age", 99).findAll();
 
@@ -131,7 +138,7 @@ private void basicQuery(Realm realm) {
 
     private void basicLinkQuery(Realm realm) {
         showStatus("\nPerforming basic Link Query operation...");
-        showStatus("Number of persons: " + realm.allObjects(Person.class).size());
+        showStatus("Number of persons: " + realm.where(Person.class).count());
 
         RealmResults<Person> results = realm.where(Person.class).equalTo("cats.name", "Tiger").findAll();
 
@@ -146,35 +153,38 @@ private String complexReadWrite() {
         Realm realm = Realm.getInstance(realmConfig);
 
         // Add ten persons in one transaction
-        realm.beginTransaction();
-        Dog fido = realm.createObject(Dog.class);
-        fido.name = "fido";
-        for (int i = 0; i < 10; i++) {
-            Person person = realm.createObject(Person.class);
-            person.setId(i);
-            person.setName("Person no. " + i);
-            person.setAge(i);
-            person.setDog(fido);
-
-            // The field tempReference is annotated with @Ignore.
-            // This means setTempReference sets the Person tempReference
-            // field directly. The tempReference is NOT saved as part of
-            // the RealmObject:
-            person.setTempReference(42);
-
-            for (int j = 0; j < i; j++) {
-                Cat cat = realm.createObject(Cat.class);
-                cat.name = "Cat_" + j;
-                person.getCats().add(cat);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Dog fido = realm.createObject(Dog.class);
+                fido.name = "fido";
+                for (int i = 0; i < 10; i++) {
+                    Person person = realm.createObject(Person.class);
+                    person.setId(i);
+                    person.setName("Person no. " + i);
+                    person.setAge(i);
+                    person.setDog(fido);
+
+                    // The field tempReference is annotated with @Ignore.
+                    // This means setTempReference sets the Person tempReference
+                    // field directly. The tempReference is NOT saved as part of
+                    // the RealmObject:
+                    person.setTempReference(42);
+
+                    for (int j = 0; j < i; j++) {
+                        Cat cat = realm.createObject(Cat.class);
+                        cat.name = "Cat_" + j;
+                        person.getCats().add(cat);
+                    }
+                }
             }
-        }
-        realm.commitTransaction();
+        });
 
         // Implicit read transactions allow you to access your objects
-        status += "\nNumber of persons: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Iterate over all objects
-        for (Person pers : realm.allObjects(Person.class)) {
+        for (Person pers : realm.where(Person.class).findAll()) {
             String dogName;
             if (pers.getDog() == null) {
                 dogName = "None";
@@ -185,9 +195,8 @@ private String complexReadWrite() {
         }
 
         // Sorting
-        RealmResults<Person> sortedPersons = realm.allObjects(Person.class);
-        sortedPersons.sort("age", Sort.DESCENDING);
-        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.allObjects(Person.class).first()
+        RealmResults<Person> sortedPersons = realm.where(Person.class).findAllSorted("age", Sort.DESCENDING);
+        status += "\nSorting " + sortedPersons.last().getName() + " == " + realm.where(Person.class).findFirst()
                 .getName();
 
         realm.close();
@@ -198,7 +207,7 @@ private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
         Realm realm = Realm.getInstance(realmConfig);
-        status += "\nNumber of persons: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of persons: " + realm.where(Person.class).count();
 
         // Find all persons where age between 7 and 9 and name begins with "Person".
         RealmResults<Person> results = realm.where(Person.class)
diff --git a/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index 4dcc5d1350..1b9bd2a6a7 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'android-command'
diff --git a/examples/jsonExample/lint.xml b/examples/jsonExample/lint.xml
index 9a4f122c70..6a7edc9890 100644
--- a/examples/jsonExample/lint.xml
+++ b/examples/jsonExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/jsonExample/src/main/AndroidManifest.xml b/examples/jsonExample/src/main/AndroidManifest.xml
index 22004a8ef0..7c50dd72f8 100644
--- a/examples/jsonExample/src/main/AndroidManifest.xml
+++ b/examples/jsonExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
index e2fbb7bfbd..233a563017 100644
--- a/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
+++ b/examples/jsonExample/src/main/java/io/realm/examples/json/JsonExampleActivity.java
@@ -88,7 +88,7 @@ protected void onDestroy() {
         loadJsonFromJsonObject();
         loadJsonFromString();
 
-        return realm.allObjects(City.class);
+        return realm.where(City.class).findAll();
     }
 
     private void loadJsonFromStream() throws IOException {
@@ -115,18 +115,24 @@ private void loadJsonFromJsonObject() {
         Map<String, String> city = new HashMap<String, String>();
         city.put("name", "København");
         city.put("votes", "9");
-        JSONObject json = new JSONObject(city);
+        final JSONObject json = new JSONObject(city);
 
-        realm.beginTransaction();
-        realm.createObjectFromJson(City.class, json);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObjectFromJson(City.class, json);
+            }
+        });
     }
 
     private void loadJsonFromString() {
-        String json = "{ name: \"Aarhus\", votes: 99 }";
+        final String json = "{ name: \"Aarhus\", votes: 99 }";
 
-        realm.beginTransaction();
-        realm.createObjectFromJson(City.class, json);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObjectFromJson(City.class, json);
+            }
+        });
     }
 }
diff --git a/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 3e35bbf2e9..a7baf526da 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,14 +1,14 @@
 buildscript {
-    ext.kotlin_version = '1.0.1-2'
+    ext.kotlin_version = '1.0.3'
     repositories {
         jcenter()
+        mavenCentral()
     }
     dependencies {
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'kotlin-android'
 apply plugin: 'android-command'
diff --git a/examples/kotlinExample/lint.xml b/examples/kotlinExample/lint.xml
index 829e13eda8..cc4d461aee 100644
--- a/examples/kotlinExample/lint.xml
+++ b/examples/kotlinExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/kotlinExample/src/main/AndroidManifest.xml b/examples/kotlinExample/src/main/AndroidManifest.xml
index 877e97864f..3373613527 100644
--- a/examples/kotlinExample/src/main/AndroidManifest.xml
+++ b/examples/kotlinExample/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 37c16e37c0..5c6c37f1ec 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -66,7 +66,7 @@ class KotlinExampleActivity : Activity() {
         // Using executeTransaction with a lambda reduces code size and makes it impossible
         // to forget to commit the transaction.
         realm.executeTransaction {
-            realm.allObjects(Person::class.java).deleteAllFromRealm()
+            realm.delete(Person::class.java)
         }
 
         // More complex operations can be executed on another thread, for example using
@@ -98,32 +98,29 @@ class KotlinExampleActivity : Activity() {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...")
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction()
-
-        // Add a person
-        var person = realm.createObject(Person::class.java)
-        person.id = 1
-        person.name = "Young Person"
-        person.age = 14
-
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction()
+        realm.executeTransaction {
+            // Add a person
+            var person = realm.createObject(Person::class.java)
+            person.id = 1
+            person.name = "Young Person"
+            person.age = 14
+        }
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person::class.java).findFirst()
+        var person = realm.where(Person::class.java).findFirst()
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
-        realm.beginTransaction()
-        person.name = "Senior Person"
-        person.age = 99
-        showStatus(person.name + " got older: " + person.age)
-        realm.commitTransaction()
+        realm.executeTransaction {
+            person.name = "Senior Person"
+            person.age = 99
+            showStatus(person.name + " got older: " + person.age)
+        }
     }
 
     private fun basicQuery(realm: Realm) {
         showStatus("\nPerforming basic Query operation...")
-        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
 
         val results = realm.where(Person::class.java).equalTo("age", 99).findAll()
 
@@ -132,7 +129,7 @@ class KotlinExampleActivity : Activity() {
 
     private fun basicLinkQuery(realm: Realm) {
         showStatus("\nPerforming basic Link Query operation...")
-        showStatus("Number of persons: ${realm.allObjects(Person::class.java).size}")
+        showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
 
         val results = realm.where(Person::class.java).equalTo("cats.name", "Tiger").findAll()
 
@@ -147,35 +144,35 @@ class KotlinExampleActivity : Activity() {
         val realm = Realm.getInstance(realmConfig)
 
         // Add ten persons in one transaction
-        realm.beginTransaction()
-        val fido = realm.createObject(Dog::class.java)
-        fido.name = "fido"
-        for (i in 0..9) {
-            val person = realm.createObject(Person::class.java)
-            person.id = i.toLong()
-            person.name = "Person no. $i"
-            person.age = i
-            person.dog = fido
-
-            // The field tempReference is annotated with @Ignore.
-            // This means setTempReference sets the Person tempReference
-            // field directly. The tempReference is NOT saved as part of
-            // the RealmObject:
-            person.tempReference = 42
-
-            for (j in 0..i - 1) {
-                val cat = realm.createObject(Cat::class.java)
-                cat.name = "Cat_$j"
-                person.cats.add(cat)
+        realm.executeTransaction {
+            val fido = realm.createObject(Dog::class.java)
+            fido.name = "fido"
+            for (i in 0..9) {
+                val person = realm.createObject(Person::class.java)
+                person.id = i.toLong()
+                person.name = "Person no. $i"
+                person.age = i
+                person.dog = fido
+
+                // The field tempReference is annotated with @Ignore.
+                // This means setTempReference sets the Person tempReference
+                // field directly. The tempReference is NOT saved as part of
+                // the RealmObject:
+                person.tempReference = 42
+
+                for (j in 0..i - 1) {
+                    val cat = realm.createObject(Cat::class.java)
+                    cat.name = "Cat_$j"
+                    person.cats.add(cat)
+                }
             }
         }
-        realm.commitTransaction()
 
         // Implicit read transactions allow you to access your objects
-        status += "\nNumber of persons: ${realm.allObjects(Person::class.java).size}"
+        status += "\nNumber of persons: ${realm.where(Person::class.java).count()}"
 
         // Iterate over all objects
-        for (person in realm.allObjects(Person::class.java)) {
+        for (person in realm.where(Person::class.java).findAll()) {
             val dogName: String = person?.dog?.name ?: "None"
 
             status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
@@ -187,10 +184,9 @@ class KotlinExampleActivity : Activity() {
         }
 
         // Sorting
-        val sortedPersons = realm.allObjects(Person::class.java)
-        sortedPersons.sort("age", Sort.DESCENDING)
-        check(realm.allObjects(Person::class.java).last().name == sortedPersons.first().name)
-        status += "\nSorting ${sortedPersons.last().name} == ${realm.allObjects(Person::class.java).first().name}"
+        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING);
+        check(realm.where(Person::class.java).findAll().last().name == sortedPersons.first().name)
+        status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
         realm.close()
         return status
@@ -203,7 +199,7 @@ class KotlinExampleActivity : Activity() {
         // extension method 'use' (pun intended).
         Realm.getInstance(realmConfig).use {
             // 'it' is the implicit lambda parameter of type Realm
-            status += "\nNumber of persons: ${it.allObjects(Person::class.java).size}"
+            status += "\nNumber of persons: ${it.where(Person::class.java).count()}"
 
             // Find all persons where age between 7 and 9 and name begins with "Person".
             val results = it
diff --git a/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index b15849923f..800fa0ee4f 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/migrationExample/lint.xml b/examples/migrationExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/migrationExample/lint.xml
+++ b/examples/migrationExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/migrationExample/src/main/AndroidManifest.xml b/examples/migrationExample/src/main/AndroidManifest.xml
index e92dc433ae..b21664e66a 100644
--- a/examples/migrationExample/src/main/AndroidManifest.xml
+++ b/examples/migrationExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
index 32d9eb77f9..c96ccdabc4 100644
--- a/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
+++ b/examples/migrationExample/src/main/java/io/realm/examples/realmmigrationexample/MigrationExampleActivity.java
@@ -121,7 +121,7 @@ private String copyBundledRealmFile(InputStream inputStream, String outFileName)
 
     private String realmString(Realm realm) {
         StringBuilder stringBuilder = new StringBuilder();
-        for (Person person : realm.allObjects(Person.class)) {
+        for (Person person : realm.where(Person.class).findAll()) {
             stringBuilder.append(person.toString()).append("\n");
         }
 
diff --git a/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index 33a5ed5655..957f094945 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/moduleExample/app/lint.xml b/examples/moduleExample/app/lint.xml
new file mode 100644
index 0000000000..1d3dbb0011
--- /dev/null
+++ b/examples/moduleExample/app/lint.xml
@@ -0,0 +1,7 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
+</lint>
diff --git a/examples/moduleExample/app/src/main/AndroidManifest.xml b/examples/moduleExample/app/src/main/AndroidManifest.xml
index 97549cad37..c5aaf2017b 100644
--- a/examples/moduleExample/app/src/main/AndroidManifest.xml
+++ b/examples/moduleExample/app/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
     package="io.realm.examples.appmodules" >
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 1d36960fda..246bafadfc 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -60,7 +60,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // configuration would know about the following classes: { Cow, Pig, Snake, Spider }
         RealmConfiguration defaultConfig = new RealmConfiguration.Builder(this).build();
 
-        // It is possible to extend the default schema by adding additional Realm modules using setModule(). This can
+        // It is possible to extend the default schema by adding additional Realm modules using modules(). This can
         // also be Realm modules from libraries. The below Realm contains the following classes: { Cow, Pig, Snake,
         // Spider, Cat, Dog }
         RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
@@ -78,7 +78,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // Multiple Realms can be open at the same time
         showStatus("Opening multiple Realms");
         Realm defaultRealm = Realm.getInstance(defaultConfig);
-        Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
+        final Realm farmRealm = Realm.getInstance(farmAnimalsConfig);
         Realm exoticRealm = Realm.getInstance(exoticAnimalsConfig);
 
         // Objects can be added to each Realm independantly
@@ -120,10 +120,14 @@ public void execute(Realm realm) {
         showStatus("Copy objects between Realms");
         showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
         showStatus("Copy pig from defaultRealm to farmRealm");
-        Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
-        farmRealm.beginTransaction();
-        farmRealm.copyToRealm(defaultPig);
-        farmRealm.commitTransaction();
+        final Pig defaultPig = defaultRealm.where(Pig.class).findFirst();
+        farmRealm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.copyToRealm(defaultPig);
+            }
+        });
+
         showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
 
         // Each Realm is restricted to only accept the classes in their schema.
diff --git a/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
index f7891e6991..38d19031c7 100644
--- a/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
+++ b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
@@ -13,7 +13,7 @@
         android:layout_height="wrap_content">
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/status_output"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/values/strings.xml b/examples/moduleExample/app/src/main/res/values/strings.xml
index d6848f4045..3a9a495414 100644
--- a/examples/moduleExample/app/src/main/res/values/strings.xml
+++ b/examples/moduleExample/app/src/main/res/values/strings.xml
@@ -2,5 +2,6 @@
 <resources>
 
     <string name="app_name">RealmModule example</string>
+    <string name="status_output">Status Output…</string>
 
 </resources>
diff --git a/examples/moduleExample/library/build.gradle b/examples/moduleExample/library/build.gradle
index c4e79639f9..3697638a79 100644
--- a/examples/moduleExample/library/build.gradle
+++ b/examples/moduleExample/library/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.library'
 apply plugin: 'realm-android'
 
diff --git a/examples/moduleExample/library/lint.xml b/examples/moduleExample/library/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/moduleExample/library/lint.xml
+++ b/examples/moduleExample/library/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
index 9e19a30e2a..f33c90cbbd 100644
--- a/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
+++ b/examples/moduleExample/library/src/main/java/io/realm/examples/librarymodules/Zoo.java
@@ -52,13 +52,16 @@ public long getNoOfAnimals() {
         return realm.where(Cat.class).count();
     }
 
-    public void addAnimals(int count) {
-        realm.beginTransaction();
-        for (int i = 0; i < count; i++) {
-            Cat cat = realm.createObject(Cat.class);
-            cat.setName("Cat " + i);
-        }
-        realm.commitTransaction();
+    public void addAnimals(final int count) {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < count; i++) {
+                    Cat cat = realm.createObject(Cat.class);
+                    cat.setName("Cat " + i);
+                }
+            }
+        });
     }
 
     public void close() {
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index f90596c1ed..3809773b25 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
@@ -35,9 +34,9 @@ android {
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile 'com.android.support:appcompat-v7:24.0.0'
     //noinspection GradleDependency
-    compile 'com.android.support:design:23.1.1'
+    compile 'com.android.support:design:24.0.0'
     compile 'io.reactivex:rxjava:1.1.0'
     compile 'io.reactivex:rxandroid:1.1.0'
     compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
diff --git a/examples/newsreaderExample/lint.xml b/examples/newsreaderExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/newsreaderExample/lint.xml
+++ b/examples/newsreaderExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
old mode 100644
new mode 100755
index 433021180b..eb9ece04b2
Binary files a/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/release/AndroidManifest.xml b/examples/newsreaderExample/src/release/AndroidManifest.xml
index d044658dcf..815e4d18c1 100644
--- a/examples/newsreaderExample/src/release/AndroidManifest.xml
+++ b/examples/newsreaderExample/src/release/AndroidManifest.xml
@@ -2,5 +2,5 @@
 <manifest package="io.realm.examples.newsreader"
           xmlns:android="http://schemas.android.com/apk/res/android">
 
-    <application android:name=".DebugNewsReaderApplication"/>
+    <application android:name=".ReleaseNewsReaderApplication"/>
 </manifest>
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index e91c2e7875..9a916ede8a 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/rxJavaExample/lint.xml b/examples/rxJavaExample/lint.xml
index 829e13eda8..cc4d461aee 100644
--- a/examples/rxJavaExample/lint.xml
+++ b/examples/rxJavaExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/rxJavaExample/src/main/AndroidManifest.xml b/examples/rxJavaExample/src/main/AndroidManifest.xml
index 8283fb31e6..b214dcd863 100644
--- a/examples/rxJavaExample/src/main/AndroidManifest.xml
+++ b/examples/rxJavaExample/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.INTERNET" />
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:name=".MyApplication"
         android:theme="@style/AppTheme" >
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
index 59e25bace0..fcfd43d85e 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -77,7 +77,7 @@ protected void onResume() {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                realm.allObjectsSorted(Person.class, "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
+                realm.where(Person.class).findAllSorted( "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
             }
         });
 
@@ -144,7 +144,7 @@ public Person call(Realm realm) {
 
         // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
         // that all objects in the cache will contain the same data.
-        // Either avoid using buffer or copy data into an un-managed object.
+        // Either avoid using buffer or copy data into an unmanaged object.
         return personObserver
                 .buffer(2)
                 .subscribe(new Action1<List<Person>>() {
diff --git a/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index cc74e3a549..98ec9f1827 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
@@ -26,5 +25,5 @@ android {
 
 dependencies {
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:23.2.1'
+    compile 'com.android.support:appcompat-v7:24.0.0'
 }
diff --git a/examples/threadExample/lint.xml b/examples/threadExample/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/threadExample/lint.xml
+++ b/examples/threadExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/threadExample/src/main/AndroidManifest.xml b/examples/threadExample/src/main/AndroidManifest.xml
index 3f54c69592..a59f33e36c 100644
--- a/examples/threadExample/src/main/AndroidManifest.xml
+++ b/examples/threadExample/src/main/AndroidManifest.xml
@@ -7,7 +7,7 @@
     <application
         android:name=".MyApplication"
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
index 48a821225b..6d730bce93 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncQueryFragment.java
@@ -40,7 +40,7 @@
 /**
  * This fragment demonstrates how you can perform asynchronous queries with Realm.
  */
-public class AsyncQueryFragment extends Fragment implements View.OnClickListener, RealmChangeListener {
+public class AsyncQueryFragment extends Fragment implements View.OnClickListener, RealmChangeListener<RealmResults<Dot>> {
     private Realm realm;
     private DotAdapter dotAdapter;
     private RealmResults<Dot> allSortedDots;
@@ -135,7 +135,7 @@ private void cancelAsyncTransaction() {
     }
 
     @Override
-    public void onChange() {
+    public void onChange(RealmResults<Dot> result) {
         dotAdapter.notifyDataSetChanged();
     }
 
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
index 73a177e8a3..c3b567d105 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/AsyncTaskFragment.java
@@ -86,17 +86,20 @@ private void showStatus(String txt) {
         protected Integer doInBackground(Void... params) {
             Realm realm = Realm.getDefaultInstance();
 
-            realm.beginTransaction();
-            realm.clear(Score.class);
-            for (int i = 0; i < TEST_OBJECTS; i++) {
-                if (isCancelled()) break;
-                Score score = realm.createObject(Score.class);
-                score.setName("Name" + i);
-                score.setScore(i);
-            }
-            realm.commitTransaction();
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.delete(Score.class);
+                    for (int i = 0; i < TEST_OBJECTS; i++) {
+                        if (isCancelled()) break;
+                        Score score = realm.createObject(Score.class);
+                        score.setName("Name" + i);
+                        score.setScore(i);
+                    }
+                }
+            });
 
-            Number sum = realm.allObjects(Score.class).sum("score");
+            Number sum = realm.where(Score.class).sum("score");
             realm.close();
             return sum.intValue();
         }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
index 8ce4838613..c64cf21644 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -97,21 +97,28 @@ public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
 
         realm = Realm.getDefaultInstance();
-        realm.beginTransaction();
-        person = realm.createObject(Person.class);
-        person.setName("Jane");
-        person.setAge(42);
-        person.setId(UUID.randomUUID().toString());
-        realm.commitTransaction();
-
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person = realm.createObject(Person.class);
+                person.setName("Jane");
+                person.setAge(42);
+                person.setId(UUID.randomUUID().toString());
+            }
+        });
         textContent.setText(person.toString());
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
         // Clear out all Person instances.
-        realm.clear(Person.class);
         realm.close();
     }
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index 7d0c1ba477..43b9da847a 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -44,9 +44,9 @@
     private DotsView dotsView;
 
     // Realm change listener that refreshes the UI when there is changes to Realm.
-    private RealmChangeListener realmListener = new RealmChangeListener() {
+    private RealmChangeListener<Realm> realmListener = new RealmChangeListener<Realm>() {
         @Override
-        public void onChange() {
+        public void onChange(Realm realm) {
             dotsView.invalidate();
         }
     };
@@ -76,18 +76,24 @@ public boolean onOptionsItemSelected(MenuItem item) {
         switch(item.getItemId()) {
             case R.id.action_add_dot:
                 // Add blue dot from the UI thread
-                realm.beginTransaction();
-                Dot dot = realm.createObject(Dot.class);
-                dot.setX(random.nextInt(100));
-                dot.setY(random.nextInt(100));
-                dot.setColor(getResources().getColor(R.color.realm_blue));
-                realm.commitTransaction();
+                realm.executeTransaction(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        Dot dot = realm.createObject(Dot.class);
+                        dot.setX(random.nextInt(100));
+                        dot.setY(random.nextInt(100));
+                        dot.setColor(getResources().getColor(R.color.realm_blue));
+                    }
+                });
                 return true;
 
             case R.id.action_clear:
-                realm.beginTransaction();
-                realm.clear(Dot.class);
-                realm.commitTransaction();
+                realm.executeTransaction(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        realm.delete(Dot.class);
+                    }
+                });
                 return true;
 
             default:
@@ -108,7 +114,7 @@ public void onStart() {
         // Note that the query gets updated by rerunning it on the thread it was
         // created. This can negatively effect frame rates if it is a complicated query or a very
         // large data set.
-        dotsView.setRealmResults(realm.allObjects(Dot.class));
+        dotsView.setRealmResults(realm.where(Dot.class).findAll());
     }
 
     @Override
@@ -125,17 +131,19 @@ public void onResume() {
             public void run() {
                 // Realm instances cannot be shared between threads, so we need to create a new
                 // instance on the background thread.
-                int redColor = getResources().getColor(R.color.realm_red);
-                Realm backgroundThreadRealm = Realm.getDefaultInstance();
+                final int redColor = getResources().getColor(R.color.realm_red);
+                final Realm backgroundThreadRealm = Realm.getDefaultInstance();
                 while (!backgroundThread.isInterrupted()) {
-                    backgroundThreadRealm.beginTransaction();
-
-                    // Add red dot from the background thread
-                    Dot dot = backgroundThreadRealm.createObject(Dot.class);
-                    dot.setX(random.nextInt(100));
-                    dot.setY(random.nextInt(100));
-                    dot.setColor(redColor);
-                    backgroundThreadRealm.commitTransaction();
+                    backgroundThreadRealm.executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            // Add red dot from the background thread
+                            Dot dot = backgroundThreadRealm.createObject(Dot.class);
+                            dot.setX(random.nextInt(100));
+                            dot.setY(random.nextInt(100));
+                            dot.setColor(redColor);
+                        }
+                    });
 
                     // Wait 0.5 sec. before adding the next dot.
                     SystemClock.sleep(500);
diff --git a/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index b2a09b1677..f4a1b95430 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'com.neenbedankt.android-apt'
@@ -46,9 +45,9 @@ dependencies {
     testCompile "org.powermock:powermock-classloading-xstream:1.6.4"
 
 
-    androidTestCompile 'com.android.support.test:runner:0.4.1'
+    androidTestCompile 'com.android.support.test:runner:0.5'
     // Set this dependency to use JUnit 4 rules
-    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    androidTestCompile 'com.android.support.test:rules:0.5'
     // Set this dependency to build and run Espresso tests
-    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1'
+    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
 }
diff --git a/examples/unitTestExample/lint.xml b/examples/unitTestExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/unitTestExample/lint.xml
+++ b/examples/unitTestExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/unitTestExample/src/main/AndroidManifest.xml b/examples/unitTestExample/src/main/AndroidManifest.xml
index bdb9f97441..5dfb87f40a 100644
--- a/examples/unitTestExample/src/main/AndroidManifest.xml
+++ b/examples/unitTestExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
index 757f0f5422..b918cdd6f4 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -85,9 +85,12 @@ public void onClick(View v) {
 
     private void cleanUp() {
         // Delete all persons
-        realm.beginTransaction();
-        realm.allObjects(Person.class).deleteAllFromRealm();
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
     }
 
     @Override
@@ -107,40 +110,45 @@ private void basicCRUD(Realm realm) {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.beginTransaction();
-
-        // Add a person
-        Person person = realm.createObject(Person.class);
-        person.setId(1);
-        person.setName("John Young");
-        person.setAge(14);
-
-        // When the transaction is committed, all changes a synced to disk.
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // Add a person
+                Person person = realm.createObject(Person.class);
+                person.setId(1);
+                person.setName("John Young");
+                person.setAge(14);
+            }
+        });
 
         // Find the first person (no query conditions) and read a field
-        person = realm.where(Person.class).findFirst();
+        final Person person = realm.where(Person.class).findFirst();
         showStatus(person.getName() + ":" + person.getAge());
 
         // Update person in a transaction
-        realm.beginTransaction();
-        person.setName("John Senior");
-        person.setAge(89);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                person.setName("John Senior");
+                person.setAge(89);
+            }
+        });
+
         showStatus(person.getName() + " got older: " + person.getAge());
-        realm.commitTransaction();
 
         // Add two more people
-        realm.beginTransaction();
-
-        Person jane = realm.createObject(Person.class);
-        jane.setName("Jane");
-        jane.setAge(27);
-
-        Person doug = realm.createObject(Person.class);
-        doug.setName("Robert");
-        doug.setAge(42);
-
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Person jane = realm.createObject(Person.class);
+                jane.setName("Jane");
+                jane.setAge(27);
+
+                Person doug = realm.createObject(Person.class);
+                doug.setName("Robert");
+                doug.setAge(42);
+            }
+        });
 
         RealmResults<Person> people = realm.where(Person.class).findAll();
         showStatus(String.format("Found %s people", people.size()));
@@ -153,7 +161,7 @@ private String complexQuery() {
         String status = "\n\nPerforming complex Query operation...";
 
         Realm realm = Realm.getInstance(realmConfig);
-        status += "\nNumber of people in the DB: " + realm.allObjects(Person.class).size();
+        status += "\nNumber of people in the DB: " + realm.where(Person.class).count();
 
         // Find all persons where age between 1 and 99 and name begins with "J".
         RealmResults<Person> results = realm.where(Person.class)
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
index d9ba05e744..60ff3b2eeb 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
@@ -22,12 +22,15 @@
 
 public class DogRepositoryImpl implements DogRepository {
     @Override
-    public void createDog(String name) {
+    public void createDog(final String name) {
         Realm realm = Realm.getDefaultInstance();
-        realm.beginTransaction();
-        Dog dog = realm.createObject(Dog.class);
-        dog.setName(name);
-        realm.commitTransaction();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Dog dog = realm.createObject(Dog.class);
+                dog.setName(name);
+            }
+        });
         realm.close();
     }
 }
diff --git a/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 1abe5250b8..4e23a70df5 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -22,6 +22,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.modules.junit4.rule.PowerMockRule;
@@ -30,7 +31,6 @@
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ActivityController;
 
-import java.lang.Exception;
 import java.util.Arrays;
 import java.util.List;
 
@@ -42,20 +42,20 @@
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
 
-
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doCallRealMethod;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.powermock.api.mockito.PowerMockito.doNothing;
 import static org.powermock.api.mockito.PowerMockito.mock;
 import static org.powermock.api.mockito.PowerMockito.mockStatic;
 import static org.powermock.api.mockito.PowerMockito.verifyStatic;
 import static org.powermock.api.mockito.PowerMockito.when;
 import static org.powermock.api.mockito.PowerMockito.whenNew;
-import static org.powermock.api.mockito.PowerMockito.doNothing;
 
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
@@ -137,7 +137,7 @@ public void setup() throws Exception {
         RealmResults<Person> people = mockRealmResults();
 
         // When we ask Realm for all of the Person instances, return the mock RealmResults
-        when(mockRealm.allObjects(Person.class)).thenReturn(people);
+        when(mockRealm.where(Person.class).findAll()).thenReturn(people);
 
         // When a between query is performed with any string as the field and any int as the
         // value, then return the personQuery itself
@@ -167,6 +167,8 @@ public void setup() throws Exception {
 
     @Test
     public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
+        doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
+
         // Create activity
         ActivityController<ExampleActivity> controller =
                 Robolectric.buildActivity(ExampleActivity.class).setup();
@@ -179,24 +181,23 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         Realm.getInstance(any(RealmConfiguration.class));
 
         // verify that we have four begin and commit transaction calls
-        verify(mockRealm, times(4)).beginTransaction();
-        verify(mockRealm, times(4)).commitTransaction();
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        //verify(mockRealm, times(4)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Click the clean up button
         activity.findViewById(R.id.clean_up).performClick();
 
         // Verify that begin and commit transaction were called (been called a total of 5 times now)
-        verify(mockRealm, times(5)).beginTransaction();
-        verify(mockRealm, times(5)).commitTransaction();
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        //verify(mockRealm, times(5)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
-        // Verify that we queried for all Person instance two times in this run (in the original
-        // onCreate, and then again in the button click). Was called two times previously in the
-        // setup, therefore we need to check if it was called again.
-        verify(mockRealm, times(3)).allObjects(Person.class);
+        // Verify that we queried for Person instances five times in this run (2 in basicCrud(),
+        // 2 in complexQuery() and 1 in the button click)
+        verify(mockRealm, times(5)).where(Person.class);
 
-        // Verify that the clear method was called. Clear is also called in the start of the
+        // Verify that the delete method was called. Delete is also called in the start of the
         // activity to ensure we start with a clean db.
-        verify(people, times(2)).deleteAllFromRealm();
+        verify(mockRealm, times(2)).delete(Person.class);
 
         // Call the destroy method so we can verify that the .close() method was called (below)
         controller.destroy();
@@ -206,6 +207,44 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         verify(mockRealm, times(2)).close();
     }
 
+    /**
+     * Have to verify the transaction execution in a different test because
+     * of a problem with Powermock: https://github.com/jayway/powermock/issues/649
+     */
+    @Test
+    public void shouldBeAbleToVerifyTransactionCalls() {
+
+        // Create activity
+        ActivityController<ExampleActivity> controller =
+                Robolectric.buildActivity(ExampleActivity.class).setup();
+        ExampleActivity activity = controller.get();
+
+        assertThat(activity.getTitle().toString(), is("Unit Test Example"));
+
+        // Verify that two Realm.getInstance() calls took place.
+        verifyStatic(times(2));
+        Realm.getInstance(any(RealmConfiguration.class));
+
+        // verify that we have four begin and commit transaction calls
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        verify(mockRealm, times(4)).executeTransaction(Mockito.any(Realm.Transaction.class));
+
+        // Click the clean up button
+        activity.findViewById(R.id.clean_up).performClick();
+
+        // Verify that begin and commit transaction were called (been called a total of 5 times now)
+        // Do not verify partial mock invocation count: https://github.com/jayway/powermock/issues/649
+        verify(mockRealm, times(5)).executeTransaction(Mockito.any(Realm.Transaction.class));
+
+        // Call the destroy method so we can verify that the .close() method was called (below)
+        controller.destroy();
+
+        // Verify that the realm got closed 2 separate times. Once in the AsyncTask, once
+        // in onDestroy
+        verify(mockRealm, times(2)).close();
+    }
+
+
     @SuppressWarnings("unchecked")
     private <T extends RealmObject> RealmQuery<T> mockRealmQuery() {
         return mock(RealmQuery.class);
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
index 8aef6265e8..e7be410e33 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -38,6 +38,7 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.internal.verification.VerificationModeFactory.times;
+import static org.powermock.api.mockito.PowerMockito.doCallRealMethod;
 import static org.powermock.api.mockito.PowerMockito.mockStatic;
 import static org.powermock.api.mockito.PowerMockito.when;
 
@@ -91,7 +92,9 @@ public void shouldBeAbleToCreateARealmObject() {
      * This test verifies the behavior in the {@link DogRepositoryImpl} class.
      */
     @Test
-    public void shouldVerifyTransactionWasCreated() {
+    public void shouldVerifyThatDogWasCreated() {
+
+        doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         Dog dog = mock(Dog.class);
         when(mockRealm.createObject(Dog.class)).thenReturn(dog);
@@ -99,8 +102,12 @@ public void shouldVerifyTransactionWasCreated() {
         DogRepository dogRepo = new DogRepositoryImpl();
         dogRepo.createDog("Spot");
 
-        // Verify that the begin transaction was called only once
-        verify(mockRealm, times(1)).beginTransaction();
+        // Attempting to verify that a method was called (executeTransaction) on a partial
+        // mock will return unexpected resultes due to the partial mock. For example,
+        // verifying that `executeTransaction` was called only once will fail as Powermock
+        // actually calls the method 3 times for some reason. I cannot determine why at this
+        // point.
+
 
         // Verify that Realm#createObject was called only once
         verify(mockRealm, times(1)).createObject(Dog.class); // Verify that a Dog was in fact created.
@@ -108,8 +115,22 @@ public void shouldVerifyTransactionWasCreated() {
         // Verify that Dog#setName() is called only once
         verify(dog, times(1)).setName(Mockito.anyString()); // Any string will do
 
-        // Verify that the transaction was committed only once
-        verify(mockRealm, times(1)).commitTransaction();
+        // Verify that the Realm was closed only once.
+        verify(mockRealm, times(1)).close();
+    }
+
+    /**
+     * Have to verify the {@link Realm#executeTransaction(Realm.Transaction)} call in a different
+     * test because of a problem with Powermock: https://github.com/jayway/powermock/issues/649
+     */
+    @Test
+    public void shouldVerifyThatTransactionWasExecuted() {
+
+        DogRepository dogRepo = new DogRepositoryImpl();
+        dogRepo.createDog("Spot");
+
+        // Verify that the begin transaction was called only once
+        verify(mockRealm, times(1)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Verify that the Realm was closed only once.
         verify(mockRealm, times(1)).close();
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index dec61401ca..2bcb843bee 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -47,7 +47,7 @@ dependencies {
     compile localGroovy()
     compile "io.realm:realm-transformer:${version}"
     compile 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
 
     testCompile gradleTestKit()
     testCompile 'junit:junit:4.12'
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 2077c526da..0ca9c0c343 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -19,6 +19,7 @@ package io.realm.gradle
 import com.android.build.gradle.AppPlugin
 import com.android.build.gradle.LibraryPlugin
 import com.neenbedankt.gradle.androidapt.AndroidAptPlugin
+import io.realm.transformer.RealmOptionalAPITransformer
 import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
@@ -39,19 +40,21 @@ class Realm implements Plugin<Project> {
             throw new GradleException('Realm gradle plugin only supports android gradle plugin 1.5.0 or later.')
         }
 
-        def isKotlinProject = project.plugins.find {
-            it.getClass().name == 'org.jetbrains.kotlin.gradle.plugin.KotlinAndroidPluginWrapper'
-        }
+        def usesKotlinPlugin = project.plugins.findPlugin('kotlin-android') != null
+        def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
+
+        def isKaptProject = usesKotlinPlugin && !usesAptPlugin
 
-        if (!isKotlinProject) {
+        if (!isKaptProject) {
             project.plugins.apply(AndroidAptPlugin)
         }
 
-        project.android.registerTransform(new RealmTransformer())
+        project.android.registerTransform(new RealmTransformer(project))
+
         project.repositories.add(project.getRepositories().jcenter())
         project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
-        if (isKotlinProject) {
+        if (isKaptProject) {
             project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
         } else {
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index e7be7c0de8..c48dc6cb37 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -17,6 +17,8 @@
 package io.realm.gradle
 
 import com.android.build.api.transform.Transform
+import io.realm.transformer.RealmOptionalAPITransformer
+import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Project
 import org.gradle.api.artifacts.Dependency
@@ -30,6 +32,7 @@ import org.junit.Before
 import org.junit.Test
 
 import static org.junit.Assert.assertEquals
+import static org.junit.Assert.assertFalse
 import static org.junit.Assert.assertTrue
 import static org.junit.Assert.fail
 
@@ -52,7 +55,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
@@ -67,6 +70,8 @@ class PluginTest {
         assertTrue(containsDependency(project.dependencies, 'io.realm', 'realm-annotations', currentVersion))
 
         assertTrue(containsTransform(project.android.transforms, RealmTransformer.class))
+        // Disabled because of https://github.com/realm/realm-java/issues/3022
+        assertFalse(containsTransform(project.android.transforms, RealmOptionalAPITransformer.class))
     }
 
     @Test
@@ -77,7 +82,7 @@ class PluginTest {
                 jcenter()
             }
             dependencies {
-                classpath 'com.android.tools.build:gradle:1.5.0'
+                classpath 'com.android.tools.build:gradle:2.1.0'
                 classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
                 classpath "io.realm:realm-gradle-plugin:${currentVersion}"
             }
diff --git a/integration-tests/build.gradle b/integration-tests/build.gradle
new file mode 100644
index 0000000000..272cd2af02
--- /dev/null
+++ b/integration-tests/build.gradle
@@ -0,0 +1,34 @@
+project.ext.sdkVersion = 24
+project.ext.buildTools = '24.0.0'
+
+// Don't cache SNAPSHOT (changing) dependencies.
+configurations.all {
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+
+allprojects {
+    def currentVersion = file("${rootDir}/../version.txt").text.trim()
+
+    buildscript {
+        repositories {
+            mavenLocal()
+            jcenter()
+        }
+        dependencies {
+            classpath 'com.android.tools.build:gradle:2.1.0'
+            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+            classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
+            classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
+            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
+            classpath "io.realm:realm-gradle-plugin:${currentVersion}"
+        }
+    }
+
+    group = 'io.realm'
+    version = currentVersion
+
+    repositories {
+        mavenLocal()
+        jcenter()
+    }
+}
diff --git a/integration-tests/gradle/wrapper/gradle-wrapper.jar b/integration-tests/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..13372aef5e
Binary files /dev/null and b/integration-tests/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/integration-tests/gradle/wrapper/gradle-wrapper.properties b/integration-tests/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..122a0dca2e
--- /dev/null
+++ b/integration-tests/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Mon Dec 28 10:00:20 PST 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/integration-tests/gradlew b/integration-tests/gradlew
new file mode 100755
index 0000000000..9d82f78915
--- /dev/null
+++ b/integration-tests/gradlew
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/integration-tests/gradlew.bat b/integration-tests/gradlew.bat
new file mode 100644
index 0000000000..aec99730b4
--- /dev/null
+++ b/integration-tests/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/integration-tests/optionalAPIExists/.gitignore b/integration-tests/optionalAPIExists/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/integration-tests/optionalAPIExists/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/integration-tests/optionalAPIExists/build.gradle b/integration-tests/optionalAPIExists/build.gradle
new file mode 100644
index 0000000000..0113dfc97a
--- /dev/null
+++ b/integration-tests/optionalAPIExists/build.gradle
@@ -0,0 +1,27 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId "io.realm.tests.optionalapiexists"
+        minSdkVersion 9
+        targetSdkVersion rootProject.sdkVersion
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'io.reactivex:rxjava:1.1.0'
+}
diff --git a/integration-tests/optionalAPIExists/proguard-rules.pro b/integration-tests/optionalAPIExists/proguard-rules.pro
new file mode 100644
index 0000000000..8456b3daec
--- /dev/null
+++ b/integration-tests/optionalAPIExists/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /home/cc/.android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java b/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java
new file mode 100644
index 0000000000..7553ce9c47
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/androidTest/java/io/realm/tests/optionalapiexists/ApplicationTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.optionalapiexists;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+    private RealmConfiguration realmConfiguration;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        realmConfiguration = new RealmConfiguration.Builder(this.getContext()).build();
+
+        realm = Realm.getInstance(realmConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
+        // Open the dynamic Realm after transaction.
+        dynamicRealm = DynamicRealm.getInstance(realmConfiguration);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        realm.close();
+        dynamicRealm.close();
+        Realm.deleteRealm(realmConfiguration);
+        super.tearDown();
+    }
+
+    public void testRealmAsObservableRemoved() {
+        assertNotNull(realm.asObservable());
+    }
+
+    public void testRealmObjectAsObservableRemoved() {
+        Dog dog = realm.where(Dog.class).findFirst();
+        assertNotNull(dog.asObservable());
+    }
+
+    public void testDynamicRealmAsObservableRemoved() {
+        assertNotNull(dynamicRealm.asObservable());
+    }
+
+    public void testDynamicRealmObjectAsObservableRemoved() {
+        DynamicRealmObject dog = dynamicRealm.where("Dog").findFirst();
+        assertNotNull(dog.asObservable());
+    }
+
+    public void testRealmResultsAsObservableRemoved() {
+        RealmResults<Dog> results = realm.where(Dog.class).findAll();
+        assertNotNull(results.asObservable());
+    }
+}
diff --git a/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml b/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..d846ee6f5c
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/main/AndroidManifest.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.tests.optionalapiexists"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:label="optionalAPIExists"
+        android:supportsRtl="true" >
+        <activity android:name=".MainActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java
similarity index 75%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
rename to integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java
index d85661cc79..84700f6b22 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
+++ b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/Dog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package io.realm.tests.optionalapiexists;
 
-package io.realm.internal.test;
+import io.realm.RealmObject;
 
-public class TestValue {
-
-    public Object value;
-
-    public TestValue(Object value) {
-        this.value = value;
-    }
+public class Dog extends RealmObject {
+    @SuppressWarnings("unused")
+    String name;
 }
-
diff --git a/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java
new file mode 100644
index 0000000000..7f92feee88
--- /dev/null
+++ b/integration-tests/optionalAPIExists/src/main/java/io/realm/tests/optionalapiexists/MainActivity.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.optionalapiexists;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class MainActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+}
diff --git a/integration-tests/optionalAPIRemoved/.gitignore b/integration-tests/optionalAPIRemoved/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/integration-tests/optionalAPIRemoved/build.gradle b/integration-tests/optionalAPIRemoved/build.gradle
new file mode 100644
index 0000000000..56863ce43f
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/build.gradle
@@ -0,0 +1,26 @@
+apply plugin: 'com.android.application'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
+
+    defaultConfig {
+        applicationId "io.realm.tests.removeoptionalapitest"
+        minSdkVersion 9
+        targetSdkVersion rootProject.sdkVersion
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    androidTestCompile 'io.reactivex:rxjava:1.1.0'
+}
diff --git a/integration-tests/optionalAPIRemoved/proguard-rules.pro b/integration-tests/optionalAPIRemoved/proguard-rules.pro
new file mode 100644
index 0000000000..8456b3daec
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /home/cc/.android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java b/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java
new file mode 100644
index 0000000000..f248b97f01
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/androidTest/java/io/realm/tests/removeoptionalapitest/ApplicationTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.removeoptionalapitest;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import rx.Observable;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+
+    private Realm realm;
+    private DynamicRealm dynamicRealm;
+    private RealmConfiguration realmConfiguration;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        realmConfiguration = new RealmConfiguration.Builder(this.getContext()).build();
+
+        realm = Realm.getInstance(realmConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
+        // Open the dynamic Realm after transaction.
+        dynamicRealm = DynamicRealm.getInstance(realmConfiguration);
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        realm.close();
+        dynamicRealm.close();
+        Realm.deleteRealm(realmConfiguration);
+        super.tearDown();
+    }
+
+    public void testRealmAsObservableRemoved() {
+        try {
+            @SuppressWarnings("unused")
+            Observable<Realm> observable = realm.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testRealmObjectAsObservableRemoved() {
+        Dog dog = realm.where(Dog.class).findFirst();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<Dog> observable = dog.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testDynamicRealmAsObservableRemoved() {
+        try {
+            @SuppressWarnings("unused")
+            Observable<DynamicRealm> observable = dynamicRealm.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testDynamicRealmObjectAsObservableRemoved() {
+        DynamicRealmObject dog = dynamicRealm.where("Dog").findFirst();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<DynamicRealmObject> observable = dog.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+
+    public void testRealmResultsAsObservableRemoved() {
+        RealmResults<Dog> results = realm.where(Dog.class).findAll();
+
+        try {
+            @SuppressWarnings("unused")
+            Observable<RealmResults<Dog>> observable = results.asObservable();
+            fail();
+        } catch (NoSuchMethodError ignored) {
+        }
+    }
+}
diff --git a/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml b/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..9201846149
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="io.realm.tests.removeoptionalapitest"
+          xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <application
+        android:allowBackup="true"
+        android:label="optionalAPIRemoved"
+        android:supportsRtl="true" >
+        <activity
+            android:name=".MainActivity" >
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+</manifest>
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java
similarity index 70%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
rename to integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java
index e841f2daee..e04ed805ae 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
+++ b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/Dog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package io.realm.tests.removeoptionalapitest;
 
-package io.realm.internal.test;
+import io.realm.RealmObject;
 
-import io.realm.RealmFieldType;
-
-public class ColumnTypeData {
-
-    public RealmFieldType type;
-
-    public ColumnTypeData(RealmFieldType type) {
-        this.type = type;
-    }
+public class Dog extends RealmObject {
+    @SuppressWarnings("unused")
+    String name;
 }
diff --git a/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java
new file mode 100644
index 0000000000..dec189185d
--- /dev/null
+++ b/integration-tests/optionalAPIRemoved/src/main/java/io/realm/tests/removeoptionalapitest/MainActivity.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.tests.removeoptionalapitest;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class MainActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+    }
+}
diff --git a/integration-tests/settings.gradle b/integration-tests/settings.gradle
new file mode 100644
index 0000000000..f804c6689a
--- /dev/null
+++ b/integration-tests/settings.gradle
@@ -0,0 +1,4 @@
+include ':optionalAPIRemoved', ':optionalAPIExists'
+
+rootProject.name = 'integration-tests'
+
diff --git a/logo.png b/logo.png
index cbe7817724..c64d652d2d 100644
Binary files a/logo.png and b/logo.png differ
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
index 940a462ac9..f28f9eb835 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -34,6 +34,10 @@
  * {@code library = true}. Setting {@code library = true} is normally only relevant for library authors. See below for
  * further details.
  *
+ * <p>
+ * Currently, it is not possible to have multiple RealmModule declarations in a single file. If you have more than one
+ * RealmModule, you will have to use separate Java files for each module.
+ *
  *
  * <h2>RealmModules and libraries</h2>
  *
diff --git a/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java b/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java
new file mode 100644
index 0000000000..0b397d7671
--- /dev/null
+++ b/realm-annotations/src/main/java/io/realm/annotations/internal/OptionalAPI.java
@@ -0,0 +1,16 @@
+package io.realm.annotations.internal;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation is used to mark an API as optional with one or more class {@link #dependencies()}. The bytecode
+ * transformer will decide on build time to remove the corresponding API if it doesn't fulfill the dependencies.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.METHOD)
+public @interface OptionalAPI {
+    String[] dependencies();
+}
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index c9ee011571..e7ebc88668 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -1,14 +1,18 @@
 buildscript {
+    ext.kotlin_version = '1.0.1-2'
     repositories {
         jcenter()
+        mavenCentral()
     }
     dependencies {
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
 apply plugin: 'groovy'
+apply plugin: 'kotlin'
 apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
@@ -24,6 +28,7 @@ targetCompatibility = '1.6'
 repositories {
     mavenLocal()
     jcenter()
+    mavenCentral()
 }
 
 configurations {
@@ -39,18 +44,20 @@ sourceSets {
             srcDir 'build/generated-src/main/java'
         }
     }
+    main.java.srcDirs += 'src/main/kotlin'
 }
 
 dependencies {
     compile localGroovy()
     compile gradleApi()
     compile "io.realm:realm-annotations:${version}"
-    provided 'com.android.tools.build:gradle:1.5.0'
+    provided 'com.android.tools.build:gradle:2.1.0'
     compile 'org.javassist:javassist:3.20.0-GA'
 
     testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
         exclude module: 'groovy-all'
     }
+    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 }
 
 // for Ant filter
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index 96a163bac1..d58fb39b7c 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -27,6 +27,7 @@ import io.realm.annotations.RealmClass
 import javassist.ClassPool
 import javassist.CtClass
 import javassist.LoaderClassPath
+import org.gradle.api.Project
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
 
@@ -43,6 +44,11 @@ import static com.android.build.api.transform.QualifiedContent.*
 class RealmTransformer extends Transform {
 
     private Logger logger = LoggerFactory.getLogger('realm-logger')
+    private Project project
+
+    public RealmTransformer(Project project) {
+        this.project = project
+    }
 
     @Override
     String getName() {
@@ -84,6 +90,9 @@ class RealmTransformer extends Transform {
 
         // Create and populate the Javassist class pool
         ClassPool classPool = createClassPool(inputs, referencedInputs)
+        // Append android.jar to class pool. We don't need the class names of them but only the class in the pool for
+        // javassist. See https://github.com/realm/realm-java/issues/2703.
+        addBootClassesToClassPool(classPool)
 
         logger.info "ClassPool contains Realm classes: ${classPool.getOrNull('io.realm.RealmList') != null}"
 
@@ -278,4 +287,19 @@ class RealmTransformer extends Transform {
         return merged;
     }
 
+    // There is no official way to get the path to android.jar for transform.
+    // See https://code.google.com/p/android/issues/detail?id=209426
+    private void addBootClassesToClassPool(ClassPool classPool) {
+        try {
+            project.android.bootClasspath.each {
+                String path = it.absolutePath
+                logger.info "Add boot class " + path + " to class pool."
+                classPool.appendClassPath(path)
+            }
+        } catch (Exception e) {
+            // Just log it. It might not impact the transforming if the method which needs to be transformer doesn't
+            // contain classes from android.jar.
+            logger.info("Cannot get bootClasspath caused by:", e)
+        }
+    }
 }
diff --git a/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
index a151800a9d..aa32099d22 100644
--- a/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
+++ b/realm-transformer/src/main/java/io/realm/transformer/ComputerIdentifierGenerator.java
@@ -94,7 +94,7 @@ private static String getMacOsIdentifier() throws SocketException, NoSuchAlgorit
 
     private static String getWindowsIdentifier() throws IOException, NoSuchAlgorithmException {
         Runtime runtime = Runtime.getRuntime();
-        Process process = runtime.exec(new String[] { "wmic", "bios", "get", "serialnumber" });
+        Process process = runtime.exec(new String[] { "wmic", "csproduct", "get", "UUID" });
 
         String result = null;
         InputStream is = process.getInputStream();
@@ -102,7 +102,7 @@ private static String getWindowsIdentifier() throws IOException, NoSuchAlgorithm
         try {
             while (sc.hasNext()) {
                 String next = sc.next();
-                if ("SerialNumber".equals(next)) {
+                if (next.contains("UUID")) {
                     result = sc.next().trim();
                     break;
                 }
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt
new file mode 100644
index 0000000000..e17ccf978e
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/RealmOptionalAPITransformer.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer
+
+import com.android.build.api.transform.Format
+import com.android.build.api.transform.Context
+import com.android.build.api.transform.Transform
+import com.android.build.api.transform.QualifiedContent.ContentType
+import com.android.build.api.transform.QualifiedContent.Scope
+import com.android.build.api.transform.QualifiedContent.DefaultContentType
+import com.android.build.api.transform.TransformInput
+import com.android.build.api.transform.TransformOutputProvider
+import com.google.common.collect.ImmutableSet
+import io.realm.annotations.internal.OptionalAPI
+import io.realm.transformer.util.appendThisToClassNames
+import io.realm.transformer.util.appendThisToClassPool
+import io.realm.transformer.util.createClassPool
+import org.slf4j.LoggerFactory
+import java.util.HashSet
+
+class RealmOptionalAPITransformer : Transform() {
+
+    private val logger = LoggerFactory.getLogger("realm-logger")
+    private val transformerName = "realm-optional-api"
+
+    override fun getName(): String? = "RealmOptionalAPITransformer"
+
+    override fun isIncremental(): Boolean = false
+
+    override fun getInputTypes(): MutableSet<ContentType>? = ImmutableSet.of(DefaultContentType.CLASSES)
+
+    override fun getScopes(): MutableSet<Scope>? = ImmutableSet.of(Scope.EXTERNAL_LIBRARIES)
+
+    override fun getReferencedScopes(): MutableSet<Scope>? = ImmutableSet.of(Scope.PROJECT, Scope.PROJECT_LOCAL_DEPS,
+            Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.EXTERNAL_LIBRARIES)
+
+    override fun transform(context: Context?,
+                           inputs: MutableCollection<TransformInput>?,
+                           referencedInputs: MutableCollection<TransformInput>?,
+                           outputProvider: TransformOutputProvider?,
+                           isIncremental: Boolean) {
+
+        val classNames = HashSet<String>()
+        inputs!!.appendThisToClassNames(classNames)
+        val refClassNames = HashSet<String>()
+        referencedInputs!!.appendThisToClassNames(refClassNames)
+        val classPool = createClassPool()
+        inputs.appendThisToClassPool(classPool)
+
+        classNames.filter { it.startsWith("io.realm.") }.forEach {
+            classPool.get(it).declaredMethods.forEach {
+                val optionalAPIAnnotation = it.getAnnotation(OptionalAPI::class.java) as? OptionalAPI
+                val dependenciesList = optionalAPIAnnotation?.dependencies?.toList()
+
+                if (optionalAPIAnnotation == null) {
+                    logger.debug("${it.declaringClass.name} ${it.name} doesn't have @OptionalAPI annotation.")
+                } else if (dependenciesList == null || dependenciesList.size == 0) {
+                    throw IllegalArgumentException("${it.name} doesn't have proper dependencies: " +
+                            "${optionalAPIAnnotation.dependencies}.")
+                } else if (!refClassNames.containsAll(dependenciesList)) {
+                    // Doesn't have enough dependencies, remove the API
+                    logger.debug("${it.declaringClass.name} ${it.name} will be removed since some of the dependencies " +
+                            "in $dependenciesList don't exist.")
+                    it.declaringClass.removeMethod(it)
+                } else {
+                    logger.debug("${it.declaringClass.name} ${it.name} has all dependencies in $dependenciesList.")
+                }
+            }
+        }
+
+        // Create outputs
+        classNames.forEach {
+            val ctClass = classPool.getCtClass(it)
+            ctClass.writeFile(
+                    outputProvider!!.getContentLocation(transformerName, inputTypes, scopes, Format.DIRECTORY).canonicalPath)
+        }
+    }
+}
diff --git a/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt b/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt
new file mode 100644
index 0000000000..77ab24630e
--- /dev/null
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/util/MutableCollectionExt.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.transformer.util
+
+import com.android.SdkConstants
+import com.android.build.api.transform.TransformInput
+import javassist.ClassPool
+import java.io.File
+import java.util.jar.JarFile
+
+// Find all classes and append their names to the given String collection
+fun MutableCollection<TransformInput>.appendThisToClassNames(classNames: MutableCollection<String>) {
+    for (item: TransformInput in this) {
+        for (input in item.directoryInputs) {
+            val dirPath = input.file.absolutePath
+            input.file.walkTopDown().filter { it.isFile && it.endsWith(SdkConstants.DOT_CLASS) }.forEach {
+                val qualifiedClassName = it.absolutePath.substring(
+                        dirPath.length + 1,
+                        input.file.absolutePath.length - SdkConstants.DOT_CLASS.length)
+                        .replace(File.separatorChar, '.')
+                classNames.add(qualifiedClassName)
+            }
+        }
+
+        for (input in item.jarInputs) {
+            val jarFile = JarFile(input.file)
+            jarFile.entries().asSequence().filter { it.name.endsWith(SdkConstants.DOT_CLASS) }.forEach {
+                val path = it.name
+                // The jar might not using File.separatorChar as the path separator. So we just replace both `\` and
+                // `/`. It depends on how the jar file was created.
+                // See http://stackoverflow.com/questions/13846000/file-separators-of-path-name-of-zipentry
+                val qualifiedClassName = path.substring(0, path.length - SdkConstants.DOT_CLASS.length)
+                        .replace('/', '.')
+                        .replace('\\', '.')
+                classNames.add(qualifiedClassName)
+            }
+        }
+    }
+}
+
+// Add all the classes in this collection to the given ClassPool
+fun MutableCollection<TransformInput>.appendThisToClassPool(classPool: ClassPool) {
+    this.forEach {
+        it.directoryInputs.forEach { classPool.appendClassPath(it.file.absolutePath) }
+        it.jarInputs.forEach { classPool.appendClassPath(it.file.absolutePath) }
+    }
+}
diff --git a/realm/realm-jni/src/columntypeutil.hpp b/realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt
similarity index 53%
rename from realm/realm-jni/src/columntypeutil.hpp
rename to realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt
index 07f3e5d324..75f76d3594 100644
--- a/realm/realm-jni/src/columntypeutil.hpp
+++ b/realm-transformer/src/main/kotlin/io/realm/transformer/util/Utils.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,25 +14,18 @@
  * limitations under the License.
  */
 
-#ifndef REALM_COLUMN_TYPE_UTIL_H
-#define REALM_COLUMN_TYPE_UTIL_H
+package io.realm.transformer.util
 
-#include <jni.h>
-#include <realm.hpp>
+import javassist.ClassPool
+import javassist.LoaderClassPath
 
-#ifdef __cplusplus
+fun createClassPool() : ClassPool {
+    // Don't use ClassPool.getDefault(). Doing consecutive builds in the same run (e.g. debug+release)
+    // will use a cached object and all the classes will be frozen.
+    val classPool = ClassPool()
+    classPool.appendSystemPath()
+    classPool.appendClassPath(LoaderClassPath(ClassLoader.getSystemClassLoader()))
 
-using realm::DataType;
-
-extern "C" {
-
-#endif
-
-DataType GetColumnTypeFromJColumnType(JNIEnv* env, jobject jColumnType);
-jobject GetJColumnTypeFromColumnType(JNIEnv* env, DataType columnType);
-
-#ifdef __cplusplus
+    return classPool
 }
-#endif
 
-#endif
diff --git a/realm/build.gradle b/realm/build.gradle
index 589eb622a1..61e092c997 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -2,14 +2,14 @@ buildscript {
     repositories {
         mavenLocal()
         jcenter()
+        maven { url 'https://jitpack.io' }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
+        classpath 'com.android.tools.build:gradle:2.1.0'
         classpath 'de.undercouch:gradle-download-task:2.0.0'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
-        classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 071ca3c6c6..37ab1ae7e9 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -42,6 +42,16 @@
         <Field name="minDepth" />
         <Bug pattern="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD" />
     </Match>
+    <Match>
+        <Class name="io.realm.internal.SharedGroup" />
+        <Field name="INCREMENTAL_BACKOFF_MS" />
+        <Bug pattern="MS_FINAL_PKGPROTECT" />
+    </Match>
+    <Match>
+        <Class name="io.realm.internal.SharedGroup" />
+        <Field name="INCREMENTAL_BACKOFF_LIMIT_MS" />
+        <Bug pattern="MS_SHOULD_BE_FINAL" />
+    </Match>
 
     <!-- Unit tests -->
     <Match>
@@ -58,5 +68,10 @@
         <Class name="~.*Tests?$"/>
         <Bug pattern="DM_GC"/>
     </Match>
+    <Match>
+        <Class name="io.realm.HandlerController" />
+        <Method name="completedAsyncRealmObject" />
+        <Bug pattern="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN" />
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/gradle.properties b/realm/gradle.properties
index 7d70fda02c..033fd72f9a 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1 @@
-org.gradle.jvmargs=-Xms256m -Xmx1024m
\ No newline at end of file
+org.gradle.jvmargs=-Xms256m -Xmx2048m
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index fe4dab1d3c..b6ca11d063 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -15,7 +15,7 @@ dependencies {
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-21/android.jar"))
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-24/android.jar"))
 }
 
 // for Ant filter
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 94586963b4..e13bbc4626 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -31,8 +31,10 @@
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import io.realm.annotations.Ignore;
@@ -59,11 +61,13 @@
 
     private final List<TypeMirror> validPrimaryKeyTypes;
     private final Types typeUtils;
+    private final Elements elements;
 
     public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
+        elements = env.getElementUtils();
         TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
         validPrimaryKeyTypes = Arrays.asList(
                 stringType,
@@ -112,6 +116,7 @@ public boolean generate() {
 
         if (!categorizeClassElements()) return false;
         if (!checkListTypes()) return  false;
+        if (!checkReferenceTypes()) return  false;
         if (!checkDefaultConstructor()) return false;
         if (!checkForFinalFields()) return false;
         if (!checkForTransientFields()) return false;
@@ -156,15 +161,46 @@ private boolean checkForFinalFields() {
     private boolean checkListTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmList(field)) {
-                if (Utils.getGenericType(field) == null) {
+                // Check for missing generic (default back to Object)
+                if (Utils.getGenericTypeQualifiedName(field) == null) {
                     Utils.error("No generic type supplied for field", field);
                     return false;
                 }
+
+                // Check that the referenced type is a concrete class and not an interface
+                TypeMirror fieldType = field.asType();
+                List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
+                String genericCanonicalType = typeArguments.get(0).toString();
+                TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes are allowed in RealmLists. Neither " +
+                            "interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
             }
         }
+
         return true;
     }
 
+    private boolean checkReferenceTypes() {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmModel(field)) {
+                // Check that the referenced type is a concrete class and not an interface
+                TypeElement typeElement = elements.getTypeElement(field.asType().toString());
+                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                    Utils.error("Only concrete Realm classes can be referenced in model classes. " +
+                            "Neither interfaces nor abstract classes can be used.", field);
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+
+
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 8cb7ec6ea8..68b2f11ca9 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -27,7 +27,7 @@
     public static final String TABLE_PREFIX = "class_";
     public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
     static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
-            "throw new IllegalArgumentException(\"Trying to set non-nullable field %s to null.\")";
+            "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")";
 
     static final Map<String, String> JAVA_TO_REALM_TYPES;
     static {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index 6fc488c70c..cd63ab09a3 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -86,8 +86,10 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
             }
 
             @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("Date is not allowed as a primary key value.");
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                         String qualifiedRealmObjectProxyClass,
+                                                         String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
             }
         });
         JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmFieldTypeConverter() {
@@ -121,17 +123,21 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
             }
 
             @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("byte[] is not allowed as a primary key value.");
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                         String qualifiedRealmObjectProxyClass,
+                                                         String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
             }
         });
     }
 
-    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedFieldType,
+    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                           String qualifiedRealmObjectProxyClass,
+                                                           String qualifiedFieldType,
                                                            String fieldName, JavaWriter writer) throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, fieldName, writer);
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
         }
     }
 
@@ -278,20 +284,24 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
         }
 
         @Override
-        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
+        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                     String qualifiedRealmObjectProxyClass,
+                                                     String fieldName, JavaWriter writer) throws IOException {
             // No error checking is done here for valid primary key types. This should be done by the annotation
             // processor
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, null)", qualifiedRealmObjectClass)
+                        .emitStatement("obj = (%1$s) realm.createObject(%2$s.class, null)",
+                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
                     .nextControlFlow("else")
-                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, json.get%2$s(\"%3$s\"))",
-                                qualifiedRealmObjectClass, jsonType, fieldName)
+                        .emitStatement("obj = (%1$s) realm.createObject(%2$s.class, json.get%3$s(\"%4$s\"))",
+                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
                     .endControlFlow()
                 .nextControlFlow("else")
-                    .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class)", qualifiedRealmObjectClass)
-                .endControlFlow();
+                    .emitStatement("obj = (%1$s) realm.createObject(%2$s.class)",
+                            qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
+                    .endControlFlow();
         }
     }
 
@@ -300,6 +310,8 @@ void emitTypeConversion(String interfaceName, String setter, String fieldName, S
                 writer) throws IOException;
         void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
                                       JavaWriter writer) throws IOException;
-        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException;
+        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                              String qualifiedRealmObjectProxyClass,
+                                              String fieldName, JavaWriter writer) throws IOException;
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index c9959299f4..1e437f8bcf 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -23,7 +23,6 @@
 import java.util.TreeSet;
 
 import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.lang.model.SourceVersion;
@@ -54,7 +53,7 @@
  * <ol>
  *  <li>Create proxy classes for all classes marked with @RealmClass. They are named &lt;className&gt;RealmProxy.java</li>
  *  <li>Create a DefaultRealmModule containing all RealmObject classes (if needed).</li>
- *  <li>Create a RealmProxyMediator class for all classes marked with @RealmModule. They are named <moduleName>Mediator.java</li>
+ *  <li>Create a RealmProxyMediator class for all classes marked with {@code @RealmModule}. They are named {@code <moduleName>Mediator.java}</li>
  * </ol>
  *
  * <h1>WHY</h1>
@@ -68,7 +67,7 @@
  * annotated with @RealmModule(library = true). It is not allowed to have both a class with library = true and
  * library = false in the same IntelliJ module and it will cause the annotation processor to throw an exception. If no
  * library modules are defined, we will create a DefaultRealmModule containing all known RealmObjects and with the
- * @RealmModule annotation. Realm automatically knows about this module, but it is still possible for users to create
+ * {@code @RealmModule} annotation. Realm automatically knows about this module, but it is still possible for users to create
  * their own modules with a subset of model classes.</li>
  *
  * <li>For each class annotated with @RealmModule a matching Mediator class is created (including the default one). This
@@ -102,6 +101,9 @@
 })
 public class RealmProcessor extends AbstractProcessor {
 
+    // Don't consume annotations. This allows 3rd party annotation processors to run.
+    private static final boolean CONSUME_ANNOTATIONS = false;
+
     Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
     private boolean hasProcessedModules = false;
 
@@ -111,8 +113,9 @@
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        // Don't run this processor in subsequent runs. We created everything in the first one.
         if (hasProcessedModules) {
-            return true;
+            return CONSUME_ANNOTATIONS;
         }
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
@@ -165,7 +168,9 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         }
 
         hasProcessedModules = true;
-        return processModules(roundEnv);
+        processModules(roundEnv);
+
+        return CONSUME_ANNOTATIONS;
     }
 
     // Returns true if modules was processed successfully, false otherwise
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 420cdcef2c..a8609582d5 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -36,18 +36,22 @@
 public class RealmProxyClassGenerator {
     private ProcessingEnvironment processingEnvironment;
     private ClassMetaData metadata;
-    private final String className;
+    private final String simpleClassName;
+    private final String qualifiedClassName;
     private final String interfaceName;
+    private final String qualifiedGeneratedClassName;
 
     public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
         this.metadata = metadata;
-        this.className = metadata.getSimpleClassName();
-        this.interfaceName = Utils.getProxyInterfaceName(className);
+        this.simpleClassName = metadata.getSimpleClassName();
+        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
+        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
+        this.qualifiedGeneratedClassName = String.format("%s.%s",
+                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));
     }
 
     public void generate() throws IOException, UnsupportedOperationException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
@@ -69,32 +73,18 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.ImplicitTransaction");
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
-        imports.add("io.realm.internal.Row");
         imports.add("java.io.IOException");
         imports.add("java.util.ArrayList");
         imports.add("java.util.Collections");
         imports.add("java.util.List");
+        imports.add("java.util.Iterator");
         imports.add("java.util.Date");
         imports.add("java.util.Map");
         imports.add("java.util.HashMap");
         imports.add("org.json.JSONObject");
         imports.add("org.json.JSONException");
         imports.add("org.json.JSONArray");
-        imports.add("java.util.concurrent.Future");
 
-        imports.add(metadata.getFullyQualifiedClassName());
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldTypeName = "";
-            if (Utils.isRealmModel(field)) { // Links
-                fieldTypeName = field.asType().toString();
-            } else if (Utils.isRealmList(field)) { // LinkLists
-                fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
-            }
-            if (!fieldTypeName.isEmpty() && !imports.contains(fieldTypeName)) {
-                imports.add(fieldTypeName);
-            }
-        }
         Collections.sort(imports);
         writer.emitImports(imports);
         writer.emitEmptyLine();
@@ -104,7 +94,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 qualifiedGeneratedClassName, // full qualified name of the item to generate
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                className,                   // class to extend
+                qualifiedClassName,          // class to extend
                 "RealmObjectProxy",          // interfaces to implement
                 interfaceName)
                 .emitEmptyLine();
@@ -122,6 +112,10 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
+        emitInsertMethod(writer);
+        emitInsertListMethod(writer);
+        emitInsertOrUpdateMethod(writer);
+        emitInsertOrUpdateListMethod(writer);
         emitCreateDetachedCopyMethod(writer);
         emitUpdateMethod(writer);
         emitToStringMethod(writer);
@@ -159,7 +153,7 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
             final String columnName = variableElement.getSimpleName().toString();
             final String columnIndexVarName = columnIndexVarName(variableElement);
             writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
-                    columnIndexVarName, className, columnName);
+                    columnIndexVarName, simpleClassName, columnName);
             writer.emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
             writer.emitEmptyLine();
         }
@@ -176,7 +170,7 @@ private void emitClassFields(JavaWriter writer) throws IOException {
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
-                String genericType = Utils.getGenericType(variableElement);
+                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                 writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
             }
         }
@@ -196,7 +190,7 @@ private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
         writer.beginConstructor(EnumSet.noneOf(Modifier.class), "ColumnInfo", "columnInfo");
         writer.emitStatement("this.columnInfo = (%s) columnInfo", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState(%s.class)", className);
+        writer.emitStatement("this.proxyState = new ProxyState(%s.class, this)", qualifiedClassName);
         writer.endConstructor();
         writer.emitEmptyLine();
     }
@@ -294,7 +288,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 /**
                  * LinkLists
                  */
-                String genericType = Utils.getGenericType(field);
+                String genericType = Utils.getGenericTypeQualifiedName(field);
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
@@ -332,7 +326,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.endMethod();
             } else {
                 throw new UnsupportedOperationException(
-                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
+                        String.format("Type '%s' of field '%s' is not supported", fieldTypeCanonicalName, fieldName));
             }
             writer.emitEmptyLine();
         }
@@ -353,8 +347,8 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if (!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if (!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
@@ -379,12 +373,12 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", transaction.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
-                String genericType = Utils.getGenericType(field);
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
-                writer.emitStatement("%s%s.initTable(transaction)", genericType, Constants.PROXY_SUFFIX);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("%s.initTable(transaction)", Utils.getProxyClassName(genericTypeSimpleName));
                 writer.endControlFlow();
                 writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", transaction.getTable(\"%s%s\"))",
-                        fieldName, Constants.TABLE_PREFIX, genericType);
+                        fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
             }
         }
 
@@ -402,7 +396,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("return table");
         writer.endControlFlow();
-        writer.emitStatement("return transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.emitStatement("return transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -414,8 +408,8 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if (transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if (transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // verify number of columns
         writer.beginControlFlow("if (table.getColumnCount() != " + metadata.getFields().size() + ")");
@@ -438,10 +432,10 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         long fieldIndex = 0;
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
+            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                 // make sure types align
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
@@ -449,7 +443,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                         "\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
-                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
+                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
@@ -464,7 +458,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                                 "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                                 fieldName);
                     // nullability check for boxed types
-                    } else if (Utils.isBoxedType(fieldTypeCanonicalName)) {
+                    } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
                         writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
                                 "\"Field '%s' does not support null values in the existing Realm file. " +
                                 "Either set @Required, use the primitive type for field '%s' " +
@@ -489,7 +483,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                             .endControlFlow();
                     } else {
                         writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                        if (Utils.isPrimitiveType(fieldTypeCanonicalName)) {
+                        if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
                             writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
                                     " \"Field '%s' does support null values in the existing Realm file. " +
                                     "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
@@ -540,20 +534,20 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                         fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             } else if (Utils.isRealmList(field)) { // Link Lists
-                String genericType = Utils.getGenericType(field);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
-                        genericType, fieldName);
+                        genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
-                        Constants.TABLE_PREFIX, genericType, fieldName);
+                        Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
-                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericType);
+                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
                 writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                         fieldIndexVariableReference(field), fieldIndex);
                 writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
@@ -566,7 +560,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("return %s", "columnInfo");
 
         writer.nextControlFlow("else");
-        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
+        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The '%s' class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -574,7 +568,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 
     private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, className);
+        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName);
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -588,10 +582,10 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
 
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
+                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
         writer
@@ -606,164 +600,631 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return object")
             .endControlFlow();
 
-        if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("return copy(realm, object, update, cache)");
-        } else {
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
+        writer.beginControlFlow("if (cachedRealmObject != null)")
+                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                .nextControlFlow("else");
+
+            if (!metadata.hasPrimaryKey()) {
+                writer.emitStatement("return copy(realm, object, update, cache)");
+            } else {
+                writer
+                    .emitStatement("%s realmObject = null", qualifiedClassName)
+                    .emitStatement("boolean canUpdate = update")
+                    .beginControlFlow("if (canUpdate)")
+                        .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                        .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+
+                String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+                VariableElement primaryKeyElement = metadata.getPrimaryKey();
+                if (metadata.isNullable(primaryKeyElement)) {
+                    if (Utils.isString(primaryKeyElement)) {
+                        writer
+                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                            .endControlFlow();
+                    } else {
+                        writer
+                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                            .endControlFlow();
+                    }
+                } else {
+                    String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                    writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                            pkType, interfaceName, primaryKeyGetter);
+                }
+
+                writer
+                    .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                        .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
+                                qualifiedGeneratedClassName,
+                                qualifiedClassName)
+                        .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm)")
+                        .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
+                        .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                    .nextControlFlow("else")
+                        .emitStatement("canUpdate = false")
+                    .endControlFlow();
+
+                writer.endControlFlow();
+
+                writer
+                    .emitEmptyLine()
+                    .beginControlFlow("if (canUpdate)")
+                        .emitStatement("return update(realm, realmObject, object, cache)")
+                    .nextControlFlow("else")
+                        .emitStatement("return copy(realm, object, update, cache)")
+                    .endControlFlow();
+            }
+
+        writer.endControlFlow();
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
+        if ("long".equals(fieldType)
+                || "int".equals(fieldType)
+                || "short".equals(fieldType)
+                || "byte".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Long".equals(fieldType)
+                || "java.lang.Integer".equals(fieldType)
+                || "java.lang.Short".equals(fieldType)
+                || "java.lang.Byte".equals(fieldType)) {
+            writer
+                    .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue())", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("double".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if("java.lang.Double".equals(fieldType)) {
+            writer
+                    .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("float".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Float".equals(fieldType)) {
+            writer
+                    .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("boolean".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Boolean".equals(fieldType)) {
+            writer
+                    .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("byte[]".equals(fieldType)) {
+            writer
+                    .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+
+        } else if ("java.util.Date".equals(fieldType)) {
+            writer
+                    .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime())", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("java.lang.String".equals(fieldType)) {
             writer
-                .emitStatement("%s realmObject = null", className)
-                .emitStatement("boolean canUpdate = update")
-                .beginControlFlow("if (canUpdate)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", className)
-                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+                    .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+        } else {
+            throw new IllegalStateException("Unsupported type " + fieldType);
+        }
+    }
+
+    private void emitInsertMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "long", // Return type
+                "insert", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        }
+        addPrimaryKeyCheckIfNeeeded(metadata, true, writer);
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                            .endControlFlow()
+                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                             .endControlFlow()
+                             .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
+                            .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
+                }
+            }
+        }
+
+        writer.emitStatement("return rowIndex");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertListMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "void", // Return type
+                "insert", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        }
+        writer.emitStatement("%s object = null", qualifiedClassName);
+
+        writer.beginControlFlow("while (objects.hasNext())");
+        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.beginControlFlow("if(!cache.containsKey(object))");
+
+        addPrimaryKeyCheckIfNeeeded(metadata, true, writer);
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                         .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                                .endControlFlow()
+                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                          .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                             .endControlFlow()
+                                .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                          .endControlFlow()
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
+                }
+            }
+        }
 
+        writer.endControlFlow();
+        writer.endControlFlow();
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void addPrimaryKeyCheckIfNeeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
+        if (metadata.hasPrimaryKey()) {
             String primaryKeyGetter = metadata.getPrimaryKeyGetter();
             VariableElement primaryKeyElement = metadata.getPrimaryKey();
             if (metadata.isNullable(primaryKeyElement)) {
                 if (Utils.isString(primaryKeyElement)) {
                     writer
-                        .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                         .emitStatement("long rowIndex = TableOrView.NO_MATCH")
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                        .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                         .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
                         .endControlFlow();
                 } else {
                     writer
-                        .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                         .emitStatement("long rowIndex = TableOrView.NO_MATCH")
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                        .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                         .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
                         .endControlFlow();
                 }
             } else {
-                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
-                        pkType, interfaceName, primaryKeyGetter);
+                writer.emitStatement("long rowIndex = TableOrView.NO_MATCH");
+                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
+                writer.beginControlFlow("if (primaryKeyValue != null)");
+
+                if (Utils.isString(metadata.getPrimaryKey())) {
+                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
+                } else {
+                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
+                }
+                writer.endControlFlow();
             }
 
-            writer
-                .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                    .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
-                            Utils.getProxyClassName(className),
-                            className)
-                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm)")
-                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
-                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
-                .nextControlFlow("else")
-                    .emitStatement("canUpdate = false")
-                .endControlFlow();
+            writer.beginControlFlow("if (rowIndex == TableOrView.NO_MATCH)");
+            writer.emitStatement("rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1)");
+            if (Utils.isString(metadata.getPrimaryKey())) {
+                writer.beginControlFlow("if (primaryKeyValue != null)");
+                writer.emitStatement("Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue)");
+                writer.endControlFlow();
+            } else {
+                writer.beginControlFlow("if (primaryKeyValue != null)");
+                writer.emitStatement("Table.nativeSetLong(tableNativePtr, pkColumnIndex, rowIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
+                writer.endControlFlow();
+            }
+
+            if (throwIfPrimaryKeyDuplicate) {
+                writer.nextControlFlow("else");
+                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
+            }
 
             writer.endControlFlow();
+            writer.emitStatement("cache.put(object, rowIndex)");
+        } else {
+            writer.emitStatement("long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1)");
+            writer.emitStatement("cache.put(object, rowIndex)");
+        }
+    }
 
-            writer
-                .emitEmptyLine()
-                .beginControlFlow("if (canUpdate)")
-                    .emitStatement("return update(realm, realmObject, object, cache)")
-                .nextControlFlow("else")
-                    .emitStatement("return copy(realm, object, update, cache)")
-                .endControlFlow();
+    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "long", // Return type
+                "insertOrUpdate", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        }
+        addPrimaryKeyCheckIfNeeeded(metadata, false, writer);
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .nextControlFlow("else")
+                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
+                                .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
+                        .endControlFlow()
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
+                }
+            }
         }
 
+        writer.emitStatement("return rowIndex");
+
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitCopyMethod(JavaWriter writer) throws IOException {
+    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
-                "copy", // Method name
+                "void", // Return type
+                "insertOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
 
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
-                    className, className, interfaceName, metadata.getPrimaryKeyGetter());
-        } else {
-            writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
         }
-        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
+        writer.emitStatement("%s object = null", qualifiedClassName);
+
+        writer.beginControlFlow("while (objects.hasNext())");
+        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.beginControlFlow("if(!cache.containsKey(object))");
+
+        addPrimaryKeyCheckIfNeeeded(metadata, false, writer);
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                        .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field))
+                                    .endControlFlow()
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                    interfaceName,
-                                    setter,
-                                    Utils.getProxyClassSimpleName(field),
-                                    fieldName)
-                        .endControlFlow()
-                    .nextControlFlow("else")
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
-                    .endControlFlow();
+                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        .endControlFlow();
             } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                    .emitEmptyLine()
-                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                                Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
-                                .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
-                                .beginControlFlow("if (cache%s != null)", fieldName)
-                                        .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
-                                .nextControlFlow("else")
-                                        .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                        .emitEmptyLine()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                                 .endControlFlow()
+                            .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
                         .endControlFlow()
-                    .endControlFlow()
-                    .emitEmptyLine();
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .emitEmptyLine();
 
             } else {
-                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
-                        interfaceName, setter, interfaceName, getter);
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
+                }
             }
         }
+            writer.endControlFlow();
+        writer.endControlFlow();
 
-        writer.emitStatement("return realmObject");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitCopyMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                qualifiedClassName, // Return type
+                "copy", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
+        writer.beginControlFlow("if (cachedRealmObject != null)")
+              .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+              .nextControlFlow("else");
+
+            if (metadata.hasPrimaryKey()) {
+                writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
+                        qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
+            } else {
+                writer.emitStatement("%s realmObject = realm.createObject(%s.class)", qualifiedClassName, qualifiedClassName);
+            }
+            writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
+            for (VariableElement field : metadata.getFields()) {
+                String fieldName = field.getSimpleName().toString();
+                String fieldType = field.asType().toString();
+                String setter = metadata.getSetter(fieldName);
+                String getter = metadata.getGetter(fieldName);
+
+                if (Utils.isRealmModel(field)) {
+                    writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                            .beginControlFlow("if (cache%s != null)", fieldName)
+                                .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                            .nextControlFlow("else")
+                                .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
+                                        interfaceName,
+                                        setter,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                            .endControlFlow()
+                        .nextControlFlow("else")
+                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
+                        .endControlFlow();
+                } else if (Utils.isRealmList(field)) {
+                    final String genericType = Utils.getGenericTypeQualifiedName(field);
+                    writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                                    genericType, fieldName, interfaceName, getter)
+                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                    .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                                    .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
+                                    .beginControlFlow("if (cache%s != null)", fieldName)
+                                            .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
+                                    .nextControlFlow("else")
+                                            .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                                    .endControlFlow()
+                            .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+                } else {
+                    writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
+                            interfaceName, setter, interfaceName, getter);
+                }
+            }
+
+            writer.emitStatement("return realmObject");
+          writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
     private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "createDetachedCopy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                className, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
+                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
             .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
             .endControlFlow()
             .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s standaloneObject", className)
+            .emitStatement("%s unmanagedObject", qualifiedClassName)
             .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                    .emitStatement("return (%s)cachedObject.object", className)
+                    .emitStatement("return (%s)cachedObject.object", qualifiedClassName)
                 .nextControlFlow("else")
-                    .emitStatement("standaloneObject = (%s)cachedObject.object", className)
+                    .emitStatement("unmanagedObject = (%s)cachedObject.object", qualifiedClassName)
                     .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
             .nextControlFlow("else")
-                .emitStatement("standaloneObject = new %s()", className)
-                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject))")
+                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
+                .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject))")
             .endControlFlow();
 
         for (VariableElement field : metadata.getFields()) {
@@ -775,34 +1236,34 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .emitStatement("((%s) standaloneObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
+                    .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
                                 interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
             } else if (Utils.isRealmList(field)) {
                 writer
                     .emitEmptyLine()
                     .emitSingleLineComment("Deep copy of %s", fieldName)
                     .beginControlFlow("if (currentDepth == maxDepth)")
-                        .emitStatement("((%s) standaloneObject).%s(null)", interfaceName, setter)
+                        .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
                     .nextControlFlow("else")
                         .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
-                                Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .emitStatement("RealmList<%1$s> standalone%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
-                        .emitStatement("((%s) standaloneObject).%s(standalone%sList)", interfaceName, setter, fieldName)
+                                 Utils.getGenericTypeQualifiedName(field), fieldName, interfaceName, getter)
+                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
+                        .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
                             .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
-                                    Utils.getGenericType(field), Utils.getProxyClassSimpleName(field), fieldName)
-                            .emitStatement("standalone%sList.add(item)", fieldName)
+                                    Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
+                            .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                     .endControlFlow();
             } else {
-                writer.emitStatement("((%s) standaloneObject).%s(((%s) realmObject).%s())",
+                writer.emitStatement("((%s) unmanagedObject).%s(((%s) realmObject).%s())",
                         interfaceName, setter, interfaceName, getter);
             }
         }
 
-        writer.emitStatement("return standaloneObject");
+        writer.emitStatement("return unmanagedObject");
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -813,10 +1274,10 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
         }
 
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -825,9 +1286,9 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             if (Utils.isRealmModel(field)) {
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
-                            Utils.getFieldTypeSimpleName(field), fieldName, interfaceName, getter)
+                            Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
                     .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
+                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeQualifiedName(field), fieldName, Utils.getFieldTypeQualifiedName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
                             .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
                         .nextControlFlow("else")
@@ -835,8 +1296,7 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                                     interfaceName,
                                     setter,
                                     Utils.getProxyClassSimpleName(field),
-                                    fieldName,
-                                    Utils.getFieldTypeSimpleName(field)
+                                    fieldName
                             )
                         .endControlFlow()
                     .nextControlFlow("else")
@@ -844,16 +1304,17 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                     .endControlFlow();
             } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                     .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
+                            genericType, fieldName, interfaceName, getter)
                     .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
+                            genericType, fieldName, interfaceName, getter)
                     .emitStatement("%sRealmList.clear()", fieldName)
                     .beginControlFlow("if (%sList != null)", fieldName)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
-                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
+                            .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
                             .beginControlFlow("if (cache%s != null)", fieldName)
                                 .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
                             .nextControlFlow("else")
@@ -885,7 +1346,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         writer.beginControlFlow("if (!RealmObject.isValid(this))");
         writer.emitStatement("return \"Invalid object\"");
         writer.endControlFlow();
-        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
+        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", simpleClassName);
         List<VariableElement> fields = metadata.getFields();
         for (int i = 0; i < fields.size(); i++) {
             VariableElement field = fields.get(i);
@@ -900,9 +1361,9 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                         fieldTypeSimpleName
                 );
             } else if (Utils.isRealmList(field)) {
-                String genericType = Utils.getGenericType(field);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
-                        genericType,
+                        genericTypeSimpleName,
                         metadata.getGetter(fieldName));
             } else {
                 if (metadata.isNullable(field)) {
@@ -927,6 +1388,11 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
+    /**
+     * Currently, the hash value emitted from this could suddenly change as an object's index might
+     * alternate due to Realm Java using {@code Table#moveLastOver()}. Hash codes should therefore not
+     * be considered stable, i.e. don't save them in a HashSet or use them as a key in a HashMap.
+     */
     private void emitHashcodeMethod(JavaWriter writer) throws IOException {
         if (metadata.containsHashCode()) {
             return;
@@ -950,22 +1416,23 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         if (metadata.containsEquals()) {
             return;
         }
-        String proxyClassName = className + Constants.PROXY_SUFFIX;
+        String proxyClassName = Utils.getProxyClassName(simpleClassName);
+        String otherObjectVarName = "a" + simpleClassName;
         writer.emitAnnotation("Override");
         writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
         writer.emitStatement("if (this == o) return true");
         writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
-        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
+        writer.emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
         writer.emitEmptyLine();
         writer.emitStatement("String path = proxyState.getRealm$realm().getPath()");
-        writer.emitStatement("String otherPath = a%s.proxyState.getRealm$realm().getPath()", className);
+        writer.emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName);
         writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
         writer.emitEmptyLine();
         writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
-        writer.emitStatement("String otherTableName = a%s.proxyState.getRow$realm().getTable().getName()", className);
+        writer.emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName);
         writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
         writer.emitEmptyLine();
-        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != a%s.proxyState.getRow$realm().getIndex()) return false", className);
+        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName);
         writer.emitEmptyLine();
         writer.emitStatement("return true");
         writer.endMethod();
@@ -976,20 +1443,20 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
-                className,
+                qualifiedClassName,
                 "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Collections.singletonList("JSONException"));
 
         if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s obj = realm.createObject(%s.class)", className, className);
+            writer.emitStatement("%s obj = realm.createObject(%s.class)", qualifiedClassName, qualifiedClassName);
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
-                .emitStatement("%s obj = null", className)
+                .emitStatement("%s obj = null", qualifiedClassName)
                 .beginControlFlow("if (update)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", className)
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                     .emitStatement("long rowIndex = TableOrView.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
@@ -1010,7 +1477,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             writer
                     .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
                         .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
-                                Utils.getProxyClassName(className), className)
+                                qualifiedGeneratedClassName, qualifiedClassName)
                         .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm)")
                         .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
                     .endControlFlow()
@@ -1019,7 +1486,8 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             writer.beginControlFlow("if (obj == null)");
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(className, primaryKeyFieldType, primaryKeyFieldName, writer);
+            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedClassName, qualifiedGeneratedClassName,
+                    primaryKeyFieldType, primaryKeyFieldName, writer);
             writer.endControlFlow();
         }
 
@@ -1065,13 +1533,13 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
     private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
-                className,
+                qualifiedClassName,
                 "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                 Collections.singletonList("IOException"));
 
-        writer.emitStatement("%s obj = realm.createObject(%s.class)",className, className);
+        writer.emitStatement("%s obj = realm.createObject(%s.class)",qualifiedClassName, qualifiedClassName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
@@ -1130,7 +1598,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
     }
 
     private String columnInfoClassName() {
-        return className + "ColumnInfo";
+        return simpleClassName + "ColumnInfo";
     }
 
     private String columnIndexVarName(VariableElement variableElement) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 7a963457c5..5a59cd66c0 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -33,14 +33,13 @@
 
 import io.realm.annotations.RealmModule;
 
+import static io.realm.processor.Constants.REALM_PACKAGE_NAME;
+
 public class RealmProxyMediatorGenerator {
     private final String className;
     private ProcessingEnvironment processingEnvironment;
     private List<String> qualifiedModelClasses = new ArrayList<String>();
-    private List<String> simpleModelClasses = new ArrayList<String>();
-    private List<String> proxyClasses = new ArrayList<String>();
-
-    private static final String REALM_PACKAGE_NAME = "io.realm";
+    private List<String> qualifiedProxyClasses = new ArrayList<String>();
 
     public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
                                        String className, Set<ClassMetaData> classesToValidate) {
@@ -50,8 +49,7 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
         for (ClassMetaData metadata : classesToValidate) {
             String simpleName = metadata.getSimpleClassName();
             qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
-            simpleModelClasses.add(simpleName);
-            proxyClasses.add(getProxyClassName(simpleName));
+            qualifiedProxyClasses.add(REALM_PACKAGE_NAME + "." + getProxyClassName(simpleName));
         }
     }
 
@@ -68,11 +66,13 @@ public void generate() throws IOException {
                 "android.util.JsonReader",
                 "java.io.IOException",
                 "java.util.Collections",
-                "java.util.HashMap",
                 "java.util.HashSet",
                 "java.util.List",
                 "java.util.Map",
+                "java.util.IdentityHashMap",
                 "java.util.Set",
+                "java.util.Iterator",
+                "java.util.Collection",
                 "io.realm.internal.ColumnInfo",
                 "io.realm.internal.ImplicitTransaction",
                 "io.realm.internal.RealmObjectProxy",
@@ -81,7 +81,6 @@ public void generate() throws IOException {
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
-        writer.emitImports(qualifiedModelClasses);
 
         writer.emitEmptyLine();
 
@@ -101,6 +100,10 @@ public void generate() throws IOException {
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
         emitCopyToRealmMethod(writer);
+        emitInsertObjectToRealmMethod(writer);
+        emitInsertListToRealmMethod(writer);
+        emitInsertOrUpdateObjectToRealmMethod(writer);
+        emitInsertOrUpdateListToRealmMethod(writer);
         emitCreteOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
         emitCreateDetachedCopyMethod(writer);
@@ -112,7 +115,7 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
         writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>()");
-        for (String clazz : simpleModelClasses) {
+        for (String clazz : qualifiedModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
         writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableSet(modelClasses)");
@@ -131,7 +134,7 @@ private void emitCreateTableMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.initTable(transaction)", proxyClasses.get(i));
+                writer.emitStatement("return %s.initTable(transaction)", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -149,7 +152,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.validateTable(transaction)", proxyClasses.get(i));
+                writer.emitStatement("return %s.validateTable(transaction)", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -167,7 +170,7 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getFieldNames()", proxyClasses.get(i));
+                writer.emitStatement("return %s.getFieldNames()", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -185,7 +188,7 @@ private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getTableName()", proxyClasses.get(i));
+                writer.emitStatement("return %s.getTableName()", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -203,7 +206,7 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(new %s(columnInfo))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(new %s(columnInfo))", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -233,13 +236,137 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", proxyClasses.get(i), simpleModelClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
             }
         }, writer, false);
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
+    private void emitInsertObjectToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insert",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "RealmModel", "object", "Map<RealmModel, Long>", "cache");
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateObjectToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insertOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "RealmModel", "obj", "Map<RealmModel, Long>", "cache");
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insertOrUpdate(realm, (%s) obj, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateListToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insertOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
+
+        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
+        writer.emitStatement("RealmModel object = null");
+        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+
+        writer.beginControlFlow("if (iterator.hasNext())")
+                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                .emitStatement("object = iterator.next()")
+                .emitSingleLineComment("This cast is correct because obj is either")
+                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                .emitEmptyLine();
+
+                emitMediatorSwitch(new ProxySwitchStatement() {
+                    @Override
+                    public void emitStatement(int i, JavaWriter writer) throws IOException {
+                        writer.emitStatement("%s.insertOrUpdate(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+                    }
+                }, writer, false);
+
+                writer.beginControlFlow("if (iterator.hasNext())");
+                emitMediatorSwitch(new ProxySwitchStatement() {
+                    @Override
+                    public void emitStatement(int i, JavaWriter writer) throws IOException {
+                        writer.emitStatement("%s.insertOrUpdate(realm, iterator, cache)", qualifiedProxyClasses.get(i));
+                    }
+                }, writer, false);
+                writer.endControlFlow();
+        writer.endControlFlow();
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertListToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insert",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
+
+        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
+        writer.emitStatement("RealmModel object = null");
+        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+
+        writer.beginControlFlow("if (iterator.hasNext())")
+                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                .emitStatement("object = iterator.next()")
+                .emitSingleLineComment("This cast is correct because obj is either")
+                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                .emitEmptyLine();
+
+                emitMediatorSwitch(new ProxySwitchStatement() {
+                    @Override
+                    public void emitStatement(int i, JavaWriter writer) throws IOException {
+                        writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+                    }
+                }, writer, false);
+
+            writer.beginControlFlow("if (iterator.hasNext())");
+            emitMediatorSwitch(new ProxySwitchStatement() {
+                @Override
+                public void emitStatement(int i, JavaWriter writer) throws IOException {
+                    writer.emitStatement("%s.insert(realm, iterator, cache)", qualifiedProxyClasses.get(i));
+                }
+            }, writer, false);
+            writer.endControlFlow();
+        writer.endControlFlow();
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
     private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
@@ -252,7 +379,7 @@ private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcept
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -271,7 +398,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -294,7 +421,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
-                        proxyClasses.get(i), simpleModelClasses.get(i));
+                        qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
             }
         }, writer, false);
         writer.endMethod();
@@ -314,13 +441,13 @@ private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter write
             writer.emitStatement("checkClass(clazz)");
             writer.emitEmptyLine();
         }
-        if (simpleModelClasses.size() == 0) {
+        if (qualifiedModelClasses.size() == 0) {
             writer.emitStatement("throw getMissingProxyClassException(clazz)");
         } else {
-            writer.beginControlFlow("if (clazz.equals(%s.class))", simpleModelClasses.get(0));
+            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(0));
             statement.emitStatement(0, writer);
-            for (int i = 1; i < simpleModelClasses.size(); i++) {
-                writer.nextControlFlow("else if (clazz.equals(%s.class))", simpleModelClasses.get(i));
+            for (int i = 1; i < qualifiedModelClasses.size(); i++) {
+                writer.nextControlFlow("else if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
                 statement.emitStatement(i, writer);
             }
             writer.nextControlFlow("else");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 8f0dd71b41..9ed30c70eb 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -50,7 +50,7 @@ public static String lowerFirstChar(String input) {
 
     public static String getProxyClassSimpleName(VariableElement field) {
         if (typeUtils.isAssignable(field.asType(), realmList)) {
-            return getProxyClassName(getGenericType(field));
+            return getProxyClassName(getGenericTypeSimpleName(field));
         } else {
             return getProxyClassName(getFieldTypeSimpleName(field));
         }
@@ -156,37 +156,48 @@ public static boolean isRealmModel(VariableElement field) {
     }
 
 
+    /**
+     * @return the qualified type name for a field.
+     */
+    public static String getFieldTypeQualifiedName(VariableElement field) {
+        return field.asType().toString();
+    }
+
     /**
      * @return the simple type name for a field.
      */
     public static String getFieldTypeSimpleName(VariableElement field) {
-        String fieldTypeCanonicalName = field.asType().toString();
-        String fieldTypeName;
-        if (fieldTypeCanonicalName.contains(".")) {
-            fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
-        } else {
-            fieldTypeName = fieldTypeCanonicalName;
+        String fieldTypeQualifiedName = getFieldTypeQualifiedName(field);
+        if (!fieldTypeQualifiedName.contains(".")) {
+            return fieldTypeQualifiedName;
         }
-        return fieldTypeName;
+        return fieldTypeQualifiedName.substring(fieldTypeQualifiedName.lastIndexOf('.') + 1);
     }
 
     /**
      * @return the generic type for Lists of the form {@code List<type>}
      */
-    public static String getGenericType(VariableElement field) {
+    public static String getGenericTypeQualifiedName(VariableElement field) {
         TypeMirror fieldType = field.asType();
         List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
         if (typeArguments.size() == 0) {
             return null;
         }
-        String genericCanonicalType = (String) typeArguments.get(0).toString();
-        String genericType;
-        if (genericCanonicalType.contains(".")) {
-            genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
-        } else {
-            genericType = genericCanonicalType;
+        return typeArguments.get(0).toString();
+    }
+
+    /**
+     * @return the generic type for Lists of the form {@code List<type>}
+     */
+    public static String getGenericTypeSimpleName(VariableElement field) {
+        final String genericTypeName = getGenericTypeQualifiedName(field);
+        if (genericTypeName == null) {
+            return null;
+        }
+        if (!genericTypeName.contains(".")) {
+            return genericTypeName;
         }
-        return genericType;
+        return genericTypeName.substring(genericTypeName.lastIndexOf('.') + 1);
     }
 
     /**
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index 7bea9166ea..d7eff132bd 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -55,6 +55,7 @@
     private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
     private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
     private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
+    private JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
 
     @Test
     public void compileSimpleFile() {
@@ -443,4 +444,20 @@ public void compileWithRealmModelFieldInReamlModel() {
                 .processedWith(new RealmProcessor())
                 .compilesWithoutError();
     }
+
+    @Test
+    public void compileWithInterfaceForList() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceList.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+
+    @Test
+    public void compileWithInterfaceForObject() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(JavaFileObjects.forResource("some/test/InterfaceObjectReference.java"), customInterface))
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index a2a7452537..ff1ef29209 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -9,7 +9,6 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -18,15 +17,14 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.AllTypes;
 
-public class AllTypesRealmProxy extends AllTypes
+public class AllTypesRealmProxy extends some.test.AllTypes
         implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
     static final class AllTypesColumnInfo extends ColumnInfo {
@@ -76,7 +74,7 @@
 
     private final AllTypesColumnInfo columnInfo;
     private final ProxyState proxyState;
-    private RealmList<AllTypes> columnRealmListRealmList;
+    private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -94,7 +92,7 @@
 
     AllTypesRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (AllTypesColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(AllTypes.class);
+        this.proxyState = new ProxyState(some.test.AllTypes.class, this);
     }
 
     @SuppressWarnings("cast")
@@ -165,7 +163,7 @@
     public void realmSet$columnDate(Date value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field columnDate to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
         }
         proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
     }
@@ -179,12 +177,12 @@
     public void realmSet$columnBinary(byte[] value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field columnBinary to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
         }
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
-    public AllTypes realmGet$columnObject() {
+    public some.test.AllTypes realmGet$columnObject() {
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
             return null;
@@ -192,7 +190,7 @@
         return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex));
     }
 
-    public void realmSet$columnObject(AllTypes value) {
+    public void realmSet$columnObject(some.test.AllTypes value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
@@ -207,19 +205,19 @@
         proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public RealmList<AllTypes> realmGet$columnRealmList() {
+    public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
         proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
         if (columnRealmListRealmList != null) {
             return columnRealmListRealmList;
         } else {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
-            columnRealmListRealmList = new RealmList<AllTypes>(AllTypes.class, linkView, proxyState.getRealm$realm());
+            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
             return columnRealmListRealmList;
         }
     }
 
-    public void realmSet$columnRealmList(RealmList<AllTypes> value) {
+    public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
         proxyState.getRealm$realm().checkIfValid();
         LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
         links.clear();
@@ -372,7 +370,7 @@ public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction)
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The AllTypes class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -385,11 +383,11 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        AllTypes obj = null;
+        some.test.AllTypes obj = null;
         if (update) {
-            Table table = realm.getTable(AllTypes.class);
+            Table table = realm.getTable(some.test.AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
             long rowIndex = TableOrView.NO_MATCH;
             if (json.isNull("columnString")) {
@@ -398,7 +396,7 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
                 rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
             }
             if (rowIndex != TableOrView.NO_MATCH) {
-                obj = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
+                obj = new io.realm.AllTypesRealmProxy(realm.schema.getColumnInfo(some.test.AllTypes.class));
                 ((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm);
                 ((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
             }
@@ -406,12 +404,12 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
         if (obj == null) {
             if (json.has("columnString")) {
                 if (json.isNull("columnString")) {
-                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, null);
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class, null);
                 } else {
-                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, json.getString("columnString"));
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class, json.getString("columnString"));
                 }
             } else {
-                obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class);
+                obj = (io.realm.AllTypesRealmProxy) realm.createObject(some.test.AllTypes.class);
             }
         }
         if (json.has("columnString")) {
@@ -423,28 +421,28 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
         }
         if (json.has("columnLong")) {
             if (json.isNull("columnLong")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) json.getLong("columnLong"));
             }
         }
         if (json.has("columnFloat")) {
             if (json.isNull("columnFloat")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) json.getDouble("columnFloat"));
             }
         }
         if (json.has("columnDouble")) {
             if (json.isNull("columnDouble")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) json.getDouble("columnDouble"));
             }
         }
         if (json.has("columnBoolean")) {
             if (json.isNull("columnBoolean")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
             }
@@ -492,9 +490,9 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
     }
 
     @SuppressWarnings("cast")
-    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
+    public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        AllTypes obj = realm.createObject(AllTypes.class);
+        some.test.AllTypes obj = realm.createObject(some.test.AllTypes.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -508,28 +506,28 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             } else if (name.equals("columnLong")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) reader.nextLong());
                 }
             } else if (name.equals("columnFloat")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) reader.nextDouble());
                 }
             } else if (name.equals("columnDouble")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) reader.nextDouble());
                 }
             } else if (name.equals("columnBoolean")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) reader.nextBoolean());
                 }
@@ -580,138 +578,404 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        AllTypes realmObject = null;
-        boolean canUpdate = update;
-        if (canUpdate) {
-            Table table = realm.getTable(AllTypes.class);
-            long pkColumnIndex = table.getPrimaryKey();
-            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-            long rowIndex = TableOrView.NO_MATCH;
-            if (value == null) {
-                rowIndex = table.findFirstNull(pkColumnIndex);
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.AllTypes) cachedRealmObject;
+        } else {
+            some.test.AllTypes realmObject = null;
+            boolean canUpdate = update;
+            if (canUpdate) {
+                Table table = realm.getTable(some.test.AllTypes.class);
+                long pkColumnIndex = table.getPrimaryKey();
+                String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (value == null) {
+                    rowIndex = table.findFirstNull(pkColumnIndex);
+                } else {
+                    rowIndex = table.findFirstString(pkColumnIndex, value);
+                }
+                if (rowIndex != TableOrView.NO_MATCH) {
+                    realmObject = new io.realm.AllTypesRealmProxy(realm.schema.getColumnInfo(some.test.AllTypes.class));
+                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
+                    ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
+                    cache.put(object, (RealmObjectProxy) realmObject);
+                } else {
+                    canUpdate = false;
+                }
+            }
+
+            if (canUpdate) {
+                return update(realm, realmObject, object, cache);
             } else {
-                rowIndex = table.findFirstString(pkColumnIndex, value);
+                return copy(realm, object, update, cache);
             }
-            if (rowIndex != TableOrView.NO_MATCH) {
-                realmObject = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
-                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
-                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
-                cache.put(object, (RealmObjectProxy) realmObject);
+        }
+    }
+
+    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.AllTypes) cachedRealmObject;
+        } else {
+            some.test.AllTypes realmObject = realm.createObject(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+
+            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+            if (columnObjectObj != null) {
+                some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
+                if (cachecolumnObject != null) {
+                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
+                } else {
+                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+                }
             } else {
-                canUpdate = false;
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
             }
+
+            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+            if (columnRealmListList != null) {
+                RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+                for (int i = 0; i < columnRealmListList.size(); i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
+                    if (cachecolumnRealmList != null) {
+                        columnRealmListRealmList.add(cachecolumnRealmList);
+                    } else {
+                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
+                    }
+                }
+            }
+
+            return realmObject;
         }
+    }
 
-        if (canUpdate) {
-            return update(realm, realmObject, object, cache);
+    public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+        long rowIndex = TableOrView.NO_MATCH;
+        if (primaryKeyValue == null) {
+            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+        } else {
+            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+        }
+        if (rowIndex == TableOrView.NO_MATCH) {
+            rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+            if (primaryKeyValue != null) {
+                Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
+            }
         } else {
-            return copy(realm, object, update, cache);
+            Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
+        }
+        cache.put(object, rowIndex);
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        if (realmGet$columnDate != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+        }
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        if (realmGet$columnBinary != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+        }
+
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+        if (columnObjectObj != null) {
+            Long cachecolumnObject = cache.get(columnObjectObj);
+            if (cachecolumnObject == null) {
+                cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
         }
+
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+        if (columnRealmListList != null) {
+            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                if (cacheItemIndexcolumnRealmList == null) {
+                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
+                }
+                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+            }
+            LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+        }
+
+        return rowIndex;
     }
 
-    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        AllTypes realmObject = realm.createObject(AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        some.test.AllTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.AllTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (primaryKeyValue == null) {
+                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+                } else {
+                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+                }
+                if (rowIndex == TableOrView.NO_MATCH) {
+                    rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                    if (primaryKeyValue != null) {
+                        Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
+                    }
+                } else {
+                    Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
+                }
+                cache.put(object, rowIndex);
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+                if (realmGet$columnDate != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                }
+                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+                if (realmGet$columnBinary != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                }
 
-        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+                if (columnObjectObj != null) {
+                    Long cachecolumnObject = cache.get(columnObjectObj);
+                    if (cachecolumnObject == null) {
+                        cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
+                    }
+                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                }
+
+                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+                if (columnRealmListList != null) {
+                    long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                        if (cacheItemIndexcolumnRealmList == null) {
+                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
+                        }
+                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                    }
+                    LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+                }
+
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+        long rowIndex = TableOrView.NO_MATCH;
+        if (primaryKeyValue == null) {
+            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+        } else {
+            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+        }
+        if (rowIndex == TableOrView.NO_MATCH) {
+            rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+            if (primaryKeyValue != null) {
+                Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
+            }
+        }
+        cache.put(object, rowIndex);
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        if (realmGet$columnDate != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+        }
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        if (realmGet$columnBinary != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+        }
+
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
-            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
-            if (cachecolumnObject != null) {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
-            } else {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+            Long cachecolumnObject = cache.get(columnObjectObj);
+            if (cachecolumnObject == null) {
+                cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
             }
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
         } else {
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
+            Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
         }
 
-        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
         if (columnRealmListList != null) {
-            RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
-                if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
-                } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
+            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                if (cacheItemIndexcolumnRealmList == null) {
+                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                 }
+                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
             }
         }
+        LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
 
-        return realmObject;
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        some.test.AllTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.AllTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (primaryKeyValue == null) {
+                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+                } else {
+                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+                }
+                if (rowIndex == TableOrView.NO_MATCH) {
+                    rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                    if (primaryKeyValue != null) {
+                        Table.nativeSetString(tableNativePtr, pkColumnIndex, rowIndex, (String)primaryKeyValue);
+                    }
+                }
+                cache.put(object, rowIndex);
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+                if (realmGet$columnDate != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+                }
+                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+                if (realmGet$columnBinary != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+                }
+
+                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+                if (columnObjectObj != null) {
+                    Long cachecolumnObject = cache.get(columnObjectObj);
+                    if (cachecolumnObject == null) {
+                        cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
+                    }
+                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                } else {
+                    Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
+                }
+
+                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+                LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
+                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+                if (columnRealmListList != null) {
+                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                        if (cacheItemIndexcolumnRealmList == null) {
+                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
+                        }
+                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                    }
+                }
+                LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+
+            }
+        }
     }
 
-    public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.AllTypes createDetachedCopy(some.test.AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        AllTypes standaloneObject;
+        some.test.AllTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (AllTypes)cachedObject.object;
+                return (some.test.AllTypes)cachedObject.object;
             } else {
-                standaloneObject = (AllTypes)cachedObject.object;
+                unmanagedObject = (some.test.AllTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new some.test.AllTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
 
         // Deep copy of columnObject
-        ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
+        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
 
         // Deep copy of columnRealmList
         if (currentDepth == maxDepth) {
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(null);
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(null);
         } else {
-            RealmList<AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            RealmList<AllTypes> standalonecolumnRealmListList = new RealmList<AllTypes>();
-            ((AllTypesRealmProxyInterface) standaloneObject).realmSet$columnRealmList(standalonecolumnRealmListList);
+            RealmList<some.test.AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+            RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
+            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(unmanagedcolumnRealmListList);
             int nextDepth = currentDepth + 1;
             int size = managedcolumnRealmListList.size();
             for (int i = 0; i < size; i++) {
-                AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
-                standalonecolumnRealmListList.add(item);
+                some.test.AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
+                unmanagedcolumnRealmListList.add(item);
             }
         }
-        return standaloneObject;
+        return unmanagedObject;
     }
 
-    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
+    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
-        AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
         if (columnObjectObj != null) {
-            AllTypes cachecolumnObject = (AllTypes) cache.get(columnObjectObj);
+            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
             if (cachecolumnObject != null) {
                 ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
             } else {
@@ -720,13 +984,13 @@ static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Ma
         } else {
             ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
         }
-        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
-        RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
         columnRealmListRealmList.clear();
         if (columnRealmListList != null) {
             for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
+                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                 if (cachecolumnRealmList != null) {
                     columnRealmListRealmList.add(cachecolumnRealmList);
                 } else {
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 07bbbfb30a..503551e11b 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -9,7 +9,6 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -18,15 +17,14 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.Booleans;
 
-public class BooleansRealmProxy extends Booleans
+public class BooleansRealmProxy extends some.test.Booleans
         implements RealmObjectProxy, BooleansRealmProxyInterface {
 
     static final class BooleansColumnInfo extends ColumnInfo {
@@ -68,7 +66,7 @@
 
     BooleansRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (BooleansColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(Booleans.class);
+        this.proxyState = new ProxyState(some.test.Booleans.class, this);
     }
 
     @SuppressWarnings("cast")
@@ -179,7 +177,7 @@ public static BooleansColumnInfo validateTable(ImplicitTransaction transaction)
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Booleans class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
         }
     }
 
@@ -192,33 +190,33 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        Booleans obj = realm.createObject(Booleans.class);
+        some.test.Booleans obj = realm.createObject(some.test.Booleans.class);
         if (json.has("done")) {
             if (json.isNull("done")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) json.getBoolean("done"));
             }
         }
         if (json.has("isReady")) {
             if (json.isNull("isReady")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) json.getBoolean("isReady"));
             }
         }
         if (json.has("mCompleted")) {
             if (json.isNull("mCompleted")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
             }
         }
         if (json.has("anotherBoolean")) {
             if (json.isNull("anotherBoolean")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
             }
@@ -227,37 +225,37 @@ public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
     }
 
     @SuppressWarnings("cast")
-    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
+    public static some.test.Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        Booleans obj = realm.createObject(Booleans.class);
+        some.test.Booleans obj = realm.createObject(some.test.Booleans.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (name.equals("done")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("isReady")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("mCompleted")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("anotherBoolean")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) reader.nextBoolean());
                 }
@@ -269,49 +267,121 @@ public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Booleans copyOrUpdate(Realm realm, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.Booleans) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
+    }
+
+    public static some.test.Booleans copy(Realm realm, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.Booleans) cachedRealmObject;
+        } else {
+            some.test.Booleans realmObject = realm.createObject(some.test.Booleans.class);
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
+            return realmObject;
+        }
+    }
+
+    public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        return rowIndex;
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        Booleans realmObject = realm.createObject(Booleans.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
-        return realmObject;
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        some.test.Booleans object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Booleans) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        some.test.Booleans object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Booleans) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+            }
+        }
     }
 
-    public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.Booleans createDetachedCopy(some.test.Booleans realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Booleans standaloneObject;
+        some.test.Booleans unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (Booleans)cachedObject.object;
+                return (some.test.Booleans)cachedObject.object;
             } else {
-                standaloneObject = (Booleans)cachedObject.object;
+                unmanagedObject = (some.test.Booleans)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new some.test.Booleans();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) standaloneObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
-        return standaloneObject;
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
+        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
+        return unmanagedObject;
     }
 
     @Override
@@ -376,4 +446,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index f4aa0f5139..6725183ed0 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -9,7 +9,6 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -18,15 +17,14 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.NullTypes;
 
-public class NullTypesRealmProxy extends NullTypes
+public class NullTypesRealmProxy extends some.test.NullTypes
         implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
     static final class NullTypesColumnInfo extends ColumnInfo {
@@ -153,7 +151,7 @@
 
     NullTypesRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (NullTypesColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(NullTypes.class);
+        this.proxyState = new ProxyState(some.test.NullTypes.class, this);
     }
 
     @SuppressWarnings("cast")
@@ -165,7 +163,7 @@
     public void realmSet$fieldStringNotNull(String value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldStringNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldStringNotNull' to null.");
         }
         proxyState.getRow$realm().setString(columnInfo.fieldStringNotNullIndex, value);
     }
@@ -194,7 +192,7 @@
     public void realmSet$fieldBooleanNotNull(Boolean value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldBooleanNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBooleanNotNull' to null.");
         }
         proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
     }
@@ -226,7 +224,7 @@
     public void realmSet$fieldBytesNotNull(byte[] value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldBytesNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBytesNotNull' to null.");
         }
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
     }
@@ -255,7 +253,7 @@
     public void realmSet$fieldByteNotNull(Byte value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldByteNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldByteNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldByteNotNullIndex, value);
     }
@@ -287,7 +285,7 @@
     public void realmSet$fieldShortNotNull(Short value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldShortNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldShortNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldShortNotNullIndex, value);
     }
@@ -319,7 +317,7 @@
     public void realmSet$fieldIntegerNotNull(Integer value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldIntegerNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldIntegerNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNotNullIndex, value);
     }
@@ -351,7 +349,7 @@
     public void realmSet$fieldLongNotNull(Long value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldLongNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldLongNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldLongNotNullIndex, value);
     }
@@ -383,7 +381,7 @@
     public void realmSet$fieldFloatNotNull(Float value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldFloatNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldFloatNotNull' to null.");
         }
         proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNotNullIndex, value);
     }
@@ -415,7 +413,7 @@
     public void realmSet$fieldDoubleNotNull(Double value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldDoubleNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDoubleNotNull' to null.");
         }
         proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNotNullIndex, value);
     }
@@ -447,7 +445,7 @@
     public void realmSet$fieldDateNotNull(Date value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldDateNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDateNotNull' to null.");
         }
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNotNullIndex, value);
     }
@@ -470,7 +468,7 @@
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNullIndex, value);
     }
 
-    public NullTypes realmGet$fieldObjectNull() {
+    public some.test.NullTypes realmGet$fieldObjectNull() {
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
             return null;
@@ -478,7 +476,7 @@
         return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex));
     }
 
-    public void realmSet$fieldObjectNull(NullTypes value) {
+    public void realmSet$fieldObjectNull(some.test.NullTypes value) {
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
@@ -734,7 +732,7 @@ public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction)
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The NullTypes class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -747,9 +745,9 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        NullTypes obj = realm.createObject(NullTypes.class);
+        some.test.NullTypes obj = realm.createObject(some.test.NullTypes.class);
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
                 ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
@@ -912,9 +910,9 @@ public static NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject js
     }
 
     @SuppressWarnings("cast")
-    public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
+    public static some.test.NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        NullTypes obj = realm.createObject(NullTypes.class);
+        some.test.NullTypes obj = realm.createObject(some.test.NullTypes.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -1084,96 +1082,592 @@ public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.NullTypes copyOrUpdate(Realm realm, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.NullTypes) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
     }
 
-    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        NullTypes realmObject = realm.createObject(NullTypes.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
-
-        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
-        if (fieldObjectNullObj != null) {
-            some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
-            if (cachefieldObjectNull != null) {
-                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
+    public static some.test.NullTypes copy(Realm realm, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.NullTypes) cachedRealmObject;
+        } else {
+            some.test.NullTypes realmObject = realm.createObject(some.test.NullTypes.class);
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
+
+            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
+            if (fieldObjectNullObj != null) {
+                some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
+                if (cachefieldObjectNull != null) {
+                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
+                } else {
+                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
+                }
             } else {
-                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
+                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+            }
+            return realmObject;
+        }
+    }
+
+    public static long insert(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        if (realmGet$fieldStringNotNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+        }
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        if (realmGet$fieldStringNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+        }
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        if (realmGet$fieldBooleanNotNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+        }
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        if (realmGet$fieldBooleanNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+        }
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        if (realmGet$fieldBytesNotNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+        }
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        if (realmGet$fieldBytesNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+        }
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        if (realmGet$fieldByteNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+        }
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        if (realmGet$fieldByteNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+        }
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        if (realmGet$fieldShortNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+        }
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        if (realmGet$fieldShortNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+        }
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        if (realmGet$fieldIntegerNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+        }
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        if (realmGet$fieldIntegerNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+        }
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        if (realmGet$fieldLongNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+        }
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        if (realmGet$fieldLongNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+        }
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+        }
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        some.test.NullTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NullTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+                if (realmGet$fieldStringNotNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                }
+                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+                if (realmGet$fieldStringNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                }
+                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+                if (realmGet$fieldBooleanNotNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                }
+                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+                if (realmGet$fieldBooleanNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                }
+                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+                if (realmGet$fieldBytesNotNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                }
+                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+                if (realmGet$fieldBytesNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                }
+                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+                if (realmGet$fieldByteNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                }
+                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+                if (realmGet$fieldByteNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                }
+                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+                if (realmGet$fieldShortNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                }
+                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+                if (realmGet$fieldShortNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                }
+                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+                if (realmGet$fieldIntegerNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                }
+                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+                if (realmGet$fieldIntegerNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                }
+                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+                if (realmGet$fieldLongNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                }
+                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+                if (realmGet$fieldLongNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                }
+                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+                if (realmGet$fieldFloatNotNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                }
+                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+                if (realmGet$fieldFloatNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                }
+                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+                if (realmGet$fieldDoubleNotNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                }
+                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+                if (realmGet$fieldDoubleNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                }
+                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+                if (realmGet$fieldDateNotNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                }
+                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+                if (realmGet$fieldDateNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                }
+
+                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+                if (fieldObjectNullObj != null) {
+                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                    if (cachefieldObjectNull == null) {
+                        cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+                    }
+                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                }
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        if (realmGet$fieldStringNotNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+        }
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        if (realmGet$fieldStringNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+        }
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        if (realmGet$fieldBooleanNotNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+        }
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        if (realmGet$fieldBooleanNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+        }
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        if (realmGet$fieldBytesNotNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+        }
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        if (realmGet$fieldBytesNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+        }
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        if (realmGet$fieldByteNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        if (realmGet$fieldByteNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+        }
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        if (realmGet$fieldShortNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        if (realmGet$fieldShortNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+        }
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        if (realmGet$fieldIntegerNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        if (realmGet$fieldIntegerNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+        }
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        if (realmGet$fieldLongNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        if (realmGet$fieldLongNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+        }
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
             }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
         } else {
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+            Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
         }
-        return realmObject;
+        return rowIndex;
     }
 
-    public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        some.test.NullTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NullTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+                if (realmGet$fieldStringNotNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+                }
+                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+                if (realmGet$fieldStringNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+                }
+                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+                if (realmGet$fieldBooleanNotNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+                }
+                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+                if (realmGet$fieldBooleanNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+                }
+                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+                if (realmGet$fieldBytesNotNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+                }
+                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+                if (realmGet$fieldBytesNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+                }
+                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+                if (realmGet$fieldByteNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+                if (realmGet$fieldByteNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+                }
+                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+                if (realmGet$fieldShortNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+                if (realmGet$fieldShortNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+                }
+                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+                if (realmGet$fieldIntegerNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+                if (realmGet$fieldIntegerNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+                }
+                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+                if (realmGet$fieldLongNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+                if (realmGet$fieldLongNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+                }
+                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+                if (realmGet$fieldFloatNotNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+                }
+                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+                if (realmGet$fieldFloatNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+                }
+                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+                if (realmGet$fieldDoubleNotNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+                }
+                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+                if (realmGet$fieldDoubleNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+                }
+                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+                if (realmGet$fieldDateNotNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+                }
+                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+                if (realmGet$fieldDateNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+                }
+
+                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+                if (fieldObjectNullObj != null) {
+                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                    if (cachefieldObjectNull == null) {
+                        cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+                    }
+                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                } else {
+                    Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+                }
+            }
+        }
+    }
+
+    public static some.test.NullTypes createDetachedCopy(some.test.NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        NullTypes standaloneObject;
+        some.test.NullTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (NullTypes)cachedObject.object;
+                return (some.test.NullTypes)cachedObject.object;
             } else {
-                standaloneObject = (NullTypes)cachedObject.object;
+                unmanagedObject = (some.test.NullTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
-        }
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
+            unmanagedObject = new some.test.NullTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
+        }
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
 
         // Deep copy of fieldObjectNull
-        ((NullTypesRealmProxyInterface) standaloneObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
-        return standaloneObject;
+        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+        return unmanagedObject;
     }
 
     @Override
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 861016434b..dacfbdf3f1 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -8,15 +8,16 @@
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
 import java.io.IOException;
+import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.AllTypes;
 
 @io.realm.annotations.RealmModule
 class DefaultRealmModuleMediator extends RealmProxyMediator {
@@ -24,7 +25,7 @@
     private static final Set<Class<? extends RealmModel>> MODEL_CLASSES;
     static {
         Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>();
-        modelClasses.add(AllTypes.class);
+        modelClasses.add(some.test.AllTypes.class);
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
@@ -32,8 +33,8 @@
     public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.initTable(transaction);
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.initTable(transaction);
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -43,8 +44,8 @@ public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction
     public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.validateTable(transaction);
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.validateTable(transaction);
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -54,8 +55,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTrans
     public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.getFieldNames();
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.getFieldNames();
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -65,8 +66,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTrans
     public String getTableName(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.getTableName();
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.getTableName();
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -76,8 +77,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(new AllTypesRealmProxy(columnInfo));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(new io.realm.AllTypesRealmProxy(columnInfo));
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -94,20 +95,100 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.copyOrUpdate(realm, (AllTypes) obj, update, cache));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.copyOrUpdate(realm, (some.test.AllTypes) obj, update, cache));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+        if (clazz.equals(some.test.AllTypes.class)) {
+            io.realm.AllTypesRealmProxy.insert(realm, (some.test.AllTypes) object, cache);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        Iterator<? extends RealmModel> iterator = objects.iterator();
+        RealmModel object = null;
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        if (iterator.hasNext()) {
+            //  access the first element to figure out the clazz for the routing below
+            object = iterator.next();
+            // This cast is correct because obj is either
+            // generated by RealmProxy or the original type extending directly from RealmObject
+            @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                io.realm.AllTypesRealmProxy.insert(realm, (some.test.AllTypes) object, cache);
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+            if (iterator.hasNext()) {
+                if (clazz.equals(some.test.AllTypes.class)) {
+                    io.realm.AllTypesRealmProxy.insert(realm, iterator, cache);
+                } else {
+                    throw getMissingProxyClassException(clazz);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel obj, Map<RealmModel, Long> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
+
+        if (clazz.equals(some.test.AllTypes.class)) {
+            io.realm.AllTypesRealmProxy.insertOrUpdate(realm, (some.test.AllTypes) obj, cache);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        Iterator<? extends RealmModel> iterator = objects.iterator();
+        RealmModel object = null;
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        if (iterator.hasNext()) {
+            //  access the first element to figure out the clazz for the routing below
+            object = iterator.next();
+            // This cast is correct because obj is either
+            // generated by RealmProxy or the original type extending directly from RealmObject
+            @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                io.realm.AllTypesRealmProxy.insertOrUpdate(realm, (some.test.AllTypes) object, cache);
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+            if (iterator.hasNext()) {
+                if (clazz.equals(some.test.AllTypes.class)) {
+                    io.realm.AllTypesRealmProxy.insertOrUpdate(realm, iterator, cache);
+                } else {
+                    throw getMissingProxyClassException(clazz);
+                }
+            }
+        }
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
             throws JSONException {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -118,8 +199,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
             throws IOException {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createUsingJsonStream(realm, reader));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createUsingJsonStream(realm, reader));
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -131,11 +212,11 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass();
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createDetachedCopy((AllTypes) realmObject, 0, maxDepth, cache));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createDetachedCopy((some.test.AllTypes) realmObject, 0, maxDepth, cache));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 43f424451e..5427f4d94a 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -9,7 +9,6 @@
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
@@ -18,15 +17,14 @@
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.Simple;
 
-public class SimpleRealmProxy extends Simple
+public class SimpleRealmProxy extends some.test.Simple
         implements RealmObjectProxy, SimpleRealmProxyInterface {
 
     static final class SimpleColumnInfo extends ColumnInfo {
@@ -58,7 +56,7 @@
 
     SimpleRealmProxy(ColumnInfo columnInfo) {
         this.columnInfo = (SimpleColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(Simple.class);
+        this.proxyState = new ProxyState(some.test.Simple.class, this);
     }
 
     @SuppressWarnings("cast")
@@ -131,7 +129,7 @@ public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Simple class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(transaction.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
         }
     }
 
@@ -144,9 +142,9 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        Simple obj = realm.createObject(Simple.class);
+        some.test.Simple obj = realm.createObject(some.test.Simple.class);
         if (json.has("name")) {
             if (json.isNull("name")) {
                 ((SimpleRealmProxyInterface) obj).realmSet$name(null);
@@ -156,7 +154,7 @@ public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json,
         }
         if (json.has("age")) {
             if (json.isNull("age")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
             } else {
                 ((SimpleRealmProxyInterface) obj).realmSet$age((int) json.getInt("age"));
             }
@@ -165,9 +163,9 @@ public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json,
     }
 
     @SuppressWarnings("cast")
-    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
+    public static some.test.Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        Simple obj = realm.createObject(Simple.class);
+        some.test.Simple obj = realm.createObject(some.test.Simple.class);
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -181,7 +179,7 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
             } else if (name.equals("age")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
                 } else {
                     ((SimpleRealmProxyInterface) obj).realmSet$age((int) reader.nextInt());
                 }
@@ -193,45 +191,125 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
         return obj;
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Simple copyOrUpdate(Realm realm, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.Simple) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
+    }
+
+    public static some.test.Simple copy(Realm realm, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.Simple) cachedRealmObject;
+        } else {
+            some.test.Simple realmObject = realm.createObject(some.test.Simple.class);
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
+            ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
+            return realmObject;
+        }
+    }
+
+    public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        if (realmGet$name != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+        }
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        some.test.Simple object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Simple) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+                if (realmGet$name != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                }
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+            }
+        }
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        Simple realmObject = realm.createObject(Simple.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
-        ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
-        return realmObject;
+    public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        if (realmGet$name != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+        }
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        some.test.Simple object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Simple) objects.next();
+            if(!cache.containsKey(object)) {
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+                if (realmGet$name != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+                }
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+            }
+        }
     }
 
-    public static Simple createDetachedCopy(Simple realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.Simple createDetachedCopy(some.test.Simple realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Simple standaloneObject;
+        some.test.Simple unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (Simple)cachedObject.object;
+                return (some.test.Simple)cachedObject.object;
             } else {
-                standaloneObject = (Simple)cachedObject.object;
+                unmanagedObject = (some.test.Simple)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            standaloneObject = new Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, standaloneObject));
+            unmanagedObject = new some.test.Simple();
+            cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
-        ((SimpleRealmProxyInterface) standaloneObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
-        return standaloneObject;
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
+        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
+        return unmanagedObject;
     }
 
     @Override
@@ -239,4 +317,4 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
         return proxyState;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
similarity index 69%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
index cbeb2c0c1b..d700a10f8c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/CustomInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +14,12 @@
  * limitations under the License.
  */
 
-package io.realm.internal.test;
+package some.test;
 
-public class PhoneData {
-
-    public String type;
-    public String number;
-
-    public PhoneData(String type, String number) {
-        this.type = type;
-        this.number = number;
-    }
+import io.realm.RealmModel;
 
+// Any interface that extends RealmModel is still a RealmModel interface, so the annotation
+// processor should accept it.
+public interface CustomInterface extends RealmModel {
 }
+
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
new file mode 100644
index 0000000000..18417d5c58
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceList.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceList implements CustomInterface {
+    String name;
+    RealmList<CustomInterface> realmList;  // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
new file mode 100644
index 0000000000..1b133f59a5
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InterfaceObjectReference.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class InterfaceObjectReference implements CustomInterface {
+    String name;
+    CustomInterface obj; // Polymorphism, not yet supported.
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
index 3f0c28f814..eb897993a2 100644
--- a/realm/realm-jni/build.gradle
+++ b/realm/realm-jni/build.gradle
@@ -1,8 +1,8 @@
 import java.security.MessageDigest
 
-ext.coreVersion = '0.97.3'
+ext.coreVersion = '1.4.2'
 // empty or comment out this to disable hash checking
-ext.coreSha256Hash = '2835ae5c51ec83c38fb3f968af6cacd5fce6393b3602ddad4a8f48aaa9e62781'
+ext.coreSha256Hash = '1dfa2b4852b1cfccb18fd1a164cfeeea2b84f8de03f1024594837ca54840665c'
 ext.forceDownloadCore =
         project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
 // gcc is default for the NDK. It also produces smaller binaries
@@ -20,7 +20,7 @@ ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
 // To obtain the ABI of the connected device, execute "adb shell getprop ro.product.cpu.abi"
 ext.buildTargetAbis = project.hasProperty('buildTargetABIs') ? project.getProperty('buildTargetABIs').split(',').collect {it.trim()} : null
 
-def commonCflags = [ '-Os', '-std=c++11' ]
+def commonCflags = [ '-Os', '-std=c++11', '-Wmissing-declarations' , '-Werror']
 // LTO and debugging don't play well together
 if (!ext.debugBuild) {
     commonCflags += [ '-fvisibility=hidden', '-ffunction-sections', '-fdata-sections', '-flto' ]
@@ -262,17 +262,9 @@ task deployCore(group: 'build setup', description: 'Deploy the latest version of
             from tarTree(project.coreArchiveFile)
             into project.coreDir
         }
-        for (target in targets) {
-            exec {
-                commandLine = [
-                        'make',
-                        '-C', "${projectDir}/src",
-                        "BASE_DENOM=${target.name}",
-                        'LIB_SUFFIX_SHARED=.so',
-                        'clean'
-                ]
-            }
-        }
+	exec {
+	    commandLine = [ 'git', 'clean', '-xfd', "${projectDir}/src" ]
+	}
     }
 }
 
@@ -327,7 +319,7 @@ targets.each { target ->
         // Store the unstripped version
         copy {
             from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${projectDir}/../build/output/jniLibs-unstripped/${target.abi}"
+            into "${buildDir}/outputs/jniLibs-unstripped/${target.abi}"
             rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
         }
     }
@@ -347,7 +339,6 @@ task clean(type: Delete) {
     delete project.buildDir
 
     delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
-    delete fileTree(dir: "${projectDir}/../build/output/jniLibs-unstripped/", include: '**/librealm-jni*.so')
     delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
 
     doLast {
diff --git a/realm/realm-jni/generate-jni-headers.sh b/realm/realm-jni/generate-jni-headers.sh
index 62e34ef83f..f3abf1a9ea 100755
--- a/realm/realm-jni/generate-jni-headers.sh
+++ b/realm/realm-jni/generate-jni-headers.sh
@@ -12,7 +12,7 @@ CLASSDIR="$(pwd)/../realm/build/intermediates/classes/release/"
 JNIDIR="$(pwd)/src"
 
 # Generate the headers
-(cd "$CLASSDIR" && javah -jni -classpath "$CLASSDIR" -d "$JNIDIR" io.realm.internal.Group io.realm.internal.LinkView io.realm.internal.Row io.realm.internal.SharedGroup io.realm.internal.SubtableSchema io.realm.internal.Table io.realm.internal.TableQuery io.realm.internal.TableView io.realm.internal.Util io.realm.internal.Version)
+(cd "$CLASSDIR" && javah -jni -classpath "$CLASSDIR" -d "$JNIDIR" io.realm.internal.Group io.realm.internal.LinkView io.realm.internal.Row io.realm.internal.SharedGroup io.realm.internal.Table io.realm.internal.TableQuery io.realm.internal.TableView io.realm.internal.Util io.realm.internal.Version)
 
 # Remove "empty" header files (they have 13 lines)
 wc -l "$JNIDIR"/*.h | grep " 13 " | awk '{print $2}' | xargs rm -f
diff --git a/realm/realm-jni/src/TableSpecUtil.cpp b/realm/realm-jni/src/TableSpecUtil.cpp
deleted file mode 100644
index ed028cfd5f..0000000000
--- a/realm/realm-jni/src/TableSpecUtil.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "TableSpecUtil.hpp"
-#include "columntypeutil.hpp"
-
-using namespace std;
-using namespace realm;
-
-jclass GetClassTableSpec(JNIEnv* env)
-{
-    static jclass myClass = GetClass(env, "io/realm/internal/TableSpec");
-    return myClass;
-}
-
-jmethodID GetTableSpecMethodID(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    jclass myClass = GetClassTableSpec(env);
-    if (myClass == NULL) {
-        return NULL;
-    }
-    jmethodID myMethod = env->GetMethodID(myClass, methodStr, typeStr);
-    if (myMethod == NULL) {
-        ThrowException(env, NoSuchMethod, "TableSpec", methodStr);
-        return NULL;
-    }
-    return myMethod;
-}
-
-jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv* env, jobject jTableSpec)
-{
-    static jmethodID jGetColumnCountMethodId = GetTableSpecMethodID(env, "getColumnCount", "()J");
-    if (jGetColumnCountMethodId)
-        return env->CallLongMethod(jTableSpec, jGetColumnCountMethodId);
-    return 0;
-}
-
-jobject Java_io_realm_TableSpec_getColumnType(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetColumnTypeMethodId = GetTableSpecMethodID(env, "getColumnType", "(J)Lio/realm/RealmFieldType;");
-    if (jGetColumnTypeMethodId)
-        return env->CallObjectMethod(jTableSpec, jGetColumnTypeMethodId, columnIndex);
-    return NULL;
-}
-
-jstring Java_io_realm_TableSpec_getColumnName(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetColumnNameMethodId = GetTableSpecMethodID(env, "getColumnName", "(J)Ljava/lang/String;");
-    if (jGetColumnNameMethodId)
-        return (jstring)env->CallObjectMethod(jTableSpec, jGetColumnNameMethodId, columnIndex);
-    return NULL;
-}
-
-jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetTableSpecMethodId = GetTableSpecMethodID(env, "getSubtableSpec", "(J)Lio/realm/internal/TableSpec;");
-    if (jGetTableSpecMethodId)
-        return env->CallObjectMethod(jTableSpec, jGetTableSpecMethodId, columnIndex);
-    return NULL;
-}
-
-jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv* env, jobject jTableSpec, jstring columnName)
-{
-    static jmethodID jGetColumnIndexMethodId = GetTableSpecMethodID(env, "getColumnIndex", "(Ljava/lang/String;)J");
-    if (jGetColumnIndexMethodId)
-        return env->CallLongMethod(jTableSpec, jGetColumnIndexMethodId, columnName);
-    return 0;
-}
-
-void set_descriptor(JNIEnv* env, Descriptor& desc, jobject jTableSpec)
-{
-    jlong n = Java_io_realm_TableSpec_getColumnCount(env, jTableSpec);
-    for (jlong i = 0; i != n; ++i) {
-        jstring jColumnName = Java_io_realm_TableSpec_getColumnName(env, jTableSpec, i);
-        JStringAccessor name(env, jColumnName);  // throws
-
-        jobject jColumnType = Java_io_realm_TableSpec_getColumnType(env, jTableSpec, i);
-        DataType type = GetColumnTypeFromJColumnType(env, jColumnType);
-        DescriptorRef subdesc;
-        desc.add_column(type, name, &subdesc); // Throws
-        if (type == type_Table) {
-            jobject jNextColumnTableSpec = Java_io_realm_TableSpec_getTableSpec(env, jTableSpec, i);
-            set_descriptor(env, *subdesc, jNextColumnTableSpec);
-        }
-    }
-}
-
-void get_descriptor(JNIEnv* env, const Descriptor& desc, jobject jTableSpec)
-{
-    static jmethodID jAddColumnMethodId = GetTableSpecMethodID(env, "addColumn", "(ILjava/lang/String;)V");
-    static jmethodID jAddSubtableColumnMethodId = GetTableSpecMethodID(env, "addSubtableColumn", 
-                                                                            "(Ljava/lang/String;)Lio/realm/internal/TableSpec;");
-
-    if (jAddColumnMethodId == NULL || jAddSubtableColumnMethodId == NULL) {
-        return;
-    }
-
-    size_t n = desc.get_column_count(); // noexcept
-    for (size_t i = 0; i != n; ++i) {
-        DataType type   = desc.get_column_type(i); // noexcept
-        StringData name = desc.get_column_name(i); // noexcept
-        if (type == type_Table) {
-            jobject jSubTableSpec = env->CallObjectMethod(jTableSpec, jAddSubtableColumnMethodId, 
-                                                          to_jstring(env, name));
-            ConstDescriptorRef subdesc = desc.get_subdescriptor(i); // Throws
-            get_descriptor(env, *subdesc, jSubTableSpec);
-        }
-        else {
-            env->CallVoidMethod(jTableSpec, jAddColumnMethodId, jint(type), to_jstring(env, name));
-        }
-    }
-}
diff --git a/realm/realm-jni/src/TableSpecUtil.hpp b/realm/realm-jni/src/TableSpecUtil.hpp
deleted file mode 100644
index d1d4715f45..0000000000
--- a/realm/realm-jni/src/TableSpecUtil.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_JAVA_TABLE_SPEC_UTIL_HPP
-#define REALM_JAVA_TABLE_SPEC_UTIL_HPP
-
-#include <cstddef>
-#include <vector>
-#include <jni.h>
-#include <realm/table.hpp>
-
-jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv*, jobject jTableSpec);
-
-jobject Java_io_realm_TableSpec_getColumnType(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jstring Java_io_realm_TableSpec_getColumnName(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv*, jobject jTableSpec, jstring columnName);
-
-void set_descriptor(JNIEnv*,       realm::Descriptor&, jobject jTableSpec);
-void get_descriptor(JNIEnv*, const realm::Descriptor&, jobject jTableSpec);
-
-jclass GetClassTableSpec(JNIEnv*);
-jmethodID GetTableSpecMethodID(JNIEnv*, const char* methodStr, const char* typeStr);
-
-#endif // REALM_JAVA_TABLE_SPEC_UTIL_HPP
diff --git a/realm/realm-jni/src/columntypeutil.cpp b/realm/realm-jni/src/columntypeutil.cpp
deleted file mode 100644
index 44e3af06d1..0000000000
--- a/realm/realm-jni/src/columntypeutil.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "columntypeutil.hpp"
-
-
-static jfieldID GetFieldIDColumnType(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    static jclass myClass = GetClass(env, "io/realm/RealmFieldType");
-    if (myClass == NULL)
-        return NULL;
-
-    jfieldID myField = env->GetFieldID(myClass, methodStr, typeStr);
-    if (myField== NULL) {
-        ThrowException(env, NoSuchField, "ColumnType", methodStr);
-        return NULL;
-    }
-    return myField;
-}
-
-DataType GetColumnTypeFromJColumnType(JNIEnv* env, jobject jColumnType)
-{
-    static jfieldID jValueFieldId = GetFieldIDColumnType(env, "nativeValue", "I");
-    if (jValueFieldId == NULL)
-        return DataType(0);
-
-    jint columnType = env->GetIntField(jColumnType, jValueFieldId);
-    return static_cast<DataType>(columnType);
-}
-
-jobject GetJColumnTypeFromColumnType(JNIEnv* env, DataType columnType)
-{
-    TR("enter GetJColumnTypeFromColumnType(%d)", columnType)
-    static jclass jColumnTypeClass = GetClass(env, "io/realm/RealmFieldType");
-
-    if (jColumnTypeClass == NULL) {
-        TR("--class is NULL");
-        return NULL;
-    }
-
-    // Couldn't figure out how to create a new enum on Java side and return as object...
-    // A workaround in java to not check for the correct ColumnTypeTable works.
-    /*
-    jmethodID jColumnTypeConsId2 = env->GetMethodID(jColumnTypeClass, "<init>", "()V");
-    if (jColumnTypeConsId2) {
-        TR((env, "-GOT INIT"));
-        return NULL;
-    }
-    */
-
-   /*
-    jfieldID subtable_id = env->GetStaticFieldID(jColumnTypeClass, "ColumnTypeTable", "LColumnType;");
-    if (!subtable_id) {
-        TR((env, "--subtable_id is NULL"));
-        return NULL;
-    }
-
-    jobject jColumnTypeConsId = env->GetStaticObjectField(jColumnTypeClass, subtable_id);
-    if (jColumnTypeConsId == NULL) {
-        TR((env, "---2.5"));
-        ThrowException(env, NoSuchMethod, "ColumnType", "<init>");
-        return NULL;
-    }
-    return jColumnTypeConsId;
-    */
-
-    return NULL;
-    //jobject jColumnType = env->NewObject(jColumnTypeClass, jColumnTypeConsId,
-                                       //  static_cast<jint>(columnType));
-    //jobject jColumnType = env->NewObject(jColumnTypeClass, jColumnTypeConsId);
-
-    //TR((env, "jni: New ColumnType %d.", columnType));
-    //return jColumnType;
-}
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
index 031afa39f0..e9116d021b 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
@@ -18,8 +18,6 @@
 #include "io_realm_internal_UncheckedRow.h"
 
 #include "util.hpp"
-#include "mixedutil.hpp"
-#include "tablebase_tpl.hpp"
 
 using namespace realm;
 
@@ -103,13 +101,13 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
     return Java_io_realm_internal_UncheckedRow_nativeGetDouble(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
         return 0;
 
-    return Java_io_realm_internal_UncheckedRow_nativeGetDateTime(env, obj, nativeRowPtr, columnIndex);
+    return Java_io_realm_internal_UncheckedRow_nativeGetTimestamp(env, obj, nativeRowPtr, columnIndex);
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
@@ -130,24 +128,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArra
     return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return 0;
-
-    return Java_io_realm_internal_UncheckedRow_nativeGetMixedType(env, obj, nativeRowPtr, columnIndex);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return NULL;
-
-    return Java_io_realm_internal_UncheckedRow_nativeGetMixed(env, obj, nativeRowPtr, columnIndex);
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
@@ -167,7 +147,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jclass obj, jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
         return 0;
@@ -211,13 +191,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
     Java_io_realm_internal_UncheckedRow_nativeSetDouble(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_DateTime))
+    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Timestamp))
         return;
 
-    Java_io_realm_internal_UncheckedRow_nativeSetDate(env, obj, nativeRowPtr, columnIndex, value);
+    Java_io_realm_internal_UncheckedRow_nativeSetTimestamp(env, obj, nativeRowPtr, columnIndex, value);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
@@ -238,15 +218,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
     Java_io_realm_internal_UncheckedRow_nativeSetByteArray(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return;
-
-    Java_io_realm_internal_UncheckedRow_nativeSetMixed(env, obj, nativeRowPtr, columnIndex, jMixedValue);
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.h b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
index 230aa03d0a..8674f9947c 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.h
+++ b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
@@ -73,10 +73,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -103,29 +103,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
   (JNIEnv *, jobject, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_CheckedRow
  * Method:    nativeGetLinkView
  * Signature: (JJ)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_CheckedRow
@@ -169,10 +153,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -191,14 +175,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
   (JNIEnv *, jobject, jlong, jlong, jbyteArray);
 
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
 /*
  * Class:     io_realm_internal_CheckedRow
  * Method:    nativeSetLink
@@ -215,14 +191,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
   (JNIEnv *, jobject, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeIsNull
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlong);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm/realm-jni/src/io_realm_internal_Group.cpp b/realm/realm-jni/src/io_realm_internal_Group.cpp
index d2e289e020..f916bae98d 100644
--- a/realm/realm-jni/src/io_realm_internal_Group.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Group.cpp
@@ -32,7 +32,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_String_2I(
-    JNIEnv* env, jobject, jstring jFileName, jint mode, jbyteArray keyArray)
+    JNIEnv* env, jobject, jstring jFileName, jint mode)
 {
     TR_ENTER()
 
@@ -52,12 +52,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_St
             return 0;
         }
 
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        pGroup = new Group(file_name, key.data(), openmode);
-#else
         pGroup = new Group(file_name, NULL, openmode);
-#endif
 
         TR("group: %p", VOID_PTR(pGroup))
         return reinterpret_cast<jlong>(pGroup);
@@ -241,26 +236,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Group_nativeWriteToMem(
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Group_nativeWriteToByteBuffer(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    BinaryData buffer;
-    try {
-        buffer = G(nativeGroupPtr)->write_to_mem();
-        if (util::int_less_than_or_equal(buffer.size(), MAX_JLONG)) {
-            return env->NewDirectByteBuffer(const_cast<char*>(buffer.data()), static_cast<jlong>(buffer.size()));
-            // Data is now owned by the Java DirectByteBuffer - so we must not free it.
-        }
-        else {
-            ThrowException(env, IndexOutOfBounds, "Group too big to write.");
-            return NULL;
-        }
-    }
-    CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit(
     JNIEnv*, jobject, jlong nativeGroupPtr)
 {
@@ -300,28 +275,16 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString(
     return 0;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeEquals(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jlong nativeGroupToComparePtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    Group* grpToCompare = G(nativeGroupToComparePtr);
-    try {
-        return (*grp == *grpToCompare);
-    } CATCH_STD()
-    return false;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
     JNIEnv*, jobject, jlong nativeGroupPtr)
 {
     Group* grp = G(nativeGroupPtr);
-    const string table_prefix(TABLE_PREFIX);
-    const size_t table_prefix_length = table_prefix.length();
+    const size_t table_prefix_length = TABLE_PREFIX.length();
 
     for (size_t i = 0; i < grp->size(); ++i) {
         ConstTableRef table = grp->get_table(i);
         const string table_name = table->get_name();
-        if (table_name.compare(0, table_prefix_length, table_prefix) == 0 && !table->is_empty()) {
+        if (table_name.compare(0, table_prefix_length, TABLE_PREFIX) == 0 && !table->is_empty()) {
             return false;
         }
     }
diff --git a/realm/realm-jni/src/io_realm_internal_Group.h b/realm/realm-jni/src/io_realm_internal_Group.h
index 6f78409cdb..0099bfec7c 100644
--- a/realm/realm-jni/src/io_realm_internal_Group.h
+++ b/realm/realm-jni/src/io_realm_internal_Group.h
@@ -7,6 +7,28 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+#undef io_realm_internal_Group_MODE_READONLY
+#define io_realm_internal_Group_MODE_READONLY 0L
+#undef io_realm_internal_Group_MODE_READWRITE
+#define io_realm_internal_Group_MODE_READWRITE 1L
+#undef io_realm_internal_Group_MODE_READWRITE_NOCREATE
+#define io_realm_internal_Group_MODE_READWRITE_NOCREATE 2L
+/*
+ * Class:     io_realm_internal_Group
+ * Method:    nativeRemoveTable
+ * Signature: (JLjava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable
+  (JNIEnv *, jobject, jlong, jstring);
+
+/*
+ * Class:     io_realm_internal_Group
+ * Method:    nativeRenameTable
+ * Signature: (JLjava/lang/String;Ljava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable
+  (JNIEnv *, jobject, jlong, jstring, jstring);
+
 /*
  * Class:     io_realm_internal_Group
  * Method:    createNative
@@ -55,14 +77,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeClose
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeSize
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeHasTable
- * Signature: (JLjava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable
-  (JNIEnv *, jobject, jlong, jstring);
-
 /*
  * Class:     io_realm_internal_Group
  * Method:    nativeGetTableName
@@ -73,26 +87,10 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName
 
 /*
  * Class:     io_realm_internal_Group
- * Method:    nativeRemoveTable
- * Signature: (JLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeRenameTable
- * Signature: (JLjava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable
-  (JNIEnv *, jobject, jlong, jstring, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeGetTableNativePtr
- * Signature: (JLjava/lang/String;)J
+ * Method:    nativeHasTable
+ * Signature: (JLjava/lang/String;)Z
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable
   (JNIEnv *, jobject, jlong, jstring);
 
 /*
@@ -105,11 +103,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile
 
 /*
  * Class:     io_realm_internal_Group
- * Method:    nativeLoadFromMem
- * Signature: ([B)J
+ * Method:    nativeGetTableNativePtr
+ * Signature: (JLjava/lang/String;)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeLoadFromMem
-  (JNIEnv *, jclass, jbyteArray);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr
+  (JNIEnv *, jobject, jlong, jstring);
 
 /*
  * Class:     io_realm_internal_Group
@@ -148,8 +146,8 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString
  * Method:    nativeIsEmpty
  * Signature: (J)Z
  */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
-    JNIEnv*, jobject, jlong nativeGroupPtr);
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty
+  (JNIEnv *, jobject, jlong);
 
 #ifdef __cplusplus
 }
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
index b10a6c8523..a2aaee63f6 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -15,7 +15,6 @@
  */
 
 #include "io_realm_internal_LinkView.h"
-#include "tablequery.hpp"
 #include "util.hpp"
 
 using namespace realm;
@@ -23,7 +22,7 @@ using namespace realm;
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
   (JNIEnv*, jclass, jlong nativeLinkViewPtr)
 {
-    LangBindHelper::unbind_linklist_ptr( LV( nativeLinkViewPtr ) );
+    LangBindHelper::unbind_linklist_ptr(*LV(nativeLinkViewPtr));
 }
 
 
@@ -31,12 +30,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
     }
     try {
-        Row* row = new Row( (*lv)[ S(pos) ] );
+        LinkViewRef lvr = *lv;
+        Row* row = new Row( (*lvr)[ S(pos) ] );
         return reinterpret_cast<jlong>(row);
     } CATCH_STD()
     return 0;
@@ -47,23 +47,26 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
     }
     try {
-        return lv->get( S(pos) ).get_index();
+        LinkViewRef lvr = *lv;
+        return lvr->get( S(pos) ).get_index();
     } CATCH_STD()
     return 0;
 }
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong rowIndex)
+  (JNIEnv* env, jclass, jlong nativeLinkViewPtr, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
-        LV(nativeLinkViewPtr)->add( S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->add( S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -72,8 +75,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
-        LV(nativeLinkViewPtr)->insert( S(pos), S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->insert( S(pos), S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -82,12 +87,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        lv->set( S(pos), S(rowIndex) );
+        LinkViewRef lvr = *lv;
+        lvr->set( S(pos), S(rowIndex) );
     } CATCH_STD()
 }
 
@@ -97,14 +103,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        size_t size = LV(nativeLinkViewPtr)->size();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        size_t size = lvr->size();
         if (old_pos < 0 || new_pos < 0 || size_t(old_pos) >= size || size_t(new_pos) >= size) {
             ThrowException(env, IndexOutOfBounds,
                 "Indices must be within range [0, " + num_to_string(size) + "[. " +
                 "Yours were (" + num_to_string(old_pos) + "," + num_to_string(new_pos) + ")");
             return;
         }
-        LV(nativeLinkViewPtr)->move( S(old_pos), S(new_pos) );
+        lvr->move( S(old_pos), S(new_pos) );
     } CATCH_STD()
 }
 
@@ -113,22 +121,25 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef *lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        return lv->remove( S(pos) );
+        LinkViewRef lvr = *lv;
+        return lvr->remove( S(pos) );
     } CATCH_STD()
 }
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
+  (JNIEnv* env, jclass, jlong nativeLinkViewPtr)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->clear();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->clear();
     } CATCH_STD()
 }
 
@@ -136,9 +147,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
+    
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->size();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->size();
     } CATCH_STD()
     return 0;
 }
@@ -149,7 +163,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->is_empty();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->is_empty();
     } CATCH_STD()
     return 0;
 }
@@ -159,9 +175,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        Query query = lv->get_target_table().where(LinkViewRef(lv));
-        TableQuery* queryPtr = new TableQuery(query);
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        Query *queryPtr = new Query(lvr->get_target_table().where(LinkViewRef(lvr)));
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
@@ -172,7 +188,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        return LV(nativeLinkViewPtr)->is_attached();
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        return lvr->is_attached();
     } CATCH_STD()
     return 0;
 }
@@ -182,11 +200,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        if (!ROW_INDEX_VALID(env, &lv->get_target_table(), targetRowIndex)) {
+        LinkViewRef *lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        if (!ROW_INDEX_VALID(env, &lvr->get_target_table(), targetRowIndex)) {
             return -1;
         }
-        size_t ndx = lv->find(targetRowIndex);
+        size_t ndx = lvr->find(targetRowIndex);
         return to_jlong_or_not_found(ndx);
     } CATCH_STD()
     return -1;
@@ -197,8 +216,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
     try {
-        LinkView *lv = LV(nativeLinkViewPtr);
-        lv->remove_all_target_rows();
+        LinkViewRef* lv = LV(nativeLinkViewPtr);
+        LinkViewRef lvr = *lv;
+        lvr->remove_all_target_rows();
     } CATCH_STD()
 }
 
@@ -207,8 +227,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
 
-    LinkView* lv = LV(nativeLinkViewPtr);
-    Table* pTable = &(lv->get_target_table());
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
+    LinkViewRef lvr = *lv;
+    Table* pTable = &(lvr->get_target_table());
     LangBindHelper::bind_table_ptr(pTable);
 
     return reinterpret_cast<jlong>(pTable);
@@ -218,11 +239,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
     TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkView *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, lv, pos)) {
+    LinkViewRef* lv = LV(nativeLinkViewPtr);
+    if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
     }
     try {
-        return lv->remove_target_row( S(pos) );
+        LinkViewRef lvr = *lv;
+        return lvr->remove_target_row( S(pos) );
     } CATCH_STD()
 }
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.h b/realm/realm-jni/src/io_realm_internal_LinkView.h
index 61aa14cedc..7c9e93e61e 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.h
+++ b/realm/realm-jni/src/io_realm_internal_LinkView.h
@@ -37,7 +37,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
  * Signature: (JJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_LinkView
@@ -77,7 +77,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
  * Signature: (J)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv *, jobject, jlong);
+  (JNIEnv *, jclass, jlong);
 
 /*
  * Class:     io_realm_internal_LinkView
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
index a85bc7105f..229d9a540e 100644
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -277,22 +277,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeHasChanged
     return SG(native_ptr)->has_changed();   // noexcept
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName(
-    JNIEnv* env, jclass)
-{
-    TR_ENTER()
-#ifdef REALM_ENABLE_REPLICATION
-    ThrowException(env, UnsupportedOperation,
-                   "Replication is not currently supported by the Java language binding.");
-    return 0;
-//    return to_jstring(env, Replication::get_path_to_database_file());
-#else
-    ThrowException(env, UnsupportedOperation,
-                   "Replication was disable in the native library at compile time");
-    return 0;
-#endif
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
     JNIEnv* env, jobject, jlong native_ptr)
 {
@@ -323,4 +307,23 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersion
     env->SetLongArrayRegion(version_data, 0, 2, version_array);
 
     return version_data;
-}
\ No newline at end of file
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
+  (JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        return static_cast<jboolean>(SG(native_ptr)->wait_for_change());
+    } CATCH_STD()
+    return false;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
+  (JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        SG(native_ptr)->wait_for_change_release();
+    } CATCH_STD()
+}
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.h b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
index d41e817899..2e0dd9d035 100644
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.h
+++ b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
@@ -7,6 +7,18 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+#undef io_realm_internal_SharedGroup_IMPLICIT_TRANSACTION
+#define io_realm_internal_SharedGroup_IMPLICIT_TRANSACTION 1L
+#undef io_realm_internal_SharedGroup_EXPLICIT_TRANSACTION
+#define io_realm_internal_SharedGroup_EXPLICIT_TRANSACTION 0L
+#undef io_realm_internal_SharedGroup_CREATE_FILE_YES
+#define io_realm_internal_SharedGroup_CREATE_FILE_YES 0L
+#undef io_realm_internal_SharedGroup_CREATE_FILE_NO
+#define io_realm_internal_SharedGroup_CREATE_FILE_NO 1L
+#undef io_realm_internal_SharedGroup_ENABLE_REPLICATION
+#define io_realm_internal_SharedGroup_ENABLE_REPLICATION 1L
+#undef io_realm_internal_SharedGroup_DISABLE_REPLICATION
+#define io_realm_internal_SharedGroup_DISABLE_REPLICATION 0L
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    createNativeWithImplicitTransactions
@@ -23,31 +35,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImpli
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplication
   (JNIEnv *, jobject, jstring, jbyteArray);
 
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceRead
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceReadToVersion
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
-(JNIEnv *, jobject, jlong, jlong, jlong);
-
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativePromoteToWrite
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *, jobject, jlong);
-
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeCommitAndContinueAsRead
@@ -56,14 +43,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeRollbackAndContinueAsRead
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
-
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeBeginImplicit
@@ -72,14 +51,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndConti
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeGetDefaultReplicationDatabaseFileName
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName
-  (JNIEnv *, jobject);
-
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeReserve
@@ -168,13 +139,61 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeRollbackAndContinueAsRead
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
+  (JNIEnv *, jobject, jlong);
+
 /*
  * Class:     io_realm_internal_SharedGroup
  * Method:    nativeGetVersionID
  * Signature: (J)[J
  */
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
-        (JNIEnv *, jobject, jlong);
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeWaitForChange
+ * Signature: (J)Z
+ */
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeStopWaitForChange
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeAdvanceRead
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
+  (JNIEnv *, jobject, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativeAdvanceReadToVersion
+ * Signature: (JJJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
+  (JNIEnv *, jobject, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_SharedGroup
+ * Method:    nativePromoteToWrite
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
+  (JNIEnv *, jobject, jlong);
 
 #ifdef __cplusplus
 }
diff --git a/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp b/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
deleted file mode 100644
index 4bfdcb8073..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "io_realm_internal_SubtableSchema.h"
-
-using namespace realm;
-using namespace std;
-
-void arrayToVector(JNIEnv* env, jlongArray path, vector<size_t>& nativePath)
-{
-    jsize size = env->GetArrayLength(path);
-    nativePath.reserve(size+1);
-
-    jlong* pathElements = env->GetLongArrayElements(path, 0);
-    for (jsize i = 0; i < size; ++i) {
-        nativePath.push_back(S(pathElements[i]));
-    }
-    env->ReleaseLongArrayElements(path, pathElements, JNI_ABORT);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SubtableSchema_nativeAddColumn
-  (JNIEnv* env, jobject, jlong  nativeTablePtr, jlongArray path, jint colType, jstring name)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return 0;
-    try {
-        JStringAccessor name2(env, name); // throws
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        return TBL(nativeTablePtr)->add_subcolumn(nativePath, DataType(colType), name2);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRemoveColumn
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlongArray path, jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return;
-    try {
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        TBL(nativeTablePtr)->remove_subcolumn(nativePath, columnIndex);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRenameColumn
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlongArray path, jlong columnIndex, jstring name)
-{
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return;
-    try {
-        JStringAccessor name2(env, name);
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        TBL(nativeTablePtr)->rename_subcolumn(nativePath, columnIndex, name2);
-    }
-    CATCH_STD()
-}
diff --git a/realm/realm-jni/src/io_realm_internal_SubtableSchema.h b/realm/realm-jni/src/io_realm_internal_SubtableSchema.h
deleted file mode 100644
index 65d74a7336..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SubtableSchema.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_SubtableSchema */
-
-#ifndef _Included_io_realm_internal_SubtableSchema
-#define _Included_io_realm_internal_SubtableSchema
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeAddColumn
- * Signature: (J[JILjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SubtableSchema_nativeAddColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jint, jstring);
-
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeRemoveColumn
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRemoveColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeRenameColumn
- * Signature: (J[JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRenameColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jstring);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-jni/src/io_realm_internal_Table.cpp
similarity index 83%
rename from realm/realm-jni/src/io_realm_internal_table.cpp
rename to realm/realm-jni/src/io_realm_internal_Table.cpp
index 30611d1b3c..bc9e7e7091 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Table.cpp
@@ -17,14 +17,9 @@
 #include <sstream>
 
 #include "util.hpp"
-#include "mixedutil.hpp"
 #include "io_realm_internal_Table.h"
-#include "columntypeutil.hpp"
-#include "TableSpecUtil.hpp"
 #include "java_lang_List_Util.hpp"
-#include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
-#include "tablequery.hpp"
 
 using namespace std;
 using namespace realm;
@@ -33,7 +28,8 @@ inline static bool is_allowed_to_index(JNIEnv* env, DataType column_type) {
     if (!(column_type == type_String ||
                 column_type == type_Int ||
                 column_type == type_Bool ||
-                column_type == type_DateTime)) {
+                column_type == type_Timestamp ||
+                column_type == type_OldDateTime)) {
         ThrowException(env, IllegalArgument,
                 "This field cannot be indexed - "
                 "Only String/byte/short/int/long/boolean/Date fields are supported.");
@@ -166,7 +162,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
 }
 
 
-// General comments about the implementation of 
+// General comments about the implementation of
 // Java_io_realm_internal_Table_nativeConvertColumnToNullable and Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
 //
 // 1. converting a (not-)nullable column is idempotent (and is implemented as a no-op)
@@ -212,8 +208,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
         while (true) {
             std::ostringstream ss;
             ss << std::string("__TMP__") << j;
-            if (table->get_column_index(ss.str()) == realm::not_found) {
-                table->insert_column(column_index, column_type, ss.str(), true);
+            std::string str = ss.str();
+            StringData sd(str);
+            if (table->get_column_index(sd) == realm::not_found) {
+                table->insert_column(column_index, column_type, sd, true);
                 tmp_column_name = ss.str();
                 break;
             }
@@ -222,10 +220,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
 
         for (size_t i = 0; i < table->size(); ++i) {
             switch (column_type) {
-                case type_String:
+               case type_String: {
                     // Payload copy is needed
-                    table->set_string(column_index, i, std::string(table->get_string(column_index + 1, i)));
+                    StringData sd(table->get_string(column_index + 1, i));
+                    table->set_string(column_index, i, sd);
                     break;
+                }
                 case type_Binary: {
                     // Payload copy is needed
                     BinaryData bd = table->get_binary(column_index + 1, i);
@@ -239,8 +239,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
                 case type_Bool:
                     table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
                     break;
-                case type_DateTime:
-                    table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                case type_Timestamp:
+                    table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
                     break;
                 case type_Float:
                     table->set_float(column_index, i, table->get_float(column_index + 1, i));
@@ -254,6 +254,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
                 case type_Table:
                     // checked previously
                     break;
+                case type_OldDateTime:
+                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                    return;
             }
         }
         if (table->has_search_index(column_index + 1)) {
@@ -279,7 +282,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
         size_t column_index = S(columnIndex);
         if (!table->is_nullable(column_index)) {
             return; // column is already not nullable
-        } 
+        }
 
         std::string column_name = table->get_column_name(column_index);
         DataType column_type = table->get_column_type(column_index);
@@ -295,8 +298,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
         while (true) {
             std::ostringstream ss;
             ss << std::string("__TMP__") << j;
-            if (table->get_column_index(ss.str()) == realm::not_found) {
-                table->insert_column(column_index, column_type, ss.str(), false);
+            std::string str = ss.str();
+            StringData sd(str);
+            if (table->get_column_index(sd) == realm::not_found) {
+                table->insert_column(column_index, column_type, sd, false);
                 tmp_column_name = ss.str();
                 break;
             }
@@ -312,7 +317,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                     }
                     else {
                         // Payload copy is needed
-                        table->set_string(column_index, i, std::string(sd));
+                        table->set_string(column_index, i, sd);
                     }
                     break;
                 }
@@ -344,12 +349,12 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                         table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
                     }
                     break;
-                case type_DateTime:
+                case type_Timestamp:
                     if (table->is_null(column_index + 1, i)) {
-                        table->set_datetime(column_index, i, static_cast<time_t>(0));
+                        table->set_timestamp(column_index, i, Timestamp(0, 0));
                     }
                     else {
-                        table->set_datetime(column_index, i, table->get_datetime(column_index + 1, i));
+                        table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
                     }
                     break;
                 case type_Float:
@@ -374,6 +379,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
                 case type_Table:
                     // checked previously
                     break;
+                case type_OldDateTime:
+                    // not used
+                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                    return;
             }
         }
         if (table->has_search_index(column_index + 1)) {
@@ -391,49 +400,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
     return !TBL(nativeTablePtr)->has_shared_type();
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeUpdateFromSpec(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jobject jTableSpec)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    TR("nativeUpdateFromSpec(tblPtr %p, spec %p)", VOID_PTR(pTable), VOID_PTR(jTableSpec))
-    if (!TABLE_VALID(env, pTable))
-        return;
-    if (pTable->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "It is not allowed to update a subtable from spec.");
-        return;
-    }
-    try {
-        DescriptorRef desc = pTable->get_descriptor(); // Throws
-        set_descriptor(env, *desc, jTableSpec);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetTableSpec(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return 0;
-
-    TR_ENTER_PTR(nativeTablePtr)
-    static jmethodID jTableSpecConsId = GetTableSpecMethodID(env, "<init>", "()V");
-    if (jTableSpecConsId) {
-        try {
-            // Create a new TableSpec object in Java
-            const Table* pTable = TBL(nativeTablePtr);
-            ConstDescriptorRef desc = pTable->get_descriptor(); // noexcept
-            jobject jTableSpec = env->NewObject(GetClassTableSpec(env), jTableSpecConsId);
-            if (jTableSpec) {
-                get_descriptor(env, *desc, jTableSpec); // Throws
-                return jTableSpec;
-            }
-        }
-        CATCH_STD()
-    }
-    return 0;
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(
     JNIEnv* env, jobject, jlong nativeTablePtr)
 {
@@ -500,7 +466,7 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(
 // ---------------- Row handling
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong rows)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong rows)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TABLE_VALID(env, pTable))
@@ -545,16 +511,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    if (!TBL_AND_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex))
-        return;
-    try {
-        tbl_nativeDoMixed(&Table::set_mixed, TBL(nativeTablePtr), env, columnIndex, rowIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 // ----------------- Get cell
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong(
@@ -592,12 +548,15 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble(
     return TBL(nativeTablePtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDateTime(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_DateTime))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return 0;
-    return TBL(nativeTablePtr)->get_datetime( S(columnIndex), S(rowIndex)).get_datetime();  // noexcept
+    try {
+        return to_milliseconds(TBL(nativeTablePtr)->get_timestamp( S(columnIndex), S(rowIndex)));
+    } CATCH_STD()
+    return 0;
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString(
@@ -633,29 +592,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(
     return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex);  // noexcept
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetMixedType(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Mixed))
-        return 0;
-
-    DataType mixedType = TBL(nativeTablePtr)->get_mixed_type( S(columnIndex), S(rowIndex));  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetMixed(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Mixed))
-        return NULL;
-
-    Mixed value = TBL(nativeTablePtr)->get_mixed( S(columnIndex), S(rowIndex));  // noexcept
-    try {
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD();
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
@@ -664,61 +600,34 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
     return TBL(nativeTablePtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
-{
-    try {
-        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target( S(columnIndex) ));
-        LangBindHelper::bind_table_ptr(pTable);
-        return (jlong)pTable;
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtable(
-    JNIEnv* env, jobject jTableBase, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView
+        (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_LinkList))
         return 0;
     try {
-        Table* pSubtable = static_cast<Table*>(LangBindHelper::get_subtable_ptr(TBL(nativeTablePtr),
-            S(columnIndex), S(rowIndex)));
-        TR("nativeGetSubtable(jTableBase:%p, nativeTablePtr: %p, colIdx: %" PRId64 ", rowIdx: %" PRId64 ") : %p",
-            VOID_PTR(jTableBase), VOID_PTR(nativeTablePtr), S64(columnIndex), S64(rowIndex), VOID_PTR(pSubtable))
-        return (jlong)pSubtable;
+        LinkViewRef* link_view_ptr = new LinkViewRef(TBL(nativeTablePtr)->get_linklist( S(columnIndex), S(rowIndex)));
+        return reinterpret_cast<jlong>(link_view_ptr);
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableDuringInsert(
-    JNIEnv* env, jobject jTableBase, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
+  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
-        return 0;
     try {
-        Table* pSubtable = static_cast<Table*>(LangBindHelper::get_subtable_ptr_during_insert(
-            TBL(nativeTablePtr), S(columnIndex), S(rowIndex)));
-        TR("nativeGetSubtableDuringInsert(jTableBase:%p, nativeTablePtr: %p, colIdx: %" PRId64 ", rowIdx: %" PRId64 ") : %p",
-           VOID_PTR(jTableBase), VOID_PTR(nativeTablePtr), S64(columnIndex), S64(rowIndex), VOID_PTR(pSubtable))
-        return (jlong)pSubtable;
+        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target( S(columnIndex) ));
+        LangBindHelper::bind_table_ptr(pTable);
+        return (jlong)pTable;
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableSize(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
-        return 0;
-
-    return TBL(nativeTablePtr)->get_subtable_size( S(columnIndex), S(rowIndex)); // noexcept
-}
-
 
 // ----------------- Set cell
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
 {
     if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
@@ -728,7 +637,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
         return;
@@ -738,7 +647,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
         return;
@@ -748,7 +657,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
         return;
@@ -758,7 +667,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
         return;
@@ -768,7 +677,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
         return;
@@ -783,13 +692,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDate(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong dateTimeValue)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_DateTime))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return;
     try {
-        TBL(nativeTablePtr)->set_datetime( S(columnIndex), S(rowIndex), dateTimeValue);
+        TBL(nativeTablePtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
     } CATCH_STD()
 }
 
@@ -806,7 +715,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
 */
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
         return;
@@ -824,7 +733,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -838,16 +747,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex))
-        return;
-    try {
-        TBL(nativeTablePtr)->clear_subtable( S(columnIndex), S(rowIndex));
-    } CATCH_STD()
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong index)
 {
@@ -914,7 +813,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
@@ -1065,26 +964,24 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble(
 
 //--------------------- Aggregate methods for date
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        // This exploits the fact that dates are stored as int in core
-        return TBL(nativeTablePtr)->maximum_int( S(columnIndex));
+        return to_milliseconds(TBL(nativeTablePtr)->maximum_timestamp( S(columnIndex)));
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        // This exploits the fact that dates are stored as int in core
-        return TBL(nativeTablePtr)->minimum_int( S(columnIndex));
+        return to_milliseconds(TBL(nativeTablePtr)->minimum_timestamp( S(columnIndex)));
     } CATCH_STD()
     return 0;
 }
@@ -1144,8 +1041,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
     if (!TABLE_VALID(env, TBL(nativeTablePtr)))
         return 0;
     try {
-        Query query = TBL(nativeTablePtr)->where();
-        TableQuery* queryPtr = new TableQuery(query);
+        Query *queryPtr = new Query(TBL(nativeTablePtr)->where());
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
@@ -1154,7 +1050,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
 //----------------------- FindFirst
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong value)
 {
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
         return 0;
@@ -1197,20 +1093,20 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble(
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        size_t res = TBL(nativeTablePtr)->find_first_datetime( S(columnIndex), DateTime(dateTimeValue));
-        return to_jlong_or_not_found( res );
+        size_t res = TBL(nativeTablePtr)->find_first_timestamp( S(columnIndex), from_milliseconds(dateTimeValue));
+        return to_jlong_or_not_found(res);
     } CATCH_STD()
     return 0;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jstring value)
 {
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String))
         return 0;
@@ -1223,7 +1119,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -1285,18 +1181,20 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllBool(
     return reinterpret_cast<jlong>(pTableView);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDate(
+// FIXME: reenable when find_first_timestamp() is implemented
+/*
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
 {
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_DateTime))
+    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
         return 0;
     try {
-        TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_datetime( S(columnIndex),
-                                            DateTime(dateTimeValue)) );
+        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex), from_milliseconds(dateTimeValue)));
         return reinterpret_cast<jlong>(pTableView);
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllString(
     JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
@@ -1358,15 +1256,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
     switch (pTable->get_column_type(S(columnIndex))) {
         case type_Bool:
         case type_Int:
-        case type_DateTime:
         case type_String:
+        case type_Timestamp:
             try {
                 TableView* pTableView = new TableView( pTable->get_distinct_view(S(columnIndex)) );
                 return reinterpret_cast<jlong>(pTableView);
             } CATCH_STD()
             break;
         default:
-            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, short, int, long and their boxed variants are supported.");
+            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
             return 0;
         break;
     }
@@ -1384,16 +1282,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView(
     switch (colType) {
         case type_Int:
         case type_Bool:
-        case type_DateTime:
         case type_String:
         case type_Double:
         case type_Float:
+        case type_Timestamp:
             try {
                 TableView* pTableView = new TableView( pTable->get_sorted_view(S(columnIndex), ascending != 0 ? true : false) );
                 return reinterpret_cast<jlong>(pTableView);
             } CATCH_STD()
         default:
-            ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, boolean, double, float, String, and Date columns.");
+            ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
             return 0;
     }
     return 0;
@@ -1433,15 +1331,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
         switch (colType) {
             case type_Int:
             case type_Bool:
-            case type_DateTime:
             case type_String:
             case type_Double:
             case type_Float:
+            case type_Timestamp:
                 indices[i] = S(long_arr[i]);
                 ascendings[i] = S(bool_arr[i]);
                 break;
             default:
-                ThrowException(env, IllegalArgument, "Sort is currently only supported on integer, boolean, double, float, String, and Date columns.");
+                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
                 return 0;
         }
     }
@@ -1470,8 +1368,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(
         Table* table = TBL(nativeTablePtr);
         if (!TABLE_VALID(env, table))
             return NULL;
-        const string str = table->get_name();
-        return to_jstring(env, str);
+        return to_jstring(env, table->get_name());
     } CATCH_STD()
     return NULL;
 }
@@ -1495,47 +1392,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong maxRows)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->to_string(ss, S(maxRows));
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong rowIndex)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_ROW_INDEX_VALID(env, table, rowIndex))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->row_to_string(S(rowIndex), ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong nativeTableToComparePtr)
-{
-    Table* tbl = TBL(nativeTablePtr);
-    Table* tblToCompare = TBL(nativeTableToComparePtr);
-    try {
-        return (*tbl == *tblToCompare);
-    } CATCH_STD()
-    return false;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
     JNIEnv*, jobject, jlong nativeTablePtr)
 {
@@ -1558,10 +1414,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, j
     return 0;
 }
 
-
 // Checks if the primary key column contains any duplicate values, making it ineligible as a
 // primary key.
-bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
+static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
 {
     size_t column_index = table->get_column_index(column_name);
     if (column_index == realm::not_found) {
@@ -1623,7 +1478,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
     try {
         Table* table = TBL(nativeTablePtr);
         Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const std::string table_name(table->get_name().substr(strlen(TABLE_PREFIX))); // Remove "class_" prefix
+        const std::string table_name(table->get_name().substr(TABLE_PREFIX.length())); // Remove "class_" prefix
         size_t row_index = pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
 
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
@@ -1697,7 +1552,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
             size_t col_ndx = static_cast<size_t>(pk_table->get_int(FIELD_COLUMN_INDEX, row_ndx));
             StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
             // Make a copy of the string
-            pk_table->set_string(tmp_col_ndx, row_ndx, std::string(col_name));
+            pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
         }
 
         // Delete old int column, and rename tmp column to same name
@@ -1712,7 +1567,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
         StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
         if (table_name.begins_with(TABLE_PREFIX)) {
             // New string copy is needed, since the original memory will be changed.
-            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, std::string(table_name.substr(strlen(TABLE_PREFIX))));
+            std::string str(table_name.substr(TABLE_PREFIX.length()));
+            StringData sd(str);
+            pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
         }
     }
 }
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
index fe247b3682..37b88fd910 100644
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ b/realm/realm-jni/src/io_realm_internal_Table.h
@@ -7,20 +7,24 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+#undef io_realm_internal_Table_TABLE_MAX_LENGTH
+#define io_realm_internal_Table_TABLE_MAX_LENGTH 56L
 #undef io_realm_internal_Table_INFINITE
 #define io_realm_internal_Table_INFINITE -1LL
 #undef io_realm_internal_Table_INTEGER_DEFAULT_VALUE
 #define io_realm_internal_Table_INTEGER_DEFAULT_VALUE 0LL
+#undef io_realm_internal_Table_NULLABLE
+#define io_realm_internal_Table_NULLABLE 1L
+#undef io_realm_internal_Table_NOT_NULLABLE
+#define io_realm_internal_Table_NOT_NULLABLE 0L
 #undef io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX
 #define io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
 #undef io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX
 #define io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX 1LL
 #undef io_realm_internal_Table_NO_PRIMARY_KEY
 #define io_realm_internal_Table_NO_PRIMARY_KEY -2LL
-#undef io_realm_internal_Table_NULLABLE
-#define io_realm_internal_Table_NULLABLE 1L
-#undef io_realm_internal_Table_NOT_NULLABLE
-#define io_realm_internal_Table_NOT_NULLABLE 0L
+#undef io_realm_internal_Table_DEBUG
+#define io_realm_internal_Table_DEBUG 0L
 /*
  * Class:     io_realm_internal_Table
  * Method:    createNative
@@ -69,14 +73,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink
   (JNIEnv *, jobject, jlong, jint, jstring, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveColumn
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeRenameColumn
@@ -85,6 +81,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
   (JNIEnv *, jobject, jlong, jlong, jstring);
 
+/*
+ * Class:     io_realm_internal_Table
+ * Method:    nativeRemoveColumn
+ * Signature: (JJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
+  (JNIEnv *, jobject, jlong, jlong);
+
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeIsColumnNullable
@@ -109,14 +113,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullabl
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
   (JNIEnv *, jobject, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeUpdateFromSpec
- * Signature: (JLio/realm/internal/TableSpec;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeUpdateFromSpec
-  (JNIEnv *, jobject, jlong, jobject);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeSize
@@ -141,14 +137,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnCount
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetTableSpec
- * Signature: (J)Lio/realm/internal/TableSpec;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetTableSpec
-  (JNIEnv *, jobject, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeGetColumnName
@@ -203,7 +191,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
  * Signature: (JJ)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -255,10 +243,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -277,22 +265,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetMixedType
- * Signature: (JJJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetMixed
- * Signature: (JJJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeGetLink
@@ -303,43 +275,20 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeGetLinkTarget
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtable
+ * Method:    nativeGetLinkView
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView
+        (JNIEnv *, jclass, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtableDuringInsert
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableDuringInsert
-  (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtableSize
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableSize
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClearSubtable
- * Signature: (JJJ)V
+ * Method:    nativeGetLinkTarget
+ * Signature: (JJ)J
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -355,7 +304,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
  * Signature: (JJJJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -363,7 +312,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong
  * Signature: (JJJZ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong, jboolean);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jboolean);
 
 /*
  * Class:     io_realm_internal_Table
@@ -371,7 +320,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean
  * Signature: (JJJF)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jfloat);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jfloat);
 
 /*
  * Class:     io_realm_internal_Table
@@ -379,15 +328,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat
  * Signature: (JJJD)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jdouble);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jdouble);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDate
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -395,15 +344,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDate
  * Signature: (JJJLjava/lang/String;)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jstring);
 
 /*
  * Class:     io_realm_internal_Table
@@ -411,15 +352,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
  * Signature: (JJJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeSetMixed
- * Signature: (JJJLio/realm/internal/Mixed;)V
+ * Method:    nativeSetByteArray
+ * Signature: (JJJ[B)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong, jobject);
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
+  (JNIEnv *, jclass, jlong, jlong, jlong, jbyteArray);
 
 /*
  * Class:     io_realm_internal_Table
@@ -427,7 +368,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed
  * Signature: (JJJJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -483,7 +424,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
  * Signature: (JJJ)V
  */
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -583,18 +524,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -643,7 +584,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere
  * Signature: (JJJ)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -671,10 +612,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstDate
+ * Method:    nativeFindFirstTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -683,15 +624,15 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDate
  * Signature: (JJLjava/lang/String;)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
+  (JNIEnv *, jclass, jlong, jlong, jstring);
 
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeFindFirstNull
- * Signature: (J)J
+ * Signature: (JJ)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_Table
@@ -727,10 +668,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDouble
 
 /*
  * Class:     io_realm_internal_Table
- * Method:    nativeFindAllDate
+ * Method:    nativeFindAllTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDate
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -797,22 +738,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeHasSameSchema
@@ -824,11 +749,10 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
 /*
  * Class:     io_realm_internal_Table
  * Method:    nativeVersion
- * Signature: (JJ)Z
+ * Signature: (J)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
-        JNIEnv*, jobject, jlong);
-
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion
+  (JNIEnv *, jobject, jlong);
 
 #ifdef __cplusplus
 }
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
index debe1ce72c..9805be7b50 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -19,7 +19,6 @@
 #include <realm/commit_log.hpp>
 #include "util.hpp"
 #include "io_realm_internal_TableQuery.h"
-#include "tablequery.hpp"
 
 using namespace realm;
 
@@ -38,7 +37,7 @@ inline bool query_valid(JNIEnv* env, Query* pQuery)
 
 inline bool query_col_type_valid(JNIEnv* env, jlong nativeQueryPtr, jlong colIndex, DataType type)
 {
-    return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TQ(nativeQueryPtr)->get_current_table().get(), colIndex, type);
+    return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, Q(nativeQueryPtr)->get_table().get(), colIndex, type);
 }
 
 
@@ -55,7 +54,9 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
 (JNIEnv *env, jobject, jlong nativeQueryPtr)
 {
     try {
-        return to_jstring(env, Q(nativeQueryPtr)->validate());
+        const std::string str = Q(nativeQueryPtr)->validate();
+        StringData sd(str);
+        return to_jstring(env, sd);
     } CATCH_STD();
     return NULL;
 }
@@ -111,7 +112,7 @@ static jlong getDistinctViewWithHandover
         switch (table->get_column_type(S(columnIndex))) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
+            case type_Timestamp:
             case type_String: {
                 TableView tableView(table->get_distinct_view(S(columnIndex)) );
 
@@ -148,10 +149,10 @@ static jlong findAllSortedWithHandover
         switch (colType) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_Float:
             case type_Double:
             case type_String:
+            case type_Timestamp:
                 tableView.sort( S(columnIndex), ascending != 0);
                 break;
             default:
@@ -206,10 +207,10 @@ static jlong findAllMultiSortedWithHandover
             switch (colType) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_Float:
                 case type_Double:
                 case type_String:
+                case type_Timestamp:
                     indices.push_back( S(long_arr[i]) );
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
@@ -662,135 +663,133 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(
 }
 
 
-// DateTime
+// Timestamp
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(
-                    numeric_link_equal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime(
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->not_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(
-                    numeric_link_notequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->greater(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greater<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->less(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal_datetime(S(arr[0]), DateTime(value));
+            Q(nativeQueryPtr)->less_equal(S(arr[0]), from_milliseconds(value));
         }
         else {
             TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<DateTime, DateTime, jlong>(table_ref, arr[arr_len-1], value));
+            Q(nativeQueryPtr)->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len-1], from_milliseconds(value)));
         }
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jlong value1, jlong value2)
 {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_DateTime)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->between_datetime(S(arr[0]), DateTime(value1), DateTime(value2));
+            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value1)).less_equal(S(arr[0]), from_milliseconds(value2));
         }
         else {
             ThrowException(env, IllegalArgument, "between() does not support queries using child object fields.");
@@ -830,7 +829,7 @@ enum StringPredicate {
 };
 
 
-void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
+static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
@@ -979,40 +978,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong columnIndex)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-
-    try {
-        Table* pTable = pTQuery->get_current_table().get();
-        pTQuery->push_subtable(S(columnIndex));
-        if (!COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Table))
-            return;
-
-        pTQuery->subtable(S(columnIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-    try {
-        if (pTQuery->pop_subtable()) {
-            pTQuery->end_subtable();
-        }
-        else {
-            ThrowException(env, UnsupportedOperation, "No matching subtable().");
-        }
-    } CATCH_STD()
-}
-
-
 // Find --------------------------------------
 
 
@@ -1039,7 +1004,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
 
 // Returns a pointer to query on the worker SharedGroup or throw a BadVersion if the SharedGroup version required
 // for the handover is no longer available.
-std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
+static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
 {
     SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
     std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
@@ -1067,7 +1032,7 @@ std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong query
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
-    JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong fromTableRow)
+    JNIEnv* env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong fromTableRow)
 {
     TR_ENTER()
     try {
@@ -1119,7 +1084,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
+  (JNIEnv* env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
   {
       TR_ENTER()
       try {
@@ -1136,7 +1101,7 @@ enum query_type {QUERY_TYPE_FIND_ALL = 0, QUERY_TYPE_DISTINCT = 4, QUERY_TYPE_FI
 
 // batch update of async queries
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *env, jobject, jlong bgSharedGroupPtr,
+        (JNIEnv *env, jclass, jlong bgSharedGroupPtr,
          jlongArray  handover_queries_array /*list of handover queries*/,
          jobjectArray  query_param_matrix /*type & params of the query to be updated*/,
          jobjectArray  multi_sorted_indices_matrix,
@@ -1170,12 +1135,12 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
         std::vector<std::unique_ptr<Query>> queries(number_of_queries);
 
         // import the first query
-        queries[0] = std::move(sg->import_from_handover(std::move(handoverQuery)));
+        queries[0] = sg->import_from_handover(std::move(handoverQuery));
 
         // import the rest of the queries
         for (size_t i = 1; i < number_of_queries; ++i) {
             std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
-            queries[i] = std::move(sg->import_from_handover(std::move(handoverQuery)));
+            queries[i] = sg->import_from_handover(std::move(handoverQuery));
         }
 
         // Step2: Bring the queries into the latest shared group version
@@ -1256,7 +1221,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
 
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong columnIndex)
+        (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong columnIndex)
 {
     TR_ENTER()
     try {
@@ -1267,7 +1232,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewW
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+  (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
   {
       TR_ENTER()
       try {
@@ -1278,7 +1243,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWit
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+  (JNIEnv *env, jclass, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
   {
       TR_ENTER()
       try {
@@ -1523,42 +1488,42 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble(
 
 
 // date aggregates
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate(
+// FIXME: This is a rough workaround while waiting for https://github.com/realm/realm-core/issues/1745 to be solved
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr,
     jlong columnIndex, jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
     if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
         !ROW_INDEXES_VALID(env, pTable, start, end, limit))
         return NULL;
     try {
         size_t return_ndx;
-        DateTime result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+        Timestamp result = pQuery->find_all().maximum_timestamp(S(columnIndex), &return_ndx);
+        if (return_ndx != npos && !result.is_null()) {
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeQueryPtr,
     jlong columnIndex, jlong start, jlong end, jlong limit)
 {
     Query* pQuery = Q(nativeQueryPtr);
     Table* pTable = pQuery->get_table().get();
     if (!QUERY_VALID(env, pQuery) ||
-        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_DateTime) ||
+        !COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Timestamp) ||
         !ROW_INDEXES_VALID(env, pTable, start, end, limit))
         return NULL;
     try {
         size_t return_ndx;
-        DateTime result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+        Timestamp result = pQuery->find_all().minimum_timestamp(S(columnIndex), &return_ndx);
+        if (return_ndx != npos && !result.is_null()) {
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
@@ -1629,7 +1594,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                     Q(nativeQueryPtr)->equal(S(column_idx), realm::null());
                     break;
                 default:
@@ -1664,8 +1629,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
                 case type_Double:
                     pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) == realm::null());
                     break;
-                case type_DateTime:
-                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) == realm::null());
+                case type_Timestamp:
+                    pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) == realm::null());
                     break;
                 default:
                     // this point is unreachable
@@ -1697,7 +1662,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTa
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  (JNIEnv *env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
       TR_ENTER_PTR(handoverPtr)
       SharedGroup::Handover<Row> *handoverRowPtr = HO(Row, handoverPtr);
@@ -1732,7 +1697,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jobject, jlong nativeHandoverQuery)
+  (JNIEnv *, jclass, jlong nativeHandoverQuery)
   {
     TR_ENTER_PTR(nativeHandoverQuery)
     delete HO(Query, nativeHandoverQuery);
@@ -1770,7 +1735,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                     pQuery->not_equal(S(column_idx), realm::null());
                     break;
                 default:
@@ -1806,8 +1771,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
                 case type_Double:
                     pQuery->and_query(src_table_ref->column<Double>(S(column_idx)) != realm::null());
                     break;
-                case type_DateTime:
-                    pQuery->and_query(src_table_ref->column<DateTime>(S(column_idx)) != realm::null());
+                case type_Timestamp:
+                    pQuery->and_query(src_table_ref->column<Timestamp>(S(column_idx)) != realm::null());
                     break;
                 default:
                     // this point is unreachable
@@ -1847,7 +1812,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                 default:
                     ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList.");
                     return;
@@ -1870,7 +1835,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
                 case type_Int:
                 case type_Float:
                 case type_Double:
-                case type_DateTime:
+                case type_Timestamp:
                 default:
                     ThrowException(env, IllegalArgument, "isEmpty() only works on String, byte[] and RealmList across links.");
                     return;
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.h b/realm/realm-jni/src/io_realm_internal_TableQuery.h
index 943f9a2227..60e581f0f6 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.h
+++ b/realm/realm-jni/src/io_realm_internal_TableQuery.h
@@ -47,22 +47,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSubtable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeParent
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent
-  (JNIEnv *, jobject, jlong);
-
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeOr
@@ -257,58 +241,58 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqualDateTime
+ * Method:    nativeEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqualDateTime
+ * Method:    nativeNotEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterDateTime
+ * Method:    nativeGreaterTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqualDateTime
+ * Method:    nativeGreaterEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessDateTime
+ * Method:    nativeLessTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqualDateTime
+ * Method:    nativeLessEqualTimestamp
  * Signature: (J[JJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetweenDateTime
+ * Method:    nativeBetweenTimestamp
  * Signature: (J[JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenDateTime
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp
   (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
 
 /*
@@ -353,19 +337,19 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeFind
- * Signature: (JJ)J
+ * Method:    nativeIsEmpty
+ * Signature: (J[J)V
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
-  (JNIEnv *, jobject, jlong, jlong);
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
+  (JNIEnv *, jobject, jlong, jlongArray);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindWithHandover
- * Signature: (JJJJ)J
+ * Method:    nativeFind
+ * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
@@ -375,62 +359,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllWithHandover
- * Signature: (JJJJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGetDistinctViewWithHandover
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllSortedWithHandover
- * Signature: (JJJJJJJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllMultiSortedWithHandover
- * Signature: (JJJJJJ[J[Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverTableViewIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverRowIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeHandoverQuery
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeSumInt
@@ -529,18 +457,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJJJJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
 
 /*
@@ -551,22 +479,6 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDate
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
   (JNIEnv *, jobject, jlong, jlongArray);
 
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsEmpty
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNonEmpty
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNonEmpty
-  (JNIEnv *, jobject, jlong, jlongArray);
-
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeIsNotNull
@@ -593,26 +505,84 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeCloseQueryHandover
- * Signature: (J)V
+ * Method:    nativeImportHandoverTableViewIntoSharedGroup
+ * Signature: (JJ)J
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jobject, jlong);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
- * Method:    nativeCloseQueryHandover
+ * Method:    nativeHandoverQuery
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
+  (JNIEnv *, jobject, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllSortedWithHandover
+ * Signature: (JJJJJJZ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllWithHandover
+ * Signature: (JJJJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeGetDistinctViewWithHandover
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeAcceptHandoverQuery
-        (JNIEnv *, jlong, jlong , jlong);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
+  (JNIEnv *, jclass, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindWithHandover
+ * Signature: (JJJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
+  (JNIEnv *, jclass, jlong, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeFindAllMultiSortedWithHandover
+ * Signature: (JJJJJ[J[Z)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
+  (JNIEnv *, jclass, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeImportHandoverRowIntoSharedGroup
+ * Signature: (JJ)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
+  (JNIEnv *, jclass, jlong, jlong);
+
+/*
+ * Class:     io_realm_internal_TableQuery
+ * Method:    nativeCloseQueryHandover
+ * Signature: (J)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
+  (JNIEnv *, jclass, jlong);
 
 /*
  * Class:     io_realm_internal_TableQuery
  * Method:    nativeBatchUpdateQueries
+ * Signature: (J[J[[J[[J[[Z)[J
  */
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *,jobject,jlong ,jlongArray,jobjectArray,jobjectArray,jobjectArray);
+  (JNIEnv *, jclass, jlong, jlongArray, jobjectArray, jobjectArray, jobjectArray);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-jni/src/io_realm_internal_TableView.cpp
similarity index 85%
rename from realm/realm-jni/src/io_realm_internal_tableview.cpp
rename to realm/realm-jni/src/io_realm_internal_TableView.cpp
index 6a7e887528..67a0d587f7 100644
--- a/realm/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-jni/src/io_realm_internal_TableView.cpp
@@ -15,10 +15,8 @@
  */
 
 #include "util.hpp"
-#include "io_realm_internal_TableView.h"
-#include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
-#include "tablequery.hpp"
+#include "io_realm_internal_TableView.h"
 #include "realm/array.hpp"
 #include <ostream>
 
@@ -36,7 +34,7 @@ inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
         }
         // depends_on_deleted_linklist() will return true if and only if the current TableView was created from a
         // query on a RealmList and that RealmList was then deleted (as a result of the object being deleted).
-        if (!TV(nativeViewPtr)->is_in_sync() && TV(nativeViewPtr)->depends_on_deleted_linklist()) {
+        if (!TV(nativeViewPtr)->is_in_sync() && TV(nativeViewPtr)->depends_on_deleted_object()) {
             // This table view is no longer valid. By calling sync_if_needed we ensure it behaves
             // properly as a 0-size TableView.
             TV(nativeViewPtr)->sync_if_needed();
@@ -70,8 +68,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct(
         switch (TV(nativeViewPtr)->get_column_type(S(columnIndex))) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_String:
+            case type_Timestamp:
                 TV(nativeViewPtr)->distinct(S(columnIndex));
                 break;
             default:
@@ -101,8 +99,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti(
             switch (TV(nativeViewPtr)->get_column_type(S(indexes[i]))) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_String:
+                case type_Timestamp:
                     columns.push_back(S(indexes[i]));
                     break;
                 default:
@@ -203,11 +201,11 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetColumnName
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnIndex
    (JNIEnv *env, jobject, jlong nativeViewPtr, jstring columnName)
+
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-        return 0;
-
+            return 0;
         JStringAccessor columnName2(env, columnName); // throws
         return to_jlong_or_not_found( TV(nativeViewPtr)->get_column_index(columnName2) ); // noexcept
     } CATCH_STD()
@@ -268,15 +266,15 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble(
     return TV(nativeViewPtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetDateTimeValue(
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_DateTime))
+            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
             return 0;
     } CATCH_STD()
-    return TV(nativeViewPtr)->get_datetime( S(columnIndex), S(rowIndex)).get_datetime();  // noexcept
+    return to_milliseconds(TV(nativeViewPtr)->get_timestamp( S(columnIndex), S(rowIndex)));
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString(
@@ -293,19 +291,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString(
     return NULL;
 }
 
-/*
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetBinary(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!VIEW_VALID(env, nativeViewPtr) ||
-        !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-        return NULL;
-    // TODO: Does the native binary get freed?
-    BinaryData bin = TV(nativeViewPtr)->get_binary( S(columnIndex), S(rowIndex));  // noexcept
-    return env->NewDirectByteBuffer(const_cast<char*>(bin.data()),  static_cast<jlong>(bin.size()));
-}
-*/
-
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
@@ -318,31 +303,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray
     return NULL;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetMixedType(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Mixed))
-            return 0;
-    } CATCH_STD()
-    DataType mixedType = TV(nativeViewPtr)->get_mixed_type( S(columnIndex), S(rowIndex));  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetMixed(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Mixed))
-            return NULL;
-        Mixed value = TV(nativeViewPtr)->get_mixed( S(columnIndex), S(rowIndex));   // noexcept
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
@@ -354,41 +314,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
     return TV(nativeViewPtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtableSize(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_subtable_size( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtable(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID_MIXED(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return 0;
-        Table* pSubtable = LangBindHelper::get_subtable_ptr(TV(nativeViewPtr), S(columnIndex), S(rowIndex));
-        return reinterpret_cast<jlong>(pSubtable);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClearSubtable(
-   JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return;
-    } CATCH_STD()
-    TV(nativeViewPtr)->clear_subtable(S(columnIndex), S(rowIndex));  // noexcept
-}
-
 // Setters
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong(
@@ -435,14 +360,14 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDateTimeValue(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong dateTimeValue)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue(
+    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_DateTime))
+            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
             return;
-        TV(nativeViewPtr)->set_datetime( S(columnIndex), S(rowIndex), dateTimeValue);
+        TV(nativeViewPtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
     } CATCH_STD()
 }
 
@@ -462,19 +387,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString(
     } CATCH_STD()
 }
 
-/*
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetBinary(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
-{
-    if (!VIEW_VALID(env, nativeViewPtr) ||
-        !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-        return;
-    try {
-        tbl_nativeDoBinary(&TableView::set_binary, TV(nativeViewPtr), env, columnIndex, rowIndex, byteBuffer);
-    } CATCH_STD()
-}
-*/
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jbyteArray byteArray)
 {
@@ -486,17 +398,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetMixed(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex))
-            return;
-        tbl_nativeDoMixed(&TableView::set_mixed, TV(nativeViewPtr), env, columnIndex, rowIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong targetIndex)
 {
@@ -603,6 +504,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDouble(
     return 0;
 }
 
+// FIXME: find_first_timestamp() isn't implemented
+/*
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
 {
@@ -614,6 +517,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstString(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
@@ -684,6 +588,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDouble(
     return 0;
 }
 
+// FIXME: find_all_timestamp() isn't implemented
+/*
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
 {
@@ -697,6 +603,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
     } CATCH_STD()
     return 0;
 }
+*/
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
@@ -891,42 +798,41 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble(
 
 // date aggregates
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
+            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
             return NULL;
 
         size_t return_ndx;
-        DateTime result = TV(nativeViewPtr)->maximum_datetime( S(columnIndex), &return_ndx);
+        Timestamp result = TV(nativeViewPtr)->maximum_timestamp( S(columnIndex), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate(
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
 {
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
+            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
             return NULL;
 
         size_t return_ndx;
-        DateTime result = TV(nativeViewPtr)->minimum_datetime( S(columnIndex), &return_ndx);
+        Timestamp result = TV(nativeViewPtr)->minimum_timestamp( S(columnIndex), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result.get_datetime());
+            return NewLong(env, to_milliseconds(result));
         }
     } CATCH_STD()
     return NULL;
 }
 
 // sort
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jboolean ascending)
 {
@@ -939,10 +845,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
         switch (colType) {
             case type_Bool:
             case type_Int:
-            case type_DateTime:
             case type_Float:
             case type_Double:
             case type_String:
+            case type_Timestamp:
                 TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
                 break;
             default:
@@ -988,10 +894,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
             switch (colType) {
                 case type_Bool:
                 case type_Int:
-                case type_DateTime:
                 case type_Float:
                 case type_Double:
                 case type_String:
+                case type_Timestamp:
                     indices.push_back( S(long_arr[i]) );
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
@@ -1021,37 +927,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong maxRows)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return NULL;
-
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        TV(nativeViewPtr)->to_string(ss, S(maxRows));
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return NULL;
-
-        std::ostringstream ss;
-        TV(nativeViewPtr)->row_to_string(S(rowIndex), ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     JNIEnv *env, jobject, jlong nativeViewPtr)
 {
@@ -1060,8 +935,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return 0;
 
-        Query query = TV(nativeViewPtr)->get_parent().where(TV(nativeViewPtr));
-        TableQuery* queryPtr = new TableQuery(query);
+        Query *queryPtr = new Query(TV(nativeViewPtr)->get_parent().where(TV(nativeViewPtr)));
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
index 4afb233be6..fb1cfb53fe 100644
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ b/realm/realm-jni/src/io_realm_internal_TableView.h
@@ -7,6 +7,8 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+#undef io_realm_internal_TableView_DEBUG
+#define io_realm_internal_TableView_DEBUG 0L
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeClose
@@ -97,10 +99,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeGetDateTimeValue
+ * Method:    nativeGetTimestamp
  * Signature: (JJJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetDateTimeValue
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -119,22 +121,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetMixedType
- * Signature: (JJJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetMixed
- * Signature: (JJJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeGetLink
@@ -143,30 +129,6 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetMixed
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSubtable
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSubtableSize
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtableSize
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClearSubtable
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClearSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeSetLong
@@ -201,10 +163,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeSetDateTimeValue
+ * Method:    nativeSetTimestampValue
  * Signature: (JJJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDateTimeValue
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue
   (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
 
 /*
@@ -223,14 +185,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray
   (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetMixed
- * Signature: (JJJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong, jobject);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeSetLink
@@ -361,11 +315,11 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllString
- * Signature: (JJLjava/lang/String;)J
+ * Method:    nativeFindBySourceNdx
+ * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
+  (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
@@ -375,6 +329,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSumInt
   (JNIEnv *, jobject, jlong, jlong);
 
+/*
+ * Class:     io_realm_internal_TableView
+ * Method:    nativeFindAllString
+ * Signature: (JJLjava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString
+  (JNIEnv *, jobject, jlong, jlong, jstring);
+
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeMaximumInt
@@ -465,18 +427,18 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumDate
+ * Method:    nativeMaximumTimestamp
  * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumDate
+ * Method:    nativeMinimumTimestamp
  * Signature: (JJ)Ljava/lang/Long;
  */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDate
+JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -511,22 +473,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView
 JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeWhere
@@ -535,6 +481,14 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
   (JNIEnv *, jobject, jlong);
 
+/*
+ * Class:     io_realm_internal_TableView
+ * Method:    nativePivot
+ * Signature: (JJJIJ)V
+ */
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
+  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
+
 /*
  * Class:     io_realm_internal_TableView
  * Method:    nativeDistinct
@@ -545,36 +499,28 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeMultiDistinct
- * Signature: (J[J)V
+ * Method:    nativeSyncIfNeeded
+ * Signature: (J)J
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti
-  (JNIEnv *, jobject, jlong, jlongArray);
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded
+  (JNIEnv *, jobject, jlong);
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativePivot
- * Signature: (JJJIJ)V
+ * Method:    nativeDistinctMulti
+ * Signature: (J[J)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
-  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti
+  (JNIEnv *, jobject, jlong, jlongArray);
 
 /*
  * Class:     io_realm_internal_TableView
- * Method:    nativeSyncIfNeeded
+ * Method:    nativeSync
  * Signature: (J)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded
+JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSync
   (JNIEnv *, jobject, jlong);
 
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindBySourceNdx
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
-        (JNIEnv *, jobject, jlong, jlong);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
index 25a7c75385..908ef25fe4 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
@@ -16,8 +16,6 @@
 
 #include "io_realm_internal_UncheckedRow.h"
 #include "util.hpp"
-#include "mixedutil.hpp"
-#include "tablebase_tpl.hpp"
 
 using namespace realm;
 
@@ -115,14 +113,14 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
     return ROW(nativeRowPtr)->get_double( S(columnIndex) );
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
-    return ROW(nativeRowPtr)->get_datetime( S(columnIndex) ).get_datetime();
+    return to_milliseconds(ROW(nativeRowPtr)->get_timestamp( S(columnIndex) ));
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
@@ -162,31 +160,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteAr
     }
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
-
-    DataType mixedType = ROW(nativeRowPtr)->get_mixed_type( S(columnIndex) );  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
-
-    Mixed value = ROW(nativeRowPtr)->get_mixed( S(columnIndex) );  // noexcept
-    try {
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD();
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
@@ -211,13 +184,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jclass, jlong nativeRowPtr, jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
-    LinkView* link_view_ptr = LangBindHelper::get_linklist_ptr( *ROW( nativeRowPtr ), S( columnIndex) );
+    LinkViewRef* link_view_ptr = const_cast<LinkViewRef*>(&(LangBindHelper::get_linklist_ptr(*ROW(nativeRowPtr), S(columnIndex))));
     return reinterpret_cast<jlong>(link_view_ptr);
 }
 
@@ -269,7 +242,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
     TR_ENTER_PTR(nativeRowPtr)
@@ -277,7 +250,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
         return;
 
     try {
-        ROW(nativeRowPtr)->set_datetime( S(columnIndex), value);
+        ROW(nativeRowPtr)->set_timestamp( S(columnIndex), from_milliseconds(value));
     } CATCH_STD()
 }
 
@@ -331,18 +304,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
     }
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return;
-
-    try {
-        row_nativeSetMixed(ROW(nativeRowPtr), env, columnIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
index b714145ce3..267be9e485 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
+++ b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
@@ -81,10 +81,10 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
 
 /*
  * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetDateTime
+ * Method:    nativeGetTimestamp
  * Signature: (JJ)J
  */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDateTime
+JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv *, jobject, jlong, jlong);
 
 /*
@@ -111,29 +111,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
   (JNIEnv *, jobject, jlong, jlong);
 
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
 /*
  * Class:     io_realm_internal_UncheckedRow
  * Method:    nativeGetLinkView
  * Signature: (JJ)J
  */
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong);
 
 /*
  * Class:     io_realm_internal_UncheckedRow
@@ -177,10 +161,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
 
 /*
  * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetDate
+ * Method:    nativeSetTimestamp
  * Signature: (JJJ)V
  */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDate
+JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv *, jobject, jlong, jlong, jlong);
 
 /*
@@ -199,14 +183,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
   (JNIEnv *, jobject, jlong, jlong, jbyteArray);
 
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
 /*
  * Class:     io_realm_internal_UncheckedRow
  * Method:    nativeSetLink
diff --git a/realm/realm-jni/src/io_realm_internal_Util.cpp b/realm/realm-jni/src/io_realm_internal_Util.cpp
index 03d298af02..49eb55f255 100644
--- a/realm/realm-jni/src/io_realm_internal_Util.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Util.cpp
@@ -16,6 +16,9 @@
 
 #include <jni.h>
 
+#include <realm/string_data.hpp>
+#include <realm/unicode.hpp>
+
 #include "util.hpp"
 #include "mem_usage.hpp"
 #include "io_realm_internal_Util.h"
@@ -31,7 +34,8 @@ using std::string;
 int trace_level = 0;
 const char* log_tag = "REALM";
 
-const char* const TABLE_PREFIX = "class_";
+const string TABLE_PREFIX("class_");
+
 
 JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
 {
@@ -78,7 +82,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, j
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
     JNIEnv* env, jclass)
 {
-    return to_jstring(env, string(TABLE_PREFIX));
+    realm::StringData sd(TABLE_PREFIX);
+    return to_jstring(env, sd);
 }
 
 // -------------------------- Testcases for exception handling
@@ -169,6 +174,12 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
             if (dotest)
                 ThrowException(env, BadVersion, "parm1", "parm2");
             break;
+        case LockFileError:
+            expect = "io.realm.exceptions.IncompatibleLockFileException: parm1";
+            if (dotest)
+                ThrowException(env, LockFileError, "parm1", "parm2");
+            break;
+
 
     }
     if (dotest) {
diff --git a/realm/realm-jni/src/io_realm_internal_Version.cpp b/realm/realm-jni/src/io_realm_internal_Version.cpp
index bcbdf120b0..4fc4bc5cf8 100644
--- a/realm/realm-jni/src/io_realm_internal_Version.cpp
+++ b/realm/realm-jni/src/io_realm_internal_Version.cpp
@@ -20,6 +20,7 @@
 #include "util.hpp"
 #include "io_realm_internal_Version.h"
 #include <realm/version.hpp>
+#include <realm/string_data.hpp>
 
 static int realm_jni_version = 23;
 
@@ -34,7 +35,9 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion(JNIEnv
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion(JNIEnv *env, jclass)
 {
     try {
-        return to_jstring(env, Version::get_version());
+        std::string str(Version::get_version());
+        StringData sd(str);
+        return to_jstring(env, sd);
     }
     CATCH_STD();
     return NULL;
diff --git a/realm/realm-jni/src/mixedutil.cpp b/realm/realm-jni/src/mixedutil.cpp
deleted file mode 100644
index ce80c43cb7..0000000000
--- a/realm/realm-jni/src/mixedutil.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "mixedutil.hpp"
-#include "columntypeutil.hpp"
-
-using namespace realm;
-
-jclass GetClassMixed(JNIEnv* env)
-{
-    static jclass jMixedClass = GetClass(env, "io/realm/internal/Mixed");
-    return jMixedClass;
-}
-
-jmethodID GetMixedMethodID(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    jclass myClass = GetClassMixed(env);
-    if (myClass == NULL)
-        return NULL;
-
-    jmethodID myMethod = env->GetMethodID(myClass, methodStr, typeStr);
-    if (myMethod == NULL) {
-        ThrowException(env, NoSuchMethod, "mixed", methodStr);
-        return NULL;
-    }
-    return myMethod;
-}
-
-DataType GetMixedObjectType(JNIEnv* env, jobject jMixed)
-{
-    // Call Java "Mixed.getType"
-    static jmethodID jGetTypeMethodId = GetMixedMethodID(env, "getType", "()Lio/realm/RealmFieldType;");
-    if (jGetTypeMethodId == NULL)
-        return DataType(0);
-
-    // ???TODO optimize
-    jobject jColumnType = env->CallObjectMethod(jMixed, jGetTypeMethodId);
-    return static_cast<DataType>(GetColumnTypeFromJColumnType(env, jColumnType));
-}
-
-jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
-{
-    jclass jMixedClass = GetClassMixed(env);
-    if (jMixedClass == NULL)
-        return NULL;
-
-    TR("CreateJMixedFromMixed(type %d)", mixed.get_type())
-    switch (mixed.get_type()) {
-    case type_Int:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(J)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_int());
-    }
-    case type_Float:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(F)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_float());
-    }
-    case type_Double:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(D)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_double());
-    }
-    case type_String:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/lang/String;)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, to_jstring(env, mixed.get_string()));
-    }
-    case type_Bool:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(Z)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_bool());
-    }
-    case type_DateTime:
-        {
-            int_fast64_t timeValue = mixed.get_datetime().get_datetime();
-            jclass jDateClass = env->FindClass("java/util/Date");
-            if (jDateClass == NULL) {
-                ThrowException(env, ClassNotFound, "Date");
-                return NULL;
-            }
-            jmethodID jDateConsId = env->GetMethodID(jDateClass, "<init>", "(J)V");
-            if (jDateConsId == NULL) {
-                ThrowException(env, NoSuchMethod, "Date", "<init>");
-                return NULL;
-            }
-            jobject jDate = env->NewObject(jDateClass, jDateConsId, static_cast<jlong>(timeValue));
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/util/Date;)V");
-            if (consId)
-                return env->NewObject(jMixedClass, consId, jDate);
-        }
-    case type_Binary:
-        {
-            BinaryData binaryData = mixed.get_binary();
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/nio/ByteBuffer;)V");
-            if (consId) {
-                jobject jByteBuffer = env->NewDirectByteBuffer(const_cast<char*>(binaryData.data()), binaryData.size());
-                return env->NewObject(jMixedClass, consId, jByteBuffer);
-            }
-        }
-    case type_Table:
-        {
-            // param input: Table* t.
-            TR("   --Mixed(type_Table)")
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Lio/realm/RealmFieldType;)V");
-
-            jobject jColumnType = NULL; // GetJColumnTypeFromColumnType(env, type_Table);
-            if (consId)
-                return env->NewObject(jMixedClass, consId, jColumnType);
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    }
-
-    return NULL;
-}
-
-jlong GetMixedIntValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetLongValueMethodId = GetMixedMethodID(env, "getLongValue", "()J");
-
-    if (jGetLongValueMethodId)
-        return env->CallLongMethod(jMixed, jGetLongValueMethodId);
-    return 0;
-}
-
-jfloat GetMixedFloatValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetFloatValueMethodId = GetMixedMethodID(env, "getFloatValue", "()F");
-
-    if (jGetFloatValueMethodId)
-        return env->CallFloatMethod(jMixed, jGetFloatValueMethodId);
-    return 0;
-}
-
-jdouble GetMixedDoubleValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetDoubleValueMethodId = GetMixedMethodID(env, "getDoubleValue", "()D");
-
-    if (jGetDoubleValueMethodId)
-        return env->CallDoubleMethod(jMixed, jGetDoubleValueMethodId);
-    return 0;
-}
-
-jstring GetMixedStringValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetStringValueMethodId = GetMixedMethodID(env, "getStringValue", "()Ljava/lang/String;");;
-
-    if (jGetStringValueMethodId)
-        return (jstring)(env->CallObjectMethod(jMixed, jGetStringValueMethodId));
-    return 0;
-}
-
-jboolean GetMixedBooleanValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBoolValueMethodId = GetMixedMethodID(env, "getBooleanValue", "()Z");
-
-    if (jGetBoolValueMethodId)
-        return env->CallBooleanMethod(jMixed, jGetBoolValueMethodId);
-    return 0;
-}
-
-jbyteArray GetMixedByteArrayValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryDataMethodId = GetMixedMethodID(env, "getBinaryByteArray", "()[B");
-
-    if (jGetBinaryDataMethodId)
-        return reinterpret_cast<jbyteArray>(env->CallObjectMethod(jMixed, jGetBinaryDataMethodId));
-    return 0;
-}
-
-jlong GetMixedDateTimeValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetDateTimeMethodId = GetMixedMethodID(env, "getDateTimeValue", "()J");
-
-    if (jGetDateTimeMethodId)
-        return env->CallLongMethod(jMixed, jGetDateTimeMethodId);
-    return 0;
-}
-
-jobject GetMixedByteBufferValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryValueMethodId = GetMixedMethodID(env, "getBinaryValue", "()Ljava/nio/ByteBuffer;");
-
-    if (jGetBinaryValueMethodId)
-        return env->CallObjectMethod(jMixed, jGetBinaryValueMethodId);
-    return 0;
-}
-
-jint GetMixedBinaryType(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryTypeMethodId = GetMixedMethodID(env, "getBinaryType", "()I");
-
-    if (jGetBinaryTypeMethodId)
-        return env->CallIntMethod(jMixed, jGetBinaryTypeMethodId);
-    return 0;
-}
diff --git a/realm/realm-jni/src/mixedutil.hpp b/realm/realm-jni/src/mixedutil.hpp
deleted file mode 100644
index e7010072b0..0000000000
--- a/realm/realm-jni/src/mixedutil.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef MIXED_UTIL_H
-#define MIXED_UTIL_H
-
-#include <jni.h>
-#include <realm.hpp>
-
-using namespace realm;
-
-DataType GetMixedObjectType(JNIEnv* env, jobject jMixed);
-jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed);
-jlong GetMixedIntValue(JNIEnv* env, jobject jMixed);
-jfloat GetMixedFloatValue(JNIEnv* env, jobject jMixed);
-jdouble GetMixedDoubleValue(JNIEnv* env, jobject jMixed);
-jstring GetMixedStringValue(JNIEnv* env, jobject jMixed);
-jboolean GetMixedBooleanValue(JNIEnv* env, jobject jMixed);
-jbyteArray GetMixedByteArrayValue(JNIEnv* env, jobject jMixed);
-jlong GetMixedDateTimeValue(JNIEnv* env, jobject jMixed);
-jobject GetMixedByteBufferValue(JNIEnv* env, jobject jMixed);
-jint GetMixedBinaryType(JNIEnv* env, jobject jMixed);
-
-#endif
diff --git a/realm/realm-jni/src/tablebase_tpl.hpp b/realm/realm-jni/src/tablebase_tpl.hpp
index afd1089d48..a9ca249173 100644
--- a/realm/realm-jni/src/tablebase_tpl.hpp
+++ b/realm/realm-jni/src/tablebase_tpl.hpp
@@ -17,6 +17,7 @@
 #ifndef REALM_JNI_TABLEBASE_TPL_HPP
 #define REALM_JNI_TABLEBASE_TPL_HPP
 
+#include <realm.hpp>
 
 template <class T>
 jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
@@ -24,7 +25,7 @@ jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex
     if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex))
         return NULL;
 
-    BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
+    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
     if (bin.is_null()) {
         return NULL;
     }
@@ -49,7 +50,7 @@ void tbl_nativeDoByteArray(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex
         return;
     }
     size_t dataLen = S(env->GetArrayLength(dataArray));
-    (pTable->*doBinary)( S(columnIndex), S(rowIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
+    (pTable->*doBinary)( S(columnIndex), S(rowIndex), realm::BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
     env->ReleaseByteArrayElements(dataArray, bytePtr, 0);
 }
 
@@ -57,183 +58,9 @@ void tbl_nativeDoByteArray(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex
 template <class M, class T>
 void tbl_nativeDoBinary(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
 {
-    BinaryData bin;
+    realm::BinaryData bin;
     if (GetBinaryData(env, byteBuffer, bin))
         (pTable->*doBinary)( S(columnIndex), S(rowIndex), bin);
 }
 
-
-// insertMixed() or setMixed() value for TableView or Table class
-
-template <class M, class T>
-void tbl_nativeDoMixed(M doMixed, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    DataType valueType = GetMixedObjectType(env, jMixedValue);
-    switch(valueType) {
-    case type_Int:
-        {
-            jlong longValue = GetMixedIntValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(static_cast<int64_t>(longValue)));
-            return;
-        }
-    case type_Float:
-        {
-            jfloat floatValue = GetMixedFloatValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(floatValue));
-            return;
-        }
-    case type_Double:
-        {
-            jdouble doubleValue = GetMixedDoubleValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(doubleValue));
-            return;
-        }
-    case type_Bool:
-        {
-            jboolean boolValue = GetMixedBooleanValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(boolValue != 0 ? true : false));
-            return;
-        }
-    case type_String:
-        {
-            jstring stringValue = GetMixedStringValue(env, jMixedValue);
-            JStringAccessor string(env, stringValue); // throws
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), StringData(string));
-            return;
-        }
-    case type_DateTime:
-        {
-            jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            DateTime date(dateTimeValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(date));
-            return;
-        }
-    case type_Binary:
-        {
-            jint mixedBinaryType = GetMixedBinaryType(env, jMixedValue);
-            if (mixedBinaryType == 0) {
-                jbyteArray dataArray = GetMixedByteArrayValue(env, jMixedValue);
-                if (!dataArray)
-                    break;
-                char* data = reinterpret_cast<char*>(env->GetByteArrayElements(dataArray, NULL));
-                if (!data)
-                    break;
-                size_t size = S(env->GetArrayLength(dataArray));
-                (pTable->*doMixed)( S(columnIndex), S(rowIndex), BinaryData(data, size));
-                env->ReleaseByteArrayElements(dataArray, reinterpret_cast<jbyte*>(data), 0);
-                return;
-            }
-            else if (mixedBinaryType == 1) {
-                jobject jByteBuffer = GetMixedByteBufferValue(env, jMixedValue);
-                if (!jByteBuffer)
-                    break;
-                BinaryData binaryData;
-                if (GetBinaryData(env, jByteBuffer, binaryData))
-                    (pTable->*doMixed)( S(columnIndex), S(rowIndex), binaryData);
-                return;
-            }
-            break; // failed
-        }
-    case type_Table:
-        {
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed::subtable_tag());
-            return;
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    }
-    TR_ERR("ERROR: nativeSetMixed() failed.")
-    ThrowException(env, IllegalArgument, "nativeSetMixed()");
-}
-
-template <class R>
-void row_nativeSetMixed(R* pRow, JNIEnv* env, jlong columnIndex, jobject jMixedValue)
-{
-    DataType valueType = GetMixedObjectType(env, jMixedValue);
-    switch(valueType) {
-    case type_Int:
-        {
-            jlong longValue = GetMixedIntValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(static_cast<int64_t>(longValue)));
-            return;
-        }
-    case type_Float:
-        {
-            jfloat floatValue = GetMixedFloatValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(floatValue));
-            return;
-        }
-    case type_Double:
-        {
-            jdouble doubleValue = GetMixedDoubleValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(doubleValue));
-            return;
-        }
-    case type_Bool:
-        {
-            jboolean boolValue = GetMixedBooleanValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(boolValue != 0 ? true : false));
-            return;
-        }
-    case type_String:
-        {
-            jstring stringValue = GetMixedStringValue(env, jMixedValue);
-            JStringAccessor string(env, stringValue); // throws
-            pRow->set_mixed( S(columnIndex), StringData(string));
-            return;
-        }
-    case type_DateTime:
-        {
-            jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            DateTime date(dateTimeValue);
-            pRow->set_mixed( S(columnIndex), Mixed(date));
-            return;
-        }
-    case type_Binary:
-        {
-            jint mixedBinaryType = GetMixedBinaryType(env, jMixedValue);
-            if (mixedBinaryType == 0) {
-                jbyteArray dataArray = GetMixedByteArrayValue(env, jMixedValue);
-                if (!dataArray)
-                    break;
-                char* data = reinterpret_cast<char*>(env->GetByteArrayElements(dataArray, NULL));
-                if (!data)
-                    break;
-                size_t size = S(env->GetArrayLength(dataArray));
-                pRow->set_mixed( S(columnIndex), BinaryData(data, size));
-                env->ReleaseByteArrayElements(dataArray, reinterpret_cast<jbyte*>(data), 0);
-                return;
-            }
-            else if (mixedBinaryType == 1) {
-                jobject jByteBuffer = GetMixedByteBufferValue(env, jMixedValue);
-                if (!jByteBuffer)
-                    break;
-                BinaryData binaryData;
-                if (GetBinaryData(env, jByteBuffer, binaryData))
-                    pRow->set_mixed( S(columnIndex), binaryData);
-                return;
-            }
-            break; // failed
-        }
-    case type_Table:
-        {
-            pRow->set_mixed( S(columnIndex), Mixed::subtable_tag());
-            return;
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    }
-    TR_ERR("ERROR: nativeSetMixed() failed.")
-    ThrowException(env, IllegalArgument, "nativeSetMixed()");
-}
-
-
 #endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-jni/src/tablequery.hpp b/realm/realm-jni/src/tablequery.hpp
deleted file mode 100644
index 11ab2891eb..0000000000
--- a/realm/realm-jni/src/tablequery.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __REALM_TABLEQUERY__
-#define __REALM_TABLEQUERY__
-
-#include <vector>
-#include <assert.h>
-#include <realm.hpp>
-
-class TableQuery : public realm::Query {
-    // 'subtables' is used to figure out which subtable the query
-    // is currently working on, so that we can lookup the correct
-    // table and verify the parameters related to that table.
-    std::vector<size_t> subtables;  // holds subtable column indices
-
-public:
-    TableQuery(const Query& copy) : realm::Query(copy) {};
- 
-    void push_subtable(size_t index) {
-        subtables.push_back(index);
-    }
-
-    bool pop_subtable() {
-        if (subtables.empty())
-            return false;
-        subtables.pop_back();
-        return true;
-    }
-    
-    realm::TableRef get_current_table() {
-        realm::TableRef table = get_table();
-
-        // Go through the stack of subtables to find current subtable (if any)
-        size_t size = subtables.size(); 
-        for (size_t i = 0; i < size; ++i) {
-            size_t index = subtables[i];
-            table = table->get_subtable(index, 0);
-        }
-        return table;
-    }
-};
-
-#define TQ(ptr) reinterpret_cast<TableQuery*>(ptr)
-
-#endif // __REALM_TABLEQUERY__
diff --git a/realm/realm-jni/src/util.cpp b/realm/realm-jni/src/util.cpp
index a2daeaec90..6d8a7dd58a 100644
--- a/realm/realm-jni/src/util.cpp
+++ b/realm/realm-jni/src/util.cpp
@@ -18,6 +18,7 @@
 #include <stdexcept>
 
 #include <realm/util/assert.hpp>
+#include <realm/unicode.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
@@ -57,6 +58,10 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
+    catch (File::AccessError& e) {
+        ss << e.what() << " path: " << e.get_path() << " in " << file << " line " << line;
+        ThrowException(env, IllegalArgument, ss.str());
+    }
     catch (exception& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, FatalError, ss.str());
@@ -156,6 +161,12 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
             message = classStr;
             break;
+
+        case LockFileError:
+            jExceptionClass = env->FindClass("io/realm/exceptions/IncompatibleLockFileException");
+            message = classStr;
+            break;
+
     }
     if (jExceptionClass != NULL) {
         env->ThrowNew(jExceptionClass, message.c_str());
@@ -181,21 +192,6 @@ jclass GetClass(JNIEnv* env, const char* classStr)
     return myClass;
 }
 
-void jprint(JNIEnv *env, char *txt)
-{
-#if 1
-    static_cast<void>(env);
-    fprintf(stderr, " -- JNI: %s", txt);  fflush(stderr);
-#else
-    static jclass myClass = GetClass(env, "io/realm/internal/Util");
-    static jmethodID myMethod = env->GetStaticMethodID(myClass, "javaPrint", "(Ljava/lang/String;)V");
-    if (myMethod)
-        env->CallStaticVoidMethod(myClass, myMethod, to_jstring(env, txt));
-    else
-        ThrowException(env, NoSuchMethod, "Util", "javaPrint");
-#endif
-}
-
 void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
     std::ostringstream ss;
     ss << "Trying to set a non-nullable field '"
@@ -206,17 +202,6 @@ void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
     ThrowException(env, IllegalArgument, ss.str());
 }
 
-void jprintf(JNIEnv *env, const char *format, ...)
-{
-    va_list argptr;
-    char buf[200];
-    va_start(argptr, format);
-    //vfprintf(stderr, format, argptr);
-    vsnprintf(buf, 200, format, argptr);
-    jprint(env, buf);
-    va_end(argptr);
-}
-
 bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
 {
     const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
@@ -275,7 +260,7 @@ struct JStringCharsAccessor {
 
 } // anonymous namespace
 
-string string_to_hex(const string& message, StringData& str, const char* in_begin, const char* in_end,
+static string string_to_hex(const string& message, StringData& str, const char* in_begin, const char* in_end,
                      jchar* out_curr, jchar* out_end, size_t retcode, size_t error_code) {
     ostringstream ret;
 
@@ -296,7 +281,7 @@ string string_to_hex(const string& message, StringData& str, const char* in_begi
     return ret.str();
 }
 
-string string_to_hex(const string& message, const jchar *str, size_t size, size_t error_code) {
+static string string_to_hex(const string& message, const jchar *str, size_t size, size_t error_code) {
     ostringstream ret;
 
     ret << message << "; ";
@@ -421,3 +406,4 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         m_size = out_begin - m_data.get();
     }
 }
+
diff --git a/realm/realm-jni/src/util.hpp b/realm/realm-jni/src/util.hpp
index c96fd26a48..947b0dfae9 100644
--- a/realm/realm-jni/src/util.hpp
+++ b/realm/realm-jni/src/util.hpp
@@ -31,6 +31,7 @@
 #include <realm/util/meta.hpp>
 #include <realm/util/safe_int_ops.hpp>
 #include <realm/lang_bind_helper.hpp>
+#include <realm/timestamp.hpp>
 
 #include "io_realm_internal_Util.h"
 
@@ -61,14 +62,22 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
         ThrowException(env, IllegalArgument, "Invalid format of Realm file."); \
     } \
     catch (util::File::PermissionDenied& e) { \
-        ThrowException(env, IOFailed, string(fileName), string("Permission denied. ") + e.what()); \
+        ThrowException(env, IOFailed, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path()); \
     } \
-    catch (util::File::NotFound&) { \
-        ThrowException(env, FileNotFound, string(fileName).data());    \
+    catch (util::File::NotFound& e) { \
+        ThrowException(env, FileNotFound, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path());    \
     } \
     catch (util::File::AccessError& e) { \
-        ThrowException(env, FileAccessError, string(fileName), e.what()); \
-    }
+        ThrowException(env, FileAccessError, string(fileName), \
+                std::string(e.what()) + " path: " + e.get_path()); \
+    } \
+    catch (realm::IncompatibleLockFile& e) { \
+        ThrowException(env, LockFileError, std::string(e.what())); \
+    } \
+
+
 
 #define CATCH_STD() \
     catch (...) { \
@@ -96,7 +105,7 @@ std::string num_to_string(T pNumber)
 #define S64(x)  static_cast<int64_t>(x)
 #define TBL(x)  reinterpret_cast<realm::Table*>(x)
 #define TV(x)   reinterpret_cast<realm::TableView*>(x)
-#define LV(x)   reinterpret_cast<realm::LinkView*>(x)
+#define LV(x)   reinterpret_cast<realm::LinkViewRef*>(x)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
 #define G(x)    reinterpret_cast<realm::Group*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
@@ -121,7 +130,8 @@ enum ExceptionKind {
     RuntimeError = 12,
     RowInvalid = 13,
     CrossTableLink = 15,
-    BadVersion = 16
+    BadVersion = 16,
+    LockFileError = 17
 // NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
 };
 
@@ -183,10 +193,8 @@ extern const char* log_tag;
 #define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
-#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              IndexAndTypeValid(env, ptr, col, row, type, false)
-#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type, false)
-#define INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type)        IndexAndTypeValid(env, ptr, col, row, type, true)
-#define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) TblIndexAndTypeValid(env, ptr, col, row, type, true)
+#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              IndexAndTypeValid(env, ptr, col, row, type)
+#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) TblIndexAndTypeInsertValid(env, ptr, col, row, type)
 
 #define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     RowColIndexAndTypeValid(env, ptr, col, type)
@@ -210,8 +218,6 @@ extern const char* log_tag;
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
 #define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              (true)
 #define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      (true)
-#define INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type)        (true)
-#define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) (true)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) (true)
 
 #define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
@@ -292,7 +298,7 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
 }
 
 template <class T>
-inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
+inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=false)
 {
     if (rowIndex < 0) {
         ThrowException(env, IndexOutOfBounds, "rowIndex is less than 0.");
@@ -381,16 +387,10 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
 }
 
 template <class T>
-inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
-    if (allowMixed) {
-        if (colType == realm::type_Mixed) {
-            size_t row = static_cast<size_t>(rowIndex);
-            colType = pTable->get_mixed_type(col, row);
-        }
-    }
     if (colType != expectColType) {
         TR_ERR("Expected columnType %d, but got %d.", expectColType, pTable->get_column_type(col))
         ThrowException(env, IllegalArgument, "ColumnType invalid.");
@@ -440,7 +440,7 @@ template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
     return ColIndexValid(env, pTable, columnIndex)
-        && TypeValid(env, pTable, columnIndex, 0, expectColType, false);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
 inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
@@ -468,22 +468,22 @@ inline bool RowColIndexAndTypeValid(JNIEnv* env, realm::Row* pRow, jlong columnI
 }
 
 template <class T>
-inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
     return IndexValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
-inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
-    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType);
 }
 
 template <class T>
 inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
     return TblIndexInsertValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, false);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 
 bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
@@ -669,6 +669,24 @@ inline jobject NewFloat(JNIEnv* env, float value)
     return env->NewObject(java_lang_float, java_lang_float_init, value);
 }
 
-extern const char* const TABLE_PREFIX;
+inline jlong to_milliseconds(const realm::Timestamp& ts)
+{
+    // From core's reference implementation aka unit test
+    // FIXME: check for overflow/underflow
+    const int64_t seconds = ts.get_seconds();
+    const int32_t nanoseconds = ts.get_nanoseconds();
+    const int64_t milliseconds = seconds * 1000 + nanoseconds / 1000000; // This may overflow
+    return milliseconds;
+}
+
+inline realm::Timestamp from_milliseconds(jlong milliseconds)
+{
+    // From core's reference implementation aka unit test
+    int64_t seconds = milliseconds / 1000;
+    int32_t nanoseconds = (milliseconds % 1000) * 1000000;
+    return realm::Timestamp(seconds, nanoseconds);
+}
+
+extern const std::string TABLE_PREFIX;
 
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index dca876a290..d3127e906f 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.library'
 apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'com.github.dcendents.android-maven'
@@ -11,12 +10,12 @@ apply plugin: 'checkstyle'
 apply plugin: 'com.github.kt3k.coveralls'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion '23.0.0'
+    compileSdkVersion 24
+    buildToolsVersion '24.0.0'
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 23
+        targetSdkVersion 24
         project.archivesBaseName = "realm-android-library"
         consumerProguardFiles 'proguard-rules.pro'
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
@@ -28,6 +27,17 @@ android {
         }
     }
 
+    sourceSets {
+        androidTest {
+            java.srcDirs += 'src/benchmarks/java'
+        }
+    }
+
+    packagingOptions {
+        exclude 'META-INF/NOTICE.txt'
+        exclude 'META-INF/LICENSE.txt'
+    }
+
     lintOptions {
         abortOnError false
     }
@@ -50,11 +60,13 @@ dependencies {
     compile 'com.getkeepsafe.relinker:relinker:1.2.1'
 
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:23.1.1'
-    androidTestCompile 'com.android.support.test:runner:0.4.1'
-    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    androidTestCompile 'com.android.support:support-annotations:24.0.0'
+    androidTestCompile 'com.android.support.test:runner:0.5'
+    androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestCompile 'com.opencsv:opencsv:3.4'
+    androidTestCompile 'dk.ilios:spanner:0.6.0'
 
     androidTestApt project(':realm-annotations-processor')
 }
@@ -76,6 +88,10 @@ task javadoc(type: Javadoc) {
         charSet = 'UTF-8'
         locale = 'en_US'
         overview = 'src/overview.html'
+
+        links "http://docs.oracle.com/javase/7/docs/api/"
+        links "http://reactivex.io/RxJava/javadoc/"
+        linksOffline "http://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -149,6 +165,24 @@ task checkstyle(type: Checkstyle) {
     classpath = files()
 }
 
+// Configuration options can be found here:
+// http://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html
+task connectedBenchmarks(type: GradleBuild) {
+    description =  'Run all benchmarks on connected devices'
+    group = 'Verification'
+    buildFile = file("${projectDir}/build.gradle")
+    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.package', 'io.realm.benchmarks')
+    tasks = ['connectedCheck']
+}
+
+task connectedUnitTests(type: GradleBuild) {
+    description =  'Run all unit tests on connected devices'
+    group = 'Verification'
+    buildFile = file("${projectDir}/build.gradle")
+    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.notPackage', 'io.realm.benchmarks')
+    tasks = ['connectedAndroidTest']
+}
+
 install {
     repositories.mavenInstaller {
         pom {
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules.pro
index 0b2181d2ed..2ad1784f1a 100644
--- a/realm/realm-library/proguard-rules.pro
+++ b/realm/realm-library/proguard-rules.pro
@@ -6,3 +6,6 @@
 -dontwarn io.realm.**
 -keep class io.realm.RealmCollection
 -keep class io.realm.OrderedRealmCollection
+-keepclasseswithmembernames class io.realm.internal.** {
+    native <methods>;
+}
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index d7fa5a811c..357f8f7ef8 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -1,16 +1,23 @@
 <?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="io.realm">
+<manifest package="io.realm"
+          xmlns:android="http://schemas.android.com/apk/res/android"
+          xmlns:tools="http://schemas.android.com/tools">
 
-    <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <uses-sdk tools:overrideLibrary="dk.ilios.spanner"/>
+    <uses-sdk
+        android:minSdkVersion="16"
+        android:targetSdkVersion="22"/>
 
     <application>
-        <uses-library android:name="android.test.runner" />
+        <uses-library android:name="android.test.runner"/>
         <service
             android:name=".services.RemoteProcessService"
             android:enabled="true"
             android:exported="true"
-            android:process=":remote" >
+            android:process=":remote">
         </service>
     </application>
 
diff --git a/realm/realm-library/src/androidTest/assets/asset_file.realm b/realm/realm-library/src/androidTest/assets/asset_file.realm
new file mode 100644
index 0000000000..c5f75da4f8
Binary files /dev/null and b/realm/realm-library/src/androidTest/assets/asset_file.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
new file mode 100644
index 0000000000..197fbaf090
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -0,0 +1,838 @@
+/*
+ * Copyright 2014-2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Log;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnimalModule;
+import io.realm.entities.Cat;
+import io.realm.entities.CatOwner;
+import io.realm.entities.CyclicType;
+import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.Dog;
+import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.HumanModule;
+import io.realm.entities.NoPrimaryKeyWithPrimaryKeyObjectRelation;
+import io.realm.entities.NullTypes;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.PrimaryKeyWithNoPrimaryKeyObjectRelation;
+import io.realm.entities.pojo.AllTypesRealmModel;
+import io.realm.entities.pojo.InvalidRealmModel;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class BulkInsertTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insert() {
+        AllJavaTypes obj = new AllJavaTypes();
+        obj.setFieldIgnored("cookie");
+        obj.setFieldLong(42);
+        obj.setFieldString("obj1");
+
+        RealmList<AllJavaTypes> list = new RealmList<AllJavaTypes>();
+        list.add(obj);
+
+        Date date = new Date();
+
+        AllJavaTypes allTypes = new AllJavaTypes();
+        allTypes.setFieldString("String");
+        allTypes.setFieldLong(1L);
+        allTypes.setFieldFloat(1F);
+        allTypes.setFieldDouble(1D);
+        allTypes.setFieldBoolean(true);
+        allTypes.setFieldDate(date);
+        allTypes.setFieldBinary(new byte[]{1, 2, 3});
+        allTypes.setFieldObject(obj);
+        allTypes.setFieldList(list);
+
+        realm.beginTransaction();
+        realm.insert(allTypes);
+        realm.commitTransaction();
+
+        AllJavaTypes realmTypes = realm.where(AllJavaTypes.class).findFirst();
+
+        assertNotNull(realmTypes);
+        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal
+        assertEquals(allTypes.getFieldString(), realmTypes.getFieldString()); // But they contain the same data
+        assertEquals(allTypes.getFieldLong(), realmTypes.getFieldLong());
+        assertEquals(allTypes.getFieldFloat(), realmTypes.getFieldFloat(), 0);
+        assertEquals(allTypes.getFieldDouble(), realmTypes.getFieldDouble(), 0);
+        assertEquals(allTypes.isFieldBoolean(), realmTypes.isFieldBoolean());
+        assertEquals(allTypes.getFieldDate(), realmTypes.getFieldDate());
+        assertArrayEquals(allTypes.getFieldBinary(), realmTypes.getFieldBinary());
+        assertEquals(allTypes.getFieldObject().getFieldString(), obj.getFieldString());
+        assertEquals(list.size(), realmTypes.getFieldList().size());
+        assertEquals(list.get(0).getFieldString(), realmTypes.getFieldList().get(0).getFieldString());
+        assertEquals(list.get(0).getFieldLong(), realmTypes.getFieldList().get(0).getFieldLong());
+        assertNull(realmTypes.getFieldList().get(0).getFieldIgnored());
+
+
+        // make sure Dog was not inserted twice in the recursive process
+        assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());
+    }
+
+    @Test
+    public void insert_realmModel() {
+        AllTypesRealmModel allTypes = new AllTypesRealmModel();
+        allTypes.columnLong = 10;
+        allTypes.columnBoolean = false;
+        allTypes.columnBinary = new byte[]{1, 2, 3};
+        allTypes.columnDate = new Date();
+        allTypes.columnDouble = 3.1415;
+        allTypes.columnFloat = 1.234567f;
+        allTypes.columnString = "test data";
+        allTypes.columnByte = 0b0010_1010;
+
+        realm.beginTransaction();
+        realm.insert(allTypes);
+        realm.commitTransaction();
+
+        AllTypesRealmModel first = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(first);
+        assertEquals(allTypes.columnString, first.columnString);
+        assertEquals(allTypes.columnLong, first.columnLong);
+        assertEquals(allTypes.columnBoolean, first.columnBoolean);
+        assertArrayEquals(allTypes.columnBinary, first.columnBinary);
+        assertEquals(allTypes.columnDate, first.columnDate);
+        assertEquals(allTypes.columnDouble, first.columnDouble, 0.0000001);
+        assertEquals(allTypes.columnFloat, first.columnFloat, 0.0000001);
+        assertEquals(allTypes.columnByte, first.columnByte);
+    }
+
+    @Test
+    public void insert_invalidRealmModel() {
+        InvalidRealmModel invalidRealmModel = new InvalidRealmModel();
+
+        realm.beginTransaction();
+        try {
+            realm.insert(invalidRealmModel);
+            fail("Expected Missing Proxy Class Exception");
+        } catch (RealmException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_nullTypes() {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(1);
+        nullTypes1.setFieldFloatNull(2F);
+        nullTypes1.setFieldDoubleNull(3D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        realm.beginTransaction();
+        realm.insert(nullTypes1);
+        realm.commitTransaction();
+
+        NullTypes first = realm.where(NullTypes.class).findFirst();
+
+        assertNotNull(first);
+        assertEquals(nullTypes1.getId(), first.getId());
+        assertEquals(nullTypes1.getFieldIntegerNull(), first.getFieldIntegerNull());
+        assertEquals(nullTypes1.getFieldFloatNull(), first.getFieldFloatNull());
+        assertEquals(nullTypes1.getFieldDoubleNull(), first.getFieldDoubleNull());
+        assertEquals(nullTypes1.getFieldBooleanNull(), first.getFieldBooleanNull());
+        assertEquals(nullTypes1.getFieldStringNull(), first.getFieldStringNull());
+        assertEquals(nullTypes1.getFieldDateNull(), first.getFieldDateNull());
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+
+        nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(null);
+        nullTypes1.setFieldFloatNull(null);
+        nullTypes1.setFieldDoubleNull(null);
+        nullTypes1.setFieldBooleanNull(null);
+        nullTypes1.setFieldStringNull(null);
+        nullTypes1.setFieldDateNull(null);
+        nullTypes1.setFieldListNull(new RealmList<NullTypes>());
+        nullTypes1.getFieldListNull().add(nullTypes2);
+        nullTypes1.getFieldListNull().add(nullTypes3);
+
+        OrderedRealmCollection<NullTypes> collection = new RealmList<NullTypes>();
+        collection.add(nullTypes2);
+        collection.add(nullTypes1);
+        collection.add(nullTypes3);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(collection);
+        realm.commitTransaction();
+
+        first = realm.where(NullTypes.class).equalTo("id", 1).findFirst();
+
+        assertNotNull(first);
+        assertEquals(nullTypes1.getId(), first.getId());
+        assertNull(first.getFieldIntegerNull());
+        assertNull(first.getFieldFloatNull());
+        assertNull(first.getFieldDoubleNull());
+        assertNull(first.getFieldBooleanNull());
+        assertNull(first.getFieldStringNull());
+        assertNull(first.getFieldDateNull());
+        assertEquals(2, first.getFieldListNull().size());
+        assertEquals(2, first.getFieldListNull().get(0).getId());
+        assertEquals(3, first.getFieldListNull().get(1).getId());
+    }
+
+    @Test
+    public void insert_cyclicType() {
+        CyclicType oneCyclicType = new CyclicType();
+        oneCyclicType.setName("One");
+        CyclicType anotherCyclicType = new CyclicType();
+        anotherCyclicType.setName("Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        realm.insert(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+
+        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).findAllSorted(CyclicType.FIELD_NAME);
+        assertNotNull(realmObjects);
+        assertEquals(2, realmObjects.size());
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("Two", realmObjects.get(0).getObject().getName());
+    }
+
+    @Test
+    public void insertOrUpdate_cyclicType() {
+        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1, "One");
+        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2, "Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+
+        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).findAllSorted("name");
+        assertNotNull(realmObjects);
+        assertEquals(2, realmObjects.size());
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("Two", realmObjects.get(0).getObject().getName());
+
+        CyclicTypePrimaryKey updatedCyclicType = new CyclicTypePrimaryKey(2, "updated");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(updatedCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("updated", realmObjects.get(0).getObject().getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
+    }
+
+    @Test
+    public void insert_nullPrimaryKey() {
+        PrimaryKeyAsString primaryKeyAsString = new PrimaryKeyAsString();
+        primaryKeyAsString.setId(19);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(primaryKeyAsString);
+        realm.commitTransaction();
+
+        primaryKeyAsString = realm.where(PrimaryKeyAsString.class).isNull("name").findFirst();
+        assertNotNull(primaryKeyAsString);
+        assertNull(primaryKeyAsString.getName());
+        assertEquals(19, primaryKeyAsString.getId());
+
+        PrimaryKeyAsBoxedShort primaryKeyAsShort = new PrimaryKeyAsBoxedShort();
+        primaryKeyAsShort.setName("42");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(primaryKeyAsShort);
+        realm.commitTransaction();
+
+        primaryKeyAsShort = realm.where(PrimaryKeyAsBoxedShort.class).isNull("id").findFirst();
+        assertNotNull(primaryKeyAsShort);
+        assertNull(primaryKeyAsShort.getId());
+        assertEquals("42", primaryKeyAsShort.getName());
+    }
+
+    @Test
+    public void insert_duplicatedPrimaryKeyFails() {
+
+        // Single object with 2 references to two objects with the same ID
+        AllJavaTypes obj = new AllJavaTypes(2);
+        obj.setFieldList(new RealmList<AllJavaTypes>(new AllJavaTypes(1), new AllJavaTypes(1)));
+        realm.beginTransaction();
+        try {
+            realm.insert(obj);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // Two objects with the same ID in a list
+        realm.beginTransaction();
+        try {
+            realm.insert(Arrays.asList(new AllJavaTypes(1), new AllJavaTypes(1)));
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+                obj.setColumnString("Foo");
+                obj.setColumnLong(1);
+                obj.setColumnFloat(1.23F);
+                obj.setColumnDouble(1.234D);
+                obj.setColumnBoolean(false);
+                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnDate(new Date(1000));
+                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
+                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
+                obj.setColumnBoxedBoolean(true);
+                realm.insert(obj);
+
+                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
+                obj2.setColumnString("Bar");
+                obj2.setColumnLong(1);
+                obj2.setColumnFloat(2.23F);
+                obj2.setColumnDouble(2.234D);
+                obj2.setColumnBoolean(true);
+                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnDate(new Date(2000));
+                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
+                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
+                obj2.setColumnBoxedBoolean(false);
+                realm.insertOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
+
+        // Check that the only element has all its properties updated
+        assertNotNull(obj);
+        assertEquals("Bar", obj.getColumnString());
+        assertEquals(1, obj.getColumnLong());
+        assertEquals(2.23F, obj.getColumnFloat(), 0);
+        assertEquals(2.234D, obj.getColumnDouble(), 0);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertEquals(new Date(2000), obj.getColumnDate());
+        assertEquals("Dog3", obj.getColumnRealmObject().getName());
+        assertEquals(1, obj.getColumnRealmList().size());
+        assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
+        assertEquals(4, realm.where(DogPrimaryKey.class).findAll().size());
+        assertFalse(obj.getColumnBoxedBoolean());
+    }
+
+    @Test
+    public void insert_list() {
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+        RealmList<Dog> list = new RealmList<Dog>();
+        list.addAll(Arrays.asList(dog1, dog2));
+
+        realm.beginTransaction();
+        realm.insert(list);
+        realm.commitTransaction();
+
+
+        RealmResults<Dog> copiedList = realm.where(Dog.class).findAll();
+
+        assertEquals(2, copiedList.size());
+        assertEquals(dog1.getName(), copiedList.get(0).getName());
+        assertEquals(dog2.getName(), copiedList.get(1).getName());
+    }
+
+    @Test
+    public void insert_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.insert(Collections.<PrimaryKeyAsLong>emptyList());
+            }
+        });
+        assertEquals(0, realm.where(PrimaryKeyAsLong.class).count());
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insert_emptyListWithCompositeMediator() {
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .modules(new HumanModule(), new AnimalModule())
+                .name("composite.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), CompositeMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insert(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insert_emptyListWithFilterableMediator() {
+        //noinspection unchecked
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(CatOwner.class, Cat.class)
+                .name("filterable.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), FilterableMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insert(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_list() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+                obj.setId(1);
+                obj.setName("Foo");
+                realm.copyToRealm(obj);
+
+                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
+                obj2.setId(1);
+                obj2.setName("Bar");
+
+                PrimaryKeyAsLong obj3 = new PrimaryKeyAsLong();
+                obj3.setId(1);
+                obj3.setName("Baz");
+
+                realm.insertOrUpdate(Arrays.asList(obj2, obj3));
+            }
+        });
+
+        assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
+        PrimaryKeyAsLong first = realm.where(PrimaryKeyAsLong.class).findFirst();
+        assertNotNull(first);
+        assertEquals("Baz", first.getName());
+    }
+
+    @Test
+    public void insertOrUpdate_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.insertOrUpdate(Collections.<PrimaryKeyAsLong>emptyList());
+            }
+        });
+        assertEquals(0, realm.where(PrimaryKeyAsLong.class).count());
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insertOrUpdate_emptyListWithCompositeMediator() {
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .modules(new HumanModule(), new AnimalModule())
+                .name("composite.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), CompositeMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insertOrUpdate(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insertOrUpdate_emptyListWithFilterableMediator() {
+        //noinspection unchecked
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(CatOwner.class, Cat.class)
+                .name("filterable.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), FilterableMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insertOrUpdate(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_mixingPrimaryKeyAndNoPrimaryKeyModels() {
+        AllTypes objB_no_pk = new AllTypes();
+        objB_no_pk.setColumnString("B");
+
+        PrimaryKeyWithNoPrimaryKeyObjectRelation objA_pk = new PrimaryKeyWithNoPrimaryKeyObjectRelation();
+        objA_pk.setColumnString("A");
+        objA_pk.setColumnRealmObjectNoPK(objB_no_pk);
+
+        realm.beginTransaction();
+        realm.insert(objA_pk);
+        realm.commitTransaction();
+
+        RealmResults<PrimaryKeyWithNoPrimaryKeyObjectRelation> all = realm.where(PrimaryKeyWithNoPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectNoPK());
+        assertEquals("B", all.get(0).getColumnRealmObjectNoPK().getColumnString());
+        assertEquals(1, realm.where(AllTypes.class).findAll().size());
+
+        objA_pk.setColumnInt(42);
+        objB_no_pk.setColumnString("updated B");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objA_pk);
+        realm.commitTransaction();
+
+        all = realm.where(PrimaryKeyWithNoPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(42, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectNoPK());
+        assertEquals("updated B", all.get(0).getColumnRealmObjectNoPK().getColumnString());
+        // since AllTypes doesn't have a PK we now have two instances
+        assertEquals(2, realm.where(AllTypes.class).findAll().size());
+    }
+
+
+    @Test
+    public void insertOrUpdate_mixingNoPrimaryKeyAndPrimaryKeyModels() {
+        AllTypesPrimaryKey objB_pk = new AllTypesPrimaryKey();
+        objB_pk.setColumnLong(7);
+        objB_pk.setColumnString("B");
+
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objA_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objA_no_pk.setColumnRealmObjectPK(objB_pk);
+        objA_no_pk.setColumnString("A");
+
+        realm.beginTransaction();
+        realm.insert(objA_no_pk);
+        realm.commitTransaction();
+
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertEquals(7, all.get(0).getColumnRealmObjectPK().getColumnLong());
+        assertEquals("B", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+
+        objA_no_pk.setColumnString("different A");
+        objA_no_pk.setColumnInt(42);//should insert a new instance
+        // update (since it has a PK) now both AllTypesPrimaryKey points to the same objB_pk instance
+        objB_pk.setColumnString("updated B");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objA_no_pk);
+        realm.commitTransaction();
+
+        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString");
+        assertEquals(2, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertEquals("different A", all.get(1).getColumnString());
+        assertEquals(42, all.get(1).getColumnInt());
+
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertNotNull(all.get(1).getColumnRealmObjectPK());
+
+        assertEquals(7, all.get(0).getColumnRealmObjectPK().getColumnLong());
+        assertEquals(7, all.get(1).getColumnRealmObjectPK().getColumnLong());
+        assertEquals("updated B", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals("updated B", all.get(1).getColumnRealmObjectPK().getColumnString());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+    }
+
+    @Test
+    public void insertOrUpdate_mixingPrimaryAndNoPrimaryKeyList() {
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objA_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objA_no_pk.setColumnString("A");
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objB_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objB_no_pk.setColumnString("B");
+        AllTypesPrimaryKey objC_pk = new AllTypesPrimaryKey();
+        objC_pk.setColumnLong(7);
+        objC_pk.setColumnString("C");
+        AllTypesPrimaryKey objD_pk = new AllTypesPrimaryKey();
+        objD_pk.setColumnLong(7);
+        objD_pk.setColumnString("D");
+
+        objA_no_pk.setColumnRealmObjectPK(objC_pk);
+        objB_no_pk.setColumnRealmObjectPK(objD_pk);
+
+        ArrayList<NoPrimaryKeyWithPrimaryKeyObjectRelation> objects = new ArrayList<NoPrimaryKeyWithPrimaryKeyObjectRelation>(2);
+        objects.add(objA_no_pk);
+        objects.add(objB_no_pk);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objects);
+        realm.commitTransaction();
+
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString", Sort.DESCENDING);
+        assertEquals(2, all.size());
+        assertEquals("B", all.get(0).getColumnString());
+        assertEquals("A", all.get(1).getColumnString());
+
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertNotNull(all.get(1).getColumnRealmObjectPK());
+
+        assertEquals("D", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals("D", all.get(1).getColumnRealmObjectPK().getColumnString());
+
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+    }
+
+    //any omitted argument should not end in a SIGSEGV but an exception
+
+    @Test
+    public void insert_nullObject() {
+        AllTypes nullObject = null;
+
+        realm.beginTransaction();
+        try {
+            //noinspection ConstantConditions
+            realm.insert(nullObject);
+            fail("Should trigger NullPointerException");
+        } catch (IllegalArgumentException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void inset_nullList() {
+        List<AllTypes> nullObjects = null;
+
+        realm.beginTransaction();
+        try {
+            //noinspection ConstantConditions
+            realm.insert(nullObjects);
+            fail("Should trigger IllegalArgumentException");
+        } catch (IllegalArgumentException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insert_listWithNullElement() {
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+        ArrayList<Dog> list = new ArrayList<Dog>();
+        list.addAll(Arrays.asList(dog1, null, dog2));
+
+        realm.beginTransaction();
+        try {
+            realm.insert(list);
+            fail("Should trigger IllegalArgumentException");
+        } catch (NullPointerException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    //Inserting a managed object will result in it being copied or updated again
+    @Test
+    public void insertOrUpdate_managedObject() {
+        AllJavaTypes obj = new AllJavaTypes();
+        obj.setFieldIgnored("cookie");
+        obj.setFieldLong(42);
+        obj.setFieldString("obj1");
+
+        realm.beginTransaction();
+        AllJavaTypes managedAllJavaTypes = realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+
+        AllJavaTypes filedObject = new AllJavaTypes();
+        filedObject.setFieldLong(8);
+        filedObject = realm.copyToRealm(filedObject);
+        managedAllJavaTypes.setFieldObject(filedObject);
+        managedAllJavaTypes.setFieldString("updated");
+
+        realm.insertOrUpdate(managedAllJavaTypes);
+        realm.commitTransaction();
+
+        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 42).findFirst();
+        assertNotNull(first);
+        assertEquals(42, first.getFieldLong(), 0);
+        assertEquals("updated", first.getFieldString());
+        assertNull(first.getFieldIgnored());
+        assertNotNull(first.getFieldObject());
+        assertEquals(8, first.getFieldObject().getFieldLong());
+
+        assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());
+    }
+
+    @Test
+    public void insertOrUpdate_linkingManagedToUnmanagedObject() {
+        realm.beginTransaction();
+        AllJavaTypes managedAllJavaTypes = realm.createObject(AllJavaTypes.class, 42);
+        realm.commitTransaction();
+
+        AllJavaTypes unmanagedObject = new AllJavaTypes(8);
+        unmanagedObject.setFieldObject(managedAllJavaTypes);//Linking managed object to unmanaged object
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(unmanagedObject);
+        realm.commitTransaction();
+
+        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 8).findFirst();
+        assertNotNull(first);
+        assertEquals(8, first.getFieldLong(), 0);
+        assertNotNull(first.getFieldObject());
+        assertEquals(42, first.getFieldObject().getFieldLong());
+        assertEquals(2, realm.where(AllJavaTypes.class).count());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insert_collection_notInTransaction() {
+        realm.insert(Arrays.asList(new AllTypes(), new AllTypes()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insert_object_notInTransaction() {
+        realm.insert(new AllTypes());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insertOrUpdate_collection_notInTransaction() {
+        realm.insert(Arrays.asList(new AllTypesPrimaryKey(), new AllTypesPrimaryKey()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insertOrUpdate_object_notInTransaction() {
+        realm.insert(new AllTypes());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 9898a360d7..d147fd591a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -37,7 +37,7 @@
         MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
     }
 
-    // Enumerate all current supported collections that can be in un-managed mode.
+    // Enumerate all current supported collections that can be in unmanaged mode.
     protected enum UnManagedCollection {
         UNMANAGED_REALMLIST
     }
@@ -138,7 +138,7 @@ private void fillObject(int index, int totalObjects, AllJavaTypes obj) {
         realm.commitTransaction();
 
         OrderedRealmCollection<CyclicType> result;
-        switch(collectionClass) {
+        switch (collectionClass) {
             case MANAGED_REALMLIST:
                 result = parent.getObjects();
                 break;
@@ -190,16 +190,16 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
         realm.beginTransaction();
         realm.deleteAll();
         switch (collectionClass) {
-            case MANAGED_REALMLIST:
+            case REALMRESULTS:
                 int id = 0;
                 for (String arg : args) {
                     AllJavaTypes obj = realm.createObject(AllJavaTypes.class, id++);
                     obj.setFieldString(arg);
                 }
                 realm.commitTransaction();
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
 
-            case REALMRESULTS:
+            case MANAGED_REALMLIST:
                 AllJavaTypes first = realm.createObject(AllJavaTypes.class);
                 first.setFieldString(args[0]);
                 first.getFieldList().add(first);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index e641615090..5efec33d5c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -39,6 +39,7 @@
 import io.realm.entities.PrimaryKeyAsBoxedLong;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -337,10 +338,10 @@ public void findFirstAsync() {
                 .between(AllTypes.FIELD_LONG, 4, 9)
                 .findFirstAsync();
         assertFalse(allTypes.isLoaded());
-
-        allTypes.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(allTypes);
+        allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealmObject object) {
                 assertEquals("test data 4", allTypes.getString(AllTypes.FIELD_STRING));
                 dynamicRealm.close();
                 looperThread.testComplete();
@@ -359,9 +360,9 @@ public void findAllAsync() {
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
-        allTypes.addChangeListener(new RealmChangeListener() {
+        allTypes.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals(6, allTypes.size());
                 for (int i = 0; i < allTypes.size(); i++) {
                     assertEquals("test data " + (4 + i), allTypes.get(i).getString(AllTypes.FIELD_STRING));
@@ -382,9 +383,9 @@ public void findAllSortedAsync() {
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
-        allTypes.addChangeListener(new RealmChangeListener() {
+        allTypes.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals(5, allTypes.size());
                 for (int i = 0; i < 5; i++) {
                     int iteration = (4 - i);
@@ -396,11 +397,12 @@ public void onChange() {
         });
     }
 
-    // Initialize a Dynamic Realm used by the *Async tests.
+    // Initialize a Dynamic Realm used by the *Async tests and keep it ref in the looperThread.
     private DynamicRealm initializeDynamicRealm() {
         RealmConfiguration defaultConfig = looperThread.realmConfiguration;
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
         populateTestRealm(dynamicRealm, 10);
+        looperThread.keepStrongReference.add(dynamicRealm);
         return dynamicRealm;
     }
 
@@ -450,9 +452,9 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 0", realmResults1.get(0).get(AllTypes.FIELD_STRING));
                 assertEquals(3L, realmResults1.get(0).get(AllTypes.FIELD_LONG));
                 assertEquals("data 0", realmResults1.get(1).get(AllTypes.FIELD_STRING));
@@ -480,9 +482,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 2", realmResults2.get(0).get(AllTypes.FIELD_STRING));
                 assertEquals(1L, realmResults2.get(0).get(AllTypes.FIELD_LONG));
                 assertEquals("data 2", realmResults2.get(1).get(AllTypes.FIELD_STRING));
@@ -522,7 +524,7 @@ public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                         post(new Runnable() {
                             @Override
                             public void run() {
@@ -557,7 +559,7 @@ public void deleteAll() {
         realm.beginTransaction();
         realm.createObject(AllTypes.CLASS_NAME);
         DynamicRealmObject cat = realm.createObject(Cat.CLASS_NAME);
-        DynamicRealmObject owner =  realm.createObject(Owner.CLASS_NAME);
+        DynamicRealmObject owner = realm.createObject(Owner.CLASS_NAME);
         owner.setObject("cat", cat);
         realm.getSchema().create("TestRemoveAll").addField("Field1", String.class);
         realm.createObject("TestRemoveAll");
@@ -592,4 +594,74 @@ public void realmListRemoveAllFromRealm() {
         assertEquals(0, list.size());
         assertEquals(0, realm.where(Dog.CLASS_NAME).count());
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            dynamicRealm.close();
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dynamicRealm.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    dynamicRealm.close();
+                }
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
+        final DynamicRealm dynamicRealm = initializeDynamicRealm();
+
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            dynamicRealm.close();
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dynamicRealm.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    dynamicRealm.close();
+                }
+            }
+        });
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
index 1ba7760203..507e7f8edf 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
@@ -19,8 +19,6 @@
 import android.os.Handler;
 import android.os.Message;
 
-import io.realm.HandlerController;
-
 /**
  * Handler decorator, to help intercept some messages before they are sent and received.
  */
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index cc45110462..87d1799643 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -79,7 +79,7 @@ public void iOSDataTypes() throws IOException {
             configFactory.copyRealmFromAssets(context,
                     "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
-            RealmResults<IOSAllTypes> result = realm.allObjectsSorted(IOSAllTypes.class, "id", Sort.ASCENDING);
+            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
             // Verify metadata
             Table table = realm.getTable(IOSAllTypes.class);
             assertTrue(table.hasPrimaryKey());
@@ -113,7 +113,7 @@ public void iOSDataTypesDefaultValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-default.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(0, obj.getShortCol());
             assertEquals(0, obj.getIntCol());
@@ -136,7 +136,7 @@ public void iOSDataTypesNullValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-null-value.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertEquals(null, obj.getByteCol());
             assertEquals(null, obj.getStringCol());
             assertEquals(null, obj.getDateCol());
@@ -152,7 +152,7 @@ public void iOSDataTypesMinimumValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-min.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(Short.MIN_VALUE, obj.getShortCol());
             assertEquals(Integer.MIN_VALUE, obj.getIntCol());
@@ -173,7 +173,7 @@ public void iOSDataTypesMaximumValues() throws IOException {
                     "ios/" + iosVersion + "-alltypes-max.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertEquals(Short.MAX_VALUE, obj.getShortCol());
             assertEquals(Integer.MAX_VALUE, obj.getIntCol());
             assertEquals(Integer.MAX_VALUE, obj.getLongCol());
@@ -198,7 +198,7 @@ public void iOSEncryptedRealm() throws IOException {
                     .build();
             realm = Realm.getInstance(realmConfig);
 
-            IOSAllTypes obj = realm.allObjects(IOSAllTypes.class).first();
+            IOSAllTypes obj = realm.where(IOSAllTypes.class).findFirst();
             assertFalse(obj.isBoolCol());
             assertEquals(0, obj.getShortCol());
             assertEquals(0, obj.getIntCol());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 2b008949ac..2f19f3c5a5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -159,7 +159,7 @@ public void tearDown() {
                         .getFieldList();
 
             case REALMRESULTS:
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -181,7 +181,7 @@ public void tearDown() {
         throw new AssertionError("Unknown collection: " + collectionClass);
     }
 
-   @Test
+    @Test
     public void sort_twoFields() {
         OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
         AllJavaTypes obj = sortedList.first();
@@ -296,7 +296,7 @@ public void sort_rowsWithPartialNullValues() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                RealmResults<NullTypes> objects = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> objects = realm.where(NullTypes.class).findAll();
                 NullTypes parent = realm.createObject(NullTypes.class, 0);
                 for (int i = 0; i < objects.size(); i++) {
                     NullTypes object = objects.get(i);
@@ -310,8 +310,8 @@ public void sort_rowsWithPartialNullValues() {
                 break;
 
             case REALMRESULTS:
-                original = realm.allObjects(NullTypes.class);
-                copy = realm.allObjects(NullTypes.class);
+                original = realm.where(NullTypes.class).findAll();
+                copy = realm.where(NullTypes.class).findAll();
                 break;
 
             default:
@@ -470,7 +470,7 @@ public void sort_usingChildObject() {
     public void sort_nullArguments() {
         OrderedRealmCollection<AllJavaTypes> result = collection;
         try {
-            result.sort(null);
+            result.sort((String) null);
             fail("Sorting with a null field name should throw an IllegalArgumentException");
         } catch (IllegalArgumentException ignored) {
         }
@@ -594,7 +594,7 @@ public void deleteFirstFromRealm() {
                     dog.setName("Dog " + i);
                 }
                 realm.commitTransaction();
-                return realm.allObjects(Dog.class);
+                return realm.where(Dog.class).findAll();
 
             default:
                 throw new AssertionError("Unknown collection class: " + collectionClass);
@@ -674,11 +674,11 @@ public void mutableMethodsOutsideTransactions() {
     @Test
     public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
         for (OrderedRealmCollectionMethod method : OrderedRealmCollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
 
         for (ListMethod method : ListMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 2cf13b2932..0812e5f972 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -26,7 +26,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
@@ -48,7 +47,7 @@
 /**
  * Test class for all methods part of the the {@link RealmCollection} interface.
  * This class only tests collections that are managed by Realm. See {@link UnManagedRealmCollectionTests} for
- * all tests targeting un-managed collections.
+ * all tests targeting unmanaged collections.
  *
  * Methods tested in this class:
  *
@@ -129,7 +128,7 @@ public void tearDown() {
                         .getFieldList();
 
             case REALMRESULTS:
-                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -153,9 +152,9 @@ public void tearDown() {
 
     private OrderedRealmCollection<NullTypes> createAllNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
-        switch(collectionClass) {
+        switch (collectionClass) {
             case MANAGED_REALMLIST:
-                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
                 realm.beginTransaction();
                 for (int i = 0; i < results.size(); i++) {
@@ -174,7 +173,7 @@ public void tearDown() {
         populatePartialNullRowsForNumericTesting(realm);
         switch (collectionClass) {
             case MANAGED_REALMLIST:
-                RealmResults<NullTypes> results = realm.allObjects(NullTypes.class);
+                RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
                 realm.beginTransaction();
                 int size = results.size();
@@ -196,7 +195,7 @@ public void tearDown() {
 
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                RealmResults<NonLatinFieldNames> results = realm.allObjects(NonLatinFieldNames.class);
+                RealmResults<NonLatinFieldNames> results = realm.where(NonLatinFieldNames.class).findAll();
                 RealmList<NonLatinFieldNames> list = results.get(0).getChildren();
                 for (int i = 0; i < results.size(); i++) {
                     list.add(results.get(i));
@@ -205,7 +204,7 @@ public void tearDown() {
                 return list;
 
             case REALMRESULTS:
-                return realm.allObjects(NonLatinFieldNames.class);
+                return realm.where(NonLatinFieldNames.class).findAll();
 
             default:
                 throw new AssertionError("Unknown collection: " + collectionClass);
@@ -399,7 +398,7 @@ public void max_partialNullRows() {
     public void sum() {
         Number sum = collection.sum(AllJavaTypes.FIELD_LONG);
         // Sum of numbers 0 to M-1: (M-1)*M/2
-        assertEquals((TEST_SIZE - 1) * TEST_SIZE/ 2, sum.intValue());
+        assertEquals((TEST_SIZE - 1) * TEST_SIZE / 2, sum.intValue());
     }
 
     // Test sum on nullable rows with all null values
@@ -491,12 +490,14 @@ public void avg_partialNullRows() {
 
     @Test
     public void maxDate() {
-        assertEquals(new Date(YEAR_MILLIS * 20 * 4), collection.maxDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(TEST_SIZE, collection.size());
+        assertEquals(new Date(YEAR_MILLIS * 20 * (TEST_SIZE / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
     public void minDate() {
-        assertEquals(new Date(YEAR_MILLIS * 20 * -5), collection.minDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(TEST_SIZE, collection.size());
+        assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
     }
 
     @Test
@@ -692,10 +693,10 @@ public void mutableMethodsOutsideTransactions() {
     @Test
     public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
         for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
         for (CollectionMethod method : CollectionMethod.values()) {
-            assertTrue(method + " failed" , runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index cbc4e41a74..f3f3c294f4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -81,6 +81,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
+        Realm.asyncTaskExecutor.resume();
         if (realm != null) {
             realm.close();
         }
@@ -136,9 +137,9 @@ public Boolean call() throws Exception {
     @UiThreadTest
     public void removeChangeListener() throws InterruptedException, ExecutionException {
         final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -158,9 +159,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void addChangeListener_duplicatedListener() {
         final AtomicInteger counter = new AtomicInteger(0);
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -168,9 +169,9 @@ public void onChange() {
         Realm realm = looperThread.realm;
         realm.addChangeListener(listener);
         realm.addChangeListener(listener);
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(1, counter.get());
                 looperThread.testComplete();
             }
@@ -187,9 +188,9 @@ public void notificationsNumber() throws InterruptedException, ExecutionExceptio
         final AtomicBoolean isReady = new AtomicBoolean(false);
         final Looper[] looper = new Looper[1];
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
@@ -255,7 +256,8 @@ public void realmResultsStableDuringLooperEvent() throws InterruptedException, E
         final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
         final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
         final Looper[] looper = new Looper[1];
-        final RealmChangeListener listener[] = new RealmChangeListener[1];
+        //noinspection unchecked
+        final RealmChangeListener<Realm>[] listener = new RealmChangeListener[1];
 
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -267,11 +269,11 @@ public Boolean call() throws Exception {
                 Realm realm = null;
                 try {
                     realm = Realm.getInstance(realmConfig);
-                    final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                    final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                     assertEquals(0, dogs.size());
-                    listener[0] = new RealmChangeListener() {
+                    listener[0] = new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             int c = counter.incrementAndGet();
                             results.put(c, dogs.size());
                         }
@@ -302,7 +304,7 @@ public void onChange() {
             dog.setName("Rex " + i);
         }
         realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.close();
 
         try {
@@ -341,7 +343,7 @@ public Boolean call() throws Exception {
                 backgroundLooperStarted.countDown();
 
                 // Random operation in the client code
-                final RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+                final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
                 if (dogs.size() != 0) {
                     return false;
                 }
@@ -384,7 +386,7 @@ public void run() {
             dog.setName("Rex " + i);
         }
         realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.close();
         addHandlerMessages.countDown();
 
@@ -418,9 +420,9 @@ public void handlerNotRemovedToSoon() {
     public void commitTransaction_delayChangeListenerOnSameThread() {
         final AtomicInteger success = new AtomicInteger(0);
         Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(1, success.get());
                 looperThread.testComplete();
             }
@@ -434,9 +436,9 @@ public void onChange() {
     @Test
     @RunTestInLooperThread
     public void emptyCommitTriggerChangeListener() {
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 looperThread.testComplete();
             }
         };
@@ -458,9 +460,9 @@ public void addRemoveListenerConcurrency() {
         // the iterator.next get called
 
         // This one will be added when listener2's onChange called
-        final RealmChangeListener listener1 = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener1 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 7: Last listener called. Should only be called once
                 counter1.incrementAndGet();
 
@@ -475,9 +477,9 @@ public void onChange() {
         };
 
         // This one will be existing in the list all the time
-        final RealmChangeListener listener2 = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener2 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 3: Listener2 called
                 // Listener state [listener2, listener3, listener1]
                 // Listener 1 will not be called this time around
@@ -487,9 +489,9 @@ public void onChange() {
         };
 
         // This one will be removed after first transaction
-        RealmChangeListener listener3 = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener3 = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Step 4: Listener3 called
                 // Listener state [listener2, listener1]
                 counter3.incrementAndGet();
@@ -528,9 +530,9 @@ public void weakReferenceListener() throws InterruptedException {
         final Realm realm = looperThread.realm;
 
         // Setup weak listener
-        RealmChangeListener weakListener = new RealmChangeListener() {
+        RealmChangeListener<Realm> weakListener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 weakCounter.incrementAndGet();
             }
         };
@@ -539,9 +541,9 @@ public void onChange() {
 
         // This is not a weak listener so will be called. When this is triggered the weak references have not been
         // removed yet. So make another change to ensure that they really are removed before validating.
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int count = strongCounter.incrementAndGet();
                 if (count == 1) {
                     realm.beginTransaction();
@@ -556,7 +558,7 @@ public void onChange() {
         });
 
         // Hack: There is no guaranteed way to release the WeakReference, just clear it.
-        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
             weakRef.clear();
         }
 
@@ -575,15 +577,15 @@ public void onChange() {
     public void removingWeakReferenceListener() throws InterruptedException {
         final AtomicInteger counter = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmChangeListener listenerA = new RealmChangeListener() {
+        RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 counter.incrementAndGet();
             }
         };
-        RealmChangeListener listenerB = new RealmChangeListener() {
+        RealmChangeListener<Realm> listenerB = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals(0, counter.get());
                 assertEquals(1, realm.handlerController.weakChangeListeners.size());
                 looperThread.testComplete();
@@ -593,7 +595,7 @@ public void onChange() {
 
         // There is no guaranteed way to release the WeakReference,
         // just clear it.
-        for (WeakReference<RealmChangeListener> weakRef : realm.handlerController.weakChangeListeners) {
+        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
             weakRef.clear();
         }
 
@@ -613,10 +615,10 @@ public void realmNotificationOrder() {
         final AtomicInteger listenerBCalled = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
 
-        final RealmChangeListener listenerA = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
 
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int called = listenerACalled.incrementAndGet();
                 if (called == 2) {
                     assertEquals(2, listenerBCalled.get());
@@ -624,9 +626,9 @@ public void onChange() {
                 }
             }
         };
-        final RealmChangeListener listenerB = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listenerB = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 listenerBCalled.incrementAndGet();
                 if (listenerACalled.get() == 1) {
                     // 2. Reverse order
@@ -663,9 +665,9 @@ public void doNotUseClosedHandler() throws InterruptedException {
             public void run() {
                 Looper.prepare();
                 final Realm realm = Realm.getInstance(realmConfig);
-                RealmChangeListener listener = new RealmChangeListener() {
+                RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         realm.close();
                         handlerNotified.countDown();
                     }
@@ -681,9 +683,9 @@ public void onChange() {
             public void run() {
                 Looper.prepare();
                 Realm realm = Realm.getInstance(realmConfig);
-                RealmChangeListener listener = new RealmChangeListener() {
+                RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         try {
                             fail("This handler should not be notified");
                         } catch (AssertionFailedError e) {
@@ -780,9 +782,9 @@ public void run() {
                     assertionFailedErrors[0] = e;
                 }
                 final Realm backgroundRealm = Realm.getInstance(realmConfig);
-                backgroundRealm.addChangeListener(new RealmChangeListener() {
+                backgroundRealm.addChangeListener(new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         backgroundRealm.close();
                         numberOfInvocation.countDown();
                     }
@@ -832,9 +834,9 @@ public void run() {
             @Override
             public void run() {
                 final Realm mainRealm = Realm.getInstance(realmConfig);
-                mainRealm.addChangeListener(new RealmChangeListener() {
+                mainRealm.addChangeListener(new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         mainRealm.close();
                         numberOfInvocation.countDown();
                     }
@@ -869,18 +871,18 @@ public void run() {
 
                 try {
                     realm[0] = Realm.getInstance(realmConfig);
-                    realm[0].addChangeListener(new RealmChangeListener() {
+                    realm[0].addChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             RealmResults<Dog> dogs; // to keep it as a strong reference
                             switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                                 case 1: {
                                     // first commit
                                     dogs = realm[0].where(Dog.class).findAllAsync();
                                     assertTrue(dogs.load());
-                                    dogs.addChangeListener(new RealmChangeListener() {
+                                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                                         @Override
-                                        public void onChange() {
+                                        public void onChange(RealmResults<Dog> object) {
                                             numberOfAsyncRealmResultsCallbackInvocation.incrementAndGet();
                                         }
                                     });
@@ -937,37 +939,38 @@ public void run() {
         TestHelper.exitOrThrow(executorService, signalTestFinished, signalClosedRealm, backgroundLooper, threadAssertionError);
     }
 
-    // The presence of async RealmResults block any `REALM_CHANGE` notification causing historically the Realm
-    // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
-    // regardless of the presence of an async RealmObject that will delay the `REALM_CHANGE` sometimes
+    // The presence of async RealmResults blocks any `REALM_CHANGE` notification . We make sure in this test that all
+    // Realm listeners will be notified regardless of the presence of an async RealmObject. RealmObjects are special
+    // in the sense that once you got a row accessor to that object, it is automatically up to date as soon as you
+    // call advance_read().
     @Test
     @RunTestInLooperThread
     public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
         final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        looperThread.realm.addChangeListener(new RealmChangeListener() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(final Realm realm) {
                 switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                     case 1: {
                         // first commit
-                        Dog dog = looperThread.realm.where(Dog.class).findFirstAsync();
+                        Dog dog = realm.where(Dog.class).findFirstAsync();
                         assertTrue(dog.load());
-                        dog.addChangeListener(new RealmChangeListener() {
+                        dog.addChangeListener(new RealmChangeListener<Dog>() {
                             @Override
-                            public void onChange() {
+                            public void onChange(Dog dog) {
                             }
                         });
-                        looperThread.keepStrongReference.add(dog);
 
                         new Thread() {
                             @Override
                             public void run() {
-                                Realm realm = Realm.getInstance(looperThread.realmConfiguration);
-                                realm.beginTransaction();
-                                realm.createObject(Dog.class);
-                                realm.commitTransaction();
-                                realm.close();
+                                Realm threadRealm = Realm.getInstance(realm.getConfiguration());
+                                threadRealm.beginTransaction();
+                                threadRealm.createObject(Dog.class);
+                                threadRealm.commitTransaction();
+                                threadRealm.close();
                                 signalClosedRealm.countDown();
                             }
                         }.start();
@@ -986,9 +989,9 @@ public void run() {
         looperThread.postRunnable(new Runnable() {
             @Override
             public void run() {
-                looperThread.realm.beginTransaction();
-                looperThread.realm.createObject(Dog.class);
-                looperThread.realm.commitTransaction();
+                realm.beginTransaction();
+                realm.createObject(Dog.class);
+                realm.commitTransaction();
             }
         });
     }
@@ -1000,9 +1003,9 @@ public void realmListenerAddedAfterCommit() {
         realm.beginTransaction();
         realm.commitTransaction();
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 looperThread.testComplete();
             }
         });
@@ -1012,14 +1015,15 @@ public void onChange() {
     @RunTestInLooperThread
     public void realmResultsListenerAddedAfterCommit() {
         Realm realm = looperThread.realm;
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        results.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
@@ -1037,11 +1041,455 @@ public void realmObjectListenerAddedAfterCommit() {
         obj.setColumnLong(42);
         realm.commitTransaction();
 
-        obj.addChangeListener(new RealmChangeListener() {
+        obj.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes object) {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
+
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            Realm realm = Realm.getInstance(realmConfig);
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.createObject(AllTypes.class);
+                }
+            });
+            realm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void realmListener_realmResultShouldBeSynced() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(1, results.size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                // Change event triggered by deletion in async transaction.
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertEquals(0, results.size());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // We precisely depend on the order of triggering change listeners right now.
+    // So it should be:
+    // 1. Synced object listener
+    // 2. Synced results listener
+    // 3. Global listener
+    // Async listeners are not concerned by this test. Since they are triggered by different event and no advance read
+    // involved.
+    // If this case fails on your code, think twice before changing the test!
+    // https://github.com/realm/realm-java/issues/2408 is related to this test!
+    @Test
+    @RunTestInLooperThread
+    public void callingOrdersOfListeners() {
+        final Realm realm = looperThread.realm;
+        final AtomicInteger count = new AtomicInteger(0);
+
+        final RealmChangeListener<RealmResults<AllTypes>> syncedResultsListener =
+                new RealmChangeListener<RealmResults<AllTypes>>() {
+                    @Override
+                    public void onChange(RealmResults<AllTypes> element) {
+                        // First called
+                        assertEquals(0, count.getAndIncrement());
+                    }
+                };
+
+        final RealmChangeListener<AllTypes> syncedObjectListener = new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                // Second called
+                assertEquals(1, count.getAndIncrement());
+            }
+        };
+        final RealmChangeListener<Realm> globalListener = new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                // third called
+                assertEquals(2, count.getAndIncrement());
+                looperThread.testComplete();
+            }
+        };
+
+
+        realm.beginTransaction();
+        final AllTypes allTypes = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // We need to create one objects first and let the pass the first change event
+        final RealmChangeListener<Realm> initListener = new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Clear the change listeners
+                        realm.removeAllChangeListeners();
+
+                        // Now we can start testing
+                        allTypes.addChangeListener(syncedObjectListener);
+                        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+                        results.addChangeListener(syncedResultsListener);
+                        realm.addChangeListener(globalListener);
+
+                        // Now we trigger those listeners
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                                assertNotNull(allTypes);
+                                allTypes.setColumnLong(42);
+                            }
+                        });
+                    }
+                });
+            }
+        };
+        realm.addChangeListener(initListener);
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 3: Delete object which will make the results contain an invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 4: Posted runnable called.
+    @Test
+    @RunTestInLooperThread(/*step1*/ before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueue() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(1, results.size());
+
+        // Step 2
+        // The transaction later will trigger the results sync, and it should be run before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                // Step 4
+                assertEquals(0, results.size());
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        // Step 3
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertFalse(results.get(0).isValid());
+            }
+        });
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Create a async query, and wait until it finishes
+    // Step 3: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 5: Posted runnable called.
+    @Test
+    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithLoadedAsync() {
+        final AtomicBoolean changedFirstTime = new AtomicBoolean(false);
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        assertEquals(1, results.size());
+
+        looperThread.keepStrongReference.add(asyncResults);
+        asyncResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                if (!changedFirstTime.get()) {
+                    // Step 2
+                    // The transaction later will trigger the results sync, and it should be run before this runnable.
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            // Step 5
+                            assertEquals(0, asyncResults.size());
+                            assertEquals(0, results.size());
+                            looperThread.testComplete();
+                        }
+                    });
+
+                    // Step 3
+                    realm.executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                            assertNotNull(allTypes);
+                            allTypes.deleteFromRealm();
+                            assertEquals(0, realm.where(AllTypes.class).count());
+                            assertFalse(results.get(0).isValid());
+                        }
+                    });
+                    changedFirstTime.set(true);
+                }
+            }
+        });
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Create a async query, and pause it
+    // Step 3: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 5: Posted runnable called.
+    //
+    @Test
+    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithPausedAsync() {
+        final Realm realm = looperThread.realm;
+
+        Realm.asyncTaskExecutor.pause();
+        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        assertEquals(1, results.size());
+
+        // Step 2
+        // The transaction later will trigger the results sync, and it should be run before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                // Step 5
+                assertFalse(asyncResults.isLoaded());
+                assertEquals(0, results.size());
+                looperThread.testComplete();
+            }
+        });
+
+        // Step 3
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertFalse(results.get(0).isValid());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void warnIfMixingSyncWritesAndAsyncQueries() {
+        final Realm realm = looperThread.realm;
+        final AtomicBoolean warningLogged = new AtomicBoolean(false);
+        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger() {
+            @Override
+            public void w(String message) {
+                assertTrue(message.contains("Mixing asynchronous queries with local writes should be avoided."));
+                warningLogged.set(true);
+            }
+        };
+        RealmLog.add(testLogger);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                RealmLog.remove(testLogger);
+                assertTrue(warningLogged.get());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void accessingSyncRealmResultInsideAsyncResultListener() {
+        final Realm realm = looperThread.realm;
+        final AtomicInteger asyncResultCallback = new AtomicInteger(0);
+
+        final RealmResults<AllTypes> syncResults = realm.where(AllTypes.class).findAll();
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                switch (asyncResultCallback.incrementAndGet()) {
+                    case 1:
+                        // Called when first async query completes
+                        assertEquals(0, results.size());
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.createObject(AllTypes.class);
+                            }
+                        });
+                        break;
+
+                    case 2:
+                        // Called after async transaction completes, A REALM_CHANGED event has been triggered,
+                        // async queries have rerun, and listeners are triggered again
+                        assertEquals(1, results.size());
+                        assertEquals(1, syncResults.size()); // If syncResults is not in sync yet, this will fail.
+                        looperThread.testComplete();
+                        break;
+                }
+            }
+        });
+    }
+
+    // If RealmResults are updated just before their change listener are notified, one change listener might
+    // reference another RealmResults that have been advance_read, but not yet called sync_if_needed.
+    // This can result in accessing detached rows and other errors.
+    @Test
+    @RunTestInLooperThread
+    public void accessingSyncRealmResultsInsideAnotherResultListener() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> syncResults1 = realm.where(AllTypes.class).findAll();
+        final RealmResults<AllTypes> syncResults2 = realm.where(AllTypes.class).findAll();
+
+        looperThread.keepStrongReference.add(syncResults1);
+        syncResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(1, syncResults1.size());
+                assertEquals(1, syncResults2.size()); // If syncResults2 is not in sync yet, this will fail.
                 looperThread.testComplete();
             }
         });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(threadName = "IntentService[1]")
+    public void listenersNotAllowedOnIntentServiceThreads() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        // Global listener
+        try {
+            realm.addChangeListener(new RealmChangeListener<Realm>() {
+                @Override
+                public void onChange(Realm element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // RealmResults listener
+        try {
+            results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+                @Override
+                public void onChange(RealmResults<AllTypes> element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Object listener
+        try {
+            obj.addChangeListener(new RealmChangeListener<RealmModel>() {
+                @Override
+                public void onChange(RealmModel element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void listenersNotAllowedOnNonLooperThreads() {
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        // Global listener
+        try {
+            realm.addChangeListener(new RealmChangeListener<Realm>() {
+                @Override
+                public void onChange(Realm element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // RealmResults listener
+        try {
+            results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+                @Override
+                public void onChange(RealmResults<AllTypes> element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Object listener
+        try {
+            obj.addChangeListener(new RealmChangeListener<RealmModel>() {
+                @Override
+                public void onChange(RealmModel element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 0539661a07..7fbed86aca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -94,14 +94,14 @@ public void tearDown() {
 
             case UNMANAGED_REALMLIST:
                 populateRealm(realm, sampleSize);
-                RealmResults<AllJavaTypes> objects = realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
                 RealmList<AllJavaTypes> inMemoryList = new RealmList<AllJavaTypes>();
                 inMemoryList.addAll(objects);
                 return inMemoryList;
 
             case REALMRESULTS:
                 populateRealm(realm, sampleSize);
-                return realm.allObjectsSorted(AllJavaTypes.class, AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -263,7 +263,7 @@ public void iterator_remove() {
             return;
         }
 
-        // un-managed objects are always invalid, but cannot be GC'ed while we have a reference.
+        // Unmanaged objects are always invalid, but cannot be GC'ed while we have a reference.
         // managed objects should not be deleted (= invalid).
         assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
         assertTrue(obj.isValid());
@@ -286,7 +286,7 @@ public void iterator_deleteManagedObjectIndirectly() {
                 assertEquals(TEST_SIZE - 1, collection.size());
                 break;
 
-            // Un-managed collections are not affected by changes to Realm and RealmResult should maintain a stable
+            // Unmanaged collections are not affected by changes to Realm and RealmResult should maintain a stable
             // view until next time sync_if_needed is called.
             case UNMANAGED_REALMLIST:
             case REALMRESULTS:
@@ -313,99 +313,6 @@ public void iterator_removeCalledTwice() {
         it.remove();
     }
 
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void iterator_refreshWhileIterating_nonLooper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case UNMANAGED_REALMLIST:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            case MANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE + 1, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    @UiThreadTest
-    public void iterator_refreshWhileIterating_looper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case MANAGED_REALMLIST:
-            case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void iterator_refreshClearsDeletedObjects() {
-        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
-            return;
-        }
-
-        assertEquals(0, collection.iterator().next().getFieldLong());
-        realm.beginTransaction();
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next(); // First item is a cyclic reference, avoid deleting that
-        AllJavaTypes obj = it.next();
-        assertEquals(1, obj.getFieldLong());
-        obj.deleteFromRealm();
-        realm.commitTransaction();
-        realm.refresh(); // Force a refresh of all Collections
-
-        assertEquals(TEST_SIZE - 1, collection.size());
-
-        it = collection.iterator();
-        it.next();
-        obj = it.next(); // Iterator can no longer access the deleted object
-        assertTrue(obj.isValid());
-        assertEquals(2, obj.getFieldLong());
-    }
-
     @Test
     public void listIterator_empty() {
         collection = createCollection(realm, collectionClass, 0);
@@ -492,7 +399,7 @@ public void listIterator_defaultStartIndex() {
 
     @Test
     public void listIterator_startIndex() {
-        int i = TEST_SIZE/2;
+        int i = TEST_SIZE / 2;
         ListIterator<AllJavaTypes> it = collection.listIterator(i);
 
         assertTrue(it.hasPrevious());
@@ -556,31 +463,6 @@ public void listIterator_transactionBeforeNextItem() {
         }
     }
 
-    @Test
-    public void listIterator_refreshClearsDeletedObjects() {
-        if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
-            return;
-        }
-
-        assertEquals(0, collection.iterator().next().getFieldLong());
-        realm.beginTransaction();
-        Iterator<AllJavaTypes> it = collection.listIterator();
-        it.next(); // First item is a cyclic reference, avoid deleting that
-        AllJavaTypes obj = it.next();
-        assertEquals(1, obj.getFieldLong());
-        obj.deleteFromRealm();
-        realm.commitTransaction();
-        realm.refresh(); // Refresh forces a refresh of all Collections
-
-        assertEquals(TEST_SIZE - 1, collection.size());
-
-        it = collection.iterator();
-        it.next();
-        obj = it.next(); // Iterator can no longer access the deleted object
-        assertTrue(obj.isValid());
-        assertEquals(2, obj.getFieldLong());
-    }
-
     @Test
     public void listIterator_closedRealm_methods() {
         if (skipTest(CollectionClass.UNMANAGED_REALMLIST)) {
@@ -630,72 +512,6 @@ public void listIterator_closedRealm_methods() {
         }
     }
 
-    // TODO Remove once waitForChange is introduced
-    @Test
-    public void listIterator_refreshWhileIterating_nonLooper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case UNMANAGED_REALMLIST:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            case MANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE + 1, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
-    // TODO Remove once waitForChange is introduced
-    @Test
-    @UiThreadTest
-    public void listIterator_refreshWhileIterating_looper() {
-        final CountDownLatch bgDone = new CountDownLatch(1);
-        Iterator<AllJavaTypes> it = collection.iterator();
-        it.next();
-
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(OrderedRealmCollectionIteratorTests.this.realm.getConfiguration());
-                appendElementToCollection(realm, collectionClass);
-                realm.close();
-                bgDone.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDone);
-
-        realm.refresh();
-        switch (collectionClass) {
-            case MANAGED_REALMLIST:
-            case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
-                assertEquals(TEST_SIZE, collection.size());
-                break;
-
-            default:
-                fail("Unknown class: " + collectionClass);
-        }
-    }
-
     @Test
     public void listIterator_deleteManagedObjectIndirectly() {
         realm.beginTransaction();
@@ -962,11 +778,20 @@ public void iterator_realmResultsThrowConcurrentModification() {
 
         // Verify that ConcurrentModification is correctly detected on non-looper threads
         Iterator<AllJavaTypes> it = collection.iterator();
-        realm.beginTransaction();
-        realm.createObject(AllJavaTypes.class, TEST_SIZE);
-        realm.commitTransaction();
-        realm.refresh();
-
+        final CountDownLatch bgDone = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.createObject(AllJavaTypes.class, TEST_SIZE);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+                bgDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDone);
+        realm.waitForChange();
         try {
             it.next();
             fail();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index e7c7235988..4d4665e4d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -37,7 +37,7 @@
 import static org.junit.Assert.fail;
 
 /**
- * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or un-managed.
+ * Test class for all methods specific to OrderedRealmCollections no matter if they are managed or unmanaged.
  *
  * Methods tested in this class:
  *
@@ -151,7 +151,7 @@ public void tearDown() {
 
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
@@ -250,7 +250,7 @@ public void get_indexOutOfBounds() {
         for (Integer index : indexes) {
             try {
                 collection.get(index);
-                fail(index +  " did not throw the expected Exception.");
+                fail(index + " did not throw the expected Exception.");
             } catch (IndexOutOfBoundsException ignored) {
             }
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index f3d627702b..81c4938f31 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -241,7 +241,7 @@ public void namingConvention() {
         anc1.setObject(true);
         realm.commitTransaction();
 
-        AnnotationNameConventions anc2 = realm.allObjects(AnnotationNameConventions.class).first();
+        AnnotationNameConventions anc2 = realm.where(AnnotationNameConventions.class).findFirst();
         assertTrue(anc2.isHasObject());
         assertEquals(1, anc2.getId_object());
         assertEquals(2, anc2.getmObject());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index c4740faeb6..f4707f7486 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -32,6 +32,7 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
@@ -41,6 +42,8 @@
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.instrumentation.MockActivityManager;
+import io.realm.internal.HandlerControllerConstants;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.internal.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
@@ -75,7 +78,7 @@
     @RunTestInLooperThread
     public void executeTransactionAsync() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -86,7 +89,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
-                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals(1, realm.where(Owner.class).count());
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -103,7 +106,7 @@ public void onError(Throwable error) {
     @RunTestInLooperThread
     public void executeTransactionAsync_onSuccess() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -114,7 +117,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
-                assertEquals(1, realm.allObjects(Owner.class).size());
+                assertEquals(1, realm.where(Owner.class).count());
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -125,7 +128,7 @@ public void onSuccess() {
     @RunTestInLooperThread
     public void executeTransactionAsync_onError() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -135,7 +138,7 @@ public void execute(Realm realm) {
         }, new Realm.Transaction.OnError() {
             @Override
             public void onError(Throwable error) {
-                assertEquals(0, realm.allObjects(Owner.class).size());
+                assertEquals(0, realm.where(Owner.class).count());
                 assertNull(realm.where(Owner.class).findFirst());
                 looperThread.testComplete();
             }
@@ -146,7 +149,7 @@ public void onError(Throwable error) {
     @RunTestInLooperThread
     public void executeTransactionAsync_NoCallbacks() throws Throwable {
         final Realm realm = looperThread.realm;
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -155,9 +158,9 @@ public void execute(Realm realm) {
                 owner.setName("Owner");
             }
         });
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 assertEquals("Owner", realm.where(Owner.class).findFirst().getName());
                 looperThread.testComplete();
             }
@@ -173,7 +176,7 @@ public void executeTransactionAsync_exceptionHandling() throws Throwable {
 
         final Realm realm = looperThread.realm;
 
-        assertEquals(0, realm.allObjects(Owner.class).size());
+        assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -279,6 +282,35 @@ public void execute(Realm realm) {
         }, transactionCallback);
     }
 
+    // Test case for https://github.com/realm/realm-java/issues/1893
+    // Ensure that onSuccess is called with the correct Realm version for async transaction.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_asyncQuery() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        assertEquals(0, results.size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                assertEquals(1, realm.where(AllTypes.class).count());
+                assertEquals(1, results.size());
+                looperThread.testComplete();
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                fail();
+            }
+        });
+    }
+
     // ************************************
     // *** promises based async queries ***
     // ************************************
@@ -296,9 +328,10 @@ public void findAllAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        results.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 assertTrue(results.get(0).isValid());
@@ -326,7 +359,7 @@ public void accessingRealmListOnUnloadedRealmObjectShouldThrow() {
     }
 
     @Test
-    public void standaloneObjectAsyncBehaviour() {
+    public void unmanagedObjectAsyncBehaviour() {
         Dog dog = new Dog();
         dog.setName("Akamaru");
         dog.setAge(10);
@@ -380,9 +413,9 @@ public void findAllAsync_withNotification() throws Throwable {
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
-        results.addChangeListener(new RealmChangeListener() {
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 assertTrue(results.get(4).isValid());
@@ -405,10 +438,11 @@ public void findAllAsync_forceLoad() throws Throwable {
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
+        looperThread.keepStrongReference.add(realmResults);
         // notification should be called as well
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(realmResults.isLoaded());
                 assertEquals(5, realmResults.size());
                 looperThread.testComplete();
@@ -457,7 +491,7 @@ public boolean onInterceptInMessage(int what) {
                 switch (what) {
                     // 5. Intercept all messages from other threads. On the first complete, we advance the tread
                     // which will cause the async query to rerun instead of triggering the change listener.
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS:
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                         if (intercepts == 1) {
                             // We advance the Realm so we can simulate a retry
                             realm.beginTransaction();
@@ -480,9 +514,10 @@ public boolean onInterceptInMessage(int what) {
         assertEquals(0, realmResults.size());
 
         // 6. Callback triggered after retry has completed
-        realmResults.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults);
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertEquals(1, numberOfInvocation.incrementAndGet());
                 assertTrue(realmResults.isLoaded());
@@ -514,7 +549,7 @@ public void findAllAsync_batchUpdate() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.getAndIncrement();
-                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
                     // 4. The first time the async queries complete we start an update from
                     // another background thread. This will cause queries to rerun when the
                     // background thread notifies this thread.
@@ -562,9 +597,12 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -583,9 +621,9 @@ public void onChange() {
         });
 
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -621,7 +659,7 @@ public boolean onInterceptInMessage(int what) {
                 // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated]
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         // we advance the Realm so we can simulate a retry
                         if (intercepts == 1) {
                             realm.beginTransaction();
@@ -643,10 +681,12 @@ public boolean onInterceptInMessage(int what) {
         assertFalse(realmResults.isLoaded());
         assertEquals(0, realmResults.size());
 
+        looperThread.keepStrongReference.add(realmResults);
+
         // Add change listener that should only be called once
-        realmResults.addChangeListener(new RealmChangeListener() {
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertTrue(realmResults.isLoaded());
                 assertEquals(6, realmResults.size());
@@ -679,7 +719,7 @@ public void findAllAsync_callerThreadBehind() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.REALM_CHANGED: {
+                    case HandlerControllerConstants.REALM_CHANGED: {
                         // should only intercept the first REALM_CHANGED coming from the
                         // background update thread
 
@@ -689,11 +729,11 @@ public boolean onInterceptInMessage(int what) {
                         // upcoming REALM_CHANGED to batch update all async queries
                         return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
                     }
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
                             // both queries have completed now (& their results should be ignored)
                             // now send the REALM_CHANGED event that should batch update all queries
-                            sendEmptyMessage(HandlerController.REALM_CHANGED);
+                            sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
                         }
                     }
                 }
@@ -701,7 +741,7 @@ public boolean onInterceptInMessage(int what) {
             }
         };
         realm.setHandler(handler);
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
 
         // Create async queries and check they haven't completed
         final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
@@ -725,7 +765,7 @@ public void doInBackground(Realm realm) {
                 realm.commitTransaction();
             }
         }.awaitOrFail();
-        Realm.asyncQueryExecutor.resume();
+        Realm.asyncTaskExecutor.resume();
 
         // Setup change listeners
         final Runnable signalCallbackDone = new Runnable() {
@@ -740,9 +780,12 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
                 assertTrue(realmResults1.isLoaded());
                 assertEquals(12, realmResults1.size());
@@ -751,9 +794,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
                 assertTrue(realmResults2.isLoaded());
                 assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
@@ -777,10 +820,10 @@ public void findFirstAsync() {
         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
         assertFalse(asyncObj.isValid());
         assertFalse(asyncObj.isLoaded());
-
-        asyncObj.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(asyncObj);
+        asyncObj.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(asyncObj.isLoaded());
                 assertTrue(asyncObj.isValid());
                 looperThread.testComplete();
@@ -793,9 +836,10 @@ public void onChange() {
     public void findFirstAsync_initalEmptyRow() throws Throwable {
         Realm realm = looperThread.realm;
         final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(firstAsync);
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(firstAsync.load());
                 assertTrue(firstAsync.isLoaded());
                 assertTrue(firstAsync.isValid());
@@ -827,9 +871,10 @@ public void findFirstAsync_updatedIfsyncRealmObjectIsUpdated() throws Throwable
         assertEquals(0, firstAsync.getColumnLong());
         assertEquals("test data 0", firstAsync.getColumnString());
 
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(firstAsync);
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertEquals("Galacticon", firstAsync.getColumnString());
                 looperThread.testComplete();
             }
@@ -851,9 +896,10 @@ public void findFirstAsync_withNotification() throws Throwable {
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
-        realmResults.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults);
+        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertTrue(realmResults.isLoaded());
                 assertTrue(realmResults.isValid());
                 assertEquals("test data 4", realmResults.getColumnString());
@@ -913,7 +959,7 @@ public void findFirstAsync_retry() throws Throwable {
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                         if (intercepts == 1) {
                             // we advance the Realm so we can simulate a retry
                             realm.beginTransaction();
@@ -944,9 +990,10 @@ public boolean onInterceptInMessage(int what) {
         }
 
         // Add change listener that should only be called once after the retry completed.
-        realmResults.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults);
+        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertEquals(3, numberOfIntercept.get());
                 assertTrue(realmResults.isLoaded());
                 assertEquals(5, realmResults.getColumnLong());
@@ -974,9 +1021,10 @@ public void findAllSortedAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
-        results.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(results.isLoaded());
                 assertEquals(5, results.size());
                 for (int i = 0; i < 5; i++) {
@@ -1009,7 +1057,7 @@ public boolean onInterceptInMessage(int what) {
                 // In order [QueryCompleted, RealmChanged, QueryUpdated]
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (intercepts == 1) {
                             // We advance the Realm so we can simulate a retry before listeners are
                             // called.
@@ -1025,7 +1073,7 @@ public boolean onInterceptInMessage(int what) {
         };
         realm.setHandler(handler);
 
-        // 3. This will add a task to the paused asyncQueryExecutor
+        // 3. This will add a task to the paused asyncTaskExecutor
         final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
                 .between("columnLong", 4, 8)
                 .findAllSortedAsync("columnString", Sort.ASCENDING);
@@ -1036,9 +1084,10 @@ public boolean onInterceptInMessage(int what) {
         // 4. Intercepting the query completed event the first time will
         // cause a commit that should cause the findAllSortedAsync to be re-run.
         // This change listener should only be called with the final result.
-        realmResults.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults);
+        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(3, numberOfIntercept.get());
                 looperThread.testComplete();
             }
@@ -1072,7 +1121,7 @@ public void findAllSortedAsync_batchUpdate() {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (numberOfIntercept.incrementAndGet() == 1) {
                             // 6. The first time the async queries complete we start an update from
                             // another background thread. This will cause queries to rerun when the
@@ -1129,9 +1178,12 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: { // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -1150,9 +1202,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: { // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -1209,7 +1261,7 @@ public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.incrementAndGet();
-                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
                     // 6. The first time the async queries complete we start an update from
                     // another background thread. This will cause queries to rerun when the
                     // background thread notifies this thread.
@@ -1270,9 +1322,12 @@ public void run() {
             }
         };
 
-        realmResults1.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
+        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery1.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults1.isLoaded());
@@ -1319,9 +1374,9 @@ public void onChange() {
             }
         });
 
-        realmResults2.addChangeListener(new RealmChangeListener() {
+        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (numberOfNotificationsQuery2.incrementAndGet()) {
                     case 1: // first callback invocation
                         assertTrue(realmResults2.isLoaded());
@@ -1410,21 +1465,21 @@ public void listenerShouldNotLeak() {
     public void combiningAsyncAndSync() {
         populateTestRealm(looperThread.realm, 10);
 
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
         final RealmResults<AllTypes> allTypesAsync = looperThread.realm.where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
         final RealmResults<AllTypes> allTypesSync = allTypesAsync.where().greaterThan("columnLong", 3).findAll();
 
         assertEquals(0, allTypesAsync.size());
         assertEquals(6, allTypesSync.size());
-        allTypesAsync.addChangeListener(new RealmChangeListener() {
+        allTypesAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(4, allTypesAsync.size());
                 assertEquals(6, allTypesSync.size());
                 looperThread.testComplete();
             }
         });
-        Realm.asyncQueryExecutor.resume();
+        Realm.asyncTaskExecutor.resume();
         looperThread.keepStrongReference.add(allTypesAsync);
     }
 
@@ -1462,9 +1517,9 @@ public void run() {
         };
 
         final RealmResults<AllTypes> allAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
-        allAsync.addChangeListener(new RealmChangeListener() {
+        allAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 assertTrue(allAsync.isLoaded());
                 if (allAsync.size() == NUMBER_OF_COMMITS) {
                     AllTypes lastInserted = looperThread.realm.where(AllTypes.class)
@@ -1495,10 +1550,10 @@ public void distinctAsync() throws Throwable {
         final long numberOfObjects = 10; // must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.distinctAsync(AnnotationIndexTypes.class, "indexBoolean");
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.distinctAsync(AnnotationIndexTypes.class, "indexLong");
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.distinctAsync(AnnotationIndexTypes.class, "indexDate");
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync("indexBoolean");
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync("indexLong");
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync("indexDate");
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -1526,33 +1581,37 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 changeListenerDone.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 changeListenerDone.run();
             }
@@ -1569,7 +1628,7 @@ public void distinctAsync_notIndexedFields() throws Throwable {
 
         for (String fieldName : new String[]{"Boolean", "Long", "Date", "String"}) {
             try {
-                realm.distinctAsync(AnnotationIndexTypes.class, "notIndex" + fieldName);
+                realm.where(AnnotationIndexTypes.class).distinctAsync("notIndex" + fieldName);
                 fail("notIndex" + fieldName);
             } catch (IllegalArgumentException ignored) {
             }
@@ -1581,12 +1640,13 @@ public void distinctAsync_notIndexedFields() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_noneExistingField() throws Throwable {
+        Realm realm = looperThread.realm;
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // must be greater than 1
-        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
             fail();
         } catch (IllegalArgumentException ignored) {
             looperThread.testComplete();
@@ -1596,26 +1656,27 @@ public void distinctAsync_noneExistingField() throws Throwable {
     @Test
     @RunTestInLooperThread
     public void batchUpdateDifferentTypeOfQueries() {
-        looperThread.realm.beginTransaction();
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
         for (int i = 0; i < 5; ) {
-            AllTypes allTypes = looperThread.realm.createObject(AllTypes.class);
+            AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnLong(i);
             allTypes.setColumnString("data " + i % 3);
 
-            allTypes = looperThread.realm.createObject(AllTypes.class);
+            allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnLong(i);
             allTypes.setColumnString("data " + (++i % 3));
         }
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // must be greater than 1
-        looperThread.realm.commitTransaction();
-        populateForDistinct(looperThread.realm, numberOfBlocks, numberOfObjects, false);
+        realm.commitTransaction();
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        RealmResults<AllTypes> findAllAsync = looperThread.realm.where(AllTypes.class).findAllAsync();
-        RealmResults<AllTypes> findAllSorted = looperThread.realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
-        RealmResults<AllTypes> findAllSortedMulti = looperThread.realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
+        RealmResults<AllTypes> findAllAsync = realm.where(AllTypes.class).findAllAsync();
+        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
+        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
                 new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
-        RealmResults<AnnotationIndexTypes> findDistinct = looperThread.realm.distinctAsync(AnnotationIndexTypes.class, "indexString");
+        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
 
         looperThread.keepStrongReference.add(findAllAsync);
         looperThread.keepStrongReference.add(findAllSorted);
@@ -1630,9 +1691,9 @@ public void batchUpdateDifferentTypeOfQueries() {
         final AtomicInteger findAllSortedMultiInvocation = new AtomicInteger(0);
         final AtomicInteger findDistinctInvocation = new AtomicInteger(0);
 
-        findAllAsync.addChangeListener(new RealmChangeListener() {
+        findAllAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllAsyncInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1648,9 +1709,9 @@ public void onChange() {
             }
         });
 
-        findAllSorted.addChangeListener(new RealmChangeListener() {
+        findAllSorted.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllSortedInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1666,9 +1727,9 @@ public void onChange() {
             }
         });
 
-        findAllSortedMulti.addChangeListener(new RealmChangeListener() {
+        findAllSortedMulti.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 switch (findAllSortedMultiInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1684,9 +1745,9 @@ public void onChange() {
             }
         });
 
-        findDistinct.addChangeListener(new RealmChangeListener() {
+        findDistinct.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 switch (findDistinctInvocation.incrementAndGet()) {
                     case 1: {
                         queriesCompleted.countDown();
@@ -1709,7 +1770,7 @@ public void onChange() {
             public void run() {
                 try {
                     queriesCompleted.await();
-                    Realm bgRealm = Realm.getInstance(looperThread.realm.getConfiguration());
+                    Realm bgRealm = Realm.getInstance(realm.getConfiguration());
 
                     bgRealm.beginTransaction();
                     bgRealm.createObject(AllTypes.class);
@@ -1733,9 +1794,10 @@ public void queryingLinkHandover() throws Throwable {
         final Realm realm = looperThread.realm;
 
         final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo("owner.name", "kiba").findAllAsync();
-        allAsync.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(allAsync);
+        allAsync.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 switch (numberOfInvocations.incrementAndGet()) {
                     case 1:
                         assertEquals(0, allAsync.size());
@@ -1758,8 +1820,8 @@ public void doInBackground(Realm realm) {
                         break;
 
                     case 2:
-                        assertEquals(1, realm.allObjects(Dog.class).size());
-                        assertEquals(1, realm.allObjects(Owner.class).size());
+                        assertEquals(1, realm.where(Dog.class).count());
+                        assertEquals(1, realm.where(Owner.class).count());
                         assertEquals(1, allAsync.size());
                         assertTrue(allAsync.isLoaded());
                         assertTrue(allAsync.isValid());
@@ -1789,12 +1851,13 @@ public void testFindFirstUsesCallerThreadVersion() throws Throwable {
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
 
         populateTestRealm(looperThread.realm, 10);
-        Realm.asyncQueryExecutor.pause();
+        Realm.asyncTaskExecutor.pause();
 
         final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
-        firstAsync.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(firstAsync);
+        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
                 assertNotNull(firstAsync);
                 assertEquals("test data 0", firstAsync.getColumnString());
                 looperThread.testComplete(signalClosedRealm);
@@ -1809,7 +1872,7 @@ public void run() {
                 // Advancing the Realm without generating notifications
                 bgRealm.sharedGroupManager.promoteToWrite();
                 bgRealm.sharedGroupManager.commitAndContinueAsRead();
-                Realm.asyncQueryExecutor.resume();
+                Realm.asyncTaskExecutor.resume();
                 bgRealm.close();
                 signalClosedRealm.countDown();
             }
@@ -1822,7 +1885,7 @@ public void run() {
     @UiThreadTest
     public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
         TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
-        RealmConfiguration config  = configFactory.createConfiguration();
+        RealmConfiguration config = configFactory.createConfiguration();
         Realm realm = Realm.getInstance(config);
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
@@ -1925,9 +1988,10 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
 
         // 1. Make sure that async query is not started
         final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
-        result.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(result);
+        result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
                 // be notified once the updated async queries has run.
                 // with the correct
@@ -1947,6 +2011,102 @@ public void onChange() {
         result.load();
     }
 
+    // handlerController#emptyAsyncRealmObject is accessed from different threads
+    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    @Test
+    @UiThreadTest
+    public void concurrentModificationEmptyAsyncRealmObject() {
+        RealmConfiguration config  = configFactory.createConfiguration();
+        final Realm realm = Realm.getInstance(config);
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+
+        realm.beginTransaction();
+        dog1 = realm.copyToRealm(dog1);
+        dog2 = realm.copyToRealm(dog2);
+        realm.commitTransaction();
+
+        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
+        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
+
+        final RealmQuery<Dog> dummyQuery = RealmQuery.createQuery(realm, Dog.class);
+        // Initialize the emptyAsyncRealmObject map, to make sure that iterating is safe
+        // even if we modify the map from a background thread (in case of an empty findFirstAsync)
+        realm.handlerController.emptyAsyncRealmObject.put(weakReference1, dummyQuery);
+
+        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>> iterator = realm.handlerController.emptyAsyncRealmObject.entrySet().iterator();
+        AtomicBoolean fireOnce = new AtomicBoolean(true);
+        while (iterator.hasNext()) {
+            Dog next = (Dog) iterator.next().getKey().get();
+            // add a new Dog from a background thread
+            if (fireOnce.compareAndSet(true, false)) {
+                new Thread() {
+                    @Override
+                    public void run() {
+                        // add a WeakReference to simulate an empty row using a findFirstAsync
+                        // this is added on an Executor thread, hence the dedicated thread
+                        realm.handlerController.emptyAsyncRealmObject.put(weakReference2, dummyQuery);
+                        dogAddFromBg.countDown();
+                    }
+                }.start();
+                TestHelper.awaitOrFail(dogAddFromBg);
+            }
+            assertEquals("Dog 1", next.getName());
+            assertFalse(iterator.hasNext());
+        }
+        realm.close();
+    }
+
+    // handlerController#realmObjects is accessed from different threads
+    // make sure that we iterate over it safely without any race condition (ConcurrentModification)
+    @Test
+    @UiThreadTest
+    public void concurrentModificationRealmObjects() {
+        RealmConfiguration config  = configFactory.createConfiguration();
+        final Realm realm = Realm.getInstance(config);
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+
+        realm.beginTransaction();
+        dog1 = realm.copyToRealm(dog1);
+        dog2 = realm.copyToRealm(dog2);
+        realm.commitTransaction();
+
+        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
+        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
+
+        realm.handlerController.realmObjects.put(weakReference1, Boolean.TRUE);
+
+        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
+        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, Object>> iterator = realm.handlerController.realmObjects.entrySet().iterator();
+        AtomicBoolean fireOnce = new AtomicBoolean(true);
+        while (iterator.hasNext()) {
+            Dog next = (Dog) iterator.next().getKey().get();
+            // add a new Dog from a background thread
+            if (fireOnce.compareAndSet(true, false)) {
+                new Thread() {
+                    @Override
+                    public void run() {
+                        realm.handlerController.realmObjects.put(weakReference2, Boolean.TRUE);
+                        dogAddFromBg.countDown();
+                    }
+                }.start();
+                TestHelper.awaitOrFail(dogAddFromBg);
+            }
+            assertEquals("Dog 1", next.getName());
+            assertFalse(iterator.hasNext());
+        }
+
+        realm.close();
+    }
+
     // *** Helper methods ***
 
     private void populateTestRealm(final Realm testRealm, int objects) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
new file mode 100644
index 0000000000..23f08c5aec
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.rule.UiThreadTestRule;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.pojo.AllTypesRealmModel;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmChangeListenerTests {
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm realm) {
+                assertNotNull(realm);
+                assertFalse(realm.isClosed());
+                looperThread.testComplete();
+            }
+        });
+        realm.beginTransaction();
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmIsNotNull() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        dynamicRealm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
+            @Override
+            public void onChange(DynamicRealm dynRealm) {
+                assertNotNull(dynRealm);
+                assertFalse(dynRealm.isClosed());
+                dynRealm.close();
+                looperThread.testComplete();
+            }
+        });
+        dynamicRealm.beginTransaction();
+        dynamicRealm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmResultsIsNotNull() {
+        Realm realm = looperThread.realm;
+        RealmResults<Cat> cats = realm.where(Cat.class).findAll();
+        looperThread.keepStrongReference.add(cats);
+        cats.addChangeListener(new RealmChangeListener<RealmResults<Cat>>() {
+            @Override
+            public void onChange(RealmResults<Cat> result) {
+                assertEquals("cat1", result.first().getName());
+                looperThread.testComplete();
+            }
+        });
+        realm.beginTransaction();
+        Cat cat = realm.createObject(Cat.class);
+        cat.setName("cat1");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmResultsOfModelIsNotNull() {
+        Realm realm = looperThread.realm;
+        RealmResults<AllTypesRealmModel> alltypes = realm.where(AllTypesRealmModel.class).findAll();
+        looperThread.keepStrongReference.add(alltypes);
+        alltypes.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
+            @Override
+            public void onChange(RealmResults<AllTypesRealmModel> result) {
+                assertEquals("data 1", result.first().columnString);
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        model.columnString = "data 1";
+        realm.commitTransaction();
+    }
+
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmObjectIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        Cat cat = looperThread.realm.createObject(Cat.class);
+        realm.commitTransaction();
+
+        looperThread.keepStrongReference.add(cat);
+        cat.addChangeListener(new RealmChangeListener<Cat>() {
+            @Override
+            public void onChange(Cat object) {
+                assertEquals("cat1", object.getName());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        cat.setName("cat1");
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedRealmModelIsNotNull() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        realm.commitTransaction();
+
+        looperThread.keepStrongReference.add(model);
+        RealmObject.addChangeListener(model, new RealmChangeListener<AllTypesRealmModel>() {
+            @Override
+            public void onChange(AllTypesRealmModel object) {
+                assertEquals("model1", object.columnString);
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        model.columnString = "model1";
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmObjectIsNotNull() {
+        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        realm.close();
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        looperThread.keepStrongReference.add(allTypes);
+        allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
+            @Override
+            public void onChange(DynamicRealmObject object) {
+                assertEquals("test data 1", object.getString(AllTypes.FIELD_STRING));
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+        dynamicRealm.beginTransaction();
+        allTypes.setString(AllTypes.FIELD_STRING, "test data 1");
+        dynamicRealm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void returnedDynamicRealmResultsIsNotNull() {
+        Realm realm = Realm.getInstance(looperThread.realmConfiguration);
+        realm.close();
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        RealmResults<DynamicRealmObject> all = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        looperThread.keepStrongReference.add(all);
+        all.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
+            @Override
+            public void onChange(RealmResults<DynamicRealmObject> result) {
+                assertEquals("test data 1", result.first().getString(AllTypes.FIELD_STRING));
+                dynamicRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        allTypes.setString(AllTypes.FIELD_STRING, "test data 1");
+        dynamicRealm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index b240f6caab..4daa4e751c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -126,7 +126,7 @@ public void tearDown() {
 
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.allObjects(AllJavaTypes.class);
+                return realm.where(AllJavaTypes.class).findAll();
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index f9416a9d88..3b58dcce74 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,17 +16,17 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.test.MoreAsserts;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Field;
@@ -35,12 +35,15 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnimalModule;
+import io.realm.entities.AssetFileModule;
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -57,10 +60,10 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmConfigurationTests {
@@ -255,7 +258,7 @@ public void migration_nullThrows() {
     }
 
     @Test
-    public void setModules_nonRealmModulesThrows() {
+    public void modules_nonRealmModulesThrows() {
         // Test first argument
         try {
             new RealmConfiguration.Builder(configFactory.getRoot()).modules(new Object());
@@ -339,6 +342,23 @@ public void deleteRealmIfMigrationNeeded() {
         assertEquals(0, realm.where(Dog.class).count());
     }
 
+    @Test
+    public void deleteRealmIfMigrationNeeded_failsWhenAssetFileProvided() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // have a builder instance to isolate codepath
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        try {
+            builder
+                    .assetFile(context, "asset_file.realm")
+                    .deleteRealmIfMigrationNeeded();
+            fail();
+        } catch (IllegalStateException expected) {
+            assertEquals("Realm cannot clear its schema when previously configured to use an asset file by calling assetFile().",
+                    expected.getMessage());
+        }
+    }
+
     @Test
     public void upgradeVersionWithNoMigration() {
         realm = Realm.getInstance(defaultConfig);
@@ -764,14 +784,12 @@ public void initialDataTransactionAssetFile() throws IOException {
         Realm.deleteRealm(defaultConfig);
 
         Context context = InstrumentationRegistry.getInstrumentation().getContext();
-        configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", Realm.DEFAULT_REALM_NAME);
         assertTrue(new File(configFactory.getRoot(), Realm.DEFAULT_REALM_NAME).exists());
 
         Realm.Transaction transaction = mock(Realm.Transaction.class);
         RealmConfiguration configuration = configFactory.createConfigurationBuilder()
-                // Just reuse existing file and set right schema
-                .schemaVersion(0)
-                .schema(AllTypes.class)
+                .modules(new AssetFileModule())
                 .initialData(transaction)
                 .build();
 
@@ -779,4 +797,124 @@ public void initialDataTransactionAssetFile() throws IOException {
         realm.close();
         verify(transaction, never()).execute(realm);
     }
+
+    @Test
+    public void assetFileNullAndEmptyFileName() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, null).build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "").build();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileWithInMemoryConfig() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        try {
+            new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm").inMemory().build();
+            fail();
+        } catch (RealmException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileFakeFile() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "no_file").build();
+        try {
+            Realm.getInstance(configuration);
+            fail();
+        } catch (RealmIOException ignored) {
+        }
+    }
+
+    @Test
+    public void assetFileValidFile() throws IOException {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // Ensure that there is no data
+        Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
+
+        RealmConfiguration configuration = new RealmConfiguration
+                .Builder(context)
+                .modules(new AssetFileModule())
+                .assetFile(context, "asset_file.realm")
+                .build();
+        Realm.deleteRealm(configuration);
+
+        File realmFile = new File(configuration.getPath());
+        assertFalse(realmFile.exists());
+
+        realm = Realm.getInstance(configuration);
+        assertTrue(realmFile.exists());
+
+        // Asset file has 10 Owners and 10 Cats, check if data is present
+        assertEquals(10, realm.where(Owner.class).count());
+        assertEquals(10, realm.where(Cat.class).count());
+
+        realm.close();
+
+        // Copy original file to another location
+        configFactory.copyRealmFromAssets(context, "asset_file.realm", "asset_file_copy.realm");
+        File copyFromAsset = new File(configFactory.getRoot(), "asset_file_copy.realm");
+        assertTrue(copyFromAsset.exists());
+
+        Realm.deleteRealm(configuration);
+        assertFalse(realmFile.exists());
+    }
+
+    @Test
+    public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // have a builder instance to isolate codepath
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        try {
+            builder
+                    .deleteRealmIfMigrationNeeded()
+                    .assetFile(context, "asset_file.realm");
+            fail();
+        } catch (IllegalStateException expected) {
+            assertEquals("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().",
+                    expected.getMessage());
+        }
+    }
+
+    private static class MigrationWithNoEquals implements RealmMigration {
+        @Override
+        public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+            // Do nothing
+        }
+    }
+
+    @Test
+    public void detectMissingEqualsInCustomMigration() {
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder().migration(new MigrationWithNoEquals()).build();
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder().migration(new MigrationWithNoEquals()).build();
+
+        Realm realm = Realm.getInstance(config1);
+        try {
+            Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("The most likely cause is that equals() and hashCode() are not overridden"));
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index 4f48119fac..a2ed08b3e1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -73,14 +73,14 @@ public void testInMemoryRealm() {
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
+        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
 
         testRealm.close();
         // After all references to the in-mem-realm closed,
         // in-mem-realm with same identifier should create a fresh new instance.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+        assertEquals(testRealm.where(Dog.class).count(), 0);
 
         StrictMode.enableDefaults();
     }
@@ -103,10 +103,10 @@ public void testInMemoryRealmWithDifferentNames() {
         dog2.setName("UFODog");
         testRealm2.commitTransaction();
 
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm.allObjects(Dog.class).first().getName(), "DinoDog");
-        assertEquals(testRealm2.allObjects(Dog.class).size(), 1);
-        assertEquals(testRealm2.allObjects(Dog.class).first().getName(), "UFODog");
+        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
+        assertEquals(testRealm2.where(Dog.class).count(), 1);
+        assertEquals(testRealm2.where(Dog.class).findFirst().getName(), "UFODog");
 
         testRealm2.close();
     }
@@ -150,13 +150,13 @@ public void testWriteCopyTo() throws IOException {
         // Test a normal Realm file
         testRealm.writeCopyTo(new File(getContext().getFilesDir(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
-        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
 
         // Test a encrypted Realm file
         testRealm.writeEncryptedCopyTo(new File(getContext().getFilesDir(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
-        assertEquals(onDiskRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
         onDiskRealm.close();
         // Test with a wrong key to see if it fails as expected.
         try {
@@ -178,8 +178,8 @@ public void testWriteCopyTo() throws IOException {
     // 4. Close the in-memory Realm instance and the Realm data should be released since no more instance with the
     //    specific name exists.
     public void testMultiThread() throws InterruptedException, ExecutionException {
-        final CountDownLatch workerReadyLatch = new CountDownLatch(1);
-        final CountDownLatch workerFinishedLatch = new CountDownLatch(1);
+        final CountDownLatch workerCommittedLatch = new CountDownLatch(1);
+        final CountDownLatch workerClosedLatch = new CountDownLatch(1);
         final CountDownLatch realmInMainClosedLatch = new CountDownLatch(1);
         final AssertionFailedError threadError[] = new AssertionFailedError[1];
 
@@ -194,13 +194,13 @@ public void run() {
                 realm.commitTransaction();
 
                 try {
-                    assertEquals(realm.allObjects(Dog.class).size(), 1);
+                    assertEquals(realm.where(Dog.class).count(), 1);
                 } catch (AssertionFailedError afe) {
                     threadError[0] = afe;
                     realm.close();
                     return;
                 }
-                workerReadyLatch.countDown();
+                workerCommittedLatch.countDown();
 
                 // Wait until Realm instance closed in main thread
                 try {
@@ -212,19 +212,19 @@ public void run() {
                 }
 
                 realm.close();
-                workerFinishedLatch.countDown();
+                workerClosedLatch.countDown();
             }
         });
         workerThread.start();
 
 
         // Wait until the worker thread started
-        workerReadyLatch.await(3, TimeUnit.SECONDS);
+        workerCommittedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // refresh will be ran in the next loop, manually refresh it here.
-        testRealm.refresh();
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        testRealm.waitForChange();
+        assertEquals(testRealm.where(Dog.class).count(), 1);
 
         // Step 3.
         // Release the main thread Realm reference, and the worker thread hold the reference still
@@ -233,18 +233,18 @@ public void run() {
         // Step 4.
         // Create a new Realm reference in main thread and checking the data.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 1);
+        assertEquals(testRealm.where(Dog.class).count(), 1);
         testRealm.close();
 
         // Let the worker thread continue.
         realmInMainClosedLatch.countDown();
 
         // Wait until the worker thread finished
-        workerFinishedLatch.await(3, TimeUnit.SECONDS);
+        workerClosedLatch.await(3, TimeUnit.SECONDS);
         if (threadError[0] != null) { throw threadError[0]; }
 
         // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.allObjects(Dog.class).size(), 0);
+        assertEquals(testRealm.where(Dog.class).count(), 0);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index cb577ee748..1b80bb1b0f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -280,8 +280,8 @@ public void testCreateInitialRealm() throws InterruptedException {
             @Override
             public void run() {
                 // Step 1
-                testRealm = Realm.getInstance(getContext());
-                assertEquals(testRealm.allObjects(AllTypes.class).size(), 0);
+                testRealm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).build());
+                assertEquals(testRealm.where(AllTypes.class).count(), 0);
                 testRealm.beginTransaction();
                 testRealm.createObject(AllTypes.class);
                 testRealm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
index 81846cd202..c5482eb151 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -16,9 +16,6 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
@@ -64,24 +61,24 @@ public void tearDown() {
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
-             {"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
-            ,{"{ \"id\":null, \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedByte.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj",  PrimaryKeyAsBoxedShort.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedInteger.class}
-            ,{"{ \"name\":\"nullPrimaryKeyObj\" }", "nullPrimaryKeyObj", PrimaryKeyAsBoxedLong.class}
-            ,{"{ \"name\":null, \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
-            ,{"{ \"id\":4299214 }", "4299214", PrimaryKeyAsString.class}
+            {PrimaryKeyAsBoxedByte.class,    "OhThisIsNullKey?!", "{ \"id\":null, \"name\":\"OhThisIsNullKey?!\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "YouBetItIsNullKey", "{ \"id\":null, \"name\":\"YouBetItIsNullKey\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "Gosh Didnt KnowIt", "{ \"id\":null, \"name\":\"Gosh Didnt KnowIt\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "?YOUNOWKNOWRIGHT?", "{ \"id\":null, \"name\":\"?YOUNOWKNOWRIGHT?\" }"},
+            {PrimaryKeyAsBoxedByte.class,    "HaHaHaHaHaHaHaHaH", "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "KeyValueTestIsFun", "{ \"name\":\"KeyValueTestIsFun\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "FunValueTestIsKey", "{ \"name\":\"FunValueTestIsKey\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "NameAsBoxedLong-!", "{ \"name\":\"NameAsBoxedLong-!\" }"},
+            {PrimaryKeyAsString.class,       "4299121",           "{ \"name\":null, \"id\":4299121  }"},
+            {PrimaryKeyAsString.class,       "2429214",           "{ \"id\":2429214 }"}
         });
     }
 
-    final private String jsonString;
-    final private String secondaryFieldValue;
     final private Class<? extends RealmObject> clazz;
+    final private String secondaryFieldValue;
+    final private String jsonString;
 
-    public RealmJsonNullPrimaryKeyTests(String jsonString, String secondFieldValue, Class<? extends RealmObject> clazz) {
+    public RealmJsonNullPrimaryKeyTests(Class<? extends RealmObject> clazz, String secondFieldValue, String jsonString) {
         this.jsonString = jsonString;
         this.secondaryFieldValue = secondFieldValue;
         this.clazz = clazz;
@@ -96,14 +93,14 @@ public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() thro
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
@@ -119,14 +116,14 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObjec
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
@@ -143,14 +140,14 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJso
 
         // PrimaryKeyAsString
         if (clazz.equals(PrimaryKeyAsString.class)) {
-            RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
 
         // PrimaryKeyAsNumber
         } else {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(secondaryFieldValue, ((NullPrimaryKey)results.first()).getName());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 6aec097eea..fbcc2fdcf8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -84,8 +84,8 @@ private InputStream convertJsonObjectToStream(JSONObject obj) {
 
     // Assert that the list of AllTypesPrimaryKey objects where inserted and updated properly.
     private void assertAllTypesPrimaryKeyUpdated() {
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
-        AllTypesPrimaryKey obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Bar", obj.getColumnString());
         assertEquals(2.23F, obj.getColumnFloat(), 0F);
         assertEquals(2.234D, obj.getColumnDouble(), 0D);
@@ -172,13 +172,13 @@ private void checkNullableValuesAreNotNull(NullTypes nullTypes2) {
     @Test
     public void createObject_fromJsonNullObject() {
         realm.createObjectFromJson(AllTypes.class, (JSONObject) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
     public void createAllFromJson_nullArray() {
         realm.createAllFromJson(AllTypes.class, (JSONArray) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
 
     }
 
@@ -195,13 +195,13 @@ public void createObjectFromJson_allSimpleObjectAllTypes() throws JSONException
         realm.beginTransaction();
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
 
         // Check that all primitive types are imported correctly
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
-        assertEquals(1.23F, obj.getColumnFloat(),0F);
-        assertEquals(1.23D, obj.getColumnDouble(),0D);
+        assertEquals(1.23F, obj.getColumnFloat(), 0F);
+        assertEquals(1.23D, obj.getColumnDouble(), 0D);
         assertEquals(true, obj.isColumnBoolean());
         assertArrayEquals(new byte[]{1, 2, 3}, obj.getColumnBinary());
     }
@@ -215,7 +215,7 @@ public void createObjectFromJson_dateAsLong() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -228,7 +228,7 @@ public void createObjectFromJson_dateAsString() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -242,14 +242,14 @@ public void createObjectFromJson_dateAsStringTimeZone() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, json);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         Calendar cal = GregorianCalendar.getInstance();
         cal.setTimeZone(TimeZone.getTimeZone("Australia/West"));
         cal.set(2015, Calendar.OCTOBER, 03, 14, 45, 33);
-        cal.set(Calendar.MILLISECOND, 0);
+        cal.set(Calendar.MILLISECOND, 376);
         Date convDate = obj.getColumnDate();
 
-        assertEquals(convDate.getTime(), cal.getTime().getTime());
+        assertEquals(convDate.getTime(), cal.getTimeInMillis());
     }
 
     @Test
@@ -263,7 +263,7 @@ public void createObjectFromJson_childObject() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Fido", obj.getColumnRealmObject().getName());
     }
 
@@ -283,7 +283,7 @@ public void createObjectFromJson_childObjectList() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(3, obj.getColumnRealmList().size());
         assertEquals("Fido-3", obj.getColumnRealmList().get(2).getName());
     }
@@ -298,7 +298,7 @@ public void createObjectFromJson_emptyChildObjectList() throws JSONException {
         realm.createObjectFromJson(AllTypes.class, allTypesObject);
         realm.commitTransaction();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
@@ -306,10 +306,10 @@ public void createObjectFromJson_emptyChildObjectList() throws JSONException {
     public void createObjectFromJson_stringSimpleObject() {
         realm.beginTransaction();
         Dog dog = realm.createObjectFromJson(Dog.class, "{ name: \"Foo\" }");
-        realm. commitTransaction();
+        realm.commitTransaction();
 
         assertEquals("Foo", dog.getName());
-        assertEquals("Foo", realm.allObjects(Dog.class).first().getName());
+        assertEquals("Foo", realm.where(Dog.class).findFirst().getName());
     }
 
     @Test
@@ -332,7 +332,7 @@ public void createObjectFromJson_stringNull() {
 
         //noinspection ConstantConditions
         assertNull(dog);
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -342,7 +342,7 @@ public void createAllFromJson_jsonArrayEmpty() {
         realm.createAllFromJson(AllTypes.class, array);
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -359,7 +359,7 @@ public void createAllFromJson_jsonArray() throws JSONException {
         realm.createAllFromJson(Dog.class, dogList);
         realm.commitTransaction();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -374,7 +374,7 @@ public void createObjectFromJson_noValues() throws JSONException {
         realm.commitTransaction();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
         assertEquals(0F, obj.getColumnFloat(), 0F);
@@ -401,7 +401,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
             realm.commitTransaction();
         }
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Foo", obj.getColumnString());
         assertEquals(new Date(0), obj.getColumnDate());
     }
@@ -417,7 +417,7 @@ public void createObjectFromJson_respectIgnoredFields() throws JSONException {
         realm.createObjectFromJson(AnnotationTypes.class, json);
         realm.commitTransaction();
 
-        AnnotationTypes annotationsObject = realm.allObjects(AnnotationTypes.class).first();
+        AnnotationTypes annotationsObject = realm.where(AnnotationTypes.class).findFirst();
         assertEquals("Foo", annotationsObject.getIndexString());
         assertEquals(null, annotationsObject.getIgnoreString());
     }
@@ -428,7 +428,7 @@ public void createAllFromJson_stringArraySimpleArray() {
         realm.createAllFromJson(Dog.class, "[{ name: \"Foo\" }, { name: \"Bar\" }]");
         realm.commitTransaction();
 
-        assertEquals(2, realm.allObjects(Dog.class).size());
+        assertEquals(2, realm.where(Dog.class).count());
     }
 
     @Test
@@ -449,7 +449,7 @@ public void createAllFromJson_stringArrayNull() {
         realm.createAllFromJson(Dog.class, (String) null);
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -457,7 +457,7 @@ public void createAllFromJson_stringEmptyArray() {
         realm.beginTransaction();
         realm.createAllFromJson(Dog.class, "");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
     @Test
@@ -466,14 +466,14 @@ public void createAllFromJson_stringNullClass() {
         realm.createAllFromJson(null, "[{ name: \"Foo\" }]");
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
     }
 
 
     @Test
     public void createAllFromJson_streamNull() throws IOException {
         realm.createAllFromJson(AllTypes.class, (InputStream) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -485,7 +485,7 @@ public void createObjectFromJson_streamAllSimpleTypes() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("String", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1.23F, obj.getColumnFloat(), 0F);
@@ -503,7 +503,7 @@ public void createObjectFromJson_streamDateAsLong() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -516,7 +516,7 @@ public void createObjectFromJson_streamDateAsString() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(new Date(1000), obj.getColumnDate());
     }
 
@@ -532,12 +532,10 @@ public void createObjectFromJson_streamDateAsISO8601String() throws IOException
         cal.setTimeZone(TimeZone.getTimeZone("GMT"));
         cal.set(Calendar.MILLISECOND, 789);
         Date date = cal.getTime();
-        cal.set(Calendar.MILLISECOND, 0);
-        Date dateZeroMillis = cal.getTime();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
-        assertEquals(dateZeroMillis, obj.getColumnDate());
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
+        assertEquals(date, obj.getColumnDate());
     }
 
     @Test
@@ -548,7 +546,7 @@ public void createObjectFromJson_streamChildObject() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("Fido", obj.getColumnRealmObject().getName());
     }
 
@@ -560,7 +558,7 @@ public void createObjectFromJson_streamEmptyChildObjectList() throws IOException
         realm.commitTransaction();
         in.close();
 
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals(0, obj.getColumnRealmList().size());
     }
 
@@ -572,7 +570,7 @@ public void createObjectFromJson_streamChildObjectList() throws IOException {
         realm.commitTransaction();
         in.close();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -583,7 +581,7 @@ public void createAllFromJson_streamArray() throws IOException {
         realm.createAllFromJson(Dog.class, in);
         realm.commitTransaction();
 
-        assertEquals(3, realm.allObjects(Dog.class).size());
+        assertEquals(3, realm.where(Dog.class).count());
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
@@ -598,7 +596,7 @@ public void createObjectFromJson_streamNoValues() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        AllTypes obj = realm.allObjects(AllTypes.class).first();
+        AllTypes obj = realm.where(AllTypes.class).findFirst();
         assertEquals("", obj.getColumnString());
         assertEquals(0L, obj.getColumnLong());
         assertEquals(0F, obj.getColumnFloat(), 0F);
@@ -620,7 +618,7 @@ public void createObjectFromJson_streamNullClass() throws IOException {
     }
 
     @Test
-    public void createObjectFromJson_streamNullJson() throws IOException  {
+    public void createObjectFromJson_streamNullJson() throws IOException {
         InputStream in = TestHelper.loadJsonFromAssets(context, "all_types_invalid.json");
         realm.beginTransaction();
         try {
@@ -634,7 +632,7 @@ public void createObjectFromJson_streamNullJson() throws IOException  {
     }
 
     @Test
-    public void createObjectFromJson_streamNullInputStream() throws IOException  {
+    public void createObjectFromJson_streamNullInputStream() throws IOException {
         realm.beginTransaction();
         assertNull(realm.createObjectFromJson(AnnotationTypes.class, (InputStream) null));
         realm.commitTransaction();
@@ -667,7 +665,7 @@ public void createOrUpdateObjectFromJson_streamNullValues() throws IOException {
         in.close();
 
         // Check that all primitive types are imported correctly
-        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1F, obj.getColumnFloat(), 0F);
@@ -753,7 +751,7 @@ public void createOrUpdateObjectFromJson_inputStream() throws IOException {
         AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, in);
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -799,7 +797,7 @@ public void createOrUpdateObjectFromJson_objectNullValues() throws IOException {
         realm.commitTransaction();
 
         // Check that all primitive types are imported correctly
-        obj = realm.allObjects(AllTypesPrimaryKey.class).first();
+        obj = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("1", obj.getColumnString());
         assertEquals(1L, obj.getColumnLong());
         assertEquals(1F, obj.getColumnFloat(), 0F);
@@ -844,7 +842,7 @@ public void createOrUpdateObjectFromJson_inputString() throws IOException {
         AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{ \"columnLong\" : 1, \"columnString\" : \"bar\" }");
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -910,7 +908,7 @@ public void createOrUpdateObjectFromJson_withJsonObject() throws JSONException {
 
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
         assertEquals("bar", newObj.getColumnString());
     }
 
@@ -925,7 +923,7 @@ public void createOrUpdateObjectFromJson_jsonObjectNullClass() throws JSONExcept
         assertNull(realm.createOrUpdateObjectFromJson(null, json));
         realm.commitTransaction();
 
-        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj2 = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Foo", obj2.getColumnString());
     }
 
@@ -934,7 +932,7 @@ public void createOrUpdateObjectFromJson_nullJsonObject() throws JSONException {
         realm.beginTransaction();
         assertNull(realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, (JSONObject) null));
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -951,7 +949,7 @@ public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONExceptio
         } finally {
             realm.commitTransaction();
         }
-        AllTypesPrimaryKey obj2 = realm.allObjects(AllTypesPrimaryKey.class).first();
+        AllTypesPrimaryKey obj2 = realm.where(AllTypesPrimaryKey.class).findFirst();
         assertEquals("Foo", obj2.getColumnString());
     }
 
@@ -985,13 +983,13 @@ public void createOrUpdateAllFromJson_jsonArrayNoPrimaryKeyThrows() {
     @Test
     public void createOrUpdateAllFromJson_jsonNullClass() {
         realm.createOrUpdateAllFromJson(null, new JSONArray());
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
     public void createOrUpdateAllFromJson_jsonNullJson() {
         realm.createOrUpdateAllFromJson(AllTypes.class, (JSONArray) null);
-        assertEquals(0, realm.allObjects(AllTypes.class).size());
+        assertEquals(0, realm.where(AllTypes.class).count());
     }
 
     @Test
@@ -1026,7 +1024,7 @@ public void createOrUpdateAllFromJson_inputStringNullClass() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson((Class<AllTypesPrimaryKey>) null, "{ \"columnLong\" : 1 }");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1034,7 +1032,7 @@ public void createOrUpdateAllFromJson_inputStringNullJson() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, (String) null);
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1042,7 +1040,7 @@ public void createOrUpdateAllFromJson_inputStringEmptyJson() {
         realm.beginTransaction();
         realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "");
         realm.commitTransaction();
-        assertEquals(0, realm.allObjects(AllTypesPrimaryKey.class).size());
+        assertEquals(0, realm.where(AllTypesPrimaryKey.class).count());
     }
 
     @Test
@@ -1096,7 +1094,7 @@ public void createAllFromJson_nullTypesJsonWithNulls() throws IOException, JSONE
         realm.createAllFromJson(NullTypes.class, array);
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
@@ -1113,7 +1111,7 @@ public void createAllFromJson_nullTypesStreamJSONWithNulls() throws IOException
         realm.createAllFromJson(NullTypes.class, TestHelper.loadJsonFromAssets(context, "nulltypes.json"));
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
@@ -1140,7 +1138,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
         realm.createObjectFromJson(NullTypes.class, jsonObject);
         realm.commitTransaction();
 
-        RealmResults<NullTypes> nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(2, nullTypesRealmResults.size());
         checkNullableValuesAreNotNull(nullTypesRealmResults.first());
 
@@ -1150,7 +1148,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
         realm.createOrUpdateAllFromJson(NullTypes.class, array);
         realm.commitTransaction();
 
-        nullTypesRealmResults = realm.allObjects(NullTypes.class);
+        nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(3, nullTypesRealmResults.size());
 
         NullTypes nullTypes1 = nullTypesRealmResults.where().equalTo("id", 1).findFirst();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 1f8a17870f..fd1af8a287 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -16,7 +16,13 @@
 
 package io.realm;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 
@@ -24,16 +30,29 @@
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmLinkTests {
 
-public class RealmLinkTests extends AndroidTestCase {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    protected Realm testRealm;
+    private Realm testRealm;
+    private RealmConfiguration realmConfig;
 
-    protected void setUp() {
-        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
-        Realm.deleteRealm(realmConfig);
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
         testRealm = Realm.getInstance(realmConfig);
 
+        populate();
+    }
+
+    private void populate() {
         testRealm.beginTransaction();
         testRealm.delete(Dog.class);
         testRealm.delete(Cat.class);
@@ -76,13 +95,16 @@ protected void setUp() {
         testRealm.commitTransaction();
     }
 
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
+    @After
+    public void tearDown() {
+        if (testRealm != null) {
+            testRealm.close();
+        }
     }
 
-    public void testObjects() {
-        RealmResults<Owner> owners = testRealm.allObjects(Owner.class);
+    @Test
+    public void objects() {
+        RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         assertEquals(1, owners.size());
         assertEquals(2, owners.first().getDogs().size());
         assertEquals("Pluto", owners.first().getDogs().first().getName());
@@ -90,19 +112,20 @@ public void testObjects() {
         assertEquals("Blackie", owners.first().getCat().getName());
         assertEquals(12, owners.first().getCat().getAge());
 
-        RealmResults<Dog> dogs = testRealm.allObjects(Dog.class);
+        RealmResults<Dog> dogs = testRealm.where(Dog.class).findAll();
         assertEquals(2, dogs.size());
         for (Dog dog : dogs) {
             assertEquals("Tim", dog.getOwner().getName());
         }
 
-        RealmResults<Cat> cats = testRealm.allObjects(Cat.class);
+        RealmResults<Cat> cats = testRealm.where(Cat.class).findAll();
         assertEquals(1, cats.size());
         assertEquals("Tim", cats.first().getOwner().getName());
     }
 
 
-    public void testReamListQuery() {
+    @Test
+    public void reamListQuery() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         RealmResults<Dog> dogs = owners.get(0).getDogs().where().contains("name", "o").findAll();
         assertEquals(2, dogs.size());
@@ -110,7 +133,8 @@ public void testReamListQuery() {
         assertEquals("Fido", dogs.get(1).getName());
     }
 
-    public void testQuerySingleRelationBoolean() {
+    @Test
+    public void querySingleRelationBoolean() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat.hasTail", true).findAll();
         assertEquals(1, owners.size());
         assertEquals(12, owners.first().getCat().getAge());
@@ -119,7 +143,8 @@ public void testQuerySingleRelationBoolean() {
         assertEquals(0, none.size());
     }
 
-    public void testQuerySingleRelationInteger() {
+    @Test
+    public void querySingleRelationInteger() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.age", 12).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -157,7 +182,8 @@ public void testQuerySingleRelationInteger() {
         }
     }
 
-    public void testQuerySingleRelationDate() {
+    @Test
+    public void querySingleRelationDate() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.birthday", new Date(6000)).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -196,7 +222,8 @@ public void testQuerySingleRelationDate() {
         }
     }
 
-    public void testQuerySingleRelationFloat() {
+    @Test
+    public void querySingleRelationFloat() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("cat.height", 0.2f).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -223,12 +250,12 @@ public void testQuerySingleRelationFloat() {
 
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.height", 0.2f, 2.2f).findAll();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-    public void testQuerySingleRelationDouble() {
+    @Test
+    public void querySingleRelationDouble() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("cat.weight", 0.2).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -256,13 +283,12 @@ public void testQuerySingleRelationDouble() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("cat.weight", 0.2, 2.2).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-
-    public void testQuerySingleRelationString() {
+    @Test
+    public void querySingleRelationString() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, owners1.size());
 
@@ -288,7 +314,8 @@ public void testQuerySingleRelationString() {
         assertEquals(1, owners6.size());
     }
 
-    public void testQueryMultipleRelationsBoolean() {
+    @Test
+    public void queryMultipleRelationsBoolean() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("dogs.hasTail", true).findAll();
         assertEquals(1, owners.size());
 
@@ -296,7 +323,8 @@ public void testQueryMultipleRelationsBoolean() {
         assertEquals(0, none.size());
     }
 
-    public void testQueryMultipleRelationsInteger() {
+    @Test
+    public void queryMultipleRelationsInteger() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.age", 10).findAll();
         assertEquals(1, owners1.size());
 
@@ -328,7 +356,8 @@ public void testQueryMultipleRelationsInteger() {
         }
     }
 
-    public void testQueryMultipleRelationsDate() {
+    @Test
+    public void queryMultipleRelationsDate() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.birthday", new Date(2000)).findAll();
         assertEquals(1, owners1.size());
 
@@ -361,7 +390,8 @@ public void testQueryMultipleRelationsDate() {
         }
     }
 
-    public void testQueryMultipleRelationsFloat() {
+    @Test
+    public void queryMultipleRelationsFloat() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("dogs.height", 0.2f).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -389,12 +419,12 @@ public void testQueryMultipleRelationsFloat() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.height", 0.2f, 2.2f).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-    public void testQueryMultipleRelationsDouble() {
+    @Test
+    public void queryMultipleRelationsDouble() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("dogs.weight", 0.2).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -422,13 +452,12 @@ public void testQueryMultipleRelationsDouble() {
         try {
             RealmResults<Owner> owners7 = testRealm.where(Owner.class).between("dogs.weight", 0.2, 12.2).findAll();
             fail();
-        }
-        catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException ignored) {
         }
     }
 
-
-    public void testQueryMultipleRelationsString() {
+    @Test
+    public void queryMultipleRelationsString() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.name", "Pluto").findAll();
         assertEquals(1, owners1.size());
 
@@ -451,7 +480,8 @@ public void testQueryMultipleRelationsString() {
         assertEquals(0, owners5.size());
     }
 
-    public void testQueryShouldFail() {
+    @Test
+    public void queryShouldFail() {
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat..hasTail", true).findAll();
             fail("Should throw Exception");
@@ -474,8 +504,9 @@ public void testQueryShouldFail() {
         }
     }
 
-    public void testWhere() throws Exception {
-        RealmResults<Owner> owners = testRealm.allObjects(Owner.class);
+    @Test
+    public void where() throws Exception {
+        RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         RealmResults<Dog> dogs = owners.first().getDogs().where().equalTo("name", "Pluto").findAll();
         assertEquals(1, dogs.size());
         assertEquals("Pluto", dogs.first().getName());
@@ -485,13 +516,15 @@ public void testWhere() throws Exception {
         assertEquals(0, none.size());
     }
 
-    public void testSubquery() {
+    @Test
+    public void subquery() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("dogs.name", "Pluto").findAll();
         RealmResults<Owner> subOwners = owners.where().equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, subOwners.size());
     }
 
-    public void testLinkIsNull() {
+    @Test
+    public void linkIsNull() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("cat").findAll();
         assertEquals(0, owners1.size());
 
@@ -503,7 +536,8 @@ public void testLinkIsNull() {
         assertEquals(1, owners2.size());
     }
 
-    public void testLinkIsNotNull() {
+    @Test
+    public void linkIsNotNull() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("cat").findAll();
         assertEquals(1, owners1.size());
 
@@ -515,7 +549,8 @@ public void testLinkIsNotNull() {
         assertEquals(0, owners2.size());
     }
 
-    public void testIsNullWrongType() {
+    @Test
+    public void isNullWrongType() {
         try {
             // AllTypes.columnFloat is not nullable
             testRealm.where(AllTypes.class).isNull("columnFloat").findAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index d049d3dc8a..1230a7c761 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -86,7 +86,7 @@ public void tearDown() throws Exception {
         }
     }
 
-    private RealmList<Dog> createNonManagedDogList() {
+    private RealmList<Dog> createUnmanagedDogList() {
         RealmList<Dog> list = new RealmList<Dog>();
         for (int i = 0; i < TEST_SIZE; i++) {
             list.add(new Dog("Dog " + i));
@@ -106,25 +106,25 @@ public void tearDown() throws Exception {
 
             //noinspection TryWithIdenticalCatches
     /*********************************************************
-     * Un-managed mode tests                                *
+     * Unmanaged mode tests                                *
      *********************************************************/
 
     @Test(expected = IllegalArgumentException.class)
-    public void constructor_nonManaged_null() {
+    public void constructor_unmanaged_null() {
         AllTypes[] args = null;
         //noinspection ConstantConditions
         new RealmList<AllTypes>(args);
     }
 
     @Test
-    public void isValid_nonManagedMode() {
+    public void isValid_unmanagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         assertFalse(list.isValid());
     }
 
     @Test
-    public void add_nonManagedMode() {
+    public void add_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -134,12 +134,12 @@ public void add_nonManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullInNonManagedMode() {
+    public void add_nullInUnmanagedMode() {
         new RealmList<AllTypes>().add(null);
     }
 
     @Test
-    public void add_managedObjectInNonManagedMode() {
+    public void add_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         realm.beginTransaction();
         AllTypes managedAllTypes = realm.createObject(AllTypes.class);
@@ -150,7 +150,7 @@ public void add_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void add_standaloneObjectAtIndexInNonManagedMode() {
+    public void add_unmanagedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object = new AllTypes();
         object.setColumnString("String");
@@ -160,7 +160,7 @@ public void add_standaloneObjectAtIndexInNonManagedMode() {
     }
 
     @Test
-    public void add_managedObjectAtIndexInNonManagedMode() {
+    public void add_managedObjectAtIndexInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -182,12 +182,12 @@ public void add_objectAtIndexInManagedMode() {
     }
 
     @Test (expected = IllegalArgumentException.class)
-    public void add_nullAtIndexInNonManagedMode() {
+    public void add_nullAtIndexInUnmanagedMode() {
         new RealmList<AllTypes>().add(0, null);
     }
 
     @Test
-    public void set_nonManagedMode() {
+    public void set_unmanagedMode() {
         RealmList<Dog> list = new RealmList<Dog>();
         Dog dog1 = new Dog("dog1");
         Dog dog2 = new Dog("dog2");
@@ -214,7 +214,7 @@ public void set_managedMode() {
     }
 
     @Test
-    public void set_nullInNonManagedMode() {
+    public void set_nullInUnmanagedMode() {
         @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
@@ -223,7 +223,7 @@ public void set_nullInNonManagedMode() {
     }
 
     @Test
-    public void set_managedObjectInNonManagedMode() {
+    public void set_managedObjectInUnmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         realm.beginTransaction();
@@ -235,7 +235,7 @@ public void set_managedObjectInNonManagedMode() {
     }
 
     @Test
-    public void clear_nonManagedMode() {
+    public void clear_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         list.add(new AllTypes());
         assertEquals(1, list.size());
@@ -244,7 +244,7 @@ public void clear_nonManagedMode() {
     }
 
     @Test
-    public void remove_nonManagedMode() {
+    public void remove_unmanagedMode() {
         RealmList<AllTypes> list = new RealmList<AllTypes>();
         AllTypes object1 = new AllTypes();
         list.add(object1);
@@ -281,8 +281,8 @@ public void move_up() {
 
     // Test move where oldPosition > newPosition
     @Test
-    public void move_downInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_downInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         Dog dog1 = dogs.get(1);
         dogs.move(1, 0);
 
@@ -291,8 +291,8 @@ public void move_downInNonManagedMode() {
 
     // Test move where oldPosition < newPosition
     @Test
-    public void move_upInNonManagedMode() {
-        RealmList<Dog> dogs = createNonManagedDogList();
+    public void move_upInUnmanagedMode() {
+        RealmList<Dog> dogs = createUnmanagedDogList();
         int oldIndex = TEST_SIZE / 2;
         int newIndex = oldIndex + 1;
         Dog dog = dogs.get(oldIndex);
@@ -371,9 +371,9 @@ public void add_managedObjectToManagedList() {
         assertEquals(1, realm.where(Owner.class).findFirst().getDogs().size());
     }
 
-    // Test that add correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that add correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void add_nonManagedObjectToManagedList() {
+    public void add_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.createObject(CyclicType.class);
         RealmList<CyclicType> children = parent.getObjects();
@@ -382,9 +382,9 @@ public void add_nonManagedObjectToManagedList() {
         assertEquals(1, realm.where(CyclicType.class).findFirst().getObjects().size());
     }
 
-    // Make sure that standalone objects with a primary key are added using copyToRealmOrUpdate
+    // Make sure that unmanaged objects with a primary key are added using copyToRealmOrUpdate
     @Test
-    public void add_nonManagedPrimaryKeyObjectToManagedList() {
+    public void add_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         realm.copyToRealm(new CyclicTypePrimaryKey(2, "original"));
         RealmList<CyclicTypePrimaryKey> children = realm.copyToRealm(new CyclicTypePrimaryKey(1)).getObjects();
@@ -395,9 +395,9 @@ public void add_nonManagedPrimaryKeyObjectToManagedList() {
         assertEquals("new", realm.where(CyclicTypePrimaryKey.class).equalTo("id", 2).findFirst().getName());
     }
 
-    // Test that set correctly uses Realm.copyToRealm() on standalone objects.
+    // Test that set correctly uses Realm.copyToRealm() on unmanaged objects.
     @Test
-    public void set_nonManagedObjectToManagedList() {
+    public void set_unmanagedObjectToManagedList() {
         realm.beginTransaction();
         CyclicType parent = realm.copyToRealm(new CyclicType("Parent"));
         RealmList<CyclicType> children = parent.getObjects();
@@ -413,9 +413,9 @@ public void set_nonManagedObjectToManagedList() {
         assertEquals(5, realm.where(CyclicType.class).count());
     }
 
-    // Test that set correctly uses Realm.copyToRealmOrUpdate() on standalone objects with a primary key.
+    // Test that set correctly uses Realm.copyToRealmOrUpdate() on unmanaged objects with a primary key.
     @Test
-    public void  set_nonManagedPrimaryKeyObjectToManagedList() {
+    public void set_unmanagedPrimaryKeyObjectToManagedList() {
         realm.beginTransaction();
         CyclicTypePrimaryKey parent = realm.copyToRealm(new CyclicTypePrimaryKey(1, "Parent"));
         RealmList<CyclicTypePrimaryKey> children = parent.getObjects();
@@ -594,7 +594,7 @@ public void removeAll_managedMode_wrongClass() {
 
     @Test
     public void removeAll_unmanaged_wrongClass() {
-        RealmList<Dog> list = createNonManagedDogList();
+        RealmList<Dog> list = createUnmanagedDogList();
         //noinspection SuspiciousMethodCalls
         assertFalse(list.removeAll(Collections.singletonList(new Cat())));
     }
@@ -689,9 +689,9 @@ public void clear() {
     public void clear_notDeleting() {
         Owner owner = realm.where(Owner.class).findFirst();
         realm.beginTransaction();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         owner.getDogs().clear();
-        assertEquals(TEST_SIZE, realm.allObjects(Dog.class).size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
         realm.commitTransaction();
     }
 
@@ -876,14 +876,14 @@ public void run() {
                 }
 
                 try {
-                    list.add(0,dynDog);
+                    list.add(0, dynDog);
                     fail();
                 } catch (IllegalStateException expected) {
                     assertEquals(expectedMsg, expected.getMessage());
                 }
 
                 try {
-                    list.set(0,dynDog);
+                    list.set(0, dynDog);
                     fail();
                 } catch (IllegalStateException expected) {
                     assertEquals(expectedMsg, expected.getMessage());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index b90e014ccd..ccfacdc351 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -47,11 +47,20 @@
 import io.realm.entities.PrimaryKeyAsShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.entities.migration.MigrationClassRenamed;
+import io.realm.entities.migration.MigrationFieldRenamed;
+import io.realm.entities.migration.MigrationFieldTypeToInt;
+import io.realm.entities.migration.MigrationFieldTypeToInteger;
+import io.realm.entities.migration.MigrationPosteriorIndexOnly;
+import io.realm.entities.migration.MigrationPriorIndexOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.Table;
+import io.realm.migration.MigrationPrimaryKey;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -226,6 +235,440 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
+    /**
+     * Builds a temporary schema to be modified later in a migration. {@link MigrationPrimaryKey} is
+     * the base class when specified.
+     *
+     * <p>MigrationPrimaryKey is supposed to be a RealmObject, but that would hamper our steps toward
+     * testing migrations as Realm looks for it in migration. It is thus set to be an interface.
+     *
+     * @param className a class whose schema is to be re-created
+     * @param createBase create a schema named "MigrationPrimaryKey" instead of {@code className} if {@code true}
+     */
+    private void buildInitialMigrationSchema(final String className, final boolean createBase) {
+        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // first, remove an existing schema
+                realm.getSchema().remove(className);
+                // then recreate the deleted schema or build a base schema
+                realm.getSchema()
+                        .create(createBase ? MigrationPrimaryKey.CLASS_NAME : className)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class, FieldAttribute.PRIMARY_KEY)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        });
+        realm.close();
+    }
+
+    // Test to show renaming a class does not hinder its PK field's attribute
+    @Test
+    public void renameClassTransferPrimaryKey() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .rename(MigrationPrimaryKey.CLASS_NAME, MigrationClassRenamed.CLASS_NAME);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        //old schema does not exist
+        assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
+    }
+
+    @Test
+    public void rename_noSimilarPrimaryKeyWithOldSchema() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // Let us rename the old schema.
+                realm.getSchema()
+                        .rename(MigrationPrimaryKey.CLASS_NAME, MigrationClassRenamed.CLASS_NAME);
+
+                // Then recreate the original schema to see if Realm is going to get confused.
+                // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
+                realm.getSchema()
+                        .create(MigrationPrimaryKey.CLASS_NAME)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+    }
+
+    // Test to show that renaming a class does not effect the primary key
+    @Test
+    public void setClassName_transferPrimaryKey() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        .setClassName(MigrationClassRenamed.CLASS_NAME);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        //old schema does not exist
+        assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
+    }
+
+    @Test
+    public void setClassName_noSimilarPrimaryKeyWithOldSchema() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // Let us set a new class name
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        .setClassName(MigrationClassRenamed.CLASS_NAME);
+
+                // Then recreate the original schema to see if Realm is going to get confused.
+                // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
+                realm.getSchema()
+                        .create(MigrationPrimaryKey.CLASS_NAME)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+    }
+
+    @Test
+    public void setClassName_throwOnLongClassName() {
+        // create the first version of schema
+        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.getSchema().create(MigrationPrimaryKey.CLASS_NAME);
+            }
+        });
+        realm.close();
+
+        // get ready for the 2nd version migration
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        // 57 characters
+                        .setClassName("MigrationNameIsLongerThan56charThisShouldThrowAnException");
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // create Realm instance fails
+        try {
+            Realm.getInstance(realmConfig);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Class name is to long. Limit is 56 characters: 'MigrationNameIsLongerThan56charThisShouldThrowAnException' (57)",
+                    expected.getMessage());
+        }
+    }
+
+    // Removing fields before a pk field does not affect the pk
+    @Test
+    public void removeFieldsBeforePrimaryKey() {
+        buildInitialMigrationSchema(MigrationPosteriorIndexOnly.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationPosteriorIndexOnly.CLASS_NAME)
+                        .removeField(MigrationPrimaryKey.FIELD_FIRST)
+                        .removeField(MigrationPrimaryKey.FIELD_SECOND);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationPosteriorIndexOnly.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        Table table = realm.getSchema().getTable(MigrationPosteriorIndexOnly.class);
+
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationPosteriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+    }
+
+    // Removing fields after a pk field does not affect the pk
+    @Test
+    public void removeFieldsAfterPrimaryKey() {
+        buildInitialMigrationSchema(MigrationPriorIndexOnly.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationPriorIndexOnly.CLASS_NAME)
+                        .removeField(MigrationPrimaryKey.FIELD_FOURTH)
+                        .removeField(MigrationPrimaryKey.FIELD_FIFTH);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationPriorIndexOnly.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        Table table = realm.getSchema().getTable(MigrationPriorIndexOnly.class);
+
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationPriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationPriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+    }
+
+    // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys
+    @Test
+    public void renamePrimaryKeyFieldInMigration() {
+        buildInitialMigrationSchema(MigrationFieldRenamed.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldRenamed.CLASS_NAME)
+                        .renameField(MigrationPrimaryKey.FIELD_PRIMARY, MigrationFieldRenamed.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldRenamed.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldRenamed.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+    }
+
+    private void createObjectsWithOldPrimaryKey(final String className, final boolean insertNullValue) {
+        DynamicRealm realm = DynamicRealm.getInstance(configFactory.createConfigurationBuilder().build());
+        try {
+            realm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    realm.createObject(className).setString(MigrationPrimaryKey.FIELD_PRIMARY, "12");
+                    if (insertNullValue) {
+                        realm.createObject(className).setString(MigrationPrimaryKey.FIELD_PRIMARY, null);
+                    }
+                }
+            });
+        } finally {
+            realm.close();
+        }
+    }
+
+    // This is to test how PK type can change to non-nullable int in migration
+    @Test
+    public void modifyPrimaryKeyFieldTypeToIntInMigration() {
+        final String TEMP_FIELD_ID = "temp_id";
+        buildInitialMigrationSchema(MigrationFieldTypeToInt.CLASS_NAME, false);
+        // create objects with the schema provided
+        createObjectsWithOldPrimaryKey(MigrationFieldTypeToInt.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldTypeToInt.CLASS_NAME)
+                        .addField("temp_id", int.class)
+                        .transform(new RealmObjectSchema.Function() {
+                            @Override
+                            public void apply(DynamicRealmObject obj) {
+                                String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);
+                                if (fieldValue != null && fieldValue.length() != 0) {
+                                    obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue).intValue());
+                                } else {
+                                    // Since this cannot be accepted as proper pk value, we'll delete it.
+                                    // *You can modify with some other value such as 0, but that's not
+                                    // counted in this scenario.
+                                    obj.deleteFromRealm();
+                                }
+                            }
+                        })
+                        .removeField(MigrationPrimaryKey.FIELD_PRIMARY)
+                        .renameField(TEMP_FIELD_ID, MigrationFieldTypeToInt.FIELD_PRIMARY)
+                        .addPrimaryKey(MigrationFieldTypeToInt.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldTypeToInt.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldTypeToInt.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldTypeToInt.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInt.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldTypeToInt.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertEquals(1, realm.where(MigrationFieldTypeToInt.class).count());
+        assertEquals(12, realm.where(MigrationFieldTypeToInt.class).findFirst().fieldIntPrimary);
+    }
+
+    // This is to test how PK type can change to nullable Integer in migration
+    @Test
+    public void modifyPrimaryKeyFieldTypeToIntegerInMigration() {
+        final String TEMP_FIELD_ID = "temp_id";
+        buildInitialMigrationSchema(MigrationFieldTypeToInteger.CLASS_NAME, false);
+        // create objects with the schema provided
+        createObjectsWithOldPrimaryKey(MigrationFieldTypeToInteger.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldTypeToInteger.CLASS_NAME)
+                        .addField("temp_id", Integer.class)
+                        .transform(new RealmObjectSchema.Function() {
+                            @Override
+                            public void apply(DynamicRealmObject obj) {
+                                String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);
+                                if (fieldValue != null && fieldValue.length() != 0) {
+                                    obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue));
+                                } else {
+                                    obj.setNull(TEMP_FIELD_ID);
+                                }
+                            }
+                        })
+                        .removeField(MigrationPrimaryKey.FIELD_PRIMARY)
+                        .renameField(TEMP_FIELD_ID, MigrationFieldTypeToInteger.FIELD_PRIMARY)
+                        .addPrimaryKey(MigrationFieldTypeToInteger.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldTypeToInteger.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldTypeToInteger.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldTypeToInteger.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInteger.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldTypeToInteger.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertEquals(2, realm.where(MigrationFieldTypeToInteger.class).count());
+
+        // not-null value
+        assertEquals(1, realm.where(MigrationFieldTypeToInteger.class)
+                             .equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, Integer.valueOf(12))
+                             .count());
+
+        // null value
+        assertEquals(1, realm.where(MigrationFieldTypeToInteger.class)
+                             .equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, (Integer) null)
+                             .count());
+    }
+
+    @Test
+    public void settingPrimaryKeyWithObjectSchema() {
+        // Create v0 of the Realm
+        RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
+                .schema(AllTypes.class)
+                .build();
+        Realm.getInstance(originalConfig).close();
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmSchema schema = realm.getSchema();
+                schema.create("AnnotationTypes")
+                        .addField("id", long.class)
+                        .addPrimaryKey("id")    // use addPrimaryKey() instead of adding FieldAttribute.PrimaryKey
+                        .addField("indexString", String.class)
+                        .addIndex("indexString") // use addIndex() instead of FieldAttribute.Index
+                        .addField("notIndexString", String.class);
+            }
+        };
+
+        // Create v1 of the Realm
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(AllTypes.class, AnnotationTypes.class)
+                .migration(migration)
+                .build();
+
+        realm = Realm.getInstance(realmConfig);
+        RealmObjectSchema schema = realm.getSchema().get("AnnotationTypes");
+        assertTrue(schema.hasPrimaryKey());
+        assertTrue(schema.hasIndex("id"));
+        realm.close();
+    }
+
     // adding search index is idempotent
     @Test
     public void addingSearchIndexTwice() throws IOException {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index bfc07906a3..d634c2a2da 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -33,8 +33,8 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.pojo.AllTypesRealmModel;
 import io.realm.entities.pojo.InvalidRealmModel;
-import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
 import io.realm.entities.pojo.PojoWithRealmListOfRealmObject;
+import io.realm.entities.pojo.RealmModelWithRealmListOfRealmModel;
 import io.realm.entities.pojo.RealmModelWithRealmModelField;
 import io.realm.entities.pojo.RealmObjectWithRealmListOfRealmModel;
 import io.realm.entities.pojo.RealmObjectWithRealmModelField;
@@ -106,15 +106,15 @@ public void createObject() {
             realm.commitTransaction();
         }
 
-        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
-        assertEquals("Realm.get is returning wrong result set", 42, resultList.size());
+        long size = realm.where(AllTypesRealmModel.class).count();
+        assertEquals("Realm.get is returning wrong result set", 42, size);
     }
 
     @Test
     public void copyToRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
-        RealmResults<AllTypesRealmModel> resultList = realm.allObjects(AllTypesRealmModel.class);
-        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, resultList.size());
+        long size = realm.where(AllTypesRealmModel.class).count();
+        assertEquals("Realm.get is returning wrong result set", TEST_DATA_SIZE, size);
     }
 
 
@@ -123,15 +123,15 @@ public void copyFromRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
-        AllTypesRealmModel standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.columnBinary, standaloneObject.columnBinary);
-        assertEquals(realmObject.columnString, standaloneObject.columnString);
-        assertEquals(realmObject.columnLong, standaloneObject.columnLong);
-        assertEquals(realmObject.columnFloat, standaloneObject.columnFloat, 0.00000000001);
-        assertEquals(realmObject.columnDouble, standaloneObject.columnDouble, 0.00000000001);
-        assertEquals(realmObject.columnBoolean, standaloneObject.columnBoolean);
-        assertEquals(realmObject.columnDate, standaloneObject.columnDate);
-        assertEquals(realmObject.hashCode(), standaloneObject.hashCode());
+        AllTypesRealmModel unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.columnBinary, unmanagedObject.columnBinary);
+        assertEquals(realmObject.columnString, unmanagedObject.columnString);
+        assertEquals(realmObject.columnLong, unmanagedObject.columnLong);
+        assertEquals(realmObject.columnFloat, unmanagedObject.columnFloat, 0.00000000001);
+        assertEquals(realmObject.columnDouble, unmanagedObject.columnDouble, 0.00000000001);
+        assertEquals(realmObject.columnBoolean, unmanagedObject.columnBoolean);
+        assertEquals(realmObject.columnDate, unmanagedObject.columnDate);
+        assertEquals(realmObject.hashCode(), unmanagedObject.hashCode());
 
     }
 
@@ -151,9 +151,9 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
+        assertEquals(1, realm.where(AllTypesRealmModel.class).count());
 
-        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
         assertEquals("Foo", obj.columnString);
     }
 
@@ -163,8 +163,8 @@ public void createOrUpdateAllFromJson() throws IOException {
         realm.createOrUpdateAllFromJson(AllTypesRealmModel.class, TestHelper.loadJsonFromAssets(context, "list_alltypes_primarykey.json"));
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(AllTypesRealmModel.class).size());
-        AllTypesRealmModel obj = realm.allObjects(AllTypesRealmModel.class).first();
+        assertEquals(1, realm.where(AllTypesRealmModel.class).count());
+        AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
         assertEquals("Bar", obj.columnString);
         assertEquals(2.23F, obj.columnFloat, 0.000000001);
         assertEquals(2.234D, obj.columnDouble, 0.000000001);
@@ -188,12 +188,14 @@ public void query() {
     @Test
     @RunTestInLooperThread
     public void async_query() {
-        populateTestRealm(looperThread.realm, TEST_DATA_SIZE);
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, TEST_DATA_SIZE);
 
-        final RealmResults<AllTypesRealmModel> allTypesRealmModels = looperThread.realm.distinctAsync(AllTypesRealmModel.class, AllTypesRealmModel.FIELD_STRING);
-        allTypesRealmModels.addChangeListener(new RealmChangeListener() {
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
+        looperThread.keepStrongReference.add(allTypesRealmModels);
+        allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypesRealmModel> object) {
                 assertEquals(1, allTypesRealmModels.size());
                 looperThread.testComplete();
             }
@@ -204,7 +206,7 @@ public void onChange() {
     public void dynamicObject() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        AllTypesRealmModel typedObj = realm.allObjects(AllTypesRealmModel.class).first();
+        AllTypesRealmModel typedObj = realm.where(AllTypesRealmModel.class).findFirst();
         DynamicRealmObject dObj = new DynamicRealmObject(typedObj);
 
         realm.beginTransaction();
@@ -259,7 +261,7 @@ public void invalidModelDefinition() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of other RealmModel, in managed and un-managed mode
+    // of other RealmModel, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModels = new RealmList<AllTypesRealmModel>();
@@ -288,7 +290,7 @@ public void realmModelWithRealmListOfRealmModel() {
     }
 
     // Test the behaviour of a RealmModel, containing a RealmList
-    // of RealmObject, in managed and un-managed mode
+    // of RealmObject, in managed and unmanaged mode
     @Test
     public void realmModelWithRealmListOfRealmObject() {
         RealmList<AllTypes> allTypes = new RealmList<AllTypes>();
@@ -317,7 +319,7 @@ public void realmModelWithRealmListOfRealmObject() {
     }
 
     // Test the behaviour of a RealmObject, containing a RealmList
-    // of RealmModel, in managed and un-managed mode
+    // of RealmModel, in managed and unmanaged mode
     @Test
     public void realmObjectWithRealmListOfRealmModel() {
         RealmList<AllTypesRealmModel> allTypesRealmModel = new RealmList<AllTypesRealmModel>();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
new file mode 100644
index 0000000000..91f85404b5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.objectid.NullPrimaryKey;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class RealmNullPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    /**
+     * Base parameters for testing null-primary key value. The parameters are aligned in an order of
+     * 1) a test target class, 2) a primary key field class, 3) a secondary field class, 4) a secondary
+     * field value, and 5) an update value, accommodating {@interface NullPrimaryKey} to condense unit tests.
+     */
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+            // 1) Test target class          2) PK Class    3) 2nd Class  4) 2nd field value   5) 2nd field value for update
+            {PrimaryKeyAsString.class,       String.class,  long.class,   Long.valueOf(492412), Long.valueOf(991241)},
+            {PrimaryKeyAsBoxedByte.class,    Byte.class,    String.class, "This-Is-Second-One", "Gosh Didnt KnowIt"},
+            {PrimaryKeyAsBoxedShort.class,   Short.class,   String.class, "AnyValueIsAccepted", "?YOUNOWKNOWRIGHT?"},
+            {PrimaryKeyAsBoxedInteger.class, Integer.class, String.class, "PlayWithSeondFied!", "HaHaHaHaHaHaHaHaH"},
+            {PrimaryKeyAsBoxedLong.class,    Long.class,    String.class, "Let's name a value", "KeyValueTestIsFun"}
+        });
+    }
+
+    final private Class<? extends RealmObject> testClazz;
+    final private Class primaryKeyFieldType;
+    final private Class secondaryFieldType;
+    final private Object secondaryFieldValue;
+    final private Object updatingFieldValue;
+
+    public RealmNullPrimaryKeyTests(Class<? extends RealmObject> testClazz, Class primaryKeyFieldType, Class secondaryFieldType, Object secondaryFieldValue, Object updatingFieldValue) {
+        this.testClazz = testClazz;
+        this.primaryKeyFieldType = primaryKeyFieldType;
+        this.secondaryFieldType = secondaryFieldType;
+        this.secondaryFieldValue = secondaryFieldValue;
+        this.updatingFieldValue = updatingFieldValue;
+    }
+
+    // Adds a PrimaryKey object to a realm with values for its PrimaryKey field and secondary field.
+    private RealmObject addPrimaryKeyObjectToTestRealm(Realm testRealm) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject) testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, secondaryFieldValue);
+        testRealm.beginTransaction();
+        testRealm.copyToRealm(obj);
+        testRealm.commitTransaction();
+        return obj;
+    }
+
+    // create a RealmObject with null primarykey
+    private void createNullPrimaryKeyObjectFromTestRealm(Realm testRealm) {
+        testRealm.beginTransaction();
+
+        RealmObject obj = testRealm.createObject(testClazz, null);
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            ((PrimaryKeyAsString)obj).setId((long) secondaryFieldValue);
+        } else {
+            ((NullPrimaryKey)obj).setName(secondaryFieldValue);
+        }
+
+        testRealm.commitTransaction();
+    }
+
+    // update existing null PrimaryKey object with a new updating value.
+    private void updatePrimaryKeyObject(Realm testRealm, RealmObject realmObject) {
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            ((PrimaryKeyAsString) realmObject).setId((long) updatingFieldValue);
+        } else {
+            ((NullPrimaryKey) realmObject).setName(updatingFieldValue);
+        }
+
+        testRealm.beginTransaction();
+        testRealm.copyToRealmOrUpdate(realmObject);
+        testRealm.commitTransaction();
+    }
+
+    // @PrimaryKey annotation accept null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealm_primaryKeyIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        addPrimaryKeyObjectToTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation accept & update null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void copyToRealmOrUpdate_primaryKeyFieldIsNull() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = addPrimaryKeyObjectToTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+
+        }
+
+        // commit to the Realm
+        updatePrimaryKeyObject(realm, obj);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            assertEquals(updatingFieldValue, realm.where(PrimaryKeyAsString.class).findFirst().getId());
+        } else {
+            assertEquals(updatingFieldValue, ((NullPrimaryKey) realm.where(testClazz).findFirst()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation creates null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_primaryKeyFieldIsNull() {
+        createNullPrimaryKeyObjectFromTestRealm(realm);
+
+        if (testClazz.equals(PrimaryKeyAsString.class)) {
+            RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, results.first().getName());
+            assertEquals(secondaryFieldValue, results.first().getId());
+
+        } else {
+            RealmResults results = realm.where(testClazz).findAll();
+            assertEquals(1, results.size());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(secondaryFieldValue, ((NullPrimaryKey) results.first()).getName());
+        }
+    }
+
+    // @PrimaryKey annotation checked duplicated null value properly as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_duplicatedNullPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        addPrimaryKeyObjectToTestRealm(realm);
+
+        realm.beginTransaction();
+        try {
+            realm.createObject(testClazz, null);
+            fail("Null value as primary key already exists.");
+        } catch (RealmPrimaryKeyConstraintException expected) {
+            assertEquals("Value already exists: null", expected.getMessage());
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 6963b7ff1a..cb9cf3f5c3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -17,8 +17,7 @@
 package io.realm;
 
 import android.support.test.runner.AndroidJUnit4;
-import io.realm.entities.AllJavaTypes;
-import io.realm.rule.TestRealmConfigurationFactory;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -29,6 +28,9 @@
 import java.util.Date;
 import java.util.Set;
 
+import io.realm.entities.AllJavaTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -180,7 +182,7 @@ public boolean isNullable() {
     public void addRemoveField() {
         for (FieldType fieldType : FieldType.values()) {
             String fieldName = "foo";
-            switch(fieldType) {
+            switch (fieldType) {
                 case OBJECT:
                     schema.addRealmObjectField(fieldName, DOG_SCHEMA);
                     checkAddedAndRemovable(fieldName);
@@ -512,9 +514,11 @@ public void setRemovePrimaryKey() {
             schema.addPrimaryKey(fieldName);
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.isPrimaryKey(fieldName));
+            assertTrue(schema.hasIndex(fieldName));
             schema.removePrimaryKey();
             assertFalse(schema.hasPrimaryKey());
             assertFalse(schema.isPrimaryKey(fieldName));
+            assertFalse(schema.hasIndex(fieldName));
             schema.removeField(fieldName);
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index e211c85055..7c64ba48cd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -26,9 +28,11 @@
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
+import java.lang.ref.WeakReference;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -37,13 +41,13 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.ConflictingFieldName;
 import io.realm.entities.CustomMethods;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
-import io.realm.entities.Thread;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
@@ -73,6 +77,8 @@
     public final ExpectedException thrown = ExpectedException.none();
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
 
     private Realm realm;
     private RealmConfiguration realmConfig;
@@ -122,7 +128,7 @@ public void stringEncoding() {
         }
         realm.commitTransaction();
 
-        RealmResults<AllTypes> objects = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> objects = realm.where(AllTypes.class).findAll();
         assertEquals(strings.length, objects.size());
         int i = 0;
         for (AllTypes obj : objects) {
@@ -137,7 +143,7 @@ public void stringEncoding() {
     @Test
     public void invalidSurrogates() {
         String high = "Invalid high surrogate \uD83C\uD83C\uDF51";
-        String low  = "Invalid low surrogate \uD83C\uDF51\uDF51";
+        String low = "Invalid low surrogate \uD83C\uDF51\uDF51";
 
         realm.beginTransaction();
         realm.delete(AllTypes.class);
@@ -237,7 +243,7 @@ public void deleteFromRealm_removedFromResults() {
         dogToAdd.setName("Rex");
         realm.commitTransaction();
 
-        assertEquals(1, realm.allObjects(Dog.class).size());
+        assertEquals(1, realm.where(Dog.class).count());
 
         Dog dogToRemove = realm.where(Dog.class).findFirst();
         assertNotNull(dogToRemove);
@@ -245,7 +251,7 @@ public void deleteFromRealm_removedFromResults() {
         dogToRemove.deleteFromRealm();
         realm.commitTransaction();
 
-        assertEquals(0, realm.allObjects(Dog.class).size());
+        assertEquals(0, realm.where(Dog.class).count());
         try {
             dogToAdd.getName();
             realm.close();
@@ -271,7 +277,7 @@ private void removeOneByOne(boolean removeFromFront) {
         realm.commitTransaction();
 
         // Check initial size
-        RealmResults<Dog> dogs = realm.allObjects(Dog.class);
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
         assertEquals(TEST_SIZE, dogs.size());
 
         // Check that calling deleteFromRealm doesn't remove the object from the RealmResult
@@ -308,7 +314,7 @@ public Boolean call() throws Exception {
                     switch (method) {
                         case METHOD_GETTER:
                             allTypes.getColumnFloat();
-                           break;
+                            break;
                         case METHOD_SETTER:
                             allTypes.setColumnFloat(1.0f);
                             break;
@@ -383,7 +389,7 @@ public void equals_afterModification() {
     }
 
     @Test
-    public void equals_standAloneObject() {
+    public void equals_unmanagedObject() {
         realm.beginTransaction();
         CyclicType ct1 = realm.createObject(CyclicType.class);
         ct1.setName("Foo");
@@ -560,10 +566,8 @@ private CyclicType createCyclicData() {
 
     @Test
     public void dateType() {
-        long testDatesValid[] = {-1000, 0, 1000};
-        long testDatesLoosePrecision[] = {Long.MIN_VALUE, 1, 1001, Long.MAX_VALUE};
+        long testDatesValid[] = {Long.MIN_VALUE, -1001, -1000, -1, 0, 1, 1000, 1001, Long.MAX_VALUE};
 
-        // test valid dates
         realm.beginTransaction();
         for (long value : testDatesValid) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -572,26 +576,10 @@ public void dateType() {
         realm.commitTransaction();
 
         int i = 0;
-        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
+        for (AllTypes allTypes : realm.where(AllTypes.class).findAll()) {
             assertEquals("Item " + i, new Date(testDatesValid[i]), allTypes.getColumnDate());
             i++;
         }
-
-        // test valid dates but with precision lost
-        realm.beginTransaction();
-        realm.delete(AllTypes.class);
-        for (long value : testDatesLoosePrecision) {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnDate(new Date(value));
-        }
-        realm.commitTransaction();
-
-        i = 0;
-        for (AllTypes allTypes : realm.allObjects(AllTypes.class)) {
-            assertFalse("Item " + i, new Date(testDatesLoosePrecision[i]) == allTypes.getColumnDate());
-            assertEquals("Item " + i, new Date(1000*(testDatesLoosePrecision[i]/1000)), allTypes.getColumnDate());
-            i++;
-        }
     }
 
     private Date newDate(int year, int month, int dayOfMonth) {
@@ -637,15 +625,15 @@ public void setter_link_null() {
     }
 
     @Test
-    public void setter_link_standaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_link_unmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
             CyclicType target = realm.createObject(CyclicType.class);
 
             try {
-                target.setObject(standalone);
+                target.setObject(unmanaged);
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
@@ -772,8 +760,8 @@ public void run() {
     }
 
     @Test
-    public void setter_list_withStandaloneObject() {
-        CyclicType standalone = new CyclicType();
+    public void setter_list_withUnmanagedObject() {
+        CyclicType unmanaged = new CyclicType();
 
         realm.beginTransaction();
         try {
@@ -781,7 +769,7 @@ public void setter_list_withStandaloneObject() {
 
             RealmList<CyclicType> list = new RealmList<>();
             list.add(realm.createObject(CyclicType.class));
-            list.add(standalone); // List contains a standalone object
+            list.add(unmanaged); // List contains an unmanaged object
             list.add(realm.createObject(CyclicType.class));
 
             try {
@@ -938,12 +926,12 @@ public void classNameConflictsWithFrameworkClass() {
         // The annotation process must be able to handle that.
         realm.beginTransaction();
         @SuppressWarnings("unused")
-        Thread thread = realm.createObject(Thread.class);
+        io.realm.entities.Thread thread = realm.createObject(io.realm.entities.Thread.class);
         realm.commitTransaction();
     }
 
     @Test
-    public void isValid_standaloneObject() {
+    public void isValid_unmanagedObject() {
         AllTypes allTypes = new AllTypes();
         assertFalse(allTypes.isValid());
     }
@@ -961,7 +949,7 @@ public void isValid_closedRealm() {
     }
 
     @Test
-    public void IsValid_deletedObject() {
+    public void isValid_deletedObject() {
         realm.beginTransaction();
         AllTypes allTypes = realm.createObject(AllTypes.class);
         assertTrue(allTypes.isValid());
@@ -1148,8 +1136,7 @@ public void set_nullValuesToNonNullableFields() {
                 fail();
             } catch (IllegalArgumentException ignored) {
             }
-        }
-        finally {
+        } finally {
             realm.cancelTransaction();
         }
     }
@@ -1196,29 +1183,32 @@ public void defaultValuesForNewObject() {
 
     @Test
     public void getter_afterDeleteFromOtherThreadThrows() {
+        final CountDownLatch bgRealmDone = new CountDownLatch(1);
         realm.beginTransaction();
-        AllTypes obj = realm.createObject(AllTypes.class);
+        final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        final CountDownLatch objectDeletedInBackground = new CountDownLatch(1);
-        new java.lang.Thread(new Runnable() {
+        new Thread(new Runnable() {
             @Override
             public void run() {
-                Realm realm = Realm.getInstance(realmConfig);
-                realm.beginTransaction();
-                realm.delete(AllTypes.class);
-                realm.commitTransaction();
-                realm.close();
-                objectDeletedInBackground.countDown();
+                Realm bgRealm = Realm.getInstance(realm.getConfiguration());
+                bgRealm.beginTransaction();
+                bgRealm.delete(AllTypes.class);
+                bgRealm.commitTransaction();
+                bgRealm.close();
+                bgRealmDone.countDown();
             }
         }).start();
-        TestHelper.awaitOrFail(objectDeletedInBackground);
-        realm.refresh(); // Move to version where underlying object is deleted.
+        TestHelper.awaitOrFail(bgRealmDone);
+        realm.waitForChange();
 
         // Object should no longer be available
         assertFalse(obj.isValid());
-        thrown.expect(IllegalStateException.class);
-        obj.getColumnLong();
+        try {
+            obj.getColumnLong();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
     }
 
     @Test
@@ -1391,18 +1381,18 @@ public void execute(Realm realm) {
 
     @Test
     public void conflictingFieldName_readAndUpdate() {
-        final ConflictingFieldName standalone = new ConflictingFieldName();
-        standalone.setRealm("realm");
-        standalone.setRow("row");
-        standalone.setIsCompleted("isCompleted");
-        standalone.setListeners("listeners");
-        standalone.setPendingQuery("pendingQuery");
-        standalone.setCurrentTableVersion("currentTableVersion");
+        final ConflictingFieldName unmanaged = new ConflictingFieldName();
+        unmanaged.setRealm("realm");
+        unmanaged.setRow("row");
+        unmanaged.setIsCompleted("isCompleted");
+        unmanaged.setListeners("listeners");
+        unmanaged.setPendingQuery("pendingQuery");
+        unmanaged.setCurrentTableVersion("currentTableVersion");
 
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                realm.copyToRealm(standalone);
+                realm.copyToRealm(unmanaged);
             }
         });
 
@@ -1441,7 +1431,7 @@ public void execute(Realm realm) {
     @Test
     public void setter_nullValueInRequiredField() {
         TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> list = realm.where(NullTypes.class).findAll();
 
         // 1 String
         try {
@@ -1521,97 +1511,140 @@ public void setter_nullValueInRequiredField() {
     @Test
     public void setter_nullValueInNullableField() {
         TestHelper.populateTestRealmForNullTests(realm);
-        RealmResults<NullTypes> list = realm.allObjects(NullTypes.class);
+        RealmResults<NullTypes> list = realm.where(NullTypes.class).findAll();
 
         // 1 String
         realm.beginTransaction();
         list.first().setFieldStringNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldStringNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldStringNull());
 
         // 2 Bytes
         realm.beginTransaction();
         list.first().setFieldBytesNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBytesNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldBytesNull());
 
         // 3 Boolean
         realm.beginTransaction();
         list.first().setFieldBooleanNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldBooleanNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldBooleanNull());
 
         // 4 Byte
         // 5 Short 6 Integer 7 Long are skipped
         realm.beginTransaction();
         list.first().setFieldByteNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldByteNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldByteNull());
 
         // 8 Float
         realm.beginTransaction();
         list.first().setFieldFloatNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldFloatNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldFloatNull());
 
         // 9 Double
         realm.beginTransaction();
         list.first().setFieldDoubleNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDoubleNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldDoubleNull());
 
         // 10 Date
         realm.beginTransaction();
         list.first().setFieldDateNull(null);
         realm.commitTransaction();
-        assertNull(realm.allObjects(NullTypes.class).first().getFieldDateNull());
+        assertNull(realm.where(NullTypes.class).findFirst().getFieldDateNull());
     }
 
     @Test
     @RunTestInLooperThread
-    public void addChangeListener_throwOnAddingNullListener() {
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
         final Realm realm = looperThread.realm;
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.addChangeListener((RealmChangeListener) null);
-            fail("Failed on adding null change listener.");
+            dog.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dog.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnUnmanagedObject() {
         Dog dog = new Dog();
 
         try {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                 }
             });
-            fail("Failed on adding listener on null realm.");
+            fail("adding change listener on unmanaged object must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
     @Test
     @RunTestInLooperThread
-    public void removeChangeListener_throwOnRemovingNullListener() {
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
         final Realm realm = looperThread.realm;
         Dog dog = createManagedDogObjectFromRealmInstance(realm);
 
         try {
-            dog.removeChangeListener((RealmChangeListener) null);
-            fail("Failed on adding null change listener.");
+            dog.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
         } catch (IllegalArgumentException ignore) {
+        } finally {
             looperThread.testComplete();
         }
     }
 
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+                final Dog dog = createManagedDogObjectFromRealmInstance(realm);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    dog.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     /**
      * This test is to see if RealmObject.removeChangeListeners() works as it is intended.
      */
@@ -1623,9 +1656,9 @@ public void removeChangeListeners() {
         Dog dog = realm.createObject(Dog.class);
         dog.setAge(13);
         realm.commitTransaction();
-        dog.addChangeListener(new RealmChangeListener() {
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertTrue(false);
             }
         });
@@ -1642,9 +1675,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void removeChangeListener_throwOnUnmanagedObject() {
         Dog dog = new Dog();
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener listener = new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
             }
         };
 
@@ -1668,4 +1701,116 @@ public void removeChangeListeners_throwOnUnmanagedObject() {
             looperThread.testComplete();
         }
     }
+
+    // Bug https://github.com/realm/realm-java/issues/2569
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        realm.createObject(AllTypesPrimaryKey.class, 1);
+
+        AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
+        allTypesPrimaryKey.setColumnLong(1);
+        allTypesPrimaryKey.setColumnFloat(42f);
+        allTypesPrimaryKey = realm.copyToRealmOrUpdate(allTypesPrimaryKey);
+        realm.commitTransaction();
+
+        looperThread.keepStrongReference.add(allTypesPrimaryKey);
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+                assertEquals(42.0f, element.getColumnFloat(), 0f);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // The object should be added to HandlerController.realmObjects only when the first time addListener called.
+    @Test
+    @UiThreadTest
+    public void addChangeListener_shouldAddTheObjectToHandlerRealmObjects() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
+                realm.handlerController.realmObjects;
+
+        assertTrue(realmObjects.isEmpty());
+
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+
+        assertEquals(1, realmObjects.size());
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertTrue(ref.get() == allTypesPrimaryKey);
+        }
+    }
+
+    // The object should be added to HandlerController.realmObjects only once.
+    @Test
+    @UiThreadTest
+    public void addChangeListener_shouldNotAddDupEntriesToHandlerRealmObjects() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
+                realm.handlerController.realmObjects;
+
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertFalse(ref.get() == allTypesPrimaryKey);
+        }
+
+        // Add different listeners twice
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+            }
+        });
+
+        assertEquals(1, realmObjects.size());
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            assertTrue(ref.get() == allTypesPrimaryKey);
+        }
+    }
+
+    // The object should not be added to HandlerController again after the async query loaded.
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_checkHandlerRealmObjectsWhenCallingOnAsyncObject() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        realm.createObject(AllTypesPrimaryKey.class, 1);
+        realm.commitTransaction();
+        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
+                realm.handlerController.realmObjects;
+
+        final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
+        looperThread.keepStrongReference.add(allTypesPrimaryKey);
+        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+            @Override
+            public void onChange(AllTypesPrimaryKey element) {
+                allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
+                    @Override
+                    public void onChange(AllTypesPrimaryKey element) {
+
+                    }
+                });
+                assertEquals(1, realmObjects.size());
+                looperThread.testComplete();
+            }
+        });
+        assertEquals(1, realmObjects.size());
+        for (Object query : realmObjects.values()) {
+            assertNotNull(query);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
index d642764f0d..155607bbfe 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmPrimaryKeyTests.java
@@ -67,12 +67,12 @@ public void tearDown() {
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
-                // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
-                {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
-                {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
-                {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
-                {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
-                {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
+            // 1) Test target class                  2) PK Class    3) PK value            4) 2nd Class  5) 2nd field value
+            {PrimaryKeyRequiredAsString.class,       String.class,  "424123",              String.class, "SomeSecondaryValue"},
+            {PrimaryKeyRequiredAsBoxedByte.class,    Byte.class,    Byte.valueOf("67"),    String.class, "This-Is-Second-One"},
+            {PrimaryKeyRequiredAsBoxedShort.class,   Short.class,   Short.valueOf("1729"), String.class, "AnyValueIsAccepted"},
+            {PrimaryKeyRequiredAsBoxedInteger.class, Integer.class, Integer.valueOf("19"), String.class, "PlayWithSeondFied!"},
+            {PrimaryKeyRequiredAsBoxedLong.class,    Long.class,    Long.valueOf("62914"), String.class, "Let's name a value"}
         });
     }
 
@@ -107,9 +107,10 @@ public void copyToRealmOrUpdate_requiredPrimaryKey() throws NoSuchMethodExceptio
     // @PrimaryKey + @Required annotation does accept null as a primary key value for Realm version 0.89.1+
     @Test
     public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
+
+        realm.beginTransaction();
         try {
-            RealmObject obj = (RealmObject)testClazz.getConstructor(primaryKeyFieldType, secondaryFieldType).newInstance(null, null);
-            realm.beginTransaction();
             realm.copyToRealmOrUpdate(obj);
             fail("@PrimaryKey + @Required field cannot be null");
         } catch (RuntimeException expected) {
@@ -123,4 +124,18 @@ public void copyToRealmOrUpdate_requiredPrimaryKeyThrows() throws NoSuchMethodEx
             realm.cancelTransaction();
         }
     }
+
+    // @PrimaryKey + @Required annotation does not accept null as a primary key value for Realm version 0.89.1+
+    @Test
+    public void createObject_nullPrimaryKeyValueThrows() throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
+        realm.beginTransaction();
+        try {
+            realm.createObject(testClazz, null);
+            fail("@PrimaryKey + @Required field cannot be null");
+        } catch (RuntimeException expected) {
+            assertTrue(expected instanceof IllegalArgumentException);
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 977d702da2..cd296a6d52 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -42,6 +42,7 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.Dog;
+import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
@@ -71,6 +72,7 @@
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
     protected final static int TEST_DATA_SIZE = 10;
+    protected final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
 
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
@@ -89,14 +91,14 @@ public void tearDown() throws Exception {
         }
     }
 
-    private void populateTestRealm(Realm testRealm, int objects) {
+    private void populateTestRealm(Realm testRealm, int dataSize) {
         testRealm.beginTransaction();
         testRealm.deleteAll();
-        for (int i = 0; i < objects; ++i) {
+        for (int i = 0; i < dataSize; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
+            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
             allTypes.setColumnDouble(3.1415);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
@@ -114,6 +116,37 @@ private void populateTestRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
     }
 
+    private void populateNoPrimaryKeyNullTypesRows(Realm testRealm, int dataSize) {
+        testRealm.beginTransaction();
+        testRealm.deleteAll();
+        for (int i = 0; i < dataSize; ++i) {
+            NoPrimaryKeyNullTypes noPrimaryKeyNullTypes = testRealm.createObject(NoPrimaryKeyNullTypes.class);
+            noPrimaryKeyNullTypes.setFieldStringNull((i % 3) == 0 ? null : "test data " + i);
+            noPrimaryKeyNullTypes.setFieldStringNotNull("test data " + i);
+            noPrimaryKeyNullTypes.setFieldBooleanNull((i % 3) == 0 ? null : (i % 3) == 1);
+            noPrimaryKeyNullTypes.setFieldBooleanNotNull((i % 3) == 0);
+            noPrimaryKeyNullTypes.setFieldByteNull((i % 3) == 0 ? null : (byte) i);
+            noPrimaryKeyNullTypes.setFieldByteNotNull((byte) i);
+            noPrimaryKeyNullTypes.setFieldShortNull((i % 3) == 0 ? null : (short) i);
+            noPrimaryKeyNullTypes.setFieldShortNotNull((short) i);
+            noPrimaryKeyNullTypes.setFieldIntegerNull((i % 3) == 0 ? null : i);
+            noPrimaryKeyNullTypes.setFieldIntegerNotNull(i);
+            noPrimaryKeyNullTypes.setFieldLongNull((i % 3) == 0 ? null : (long) i);
+            noPrimaryKeyNullTypes.setFieldLongNotNull((long) i);
+            noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.234567f + i);
+            noPrimaryKeyNullTypes.setFieldFloatNotNull(1.234567f + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : 3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNotNull(3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDateNull((i % 3) == 0 ? null : new Date(DECADE_MILLIS * (i - (dataSize / 2))));
+            noPrimaryKeyNullTypes.setFieldDateNotNull(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
+        }
+        testRealm.commitTransaction();
+    }
+
+    private void populateNoPrimaryKeyNullTypesRows() {
+        populateNoPrimaryKeyNullTypesRows(realm, TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE);
+    }
+
     @Test
     public void between() {
         final int TEST_OBJECTS_COUNT = 200;
@@ -404,6 +437,359 @@ public void equalTo_nonLatinCharacters() {
         assertEquals(0, resultList.size());
     }
 
+    private void doTestForInString(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (String[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"test data 14"}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"test data 14", "test data 118", "test data 31", "test data 199"}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(196, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInBoolean(String targetField, int expected1, int expected2, int expected3, int expected4) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Boolean[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{false}).findAll();
+        assertEquals(expected1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{true}).findAll();
+        assertEquals(expected2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{true, false}).findAll();
+        assertEquals(expected3, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Boolean[]{true, false}).findAll();
+        assertEquals(expected4, resultList.size());
+    }
+
+    private void doTestForInDate(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Date[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(DECADE_MILLIS * -80)}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(0)}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(DECADE_MILLIS * -80), new Date(0)}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Date[]{new Date(DECADE_MILLIS * -80), new Date(0)}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInDouble(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Double[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 2}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInFloat(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Float[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 2}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInByte(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Byte[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{13}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{11, 13, 16, 98}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Byte[]{11, 13, 16, 98}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInShort(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Short[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{4}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{2, 4, 5, 8}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Short[]{2, 4, 5, 8}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInInteger(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Integer[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{1, 2, 4, 5}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Integer[]{1, 2, 4, 5}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInLong(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Long[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{11l}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{13l}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{13l, 14l, 16l, 98l}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Long[]{13l, 14l, 16l, 98l}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    @Test
+    public void in_stringNotNull() {
+        doTestForInString(NoPrimaryKeyNullTypes.FIELD_STRING_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_STRING_NOT_NULL, new String[]{"TEST data 14", "test data 118", null, "test DATA 199"}, Case.INSENSITIVE).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_stringNull() {
+        doTestForInString(NoPrimaryKeyNullTypes.FIELD_STRING_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_STRING_NULL, new String[]{"TEST data 14", "test data 118", null, "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_booleanNotNull() {
+        doTestForInBoolean(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NOT_NULL, 133, 67, 200, 0);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NOT_NULL, new Boolean[]{true, null, false}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_booleanNull() {
+        doTestForInBoolean(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NULL, 66, 67, 133, 67);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NULL, new Boolean[]{true, null, false}).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void in_dateNotNull() {
+        doTestForInDate(NoPrimaryKeyNullTypes.FIELD_DATE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DATE_NOT_NULL, new Date[]{new Date(DECADE_MILLIS * -80), null, new Date(0)}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_dateNull() {
+        doTestForInDate(NoPrimaryKeyNullTypes.FIELD_DATE_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DATE_NULL, new Date[]{new Date(DECADE_MILLIS * -80), null, new Date(0)}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_doubleNotNull() {
+        doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_doubleNull() {
+        doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_floatNotNull() {
+        doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_floatNull() {
+        doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_byteNotNull() {
+        doTestForInByte(NoPrimaryKeyNullTypes.FIELD_BYTE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BYTE_NOT_NULL, new Byte[]{11, null, 13, 99}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_byteNull() {
+        doTestForInByte(NoPrimaryKeyNullTypes.FIELD_BYTE_NULL);
+        RealmResults resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BYTE_NULL, new Byte[]{11, null, 13, 99}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_shortNotNull() {
+        doTestForInShort(NoPrimaryKeyNullTypes.FIELD_SHORT_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_SHORT_NOT_NULL, new Short[]{2, null, 5, 8}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_shortNull() {
+        doTestForInShort(NoPrimaryKeyNullTypes.FIELD_SHORT_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_SHORT_NULL, new Short[]{2, null, 5, 8}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_integerNotNull() {
+        doTestForInInteger(NoPrimaryKeyNullTypes.FIELD_INTEGER_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_INTEGER_NOT_NULL, new Integer[]{1, null, 4, 5}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_integerNull() {
+        doTestForInInteger(NoPrimaryKeyNullTypes.FIELD_INTEGER_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_INTEGER_NULL, new Integer[]{1, null, 4, 5}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_longNotNull() {
+        doTestForInLong(NoPrimaryKeyNullTypes.FIELD_LONG_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_LONG_NOT_NULL, new Long[]{13l, null, 16l, 98l}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_longNull() {
+        doTestForInLong(NoPrimaryKeyNullTypes.FIELD_LONG_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_LONG_NULL, new Long[]{13l, null, 16l, 98l}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
     @Test
     public void notEqualTo() {
         final int TEST_OBJECTS_COUNT = 200;
@@ -639,7 +1025,7 @@ public void georgian() {
         RealmResults<StringOnly> stringOnlies1 = realm.where(StringOnly.class).contains("chars", "მთავარი").findAll();
         assertEquals(1, stringOnlies1.size());
 
-        RealmResults<StringOnly> stringOnlies2 = realm.allObjects(StringOnly.class);
+        RealmResults<StringOnly> stringOnlies2 = realm.where(StringOnly.class).findAll();
         stringOnlies2 = stringOnlies2.sort("chars");
         for (int i = 0; i < stringOnlies2.size(); i++) {
             assertEquals(sorted[i], stringOnlies2.get(i).getChars());
@@ -835,19 +1221,19 @@ public void notEqualTo_nullPrimaryKeys() {
         // String
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).notEqualTo(PrimaryKeyAsString.FIELD_PRIMARY_KEY,             "-1").findAll().first().getId());
         // Boxed Byte
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).notEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       Byte.valueOf((byte)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).notEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       Byte.valueOf((byte) -1)).findAll().first().getName());
         // Boxed Short
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).notEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     Short.valueOf((short)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).notEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     Short.valueOf((short) -1)).findAll().first().getName());
         // Boxed Integer
         assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedInteger.class).notEqualTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, Integer.valueOf(-1)).findAll().first().getName());
         // Boxed Long
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).notEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       Long.valueOf((long)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).notEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       Long.valueOf((long) -1)).findAll().first().getName());
     }
 
     @Test
     public void beginWith_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).beginsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
     }
@@ -855,7 +1241,7 @@ public void beginWith_nullStringPrimaryKey() {
     @Test
     public void contains_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).contains(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
     }
@@ -863,7 +1249,7 @@ public void contains_nullStringPrimaryKey() {
     @Test
     public void endsWith_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).endsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
     }
@@ -1308,7 +1694,7 @@ public void max_allNonNullRows() {
         assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
         assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
         assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+        assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
     // Test max on columns with partial null rows
@@ -1320,7 +1706,7 @@ public void max_partialNullRows() {
         assertEquals(4, query.max(NullTypes.FIELD_INTEGER_NULL).intValue());
         assertEquals(5f, query.max(NullTypes.FIELD_FLOAT_NULL).floatValue(), 0f);
         assertEquals(6d, query.max(NullTypes.FIELD_DOUBLE_NULL).doubleValue(), 0d);
-        assertEquals(12000, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
+        assertEquals(12345, query.maximumDate(NullTypes.FIELD_DATE_NULL).getTime());
     }
 
     // Test average on empty columns
@@ -1722,7 +2108,7 @@ public void largeRealmMultipleThreads() throws InterruptedException {
                         public void run() {
                             RealmConfiguration realmConfig = configFactory.createConfiguration();
                             Realm realm = Realm.getInstance(realmConfig);
-                            RealmResults<StringOnly> realmResults = realm.allObjects(StringOnly.class);
+                            RealmResults<StringOnly> realmResults = realm.where(StringOnly.class).findAll();
                             int n = 0;
                             for (StringOnly ignored : realmResults) {
                                 n = n + 1;
@@ -1827,6 +2213,7 @@ public void isValid_removedParent() {
         list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
         list.remove(RealmFieldType.UNSUPPORTED_MIXED);
         list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        list.remove(RealmFieldType.UNSUPPORTED_DATE);
         NOT_SUPPORTED_IS_EMPTY_TYPES = list;
     }
 
@@ -1949,6 +2336,7 @@ public void isEmpty_invalidFieldNameThrows() {
         list.removeAll(SUPPORTED_IS_NOT_EMPTY_TYPES);
         list.remove(RealmFieldType.UNSUPPORTED_MIXED);
         list.remove(RealmFieldType.UNSUPPORTED_TABLE);
+        list.remove(RealmFieldType.UNSUPPORTED_DATE);
         NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = list;
     }
 
@@ -2309,33 +2697,37 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 endTest.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 endTest.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 endTest.run();
             }
@@ -2343,7 +2735,7 @@ public void onChange() {
     }
 
     @Test
-    public void distinctAsync_withNullValues () throws Throwable {
+    public void distinctAsync_withNullValues() throws Throwable {
         final CountDownLatch signalCallbackFinished = new CountDownLatch(2);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
         final Throwable[] threadAssertionError = new Throwable[1];
@@ -2357,7 +2749,7 @@ public void run() {
 
                 Realm asyncRealm = null;
                 try {
-                    Realm.asyncQueryExecutor.pause();
+                    Realm.asyncTaskExecutor.pause();
                     asyncRealm = openRealmInstance("testDistinctAsyncQueryWithNull");
                     final long numberOfBlocks = 25;
                     final long numberOfObjects = 10; // must be greater than 1
@@ -2374,19 +2766,19 @@ public void run() {
                     assertTrue(distinctString.isValid());
                     assertTrue(distinctString.isEmpty());
 
-                    Realm.asyncQueryExecutor.resume();
+                    Realm.asyncTaskExecutor.resume();
 
-                    distinctDate.addChangeListener(new RealmChangeListener() {
+                    distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
                             assertEquals(1, distinctDate.size());
                             signalCallbackFinished.countDown();
                         }
                     });
 
-                    distinctString.addChangeListener(new RealmChangeListener() {
+                    distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
                             assertEquals(1, distinctString.size());
                             signalCallbackFinished.countDown();
                         }
@@ -2520,32 +2912,32 @@ public void distinctMultiArgs_emptyField() {
         }
         // a null string field in the middle
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
         // a null string field at the end
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // (String)null makes varargs a null array.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // Two (String)null for first and varargs fields
         try {
-            query.distinct((String)null, (String)null);
+            query.distinct((String) null, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            query.distinct("", (String)null);
+            query.distinct("", (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            query.distinct((String)null, "");
+            query.distinct((String) null, "");
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 85b4899fee..cf2ea4fd8b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -40,6 +40,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -73,7 +74,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
-        collection = realm.allObjectsSorted(AllTypes.class, AllTypes.FIELD_LONG, Sort.ASCENDING);
+        collection = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
     }
 
     @After
@@ -112,7 +113,7 @@ public void size_returns_Integer_MAX_VALUE_for_huge_results() {
 
     @Test
     public void subList() {
-        RealmResults<AllTypes> list = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> list = realm.where(AllTypes.class).findAll();
         list.sort("columnLong");
         List<AllTypes> sublist = list.subList(Math.max(list.size() - 20, 0), list.size());
         assertEquals(TEST_DATA_SIZE - 1, sublist.get(sublist.size() - 1).getColumnLong());
@@ -341,19 +342,19 @@ public void distinct_invalidTypesLinkedFields() {
     @Test
     @RunTestInLooperThread
     public void changeListener_syncIfNeeded_updatedFromOtherThread() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration("Foo"));
+        final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 10).findAll();
         assertEquals(10, results.size());
 
         // 1. Delete first object from another thread.
-        realm.executeTransaction(new Realm.Transaction() {
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-               realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 0).findFirst().removeFromRealm();
+                realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 0).findFirst().deleteFromRealm();
             }
-        }, new Realm.Transaction.Callback() {
+        }, new Realm.Transaction.OnSuccess() {
             @Override
             public void onSuccess() {
                 // 2. RealmResults are refreshed before onSuccess is called
@@ -449,33 +450,37 @@ public void run() {
             }
         };
 
-        distinctBool.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(2, distinctBool.size());
                 endTest.run();
             }
         });
 
-        distinctLong.addChangeListener(new RealmChangeListener() {
+        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctLong.size());
                 endTest.run();
             }
         });
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals(numberOfBlocks, distinctString.size());
                 endTest.run();
             }
@@ -511,17 +516,19 @@ public void run() {
             }
         };
 
-        distinctDate.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals("distinctDate", 1, distinctDate.size());
                 endTest.run();
             }
         });
 
-        distinctString.addChangeListener(new RealmChangeListener() {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
                 assertEquals("distinctString", 1, distinctString.size());
                 endTest.run();
             }
@@ -853,11 +860,12 @@ public void max_resultsBuiltOnDeletedLinkView() {
     @RunTestInLooperThread
     public void addChangeListener() {
         Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
-        collection.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(collection);
+        collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 looperThread.testComplete();
             }
         });
@@ -872,18 +880,18 @@ public void onChange() {
     public void addChangeListener_twice() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 listenersTriggered.incrementAndGet();
                 looperThread.postRunnable(new Runnable() {
                     @Override
@@ -899,6 +907,7 @@ public void run() {
         });
 
         // Adding it twice will be ignored, so removing it will not cause the listener to be triggered.
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listener);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
@@ -923,15 +932,16 @@ public void addChangeListener_null() {
     public void removeChangeListener() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
 
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
 
@@ -967,21 +977,22 @@ public void removeChangeListener_null() {
     public void removeAllChangeListeners() {
         final AtomicInteger listenersTriggered = new AtomicInteger(0);
         final Realm realm = looperThread.realm;
-        RealmResults<AllTypes> collection = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
-        RealmChangeListener listenerA = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listenerA = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
-        RealmChangeListener listenerB = new RealmChangeListener() {
+        RealmChangeListener<RealmResults<AllTypes>> listenerB = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
                 listenersTriggered.incrementAndGet();
             }
         };
 
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listenerA);
         collection.addChangeListener(listenerB);
         collection.removeChangeListeners();
@@ -1002,4 +1013,28 @@ public void run() {
             }
         });
     }
+
+    @Test
+    public void deleteAndDeleteAll() {
+        realm.beginTransaction();
+        for (int i = 0; i < 10; i++) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars("String " + i);
+        }
+        realm.commitTransaction();
+
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAll();
+
+        realm.beginTransaction();
+        // remove one object
+        stringOnlies.get(0).deleteFromRealm();
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        // remove the rest
+        stringOnlies.deleteAllFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(StringOnly.class).findAll().size());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index bef98fac91..018f063f37 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -31,7 +31,6 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsString;
-import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 760d809ad1..f73eff9771 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -40,6 +40,7 @@
 import org.junit.runner.RunWith;
 
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -55,6 +56,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
@@ -83,6 +85,7 @@
 import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
 import io.realm.entities.PrimaryKeyRequiredAsString;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmError;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
@@ -91,6 +94,8 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.util.ExceptionHolder;
+import io.realm.util.RealmThread;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -182,6 +187,18 @@ public void getInstance_writeProtectedDir() {
         Realm.getInstance(new RealmConfiguration.Builder(folder).build());
     }
 
+    @Test(expected = IllegalArgumentException.class)
+    public void getInstance_nullContextWithCustomDirThrows() {
+        Realm.getInstance(new RealmConfiguration.Builder((Context) null, configFactory.getRoot()).build());
+    }
+
+    @Test
+    public void getInstance_writeProtectedDirWithContext() {
+        File folder = new File("/");
+        thrown.expect(IllegalArgumentException.class);
+        Realm.getInstance(new RealmConfiguration.Builder(context, folder).build());
+    }
+
     @Test
     public void getInstance_writeProtectedFile() throws IOException {
         String REALM_FILE = "readonly.realm";
@@ -195,6 +212,19 @@ public void getInstance_writeProtectedFile() throws IOException {
         Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
     }
 
+    @Test
+    public void getInstance_writeProtectedFileWithContext() throws IOException {
+        String REALM_FILE = "readonly.realm";
+        File folder = configFactory.getRoot();
+        File realmFile = new File(folder, REALM_FILE);
+        assertFalse(realmFile.exists());
+        assertTrue(realmFile.createNewFile());
+        assertTrue(realmFile.setWritable(false));
+
+        thrown.expect(RealmIOException.class);
+        Realm.getInstance(new RealmConfiguration.Builder(context, folder).name(REALM_FILE).build());
+    }
+
     @Test
     public void getInstance_twiceWhenRxJavaUnavailable() {
         // test for https://github.com/realm/realm-java/issues/2416
@@ -264,64 +294,7 @@ public void internalRealmChangedHandlersRemoved() {
     @Test
     public void getInstance() {
         assertNotNull("Realm.getInstance unexpectedly returns null", realm);
-        assertTrue("Realm.getInstance does not contain expected table", realm.contains(AllTypes.class));
-    }
-
-    @Test
-    public void getInstance_context() {
-        RealmConfiguration config = new RealmConfiguration.Builder(context).build();
-        Realm.deleteRealm(config);
-
-        Realm testRealm = Realm.getInstance(context);
-        assertNotNull("Realm.getInstance unexpectedly returns null", testRealm);
-        assertTrue("Realm.getInstance does not contain expected table", testRealm.contains(AllTypes.class));
-        config = testRealm.getConfiguration();
-        config.getRealmFolder().equals(context.getFilesDir());
-        testRealm.close();
-        Realm.deleteRealm(config);
-    }
-
-    @Test
-    public void getInstance_nullContext() {
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance((Context) null); // throws when context.getFilesDir() is called;
-            // has nothing to do with Realm
-            fail("Should throw an exception");
-        } catch (IllegalArgumentException ignored) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    // Private API
-    @Test
-    public void remove() {
-        populateTestRealm();
-        realm.beginTransaction();
-        realm.remove(AllTypes.class, 0);
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> resultList = realm.where(AllTypes.class).findAll();
-        assertEquals(TEST_DATA_SIZE - 1, resultList.size());
-    }
-
-    // Private API
-    @Test
-    public void get() {
-        populateTestRealm();
-        AllTypes allTypes = realm.get(AllTypes.class, 0);
-        assertNotNull(allTypes);
-        assertEquals("test data 0", allTypes.getColumnString());
-    }
-
-    // Private API
-    @Test
-    public void contains() {
-        assertTrue("contains returns false for table that should exists", realm.contains(Dog.class));
-        assertFalse("contains returns true for non-existing table", realm.contains(null));
+        assertTrue("Realm.getInstance does not contain expected table", realm.getSchema().contains(AllTypes.CLASS_NAME));
     }
 
     @Test
@@ -553,7 +526,11 @@ public void nestedTransaction() {
         METHOD_CREATE_ALL_FROM_JSON,
         METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON,
         METHOD_CREATE_FROM_JSON,
-        METHOD_CREATE_OR_UPDATE_FROM_JSON
+        METHOD_CREATE_OR_UPDATE_FROM_JSON,
+        METHOD_INSERT_COLLECTION,
+        METHOD_INSERT_OBJECT,
+        METHOD_INSERT_OR_UPDATE_COLLECTION,
+        METHOD_INSERT_OR_UPDATE_OBJECT
     }
 
     // Calling methods on a wrong thread will fail.
@@ -604,6 +581,18 @@ public Boolean call() throws Exception {
                         case METHOD_CREATE_OR_UPDATE_FROM_JSON:
                             realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1}");
                             break;
+                        case METHOD_INSERT_COLLECTION:
+                            realm.insert(Arrays.asList(new AllTypes(), new AllTypes()));
+                            break;
+                        case METHOD_INSERT_OBJECT:
+                            realm.insert(new AllTypes());
+                            break;
+                        case METHOD_INSERT_OR_UPDATE_COLLECTION:
+                            realm.insert(Arrays.asList(new AllTypesPrimaryKey(), new AllTypesPrimaryKey()));
+                            break;
+                        case METHOD_INSERT_OR_UPDATE_OBJECT:
+                            realm.insertOrUpdate(new AllTypesPrimaryKey());
+                            break;
                     }
                     return false;
                 } catch (IllegalStateException ignored) {
@@ -1121,7 +1110,6 @@ public void copyToRealm_fromOtherRealm() {
     @Test
     public void copyToRealm() {
         Date date = new Date();
-        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
         Dog dog = new Dog();
         dog.setName("Fido");
         RealmList<Dog> list = new RealmList<Dog>();
@@ -1171,6 +1159,54 @@ public void copyToRealm_cyclicObjectReferences() {
         assertEquals("One", realmObject.getName());
         assertEquals("Two", realmObject.getObject().getName());
         assertEquals(2, realm.where(CyclicType.class).count());
+
+        // testing copyToRealm overload that uses the Iterator
+        // making sure we reuse the same graph cache Map to avoid duplicates
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(CyclicType.class).count());
+
+        realm.beginTransaction();
+        List<CyclicType> cyclicTypes = realm.copyToRealm(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+        assertEquals(2, cyclicTypes.size());
+        assertEquals("One", cyclicTypes.get(0).getName());
+        assertEquals("Two", cyclicTypes.get(1).getName());
+        assertEquals(2, realm.where(CyclicType.class).count());
+    }
+
+    @Test
+    public void copyToRealm_cyclicObjectReferencesWithPK() {
+        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1, "One");
+        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2, "Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        CyclicTypePrimaryKey realmObject = realm.copyToRealm(oneCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObject.getName());
+        assertEquals("Two", realmObject.getObject().getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
+
+        // testing copyToRealm overload that uses the Iterator
+        // making sure we reuse the same graph cache Map to avoid duplicates
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(CyclicTypePrimaryKey.class).count());
+
+        realm.beginTransaction();
+        List<CyclicTypePrimaryKey> cyclicTypes = realm.copyToRealm(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+        assertEquals(2, cyclicTypes.size());
+        assertEquals("One", cyclicTypes.get(0).getName());
+        assertEquals("Two", cyclicTypes.get(1).getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
     }
 
     @Test
@@ -1218,7 +1254,7 @@ public void copyToRealm_stringPrimaryKeyIsNull() {
         final long SECONDARY_FIELD_VALUE = 34992142L;
         TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsString> results = realm.allObjects(PrimaryKeyAsString.class);
+        RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class).findAll();
         assertEquals(1, results.size());
         assertEquals(null, results.first().getName());
         assertEquals(SECONDARY_FIELD_VALUE, results.first().getId());
@@ -1235,7 +1271,7 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
         TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    SECONDARY_FIELD_VALUE);
 
         for (Class clazz : CLASSES) {
-            RealmResults results = realm.allObjects(clazz);
+            RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
             assertEquals(null, ((NullPrimaryKey)results.first()).getId());
             assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey)results.first()).getName());
@@ -1291,7 +1327,7 @@ public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         childObj.setName("Child");
         childObj.setId(1);
 
-        // Parent object is a standalone object
+        // Parent object is an unmanaged object
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
         parentObj.setObject(childObj);
 
@@ -1362,7 +1398,7 @@ public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
         final long SECONDARY_FIELD_UPDATED = 44887612L;
         PrimaryKeyAsString nullPrimaryKeyObj = TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsString> result = realm.allObjects(PrimaryKeyAsString.class);
+        RealmResults<PrimaryKeyAsString> result = realm.where(PrimaryKeyAsString.class).findAll();
         assertEquals(1, result.size());
         assertEquals(null, result.first().getName());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getId());
@@ -1373,7 +1409,7 @@ public void copyToRealmOrUpdate_stringPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsString.class).first().getId());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsString.class).findFirst().getId());
     }
 
     @Test
@@ -1382,7 +1418,7 @@ public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullBytePrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedByte nullPrimaryKeyObj = TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedByte> result = realm.allObjects(PrimaryKeyAsBoxedByte.class);
+        RealmResults<PrimaryKeyAsBoxedByte> result = realm.where(PrimaryKeyAsBoxedByte.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1393,7 +1429,7 @@ public void copyToRealmOrUpdate_boxedBytePrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedByte.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedByte.class).findFirst().getName());
     }
 
     @Test
@@ -1402,7 +1438,7 @@ public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullShortPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedShort nullPrimaryKeyObj = TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedShort> result = realm.allObjects(PrimaryKeyAsBoxedShort.class);
+        RealmResults<PrimaryKeyAsBoxedShort> result = realm.where(PrimaryKeyAsBoxedShort.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1413,7 +1449,7 @@ public void copyToRealmOrUpdate_boxedShortPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedShort.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedShort.class).findFirst().getName());
     }
 
     @Test
@@ -1422,7 +1458,7 @@ public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullIntegerPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedInteger nullPrimaryKeyObj = TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedInteger> result = realm.allObjects(PrimaryKeyAsBoxedInteger.class);
+        RealmResults<PrimaryKeyAsBoxedInteger> result = realm.where(PrimaryKeyAsBoxedInteger.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1433,7 +1469,7 @@ public void copyToRealmOrUpdate_boxedIntegerPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedInteger.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedInteger.class).findFirst().getName());
     }
 
     @Test
@@ -1442,7 +1478,7 @@ public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
         final String SECONDARY_FIELD_UPDATED = "nullLongPrimaryKeyObjUpdated";
         PrimaryKeyAsBoxedLong nullPrimaryKeyObj = TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, SECONDARY_FIELD_VALUE);
 
-        RealmResults<PrimaryKeyAsBoxedLong> result = realm.allObjects(PrimaryKeyAsBoxedLong.class);
+        RealmResults<PrimaryKeyAsBoxedLong> result = realm.where(PrimaryKeyAsBoxedLong.class).findAll();
         assertEquals(1, result.size());
         assertEquals(SECONDARY_FIELD_VALUE, result.first().getName());
         assertEquals(null, result.first().getId());
@@ -1453,7 +1489,7 @@ public void copyToRealmOrUpdate_boxedLongPrimaryKeyFieldIsNull() {
         realm.copyToRealmOrUpdate(nullPrimaryKeyObj);
         realm.commitTransaction();
 
-        assertEquals(SECONDARY_FIELD_UPDATED, realm.allObjects(PrimaryKeyAsBoxedLong.class).first().getName());
+        assertEquals(SECONDARY_FIELD_UPDATED, realm.where(PrimaryKeyAsBoxedLong.class).findFirst().getName());
     }
 
     @Test
@@ -1557,7 +1593,7 @@ public void copyToRealmOrUpdate_cyclicObject() {
     }
 
 
-    // Checks that a standalone object with only default values can override data
+    // Checks that an unmanaged object with only default values can override data
     @Test
     public void copyToRealmOrUpdate_defaultValuesOverrideExistingData() {
         realm.executeTransaction(new Realm.Transaction() {
@@ -1938,23 +1974,13 @@ public void setter_updateField() throws Exception {
 
     @Test
     public void deleteRealm() throws InterruptedException {
-        File tempDir = new File(context.getFilesDir(), "delete_test_dir");
-        if (!tempDir.exists()) {
-            assertTrue(tempDir.mkdir());
-        }
-
-        assertTrue(tempDir.isDirectory());
-
-        // Delete all files in the directory
-        File[] files = tempDir.listFiles();
-        if (files != null) {
-            for (File file : files) {
-                assertTrue(file.delete());
-            }
-        }
+        File tempDir = new File(configFactory.getRoot(), "delete_test_dir");
+        File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
+        assertTrue(tempDir.mkdir());
 
         final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
 
+        final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
         final CountDownLatch readyToCloseLatch = new CountDownLatch(1);
         final CountDownLatch closedLatch = new CountDownLatch(1);
 
@@ -1964,6 +1990,7 @@ public void deleteRealm() throws InterruptedException {
             @Override
             public void run() {
                 Realm realm = Realm.getInstance(configuration);
+                bgThreadReadyLatch.countDown();
                 try {
                     readyToCloseLatch.await();
                 } catch (InterruptedException ignored) {
@@ -1976,14 +2003,19 @@ public void run() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
+
+        // Wait for bg thread's opening the same Realm.
+        TestHelper.awaitOrFail(bgThreadReadyLatch);
+
+        // A core upgrade might change the location of the files
+        assertTrue(tempDir.renameTo(tempDirRenamed));
         readyToCloseLatch.countDown();
+
         realm.close();
         closedLatch.await();
+        // Now we get log files back!
+        assertTrue(tempDirRenamed.renameTo(tempDir));
 
-        // ATTENTION: log, log_a, log_b will be deleted when the other thread close the Realm peacefully. And we force
-        // user to close all Realm instances before deleting. It would be difficult to simulate a case that log files
-        // exist before deletion. Let's keep the case like this for now, we might allow user to delete Realm even there
-        // are instances opened in the future.
         assertTrue(Realm.deleteRealm(configuration));
 
         // Directory should be empty now
@@ -1994,7 +2026,7 @@ public void run() {
     @Test
     public void callMutableMethodOutsideTransaction() throws JSONException, IOException {
 
-        // Prepare standalone object data
+        // Prepare unmanaged object data
         AllTypesPrimaryKey t = new AllTypesPrimaryKey();
         List<AllTypesPrimaryKey> ts = Arrays.asList(t, t);
 
@@ -2015,7 +2047,6 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
         try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.remove(AllTypes.class, 0);      fail(); } catch (IllegalStateException expected) {}
         try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
         try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
 
@@ -2148,7 +2179,7 @@ public void createObjectWithPrimaryKey_valueAlreadyExists() {
     public void createObjectWithPrimaryKey_null() {
         // Byte
         realm.beginTransaction();
-        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte= realm.createObject(PrimaryKeyAsBoxedByte.class, null);
+        PrimaryKeyAsBoxedByte primaryKeyAsBoxedByte = realm.createObject(PrimaryKeyAsBoxedByte.class, null);
         realm.commitTransaction();
         assertEquals(1, realm.where(PrimaryKeyAsBoxedByte.class).count());
         assertNull(primaryKeyAsBoxedByte.getId());
@@ -2381,85 +2412,6 @@ public void run() {
         }
     }
 
-    // This test assures that calling refresh will not trigger local listeners until after the Looper receives a
-    // REALM_CHANGE message
-    @Test
-    public void processRefreshLocalListenersAfterLooperQueueStart() throws Throwable {
-        // Used to validate the result
-        final AtomicBoolean listenerWasCalled = new AtomicBoolean(false);
-        final AtomicBoolean typeListenerWasCalled = new AtomicBoolean(false);
-
-        // Used by the background thread to wait for the main thread to do the write operation
-        final CountDownLatch bgThreadLatch = new CountDownLatch(1);
-        final CountDownLatch bgClosedLatch = new CountDownLatch(2);
-        final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
-        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-
-        final Looper[] looper = new Looper[1];
-        final Throwable[] throwable = new Throwable[1];
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        executorService.submit(new Runnable() {
-            @Override
-            public void run() {
-                // this will allow to register a listener.
-                // we don't start looping to prevent the callback to be invoked via
-                // the handler mechanism, the purpose of this test is to make sure refresh calls
-                // the listeners.
-                Looper.prepare();
-                looper[0] = Looper.myLooper();
-
-                Realm bgRealm = Realm.getInstance(realmConfig);
-                RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
-                try {
-                    bgRealm.addChangeListener(new RealmChangeListener() {
-                        @Override
-                        public void onChange() {
-                            listenerWasCalled.set(true);
-                            bgClosedLatch.countDown();
-                        }
-                    });
-                    dogs.addChangeListener(new RealmChangeListener() {
-                        @Override
-                        public void onChange() {
-                            typeListenerWasCalled.set(true);
-                            bgClosedLatch.countDown();
-                        }
-                    });
-
-                    bgThreadReadyLatch.countDown();
-                    bgThreadLatch.await(); // Wait for the main thread to do a write operation
-                    bgRealm.refresh(); // This should call the listener
-                    assertFalse(listenerWasCalled.get());
-                    assertFalse(typeListenerWasCalled.get());
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    throwable[0] = e;
-
-                } finally {
-                    bgRealm.close();
-                    signalClosedRealm.countDown();
-                }
-            }
-        });
-
-        // Wait until bgThread finishes adding listener to the RealmResults. Otherwise same TableView version won't
-        // trigger the listener.
-        bgThreadReadyLatch.await();
-        realm.beginTransaction();
-        realm.createObject(Dog.class);
-        realm.commitTransaction();
-        bgThreadLatch.countDown();
-        bgClosedLatch.await();
-
-        TestHelper.exitOrThrow(executorService, bgClosedLatch, signalClosedRealm, looper, throwable);
-
-        assertTrue(listenerWasCalled.get());
-        assertTrue(typeListenerWasCalled.get());
-    }
-
     @Test
     public void isInTransaction() {
         assertFalse(realm.isInTransaction());
@@ -2580,13 +2532,6 @@ public void run() {
         }
     }
 
-    @Test
-    public void refresh_insideTransactionThrows() {
-        realm.beginTransaction();
-        thrown.expect(IllegalStateException.class);
-        realm.refresh();
-    }
-
     @Test
     public void isEmpty() {
         RealmConfiguration realmConfig = configFactory.createConfiguration("empty_test.realm");
@@ -2649,24 +2594,24 @@ public void copyFromRealm_invalidDepthThrows() {
     public void copyFromRealm() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject = realm.copyFromRealm(realmObject);
-        assertArrayEquals(realmObject.getColumnBinary(), standaloneObject.getColumnBinary());
-        assertEquals(realmObject.getColumnString(), standaloneObject.getColumnString());
-        assertEquals(realmObject.getColumnLong(), standaloneObject.getColumnLong());
-        assertEquals(realmObject.getColumnFloat(), standaloneObject.getColumnFloat(), 0.00000000001);
-        assertEquals(realmObject.getColumnDouble(), standaloneObject.getColumnDouble(), 0.00000000001);
-        assertEquals(realmObject.isColumnBoolean(), standaloneObject.isColumnBoolean());
-        assertEquals(realmObject.getColumnDate(), standaloneObject.getColumnDate());
+        AllTypes unmanagedObject = realm.copyFromRealm(realmObject);
+        assertArrayEquals(realmObject.getColumnBinary(), unmanagedObject.getColumnBinary());
+        assertEquals(realmObject.getColumnString(), unmanagedObject.getColumnString());
+        assertEquals(realmObject.getColumnLong(), unmanagedObject.getColumnLong());
+        assertEquals(realmObject.getColumnFloat(), unmanagedObject.getColumnFloat(), 0.00000000001);
+        assertEquals(realmObject.getColumnDouble(), unmanagedObject.getColumnDouble(), 0.00000000001);
+        assertEquals(realmObject.isColumnBoolean(), unmanagedObject.isColumnBoolean());
+        assertEquals(realmObject.getColumnDate(), unmanagedObject.getColumnDate());
     }
 
     @Test
     public void copyFromRealm_newCopyEachTime() {
         populateTestRealm();
         AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
-        AllTypes standaloneObject1 = realm.copyFromRealm(realmObject);
-        AllTypes standaloneObject2 = realm.copyFromRealm(realmObject);
-        assertFalse(standaloneObject1 == standaloneObject2);
-        assertNotSame(standaloneObject1, standaloneObject2);
+        AllTypes unmanagedObject1 = realm.copyFromRealm(realmObject);
+        AllTypes unmanagedObject2 = realm.copyFromRealm(realmObject);
+        assertFalse(unmanagedObject1 == unmanagedObject2);
+        assertNotSame(unmanagedObject1, unmanagedObject2);
     }
 
     // Test that the object graph is copied as it is and no extra copies are made
@@ -2842,9 +2787,9 @@ public void closeRealmInChangeListener() {
             @Override
             public void run() {
                 final Realm realm = Realm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm object) {
                         if (realm.where(AllTypes.class).count() == 1) {
                             realm.removeChangeListener(this);
                             realm.close();
@@ -2870,17 +2815,17 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final Realm realm = looperThread.realm;
+        final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
             }
         };
 
         // Change listener on Realm
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 1) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -2911,15 +2856,15 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final Realm realm = looperThread.realm;
+        final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
-            public void onChange() {
+            public void onChange(AllTypes object) {
             }
         };
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 2) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -2956,15 +2901,15 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
-        final RealmChangeListener dummyListener = new RealmChangeListener() {
+        final Realm realm = looperThread.realm;
+        final RealmChangeListener<RealmResults<AllTypes>> dummyListener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<AllTypes> object) {
             }
         };
-        final RealmChangeListener listener = new RealmChangeListener() {
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(AllTypes.class).count() == 1) {
                     realm.removeChangeListener(this);
                     realm.close();
@@ -2992,6 +2937,72 @@ public void execute(Realm realm) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
+        final Realm realm = looperThread.realm;
+
+        try {
+            realm.addChangeListener(null);
+            fail("adding null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void addChangeListener_throwOnAddingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    realm.addChangeListener(null);
+                    fail("adding null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener_throwOnRemovingNullListenerFromLooperThread() {
+        final Realm realm = looperThread.realm;
+
+        try {
+            realm.removeChangeListener(null);
+            fail("removing null change listener must throw an exception.");
+        } catch (IllegalArgumentException ignore) {
+        } finally {
+            looperThread.testComplete();
+        }
+    }
+
+    @Test
+    public void removeChangeListener_throwOnRemovingNullListenerFromNonLooperThread() throws Throwable {
+        TestHelper.executeOnNonLooperThread(new TestHelper.Task() {
+            @Override
+            public void run() throws Exception {
+                final Realm realm = Realm.getInstance(realmConfig);
+
+                //noinspection TryFinallyCanBeTryWithResources
+                try {
+                    realm.removeChangeListener(null);
+                    fail("removing null change listener must throw an exception.");
+                } catch (IllegalArgumentException ignore) {
+                } finally {
+                    realm.close();
+                }
+            }
+        });
+    }
+
     @Test
     public void removeChangeListenerThrowExceptionOnNonLooperThread() {
         final CountDownLatch signalTestFinished = new CountDownLatch(1);
@@ -3000,9 +3011,9 @@ public void removeChangeListenerThrowExceptionOnNonLooperThread() {
             public void run() {
                 Realm realm = Realm.getInstance(realmConfig);
                 try {
-                    realm.removeChangeListener(new RealmChangeListener() {
+                    realm.removeChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                         }
                     });
                     fail("Should not be able to invoke removeChangeListener");
@@ -3068,4 +3079,373 @@ public void deleteAll() {
         assertEquals(0, realm.where(Cat.class).count());
         assertTrue(realm.isEmpty());
     }
+
+    @Test
+    public void waitForChange_emptyDataChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        realm.beginTransaction();
+        realm.commitTransaction();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(0, bgRealmWaitForChangeResult.get());
+    }
+
+    @Test
+    public void waitForChange_withDataChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());
+    }
+
+    @Test
+    public void waitForChange_syncBackgroundRealmResults() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmResultSize = new AtomicLong(0);
+
+        // wait in background
+        final CountDownLatch signalTestFinished = new CountDownLatch(1);
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+                // first make sure the results is empty
+                bgRealmResultSize.set(results.size());
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmResultSize.set(results.size());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        // background result should be empty
+        assertEquals(0, bgRealmResultSize.get());
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertTrue(bgRealmChangeResult.get());
+        // Once RealmResults are synchronized after waitForChange, the result size should be what we expect
+        assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());
+    }
+
+    @Test
+    public void stopWaitForChange() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(true);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        Thread.sleep(200);
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmChangeResult.get());
+    }
+
+    // Test if waitForChange doesn't blocks once stopWaitForChange has been called before.
+    @Test
+    public void waitForChange_stopWaitForChangeDisablesWaiting() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmStopped = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicBoolean bgRealmFirstWaitResult = new AtomicBoolean(true);
+        final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmFirstWaitResult.set(realm.waitForChange());
+                bgRealmStopped.countDown();
+                bgRealmSecondWaitResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        }).start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmStopped);
+        assertFalse(bgRealmFirstWaitResult.get());
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmSecondWaitResult.get());
+    }
+
+    // Test if waitForChange still blocks if stopWaitForChange has been called for a realm in a different thread.
+    @Test
+    public void waitForChange_blockSpecificThreadOnly() throws InterruptedException {
+        final CountDownLatch bgRealmsOpened = new CountDownLatch(2);
+        final CountDownLatch bgRealmsClosed = new CountDownLatch(2);
+        final AtomicBoolean bgRealmFirstWaitResult = new AtomicBoolean(true);
+        final AtomicBoolean bgRealmSecondWaitResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmWaitForChangeResult = new AtomicLong(0);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        Thread thread1 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmsOpened.countDown();
+                bgRealmFirstWaitResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmsClosed.countDown();
+            }
+        });
+
+        Thread thread2 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealmsOpened.countDown();
+                bgRealmSecondWaitResult.set(realm.waitForChange());
+                bgRealmWaitForChangeResult.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmsClosed.countDown();
+            }
+        });
+        thread1.start();
+        thread2.start();
+
+        TestHelper.awaitOrFail(bgRealmsOpened);
+        bgRealm.get().stopWaitForChange();
+        // wait for Thread 2 to wait
+        Thread.sleep(500);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmsClosed);
+        assertFalse(bgRealmFirstWaitResult.get());
+        assertTrue(bgRealmSecondWaitResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmWaitForChangeResult.get());
+    }
+
+    // Check if waitForChange() does not respond to Thread.interrupt().
+    @Test
+    public void waitForChange_interruptingThread() throws InterruptedException {
+        final CountDownLatch bgRealmOpened = new CountDownLatch(1);
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicReference<Boolean> bgRealmWaitResult = new AtomicReference<Boolean>();
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        // wait in background
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                bgRealmOpened.countDown();
+                bgRealmWaitResult.set(new Boolean(realm.waitForChange()));
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmOpened);
+        // make sure background thread goes to wait
+        Thread.sleep(500);
+        // interrupting a thread should neither cause any side effect nor terminate the Background Realm from waiting.
+        thread.interrupt();
+        assertTrue(thread.isInterrupted());
+        assertEquals(null, bgRealmWaitResult.get());
+
+        // now we'll stop realm from waiting
+        bgRealm.get().stopWaitForChange();
+        TestHelper.awaitOrFail(bgRealmClosed);
+        assertFalse(bgRealmWaitResult.get().booleanValue());
+    }
+
+    @Test
+    public void waitForChange_onLooperThread() throws Throwable {
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final ExceptionHolder bgError = new ExceptionHolder();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Looper.prepare();
+                Realm realm = Realm.getInstance(realmConfig);
+                try {
+                    realm.waitForChange();
+                    fail();
+                } catch (Throwable expected) {
+                    bgError.setException(expected);
+                } finally {
+                    realm.close();
+                    bgRealmClosed.countDown();
+                }
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmClosed);
+        if (bgError.getException() instanceof AssertionError) {
+            throw bgError.getException();
+        }
+        assertEquals(IllegalStateException.class, bgError.getException().getClass());
+    }
+
+    // Cannot wait inside of a transaction
+    @Test(expected= IllegalStateException.class)
+    public void waitForChange_illegalWaitInsideTransaction() {
+        realm.beginTransaction();
+        realm.waitForChange();
+    }
+
+    @Test
+    public void waitForChange_stopWaitingOnClosedRealmThrows() throws InterruptedException {
+        final CountDownLatch bgRealmClosed = new CountDownLatch(1);
+        final AtomicReference<Realm> bgRealm = new AtomicReference<Realm>();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(realmConfig);
+                bgRealm.set(realm);
+                realm.close();
+                bgRealmClosed.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmClosed);
+        try {
+            bgRealm.get().stopWaitForChange();
+            fail("Cannot stop a closed Realm from waiting");
+        } catch (IllegalStateException expected) {
+        }
+    }
+
+    // waitForChange & stopWaitForChange within a simple Thread wrapper.
+    @Test
+    public void waitForChange_runWithRealmThread() throws InterruptedException {
+        final CountDownLatch bgRealmStarted = new CountDownLatch(1);
+        final CountDownLatch bgRealmFished = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(false);
+        final AtomicLong bgRealmResultSize = new AtomicLong(0);
+
+        RealmThread thread = new RealmThread(realmConfig, new RealmThread.RealmRunnable() {
+            @Override
+            public void run(Realm realm) {
+                bgRealmStarted.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                bgRealmResultSize.set(realm.where(AllTypes.class).count());
+                realm.close();
+                bgRealmFished.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmStarted);
+        populateTestRealm();
+        TestHelper.awaitOrFail(bgRealmFished);
+        assertTrue(bgRealmChangeResult.get());
+        assertEquals(TEST_DATA_SIZE, bgRealmResultSize.get());
+    }
+
+    @Test
+    public void waitForChange_endRealmThread() throws InterruptedException {
+        final CountDownLatch bgRealmStarted = new CountDownLatch(1);
+        final CountDownLatch bgRealmFished = new CountDownLatch(1);
+        final AtomicBoolean bgRealmChangeResult = new AtomicBoolean(true);
+
+        RealmThread thread = new RealmThread(realmConfig, new RealmThread.RealmRunnable() {
+            @Override
+            public void run(Realm realm) {
+                bgRealmStarted.countDown();
+                bgRealmChangeResult.set(realm.waitForChange());
+                realm.close();
+                bgRealmFished.countDown();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgRealmStarted);
+        thread.end();
+        TestHelper.awaitOrFail(bgRealmFished);
+        assertFalse(bgRealmChangeResult.get());
+    }
+
+    @Test
+    public void incompatibleLockFile() throws IOException {
+        // Replace .lock file with a corrupted one
+        File lockFile = new File(realmConfig.getPath() + ".lock");
+        assertTrue(lockFile.exists());
+        FileOutputStream fooStream = new FileOutputStream(lockFile, false);
+        fooStream.write("Boom".getBytes());
+        fooStream.close();
+
+        try {
+            // This will try to open a second SharedGroup which should fail when the .lock file is corrupt
+            DynamicRealm.getInstance(realm.getConfiguration());
+            fail();
+        } catch (RealmError expected) {
+            assertTrue(expected.getMessage().contains("Info size doesn't match"));
+        } finally {
+            lockFile.delete();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index ac2122a32d..bce5a2d917 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -187,7 +187,7 @@ public void call(AllTypes rxObject) {
     @UiThreadTest
     public void realmResults_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
             @Override
             public void call(RealmResults<AllTypes> rxResults) {
@@ -204,7 +204,7 @@ public void call(RealmResults<AllTypes> rxResults) {
     public void dynamicRealmResults_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
             @Override
             public void call(RealmResults<DynamicRealmObject> rxResults) {
@@ -222,7 +222,7 @@ public void realmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.realm;
         realm.beginTransaction();
-        RealmResults<AllTypes> results = realm.allObjects(AllTypes.class);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.commitTransaction();
 
         subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
@@ -245,7 +245,7 @@ public void dynamicRealmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         final DynamicRealm dynamicRealm = DynamicRealm.createInstance(looperThread.realmConfiguration);
         dynamicRealm.beginTransaction();
-        RealmResults<DynamicRealmObject> results = dynamicRealm.allObjects(AllTypes.CLASS_NAME);
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
 
         results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
@@ -491,7 +491,7 @@ public void call(DynamicRealm rxRealm) {
     @Test
     @UiThreadTest
     public void realmResults_closeInDoOnUnsubscribe() {
-        Observable<RealmResults<AllTypes>> observable = realm.allObjects(AllTypes.class).asObservable()
+        Observable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -514,7 +514,7 @@ public void call(RealmResults<AllTypes> allTypes) {
     public void dynamicRealmResults_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).asObservable()
+        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -539,7 +539,7 @@ public void realmObject_closeInDoOnUnsubscribe() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<AllTypes> observable = realm.allObjects(AllTypes.class).first().<AllTypes>asObservable()
+        Observable<AllTypes> observable = realm.where(AllTypes.class).findFirst().<AllTypes>asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
@@ -565,7 +565,7 @@ public void dynamicRealmObject_closeInDoOnUnsubscribe() {
         realm.commitTransaction();
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealmObject> observable = dynamicRealm.allObjects(AllTypes.CLASS_NAME).first().<DynamicRealmObject>asObservable()
+        Observable<DynamicRealmObject> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asObservable()
                 .doOnUnsubscribe(new Action0() {
                     @Override
                     public void call() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 5835953c0e..396e9cdf91 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -16,13 +16,39 @@
 
 package io.realm;
 
-import android.test.AndroidTestCase;
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
 import io.realm.internal.TableView;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SortTest {
+    private Realm realm;
 
-public class SortTest extends AndroidTestCase {
-    private Realm testRealm = null;
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Context context;
+    private RealmConfiguration realmConfig;
 
     private final static String FIELD_STRING = "columnString";
     private final static String FIELD_LONG = "columnLong";
@@ -33,44 +59,54 @@
     private final static Sort[] ORDER_ASC_ASC = {Sort.ASCENDING, Sort.ASCENDING};
     private final static Sort[] ORDER_ASC_DES = {Sort.ASCENDING, Sort.DESCENDING};
 
-    @Override
-    public void setUp() {
-        // Creates a Realm with the following objects:
-        // 0: (5, "Adam")
-        // 1: (4, "Brian")
-        // 2: (4, "Adam")
-        // 3: (5, "Adam")
-        RealmConfiguration config = TestHelper.createConfiguration(getContext());
-        Realm.deleteRealm(config);
-        testRealm = Realm.getInstance(config);
-
-        testRealm.beginTransaction();
-        testRealm.delete(AllTypes.class);
-        AllTypes object1 = testRealm.createObject(AllTypes.class);
+    private void populateRealm(Realm realm) {
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        AllTypes object1 = realm.createObject(AllTypes.class);
         object1.setColumnLong(5);
         object1.setColumnString("Adam");
 
-        AllTypes object2 = testRealm.createObject(AllTypes.class);
+        AllTypes object2 = realm.createObject(AllTypes.class);
         object2.setColumnLong(4);
         object2.setColumnString("Brian");
 
-        AllTypes object3 = testRealm.createObject(AllTypes.class);
+        AllTypes object3 = realm.createObject(AllTypes.class);
         object3.setColumnLong(4);
         object3.setColumnString("Adam");
 
-        AllTypes object4 = testRealm.createObject(AllTypes.class);
+        AllTypes object4 = realm.createObject(AllTypes.class);
         object4.setColumnLong(5);
         object4.setColumnString("Adam");
-        testRealm.commitTransaction();
+        realm.commitTransaction();
+    }
+
+    @Before
+    public void setUp() {
+        // Creates a Realm with the following objects:
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+
+        // Injecting the Instrumentation instance is required
+        // for your test to run with AndroidJUnitRunner.
+        context = InstrumentationRegistry.getInstrumentation().getContext();
+        realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+
+        populateRealm(realm);
     }
 
-    @Override
-    public void tearDown() throws Exception {
-        testRealm.close();
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
     }
 
-    public void testSortMultiFailures() {
-        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
+    @Test
+    public void sortMultiFailures() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
         // zero fields specified
         try {
@@ -88,7 +124,7 @@ public void testSortMultiFailures() {
 
         // null is not allowed
         try {
-            allTypes.sort(null, (Sort[])null);
+            allTypes.sort(null, (Sort[]) null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -117,19 +153,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -143,19 +179,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -169,19 +205,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -195,108 +231,290 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, ((TableView)results.getTable()).getSourceRowIndex(0));
+        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(3, ((TableView)results.getTable()).getSourceRowIndex(1));
+        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, ((TableView)results.getTable()).getSourceRowIndex(2));
+        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView)results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
     }
 
-    public void testSortRealmResultsTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void sortRealmResultsTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class).findAll().sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class).findAll().sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.allObjects(AllTypes.class).sort(ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class).findAll().sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.allObjects(AllTypes.class).sort(ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class).findAll().sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
-   }
-
+    }
 
-    public void testRealmQuerySortTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void realmQuerySortTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.where(AllTypes.class)
-                .findAllSorted(ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class)
+                .findAll().sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
     }
 
-    public void testRealmSortTwoFields() {
-        RealmResults<AllTypes> results1 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_STRING_INT, ORDER_ASC_ASC);
+    @Test
+    public void realmSortTwoFields() {
+        RealmResults<AllTypes> results1 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_STRING_INT, ORDER_ASC_ASC);
         checkSortTwoFieldsStringAscendingIntAscending(results1);
 
-        RealmResults<AllTypes> results2 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_INT_STRING, ORDER_ASC_ASC);
+        RealmResults<AllTypes> results2 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_INT_STRING, ORDER_ASC_ASC);
         checkSortTwoFieldsIntString(results2);
 
-        RealmResults<AllTypes> results3 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_STRING_INT, ORDER_ASC_DES);
+        RealmResults<AllTypes> results3 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_STRING_INT, ORDER_ASC_DES);
         checkSortTwoFieldsStringAscendingIntDescending(results3);
 
-        RealmResults<AllTypes> results4 = testRealm.allObjectsSorted(AllTypes.class,
-                ORDER_INT_STRING, ORDER_ASC_DES);
+        RealmResults<AllTypes> results4 = realm.where(AllTypes.class).findAll().
+                sort(ORDER_INT_STRING, ORDER_ASC_DES);
         checkSortTwoFieldsIntAscendingStringDescending(results4);
     }
 
-    public void testRealmSortMultiFailures() {
-        RealmResults<AllTypes> allTypes = testRealm.allObjects(AllTypes.class);
+    @Test
+    public void realmSortMultiFailures() {
+        RealmResults<AllTypes> allTypes = realm.where(AllTypes.class).findAll();
 
         // zero fields specified
         try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{}, new Sort[]{});
+            realm.where(AllTypes.class).findAll().sort(new String[]{}, new Sort[]{});
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // number of fields and sorting orders don't match
         try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING}, ORDER_ASC_ASC);
+            realm.where(AllTypes.class).findAll().
+                    sort(new String[]{FIELD_STRING}, ORDER_ASC_ASC);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // null is not allowed
         try {
-            testRealm.allObjectsSorted(AllTypes.class, null, (Sort[])null);
+            realm.where(AllTypes.class).findAll().sort(null, (Sort[]) null);
             fail();
-        } catch (IllegalArgumentException ignored) {}
+        } catch (IllegalArgumentException ignored) {
+        }
         try {
-            testRealm.allObjectsSorted(AllTypes.class, new String[]{FIELD_STRING}, null);
+            realm.where(AllTypes.class).findAll().sort(new String[]{FIELD_STRING}, null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // non-existing field name
         try {
-            testRealm.allObjectsSorted(AllTypes.class,
-                    new String[]{FIELD_STRING, "dont-exist"},
-                    ORDER_ASC_ASC);
+            realm.where(AllTypes.class).findAll().
+                    sort(new String[]{FIELD_STRING, "dont-exist"}, ORDER_ASC_ASC);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void resorting() throws InterruptedException {
+        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
+
+        final Realm realm = looperThread.realm;
+        realm.setAutoRefresh(true);
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+        populateRealm(realm);
+
+        // rr0: [0, 1, 2, 3]
+        final RealmResults<AllTypes> rr0 = realm.where(AllTypes.class).findAll();
+        looperThread.keepStrongReference.add(rr0);
+        rr0.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [0, 1, 2, 3, 4] - most likely as order isn't guaranteed
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+
+        // rr1: [1, 2, 0, 3]
+        final RealmResults<AllTypes> rr1 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.ASCENDING);
+        looperThread.keepStrongReference.add(rr1);
+        rr1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [1, 2, 0, 3, 4]
+                assertEquals(4, element.first().getColumnLong());
+                assertEquals(6, element.last().getColumnLong());
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+        assertEquals(4, rr1.first().getColumnLong());
+        assertEquals(5, rr1.last().getColumnLong());
+
+        // rr2: [0, 3, 1, 2]
+        final RealmResults<AllTypes> rr2 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.DESCENDING);
+        looperThread.keepStrongReference.add(rr2);
+        rr2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                // After commit: [4, 0, 3, 1, 2]
+                assertEquals(6, element.first().getColumnLong());
+                assertEquals(4, element.last().getColumnLong());
+                assertEquals(5, element.size());
+                endTest.run();
+            }
+        });
+        assertEquals(5, rr2.first().getColumnLong());
+        assertEquals(4, rr2.last().getColumnLong());
+
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                assertEquals(5, element.where(AllTypes.class).findAll().size());
+                endTest.run();
+            }
+        });
+
+        // After commit:
+        // 0: (5, "Adam")
+        // 1: (4, "Brian")
+        // 2: (4, "Adam")
+        // 3: (5, "Adam")
+        // 4: (6, "")
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnLong(6);
+        realm.commitTransaction();
+    }
+
+    private void populateDates(Realm realm, int n) {
+        realm.beginTransaction();
+        realm.delete(AllTypes.class);
+        for (int i = 0; i < n; i++) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnDate(new Date(i));
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void sortingDates() {
+        final int TEST_SIZE = 10;
+
+        populateDates(realm, TEST_SIZE);
+
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, objectsAscending.size());
+        int i = 0;
+        for (AllTypes allTypes : objectsAscending) {
+            assertEquals(new Date(i), allTypes.getColumnDate());
+            i++;
+        }
+
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, objectsDescending.size());
+        i = TEST_SIZE - 1;
+        for (AllTypes allTypes : objectsDescending) {
+            assertEquals(new Date(i), allTypes.getColumnDate());
+            i--;
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void resortingDates() {
+        final int TEST_SIZE = 10;
+        final AtomicInteger changeListenerCalled = new AtomicInteger(2);
+
+        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        realm.setAutoRefresh(true);
+        populateDates(realm, TEST_SIZE);
+
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
+
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, objectsAscending.size());
+        looperThread.keepStrongReference.add(objectsAscending);
+        objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(TEST_SIZE + 1, element.size());
+                int i = 0;
+                for (AllTypes allTypes : element) {
+                    assertEquals(new Date(i), allTypes.getColumnDate());
+                    i++;
+                }
+                endTest.run();
+            }
+        });
+
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, objectsDescending.size());
+        looperThread.keepStrongReference.add(objectsDescending);
+        objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(TEST_SIZE + 1, element.size());
+                int i = element.size() - 1;
+                for (AllTypes allTypes : element) {
+                    assertEquals(new Date(i), allTypes.getColumnDate());
+                    i--;
+                }
+                endTest.run();
+            }
+        });
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnDate(new Date(TEST_SIZE));
+        realm.commitTransaction();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 79613954e9..2239f6d66c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -41,6 +41,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
@@ -77,7 +78,7 @@ public void onResult(int count) {
         }
     }
 
-    public static RealmFieldType getColumnType(Object o){
+    public static RealmFieldType getColumnType(Object o) {
         if (o instanceof Boolean)
             return RealmFieldType.BOOLEAN;
         if (o instanceof String)
@@ -97,9 +98,10 @@ public static RealmFieldType getColumnType(Object o){
 
     /**
      * Creates an empty table with 1 column of all our supported column types, currently 9 columns
+     *
      * @return
      */
-    public static Table getTableWithAllColumnTypes(){
+    public static Table getTableWithAllColumnTypes() {
         Table t = new Table();
 
         t.addColumn(RealmFieldType.BINARY, "binary");
@@ -108,9 +110,7 @@ public static Table getTableWithAllColumnTypes(){
         t.addColumn(RealmFieldType.DOUBLE, "double");
         t.addColumn(RealmFieldType.FLOAT, "float");
         t.addColumn(RealmFieldType.INTEGER, "long");
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
         t.addColumn(RealmFieldType.STRING, "string");
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         return t;
     }
@@ -316,7 +316,7 @@ public int read() throws IOException {
         if (garbageSize == 0) {
             long maxMemory = Runtime.getRuntime().maxMemory();
             long totalMemory = Runtime.getRuntime().totalMemory();
-            garbageSize = (int)(maxMemory - totalMemory)/10*9;
+            garbageSize = (int) (maxMemory - totalMemory) / 10 * 9;
         }
         byte garbage[] = new byte[0];
         try {
@@ -326,7 +326,7 @@ public int read() throws IOException {
                 garbage[garbage.length - 1] = 1;
             }
         } catch (OutOfMemoryError oom) {
-            return allocGarbage(garbageSize/10*9);
+            return allocGarbage(garbageSize / 10 * 9);
         }
 
         return garbage;
@@ -633,7 +633,7 @@ public static void populateTestRealmForNullTests(Realm testRealm) {
         testRealm.commitTransaction();
     }
 
-    public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
+    public static void populateAllNonNullRowsForNumericTesting(Realm realm) {
         NullTypes nullTypes1 = new NullTypes();
         nullTypes1.setId(1);
         nullTypes1.setFieldIntegerNull(3);
@@ -668,7 +668,7 @@ public static void populateAllNonNullRowsForNumericTesting (Realm realm) {
         realm.commitTransaction();
     }
 
-    public static void populatePartialNullRowsForNumericTesting (Realm realm) {
+    public static void populatePartialNullRowsForNumericTesting(Realm realm) {
         // Id values are [1, 2, 3]
         // IntegerNull values are [3, null, 4]
         // FloatNull values are [4F, null, 5F]
@@ -796,7 +796,7 @@ public static void populateForMultiSort(Realm typedRealm) {
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(typedRealm.getConfiguration());
         populateForMultiSort(dynamicRealm);
         dynamicRealm.close();
-        typedRealm.refresh();
+        typedRealm.waitForChange();
     }
 
     public static void populateForMultiSort(DynamicRealm realm) {
@@ -951,7 +951,7 @@ public static void quitLooperOrFail() {
      * @param executor {@link RealmThreadPoolExecutor} that should replace the current one
      */
     public static RealmThreadPoolExecutor replaceRealmThreadExectutor(RealmThreadPoolExecutor executor) throws NoSuchFieldException, IllegalAccessException {
-        Field field = BaseRealm.class.getDeclaredField("asyncQueryExecutor");
+        Field field = BaseRealm.class.getDeclaredField("asyncTaskExecutor");
         field.setAccessible(true);
         RealmThreadPoolExecutor oldExecutor = (RealmThreadPoolExecutor) field.get(null);
         field.set(field, executor);
@@ -976,4 +976,31 @@ public static void emulateRxJavaUnavailable(RealmConfiguration config) {
         }
     }
 
+    public static abstract class Task {
+        public abstract void run() throws Exception;
+    }
+
+    public static void executeOnNonLooperThread(final Task task) throws Throwable {
+        final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>();
+        final Thread thread = new Thread() {
+            @Override
+            public void run() {
+                try {
+                    task.run();
+                } catch (Throwable e) {
+                    thrown.set(e);
+                    if (e instanceof Error) {
+                        throw (Error) e;
+                    }
+                }
+            }
+        };
+        thread.start();
+        thread.join();
+
+        final Throwable throwable = thrown.get();
+        if (throwable != null) {
+            throw throwable;
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index eb4f467371..34cbeef9ef 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -43,7 +43,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsLong;
-import io.realm.internal.RealmObjectProxy;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -86,9 +85,9 @@ public void setUp() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -105,9 +104,10 @@ public void run() {
         final Dog dog = realm.createObject(Dog.class);
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertEquals("Akamaru", dog.getName());
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -122,9 +122,10 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject_dynamic_realm() {
         final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
-        realm.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(realm);
+        realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -142,9 +143,10 @@ public void run() {
         final DynamicRealmObject dog = realm.createObject("Dog");
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
-            public void onChange() {
+            public void onChange(DynamicRealmObject object) {
                 assertEquals("Akamaru", dog.getString("name"));
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -160,9 +162,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealm() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -181,9 +183,10 @@ public void run() {
         final Dog dog = realm.copyToRealm(akamaru);
         realm.commitTransaction();
 
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 assertEquals(8, dog.getAge());
                 typebasedCommitInvocations.incrementAndGet();
             }
@@ -199,9 +202,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_copyToRealmOrUpdate() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -222,12 +225,13 @@ public void run() {
         final PrimaryKeyAsLong primaryKeyAsLong = realm.copyToRealmOrUpdate(obj);
         realm.commitTransaction();
 
-        primaryKeyAsLong.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(primaryKeyAsLong);
+        primaryKeyAsLong.addChangeListener(new RealmChangeListener<PrimaryKeyAsLong>() {
             @Override
-            public void onChange() {
+            public void onChange(PrimaryKeyAsLong object) {
                 assertEquals(1, primaryKeyAsLong.getId());
                 assertEquals("Bar", primaryKeyAsLong.getName());
-                assertEquals(1, realm.allObjects(PrimaryKeyAsLong.class).size());
+                assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
                 typebasedCommitInvocations.incrementAndGet();
             }
         });
@@ -247,9 +251,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -269,9 +273,10 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            looperThread.keepStrongReference.add(objectFromJson);
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypes object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
@@ -296,9 +301,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -324,9 +329,10 @@ public void run() {
             final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
             realm.commitTransaction();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            looperThread.keepStrongReference.add(objectFromJson);
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypes object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1.23F, objectFromJson.getColumnFloat(), 0F);
@@ -351,9 +357,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -387,9 +393,10 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
-            objectFromJson.addChangeListener(new RealmChangeListener() {
+            looperThread.keepStrongReference.add(objectFromJson);
+            objectFromJson.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
                 @Override
-                public void onChange() {
+                public void onChange(AllTypesPrimaryKey object) {
                     assertEquals("ObjectFromJson", objectFromJson.getColumnString());
                     assertEquals(1L, objectFromJson.getColumnLong());
                     assertEquals(1F, objectFromJson.getColumnFloat(), 0F);
@@ -416,9 +423,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONObject() throws JSONException {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -446,10 +453,11 @@ public void run() {
         final AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
         realm.commitTransaction();
 
-        newObj.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(newObj);
+        newObj.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
-            public void onChange() {
-                assertEquals(1, realm.allObjects(AllTypesPrimaryKey.class).size());
+            public void onChange(AllTypesPrimaryKey object) {
+                assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
                 assertEquals("bar", newObj.getColumnString());
                 assertTrue(newObj.getColumnBoxedBoolean());
                 typebasedCommitInvocations.incrementAndGet();
@@ -479,9 +487,10 @@ public void callback_with_relevant_commit_realmobject_sync() {
         realm.commitTransaction();
 
         final Dog dog = realm.where(Dog.class).findFirst();
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 // Step 4: Respond to relevant change
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals("Akamaru", dog.getName());
@@ -489,9 +498,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -537,9 +546,10 @@ public void callback_with_relevant_commit_realmobject_async() {
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
 
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1:
                         assertEquals("Akamaru", dog.getName());
@@ -554,9 +564,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -605,18 +615,19 @@ public void callback_with_relevant_commit_from_different_looper_realmobject_asyn
         final Handler looperHandler2 = new Handler(looperThread2.getLooper());
         final Handler looperHandler3 = new Handler(looperThread3.getLooper());
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 globalCommitInvocations.incrementAndGet();
             }
         });
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1: // triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load()
                         assertTrue(dog.isLoaded());
@@ -705,18 +716,19 @@ public void run() {
     public void callback_with_relevant_commit_from_different_non_looper_realmobject_async() throws Throwable {
         final CountDownLatch nonLooperThread3CloseLatch = new CountDownLatch(1);
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 globalCommitInvocations.incrementAndGet();
             }
         });
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1:  // triggered by COMPLETED_ASYNC_REALM_OBJECT
                         new RealmBackgroundTask(realm.configuration) {
@@ -798,9 +810,10 @@ public void callback_with_relevant_commit_realmresults_sync() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 // Step 4: Respond to relevant change
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals(1, dogs.size());
@@ -809,9 +822,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -855,9 +868,10 @@ public void callback_with_relevant_commit_realmresults_async() {
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
-        dogs.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 // Step 4: Respond to relevant change
                 int commits = typebasedCommitInvocations.incrementAndGet();
                 switch (commits) {
@@ -871,9 +885,9 @@ public void onChange() {
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 int commits = globalCommitInvocations.incrementAndGet();
                 switch (commits) {
                     case 1:
@@ -913,9 +927,9 @@ public void run() {
     public void multiple_callbacks_should_be_invoked_realmobject_sync() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -931,10 +945,11 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
+        looperThread.keepStrongReference.add(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -951,9 +966,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmobject_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        RealmChangeListener listener = new RealmChangeListener() {
+        RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -972,10 +987,11 @@ public void run() {
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
+        looperThread.keepStrongReference.add(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dog.addChangeListener(new RealmChangeListener() {
+            dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
-                public void onChange() {
+                public void onChange(Dog object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -992,9 +1008,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmresults_sync() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -1010,10 +1026,11 @@ public void run() {
         realm.commitTransaction();
 
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        looperThread.keepStrongReference.add(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dogs.addChangeListener(new RealmChangeListener() {
+            dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
-                public void onChange() {
+                public void onChange(RealmResults<Dog> object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -1030,9 +1047,9 @@ public void onChange() {
     public void multiple_callbacks_should_be_invoked_realmresults_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 realm.handler.post(new Runnable() {
                     @Override
                     public void run() {
@@ -1050,10 +1067,11 @@ public void run() {
         RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
 
+        looperThread.keepStrongReference.add(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
-            dogs.addChangeListener(new RealmChangeListener() {
+            dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
-                public void onChange() {
+                public void onChange(RealmResults<Dog> object) {
                     typebasedCommitInvocations.incrementAndGet();
                 }
             });
@@ -1077,9 +1095,9 @@ public void onChange() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_sync() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
@@ -1097,9 +1115,10 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 typebasedCommitInvocations.incrementAndGet();
             }
         });
@@ -1130,15 +1149,15 @@ public void run() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmobject_async() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 // Check if the 2nd transaction is committed.
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(2,typebasedCommitInvocations.get());
+                            assertEquals(2, typebasedCommitInvocations.get());
                             looperThread.testComplete();
                         }
                     });
@@ -1169,9 +1188,10 @@ public void run() {
         };
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
-        dog.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dog);
+        dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
-            public void onChange() {
+            public void onChange(Dog object) {
                 typebasedCommitInvocations.incrementAndGet();
 
                 if (typebasedCommitInvocations.get() == 1) {
@@ -1195,14 +1215,14 @@ public void onChange() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_sync() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(typebasedCommitInvocations.get(),1);
+                            assertEquals(typebasedCommitInvocations.get(), 1);
                             looperThread.testComplete();
                         }
                     });
@@ -1215,9 +1235,10 @@ public void run() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals(2, dogs.size());
             }
@@ -1249,14 +1270,14 @@ public void run() {
     @RunTestInLooperThread
     public void non_looper_thread_commit_realmresults_async() {
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange() {
+            public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
                     realm.handler.post(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(2,typebasedCommitInvocations.get());
+                            assertEquals(2, typebasedCommitInvocations.get());
                             looperThread.testComplete();
                         }
                     });
@@ -1280,9 +1301,10 @@ public void run() {
         };
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        dogs.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 typebasedCommitInvocations.incrementAndGet();
                 if (typebasedCommitInvocations.get() == 1) {
                     // COMPLETED_ASYNC_REALM_RESULTS arrived
@@ -1316,9 +1338,9 @@ public void run() {
                     bgRealm.createObject(Dog.class);
                     bgRealm.commitTransaction();
 
-                    bgRealm.addChangeListener(new RealmChangeListener() {
+                    bgRealm.addChangeListener(new RealmChangeListener<Realm>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Realm object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1348,9 +1370,9 @@ public void run() {
                     bgRealm.commitTransaction();
 
                     Dog dog = bgRealm.where(Dog.class).findFirst();
-                    dog.addChangeListener(new RealmChangeListener() {
+                    dog.addChangeListener(new RealmChangeListener<Dog>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(Dog object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1380,9 +1402,9 @@ public void run() {
                     bgRealm.commitTransaction();
 
                     RealmResults<Dog> dogs = bgRealm.where(Dog.class).findAll();
-                    dogs.addChangeListener(new RealmChangeListener() {
+                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                         @Override
-                        public void onChange() {
+                        public void onChange(RealmResults<Dog> object) {
                             fail("Callback should not be registered and invoked on a non-Looper thread");
                         }
                     });
@@ -1398,44 +1420,6 @@ public void onChange() {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // Test modifying realmObjects in RealmObject's change listener
-    @Test
-    @RunTestInLooperThread
-    public void change_realm_objects_map_in_listener() throws InterruptedException {
-        final Realm realm = looperThread.realm;
-        realm.beginTransaction();
-        // At least two objects are needed to make sure list modification happen during iterating.
-        final Cat cat = realm.createObject(Cat.class);
-        final Owner owner = realm.createObject(Owner.class);
-        owner.setCat(cat);
-        realm.commitTransaction();
-
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange() {
-                Cat cat = owner.getCat();
-                boolean foundKey = false;
-                // Check if cat has been added to the realmObjects in case of the behaviour of getCat changes
-                for (WeakReference<RealmObjectProxy> weakReference : realm.handlerController.realmObjects.keySet()) {
-                    if (weakReference.get() == cat) {
-                        foundKey = true;
-                        break;
-                    }
-                }
-                assertTrue(foundKey);
-                looperThread.testComplete();
-            }
-        };
-
-        cat.addChangeListener(listener);
-        owner.addChangeListener(listener);
-
-        realm.beginTransaction();
-        // To make sure the shared group version changed
-        realm.createObject(Owner.class);
-        realm.commitTransaction();
-    }
-
     // Test modifying syncRealmResults in RealmResults's change listener
     @Test
     @RunTestInLooperThread
@@ -1444,12 +1428,12 @@ public void change_realm_results_map_in_listener() throws InterruptedException {
 
         final Realm realm = looperThread.realm;
         // Two results needed to make sure list modification happen while iterating
-        RealmResults<Owner> results1 = realm.allObjects(Owner.class);
-        RealmResults<Cat> results2 = realm.allObjects(Cat.class);
+        RealmResults<Owner> results1 = realm.where(Owner.class).findAll();
+        RealmResults<Cat> results2 = realm.where(Cat.class).findAll();
         RealmChangeListener listener = new RealmChangeListener() {
             @Override
-            public void onChange() {
-                RealmResults<Owner> results = realm.allObjects(Owner.class);
+            public void onChange(Object object) {
+                RealmResults<Owner> results = realm.where(Owner.class).findAll();
                 boolean foundKey = false;
                 // Check if the results has been added to the syncRealmResults in case of the behaviour of
                 // allObjects changes
@@ -1465,6 +1449,8 @@ public void onChange() {
                 finishedLatch.countDown();
             }
         };
+        looperThread.keepStrongReference.add(results1);
+        looperThread.keepStrongReference.add(results2);
         results1.addChangeListener(listener);
         results2.addChangeListener(listener);
 
@@ -1490,9 +1476,10 @@ public void changeListener_onResultsBuiltOnDeletedLinkView() {
 
         final RealmResults<Dog> dogs =
                 allTypes.getColumnRealmList().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
-        dogs.addChangeListener(new RealmChangeListener() {
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void onChange() {
+            public void onChange(RealmResults<Dog> object) {
                 if (typebasedCommitInvocations.getAndIncrement() == 0) {
                     assertTrue(dogs.isValid());
                     assertEquals(0, dogs.size());
@@ -1516,7 +1503,7 @@ public void onChange() {
             @Override
             public void run() {
                 realm.close();
-                assertEquals(1,typebasedCommitInvocations.get());
+                assertEquals(1, typebasedCommitInvocations.get());
                 looperThread.testComplete();
             }
         });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index cf0da4bd50..2a5308d913 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -24,7 +24,7 @@
 import io.realm.annotations.Index;
 import io.realm.annotations.PrimaryKey;
 
-public class AllJavaTypes extends RealmObject{
+public class AllJavaTypes extends RealmObject {
 
     public static final String CLASS_NAME = "AllJavaTypes";
     public static String FIELD_IGNORED = "fieldIgnored";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
similarity index 63%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
index 7bc898b5c8..0b791f675e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,19 +14,13 @@
  * limitations under the License.
  */
 
-package io.realm.internal.test;
+package io.realm.entities;
 
-import io.realm.internal.DefineTable;
+import io.realm.annotations.RealmModule;
 
 /**
- * A helper class containing model(s) for simple code generation tests.
+ * module definition for "asset_file.realm"
  */
-class CodeGenTest {
-
-    @DefineTable // this is enabled only for occasional local tests
-    class someModel {
-        String name;
-        int age;
-    }
-
+@RealmModule(classes = {Owner.class, Cat.class, Dog.class, DogPrimaryKey.class})
+public class AssetFileModule {
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
index dbac8543f2..d8ee4e85aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
@@ -35,6 +35,25 @@
 // 11 Object
 public class NoPrimaryKeyNullTypes extends RealmObject {
 
+    public static String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
+    public static String FIELD_STRING_NULL = "fieldStringNull";
+    public static String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
+    public static String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
+    public static String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
+    public static String FIELD_BYTE_NULL = "fieldByteNull";
+    public static String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
+    public static String FIELD_SHORT_NULL = "fieldShortNull";
+    public static String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
+    public static String FIELD_INTEGER_NULL = "fieldIntegerNull";
+    public static String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
+    public static String FIELD_LONG_NULL = "fieldLongNull";
+    public static String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
+    public static String FIELD_FLOAT_NULL = "fieldFloatNull";
+    public static String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
+    public static String FIELD_DOUBLE_NULL = "fieldDoubleNull";
+    public static String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
+    public static String FIELD_DATE_NULL = "fieldDateNull";
+
     @Required
     private String fieldStringNotNull = "";
     private String fieldStringNull;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java
new file mode 100644
index 0000000000..e540166b4a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class NoPrimaryKeyWithPrimaryKeyObjectRelation extends RealmObject {
+    private String columnString;
+
+    private AllTypesPrimaryKey columnRealmObjectPK;
+
+    private int columnInt = 8;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public AllTypesPrimaryKey getColumnRealmObjectPK() {
+        return columnRealmObjectPK;
+    }
+
+    public void setColumnRealmObjectPK(AllTypesPrimaryKey columnRealmObjectPK) {
+        this.columnRealmObjectPK = columnRealmObjectPK;
+    }
+
+    public int getColumnInt() {
+        return columnInt;
+    }
+
+    public void setColumnInt(int columnInt) {
+        this.columnInt = columnInt;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
index 5328afe314..ce08779c58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NonLatinFieldNames.java
@@ -19,7 +19,7 @@
 import io.realm.RealmList;
 import io.realm.RealmObject;
 
-public class NonLatinFieldNames extends RealmObject{
+public class NonLatinFieldNames extends RealmObject {
 
     public final static String FIELD_LONG_KOREAN_CHAR = "델타";
     public final static String FIELD_LONG_GREEK_CHAR = "Δέλτα";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
index dbd8689566..f244ea1cc3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedByte.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedByte() {}
+    public PrimaryKeyAsBoxedByte(Byte id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Byte getId() {
         return id;
     }
 
+    @Override
     public void setId(Byte id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
index 5465f07de4..34179ca174 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedInteger.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedInteger() {}
+    public PrimaryKeyAsBoxedInteger(Integer id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Integer getId() {
         return id;
     }
 
+    @Override
     public void setId(Integer id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
index 53a0187607..6ad4929040 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedLong() {}
+    public PrimaryKeyAsBoxedLong(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Long getId() {
         return id;
     }
 
+    @Override
     public void setId(Long id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
index 402f4b6b58..14ce7656c2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedShort.java
@@ -30,11 +30,18 @@
 
     private String name;
 
+    public PrimaryKeyAsBoxedShort() {}
+    public PrimaryKeyAsBoxedShort(Short id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
     @Override
     public Short getId() {
         return id;
     }
 
+    @Override
     public void setId(Short id) {
         this.id = id;
     }
@@ -44,6 +51,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index c64e9642de..5e70b431b8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -18,6 +18,7 @@
 
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.objectid.NullPrimaryKey;
 
 public class PrimaryKeyAsString extends RealmObject {
 
@@ -29,7 +30,10 @@
 
     private long id;
 
-    public PrimaryKeyAsString() {
+    public PrimaryKeyAsString() {}
+    public PrimaryKeyAsString(String name, long id) {
+        this.name = name;
+        this.id = id;
     }
 
     public PrimaryKeyAsString(String name) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
index 20979c2518..88e1e7286b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedByte.java
@@ -40,6 +40,7 @@ public Byte getId() {
         return id;
     }
 
+    @Override
     public void setId(Byte id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
index bb8ecfbf83..7f3756e23d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedInteger.java
@@ -40,6 +40,7 @@ public Integer getId() {
         return id;
     }
 
+    @Override
     public void setId(Integer id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
index fe526e125a..52092b7239 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedLong.java
@@ -40,6 +40,7 @@ public Long getId() {
         return id;
     }
 
+    @Override
     public void setId(Long id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
index 3c14549a52..7c31a298b9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsBoxedShort.java
@@ -40,6 +40,7 @@ public Short getId() {
         return id;
     }
 
+    @Override
     public void setId(Short id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
index 4daa2d8fe6..dc4aadd9a4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyRequiredAsString.java
@@ -40,6 +40,7 @@ public String getId() {
         return id;
     }
 
+    @Override
     public void setId(String id) {
         this.id = id;
     }
@@ -49,6 +50,7 @@ public String getName() {
         return name;
     }
 
+    @Override
     public void setName(String name) {
         this.name = name;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
new file mode 100644
index 0000000000..cb10b36f94
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class PrimaryKeyWithNoPrimaryKeyObjectRelation extends RealmObject {
+    @PrimaryKey
+    private String columnString;
+
+    private AllTypes columnRealmObjectNoPK;
+
+    private int columnInt = 8;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public AllTypes getColumnRealmObjectNoPK() {
+        return columnRealmObjectNoPK;
+    }
+
+    public void setColumnRealmObjectNoPK(AllTypes columnRealmObjectNoPK) {
+        this.columnRealmObjectNoPK = columnRealmObjectNoPK;
+    }
+
+    public int getColumnInt() {
+        return columnInt;
+    }
+
+    public void setColumnInt(int columnInt) {
+        this.columnInt = columnInt;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java
new file mode 100644
index 0000000000..eab61441a1
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.conflict;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class List extends RealmObject {
+    public RealmList<Map> mapList;
+    public Map map;
+
+    public java.lang.String str;
+    public String strObj;
+    public RealmList<String> strList;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java
new file mode 100644
index 0000000000..046ec3ea4a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.conflict;
+
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
+
+@RealmClass
+public class Map implements RealmModel {
+
+    public Map Map;
+    public RealmList<Map> mapList;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
new file mode 100644
index 0000000000..7b57935d58
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.conflict;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class String extends RealmObject {
+    public String str;
+    public RealmList<String> strList;
+
+    public Map map;
+    public RealmList<Map> mapList;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java
new file mode 100644
index 0000000000..ea43938900
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * The classes in this package have conflicting name with classes used in Realm proxy classes.
+ *
+ * Those model classes test https://github.com/realm/realm-java/issues/3077
+ */
+package io.realm.entities.conflict;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java
new file mode 100644
index 0000000000..ddcf95c8aa
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a class name in a migration.
+public class MigrationClassRenamed extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationClassRenamed";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+
+    // PK is placed in the middle to check if prior/posterior fields' removal is properly reflected
+    // during migration step.
+    @PrimaryKey
+    private String fieldPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java
new file mode 100644
index 0000000000..7f03c819a4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you rename a primary field in a migration.
+public class MigrationFieldRenamed extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldRenamed";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    public static String FIELD_PRIMARY = "fieldRenamedPrimary";
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+
+    // PK is placed in the middle to check if prior/posterior fields' removal is properly reflected
+    // during migration step. The MigrationPrimaryKey interface' PK field name is `fieldPrimary`.
+    @PrimaryKey
+    private String fieldRenamedPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldRenamedPrimary(String fieldRenamedPrimary) {
+        this.fieldRenamedPrimary = fieldRenamedPrimary;
+    }
+
+    public String getFieldRenamedPrimary() {
+        return this.fieldRenamedPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java
new file mode 100644
index 0000000000..8f2ae79491
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a String type primary key field to int type in a migration.
+public class MigrationFieldTypeToInt extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldTypeToInt";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 4;
+
+    public static String FIELD_PRIMARY = "fieldIntPrimary";
+
+    public Byte fieldFirst;
+    public Short fieldSecond;
+    @PrimaryKey
+    public int fieldIntPrimary;
+    public Integer fieldFourth;
+    public Long fieldFifth;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java
new file mode 100644
index 0000000000..777d163fbd
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a String type primary key field to nullable Integer type in a migration.
+public class MigrationFieldTypeToInteger extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldTypeToInteger";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 4;
+
+    public static String FIELD_PRIMARY = "fieldIntegerPrimary";
+
+    public Byte fieldFirst;
+    public Short fieldSecond;
+    @PrimaryKey
+    public Integer fieldIntegerPrimary;
+    public Integer fieldFourth;
+    public Long fieldFifth;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java
new file mode 100644
index 0000000000..5406532b72
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used for testing what happens if you modify fields defined after the primary key field
+public class MigrationPosteriorIndexOnly extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationPosteriorIndexOnly";
+
+    public static long DEFAULT_FIELDS_COUNT = 3;
+    public static long DEFAULT_PRIMARY_INDEX = 0;
+
+    @PrimaryKey
+    private String fieldPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java
new file mode 100644
index 0000000000..e8d0d8ca7c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used for testing what happens if you modify fields defined before the primary key field
+public class MigrationPriorIndexOnly extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationPriorIndexOnly";
+
+    public static long DEFAULT_FIELDS_COUNT = 3;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+    @PrimaryKey
+    private String fieldPrimary;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
index 71be5a1a07..6b481e59ce 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/RealmObjectWithRealmModelField.java
@@ -18,7 +18,7 @@
 
 import io.realm.RealmObject;
 
-public class RealmObjectWithRealmModelField extends RealmObject{
+public class RealmObjectWithRealmModelField extends RealmObject {
     private AllTypesRealmModel allTypesRealmModel;
 
     public AllTypesRealmModel getAllTypesRealmModel() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
index bad11e5007..a438e62d78 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/ActivityLifecycle.java
@@ -22,7 +22,7 @@
 import io.realm.RealmResults;
 import io.realm.entities.AllTypes;
 
-public class ActivityLifecycle implements Lifecycle, RealmChangeListener {
+public class ActivityLifecycle implements Lifecycle, RealmChangeListener<RealmResults<AllTypes>> {
     private final RealmConfiguration realmConfiguration;
     private Realm realm;
     private RealmResults<AllTypes> mAllTypes;
@@ -45,7 +45,6 @@ public void onStop() {
     }
 
     @Override
-    public void onChange() {
-
+    public void onChange(RealmResults<AllTypes> object) {
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
deleted file mode 100644
index e6ac3b88a6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class JNIBinaryTypeTest extends TestCase {
-
-    protected Table table;
-    protected byte [] testArray = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
-
-    @Override
-    public void setUp() {
-        RealmCore.loadLibrary();
-        //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
-
-        table = new Table();
-        table.addColumn(RealmFieldType.BINARY, "bin");
-    }
-
-    @Override
-    public void tearDown() {
-        //table.close();
-        table = null;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
index a798ecb28c..d9e8991f9e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
@@ -128,7 +128,6 @@ public void testAccessingViewMethodsAfterTableClose() {
         TableView view = query.findAll();
         //Closes the table, it should be allowed to access the view thereafter (table is ref-counted)
         table.close();
-        table = null;
 
         // Accessing methods should be ok.
         view.size();
@@ -138,8 +137,6 @@ public void testAccessingViewMethodsAfterTableClose() {
         view.getDouble(3, 0);
         view.getFloat(4, 0);
         view.getLong(5, 0);
-        view.getMixed(6, 0);
-        view.getString(7, 0);
 
         // TODO - add all methods from view
     }
@@ -173,7 +170,6 @@ public void testAccessingViewMethodsAfterTableClose() {
         try { view.getDouble(3, 0);              fail(); } catch (IllegalStateException e){}
         try { view.getFloat(4, 0);               fail(); } catch (IllegalStateException e){}
         try { view.getLong(5, 0);                fail(); } catch (IllegalStateException e){}
-        try { view.getMixed(6, 0);               fail(); } catch (IllegalStateException e){}
         try { view.getString(7, 0);              fail(); } catch (IllegalStateException e){}
         // TODO: Add more methods
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
deleted file mode 100644
index 3ca74bc1e4..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-// Tables get detached
-
-public class JNIGarbageCollectorQueryTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        List<TableQuery> views = new ArrayList<TableQuery>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            Table sub = t.getSubtable(0, i);
-            views.add(sub.where());
-            sub.close();
-        }
-    }
-
-    public void t2(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableQuery query = sub.where();
-            sub.close();
-            query.count();
-        }
-    }
-
-    public void t3(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableQuery query = sub.where();
-            sub.close();
-            query.count();
-            query.close();
-        }
-    }
-
-    public void testGetSubtable(){
-
-        t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        long count = 100;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
deleted file mode 100644
index 4f44a3c174..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-
-// Tables get detached
-
-public class JNIGarbageCollectorSubtableSchemaTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        List<TableSchema> tables = new ArrayList<TableSchema>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            tables.add(t.getSubtableSchema(0));
-        }
-        
-        t.close();
-    }
-
-    public void t2(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            TableSchema schema = t.getSubtableSchema(0);
-            schema.toString();
-        }
-        
-        t.close();
-    }
-
-    public void t3(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            TableSchema schema = t.getSubtableSchema(0);
-            schema.toString();
-            //schema.close();
-        }
-        
-        t.close();
-    }
-
-    public void testGetSubtable(){
-
-        long count = 10; // 1000;
-        long loop = 10; //  1000;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
deleted file mode 100644
index 309b0611fd..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-
-// Tables get detached
-
-public class JNIGarbageCollectorTableTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        List<Table> tables = new ArrayList<Table>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            tables.add(t.getSubtable(0, i));
-        }
-        
-        t.close();
-    }
-
-    public void t2(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            Table sub = t.getSubtable(0, i);
-            sub.size();
-        }
-        
-        t.close();
-    }
-
-    public void t3(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            Table sub = t.getSubtable(0, i);
-            sub.size();
-            sub.close();
-        }
-        
-        t.close();
-    }
-
-    public void testGetSubtable(){
-
-        long count = 10; //1000;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
deleted file mode 100644
index a6d9024d57..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-// Tables get detached
-
-public class JNIGarbageCollectorTableViewTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        List<TableView> views = new ArrayList<TableView>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            Table sub = t.getSubtable(0, i);
-            views.add(sub.where().findAll());
-            sub.close();
-        }
-    }
-
-    public void t2(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableView view = sub.where().findAll();
-            sub.close();
-            view.size();
-        }
-    }
-
-    public void t3(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableView view = sub.where().findAll();
-            sub.close();
-            view.size();
-            view.close();
-        }
-    }
-
-    public void testGetSubtableView(){
-        
-        t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        long count = 10; // 1000;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
deleted file mode 100644
index fcce79d622..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-
-public class JNIMixedSubtableTest extends TestCase {
-
-    public void testGetSubtableFromMixedColumnTest() {
-        Util.setDebugLevel(2);
-        Table table = new Table();
-
-        table.addColumn(RealmFieldType.INTEGER, "num");
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-
-        // No rows added yet
-        try { Table subtable = table.getSubtable(1, 0); fail("No rows added, index out of bounds"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        // addEmptyRow() will put Mixed(0) as default value into the mixed column.
-        table.addEmptyRow();
-        // Getting a subtable on a mixed with a 0 int value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an int, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a binary
-        table.setMixed(1, 0, new Mixed(new byte[] {1,2,3}));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an binary, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a bool
-        table.setMixed(1, 0, new Mixed(true));
-        // Getting a subtable on a mixed with a String value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a bool, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a date
-        table.setMixed(1, 0, new Mixed(new Date()));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a date, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a double
-        table.setMixed(1, 0, new Mixed(3.0d));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a double, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a float
-        table.setMixed(1, 0, new Mixed(3.0f));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a float, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a int
-        table.setMixed(1, 0, new Mixed(300));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an int, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a String
-        table.setMixed(1, 0, new Mixed("s"));
-        // Getting a subtable on a mixed with a String value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a String, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        /* FIXME: Subtable in Mixed is currently not supported
-        // Now we specifically set the Mixed value to a subtable
-        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-        // Getting a subtable on the mixed column is now allowed
-        Table subtable = table.getSubtable(1, 0);
-        */
-    }
-
-    // Test uses TableSpec..
-    public void testShouldCreateSubtableInMixedTypeColumn() {
-        Table table = new Table();
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
-        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-        TableSpec subspec = tableSpec.addSubtableColumn("subtable");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-        table.updateFromSpec(tableSpec);
-
-        // Shouldn't work: no Mixed stored yet
-        //Mixed m1 = table.getMixed(1, 0);
-        //ColumnType mt = table.getMixedType(1,0);
-
-        // You can't "getSubtable()" unless there is one. And the addEmptyRow will put in a Mixed(0) as default.
-        // You now get an exception instead of crash if you try anyway
-        {
-            table.addEmptyRow();
-
-            try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains 0, not a subtable");  } catch (IllegalArgumentException e) {}
-            table.removeLast();
-        }
-
-        /* FIXME: Subtable in Mixed is currently not supported
-        long ROW = 0;
-        // Add empty row - the simple way
-        table.addEmptyRow();
-        table.setMixed(1, ROW, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-        assertEquals(1, table.size());
-        assertEquals(0, table.getSubtableSize(1, 0));
-
-        // Create schema for the one Mixed cell with a subtable
-        Table subtable = table.getSubtable(1, ROW);
-        TableSpec subspecMixed = subtable.getTableSpec();
-        subspecMixed.addColumn(RealmFieldType.INTEGER, "num");
-        subtable.updateFromSpec(subspecMixed);
-
-        // Insert value in the Mixed subtable
-        subtable.add(27);
-        subtable.add(273);
-        assertEquals(2, subtable.size());
-        assertEquals(2, table.getSubtableSize(1, ROW));
-        assertEquals(27, subtable.getLong(0, ROW));
-        assertEquals(273, subtable.getLong(0, ROW+1));
-        */
-    }
-
-    /* FIXME: Subtable in Mixed is currently not supported
-    public void testShouldCreateSubtableInMixedTypeColumn2() {
-        Table table = new Table();
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
-        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-        table.updateFromSpec(tableSpec);
-
-        table.addEmptyRow();
-        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-
-        Table subtable = table.getSubtable(1, 0);
-    }
-    */
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
deleted file mode 100644
index 5c630f7ff6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-import io.realm.internal.test.MixedData;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public class JNIMixedTypeTest {
-
-    List<MixedData> mixedDataList = new ArrayList<MixedData>();
-
-    @Parameterized.Parameters
-    public static List<Object[]> parameters() {
-        //Adding MixedData to the list
-        List<MixedData> mixedDataList = new ArrayList<MixedData>();
-        mixedDataList.add(0, new MixedData(RealmFieldType.INTEGER, 123L));
-        mixedDataList.add(1, new MixedData(RealmFieldType.FLOAT, 987.123f));
-        mixedDataList.add(2, new MixedData(RealmFieldType.DOUBLE, 1234567.898d));
-        mixedDataList.add(3, new MixedData(RealmFieldType.BOOLEAN, true));
-        mixedDataList.add(4, new MixedData(RealmFieldType.STRING, "abc"));
-        mixedDataList.add(5, new MixedData(RealmFieldType.BINARY, new byte[]{1, 2, 3, 4, 5}));
-        mixedDataList.add(6, new MixedData(RealmFieldType.DATE, new Date(645342)));
-
-        return Arrays.asList(
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList}
-        );
-    }
-
-    public JNIMixedTypeTest(List<MixedData> mixedDataList) {
-        this.mixedDataList = mixedDataList;
-    }
-
-    @Test
-    public void testShouldMatchMixedValues() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            for (int j = 0; j < mixedDataList.size(); j++) {
-                if (mixedDataList.get(i).value == mixedDataList.get(j).value) {
-                    assertEquals(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                } else {
-                    assertNotSame(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testShouldFailOnWrongTypeRetrieval() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            Object value = mixedDataList.get(i).type != RealmFieldType.STRING ? "abc" : 123;
-            Mixed mixed = Mixed.mixedValue(value);
-
-            switch (mixedDataList.get(i).type) {
-                case BINARY:
-                    try {
-                        mixed.getBinaryByteArray();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case DATE:
-                    try {
-                        mixed.getDateValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case BOOLEAN:
-                    try {
-                        mixed.getBooleanValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case INTEGER:
-                    try {
-                        mixed.getLongValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case FLOAT:
-                    try {
-                        mixed.getFloatValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case DOUBLE:
-                    try {
-                        mixed.getDoubleValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case STRING:
-                    try {
-                        mixed.getStringValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                default:
-                    fail("wrong type");
-                    break;
-            }
-        }
-    }
-}
-
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 4942a9497e..ffdaa0f244 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -439,7 +439,7 @@ public void testQueryTestForNoMatches() {
         Table t = new Table();
         t = TestHelper.getTableWithAllColumnTypes();
 
-        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
 
         TableQuery q = t.where().greaterThan(new long[]{5}, 1000); // No matches
 
@@ -457,18 +457,16 @@ public void testQueryWithWrongDataType() {
         TableQuery query = table.where();
 
         // Compare strings in non string columns
-        for (int i = 0; i <= 8; i++) {
-            if (i != 7) {
-                try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.beginsWith(new long[]{i}, "string");            assert(false); } catch(IllegalArgumentException e) {}
-                try { query.endsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.contains(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            }
+        for (int i = 0; i <= 6; i++) {
+            try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
+            try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.beginsWith(new long[]{i}, "string");            assert(false); } catch(IllegalArgumentException e) {}
+            try { query.endsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.contains(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
         }
 
         // Compare integer in non integer columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 5) {
                 try { query.equalTo(new long[]{i}, 123);                      assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123);                   assert(false); } catch(IllegalArgumentException e) {}
@@ -481,7 +479,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare float in non float columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 4) {
                 try { query.equalTo(new long[]{i}, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123F);                  assert(false); } catch(IllegalArgumentException e) {}
@@ -494,7 +492,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare double in non double columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 3) {
                 try { query.equalTo(new long[]{i}, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123D);                  assert(false); } catch(IllegalArgumentException e) {}
@@ -507,7 +505,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare boolean in non boolean columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 1) {
               try { query.equalTo(new long[]{i}, true);                       assert(false); } catch(IllegalArgumentException e) {}
             }
@@ -547,12 +545,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.minimumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.minimumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.minimumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.maximumInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
@@ -566,12 +558,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.maximumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.sumInt(0);                     assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumFloat(0);                assert(false); } catch(IllegalArgumentException e) {}
@@ -585,12 +571,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.sumInt(6);                     assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumFloat(6);                assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumDouble(6);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(7);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(7);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(7);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(8);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(8);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(8);               assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.averageInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
@@ -604,52 +584,46 @@ public void testColumnIndexOutOfBounds() {
         try { query.averageInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
         // Out of bounds for string
-        try { query.equalTo(new long[]{9}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.beginsWith(new long[]{9}, "string");            assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.endsWith(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.beginsWith(new long[]{7}, "string");            assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.endsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for integer
-        try { query.equalTo(new long[]{9}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for float
-        try { query.equalTo(new long[]{9}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for double
-        try { query.equalTo(new long[]{9}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for boolean
-        try { query.equalTo(new long[]{9}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -702,48 +676,6 @@ public void testQueryOnViewWithAlreadyQueriedTable() {
         assertEquals(1, view2.size());
     }
 
-
-
-    public void testQueryWithSubtable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "username");
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "tasks");
-        table.addColumn(RealmFieldType.STRING, "username2");
-
-        TableSchema tasks = table.getSubtableSchema(1);
-        tasks.addColumn(RealmFieldType.STRING, "name");
-        tasks.addColumn(RealmFieldType.INTEGER, "score");
-        tasks.addColumn(RealmFieldType.BOOLEAN, "completed");
-
-        // Insert some values
-        table.add("Arnold", new Object[][] {{"task1", 120, false},
-                                            {"task2", 321, false},
-                                            {"task3", 78, false}}, "");
-        table.add("Jane", new Object[][] {{"task2", 400, true},
-                                          {"task3", 375, true}}, "");
-        table.add("Erik", new Object[][] {{"task1", 562, true},
-                                          {"task3", 14, false}}, "");
-
-        // Query the table
-        TableView view = table.where().subtable(1).equalTo(new long[]{2}, true).endSubtable().findAll();
-        assertEquals(2, view.size());
-    }
-
-
-    public void testQueryWithUnbalancedSubtable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-
-        TableSchema tasks = table.getSubtableSchema(0);
-        tasks.addColumn(RealmFieldType.STRING, "name");
-
-        try { table.where().subtable(0).count();               assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().endSubtable().count();             assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().endSubtable().subtable(0).count(); assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().subtable(0).endSubtable().count(); assert(false); } catch (UnsupportedOperationException e) {}
-    }
-
-
     public void testMaximumDate() {
 
         Table table = new Table();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 96f6c359d6..8b9c613d0b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -74,26 +74,6 @@ public void testRow() {
         MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
     }
 
-    public void testMixed() {
-        Table table = new Table();
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
-
-        table.addEmptyRows(2);
-
-        UncheckedRow row = table.getUncheckedRow(0);
-        row.setMixed(0, new Mixed(1.5));
-
-        assertEquals(1.5, row.getMixed(0).getDoubleValue());
-
-        UncheckedRow row2 = table.getUncheckedRow(1);
-        row2.setMixed(0, new Mixed("test"));
-
-        assertEquals("test", row2.getMixed(0).getStringValue());
-
-
-    }
-
     public void testNull() {
 
         Table table = new Table();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
deleted file mode 100644
index 50a3650938..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class JNISubtableTest extends TestCase {
-
-    public void testShouldSynchronizeNestedTables() throws Throwable {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.STRING, "name");
-
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-
-        table.updateFromSpec(tableSpec);
-
-        table.add("Foo", null);
-        assertEquals(1, table.size());
-
-        Table subtable1 = table.getSubtable(1, 0);
-        subtable1.add(123);
-        assertEquals(1, subtable1.size());
-        subtable1.close();
-
-        Table subtable2 = table.getSubtable(1, 0);
-        assertEquals(1, subtable2.size());
-        assertEquals(123, subtable2.getLong(0, 0));
-
-        table.clear();
-    }
-
-    public void testShouldInsertNestedTablesNested() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        // Define table
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.STRING, "name");
-
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-
-        tableSpec.addColumn(RealmFieldType.INTEGER, "Int");
-        table.updateFromSpec(tableSpec);
-
-        // Insert values
-        table.add("Foo", null, 123456);
-        table.getSubtable(1, 0).add(123);
-        assertEquals(1, table.getSubtable(1, 0).size());
-        assertEquals(123, table.getSubtable(1, 0).getLong(0,0));
-
-        assertEquals(1, table.size());
-    }
-
-    public void testShouldReturnSubtableIfNullIsInsertedAsSubtable() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.STRING, "string");
-        long subtableColIndex = table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        table.add("val", null);
-        assertEquals(0,  table.getSubtable(subtableColIndex, 0).getColumnCount());
-    }
-
-    public void testGetSubtableOutOfRange() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        // No rows added
-        try { 
-            table.getSubtable(0, 0); 
-            fail("rowIndex > available rows."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-
-        try { 
-            table.getSubtable(1, 0); 
-            fail("columnIndex > available columns."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-
-        table.addEmptyRow();
-
-        try { 
-            table.getSubtable(1, 0); 
-            fail("columnIndex > available columns."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testSubtableSort() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        TableSchema subSchema = table.getSubtableSchema(0);
-        long subtableIntColIndex = subSchema.addColumn(RealmFieldType.INTEGER, "int col");
-        long subtableStringColIndex = subSchema.addColumn(RealmFieldType.STRING, "string col");
-
-        table.addEmptyRow();
-
-        Table subtable = table.getSubtable(0, 0);
-        subtable.add(10, "s");
-        subtable.add(100, "ss");
-        subtable.add(1000, "sss");
-
-        TableView subView = subtable.where().findAll();
-        subView.sort(subtableIntColIndex);
-
-        assertEquals(10, subView.getLong(0, 0));
-        assertEquals(100, subView.getLong(0, 1));
-        assertEquals(1000, subView.getLong(0, 2));
-    }
-
-    public void testAddColumnsToSubtables() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        // Add a subtable
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals(persons.getColumnName(2), "addresses");
-        assertEquals(persons.getSubtable(2,0).getColumnName(2), "phone_numbers");
-        assertEquals(persons.getSubtable(2,0).getSubtable(2,0).getColumnName(0), "number");
-
-        assertEquals(persons.getString(1,0), "xx@xxxx.com");
-        assertEquals(persons.getSubtable(2,0).getString(0,0), "X Street");
-        assertEquals(persons.getSubtable(2,0).getSubtable(2,0).getLong(0,0), 12345678);
-    }
-
-
-    public void testSubtableAddColumnsCheckNames() {
-
-        // Table definition
-        Table persons = new Table();
-
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-
-        TableSchema addresses = persons.getSubtableSchema(0);
-        try {
-            addresses.addColumn(RealmFieldType.STRING, "I am 64 characters..............................................");
-            fail("Only 63 characters supported"); }
-        catch (IllegalArgumentException e) {
-            assertNotNull(e);
-        }
-
-        addresses.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
-    }
-
-    public void testRemoveColumnFromSubtable() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals(persons.getSubtable(2,0).getColumnCount(), 3);
-        addresses.removeColumn(1);
-        assertEquals(persons.getSubtable(2,0).getColumnCount(), 2);
-    }
-
-    public void testRenameColumnInSubtable() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        // Define subtable
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals("zipcode", persons.getSubtable(2,0).getColumnName(1));
-        addresses.renameColumn(1, "zip");
-        assertEquals("zip", persons.getSubtable(2,0).getColumnName(1));
-    }
-
-    public void testShouldThrowOnGetSubtableDefinitionFromSubtable() {
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        try {
-            // Should throw
-            persons.getSubtable(2,0).addColumn(RealmFieldType.INTEGER, "i");
-            fail("expected exception.");
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-
-        try {
-            // Should throw
-            persons.getSubtable(2,0).getSubtableSchema(2);
-            fail("expected exception.");
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-
-    }
-
-    // TODO: try on mixed columns - it should work there
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
index 675a46ac1f..36507e6f58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
@@ -61,28 +61,6 @@ public JNITableInsertTest(List<Object> value) {
         this.value = value;
     }
 
-    public void verifyRow(Table tbl, long rowIndex, Object[] values) {
-        assertTrue((Boolean) (values[0]) == tbl.getBoolean(0, rowIndex));
-        assertEquals(((Number) values[1]).longValue(), tbl.getLong(1, rowIndex));
-        assertEquals((String) values[2], tbl.getString(2, rowIndex));
-        if (values[3] instanceof byte[])
-            MoreAsserts.assertEquals((byte[]) values[3], tbl.getBinaryByteArray(3, rowIndex));
-        assertEquals(((Date) values[4]).getTime() / 1000, tbl.getDate(4, rowIndex).getTime() / 1000);
-
-        //      Mixed mix1 = Mixed.mixedValue(values[5]);
-        //      Mixed mix2 =  tbl.getMixed(5, rowIndex);
-        // TODO:        assertTrue(mix1.equals(mix2));
-
-        Table subtable = tbl.getSubtable(6, rowIndex);
-        Object[] subValues = (Object[]) values[6];
-        for (long i = 0; i < subtable.size(); i++) {
-            Object[] val = (Object[]) subValues[(int) i];
-            assertTrue(((Number) val[0]).longValue() == subtable.getLong(0, i));
-            assertEquals(((String) val[1]), subtable.getString(1, i));
-        }
-        assertTrue(tbl.isValid());
-    }
-
     @Test
     public void testShouldThrowExceptionWhenColumnNameIsTooLong() {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
deleted file mode 100644
index 8eeb871773..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-import io.realm.internal.test.ColumnTypeData;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public class JNITableSpecTest {
-
-    TableSpec spec, spec2 = new TableSpec();
-    Table table = new Table();
-    ColumnTypeData columnTypeData = new ColumnTypeData(null);
-
-    @Parameterized.Parameters
-    public static Collection<Object[]> parameters() {
-        return Arrays.asList(
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.INTEGER)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.FLOAT)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.DOUBLE)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BOOLEAN)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.STRING)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BINARY)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_MIXED)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_TABLE)}
-        );
-    }
-
-    public JNITableSpecTest(TableSpec spec, TableSpec spec2,
-                            Table table, ColumnTypeData columnTypeData) {
-        this.spec = spec;
-        this.spec2 = spec2;
-        this.table = table;
-        this.columnTypeData = columnTypeData;
-    }
-
-    @Test
-    public void testShouldDefineOneColumnTable() {
-        spec.addColumn(columnTypeData.type, "foo");
-        assertEquals(0, spec.getColumnIndex("foo"));
-        assertEquals(-1, spec.getColumnIndex("xx"));
-
-        spec2.addColumn(columnTypeData.type, "foo");
-        checkSpecIdentity(spec, spec2);
-
-        Table table = new Table();
-        table.updateFromSpec(spec);
-    }
-
-    public void checkSpecIdentity(TableSpec spec, TableSpec spec2) {
-        assertEquals(spec, spec2);
-        assertEquals(spec.hashCode(), spec2.hashCode());
-    }
-
-    @Test
-    public void testShouldDefineTwoColumnsTable() {
-        TableSpec subSpec = spec.addSubtableColumn("bar");
-        subSpec.addColumn(columnTypeData.type, "subbar");
-        assertEquals(0, spec.getColumnIndex("foo"));
-        assertEquals(1, spec.getColumnIndex("bar"));
-        assertEquals(0, subSpec.getColumnIndex("subbar"));
-        assertEquals(-1, subSpec.getColumnIndex("xx"));
-
-        TableSpec subSpec2 = spec2.addSubtableColumn("bar");
-        subSpec2.addColumn(columnTypeData.type, "subbar");
-
-        checkSpecIdentity(spec, spec2);
-        Table table = new Table();
-        table.updateFromSpec(spec);
-    }
-
-    @Test
-    public void testShouldHandleColumnsDynamically() {
-        table.addColumn(RealmFieldType.INTEGER, "0");
-        assertEquals(1, table.getColumnCount());
-        assertEquals(0, table.getColumnIndex("0"));
-        assertEquals("0", table.getColumnName(0));
-        assertEquals(RealmFieldType.INTEGER, table.getColumnType(0));
-        table.add(23);
-
-        table.addColumn(RealmFieldType.FLOAT, "1");
-        table.add(11, 11.1f);
-        table.addColumn(RealmFieldType.DOUBLE, "2");
-        table.add(22, 22.2f, -22.2);
-        table.addColumn(RealmFieldType.BOOLEAN, "3");
-        table.add(33, 33.3f, -33.3, true);
-        table.addColumn(RealmFieldType.STRING, "4");
-        table.add(44, 44.4f, -44.4, true, "44");
-        table.addColumn(RealmFieldType.DATE, "5");
-        Date date = new Date();
-        table.add(55, 55.5f, -55.5, false, "55", date);
-        table.addColumn(RealmFieldType.BINARY, "6");
-        table.add(66, 66.6f, -66.6, false, "66", date, new byte[]{6});
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "7");
-        table.add(77, 77.7f, -77.7, true, "77", date, new byte[]{7, 7}, "mix");
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "8");
-        table.add(88, 88.8f, -88.8, false, "88", date, new byte[]{8, 8, 8}, "mixed", null);
-
-        table.addEmptyRows(10);
-        assertEquals(9 + 10, table.size());
-        checkColumnsTest(table);
-        renameColumnsTest(table);
-        removeColumnsTest(table);
-    }
-
-    public void checkColumnsTest(Table table) {
-        // Check columns
-        long columns = 9;
-        assertEquals(columns, table.getColumnCount());
-        for (long i = 0; i < columns; i++) {
-            String name = "" + i;
-            assertEquals(name, table.getColumnName(i));
-            assertEquals(i, table.getColumnIndex(name));
-        }
-    }
-
-    public void renameColumnsTest(Table table) {
-        // Test renameColumn():
-        long columns = 9;
-        for (long i = 0; i < columns; i++)
-            table.renameColumn(i, "New " + i);
-        for (long i = 0; i < columns; i++)
-            assertEquals("New " + i, table.getColumnName(i));
-    }
-
-    public void removeColumnsTest(Table table) {
-        // Test removeColumn():
-        long columns = 9;
-        table.removeColumn(1);
-        assertEquals(columns - 1, table.getColumnCount());
-        assertEquals("New 0", table.getColumnName(0));
-        for (long i = 1; i < columns - 1; i++)
-            assertEquals("New " + (i + 1), table.getColumnName(i));
-        // remove first
-        table.removeColumn(0);
-        assertEquals(columns - 2, table.getColumnCount());
-        for (long i = 0; i < columns - 2; i++)
-            assertEquals("New " + (i + 2), table.getColumnName(i));
-        // remove last
-        table.removeColumn(columns - 3);
-        assertEquals(columns - 3, table.getColumnCount());
-        for (long i = 0; i < columns - 3; i++)
-            assertEquals("New " + (i + 2), table.getColumnName(i));
-        // remove all but "New 4"
-        table.removeColumn(0);
-        table.removeColumn(0);
-        assertEquals(columns - 5, table.getColumnCount());
-        for (long i = 0; i < columns - 6; i++)
-            table.removeColumn(1);
-        assertEquals(1, table.getColumnCount());
-        assertEquals("New 4", table.getColumnName(0));
-        assertEquals("44", table.getString(0, 4));
-    }
-
-    @Test
-    public void testShouldThrowOnUpdateFromTableSpecOnSubtable() {
-        // Table definition
-        Table persons = new Table();
-
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        persons.add(new Object[]{"Mr X", "xx@xxxx.com", new Object[][]{{"X Street", 1234, null}}});
-
-        Table address = persons.getSubtable(2, 0);
-
-        spec.addColumn(RealmFieldType.INTEGER, "foo");
-
-        try {
-            address.updateFromSpec(spec);
-            fail("Address is subtable. Not allowed to update from spec");
-        } catch (UnsupportedOperationException e) {
-        }
-    }
-}
-
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index 5bc96014e0..09973c790b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -49,11 +49,7 @@ public void testTableToString() {
         t.add("s1", 1, true);
         t.add("s2", 2, false);
 
-        String expected =
-"    stringCol  intCol  boolCol\n" +
-"0:  s1              1     true\n" +
-"1:  s2              2    false\n" ;
-
+        String expected = "The Table contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
         assertEquals(expected, t.toString());
     }
 
@@ -89,37 +85,33 @@ public void testZeroColOperations() {
 
     public void testFindFirstNonExisting() {
         Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
 
         assertEquals(-1, t.findFirstBoolean(1, false));
-        assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
+        // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
         assertEquals(-1, t.findFirstDouble(3, 1.0d));
         assertEquals(-1, t.findFirstFloat(4, 1.0f));
         assertEquals(-1, t.findFirstLong(5, 50));
-        assertEquals(-1, t.findFirstString(7, "other string"));
     }
 
     public void testFindFirst() {
         final int TEST_SIZE = 10;
         Table t = TestHelper.getTableWithAllColumnTypes();
         for (int i = 0; i < TEST_SIZE; i++) {
-            t.add(new byte[]{1,2,3}, true, new Date(1000*i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
+            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, "string " + i);
         }
-        t.add(new byte[]{1, 2, 3}, true, new Date(1000 * TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
+        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
 
         assertEquals(0, t.findFirstBoolean(1, true));
         for (int i = 0; i < TEST_SIZE; i++) {
-            assertEquals(i, t.findFirstDate(2, new Date(1000*i)));
+            assertEquals(i, t.findFirstDate(2, new Date(i)));
             assertEquals(i, t.findFirstDouble(3, (double) i));
             assertEquals(i, t.findFirstFloat(4, (float) i));
             assertEquals(i, t.findFirstLong(5, i));
-            assertEquals(i, t.findFirstString(7, "string " + i));
         }
 
-        assertEquals(TEST_SIZE, t.findFirstString(7, ""));
-
         try {
-            t.findFirstString(7, null);
+            t.findFirstString(6, null);
             fail();
         } catch (IllegalArgumentException ignored) {}
 
@@ -158,18 +150,9 @@ public void testGetValuesFromNonExistingColumn() {
         try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getMixed(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getMixed(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getMixed(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
         try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
-        try { t.getSubtable(-1, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSubtable(-10, 0);                fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSubtable(9, 0);                  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
     }
 
     public void testGetNonExistingColumn() {
@@ -242,9 +225,8 @@ public void testSetNulls() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "");
         t.addColumn(RealmFieldType.DATE, "");
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "");
         t.addColumn(RealmFieldType.BINARY, "");
-        t.add("String val", new Date(), new Mixed(""), new byte[]{1, 2, 3});
+        t.add("String val", new Date(), new byte[]{1, 2, 3});
 
         try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
         try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
@@ -257,14 +239,6 @@ public void testAddNegativeEmptyRows() {
         try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
     }
 
-    public void testAddNullInMixedColumn() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
-        t.add(new Mixed(true));
-
-        try { t.setMixed(0, 0, null); fail("Argument is null"); } catch (IllegalArgumentException ignored) { }
-    }
-
     public void testImmutableInsertNotAllowed() {
 
         String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
@@ -604,17 +578,6 @@ else if (columnType == RealmFieldType.INTEGER)
         }
     }
 
-    // migrating an mixed column to be nullable is not supported
-    public void testConvertMixedToNullable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed", Table.NOT_NULLABLE);
-        try {
-            table.convertColumnToNullable(0);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     // add column and read back if it is nullable or not
     public void testIsNullable() {
         Table table = new Table();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
index 0f0631baa2..f5f2908f07 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -265,7 +265,6 @@ public void mustFailOnWriteInReadTransactions() {
         try { table.addEmptyRow();                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.addEmptyRows(1);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.clear();                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.clearSubtable(0,0);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.optimize();                     fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.remove(0);                      fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.removeLast();                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -274,9 +273,7 @@ public void mustFailOnWriteInReadTransactions() {
         try { table.setDate(0,0,new Date(0));       fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.addSearchIndex(0);              fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setLong(0,0,0);                 fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setMixed(0,0,null);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { table.setString(0,0,"");              fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.updateFromSpec(null);           fail();} catch (IllegalStateException e) {assertNotNull(e);}
 
         TableQuery q = table.where();
         try { q.remove();                           fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -284,7 +281,6 @@ public void mustFailOnWriteInReadTransactions() {
 
         TableView v = q.findAll();
         try { v.clear();                            fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.clearSubtable(0, 0);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.remove(0);                          fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.removeLast();                       fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.setBinaryByteArray(0, 0, null);     fail();} catch (IllegalStateException e) {assertNotNull(e);}
@@ -292,7 +288,6 @@ public void mustFailOnWriteInReadTransactions() {
         try { v.setDate(0, 0, new Date());          fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.setLong(0, 0, 0);                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
         try { v.setString(0,0,"");                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setMixed(0, 0, null);               fail();} catch (IllegalStateException e) {assertNotNull(e);}
 
         t.endRead();
     }
@@ -451,4 +446,17 @@ public void primaryKeyTableMigratedWithRightName() throws IOException {
         }
         db.close();
     }
+
+    // Test if toString() returns a correct PrimaryKey field description from a Table
+    public void testTableToStringWithPrimaryKey() {
+        Table t = getTableWithStringPrimaryKey();
+        t.addColumn(RealmFieldType.INTEGER, "intCol");
+        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
+
+        t.add("s1", 1, true);
+        t.add("s2", 2, false);
+
+        String expected = "The Table has 'colName' field as a PrimaryKey, and contains 3 columns: colName, intCol, boolCol. And 2 rows.";
+        assertEquals(expected, t.toString());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index 27d1aa48da..9a3d5669e7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -43,15 +43,11 @@ public void setUp() {
         t.addColumn(RealmFieldType.INTEGER,    "Age");
         t.addColumn(RealmFieldType.DATE,   "Birthday");
 
-        // Add unsupported column types
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED,  "Unsupported3");
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE,  "Unsupported4");
-
         //Add data
-        t.add("cc", true,  24, date1, 0, null);
-        t.add("dd", false, 35, date2, 0, null);
-        t.add("bb", true,  22, date3, 0, null);
-        t.add("aa", false, 22, date4, 0, null);
+        t.add("cc", true,  24, date1);
+        t.add("dd", false, 35, date2);
+        t.add("bb", true,  22, date3);
+        t.add("aa", false, 22, date4);
 
         assertEquals(date1, t.getDate(3, 0));
         assertEquals(date2, t.getDate(3, 1));
@@ -140,39 +136,6 @@ public void testSetBinary() {
         MoreAsserts.assertEquals(arr2, view.getBinaryByteArray(0, 0));
     }
 
-
-    public void testSubtable() {
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com",
-                new Object[][] { { "X Street", 1234, new Object[][] {{ 12345678 }} },
-                                 { "Y Street", 1234, new Object[][] {{ 12345678 }} }
-                               });
-
-        TableView personsView = persons.where().findAll();
-
-        assertEquals(2, personsView.getSubtableSize(2, 0));
-
-        Table address = personsView.getSubtable(2, 0);
-        assertEquals(2, address.size());
-        assertEquals(3, address.getColumnCount());
-
-        personsView.clearSubtable(2, 0);
-        assertEquals(0, personsView.getSubtableSize(2, 0));
-    }
-
     public void testSortOnNonexistingColumn() {
         TableView view = t.where().findAll();
 
@@ -184,57 +147,48 @@ public void testSortOnNonexistingColumn() {
 
     public void testFindFirstNonExisting() {
         Table tt = TestHelper.getTableWithAllColumnTypes();
-        tt.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        tt.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
         TableView v = tt.where().findAll();
 
         assertEquals(-1, v.findFirstBoolean(1, false));
-        assertEquals(-1, v.findFirstDate(2, new Date(138442314986l)));
+        //FIXME: enable when find_first_timestamp() is implemented: assertEquals(-1, v.findFirstDate(2, new Date(138442314986l)));
         assertEquals(-1, v.findFirstDouble(3, 1.0d));
         assertEquals(-1, v.findFirstFloat(4, 1.0f));
         assertEquals(-1, v.findFirstLong(5, 50));
-        assertEquals(-1, v.findFirstString(7, "other string"));
     }
 
 
     public void testGetValuesFromNonExistingColumn() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableView view = table.where().findAll();
-        
+
         try { view.getBinaryByteArray(-1, 0);   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBinaryByteArray(-10, 0);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBinaryByteArray(100, 0);  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getBoolean(-1, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBoolean(-10, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getBoolean(100, 0);          fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getDate(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDate(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDate(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getDouble(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDouble(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getDouble(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getFloat(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getFloat(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getFloat(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getLong(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getLong(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getLong(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
-        try { view.getMixed(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getMixed(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getMixed(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
+
         try { view.getString(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-        
-        try { view.getSubtable(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getSubtable(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getSubtable(100, 0);         fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
     }
 
 
@@ -300,20 +254,6 @@ public void testShouldSortViewBool() {
         assertEquals("bb", view.getString(0, 3));
     }
 
-
-
-    public void testShouldThrowExceptionForUnsupportedColumns() {
-        TableView view = t.where().findAll();
-        long colIndex;
-        for (colIndex = 4; colIndex <= 5; colIndex++) {
-            try {
-                view.sort(colIndex); // Must throw for invalid column types
-                fail("expected exception.");
-            } catch (IllegalArgumentException e) {
-            }
-        }
-    }
-
     public void testShouldSearchByColumnValue() {
         Table table = new Table();
         table.addColumn(RealmFieldType.STRING, "name");
@@ -375,10 +315,7 @@ public void testViewToString() {
 
         TableView view = t.where().findAll();
 
-        String expected =
-                "    stringCol  intCol  boolCol\n" +
-                        "0:  s1              1     true\n" +
-                        "1:  s2              2    false\n" ;
+        String expected = "The TableView contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
 
         assertEquals(expected, view.toString());
     }
@@ -446,7 +383,7 @@ public void testViewShouldInvalidate() {
         view = t.where().equalTo(new long[]{0}, 2).findAll();
         accessingViewOk(view);
 
-        // Removing any row in Table should invalidate view 
+        // Removing any row in Table should invalidate view
         t.remove(3);
         accessingViewMustThrow(view);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index d8587d2bc3..751158bc98 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -142,24 +142,6 @@ public void testShouldThrowDistinctErrorWhenWrongColumnType() {
         }
     }
 
-    /**
-     * Is used to run a test multiple times,
-     * that corresponds to the number of columns in the Table generated
-     * in TestHelper.getTableWithAllColumnTypes
-     * @return
-     */
-
-// TODO: parametric test
-/*    @DataProvider(name = "columnIndex")
-    public Iterator<Object[]> mixedValuesProvider() {
-        Long[] values = {
-               0L,1L,2L,3L,4L,5L,6L,7L,8L
-        };
-
-        List<?> mixedValues = Arrays.asList(values);
-        return DataProviderUtil.allCombinations(mixedValues);
-    }*/
-
     public void testRemoveSearchIndex() {
         init();
         table.addSearchIndex(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
deleted file mode 100644
index 89539fc9fc..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class TableSpecEqualityTest extends TestCase {
-
-    public void testShouldMatchIdenticalSimpleSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnNames() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BOOLEAN, "bar2");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnTypes() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BINARY, "bar");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldMatchDeepRecursiveIdenticalSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldNotMatchDeepRecursiveDifferentSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub2");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
deleted file mode 100644
index db78aa4ff6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-
-public class DataProviderUtil {
-
-    public static Iterator<Object[]> allCombinations(List<?>... lists) {
-        Iterator<Object[]> iterator = new VariationsIterator<Object>(Arrays.asList(lists));
-        return iterator;
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
deleted file mode 100644
index e8436e35a6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.nio.ByteBuffer;
-import java.util.Date;
-
-import io.realm.internal.Mixed;
-
-public class EmployeeData {
-
-    public String firstName;
-    public String lastName;
-    public int salary;
-    public boolean driver;
-    public byte[] photo;
-    public Date birthdate;
-    public Object extra;
-    public PhoneData[] phones;
-
-    public EmployeeData(String firstName, String lastName, int salary, boolean driver, byte[] photo, Date birthdate, Object extra, PhoneData[] phones) {
-        this.firstName = firstName;
-        this.lastName = lastName;
-        this.salary = salary;
-        this.driver = driver;
-        this.photo = photo;
-        this.birthdate = birthdate;
-        this.extra = extra;
-        this.phones = phones;
-    }
-
-    public Object get(int index) {
-        switch (index) {
-        case 0:
-            return firstName;
-        case 1:
-            return lastName;
-        case 2:
-            return new Long(salary);
-        case 3:
-            return new Boolean(driver);
-        case 4:
-            return ByteBuffer.wrap(photo);
-        case 5:
-            return birthdate;
-        case 6:
-            return Mixed.mixedValue(extra);
-        case 7:
-            return phones;
-        default:
-            throw new IllegalArgumentException("Incorrect index: " + index);
-        }
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
deleted file mode 100644
index d1f4c85453..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Date;
-
-public class EmployeesFixture {
-
-    public static final PhoneData[][] PHONES = {
-        { new PhoneData("home", "123") },
-        { new PhoneData("mobile", "456") },
-        { new PhoneData("work", "789"), new PhoneData("mobile", "012") }
-    };
-
-    public static final EmployeeData[] EMPLOYEES = { new EmployeeData("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(111111), "extra", PHONES[0]),
-            new EmployeeData("Nikolche", "Mihajlovski", 30000, false, new byte[] { 4, 5 }, new Date(2222), 1234, PHONES[1]),
-            new EmployeeData("Johny", "B. Good", 10000, true, new byte[] { 1, 2, 3 }, new Date(333343333), true, PHONES[2]) };
-
-    public static Object[] getAll(int index) {
-        Object[] values = new Object[EMPLOYEES.length];
-
-        for (int i = 0; i < values.length; i++) {
-            values[i] = EMPLOYEES[i].get(index);
-        }
-
-        return values;
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
deleted file mode 100644
index 3f748bef60..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import io.realm.RealmFieldType;
-
-public class MixedData {
-
-    public RealmFieldType type;
-
-    public Object value;
-
-    public MixedData(RealmFieldType type, Object value) {
-        this.type = type;
-        this.value = value;
-    }
-
-    @Override
-    public String toString() {
-        return "MixedData [type=" + type + ", value=" + value + "]";
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
deleted file mode 100644
index 51182615b5..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Date;
-
-import io.realm.internal.DefineTable;
-
-/**
- * This model is used to generate classes that are used only for the tests.
- */
-public class TestTableModel {
-
-    @DefineTable
-    class TestEmployee {
-        String firstName;
-        String lastName;
-        int salary;
-        boolean driver;
-        byte[] photo;
-        Date birthdate;
-        Object extra;
-        TestPhone phones;
-    }
-
-    @DefineTable
-    class TestPhone {
-        String type;
-        String number;
-    }
-
-    @DefineTable
-    class TestNumbers {
-        long longNum;
-        float floatNum;
-        double doubleNum;
-    }
-
-    @DefineTable
-    class TestQueryTable {
-        long longNum;
-        float floatNum;
-        double doubleNum;
-        String stringVal;
-    }
-
-    @DefineTable
-    class AllTypes {
-        boolean  boolCol;
-        java.util.Date dateCol;
-        double doubleCol;
-        int intCol;
-        long longCol;
-        float floatCol;
-        String stringCol;
-        byte[] byteCol;
-        Car carTableCol; // Subtable of the type Car defined as a typed table
-        Object mixedCol; // Can hold any of the types
-    }
-
-    @DefineTable
-    class Car {
-        String  brand;
-        String  model;
-        int year;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
deleted file mode 100644
index 03a7d85ab5..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Iterator;
-import java.util.List;
-
-public class VariationsIterator<T> implements Iterator<Object[]> {
-
-    private final List<List<?>> lists;
-
-    private int[] sizes;
-    private int[] indexes;
-
-    private boolean hasNext = true;
-
-    public VariationsIterator(List<List<?>> lists) {
-        this.lists = lists;
-
-        sizes = new int[lists.size()];
-        indexes = new int[lists.size()];
-
-        for (int i = 0; i < lists.size(); i++) {
-            if (lists.get(i).isEmpty()) {
-                throw new RuntimeException("Each list must contain at least 1 item!");
-            }
-
-            sizes[i] = lists.get(i).size();
-            indexes[i] = 0;
-        }
-    }
-
-    public Object[] next() {
-        Object[] result = new Object[lists.size()];
-
-        for (int i = 0; i < lists.size(); i++) {
-            result[i] = lists.get(i).get(indexes[i]);
-        }
-
-        increase();
-        return result;
-    }
-
-    public boolean hasNext() {
-        return hasNext;
-    }
-
-    private void increase() {
-        for (int i = 0; i < indexes.length; i++) {
-            indexes[i] = (indexes[i] + 1) % sizes[i];
-            if (indexes[i] > 0) {
-                hasNext = true;
-                return;
-            }
-        }
-        hasNext = false;
-    }
-
-    public void remove() {
-        throw new UnsupportedOperationException();
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
new file mode 100644
index 0000000000..f53221b9ef
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.migration;
+
+/**
+ * This interface should be used as a stub for dynamically creating the first version of schema.
+ * As this is an interface and does not inherit RealmObject, a schema for {@link MigrationPrimaryKey}
+ * there does not exist.
+ */
+public interface MigrationPrimaryKey {
+    public static String CLASS_NAME    = "MigrationPrimaryKey";
+
+    public static String FIELD_FIRST   = "fieldFirst";
+    public static String FIELD_SECOND  = "fieldSecond";
+
+    // this is original primary key field name.
+    public static String FIELD_PRIMARY = "fieldPrimary";
+    public static String FIELD_FOURTH  = "fieldFourth";
+    public static String FIELD_FIFTH   = "fieldFifth";
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
index 527825cedd..3ed5672410 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/objectid/NullPrimaryKey.java
@@ -20,5 +20,9 @@
 
     public P getId();
 
+    public void setId(P id);
+
     public S getName();
+
+    public void setName(S name);
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 29060837c0..99028c9edd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -24,11 +24,13 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.annotation.Annotation;
 import java.util.LinkedList;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -75,7 +77,8 @@ protected void after() {
 
     @Override
     public Statement apply(final Statement base, Description description) {
-        if (description.getAnnotation(RunTestInLooperThread.class) == null) {
+        final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
+        if (annotation == null) {
             return base;
         }
         return new Statement() {
@@ -84,11 +87,21 @@ public Statement apply(final Statement base, Description description) {
             @Override
             public void evaluate() throws Throwable {
                 before();
+                final String threadName = annotation.threadName();
+                Class<? extends RunnableBefore> runnableBefore = annotation.before();
+                if (!runnableBefore.isInterface()) {
+                    runnableBefore.newInstance().run(realmConfiguration);
+                }
                 try {
                     final CountDownLatch signalClosedRealm = new CountDownLatch(1);
                     final Throwable[] threadAssertionError = new Throwable[1];
                     final Looper[] backgroundLooper = new Looper[1];
-                    final ExecutorService executorService = Executors.newSingleThreadExecutor();
+                    final ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
+                        @Override
+                        public Thread newThread(Runnable runnable) {
+                            return new Thread(runnable, threadName);
+                        }
+                    });
                     executorService.submit(new Runnable() {
                         @Override
                         public void run() {
@@ -111,9 +124,7 @@ public void run() {
                                     }
                                     unitTestFailed = true;
                                 }
-                                if (signalTestCompleted.getCount() > 0) {
-                                    signalTestCompleted.countDown();
-                                }
+                                signalTestCompleted.countDown();
                                 if (realm != null) {
                                     realm.close();
                                 }
@@ -196,4 +207,12 @@ public void postRunnable(Runnable runnable) {
      */
     public void looperTearDown() {
     }
+
+    /**
+     * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
+     * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
+     */
+    public interface RunnableBefore {
+        void run(RealmConfiguration realmConfig);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
index 149412fbcb..c24c085983 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
@@ -25,8 +25,12 @@
  * This annotation should be used along with {@link RunInLooperThread}
  * When the annotation is present, the test method is executed on a worker thread with a looper.
  * This will also uses {@link org.junit.rules.TemporaryFolder} to create and open a Realm.
+ * Annotation param {@link io.realm.rule.RunInLooperThread.RunnableBefore} can be supplied which will run before the
+ * looper thread.
  */
-@Target(METHOD) @Retention(RUNTIME)
+@Target(METHOD)
+@Retention(RUNTIME)
 public @interface RunTestInLooperThread {
-
+        String threadName() default "RunTestInLooperThread";
+        Class<?extends RunInLooperThread.RunnableBefore> before() default RunInLooperThread.RunnableBefore.class;
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index d560e819f2..a29895fffb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.entities.AllTypes;
 
 /**
@@ -120,9 +121,9 @@ private static String currentLine() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
             int expected = 1;
-            int got = thiz.testRealm.allObjects(AllTypes.class).size();
+            long got = thiz.testRealm.where(AllTypes.class).count();
             if (expected == got) {
                 response(null);
             } else {
@@ -136,7 +137,7 @@ void run() {
 
         @Override
         void run() {
-            thiz.testRealm = Realm.getInstance(thiz);
+            thiz.testRealm = Realm.getInstance(new RealmConfiguration.Builder(thiz).build());
             thiz.testRealm.close();
             response(null);
             Runtime.getRuntime().exit(0);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
deleted file mode 100644
index 380bd44f08..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* TODO: re-enable
-
-
-package io.realm.tests.typed.entities;
-
-import java.util.Date;
-
-import io.realm.RealmObject;
-
-public class AllColumns extends RealmObject {
-
-    private String columnString;
-    private long columnLong;
-    private float columnFloat;
-    private double columnDouble;
-    private boolean columnBoolean;
-    private Date columnDate;
-    private byte[] columnBinary;
-    private User columnRealmObject;
-
-    public String getColumnString() {
-        return columnString;
-    }
-
-    public void setColumnString(String columnString) {
-        this.columnString = columnString;
-    }
-
-    public long getColumnLong() {
-        return columnLong;
-    }
-
-    public void setColumnLong(long columnLong) {
-        this.columnLong = columnLong;
-    }
-
-    public float getColumnFloat() {
-        return columnFloat;
-    }
-
-    public void setColumnFloat(float columnFloat) {
-        this.columnFloat = columnFloat;
-    }
-
-    public double getColumnDouble() {
-        return columnDouble;
-    }
-
-    public void setColumnDouble(double columnDouble) {
-        this.columnDouble = columnDouble;
-    }
-
-    public boolean isColumnBoolean() {
-        return columnBoolean;
-    }
-
-    public void setColumnBoolean(boolean columnBoolean) {
-        this.columnBoolean = columnBoolean;
-    }
-
-    public Date getColumnDate() {
-        return columnDate;
-    }
-
-    public void setColumnDate(Date columnDate) {
-        this.columnDate = columnDate;
-    }
-
-    public byte[] getColumnBinary() {
-        return columnBinary;
-    }
-
-    public void setColumnBinary(byte[] columnBinary) {
-        this.columnBinary = columnBinary;
-    }
-
-    public User getColumnRealmObject() {
-        return columnRealmObject;
-    }
-
-    public void setColumnRealmObject(User columnRealmObject) {
-        this.columnRealmObject = columnRealmObject;
-    }
-}
-*/
diff --git a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
deleted file mode 100644
index e08d5270d8..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* TODO: re-enable
-
-
-package io.realm.tests.api.entities;
-
-import io.realm.RealmArrayList;
-import io.realm.RealmList;
-import io.realm.RealmObject;
-
-public class Dog extends RealmObject {
-
-    private RealmList<User> owners = new RealmArrayList<User>();
-    private String name;
-
-    public RealmList<User> getOwners() {
-        return owners;
-    }
-
-    public void setOwners(RealmList<User> owners) {
-        this.owners = owners;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-}
-*/
diff --git a/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java b/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java
new file mode 100644
index 0000000000..e87fc2aa8a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/util/RealmThread.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.util;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+// this is a simple example of how Realm can be encapsulated within a Thread wrapper.
+public final class RealmThread extends Thread {
+
+    public interface RealmRunnable {
+        void run(final Realm realm);
+    }
+
+    private final RealmConfiguration realmConfig;
+    private final RealmRunnable task;
+    private Realm realm;
+
+    public RealmThread(RealmConfiguration realmConfig, RealmRunnable task) {
+        super();
+        this.realmConfig = realmConfig;
+        this.task = task;
+    }
+
+    public RealmThread(RealmConfiguration realmConfig, RealmRunnable task, String threadName) {
+        super(threadName);
+        this.realmConfig = realmConfig;
+        this.task = task;
+    }
+
+    @Override
+    public void run() {
+        realm = Realm.getInstance(this.realmConfig);
+        if (task != null) {
+            task.run(realm);
+        }
+        if (!realm.isClosed()) {
+            realm.close();
+        }
+        realm = null;
+    }
+
+    public void end() {
+        if (!this.isAlive()) {
+            return;
+        }
+        if (realm == null) {
+            return;
+        }
+        realm.stopWaitForChange();
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
new file mode 100644
index 0000000000..dd23f1f917
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes readObject;
+    private RealmConfiguration coldConfig;
+
+    @BeforeExperiment
+    public void before() {
+        coldConfig = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).name("cold").build();
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(coldConfig);
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                readObject = realm.createObject(AllTypes.class);
+                readObject.setColumnString("Foo");
+                readObject.setColumnLong(42);
+                readObject.setColumnDouble(1.234D);
+            }
+        });
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void coldCreateAndClose(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Realm realm = Realm.getInstance(coldConfig);
+            realm.close();
+        }
+    }
+
+    @Benchmark
+    public void emptyTransaction(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.beginTransaction();
+            realm.commitTransaction();
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
new file mode 100644
index 0000000000..e26c003cd4
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmObjectReadBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes readObject;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                readObject = realm.createObject(AllTypes.class);
+                readObject.setColumnString("Foo");
+                readObject.setColumnLong(42);
+                readObject.setColumnDouble(1.234D);
+            }
+        });
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void readString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            String value = readObject.getColumnString();
+        }
+    }
+
+    @Benchmark
+    public void readLong(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long value = readObject.getColumnLong();
+        }
+    }
+
+    @Benchmark
+    public void readDouble(long reps) {
+        for (long i = 0; i < reps; i++) {
+            double value = readObject.getColumnDouble();
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
new file mode 100644
index 0000000000..73df749ab6
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmObjectWriteBenchmarks {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private AllTypes writeObject;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        writeObject = realm.createObject(AllTypes.class);
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Benchmark
+    public void writeString(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnString("Foo");
+        }
+    }
+
+    @Benchmark
+    public void writeLong(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnLong(42);
+        }
+    }
+
+    @Benchmark
+    public void writeDouble(long reps) {
+        for (long i = 0; i < reps; i++) {
+            writeObject.setColumnDouble(1.234D);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
new file mode 100644
index 0000000000..9117d55d0a
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.Sort;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmQueryBenchmarks {
+
+    private static final int DATA_SIZE = 1000;
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        for (int i = 0; i < DATA_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnLong(i);
+            obj.setColumnBoolean(i % 2 == 0);
+            obj.setColumnString("Foo " + i);
+            obj.setColumnDouble(i + 1.234D);
+        }
+        realm.commitTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void containsQuery(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> realmResults = realm.where(AllTypes.class).contains(AllTypes.FIELD_STRING, "Foo 1").findAll();
+        }
+    }
+
+    @Benchmark
+    public void count(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long size = realm.where(AllTypes.class).count();
+        }
+    }
+
+    @Benchmark
+    public void findAll(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        }
+    }
+
+    @Benchmark
+    public void findAllSortedOneField(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_STRING, Sort.ASCENDING);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
new file mode 100644
index 0000000000..5a25e95ee0
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.RealmResults;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.entities.AllTypes;
+
+@RunWith(SpannerRunner.class)
+public class RealmResultsBenchmarks {
+
+    private static final int DATA_SIZE = 1000;
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private RealmResults<AllTypes> results;
+
+    @BeforeExperiment
+    public void before() {
+        RealmConfiguration config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        for (int i = 0; i < DATA_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnLong(i);
+            obj.setColumnBoolean(i % 2 == 0);
+            obj.setColumnString("Foo " + i);
+            obj.setColumnDouble(i + 1.234D);
+        }
+        realm.commitTransaction();
+        results = realm.where(AllTypes.class).findAll();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.close();
+    }
+
+    @Benchmark
+    public void get(long reps) {
+        for (long i = 0; i < reps; i++) {
+            AllTypes item = results.get(0);
+        }
+    }
+
+    @Benchmark
+    public void size(long reps) {
+        for (long i = 0; i < reps; i++) {
+            long size = results.size();
+        }
+    }
+
+    @Benchmark
+    public void min(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number min = results.min(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void max(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number max = results.max(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void average(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number average = results.average(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void sum(long reps) {
+        for (long i = 0; i < reps; i++) {
+            Number sum = results.sum(AllTypes.FIELD_LONG);
+        }
+    }
+
+    @Benchmark
+    public void sort(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> sorted = results.sort(AllTypes.FIELD_STRING);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
new file mode 100644
index 0000000000..47a1136b30
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.config;
+
+import android.os.Environment;
+
+import java.io.File;
+import java.util.concurrent.TimeUnit;
+
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.config.RuntimeInstrumentConfig;
+import dk.ilios.spanner.output.ResultProcessor;
+
+/**
+ * Static helper class for creating benchmark configurations
+ * */
+public class BenchmarkConfig {
+
+    public static SpannerConfig getConfiguration(String className) {
+        // Document folder is located at: /sdcard/realm-benchmarks
+        // Benchmarks results should be saved in <documentFolder>/results/<className>.json
+        // Baseline data should be found in <documentFolder>/baselines/<className>.json
+        // Custom CSV files should be found in <documentFolder>/csv/<className>.csv
+        File externalDocuments = new File(Environment.getExternalStorageDirectory(), "realm-benchmarks");
+        if (!externalDocuments.exists() && !externalDocuments.mkdir()) {
+            throw new RuntimeException("Could not create benchmark folder: " + externalDocuments);
+        }
+        File resultsDir = new File(externalDocuments, "results");
+        File baselineDir = new File(externalDocuments, "baselines");
+        File baselineFile = new File(baselineDir, className + ".json");
+        File csvDir = new File(externalDocuments, "csv");
+        csvDir.mkdir();
+        File csvFile = new File(csvDir, className + ".csv");
+        ResultProcessor csvResultProcessor = new CSVResultProcessor(csvFile);
+
+        // General configuration for running benchmarks.
+        // Always save result files. CI will determine if it wants to store them.
+        SpannerConfig.Builder builder = new SpannerConfig.Builder()
+                .saveResults(resultsDir, className + ".json")
+                .trialsPrExperiment(1)
+                .maxBenchmarkThreads(1)
+                .addInstrument(new RuntimeInstrumentConfig.Builder()
+                                .gcBeforeEachMeasurement(true)
+                                .warmupTime(0, TimeUnit.SECONDS)
+                                .timingInterval(500, TimeUnit.MILLISECONDS)
+                                .measurements(9)
+                                .build()
+                )
+                .addResultProcessor(csvResultProcessor);
+
+        // Only use baseline file if it exists
+        if (baselineFile.exists()) {
+            builder.useBaseline(baselineFile);
+            // Test that 25. , 50. and 75. percentile don't change by more than 15%
+            builder.percentileFailureLimit(25f, 0.15f);
+            builder.percentileFailureLimit(50f, 0.15f);
+            builder.percentileFailureLimit(75f, 0.15f);
+        }
+
+        return builder.build();
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
new file mode 100644
index 0000000000..9a11c14fb2
--- /dev/null
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.config;
+
+import com.google.common.io.Files;
+import com.opencsv.CSVWriter;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.text.DecimalFormat;
+
+import dk.ilios.spanner.model.Trial;
+import dk.ilios.spanner.output.ResultProcessor;
+
+/**
+ * Converts the result of a benchmark to CSV for easier processing by other data/graph programs.
+ *
+ * Output is the following.
+ * methodname, trialNumber, params, measurements, min, max, average, 25pct, 50pct, 75pct
+ */
+public class CSVResultProcessor implements ResultProcessor {
+
+    private  static final boolean APPLY_QUOTES = true;
+    private static final DecimalFormat decimalFormater = new DecimalFormat("#.00");
+
+    private final File resultFile;
+    private final File workFile;
+    private final CSVWriter writer;
+
+    public CSVResultProcessor(File resultFile) {
+        this.resultFile = resultFile;
+        this.workFile = new File(resultFile.getPath() + ".tmp");
+        try {
+            writer = new CSVWriter(new FileWriter(resultFile));
+            addLabels();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void addLabels() {
+        String[] labels = new String[] {
+                "Method name",
+                "Trial",
+                "Measurements",
+                "Min.",
+                "Max.",
+                "Mean",
+                "25pct.",
+                "50pct.",
+                "75pct.",
+        };
+
+        writer.writeNext(labels, APPLY_QUOTES);
+    }
+
+    @Override
+    public void processTrial(Trial trial) {
+        String methodName = trial.experiment().instrumentation().benchmarkMethod().getName();
+        int trialNo = trial.getTrialNumber();
+        int measurements = trial.measurements().size();
+        double min = trial.getMin();
+        double max = trial.getMax();
+        double mean = trial.getMean();
+        double percentile25 = trial.getPercentile(25);
+        double percentile50 = trial.getMedian();
+        double percentile75 = trial.getPercentile(75);
+
+        String[] resultLine = new String[] {
+                methodName,
+                Integer.toString(trialNo),
+                Integer.toString(measurements),
+                decimalFormater.format(min),
+                decimalFormater.format(max),
+                decimalFormater.format(mean),
+                decimalFormater.format(percentile25),
+                decimalFormater.format(percentile50),
+                decimalFormater.format(percentile75)
+        };
+
+        writer.writeNext(resultLine);
+    }
+
+    @Override
+    public void close() throws IOException {
+        writer.close();
+        if (workFile.exists()) {
+            Files.move(workFile, resultFile);
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 739107ee15..6565dbae6e 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -18,6 +18,9 @@
 
 import android.os.Handler;
 import android.os.Looper;
+import android.os.Message;
+
+import com.getkeepsafe.relinker.BuildConfig;
 
 import java.io.Closeable;
 import java.io.File;
@@ -28,12 +31,13 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SharedGroupManager;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
 import io.realm.internal.UncheckedRow;
 import io.realm.internal.android.DebugAndroidLogger;
 import io.realm.internal.android.ReleaseAndroidLogger;
@@ -47,18 +51,23 @@
  * @see io.realm.Realm
  * @see io.realm.DynamicRealm
  */
+@SuppressWarnings("WeakerAccess")
 abstract class BaseRealm implements Closeable {
     protected static final long UNVERSIONED = -1;
-    private static final String INCORRECT_THREAD_CLOSE_MESSAGE = "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
-    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
-    private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
-    private static final String CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE = "Cannot refresh inside of a transaction.";
+    private static final String INCORRECT_THREAD_CLOSE_MESSAGE =
+            "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
+    private static final String INCORRECT_THREAD_MESSAGE =
+            "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
+    private static final String CLOSED_REALM_MESSAGE =
+            "This Realm instance has already been closed, making it unusable.";
+    private static final String NOT_IN_TRANSACTION_MESSAGE =
+            "Changing Realm data can only be done from inside a transaction.";
 
     // Map between a Handler and the canonical path to a Realm file
     protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
 
     // Thread pool for all async operations (Query & transaction)
-    static final RealmThreadPoolExecutor asyncQueryExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
+    static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
     protected RealmConfiguration configuration;
@@ -68,24 +77,28 @@
     HandlerController handlerController;
 
     static {
+        //noinspection ConstantConditions
         RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
     }
 
-    protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
+    protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
         this.sharedGroupManager = new SharedGroupManager(configuration);
         this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
         this.handlerController = new HandlerController(this);
-        setAutoRefresh(autoRefresh);
+
+        if (handlerController.isAutoRefreshAvailable()) {
+            setAutoRefresh(true);
+        }
     }
 
     /**
      * Sets the auto-refresh status of the Realm instance.
      * <p>
      * Auto-refresh is a feature that enables automatic update of the current Realm instance and all its derived objects
-     * (RealmResults and RealmObjects instances) when a commit is performed on a Realm acting on the same file in
-     * another thread. This feature is only available if the Realm instance lives is a {@link android.os.Looper} enabled
+     * (RealmResults and RealmObject instances) when a commit is performed on a Realm acting on the same file in
+     * another thread. This feature is only available if the Realm instance lives on a {@link android.os.Looper} enabled
      * thread.
      *
      * @param autoRefresh {@code true} will turn auto-refresh on, {@code false} will turn it off.
@@ -93,10 +106,7 @@ protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
      */
     public void setAutoRefresh(boolean autoRefresh) {
         checkIfValid();
-        if (autoRefresh && Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
-        }
-
+        handlerController.checkCanBeAutoRefreshed();
         if (autoRefresh && !handlerController.isAutoRefreshEnabled()) { // Switch it on
             handler = new Handler(handlerController);
             handlers.put(handler, configuration.getPath());
@@ -125,29 +135,13 @@ public boolean isInTransaction() {
         return !sharedGroupManager.isImmutable();
     }
 
-    /**
-     * Adds a change listener to the Realm.
-     * <p>
-     * The listeners will be executed:
-     * <ul>
-     * <li>Immediately if a change was committed by the local thread</li>
-     * <li>On every loop of a Handler thread if changes were committed by another thread</li>
-     * <li>On every call to {@link io.realm.Realm#refresh()}</li>
-     * </ul>
-     *
-     * Listeners are stored as a strong reference, you need to remove the added listeners using {@link #removeChangeListener(RealmChangeListener)}
-     * or {@link #removeAllChangeListeners()} which removes all listeners including the ones added via anonymous classes.
-     *
-     * @param listener the change listener.
-     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
-     * @see io.realm.RealmChangeListener
-     * @see #removeChangeListener(RealmChangeListener)
-     * @see #removeAllChangeListeners()
-     */
-    public void addChangeListener(RealmChangeListener listener) {
+    protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
         checkIfValid();
         if (!handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+            throw new IllegalStateException("You can't register a listener from a non-Looper or IntentService thread.");
         }
         handlerController.addChangeListener(listener);
     }
@@ -156,11 +150,14 @@ public void addChangeListener(RealmChangeListener listener) {
      * Removes the specified change listener.
      *
      * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
-     * @see #addChangeListener(RealmChangeListener)
      */
-    public void removeChangeListener(RealmChangeListener listener) {
+    public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
         checkIfValid();
         if (!handlerController.isAutoRefreshEnabled()) {
             throw new IllegalStateException("You can't remove a listener from a non-Looper thread ");
@@ -172,8 +169,8 @@ public void removeChangeListener(RealmChangeListener listener) {
      * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
      * when subscribed to. Items will continually be emitted as the Realm is updated -
      * {@code onComplete} will never be called.
-     *
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * <p>
+     * If you would like the {@code asObservable()} to stop emitting items, you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
      * <pre>
@@ -186,6 +183,7 @@ public void removeChangeListener(RealmChangeListener listener) {
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public abstract Observable asObservable();
 
     /**
@@ -193,7 +191,6 @@ public void removeChangeListener(RealmChangeListener listener) {
      *
      * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
-     * @see #addChangeListener(RealmChangeListener)
      */
     public void removeAllChangeListeners() {
         checkIfValid();
@@ -260,35 +257,80 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IO
     }
 
     /**
-     * Refreshes the Realm instance and all the RealmResults and RealmObjects instances coming from it.
-     * It also calls the listeners associated to the Realm instance.
+     * Blocks the current thread until new changes to the Realm are available or {@link #stopWaitForChange()}
+     * is called from another thread. Once stopWaitForChange is called, all future calls to this method will
+     * return false immediately.
      *
-     * @throws IllegalStateException if attempting to refresh from within a transaction.
+     * @return {@code true} if the Realm was updated to the latest version, {@code false} if it was
+     * cancelled by calling stopWaitForChange.
+     * @throws IllegalStateException if calling this from within a transaction or from a Looper thread.
      */
-    @SuppressWarnings("UnusedDeclaration")
-    public void refresh() {
+    public boolean waitForChange() {
         checkIfValid();
         if (isInTransaction()) {
-            throw new IllegalStateException(BaseRealm.CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE);
+            throw new IllegalStateException("Cannot wait for changes inside of a transaction.");
         }
-        if (!handlerController.isAutoRefreshEnabled()) {
-            // non Looper Thread, just advance the Realm
-            // registering listeners is not allowed, hence nothing to notify
+        if (Looper.myLooper() != null) {
+            throw new IllegalStateException("Cannot wait for changes inside a Looper thread. Use RealmChangeListeners instead.");
+        }
+        boolean hasChanged = sharedGroupManager.getSharedGroup().waitForChange();
+        if (hasChanged) {
+            // Since this Realm instance has been waiting for change, advance realm & refresh realm.
             sharedGroupManager.advanceRead();
             handlerController.refreshSynchronousTableViews();
-        } else {
-            handlerController.notifyCurrentThreadRealmChanged();
         }
+        return hasChanged;
+    }
+
+    /**
+     * Makes any current {@link #waitForChange()} return {@code false} immediately. Once this is called,
+     * all future calls to waitForChange will immediately return {@code false}.
+     * <p>
+     * This method is thread-safe and should _only_ be called from another thread than the one that
+     * called waitForChange.
+     *
+     * @throws IllegalStateException if the {@link io.realm.Realm} instance has already been closed.
+     */
+    public void stopWaitForChange() {
+        RealmCache.invokeWithLock(new RealmCache.Callback0() {
+            @Override
+            public void onCall() {
+                // Check if the Realm instance has been closed
+                if (sharedGroupManager == null || !sharedGroupManager.isOpen() || sharedGroupManager.getSharedGroup().isClosed()) {
+                    throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+                }
+                sharedGroupManager.getSharedGroup().stopWaitForChange();
+            }
+        });
     }
 
     /**
-     * Starts a transaction, this must be closed with {@link io.realm.Realm#commitTransaction()} or aborted by
+     * Starts a transaction which must be closed by {@link io.realm.Realm#commitTransaction()} or aborted by
      * {@link io.realm.Realm#cancelTransaction()}. Transactions are used to atomically create, update and delete objects
      * within a Realm.
-     * <br>
-     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the realm in the case of
-     * pending updates from other threads.
-     * <br>
+     * <p>
+     * Before beginning a transaction, the Realm instance is updated to the latest version in order to include all
+     * changes from other threads. This update does not trigger any registered {@link RealmChangeListener}.
+     * <p>
+     * It is therefore recommended to query for the items that should be modified from inside the transaction. Otherwise
+     * there is a risk that some of the results have been deleted or modified when the transaction begins.
+     * <p>
+     * <pre>
+     * {@code
+     * // Don't do this
+     * RealmResults<Person> persons = realm.where(Person.class).findAll();
+     * realm.beginTransaction();
+     * persons.first().setName("John");
+     * realm.commitTransaction;
+     *
+     * // Do this instead
+     * realm.beginTransaction();
+     * RealmResults<Person> persons = realm.where(Person.class).findAll();
+     * persons.first().setName("John");
+     * realm.commitTransaction;
+     * }
+     * </pre>
+     * <p>
      * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
      * thrown.
      */
@@ -300,11 +342,19 @@ public void beginTransaction() {
     /**
      * All changes since {@link io.realm.Realm#beginTransaction()} are persisted to disk and the Realm reverts back to
      * being read-only. An event is sent to notify all other Realm instances that a change has occurred. When the event
-     * is received, the other Realms will get their objects and {@link io.realm.RealmResults} updated to reflect the
+     * is received, the other Realms will update their objects and {@link io.realm.RealmResults} to reflect the
      * changes from this commit.
      */
     public void commitTransaction() {
-        commitTransaction(true, null);
+        commitTransaction(true, true, null);
+    }
+
+    /**
+     * Commits an async transaction. This will not trigger any REALM_CHANGED events. Caller is responsible for handling
+     * that.
+     */
+    void commitAsyncTransaction(Runnable runAfterCommit) {
+        commitTransaction(false, false, runAfterCommit);
     }
 
     /**
@@ -315,7 +365,7 @@ public void commitTransaction() {
      * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change listeners.
      * @param runAfterCommit runnable will run after transaction committed but before notification sent.
      */
-    void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
+    void commitTransaction(boolean notifyLocalThread, boolean notifyOtherThreads, Runnable runAfterCommit) {
         checkIfValid();
         sharedGroupManager.commitAndContinueAsRead();
 
@@ -333,17 +383,48 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
                 continue;
             }
 
+            // Sometimes we don't want to notify other threads about changes because we need a custom message, e.g. when
+            // doing async transactions.
+            if (!notifyOtherThreads && !handler.equals(this.handler)) {
+                continue;
+            }
+
             // For all other threads, use the Handler
             // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
             // as the target thread consumes messages at the same time. In this case it is not a problem as worst
             // case we end up with two REALM_CHANGED messages in the queue.
-            if (
-                    realmPath.equals(configuration.getPath())                           // It's the right realm
-                            && !handler.hasMessages(HandlerController.REALM_CHANGED)    // The right message
-                            && handler.getLooper().getThread().isAlive()                // The receiving thread is alive
-                            && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
-                RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
-                        "to prevent this.");
+            Looper looper = handler.getLooper();
+            if (realmPath.equals(configuration.getPath())  // It's the right realm
+                    && looper.getThread().isAlive()) {     // The receiving thread is alive
+
+                boolean messageHandled = true;
+                if (looper == Looper.myLooper()) {
+                    // Force any updates on the current thread to the front the queue. Doing this is mostly
+                    // relevant on the UI thread where it could otherwise process a motion event before the
+                    // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
+                    // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
+                    // Other Looper threads could process similar events. For that reason all looper threads will
+                    // prioritize local commits.
+                    //
+                    // If a user is doing commits inside a RealmChangeListener this can cause the Looper thread to get
+                    // event starved as it only starts handling Realm events instead. This is an acceptable risk as
+                    // that behaviour indicate a user bug. Previously this would be hidden as the UI would still
+                    // be responsive.
+                    Message msg = Message.obtain();
+                    msg.what = HandlerControllerConstants.LOCAL_COMMIT;
+                    if (!handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
+                        handler.removeMessages(HandlerControllerConstants.REALM_CHANGED);
+                        messageHandled = handler.sendMessageAtFrontOfQueue(msg);
+                    }
+                } else {
+                    if (!handler.hasMessages(HandlerControllerConstants.REALM_CHANGED)) {
+                        messageHandled = handler.sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
+                    }
+                }
+                if (!messageHandled) {
+                    RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
+                            "to prevent this.");
+                }
             }
         }
     }
@@ -351,9 +432,9 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
     /**
      * Reverts all writes (created, updated, or deleted objects) made in the current write transaction and end the
      * transaction.
-     * <br>
+     * <p>
      * The Realm reverts back to read-only.
-     * <br>
+     * <p>
      * Calling this when not in a transaction will throw an exception.
      */
     public void cancelTransaction() {
@@ -376,6 +457,15 @@ protected void checkIfValid() {
         }
     }
 
+    /**
+     * Check if the Realm is valid and in a transaction.
+     */
+    protected void checkIfValidAndInTransaction() {
+        if (!isInTransaction()) {
+            throw new IllegalStateException(NOT_IN_TRANSACTION_MESSAGE);
+        }
+    }
+
     /**
      * Returns the canonical path to where this Realm is persisted on disk.
      *
@@ -476,32 +566,6 @@ void setVersion(long version) {
         metadataTable.setLong(0, 0, version);
     }
 
-    /**
-     * Sort a table using the given field names and sorting directions. If a field name does not
-     * exist in the table an {@link IllegalArgumentException} will be thrown.
-     */
-    protected TableView doMultiFieldSort(String[] fieldNames, Sort sortOrders[], Table table) {
-        long columnIndices[] = new long[fieldNames.length];
-        for (int i = 0; i < fieldNames.length; i++) {
-            String fieldName = fieldNames[i];
-            long columnIndex = table.getColumnIndex(fieldName);
-            if (columnIndex == -1) {
-                throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-            }
-            columnIndices[i] = columnIndex;
-        }
-
-        return table.getSortedView(columnIndices, sortOrders);
-    }
-
-    protected void checkAllObjectsSortedParameters(String[] fieldNames, Sort[] sortOrders) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames must be provided.");
-        } else if (sortOrders == null) {
-            throw new IllegalArgumentException("sortOrders must be provided.");
-        }
-    }
-
     // Return all handlers registered for this Realm
     static Map<Handler, String> getHandlers() {
         return handlers;
@@ -525,9 +589,6 @@ public RealmSchema getSchema() {
         proxy.realmGet$proxyState().setRealm$realm(this);
         proxy.realmGet$proxyState().setTableVersion$realm();
 
-        if (handlerController != null) {
-            handlerController.addToRealmObjects(result);
-        }
         return result;
     }
 
@@ -555,7 +616,6 @@ public RealmSchema getSchema() {
             proxy.realmGet$proxyState().setRow$realm(InvalidRow.INSTANCE);
         }
 
-        handlerController.addToRealmObjects(result);
         return result;
     }
 
@@ -571,10 +631,34 @@ public void deleteAll() {
         }
     }
 
+    static private boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
+        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
+
+        List<File> filesToDelete = Arrays.asList(
+                new File(rootFolder, realmFileName),
+                new File(rootFolder, realmFileName + ".lock"),
+                // Old core log file naming styles
+                new File(rootFolder, realmFileName + ".log_a"),
+                new File(rootFolder, realmFileName + ".log_b"),
+                new File(rootFolder, realmFileName + ".log"),
+                new File(canonicalPath));
+        for (File fileToDelete : filesToDelete) {
+            if (fileToDelete.exists()) {
+                boolean deleteResult = fileToDelete.delete();
+                if (!deleteResult) {
+                    realmDeleted.set(false);
+                    RealmLog.w("Could not delete the file " + fileToDelete);
+                }
+            }
+        }
+        return realmDeleted.get();
+    }
+
     /**
      * Deletes the Realm file defined by the given configuration.
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
+        final String management = ".management";
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
 
         RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
@@ -588,20 +672,20 @@ public void onResult(int count) {
                 String canonicalPath = configuration.getPath();
                 File realmFolder = configuration.getRealmFolder();
                 String realmFileName = configuration.getRealmFileName();
-                List<File> filesToDelete = Arrays.asList(new File(canonicalPath),
-                        new File(realmFolder, realmFileName + ".lock"),
-                        new File(realmFolder, realmFileName + ".log_a"),
-                        new File(realmFolder, realmFileName + ".log_b"),
-                        new File(realmFolder, realmFileName + ".log"));
-                for (File fileToDelete : filesToDelete) {
-                    if (fileToDelete.exists()) {
-                        boolean deleteResult = fileToDelete.delete();
-                        if (!deleteResult) {
-                            realmDeleted.set(false);
-                            RealmLog.w("Could not delete the file " + fileToDelete);
-                        }
+                File managementFolder = new File(realmFolder, realmFileName + management);
+
+                // delete files in management folder and the folder
+                // there is no subfolders in the management folder
+                File[] files = managementFolder.listFiles();
+                if (files != null) {
+                    for (File file : files) {
+                        realmDeleted.set(realmDeleted.get() && file.delete());
                     }
                 }
+                realmDeleted.set(realmDeleted.get() && managementFolder.delete());
+
+                // delete specific files in root folder
+                realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
             }
         });
 
@@ -610,6 +694,10 @@ public void onResult(int count) {
 
     /**
      * Compacts the Realm file defined by the given configuration.
+     *
+     * @param configuration configuration for the Realm to compact.
+     * @throws IllegalArgumentException if Realm is encrypted.
+     * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
         if (configuration.getEncryptionKey() != null) {
@@ -622,8 +710,8 @@ static boolean compactRealm(final RealmConfiguration configuration) {
     /**
      * Migrates the Realm file defined by the given configuration using the provided migration block.
      *
-     * @param configuration configuration for the Realm that should be migrated
-     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}
+     * @param configuration configuration for the Realm that should be migrated.
+     * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
      * @param callback callback for specific Realm type behaviors.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
@@ -681,6 +769,17 @@ public void onResult(int count) {
         }
     }
 
+    @Override
+    protected void finalize() throws Throwable {
+        if (sharedGroupManager != null && sharedGroupManager.isOpen()) {
+            RealmLog.w("Remember to call close() on all Realm instances. " +
+                    "Realm " + configuration.getPath() + " is being finalized without being closed, " +
+                    "this can lead to running out of native memory."
+            );
+        }
+        super.finalize();
+    }
+
     // Internal delegate for migrations
     protected interface MigrationCallback {
         void migrationComplete();
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 5a37ee6a5b..6875b18eaa 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,29 +16,29 @@
 
 package io.realm;
 
-import android.os.Looper;
+import android.app.IntentService;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
 import io.realm.internal.log.RealmLog;
 import rx.Observable;
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
  * done using string based class names instead of class type references.
- *
+ * <p>
  * This is useful during migrations or when working with string-based data like CSV or XML files.
- *
+ * <p>
  * The same {@link io.realm.RealmConfiguration} can be used to open a Realm file in both dynamic and typed mode, but
  * modifying the schema while having both a typed and dynamic version open is highly discouraged and will most likely
  * crash the typed Realm. During migrations only a DynamicRealm will be open.
- *
+ * <p>
  * Dynamic Realms do not enforce schemas or schema versions and {@link RealmMigration} code is not used even if it has
  * been defined in the {@link RealmConfiguration}.
- *
- * This means that the schema is not created or validated until a Realm has been opened in typed mode, so if a Realm
+ * <p>
+ * This means that the schema is not created or validated until a Realm has been opened in typed mode. If a Realm
  * file is opened in dynamic mode first it will not contain any information about classes and fields, and any queries
  * for classes defined by the schema will fail.
  *
@@ -47,8 +47,8 @@
  */
 public final class DynamicRealm extends BaseRealm {
 
-    private DynamicRealm(RealmConfiguration configuration, boolean autoRefresh) {
-        super(configuration, autoRefresh);
+    private DynamicRealm(RealmConfiguration configuration) {
+        super(configuration);
     }
 
     /**
@@ -89,7 +89,7 @@ public DynamicRealmObject createObject(String className) {
      * @return the new object. All fields will have default values for their type, except for the
      * primary key field which will have the provided value.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expectd value.
      */
@@ -97,14 +97,13 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
         Table table = schema.getTable(className);
         long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
         DynamicRealmObject dynamicRealmObject = new DynamicRealmObject(this, table.getCheckedRow(index));
-        handlerController.addToRealmObjects(dynamicRealmObject);
         return dynamicRealmObject;
     }
 
     /**
-     * Returns a RealmQuery, which can be used to query for the provided class.
+     * Returns a RealmQuery, which can be used to query the provided class.
      *
-     * @param className The class of the object which is to be queried for.
+     * @param className the class of the object which is to be queried.
      * @return a RealmQuery, which can be used to query for specific objects of provided type.
      * @see io.realm.RealmQuery
      * @throws IllegalArgumentException if the class doesn't exist.
@@ -112,21 +111,31 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
         if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
-            throw new IllegalArgumentException("Class does not exist in the Realm so it cannot be queried: " + className);
+            throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
     }
 
+
     /**
-     * Removes all objects of the specified class.
-     *
-     * DEPRECATED: Use {@link #delete(String)} instead.
+     * Adds a change listener to the Realm.
+     * <p>
+     * The listeners will be executed on every loop of a Handler thread if changes are committed by
+     * this or another thread.
+     * <p>
+     * Realm instances are cached per thread. For that reason it is important to
+     * remember to remove listeners again either using {@link #removeChangeListener(RealmChangeListener)}
+     * or {@link #removeAllChangeListeners()}. Not doing so can cause memory leaks.
      *
-     * @param className the class for which all objects should be removed.
+     * @param listener the change listener.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper or {@link IntentService} thread.
+     * @see io.realm.RealmChangeListener
+     * @see #removeChangeListener(RealmChangeListener)
+     * @see #removeAllChangeListeners()
      */
-    @Deprecated
-    public void clear(String className) {
-        delete(className);
+    public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
+        super.addListener(listener);
     }
 
     /**
@@ -166,99 +175,20 @@ public void executeTransaction(Transaction transaction) {
         }
     }
 
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll()} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjects(String className) {
-        return where(className).findAll();
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName, sortOrder)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName, Sort sortOrder) {
-        checkIfValid();
-        Table table = schema.getTable(className);
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        TableView tableView = table.getSortedView(columnIndex, sortOrder);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldName1,
-                                                                    Sort sortOrder1, String fieldName2,
-                                                                    Sort sortOrder2) {
-        return allObjectsSorted(className, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
-                sortOrder2});
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).findAll(fieldNames[], sortOrders[])} instead.
-     */
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public RealmResults<DynamicRealmObject> allObjectsSorted(String className, String fieldNames[], Sort sortOrders[]) {
-        checkAllObjectsSortedParameters(fieldNames, sortOrders);
-        Table table = schema.getTable(className);
-
-        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
     /**
      * Creates a {@link DynamicRealm} instance without checking the existence in the {@link RealmCache}.
      *
      * @return a {@link DynamicRealm} instance.
      */
     static DynamicRealm createInstance(RealmConfiguration configuration) {
-        boolean autoRefresh = Looper.myLooper() != null;
-        return new DynamicRealm(configuration, autoRefresh);
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(fieldName)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinct(String className, String fieldName) {
-        checkIfValid();
-        Table table = schema.getTable(className);
-        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
-        TableView tableView = table.getDistinctView(columnIndex);
-        return RealmResults.createFromDynamicTableOrView(this, tableView, className);
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinctAsync(fieldName)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinctAsync(String className, String fieldName) {
-        checkIfValid();
-        return where(className).distinctAsync(fieldName);
-    }
-
-    /**
-     * DEPRECATED: Use {@code dynamicRealm.where(className).distinct(firstFieldName, remainingFieldNames)} instead.
-     */
-    @Deprecated
-    public RealmResults<DynamicRealmObject> distinct(String className, String firstFieldName, String... remainingFieldNames) {
-        checkIfValid();
-        return where(className).distinct(firstFieldName, remainingFieldNames);
+        return new DynamicRealm(configuration);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<DynamicRealm> asObservable() {
         return configuration.getRxFactory().from(this);
     }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index e10d3efc13..773ad0894f 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -32,7 +32,7 @@
  * Using a DynamicRealmObject is slower than using the regular RealmObject class.
  */
 public final class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
-    private final ProxyState proxyState = new ProxyState();
+    private final ProxyState proxyState = new ProxyState(this);
     /**
      * Creates a dynamic Realm object based on an existing object.
      *
@@ -49,7 +49,7 @@ public DynamicRealmObject(RealmModel obj) {
 
         if (!RealmObject.isValid(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
-                    "is a standalone object or it was deleted.");
+                    "is an unmanaged object or it was deleted.");
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) obj;
@@ -102,12 +102,13 @@ public DynamicRealmObject(RealmModel obj) {
 
     /**
      * Returns the {@code boolean} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the boolean value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain booleans.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain booleans.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public boolean getBoolean(String fieldName) {
@@ -117,12 +118,13 @@ public boolean getBoolean(String fieldName) {
 
     /**
      * Returns the {@code int} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the int value. Integer values exceeding {@code Integer.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public int getInt(String fieldName) {
@@ -131,12 +133,13 @@ public int getInt(String fieldName) {
 
     /**
      * Returns the {@code short} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the short value. Integer values exceeding {@code Short.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public short getShort(String fieldName) {
@@ -145,12 +148,13 @@ public short getShort(String fieldName) {
 
     /**
      * Returns the {@code long} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the long value. Integer values exceeding {@code Long.MAX_VALUE} will wrap.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public long getLong(String fieldName) {
@@ -160,12 +164,13 @@ public long getLong(String fieldName) {
 
     /**
      * Returns the {@code byte} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the byte value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain integers.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain integers.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public byte getByte(String fieldName) {
@@ -175,12 +180,13 @@ public byte getByte(String fieldName) {
 
     /**
      * Returns the {@code float} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the float value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain floats.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain floats.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public float getFloat(String fieldName) {
@@ -190,12 +196,13 @@ public float getFloat(String fieldName) {
 
     /**
      * Returns the {@code double} value for a given field.
-     * If the field is nullable use {@link #isNull(String)} to check for {@code null} instead of using
+     * <p>
+     * If the field is nullable, use {@link #isNull(String)} to check for {@code null} instead of using
      * this method.
      *
      * @param fieldName the name of the field.
      * @return the double value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain doubles.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain doubles.
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public double getDouble(String fieldName) {
@@ -208,7 +215,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the byte[] value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain binary data.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain binary data.
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -220,7 +227,7 @@ public double getDouble(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the String value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Strings.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Strings.
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -232,7 +239,7 @@ public String getString(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the Date value.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain Dates.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Dates.
      */
     public Date getDate(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -248,7 +255,7 @@ public Date getDate(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link DynamicRealmObject} representation of the linked object or {@code null} if no object is linked.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain links to other objects.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain links to other objects.
      */
     public DynamicRealmObject getObject(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -266,7 +273,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return the {@link RealmList} data for this field.
-     * @throws IllegalArgumentException if field name doesn't exists or it doesn't contain a list of links.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -280,7 +287,7 @@ public DynamicRealmObject getObject(String fieldName) {
      *
      * @param fieldName the name of the field.
      * @return {@code true} if field value is null, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exists.
+     * @throws IllegalArgumentException if field name doesn't exist.
      */
     public boolean isNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -332,13 +339,13 @@ public boolean hasField(String fieldName) {
     }
 
     /**
-     * Set the value for the given field. This method will automatically try to convert numbers and
-     * booleans that are given as {@code String} to their appropriate type. E.g. {@code "10"} will be
-     * converted to {@code 10} if the field type is {@code int}.
-     *
+     * Sets the value for the given field. This method will automatically try to convert numbers and
+     * booleans that are given as {@code String} to their appropriate type. For example {@code "10"} 
+     * will be converted to {@code 10} if the field type is {@code int}.
+     * <p>
      * Using the typed setters will be faster than using this method.
-     *
-     * @throws IllegalArgumentException if field name doesn't exists or if the input value cannot be converted
+     * 
+     * @throws IllegalArgumentException if field name doesn't exist or if the input value cannot be converted
      * to the appropriate input type.
      * @throws NumberFormatException if a String based number cannot be converted properly.
      */
@@ -410,7 +417,7 @@ private void setValue(String fieldName, Object value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a boolean field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a boolean field.
      */
     public void setBoolean(String fieldName, boolean value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -422,7 +429,7 @@ public void setBoolean(String fieldName, boolean value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setShort(String fieldName, short value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -434,7 +441,7 @@ public void setShort(String fieldName, short value) {
      *
      * @param fieldName field name to update.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setInt(String fieldName, int value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -446,7 +453,7 @@ public void setInt(String fieldName, int value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setLong(String fieldName, long value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -458,7 +465,7 @@ public void setLong(String fieldName, long value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
      */
     public void setByte(String fieldName, byte value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -470,7 +477,7 @@ public void setByte(String fieldName, byte value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't an integer field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a float field.
      */
     public void setFloat(String fieldName, float value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -482,7 +489,7 @@ public void setFloat(String fieldName, float value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a double field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a double field.
      */
     public void setDouble(String fieldName, double value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -494,7 +501,7 @@ public void setDouble(String fieldName, double value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a String field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
      */
     public void setString(String fieldName, String value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -506,7 +513,7 @@ public void setString(String fieldName, String value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a binary field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a binary field.
      */
     public void setBlob(String fieldName, byte[] value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -518,7 +525,7 @@ public void setBlob(String fieldName, byte[] value) {
      *
      * @param fieldName field name.
      * @param value value to insert.
-     * @throws IllegalArgumentException if field name doesn't exists or isn't a Date field.
+     * @throws IllegalArgumentException if field name doesn't exist or field isn't a Date field.
      */
     public void setDate(String fieldName, Date value) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -534,7 +541,7 @@ public void setDate(String fieldName, Date value) {
      *
      * @param fieldName field name.
      * @param value object to link to.
-     * @throws IllegalArgumentException if field name doesn't exists, it doesn't link to other Realm objects, the type
+     * @throws IllegalArgumentException if field name doesn't exist, it doesn't link to other Realm objects, the type
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
     public void setObject(String fieldName, DynamicRealmObject value) {
@@ -575,7 +582,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
         String tableName = proxyState.getRow$realm().getTable().getName();
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
-            // Standalone lists don't know anything about the types they contain. They might even hold objects of
+            // Unmanaged lists don't know anything about the types they contain. They might even hold objects of
             // multiple types :(, so we have to check each item in the list.
             typeValidated = false;
         } else {
@@ -609,7 +616,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
      * Sets the value to {@code null} for the given field.
      *
      * @param fieldName field name.
-     * @throws IllegalArgumentException if field name doesn't exists, or the field isn't nullable.
+     * @throws IllegalArgumentException if field name doesn't exist, or the field isn't nullable.
      */
     public void setNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -622,7 +629,7 @@ public void setNull(String fieldName) {
     }
 
     /**
-     * Return the type of object. This will normally correspond to the name of a class that is extending
+     * Returns the type of object. This will normally correspond to the name of a class that is extending
      * {@link RealmObject}.
      *
      * @return this objects type.
@@ -641,6 +648,19 @@ public RealmFieldType getFieldType(String fieldName) {
         return proxyState.getRow$realm().getColumnType(columnIndex);
     }
 
+    /**
+     * Returns a hash code value for the {@link DynamicRealmObject} object.
+     * <p>
+     * By the general contract of {@link Object#hashCode()}, any two objects for which {@link #equals}
+     * returns {@code true} must return the same hash code value.
+     * <p>
+     * Note that a {@link RealmObject} is a live object, and it might be updated by changes from
+     * other threads. This means that a hash code value of the object is not stable, and the value
+     * should be neither used as a key in HashMap nor saved in HashSet.
+     *
+     * @return  a hash code value for the object.
+     * @see     #equals
+     */
     @Override
     public int hashCode() {
         String realmName = proxyState.getRealm$realm().getPath();
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index 5b4185f188..1d8d5a047a 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -29,9 +29,11 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.IdentitySet;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -45,25 +47,21 @@
  */
 final class HandlerController implements Handler.Callback {
 
-    static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
-    static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
-    static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
-    static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
-    static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+    private final static Boolean NO_REALM_QUERY = Boolean.TRUE;
 
     // Keep a strong reference to the registered RealmChangeListener
     // user should unregister those listeners
-    final CopyOnWriteArrayList<RealmChangeListener> changeListeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    final CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>> changeListeners = new CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>>();
 
     // Keep a weak reference to the registered RealmChangeListener those are Weak since
     // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener
-    final List<WeakReference<RealmChangeListener>> weakChangeListeners =
-            new CopyOnWriteArrayList<WeakReference<RealmChangeListener>>();
+    final List<WeakReference<RealmChangeListener<? extends BaseRealm>>> weakChangeListeners =
+            new CopyOnWriteArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>();
 
     final BaseRealm realm;
     private boolean autoRefresh; // Requires a Looper thread to be true.
 
-    // pending update of async queriess
+    // pending update of async queries
     private Future updateAsyncQueriesTask;
 
     private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueAsyncRealmResults =
@@ -81,15 +79,24 @@
     // Keep a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
     // the query in the background for each commit, until we got a valid Row (pointer)
     final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> emptyAsyncRealmObject =
-            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
+            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
 
-    // keep a reference to the list of sync RealmResults, we'll use it
+    // Keep a reference to the list of sync RealmResults, we'll use it
     // to deliver type based notification once the shared_group advance
     final IdentitySet<WeakReference<RealmResults<? extends RealmModel>>> syncRealmResults =
             new IdentitySet<WeakReference<RealmResults<? extends RealmModel>>>();
 
-    final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> realmObjects =
-            new IdentityHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
+    // Since ConcurrentHashMap doesn't support null value, and since java.util.Optional are not
+    // yet an option (using Java 6) we use an Object with the dummy value Boolean.TRUE to indicate
+    // a null value (no RealmQuery<? extends RealmModel>) this is the same approach used in the JDK
+    // ex here https://android.googlesource.com/platform/libcore/+/refs/heads/master/luni/src/main/java/java/util/concurrent/ConcurrentSkipListSet.java#214
+    final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
+            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object>();
+
+    // List of onSuccess callbacks from async transactions. We need to track all callbacks as notifying listeners might
+    // be delayed due to the presence of async queries. This can mean that multiple async transactions can complete
+    // before we are ready to notify all of them.
+    private final List<Runnable> pendingOnSuccessAsyncTransactionCallbacks = new ArrayList<Runnable>();
 
     public HandlerController(BaseRealm realm) {
         this.realm = realm;
@@ -106,27 +113,28 @@ public boolean handleMessage(Message message) {
             QueryUpdateTask.Result result;
             switch (message.what) {
 
-                case REALM_CHANGED:
-                    realmChanged();
+                case HandlerControllerConstants.LOCAL_COMMIT:
+                case HandlerControllerConstants.REALM_CHANGED:
+                    realmChanged(message.what == HandlerControllerConstants.LOCAL_COMMIT);
                     break;
 
-                case COMPLETED_ASYNC_REALM_RESULTS:
+                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmResults(result);
                     break;
 
-                case COMPLETED_ASYNC_REALM_OBJECT:
+                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT:
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmObject(result);
                     break;
 
-                case COMPLETED_UPDATE_ASYNC_QUERIES:
+                case HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES:
                     // this is called once the background thread completed the update of the async queries
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncQueriesUpdate(result);
                     break;
 
-                case REALM_ASYNC_BACKGROUND_EXCEPTION:
+                case HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION:
                     // Don't fail silently in the background in case of Core exception
                     throw (Error) message.obj;
 
@@ -137,29 +145,47 @@ public boolean handleMessage(Message message) {
         return true;
     }
 
-    void addChangeListener(RealmChangeListener listener) {
+    /**
+     * Properly handles when an async transaction completes. This will be treated as a REALM_CHANGED event when
+     * determining which queries to re-run and when to notify listeners.
+     * <p>
+     * NOTE: This is needed as it is not possible to combine a `Message.what` value and a callback runnable. So instead
+     * of posting two messages, we post a runnable that runs this method. This means it is possible to interpret
+     * `REALM_CHANGED + Runnable` as one atomic message.
+     *
+     * @param onSuccess onSuccess callback to run for the async transaction that completed.
+     */
+    public void handleAsyncTransactionCompleted(Runnable onSuccess) {
+        if (onSuccess != null) {
+            pendingOnSuccessAsyncTransactionCallbacks.add(onSuccess);
+        }
+        realmChanged(false);
+    }
+
+    void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         changeListeners.addIfAbsent(listener);
     }
 
     /**
      * For internal use only.
-     * Sometimes we don't know when to unregister listeners (ex: {@link RealmBaseAdapter}). Using
+     * <p>
+     * Sometimes we don't know when to unregister listeners (e.g., {@code RealmBaseAdapter}). Using
      * a WeakReference the listener doesn't need to be explicitly unregistered.
      *
      * @param listener the change listener.
      */
-    void addChangeListenerAsWeakReference(RealmChangeListener listener) {
-        Iterator<WeakReference<RealmChangeListener>> iterator = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+    void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> listener) {
+        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iterator = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         boolean addListener = true;
         while (iterator.hasNext()) {
-            WeakReference<RealmChangeListener> weakRef = iterator.next();
-            RealmChangeListener weakListener = weakRef.get();
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iterator.next();
+            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
             // Collect all listeners that are GC'ed
             if (weakListener == null) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             }
@@ -173,20 +199,21 @@ void addChangeListenerAsWeakReference(RealmChangeListener listener) {
             weakChangeListeners.removeAll(toRemoveList);
         }
         if (addListener) {
-            weakChangeListeners.add(new WeakReference<RealmChangeListener>(listener));
+            weakChangeListeners.add(new WeakReference<RealmChangeListener<? extends BaseRealm>>(listener));
         }
     }
 
-    void removeWeakChangeListener(RealmChangeListener listener) {
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
+    @SuppressWarnings("unused")
+    void removeWeakChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         for (int i = 0; i < weakChangeListeners.size(); i++) {
-            WeakReference<RealmChangeListener> weakRef = weakChangeListeners.get(i);
-            RealmChangeListener weakListener = weakRef.get();
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = weakChangeListeners.get(i);
+            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
 
             // Collect all listeners that are GC'ed or we need to remove
             if (weakListener == null || weakListener == listener) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             }
@@ -195,7 +222,7 @@ void removeWeakChangeListener(RealmChangeListener listener) {
         weakChangeListeners.removeAll(toRemoveList);
     }
 
-    void removeChangeListener(RealmChangeListener listener) {
+    void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         changeListeners.remove(listener);
     }
 
@@ -203,26 +230,29 @@ void removeAllChangeListeners() {
         changeListeners.clear();
     }
 
+    /**
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
     private void notifyGlobalListeners() {
         // notify strong reference listener
-        Iterator<RealmChangeListener> iteratorStrongListeners = changeListeners.iterator();
-        while (iteratorStrongListeners.hasNext() && !realm.isClosed()) { // every callback could close the realm
+        Iterator<RealmChangeListener<? extends BaseRealm>> iteratorStrongListeners = changeListeners.iterator();
+        while (!realm.isClosed() && iteratorStrongListeners.hasNext()) { // every callback could close the realm
             RealmChangeListener listener = iteratorStrongListeners.next();
-            listener.onChange();
+            listener.onChange(realm);
         }
         // notify weak reference listener (internals)
-        Iterator<WeakReference<RealmChangeListener>> iteratorWeakListeners = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener>> toRemoveList = null;
-        while (iteratorWeakListeners.hasNext() && !realm.isClosed()) {
-            WeakReference<RealmChangeListener> weakRef = iteratorWeakListeners.next();
+        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iteratorWeakListeners = weakChangeListeners.iterator();
+        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
+        while (!realm.isClosed() && iteratorWeakListeners.hasNext()) {
+            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iteratorWeakListeners.next();
             RealmChangeListener listener = weakRef.get();
             if (listener == null) {
                 if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener>>(weakChangeListeners.size());
+                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
                 }
                 toRemoveList.add(weakRef);
             } else {
-                listener.onChange();
+                listener.onChange(realm);
             }
         }
         if (toRemoveList != null) {
@@ -235,13 +265,13 @@ private void updateAsyncEmptyRealmObject() {
         while (iterator.hasNext()) {
             Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
             if (next.getKey().get() != null) {
-                Realm.asyncQueryExecutor
-                        .submit(QueryUpdateTask.newBuilder()
+                Realm.asyncTaskExecutor
+                        .submitQueryUpdate(QueryUpdateTask.newBuilder()
                                 .realmConfiguration(realm.getConfiguration())
                                 .addObject(next.getKey(),
                                         next.getValue().handoverQueryPointer(),
                                         next.getValue().getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT)
                                 .build());
 
             } else {
@@ -250,53 +280,74 @@ private void updateAsyncEmptyRealmObject() {
         }
     }
 
-    void notifyAllListeners() {
-        notifyGlobalListeners();
-        notifyTypeBasedListeners();
+    /**
+     * This method calls all registered listeners for Realm, RealmResults and RealmObjects, and callbacks for async
+     * transactions.
+     *
+     * PREREQUISITE: Only call this method after all objects are up to date. This means:
+     * - `advance_read` was called on the Realm.
+     * - `RealmResults.syncIfNeeded()` was called when collecting RealmResults listeners.
+     *
+     * @param realmResultsToBeNotified list of all RealmResults listeners that can be notified.
+     */
+    void notifyAllListeners(List<RealmResults<? extends RealmModel>> realmResultsToBeNotified) {
 
-        // empty async RealmObject shouldn't block the realm to advance
-        // they're empty so no risk for running into a corrupt state
-        // where the pointer (Row) is using one version of a Realm, whereas the
-        // current Realm is advancing to a newer version (they're empty anyway)
+        // Notify all RealmResults (async and synchronous).
+        for (Iterator<RealmResults<? extends RealmModel>> it = realmResultsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
+            RealmResults<? extends RealmModel> realmResults = it.next();
+            realmResults.notifyChangeListeners(false);
+        }
+
+        // Notify all loaded RealmObjects
+        notifyRealmObjectCallbacks();
+
+        // Re-run any async single objects that are still not loaded.
+        // TODO: Why is this here? This was not called in `completedAsyncQueriesUpdate()`. Problem?
         if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
             updateAsyncEmptyRealmObject();
         }
-    }
 
-    private void notifyTypeBasedListeners() {
-        notifyAsyncRealmResultsCallbacks();
-        notifySyncRealmResultsCallbacks();
-        notifyRealmObjectCallbacks();
+        // Notify any completed async transactions
+        notifyAsyncTransactionCallbacks();
+
+        // Trigger global listeners last.
+        // Note that NotificationTest.callingOrdersOfListeners will fail if orders change.
+        notifyGlobalListeners();
     }
 
-    private void notifyAsyncRealmResultsCallbacks() {
-        notifyRealmResultsCallbacks(asyncRealmResults.keySet().iterator());
+    private void collectAsyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
+        collectRealmResultsCallbacks(asyncRealmResults.keySet().iterator(), resultsToBeNotified);
     }
 
-    private void notifySyncRealmResultsCallbacks() {
-        notifyRealmResultsCallbacks(syncRealmResults.keySet().iterator());
+    private void collectSyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
+        collectRealmResultsCallbacks(syncRealmResults.keySet().iterator(), resultsToBeNotified);
     }
 
-    private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator) {
-        List<RealmResults<? extends RealmModel>> resultsToBeNotified =
-                new ArrayList<RealmResults<? extends RealmModel>>();
+
+    private void collectRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator,
+                                              List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
         while (iterator.hasNext()) {
             WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
             RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 iterator.remove();
             } else {
-                // It should be legal to modify asyncRealmResults and syncRealmResults in the listener
-                resultsToBeNotified.add(realmResults);
+                // Sync the RealmResult so it is completely up to date.
+                // This is a prerequisite to calling the listener, so when the listener is finally triggered, all
+                // RealmResults will be up to date.
+                // Local commits can accidentially cause async RealmResults to be notified, so we only want to
+                // include those that are actually done loading.
+                if (realmResults.isLoaded()) {
+                    realmResults.syncIfNeeded();
+                    resultsToBeNotified.add(realmResults);
+                }
             }
         }
-
-        for (Iterator<RealmResults<? extends RealmModel>> it = resultsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
-            RealmResults<? extends RealmModel> realmResults = it.next();
-            realmResults.notifyChangeListeners();
-        }
     }
 
+    /**
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
     private void notifyRealmObjectCallbacks() {
         List<RealmObjectProxy> objectsToBeNotified = new ArrayList<RealmObjectProxy>();
         Iterator<WeakReference<RealmObjectProxy>> iterator = realmObjects.keySet().iterator();
@@ -316,7 +367,7 @@ private void notifyRealmObjectCallbacks() {
             }
         }
 
-        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
             RealmObjectProxy realmObject = it.next();
             realmObject.realmGet$proxyState().notifyChangeListeners$realm();
         }
@@ -326,7 +377,7 @@ private void updateAsyncQueries() {
         if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
             // try to cancel any pending update since we're submitting a new one anyway
             updateAsyncQueriesTask.cancel(true);
-            Realm.asyncQueryExecutor.getQueue().remove(updateAsyncQueriesTask);
+            Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
             RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates");
         }
         RealmLog.d("REALM_CHANGED realm:"+ HandlerController.this + " updating async queries, total: " + asyncRealmResults.size());
@@ -361,21 +412,39 @@ private void updateAsyncQueries() {
         }
         if (realmResultsQueryStep != null) {
             QueryUpdateTask queryUpdateTask = realmResultsQueryStep
-                    .sendToHandler(realm.handler, COMPLETED_UPDATE_ASYNC_QUERIES)
+                    .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES)
                     .build();
-            updateAsyncQueriesTask = Realm.asyncQueryExecutor.submit(queryUpdateTask);
+            updateAsyncQueriesTask = Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
         }
     }
 
-    private void realmChanged() {
+    private void realmChanged(boolean localCommit) {
+        RealmLog.d((localCommit ? "LOCAL_COMMIT" : "REALM_CHANGED") + " : realm:" + HandlerController.this);
         deleteWeakReferences();
-        if (threadContainsAsyncQueries()) {
-            updateAsyncQueries();
+        boolean threadContainsAsyncQueries = threadContainsAsyncQueries();
+
+        // Mixing local transactions and async queries has unavoidable race conditions
+        if (localCommit && threadContainsAsyncQueries) {
+            RealmLog.w("Mixing asynchronous queries with local writes should be avoided. " +
+                    "Realm will convert any async queries to synchronous in order to remain consistent. Use " +
+                    "asynchronous writes instead. You can read more here: " +
+                    "https://realm.io/docs/java/latest/#asynchronous-transactions");
+        }
 
+        if (!localCommit && threadContainsAsyncQueries) {
+            // For changes from other threads, swallow the change and re-run async queries first.
+            updateAsyncQueries();
         } else {
-            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " no async queries, advance_read");
+            // Following cases handled by this:
+            // localCommit && threadContainsAsyncQueries (this is the case the warning above is about)
+            // localCommit && !threadContainsAsyncQueries
+            // !localCommit && !threadContainsAsyncQueries
             realm.sharedGroupManager.advanceRead();
-            notifyAllListeners();
+
+            List<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>();
+            collectAsyncRealmResultsCallbacks(resultsToBeNotified);
+            collectSyncRealmResultsCallbacks(resultsToBeNotified);
+            notifyAllListeners(resultsToBeNotified);
         }
     }
 
@@ -400,7 +469,8 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                         // swap pointer
                         realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                         // notify callbacks
-                        realmResults.notifyChangeListeners();
+                        realmResults.syncIfNeeded();
+                        realmResults.notifyChangeListeners(false);
                     } else {
                         RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " ignoring result the RealmResults (is already loaded)");
                     }
@@ -425,10 +495,10 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                                 .add(weakRealmResults,
                                         query.handoverQueryPointer(),
                                         query.getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_RESULTS)
+                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS)
                                 .build();
 
-                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
 
                     } else {
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
@@ -450,7 +520,9 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
         SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
         int compare = callerVersionID.compareTo(result.versionID);
         if (compare > 0) {
-            // if the caller thread is advanced i.e it already sent a REALM_CHANGE that will update the queries
+            // if the caller thread is more advanced than the worker thread, it means it did a local commit.
+            // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
+            // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
             RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, Looper will updates queries");
 
         } else {
@@ -475,8 +547,10 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 }
             }
 
-            ArrayList<RealmResults<? extends RealmModel>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
-            // use updated TableViews pointers for the existing async RealmResults
+            // It's dangerous to notify the callback about new results before updating
+            // the pointers, because the callback may use another RealmResults not updated yet
+            // this is why we defer the notification until we're done updating all pointers.
+            ArrayList<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
             for (Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, Long> query : result.updatedTableViews.entrySet()) {
                 WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
                 RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
@@ -487,30 +561,36 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 } else {
                     // update the instance with the new pointer
                     realmResults.swapTableViewPointer(query.getValue());
-
-                    // it's dangerous to notify the callback about new results before updating
-                    // the pointers, because the callback may use another RealmResults not updated yet
-                    // this is why we defer the notification until we're done updating all pointers
-                    callbacksToNotify.add(realmResults);
+                    realmResults.syncIfNeeded();
+                    resultsToBeNotified.add(realmResults);
 
                     RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
                 }
             }
+            collectSyncRealmResultsCallbacks(resultsToBeNotified);
 
-            for (RealmResults<? extends RealmModel> query : callbacksToNotify) {
-                query.notifyChangeListeners();
-            }
-
-            // We need to notify the rest of listeners, since the original REALM_CHANGE
-            // was delayed/swallowed in order to be able to update async queries
-            notifyGlobalListeners();
-            notifySyncRealmResultsCallbacks();
-            notifyRealmObjectCallbacks();
+            // We need to notify all listeners, since the original REALM_CHANGE
+            // was delayed/swallowed in order to be able to update the async queries.
+            notifyAllListeners(resultsToBeNotified);
 
             updateAsyncQueriesTask = null;
         }
     }
 
+    /**
+     * Trigger onSuccess for all completed async transaction.
+     * <p>
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
+    private void notifyAsyncTransactionCallbacks() {
+        if (!pendingOnSuccessAsyncTransactionCallbacks.isEmpty()) {
+            for (Runnable callback : pendingOnSuccessAsyncTransactionCallbacks) {
+                callback.run();
+            }
+            pendingOnSuccessAsyncTransactionCallbacks.clear();
+        }
+    }
+
     private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
         Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
         if (updatedRowKey.size() > 0) {
@@ -527,7 +607,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
                         // cleanup a previously empty async RealmObject
                         emptyAsyncRealmObject.remove(realmObjectWeakReference);
-                        realmObjects.put(realmObjectWeakReference, null);
+                        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
                     }
                     proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
                     proxy.realmGet$proxyState().notifyChangeListeners$realm();
@@ -541,11 +621,15 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                         proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
+                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT " + proxy + "] , realm:" + HandlerController.this
                                 + " RealmObject is not loaded yet. Rerun the query.");
-                        RealmQuery<?> realmQuery = realmObjects.get(realmObjectWeakReference);
-                        if (realmQuery == null) { // this is a retry of an empty RealmObject
+                        Object value = realmObjects.get(realmObjectWeakReference);
+                        RealmQuery<? extends RealmModel> realmQuery;
+                        if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
                             realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
+
+                        } else {
+                            realmQuery = (RealmQuery<? extends RealmModel>) value;
                         }
 
                         QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
@@ -553,10 +637,10 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                                 .addObject(realmObjectWeakReference,
                                         realmQuery.handoverQueryPointer(),
                                         realmQuery.getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToHandler(realm.handler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT)
                                 .build();
 
-                        Realm.asyncQueryExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
                     }
                 } else {
                     // should not happen, since the the background thread position itself against the provided version
@@ -590,10 +674,10 @@ private boolean threadContainsAsyncQueries() {
     }
 
     /**
-     * Indicate the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}
-     * empty means no pointer to a valid Row. This will help to caller to decice when to rerun the query.
+     * Indicates the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}.
+     * Empty means no pointer to a valid Row. This will help caller to decide when to rerun the query.
      *
-     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject} {@code false} otherwise.
+     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject}, {@code false} otherwise.
      */
     boolean threadContainsAsyncEmptyRealmObject() {
         boolean isEmpty = true;
@@ -637,9 +721,17 @@ void addToRealmResults(RealmResults<? extends RealmModel> realmResults) {
         syncRealmResults.add(realmResultsWeakReference);
     }
 
-    // add to the list of RealmObject to be notified after a commit
-    <E extends RealmModel> void addToRealmObjects(E realmobject) {
-        realmObjects.put(new WeakReference<RealmObjectProxy>((RealmObjectProxy) realmobject), null);
+    // Add to the list of RealmObject to be notified after a commit.
+    // This method will check if the object exists in the list. It won't add the same object multiple times
+    <E extends RealmObjectProxy> void addToRealmObjects(E realmObject) {
+        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
+            if (ref.get() == realmObject) {
+                return;
+            }
+        }
+        final WeakReference<RealmObjectProxy> realmObjectWeakReference =
+                new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
+        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
     }
 
     <E extends RealmObjectProxy> WeakReference<RealmObjectProxy> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmModel> realmQuery) {
@@ -657,11 +749,11 @@ void addToEmptyAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakR
     }
 
     /**
-     * Refreshes all synchronous RealmResults by calling `sync_if_needed` on them. This will cause any backing queries
-     * to be rerun and any deleted objects will be removed from the TableView.
-     *
+     * Refreshes all synchronous RealmResults by calling {@code sync_if_needed} on them. This will cause any backing queries
+     * to rerun and any deleted objects will be removed from the TableView.
+     * <p>
      * WARNING: This will _NOT_ refresh TableViews created from async queries.
-     *
+     * <p>
      * Note this will _not_ notify any registered listeners.
      */
     public void refreshSynchronousTableViews() {
@@ -677,10 +769,11 @@ public void refreshSynchronousTableViews() {
         }
     }
 
+    /**
+     * Toggles the auto refresh flag. Will throw an {@link IllegalStateException} if auto-refresh is not available.
+     */
     public void setAutoRefresh(boolean autoRefresh) {
-        if (autoRefresh && Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot enabled autorefresh on a non-looper thread.");
-        }
+        checkCanBeAutoRefreshed();
         this.autoRefresh = autoRefresh;
     }
 
@@ -689,11 +782,35 @@ public boolean isAutoRefreshEnabled() {
     }
 
     /**
-     * Notify the current thread that the Realm has changed. This will also trigger change listener asynchronously.
+     * Validates that the current thread can enable auto refresh. An {@link IllegalStateException} will be thrown if that
+     * is not the case.
      */
-    public void notifyCurrentThreadRealmChanged() {
-        if (realm != null) {
-            realm.handler.sendEmptyMessage(HandlerController.REALM_CHANGED);
+    public void checkCanBeAutoRefreshed() {
+        if (Looper.myLooper() == null) {
+            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
+        }
+        if (isIntentServiceThread()) {
+            throw new IllegalStateException("Cannot set auto-refresh in an IntentService thread.");
         }
     }
+
+    /**
+     * Checks if the auto-refresh feature is available on this thread. Calling {@link #setAutoRefresh(boolean)}
+     * will throw if this method return {@code false}.
+     */
+    public boolean isAutoRefreshAvailable() {
+        if (Looper.myLooper() == null || isIntentServiceThread()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private static boolean isIntentServiceThread() {
+        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
+        // so use the thread name as a heuristic:
+        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
+        String threadName = Thread.currentThread().getName();
+        return threadName != null && threadName.startsWith("IntentService[");
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 6d52a81d53..29376bff76 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -47,10 +47,10 @@
      *
      * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
      *                  and String are supported.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or it has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName);
 
@@ -60,10 +60,10 @@
      * @param fieldName the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date,
      *                  and String are supported.
      * @param sortOrder the direction to sort by.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName, Sort sortOrder);
 
@@ -76,10 +76,10 @@
      * @param fieldName2 second field name. Only fields of type boolean, short, int, long, float,
      *                   double, Date, and String are supported.
      * @param sortOrder2 sort order for second field.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2);
 
@@ -89,10 +89,10 @@
      * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int, long, float,
      *                   double, Date, and String are supported.
      * @param sortOrders the directions to sort by.
-     * @return a sorted view of the collection.
+     * @return a new sorted {@link RealmResults} will be created and returned. The original collection stays unchanged.
      * @throws java.lang.IllegalArgumentException if a field name does not exist or has an invalid type.
      * @throws java.lang.IllegalStateException if the Realm is closed, called on the wrong thread or the collection is
-     *                                         an un-managed collection.
+     *                                         an unmanaged collection.
      */
     RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders);
 
@@ -102,7 +102,7 @@
      * @param location the array index identifying the object to be removed.
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     void deleteFromRealm(int location);
 
@@ -111,7 +111,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called on the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteFirstFromRealm();
 
@@ -120,7 +120,7 @@
      *
      * @return {@code true} if an object was deleted, {@code false} otherwise.
      * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
-     * @throws UnsupportedOperationException if the collection is un-managed.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteLastFromRealm();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 94f094e52a..96049817d8 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -30,22 +30,28 @@
  * This implements {@code RealmObjectProxy} interface, to eliminate copying logic between
  * {@link RealmObject} and {@link DynamicRealmObject}.
  */
-public final class ProxyState {
+public final class ProxyState<E extends RealmModel> {
+    private E model;
     private String className;
     private Class<? extends RealmModel> clazzName;
 
     private Row row;
     private BaseRealm realm;
 
-    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
     private Future<Long> pendingQuery;
     private boolean isCompleted = false;
     protected long currentTableVersion = -1;
 
     public ProxyState() {}
 
-    public ProxyState(Class<? extends RealmModel> clazzName) {
+    public ProxyState(E model) {
+        this.model = model;
+    }
+
+    public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         this.clazzName = clazzName;
+        this.model = model;
     }
 
     /**
@@ -114,7 +120,7 @@ public ProxyState(Class<? extends RealmModel> clazzName) {
         return true;
     }
 
-    public List<RealmChangeListener> getListeners$realm() {
+    public List<RealmChangeListener<E>> getListeners$realm() {
         return listeners;
     }
 
@@ -156,7 +162,7 @@ public ProxyState(Class<? extends RealmModel> clazzName) {
 
             if (notify) {
                 for (RealmChangeListener listener : listeners) {
-                    listener.onChange();
+                    listener.onChange(model);
                 }
             }
         }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index f2e8fc070d..d9dbc1c1a9 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -17,7 +17,7 @@
 package io.realm;
 
 import android.annotation.TargetApi;
-import android.content.Context;
+import android.app.IntentService;
 import android.os.Build;
 import android.os.Looper;
 import android.util.JsonReader;
@@ -34,13 +34,18 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.concurrent.Future;
 
+import io.realm.RealmObject;
+import io.realm.RealmQuery;
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
@@ -49,7 +54,6 @@
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
 import io.realm.internal.Util;
 import io.realm.internal.log.RealmLog;
 import rx.Observable;
@@ -57,7 +61,7 @@
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
  * instances of your RealmObjects. Objects within a Realm can be queried and read at any time. Creating, modifying, and
- * deleting objects must be done while inside a transaction. See {@link #beginTransaction()}
+ * deleting objects must be done while inside a transaction. See {@link #executeTransaction(Transaction)}
  * <p>
  * The transactions ensure that multiple instances (on multiple threads) can access the same objects in a consistent
  * state with full ACID guarantees.
@@ -71,10 +75,10 @@
  * Realm and should be considered a lightweight operation.
  * <p>
  * For the UI thread this means that opening and closing Realms should occur in either onCreate/onDestroy or
- *  onStart/onStop.
+ * onStart/onStop.
  * <p>
  * Realm instances coordinate their state across threads using the {@link android.os.Handler} mechanism. This also means
- * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #refresh()}
+ * that Realm instances on threads without a {@link android.os.Looper} cannot receive updates unless {@link #waitForChange()}
  * is manually called.
  * <p>
  * A standard pattern for working with Realm in Android activities can be seen below:
@@ -131,53 +135,21 @@
      * The constructor is private to enforce the use of the static one.
      *
      * @param configuration the {@link RealmConfiguration} used to open the Realm.
-     * @param autoRefresh {@code true} if Realm should auto-refresh. {@code false} otherwise.
      * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
      */
-    Realm(RealmConfiguration configuration, boolean autoRefresh) {
-        super(configuration, autoRefresh);
+    Realm(RealmConfiguration configuration) {
+        super(configuration);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<Realm> asObservable() {
         return configuration.getRxFactory().from(this);
     }
 
-    @Override
-    protected void finalize() throws Throwable {
-        if (sharedGroupManager != null && sharedGroupManager.isOpen()) {
-            RealmLog.w("Remember to call close() on all Realm instances. " +
-                            "Realm " + configuration.getPath() + " is being finalized without being closed, " +
-                            "this can lead to running out of native memory."
-            );
-        }
-        super.finalize();
-    }
-
-    /**
-     * Realm static constructor for the default Realm file {@value io.realm.RealmConfiguration#DEFAULT_REALM_NAME}.
-     * This is equivalent to calling {@code Realm.getInstance(new RealmConfiguration(getContext()).build())}.
-     *
-     * This constructor is only provided for convenience. It is recommended to use
-     * {@link #getInstance(RealmConfiguration)} or {@link #getDefaultInstance()}.
-     *
-     * @param context a non-null Android {@link android.content.Context}
-     * @return an instance of the Realm class.
-     * @throws java.lang.IllegalArgumentException if no {@link Context} is provided.
-     * @throws RealmMigrationNeededException if the RealmObject classes no longer match the underlying Realm and it must
-     *         be migrated.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
-     * @deprecated use {@link #getDefaultInstance()} or {@link #getInstance(RealmConfiguration)} instead.
-     */
-    public static Realm getInstance(Context context) {
-        return Realm.getInstance(new RealmConfiguration.Builder(context)
-                .name(DEFAULT_REALM_NAME)
-                .build());
-    }
-
     /**
      * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
      * by {@link #setDefaultConfiguration(RealmConfiguration)}
@@ -239,7 +211,7 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null} value, the {@link BaseRealm#schema#columnIndices} will be
+     * @param columnIndices if this is not  {@code null}, the {@link BaseRealm#schema#columnIndices} will be
      *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
      *                      the Realm file.
      * @return a {@link Realm} instance.
@@ -265,8 +237,7 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices colu
     }
 
     static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices columnIndices) {
-        boolean autoRefresh = Looper.myLooper() != null;
-        Realm realm = new Realm(configuration, autoRefresh);
+        Realm realm = new Realm(configuration);
         long currentVersion = realm.getVersion();
         long requiredVersion = configuration.getSchemaVersion();
         if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && columnIndices == null) {
@@ -325,7 +296,7 @@ private static void initializeRealm(Realm realm) {
             }
         } finally {
             if (commitNeeded) {
-                realm.commitTransaction(false, null);
+                realm.commitTransaction(false, true, null);
             } else {
                 realm.cancelTransaction();
             }
@@ -334,8 +305,9 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the RealmObject
+     * <p>
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
+     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject}
      * field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
@@ -386,7 +358,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -441,7 +413,7 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with a null value will map to the default value for the data type in Realm and unknown properties
+     * JSON properties with {@code null} value will map to the default value for the data type in Realm and unknown properties
      * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
      * will be set to the default value for that type.
      *
@@ -509,13 +481,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
-     * @return created object or null if no json data was provided.
+     * @return created object or {@code null} if no JSON data was provided.
      * @throws RealmException if the mapping from JSON fails.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
@@ -552,7 +524,6 @@ private static void initializeRealm(Realm realm) {
         checkHasPrimaryKey(clazz);
         try {
             E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
-            handlerController.addToRealmObjects(realmObject);
             return realmObject;
         } catch (JSONException e) {
             throw new RealmException("Could not map JSON", e);
@@ -561,13 +532,13 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if mapping to json failed.
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
@@ -618,15 +589,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with a null value will map to the default value for the data type in Realm and unknown properties will
+     * properties with {@code null} value will map to the default value for the data type in Realm and unknown properties will
      * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
      * be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
-     * @return created object or null if json string was empty or null.
+     * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if the mapping from JSON failed.
-     * @throws IOException if something was wrong with the input stream.
+     * @throws IOException if something went wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
@@ -707,9 +678,9 @@ private Scanner getFullStringScanner(InputStream in) {
     /**
      * Instantiates and adds a new object to the Realm.
      *
-     * @param clazz the Class of the object to create
-     * @return the new object
-     * @throws RealmException if an object could not be created
+     * @param clazz the Class of the object to create.
+     * @return the new object.
+     * @throws RealmException if an object cannot be created.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
@@ -720,7 +691,7 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Instantiates and adds a new object to the Realm with the primary key value already set.
-     *
+     * <p>
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
      *
@@ -728,7 +699,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException If the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model clazz does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expected value.
      */
@@ -738,16 +709,12 @@ private Scanner getFullStringScanner(InputStream in) {
         return get(clazz, rowIndex);
     }
 
-    void remove(Class<? extends RealmModel> clazz, long objectIndex) {
-        getTable(clazz).moveLastOver(objectIndex);
-    }
-
     /**
      * Copies a RealmObject to the Realm instance and returns the copy. Any further changes to the original RealmObject
      * will not be reflected in the Realm copy. This is a deep copy, so all referenced objects will be copied. Objects
      * already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in this and child objects will be
      * set to their default value if not provided.
      *
      * @param object the {@link io.realm.RealmObject} to copy to the Realm.
@@ -757,15 +724,15 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
      */
     public <E extends RealmModel> E copyToRealm(E object) {
         checkNotNullObject(object);
-        return copyOrUpdate(object, false);
+        return copyOrUpdate(object, false, new HashMap<RealmModel, RealmObjectProxy>());
     }
 
     /**
      * Updates an existing RealmObject that is identified by the same {@link io.realm.annotations.PrimaryKey} or creates
-     * a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects will be
+     * a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects will be
      * either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the object and child objects will be
      * set to their default value if not provided.
      *
      * @param object {@link io.realm.RealmObject} to copy or update.
@@ -777,15 +744,15 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object.getClass());
-        return copyOrUpdate(object, true);
+        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>());
     }
 
     /**
      * Copies a collection of RealmObjects to the Realm instance and returns their copy. Any further changes to the
-     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy, so all referenced objects
+     * original RealmObjects will not be reflected in the Realm copies. This is a deep copy i.e., all referenced objects
      * will be copied. Objects already in this Realm will be ignored.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects the RealmObjects to copy to the Realm.
@@ -797,21 +764,159 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
         if (objects == null) {
             return new ArrayList<E>();
         }
-
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
         ArrayList<E> realmObjects = new ArrayList<E>();
         for (E object : objects) {
-            realmObjects.add(copyToRealm(object));
+            checkNotNullObject(object);
+            realmObjects.add(copyOrUpdate(object, false, cache));
         }
 
         return realmObjects;
     }
 
+    /**
+     * Insert a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want these checks and the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param objects RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @see #copyToRealm(Iterable)
+     */
+    public void insert(Collection<? extends RealmModel> objects) {
+        checkIfValidAndInTransaction();
+        if (objects == null) {
+            throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
+        }
+        if (objects.isEmpty()) {
+            return;
+        }
+        configuration.getSchemaMediator().insert(this, objects);
+    }
+
+    /**
+     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want these checks and the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param object RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
+     * inserted or if a primary key value already exists in the Realm.
+     * @see #copyToRealm(RealmModel)
+     */
+    public void insert(RealmModel object) {
+        checkIfValidAndInTransaction();
+        if (object == null) {
+            throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
+        }
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        configuration.getSchemaMediator().insert(this, object, cache);
+    }
+
+    /**
+     * Insert or update a list of unmanaged RealmObjects. This is generally faster than {@link #copyToRealmOrUpdate(Iterable)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want these checks and the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param objects RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
+     * inserted or if a primary key value already exists in the Realm.
+     *
+     * @see #copyToRealmOrUpdate(Iterable)
+     */
+    public void insertOrUpdate(Collection<? extends RealmModel> objects) {
+        checkIfValidAndInTransaction();
+        if (objects == null) {
+            throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
+        }
+        if (objects.isEmpty()) {
+            return;
+        }
+        configuration.getSchemaMediator().insertOrUpdate(this, objects);
+    }
+
+    /**
+     * Insert or update an unmanaged RealmObject. This is generally faster than {@link #copyToRealmOrUpdate(RealmModel)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want these checks and the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param object RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @see #copyToRealmOrUpdate(RealmModel)
+     */
+    public void insertOrUpdate(RealmModel object) {
+        checkIfValidAndInTransaction();
+        if (object == null) {
+            throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
+        }
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        configuration.getSchemaMediator().insertOrUpdate(this, object, cache);
+    }
+
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
-     * creates a new copy if no existing object could be found. This is a deep copy or update, so all referenced objects
+     * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects
      * will be either copied or updated.
-     *
-     * Please note, copying an object will copy all field values. All unset fields in this and child objects will be
+     * <p>
+     * Please note, copying an object will copy all field values. Any unset field in the objects and child objects will be
      * set to their default value if not provided.
      *
      * @param objects a list of objects to update or copy into Realm.
@@ -824,26 +929,28 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
             return new ArrayList<E>(0);
         }
 
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
         ArrayList<E> realmObjects = new ArrayList<E>();
         for (E object : objects) {
-            realmObjects.add(copyToRealmOrUpdate(object));
+            checkNotNullObject(object);
+            realmObjects.add(copyOrUpdate(object, true, cache));
         }
 
         return realmObjects;
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(RealmModel)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects,
      * and can potentially override changes made by other threads.
      *
-     * @param realmObjects RealmObjects to copy
+     * @param realmObjects RealmObjects to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of managed RealmObjects.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -854,12 +961,12 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     }
 
     /**
-     * Makes a standalone in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
+     * Makes an unmanaged in-memory copy of already persisted RealmObjects. This is a deep copy that will copy all
      * referenced objects up to the defined depth.
-     *
-     * The copied objects are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied objects are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using {@link #copyToRealmOrUpdate(Iterable)},
      * but all fields will be overridden, not just those that were changed. This includes references to other objects
      * even though they might be {@code null} due to {@code maxDepth} being reached. This can also potentially override
@@ -880,28 +987,28 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
             return new ArrayList<E>(0);
         }
 
-        ArrayList<E> standaloneObjects = new ArrayList<E>();
+        ArrayList<E> unmanagedObjects = new ArrayList<E>();
         Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> listCache = new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>();
         for (E object : realmObjects) {
             checkValidObjectForDetach(object);
-            standaloneObjects.add(createDetachedCopy(object, maxDepth, listCache));
+            unmanagedObjects.add(createDetachedCopy(object, maxDepth, listCache));
         }
 
-        return standaloneObjects;
+        return unmanagedObjects;
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed.
      * This includes references to other objects, and can potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param <E> type of object.
      * @return an in-memory detached copy of the managed {@link RealmObject}.
      * @throws IllegalArgumentException if the RealmObject is no longer accessible or it is a {@link DynamicRealmObject}.
@@ -912,18 +1019,18 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
     }
 
     /**
-     * Makes a standalone in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
+     * Makes an unmanaged in-memory copy of an already persisted {@link RealmObject}. This is a deep copy that will copy
      * all referenced objects up to the defined depth.
-     *
-     * The copied object(s) are all detached from Realm so they will no longer be automatically updated. This means
+     * <p>
+     * The copied object(s) are all detached from Realm and they will no longer be automatically updated. This means
      * that the copied objects might contain data that are no longer consistent with other managed Realm objects.
-     *
+     * <p>
      * *WARNING*: Any changes to copied objects can be merged back into Realm using 
      * {@link #copyToRealmOrUpdate(RealmModel)}, but all fields will be overridden, not just those that were changed. 
      * This includes references to other objects even though they might be {@code null} due to {@code maxDepth} being 
      * reached. This can also potentially override changes made by other threads.
      *
-     * @param realmObject {@link RealmObject} to copy
+     * @param realmObject {@link RealmObject} to copy.
      * @param maxDepth limit of the deep copy. All references after this depth will be {@code null}. Starting depth is
      * {@code 0}.
      * @param <E> type of object.
@@ -938,10 +1045,6 @@ void remove(Class<? extends RealmModel> clazz, long objectIndex) {
         return createDetachedCopy(realmObject, maxDepth, new HashMap<RealmModel, RealmObjectProxy.CacheData<RealmModel>>());
     }
 
-    boolean contains(Class<? extends RealmModel> clazz) {
-        return configuration.getSchemaMediator().getModelClasses().contains(clazz);
-    }
-
     /**
      * Returns a typed RealmQuery, which can be used to query for specific objects of this type
      *
@@ -955,97 +1058,24 @@ boolean contains(Class<? extends RealmModel> clazz) {
     }
 
     /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAll()} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjects(Class<E> clazz) {
-        return where(clazz).findAll();
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName, sortOrder)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
-                                                                    Sort sortOrder) {
-        checkIfValid();
-        Table table = getTable(clazz);
-        long columnIndex = schema.columnIndices.getColumnIndex(clazz, fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        TableView tableView = table.getSortedView(columnIndex, sortOrder);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                                    Sort sortOrder1, String fieldName2,
-                                                                    Sort sortOrder2) {
-        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1,
-                sortOrder2});
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldName1, sortOrder1, fieldName2, sortOrder2, fieldName3, sortOrder3)}
-     * instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
-                                                                    Sort sortOrder1,
-                                                                    String fieldName2, Sort sortOrder2,
-                                                                    String fieldName3, Sort sortOrder3) {
-        return allObjectsSorted(clazz, new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).findAllSorted(fieldNames[], sortOrders[])} instead.
-     */
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public <E extends RealmModel> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
-                                                                    Sort sortOrders[]) {
-        checkAllObjectsSortedParameters(fieldNames, sortOrders);
-        Table table = this.getTable(clazz);
-
-        TableView tableView = doMultiFieldSort(fieldNames, sortOrders, table);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinct(fieldName)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> distinct(Class<E> clazz, String fieldName) {
-        checkIfValid();
-        Table table = schema.getTable(clazz);
-        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, table);
-        TableView tableView = table.getDistinctView(columnIndex);
-        return RealmResults.createFromTableOrView(this, tableView, clazz);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinctAsync(fieldName)} instead.
-     */
-    @Deprecated
-    public <E extends RealmModel> RealmResults<E> distinctAsync(Class<E> clazz, String fieldName) {
-        checkIfValid();
-        return where(clazz).distinctAsync(fieldName);
-    }
-
-    /**
-     * DEPRECATED: Use {@code realm.where(clazz).distinct(firstFieldName, remainingFieldNames)} instead.
+     * Adds a change listener to the Realm.
+     * <p>
+     * The listeners will be executed on every loop of a Handler thread if
+     * the current thread or other threads committed changes to the Realm.
+     * <p>
+     * Realm instances are per thread singletons and cached, so listeners should be
+     * removed manually even if calling {@link #close()}. Otherwise there is a
+     * risk of memory leaks.
+     *
+     * @param listener the change listener.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper or {@link IntentService} thread.
+     * @see io.realm.RealmChangeListener
+     * @see #removeChangeListener(RealmChangeListener)
+     * @see #removeAllChangeListeners()
      */
-    @Deprecated
-    public <E extends RealmObject> RealmResults<E> distinct(Class<E> clazz, String firstFieldName, String... remainingFieldNames) {
-        checkIfValid();
-        return where(clazz).distinct(firstFieldName, remainingFieldNames);
+    public void addChangeListener(RealmChangeListener<Realm> listener) {
+        super.addListener(listener);
     }
 
     /**
@@ -1079,106 +1109,8 @@ public void executeTransaction(Transaction transaction) {
      * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @param callback optional, to receive the result of this query.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
-     *         another thread.
-     * @deprecated replaced by {@link #executeTransactionAsync(Transaction)},
-     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess)},
-     * {@link #executeTransactionAsync(Transaction, io.realm.Realm.Transaction.OnError)} and
-     * {@link #executeTransactionAsync(Transaction, Transaction.OnSuccess, Transaction.OnError)}.
-     */
-    @Deprecated
-    public RealmAsyncTask executeTransaction(final Transaction transaction, final Transaction.Callback callback) {
-        checkIfValid();
-        if (transaction == null) {
-            throw new IllegalArgumentException("Transaction should not be null");
-        }
-
-        // If the user provided a Callback then we make sure, the current Realm has a Handler
-        // we can use to deliver the result
-        if (callback != null && handler == null) {
-            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
-                    " and you provided a callback, we need a Handler to invoke your callback");
-        }
-
-        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
-        // to perform the transaction
-        final RealmConfiguration realmConfiguration = getConfiguration();
-
-        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
-            @Override
-            public void run() {
-                if (Thread.currentThread().isInterrupted()) {
-                    return;
-                }
-
-                boolean transactionCommitted = false;
-                final Exception[] exception = new Exception[1];
-                final Realm bgRealm = Realm.getInstance(realmConfiguration);
-                bgRealm.beginTransaction();
-                try {
-                    transaction.execute(bgRealm);
-
-                    if (!Thread.currentThread().isInterrupted()) {
-                        bgRealm.commitTransaction(false, new Runnable() {
-                            @Override
-                            public void run() {
-                                // The bgRealm needs to be closed before post event to caller's handler to avoid
-                                // concurrency problem. eg.: User wants to delete Realm in the callbacks.
-                                // This will close Realm before sending REALM_CHANGED.
-                                bgRealm.close();
-                            }
-                        });
-                        transactionCommitted = true;
-                    }
-                } catch (final Exception e) {
-                    exception[0] = e;
-                } finally {
-                    if (!bgRealm.isClosed()) {
-                        if (bgRealm.isInTransaction()) {
-                            bgRealm.cancelTransaction();
-                        } else if (exception[0] != null) {
-                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
-                        }
-                        bgRealm.close();
-                    }
-
-                    // Send response as the final step to ensure the bg thread quit before others get the response!
-                    if (callback != null
-                            && handler != null
-                            && !Thread.currentThread().isInterrupted()
-                            && handler.getLooper().getThread().isAlive()) {
-                        if (transactionCommitted) {
-                            handler.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    callback.onSuccess();
-                                }
-                            });
-                        } else if (exception[0] != null) {
-                            // transaction has not been canceled by there is a exception during transaction.
-                            handler.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    callback.onError(exception[0]);
-                                }
-                            });
-                        }
-                    }
-                }
-            }
-        });
-
-        return new RealmAsyncTask(pendingQuery);
-    }
-
-    /**
-     * Similar to {@link #executeTransaction(Transaction)} but runs asynchronously on a worker thread.
-     *
-     * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @return a {@link RealmAsyncTask} representing a cancellable task.
-     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
+     * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the Realm is opened from
      *                                  another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
@@ -1206,7 +1138,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * Similar to {@link #executeTransactionAsync(Transaction)}, but also accepts an OnError callback.
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1224,7 +1156,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      *
      * @param transaction {@link io.realm.Realm.Transaction} to execute.
      * @param onSuccess callback invoked when the transaction succeeds.
-     * @param onError callback invoked when the transaction failed.
+     * @param onError callback invoked when the transaction fails.
      * @return a {@link RealmAsyncTask} representing a cancellable task.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
@@ -1247,7 +1179,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
 
-        final Future<?> pendingQuery = asyncQueryExecutor.submit(new Runnable() {
+        final Future<?> pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() {
             @Override
             public void run() {
                 if (Thread.currentThread().isInterrupted()) {
@@ -1262,7 +1194,7 @@ public void run() {
                     transaction.execute(bgRealm);
 
                     if (!Thread.currentThread().isInterrupted()) {
-                        bgRealm.commitTransaction(false, new Runnable() {
+                        bgRealm.commitAsyncTransaction(new Runnable() {
                             @Override
                             public void run() {
                                 // The bgRealm needs to be closed before post event to caller's handler to avoid
@@ -1290,15 +1222,23 @@ public void run() {
                     if (handler != null
                             && !Thread.currentThread().isInterrupted()
                             && handler.getLooper().getThread().isAlive()) {
-                        if (onSuccess != null && transactionCommitted) {
+
+                        if (transactionCommitted) {
+                            // This will be treated like a special REALM_CHANGED event
                             handler.post(new Runnable() {
                                 @Override
                                 public void run() {
-                                    onSuccess.onSuccess();
+                                    handlerController.handleAsyncTransactionCompleted(onSuccess != null ? new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            onSuccess.onSuccess();
+                                        }
+                                    } : null);
                                 }
                             });
                         }
 
+                        // Send errors directly to the looper, so they don't get intercepted by the HandlerController.
                         if (backgroundException != null) {
                             if (onError != null) {
                                 handler.post(new Runnable() {
@@ -1322,6 +1262,7 @@ public void run() {
                                 });
                             }
                         }
+
                     } else {
                         // Throw exception in the worker thread if the caller thread terminated
                         if (backgroundException != null) {
@@ -1341,21 +1282,7 @@ public void run() {
             }
         });
 
-        return new RealmAsyncTask(pendingQuery);
-    }
-
-
-    /**
-     * Removes all objects of the specified class.
-     *
-     * DEPRECATED: Use {@link #delete(Class)} instead.
-     *
-     * @param clazz the class which objects should be removed.
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public void clear(Class<? extends RealmModel> clazz) {
-        delete(clazz);
+        return new RealmAsyncTask(pendingTransaction);
     }
 
     /**
@@ -1371,9 +1298,9 @@ public void delete(Class<? extends RealmModel> clazz) {
 
 
     @SuppressWarnings("unchecked")
-    private <E extends RealmModel> E copyOrUpdate(E object, boolean update) {
+    private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         checkIfValid();
-        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmModel, RealmObjectProxy>());
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache);
     }
 
     private <E extends RealmModel> E createDetachedCopy(E object, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
@@ -1441,7 +1368,7 @@ public void migrationComplete() {
 
     /**
      * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
-     * The Realm must be unused and closed before calling this method.
+     * All Realm instances must be closed before calling this method.
      *
      * @param configuration a {@link RealmConfiguration}.
      * @return {@code false} if a file could not be deleted. The failing file will be logged.
@@ -1491,7 +1418,7 @@ Table getTable(Class<? extends RealmModel> clazz) {
      * Returns the default Realm module. This module contains all Realm classes in the current project, but not those
      * from library or project dependencies. Realm classes in these should be exposed using their own module.
      *
-     * @return the default Realm module or null if no default module exists.
+     * @return the default Realm module or {@code null} if no default module exists.
      * @throws RealmException if unable to create an instance of the module.
      * @see io.realm.RealmConfiguration.Builder#modules(Object, Object...)
      */
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index 3f6492f453..aa53c0ce8e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -49,7 +49,7 @@ public void cancel() {
         // first thread is attempting to purge the queue the attempt to purge
         // the queue fails and the cancelled object remain in the queue.
         // A better way to cancel objects with thread pools is to use the remove()
-        Realm.asyncQueryExecutor.getQueue().remove(pendingQuery);
+        Realm.asyncTaskExecutor.getQueue().remove(pendingQuery);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index f21b268d2f..824f7fb7ed 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -15,11 +15,16 @@
  */
 package io.realm;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.Map;
 
+import io.realm.exceptions.RealmIOException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.log.RealmLog;
 
@@ -36,6 +41,10 @@
         void onResult(int count);
     }
 
+    interface Callback0 {
+        void onCall();
+    }
+
     private static class RefAndCount {
         // The Realm instance in this thread.
         private final ThreadLocal<BaseRealm> localRealm = new ThreadLocal<BaseRealm>();
@@ -98,6 +107,8 @@ private RealmCache(RealmConfiguration config) {
             cache = new RealmCache(configuration);
             // The new cache should be added to the map later.
             isCacheInMap = false;
+
+            copyAssetFileIfNeeded(configuration);
         } else {
             // Throw the exception if validation failed.
             cache.validateConfiguration(configuration);
@@ -109,6 +120,7 @@ private RealmCache(RealmConfiguration config) {
             // Create a new local Realm instance
             BaseRealm realm;
 
+
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
                 realm = Realm.createInstance(configuration, cache.typedColumnIndices);
@@ -223,6 +235,19 @@ private void validateConfiguration(RealmConfiguration newConfiguration) {
         if (!Arrays.equals(configuration.getEncryptionKey(), newConfiguration.getEncryptionKey())) {
             throw new IllegalArgumentException(DIFFERENT_KEY_MESSAGE);
         } else {
+            // A common problem is that people are forgetting to override `equals` in their custom migration class.
+            // Try to detect this problem specifically so we can throw a better error message.
+            RealmMigration newMigration = newConfiguration.getMigration();
+            RealmMigration oldMigration = configuration.getMigration();
+            if (oldMigration != null 
+                && newMigration != null 
+                && oldMigration.getClass().equals(newMigration.getClass())
+                && !newMigration.equals(oldMigration)) {
+                throw new IllegalArgumentException("Configurations cannot be different if used to open the same file. " +
+                        "The most likely cause is that equals() and hashCode() are not overridden in the " +
+                        "migration class: " + newConfiguration.getMigration().getClass().getCanonicalName());
+            }
+
             throw new IllegalArgumentException("Configurations cannot be different if used to open the same file. " +
                     "\nCached configuration: \n" + configuration +
                     "\n\nNew configuration: \n" + newConfiguration);
@@ -248,4 +273,62 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         }
         callback.onResult(totalRefCount);
     }
+
+   /**
+     * Runs the callback function with synchronization on {@class RealmCache}.
+     *
+     * @param callback the callback will be executed.
+     */
+    static synchronized void invokeWithLock(Callback0 callback) {
+        callback.onCall();
+    }
+
+    /**
+     * Copies Realm database file from Android asset directory to the directory given in the {@link RealmConfiguration}.
+     * Copy is performed only at the first time when there is no Realm database file.
+     *
+     * @param configuration configuration object for Realm instance.
+     * @throws IOException if copying the file fails.
+     */
+    private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
+        if (configuration.hasAssetFile()) {
+            File realmFile = new File(configuration.getRealmFolder(), configuration.getRealmFileName());
+            if (realmFile.exists()) {
+                return;
+            }
+
+            InputStream inputStream = null;
+            FileOutputStream outputStream = null;
+            try {
+                inputStream = configuration.getAssetFile();
+                if (inputStream == null) {
+                    throw new RealmIOException("Invalid input stream to asset file.");
+                }
+
+                outputStream = new FileOutputStream(realmFile);
+                byte[] buf = new byte[4096];
+                int bytesRead;
+                while ((bytesRead = inputStream.read(buf)) > -1) {
+                    outputStream.write(buf, 0, bytesRead);
+                }
+            } catch (IOException e) {
+                throw new RealmIOException("Could not resolve the path to the Realm asset file.", e);
+            } finally {
+                if (inputStream != null) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException e) {
+                        // Ignore this exception because any significant errors should already have been handled
+                    }
+                }
+                if (outputStream != null) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException e) {
+                        throw new RealmIOException("Invalid output stream to " + realmFile.getPath(), e);
+                    }
+                }
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index 290910d634..2e8e7ff7c1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -22,26 +22,27 @@
  * <p>
  * When registered against a {@code Realm} you'll get notified when a Realm instance has been updated.
  * Register against a {@code RealmResults} or {@code RealmObject} to only get notified about changes to them.
- *
  * <p>
- * Realm instances on a thread without an {@link android.os.Looper} (almost all background threads) don't get updated
- * automatically, but have to call {@link Realm#refresh()} manually. This will in turn trigger the RealmChangeListener
- * for that background thread.
+ * Realm instances on a thread without an {@link android.os.Looper} cannot register a RealmChangeListener.
  * <p>
  * All {@link io.realm.RealmObject} and {@link io.realm.RealmResults} will automatically contain their new values when
- * the {@link #onChange()} method is called. Normally this means that it isn't necessary to query again for those
+ * the {@link #onChange(Object)} method is called. Normally this means that it isn't necessary to query again for those
  * objects, but just invalidate any UI elements that are using them. If there is a chance that a object has been been
  * deleted, it can be verified by using {@link RealmObject#isValid()}.
  *
+ * @param <T> The <a href="https://realm.io/docs/java/latest/#auto-updating-objects">live object</a> being returned
+ *         ({@link Realm}, {@link DynamicRealm}, {@link RealmObject}, {@link RealmResults}, {@link DynamicRealmObject}
+ *          or your model implementing {@link RealmModel})
+ *
  * @see Realm#addChangeListener(RealmChangeListener)
  * @see Realm#removeAllChangeListeners()
  * @see Realm#removeChangeListener(RealmChangeListener)
  */
-public interface RealmChangeListener {
+public interface RealmChangeListener<T> {
 
     /**
      * Called when a transaction is committed.
      */
-    void onChange();
+    void onChange(T element);
 
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 7c4328c8d8..6278272dc2 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -24,7 +24,7 @@
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
  * collections and the behavior that they will have in all implementations of {@code RealmCollection}s.
- *
+ * <p>
  * Realm collections are "live" views to the underlying data. This means that they automatically will be kept up to
  * date. As a consequence, using methods like {@link Collections#unmodifiableCollection(Collection)} will not prevent
  * a collection from being modified.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 89d723eeb7..4f7a8c031a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -17,8 +17,12 @@
 package io.realm;
 
 import android.content.Context;
+import android.text.TextUtils;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
@@ -38,21 +42,23 @@
 
 /**
  * A RealmConfiguration is used to setup a specific Realm instance.
- *
+ * <p>
  * Instances of a RealmConfiguration can only created by using the {@link io.realm.RealmConfiguration.Builder} and calling
  * its {@link io.realm.RealmConfiguration.Builder#build()} method.
- *
+ * <p>
  * A commonly used RealmConfiguration can easily be accessed by first saving it as
  * {@link Realm#setDefaultConfiguration(RealmConfiguration)} and then using {@link io.realm.Realm#getDefaultInstance()}.
- *
+ * <p>
  * A minimal configuration can be created using:
- *
+ * <p>
  * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
- *
+ * <p>
  * This will create a RealmConfiguration with the following properties.
- * - Realm file is called "default.realm"
- * - It is saved in Context.getFilesDir()
- * - It has its schema version set to 0.
+ * <ul>
+ * <li>Realm file is called "default.realm"</li>
+ * <li>It is saved in Context.getFilesDir()</li>
+ * <li>It has its schema version set to 0.</li>
+ * </ul>
  */
 public final class RealmConfiguration {
 
@@ -81,6 +87,7 @@
     private final File realmFolder;
     private final String realmFileName;
     private final String canonicalPath;
+    private final String assetFilePath;
     private final byte[] key;
     private final long schemaVersion;
     private final RealmMigration migration;
@@ -89,11 +96,13 @@
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
+    private final WeakReference<Context> contextWeakRef;
 
     private RealmConfiguration(Builder builder) {
         this.realmFolder = builder.folder;
         this.realmFileName = builder.fileName;
         this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.assetFilePath = builder.assetFilePath;
         this.key = builder.key;
         this.schemaVersion = builder.schemaVersion;
         this.deleteRealmIfMigrationNeeded = builder.deleteRealmIfMigrationNeeded;
@@ -102,6 +111,7 @@ private RealmConfiguration(Builder builder) {
         this.schemaMediator = createSchemaMediator(builder);
         this.rxObservableFactory = builder.rxFactory;
         this.initialDataTransaction = builder.initialDataTransaction;
+        this.contextWeakRef = builder.contextWeakRef;
     }
 
     public File getRealmFolder() {
@@ -150,6 +160,30 @@ RealmProxyMediator getSchemaMediator() {
         return initialDataTransaction;
     }
 
+    /**
+     * Indicates if there is available asset file for copy action.
+     *
+     * @return {@code true} if there is asset file, {@code false} otherwise.
+     */
+    boolean hasAssetFile() {
+        return !TextUtils.isEmpty(assetFilePath);
+    }
+
+    /**
+     * Returns input stream object to the Realm asset file.
+     *
+     * @return input stream to the asset file.
+     * @throws IOException if copying the file fails.
+     */
+    InputStream getAssetFile() throws IOException {
+        Context context = contextWeakRef.get();
+        if (context != null) {
+            return context.getAssets().open(assetFilePath);
+        } else {
+            throw new IllegalArgumentException("Context should not be null. Use Application Context instead of Activity Context.");
+        }
+    }
+
     /**
      * Returns the unmodifiable {@link Set} of model classes that make up the schema for this Realm.
      *
@@ -294,7 +328,7 @@ public String toString() {
     /**
      * Checks if RxJava is can be loaded.
      *
-     * @return true if RxJava dependency exist.
+     * @return {@code true} if RxJava dependency exist, {@code false} otherwise.
      */
     private static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
@@ -314,6 +348,7 @@ private static synchronized boolean isRxJavaAvailable() {
     public static final class Builder {
         private File folder;
         private String fileName;
+        private String assetFilePath;
         private byte[] key;
         private long schemaVersion;
         private RealmMigration migration;
@@ -321,6 +356,7 @@ private static synchronized boolean isRxJavaAvailable() {
         private SharedGroup.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        private WeakReference<Context> contextWeakRef;
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
@@ -328,9 +364,11 @@ private static synchronized boolean isRxJavaAvailable() {
          * Creates an instance of the Builder for the RealmConfiguration.
          * The Realm file will be saved in the provided folder.
          *
-         * @param folder Folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exists or isn't writable.
+         * @param folder the folder to save Realm file in. Folder must be writable.
+         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
+         * @deprecated Please use {@link #Builder(Context, File)} instead.
          */
+        @Deprecated
         public Builder(File folder) {
             RealmCore.loadLibrary();
             initializeBuilder(folder);
@@ -338,12 +376,12 @@ public Builder(File folder) {
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
-         *
-         * This will use the apps own internal directory for storing the Realm file. This does not require any
+         * <p>
+         * This will use the app's own internal directory for storing the Realm file. This does not require any
          * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
          * change depending on vendor implementations of Android.
          *
-         * @param context Android context.
+         * @param context the Android application context.
          */
         public Builder(Context context) {
             if (context == null) {
@@ -353,6 +391,23 @@ public Builder(Context context) {
             initializeBuilder(context.getFilesDir());
         }
 
+        /**
+         * Creates an instance of the Builder for the RealmConfiguration.
+         * <p>
+         * The Realm file will be saved in the provided folder, and it might require additional permissions.
+         *
+         * @param context the Android application context.
+         * @param folder the folder to save Realm file in. Folder must be writable.
+         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
+         */
+        public Builder(Context context, File folder) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            RealmCore.loadLibrary(context);
+            initializeBuilder(folder);
+        }
+
         // Setup builder in its initial state
         private void initializeBuilder(File folder) {
             if (folder == null || !folder.isDirectory()) {
@@ -405,7 +460,7 @@ public Builder encryptionKey(byte[] key) {
         /**
          * Sets the schema version of the Realm. This must be equal to or higher than the schema version of the existing
          * Realm file, if any. If the schema version is higher than the already existing Realm, a migration is needed.
-         *
+         * <p>
          * If no migration code is provided, Realm will throw a
          * {@link io.realm.exceptions.RealmMigrationNeededException}.
          *
@@ -437,9 +492,18 @@ public Builder migration(RealmMigration migration) {
          * {@link io.realm.exceptions.RealmMigrationNeededException} the on-disc Realm will be cleared and recreated
          * with the new Realm schema.
          *
-         * <b>WARNING!</b> This will result in loss of data.
+         * <p>This cannot be configured to have an asset file at the same time by calling
+         * {@link #assetFile(Context, String)} as the provided asset file will be deleted in migrations.
+         *
+         * <p><b>WARNING!</b> This will result in loss of data.
+         *
+         * @throws IllegalStateException if configured to use an asset file by calling {@link #assetFile(Context, String)} previously.
          */
         public Builder deleteRealmIfMigrationNeeded() {
+            if (this.assetFilePath != null && this.assetFilePath.length() != 0) {
+                throw new IllegalStateException("Realm cannot clear its schema when previously configured to use an asset file by calling assetFile().");
+            }
+
             this.deleteRealmIfMigrationNeeded = true;
             return this;
         }
@@ -453,29 +517,25 @@ public Builder deleteRealmIfMigrationNeeded() {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
+            if (!TextUtils.isEmpty(assetFilePath)) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+
             this.durability = SharedGroup.Durability.MEM_ONLY;
-            return this;
-        }
 
-        /**
-         * DEPRECATED: Use {@link #modules(Object, Object...)} instead.
-         */
-        @Deprecated
-        public Builder setModules(Object baseModule, Object... additionalModules) {
-            modules(baseModule, additionalModules);
             return this;
         }
 
         /**
          * Replaces the existing module(s) with one or more {@link RealmModule}s. Using this method will replace the
          * current schema for this Realm with the schema defined by the provided modules.
-         *
+         * <p>
          * A reference to the default Realm module containing all Realm classes in the project (but not dependencies),
          * can be found using {@link Realm#getDefaultModule()}. Combining the schema from the app project and a library
          * dependency is thus done using the following code:
-         *
+         * <p>
          * {@code builder.modules(Realm.getDefaultMode(), new MyLibraryModule()); }
-         *
+         * <p>
          * @param baseModule the first Realm module (required).
          * @param additionalModules the additional Realm modules
          * @throws IllegalArgumentException if any of the modules doesn't have the {@link RealmModule} annotation.
@@ -515,6 +575,42 @@ public Builder initialData(Realm.Transaction transaction) {
             return this;
         }
 
+        /**
+         * Copies the Realm file from the given asset file path.
+         * <p>
+         * When opening the Realm for the first time, instead of creating an empty file,
+         * the Realm file will be copied from the provided asset file and used instead.
+         *
+         * <p>This cannot be configured to clear and recreate schema by calling {@link #deleteRealmIfMigrationNeeded()}
+         * at the same time as doing so will delete the copied asset schema.
+         *
+         * <p>
+         * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
+         *
+         * @param context Android application context.
+         * @param assetFile path to the asset database file.
+         * @throws IllegalStateException if this is configured to clear its schema by calling {@link #deleteRealmIfMigrationNeeded()}.
+         */
+        public Builder assetFile(Context context, final String assetFile) {
+            if (context == null) {
+                throw new IllegalArgumentException("A non-null Context must be provided");
+            }
+            if (TextUtils.isEmpty(assetFile)) {
+                throw new IllegalArgumentException("A non-empty asset file path must be provided");
+            }
+            if (durability == SharedGroup.Durability.MEM_ONLY) {
+                throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
+            }
+            if (this.deleteRealmIfMigrationNeeded) {
+                throw new IllegalStateException("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().");
+            }
+
+            this.contextWeakRef = new WeakReference<>(context);
+            this.assetFilePath = assetFile;
+
+            return this;
+        }
+
         private void addModule(Object module) {
             if (module != null) {
                 checkModule(module);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index b5b4df2c0f..df514821ef 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -19,11 +19,10 @@
 import java.nio.ByteBuffer;
 
 import io.realm.internal.Keep;
-import io.realm.internal.Mixed;
 
 /**
  * List of the types used by Realm's underlying storage engine.
- *
+ * <p>
  * Normally there is no reason to interact with the underlying Realm types as Realm will automatically
  * convert between normal Java types and the Realm types. However it is possible to access these
  * types through a {@link DynamicRealmObject}.
@@ -37,7 +36,8 @@
     BINARY(4),
     UNSUPPORTED_TABLE(5),
     UNSUPPORTED_MIXED(6),
-    DATE(7),
+    UNSUPPORTED_DATE(7),
+    DATE(8),
     FLOAT(9),
     DOUBLE(10),
     OBJECT(12),
@@ -63,7 +63,7 @@
     /**
      * Returns the native value representing this type.
      *
-     * @return The value used by the underlying storage engine to represent this type.
+     * @return the value used by the underlying storage engine to represent this type.
      */
     public int getNativeValue() {
         return nativeValue;
@@ -71,7 +71,7 @@ public int getNativeValue() {
 
     /**
      * Checks if the given Java object can be converted to the underlying Realm type.
-     * @param obj Object to test compatibility on.
+     * @param obj object to test compatibility on.
      * @return {@code true} if object can be converted to the Realm type, {@code false} otherwise.
      */
     public boolean isValid(Object obj) {
@@ -81,15 +81,8 @@ public boolean isValid(Object obj) {
             case 2: return (obj instanceof String);
             case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
             case 5: return (obj == null || obj instanceof Object[][]);
-            case 6: return (obj instanceof Mixed ||
-                    obj instanceof Long || obj instanceof Integer ||
-                    obj instanceof Short || obj instanceof Byte || obj instanceof Boolean ||
-                    obj instanceof Float || obj instanceof Double ||
-                    obj instanceof String ||
-                    obj instanceof byte[] || obj instanceof ByteBuffer ||
-                    obj == null || obj instanceof Object[][] ||
-                    obj instanceof java.util.Date);
-            case 7: return (obj instanceof java.util.Date);
+            case 7: return (obj instanceof java.util.Date); // the unused DateTime
+            case 8: return (obj instanceof java.util.Date);
             case 9: return (obj instanceof Float);
             case 10: return (obj instanceof Double);
             case 12: return false;
@@ -102,8 +95,8 @@ public boolean isValid(Object obj) {
     /**
      * Converts the underlying value used by the storage engine to the proper Realm type.
      *
-     * @param value Value to convert
-     * @return The corresponding Realm type.
+     * @param value the value to convert
+     * @return the corresponding Realm type.
      * @throws IllegalArgumentException if value isn't valid.
      */
     public static RealmFieldType fromNativeValue(int value) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index c7d66424d0..d6397ef789 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -33,15 +33,15 @@
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
- * RealmList has two modes: A managed and non-managed mode. In managed mode all objects are persisted inside a Realm, in
- * non-managed mode it works as a normal ArrayList.
+ * RealmList has two modes: A managed and unmanaged mode. In managed mode all objects are persisted inside a Realm, in
+ * unmanaged mode it works as a normal ArrayList.
  * <p>
  * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the
  * underlying Realm is updated, and can only be accessed using the getter of a {@link io.realm.RealmObject}.
  * <p>
- * Non-managed RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
+ * Unmanaged RealmLists can be created by the user and can contain both managed and unmanaged RealmObjects. This is
  * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
- * Non-managed elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
+ * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
  * <p>
  * {@link RealmList} can contain more elements than {@code Integer.MAX_VALUE}.
  * In that case, you can access only first {@code Integer.MAX_VALUE} elements in it.
@@ -60,26 +60,26 @@
     protected String className;
     protected LinkView view;
     protected BaseRealm realm;
-    private List<E> nonManagedList;
+    private List<E> unmanagedList;
 
     /**
-     * Creates a RealmList in non-managed mode, where the elements are not controlled by a Realm.
+     * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
      * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
      * the objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist it's elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
         managedMode = false;
-        nonManagedList = new ArrayList<E>();
+        unmanagedList = new ArrayList<E>();
     }
 
     /**
-     * Creates a RealmList in non-managed mode with an initial list of elements.
-     * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not possible to query the
+     * Creates a RealmList in unmanaged mode with an initial list of elements.
+     * A RealmList in unmanaged mode function as a {@link java.util.ArrayList} and it is not possible to query the
      * objects in this state.
-     *
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements in Realm.
+     * <p>
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all unmanaged elements in Realm.
      *
      * @param objects initial objects in the list.
      */
@@ -88,16 +88,16 @@ public RealmList(E... objects) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
         managedMode = false;
-        nonManagedList = new ArrayList<E>(objects.length);
-        Collections.addAll(nonManagedList, objects);
+        unmanagedList = new ArrayList<E>(objects.length);
+        Collections.addAll(unmanagedList, objects);
     }
 
     /**
      * Creates a RealmList from a LinkView, so its elements are managed by Realm.
      *
-     * @param clazz type of elements in the Array
-     * @param linkView  backing LinkView
-     * @param realm reference to Realm containing the data
+     * @param clazz type of elements in the Array.
+     * @param linkView  backing LinkView.
+     * @param realm reference to Realm containing the data.
      */
     RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
         this.managedMode = true;
@@ -114,10 +114,10 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e. the {@link io.realm.Realm}
+     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e., the {@link io.realm.Realm}
      * instance hasn't been closed.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an un-managed list.
+     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an unmanaged list.
      */
     public boolean isValid() {
         //noinspection SimplifiableIfStatement
@@ -136,11 +136,11 @@ private boolean isAttached() {
      * element at the specified location. If the location is equal to the size of this List, the object is added at the
      * end.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -161,7 +161,7 @@ public void add(int location, E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.insert(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(location, object);
+            unmanagedList.add(location, object);
         }
         modCount++;
     }
@@ -169,17 +169,17 @@ public void add(int location, E object) {
     /**
      * Adds the specified object at the end of this List.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed. In
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed. In
      * that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)}
      * or {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
      *
      * @param object the object to add.
-     * @return always true
+     * @return always {@code true}.
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      */
     @Override
@@ -190,7 +190,7 @@ public boolean add(E object) {
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
         } else {
-            nonManagedList.add(object);
+            unmanagedList.add(object);
         }
         modCount++;
         return true;
@@ -199,11 +199,11 @@ public boolean add(E object) {
     /**
      * Replaces the element at the specified location in this list with the specified object.
      * <ol>
-     * <li><b>Un-managed RealmLists:</b> It is possible to add both managed and un-managed objects. If adding managed
-     * objects to a un-managed RealmList they will not be copied to the Realm again if using
+     * <li><b>Unmanaged RealmLists</b>: It is possible to add both managed and unmanaged objects. If adding managed
+     * objects to an unmanaged RealmList they will not be copied to the Realm again if using
      * {@link Realm#copyToRealm(RealmModel)} afterwards.</li>
      *
-     * <li><b>Managed RealmLists:</b> It is possible to add un-managed objects to a RealmList that is already managed.
+     * <li><b>Managed RealmLists</b>: It is possible to add unmanaged objects to a RealmList that is already managed.
      * In that case the object will transparently be copied to Realm using {@link Realm#copyToRealm(RealmModel)} or
      * {@link Realm#copyToRealmOrUpdate(RealmModel)} if it has a primary key.</li>
      * </ol>
@@ -224,12 +224,12 @@ public E set(int location, E object) {
             view.set(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
             return oldObject;
         } else {
-            oldObject = nonManagedList.set(location, object);
+            oldObject = unmanagedList.set(location, object);
         }
         return oldObject;
     }
 
-    // Transparently copies a standalone object or managed object from another Realm to the Realm backing this RealmList.
+    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
     private E copyToRealmIfNeeded(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
@@ -276,7 +276,7 @@ private E copyToRealmIfNeeded(E object) {
 
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
-     * RealmObjects will be shifted so no null values are introduced.
+     * RealmObjects will be shifted so no {@code null} values are introduced.
      *
      * @param oldPos index of RealmObject to move.
      * @param newPos target position. If newPos &lt; oldPos the object at the location will be shifted to the right. If
@@ -291,11 +291,11 @@ public void move(int oldPos, int newPos) {
         } else {
             checkIndex(oldPos);
             checkIndex(newPos);
-            E object = nonManagedList.remove(oldPos);
+            E object = unmanagedList.remove(oldPos);
             if (newPos > oldPos) {
-                nonManagedList.add(newPos - 1, object);
+                unmanagedList.add(newPos - 1, object);
             } else {
-                nonManagedList.add(newPos, object);
+                unmanagedList.add(newPos, object);
             }
         }
     }
@@ -314,7 +314,7 @@ public void clear() {
             checkValidView();
             view.clear();
         } else {
-            nonManagedList.clear();
+            unmanagedList.clear();
         }
         modCount++;
     }
@@ -335,7 +335,7 @@ public E remove(int location) {
             removedItem = get(location);
             view.remove(location);
         } else {
-            removedItem = nonManagedList.remove(location);
+            removedItem = unmanagedList.remove(location);
         }
         modCount++;
         return removedItem;
@@ -343,8 +343,8 @@ public E remove(int location) {
 
     /**
      * Removes one instance of the specified object from this {@code Collection} if one
-     * is contained . This implementation iterates over this
-     * {@code Collection} and tests for each element {@code e} returned by the iterator,
+     * is contained. This implementation iterates over this
+     * {@code Collection} and tests each element {@code e} returned by the iterator,
      * whether {@code e} is equal to the given object. If {@code object != null}
      * then this test is performed using {@code object.equals(e)}, otherwise
      * using {@code object == null}. If an element equal to the given object is
@@ -372,7 +372,7 @@ public boolean remove(Object object) {
      * elements in the passed {@code Collection} can be found in this {@code Collection}
      * anymore.
      * <p>
-     * This implementation iterates over this {@code Collection} and tests for each
+     * This implementation iterates over the {@code Collection} and tests each
      * element {@code e} returned by the iterator, whether it is contained in
      * the specified {@code Collection}. If this test is positive, then the {@code
      * remove} method is called on the iterator.
@@ -441,15 +441,12 @@ public E get(int location) {
             long rowIndex = view.getTargetRowIndex(location);
             return realm.get(clazz, className, rowIndex);
         } else {
-            return nonManagedList.get(location);
+            return unmanagedList.get(location);
         }
     }
 
     /**
-     * Finds the first object.
-     *
-     * @return the first object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E first() {
         if (managedMode) {
@@ -457,17 +454,14 @@ public E first() {
             if (!view.isEmpty()) {
                 return get(0);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(0);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(0);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
 
     /**
-     * Finds the last object.
-     *
-     * @return the last object or {@code null} if the list is empty.
-     * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
+     * {@inheritDoc}
      */
     public E last() {
         if (managedMode) {
@@ -475,8 +469,8 @@ public E last() {
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
             }
-        } else if (nonManagedList != null && nonManagedList.size() > 0) {
-            return nonManagedList.get(nonManagedList.size() - 1);
+        } else if (unmanagedList != null && unmanagedList.size() > 0) {
+            return unmanagedList.get(unmanagedList.size() - 1);
         }
         throw new IndexOutOfBoundsException("The list is empty.");
     }
@@ -548,7 +542,7 @@ public int size() {
             long size = view.size();
             return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
         } else {
-            return nonManagedList.size();
+            return unmanagedList.size();
         }
     }
 
@@ -664,7 +658,7 @@ public boolean deleteAllFromRealm() {
      */
     @Override
     public boolean isLoaded() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
@@ -672,14 +666,14 @@ public boolean isLoaded() {
      */
     @Override
     public boolean load() {
-        return true; // Managed RealmLists are always loaded, Un-managed RealmLists return true pr. the contract.
+        return true; // Managed RealmLists are always loaded, Unmanaged RealmLists return true pr. the contract.
     }
 
     /**
-     * Returns true if the list contains the specified element when attached to a Realm. This
+     * Returns {@code true} if the list contains the specified element when attached to a Realm. This
      * method will query the native Realm underlying storage engine to quickly find the specified element.
-     *
-     * If this list is not attached to a Realm the default {@link List#contains(Object)}
+     * <p>
+     * If the list is not attached to a Realm, the default {@link List#contains(Object)}
      * implementation will occur.
      *
      * @param object the element whose presence in this list is to be tested.
@@ -697,7 +691,7 @@ public boolean contains(Object object) {
                 }
             }
         } else {
-            contains = nonManagedList.contains(object);
+            contains = unmanagedList.contains(object);
         }
         return contains;
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmMigration.java b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
index 70ec9df868..5140a3bf6a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmMigration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
@@ -18,12 +18,12 @@
 
 /**
  * The RealmMigration class is used to perform the migration of one Realm schema to another.
- * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}, so any
- * changes to these classes will require a migration.
- *
+ * The schema for a Realm is defined by all classes in a project that extend {@link io.realm.RealmObject}
+ * or implement {@link io.realm.RealmModel}, so any changes to these classes will require a migration.
+ * <p>
  * To support migrations from any previous schemaVersion to the newest, the following pattern is recommended when
  * writing a migration:
- *
+ * <p>
  * <pre>
  * {@code
  * public class CustomMigration implements RealmMigration {
@@ -48,7 +48,7 @@
  * }
  * }
  * </pre>
- *
+ * <p>
  * During development when RealmObject classes can change frequently, it is possible to use
  * {@link io.realm.Realm#deleteRealm(RealmConfiguration)}. This will delete the database file and eliminate the need for
  * any migrations.
@@ -61,7 +61,7 @@
 
     /**
      * This method will be called if a migration is needed. The entire method is wrapped in a
-     * write transaction so it is possible to create/change or delete any existing objects
+     * write transaction so it is possible to create, update or delete any existing objects
      * without wrapping it in your own transaction.
      *
      * @param realm the Realm schema on which to perform the migration.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmModel.java b/realm/realm-library/src/main/java/io/realm/RealmModel.java
index 8fbf94f3ac..0c4c8a1046 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmModel.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmModel.java
@@ -21,7 +21,7 @@
 
 /**
  * Interface for marking classes as RealmObjects, it can be used instead of extending {@link RealmObject}.
- *
+ * <p>
  * All helper methods available to classes that extend RealmObject are instead available as static methods:
  *
  * <pre>
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 5366e338c6..b77dfca7d5 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -16,16 +16,19 @@
 
 package io.realm;
 
+import android.app.IntentService;
+
 import java.util.List;
 
 import io.realm.annotations.RealmClass;
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import rx.Observable;
 
 /**
- * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then 
+ * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then
  * create your objects within a Realm, and use your custom subclasses instead of using the RealmObject class directly.
  * <p>
  * An annotation processor will create a proxy class for your RealmObject subclass.
@@ -49,7 +52,8 @@
  * within a Realm.
  * <p>
  * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
- * Any method as well as public fields are allowed.
+ * Any method as well as public fields are allowed. When providing custom constructors, a public constructor with
+ * no arguments must be declared and be empty.
  * <p>
  * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
  * getter or setter.
@@ -65,20 +69,6 @@
 
 @RealmClass
 public abstract class RealmObject implements RealmModel {
-    /**
-     * DEPRECATED: Use {@link #deleteFromRealm()} instead.
-     *
-     * Removes the object from the Realm it is currently associated to.
-     * <p>
-     * After this method is called the object will be invalid and any operation (read or write) performed on it will
-     * fail with an IllegalStateException
-     *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public final void removeFromRealm() {
-        deleteFromRealm();
-    }
 
     /**
      * Deletes the object from the Realm it is currently associated to.
@@ -92,7 +82,7 @@ public final void removeFromRealm() {
     public final void deleteFromRealm() {
         deleteFromRealm(this);
     }
-    
+
     /**
      * Deletes the object from the Realm it is currently associated with.
      * <p>
@@ -124,21 +114,32 @@ public final void deleteFromRealm() {
 
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * <p>
+     * Note that this can be used to check the validity of certain conditions such as being {@code null}
+     * when observed.
+     * <pre>
+     * {@code
+     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asObservable()
+     *      .filter(result.isLoaded() && result.isValid())
+     *      .first()
+     * }
+     * </pre>
      *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
     public final boolean isValid() {
         return RealmObject.isValid(this);
     }
 
     /**
-     * Checks if the RealmObject is still valid to use i.e. the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return false for stand alone objects.
+     * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
+     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
      *
      * @param object RealmObject to check validity for.
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is a standalone object.
+     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
      */
     public static <E extends RealmModel> boolean isValid(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -151,25 +152,85 @@ public final boolean isValid() {
     }
 
     /**
-     * Determines if the current RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Checks if the query used to find this RealmObject has completed.
+     *
+     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future result
+     * of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this regard.
+     *
+     * Once {@code isLoaded()} returns {@code true}, the object represents the query result even if the query
+     * didn't find any object matching the query parameters. In this case the {@link RealmObject} will
+     * become a "null" object.
+     *
+     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to also
+     * check {@link #isValid()} before calling any methods. A common pattern is:
+     *
+     * <pre>
+     * {@code
+     * Person person = realm.where(Person.class).findFirstAsync();
+     * person.isLoaded(); // == false
+     * person.addChangeListener(new RealmChangeListener() {
+     *      \@Override
+     *      public void onChange(Person person) {
+     *          person.isLoaded(); // Always true here
+     *          if (person.isValid()) {
+     *              // It is safe to access the person.
+     *          }
+     *      }
+     * });
+     * }
+     * </pre>
+     *
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This method will return {@code true} if called on an unmanaged object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * @return {@code true} if the query has completed, {@code false} if the query is in
      * progress.
+     *
+     * @see #isValid()
      */
     public final boolean isLoaded() {
         return RealmObject.isLoaded(this);
     }
 
+
     /**
-     * Determines if the RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Checks if the query used to find this RealmObject has completed.
+     *
+     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future result
+     * of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this regard.
+     *
+     * Once {@code isLoaded()} returns {@code true}, the object represents the query result even if the query
+     * didn't find any object matching the query parameters. In this case the {@link RealmObject} will
+     * become a "null" object.
+     *
+     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to also
+     * check {@link #isValid()} before calling any methods. A common pattern is:
+     *
+     * <pre>
+     * {@code
+     * Person person = realm.where(Person.class).findFirstAsync();
+     * RealmObject.isLoaded(person); // == false
+     * RealmObject.addChangeListener(person, new RealmChangeListener() {
+     *      \@Override
+     *      public void onChange(Person person) {
+     *          RealmObject.isLoaded(person); // always true here
+     *          if (RealmObject.isValid(person)) {
+     *              // It is safe to access the person.
+     *          }
+     *      }
+     * });
+     * }
+     * </pre>
+     *
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
+     * This method will return {@code true} if called on an unmanaged object (created outside of Realm).
+     *
      *
      * @param object RealmObject to check.
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * @return {@code true} if the query has completed, {@code false} if the query is in
      * progress.
+     *
+     * @see #isValid(RealmModel)
      */
     public static <E extends RealmModel> boolean isLoaded(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -183,7 +244,8 @@ public final boolean isLoaded() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
@@ -193,7 +255,8 @@ public final boolean load() {
 
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
-     * Note: This will return {@code true} if called for a standalone object (created outside of Realm).
+     * <p>
+     * Note: This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
      * @param object RealmObject to force load.
      * @return {@code true} if it successfully completed the query, {@code false} otherwise.
@@ -216,10 +279,12 @@ public final boolean load() {
      * Adds a change listener to this RealmObject.
      *
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
-    public final void addChangeListener(RealmChangeListener listener) {
-        RealmObject.addChangeListener(this, listener);
+    public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
+        RealmObject.addChangeListener((E) this, listener);
     }
 
     /**
@@ -227,9 +292,14 @@ public final void addChangeListener(RealmChangeListener listener) {
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
-     * @throws IllegalArgumentException if object is an un-managed RealmObject.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
-    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener listener) {
+    public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
+        if (object == null) {
+            throw new IllegalArgumentException("Object should not be null");
+        }
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -237,13 +307,19 @@ public final void addChangeListener(RealmChangeListener listener) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
             realm.checkIfValid();
-            if (realm.handler == null) {
-                throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+            if (!realm.handlerController.isAutoRefreshEnabled()) {
+                throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread.");
             }
             List<RealmChangeListener> listeners = proxy.realmGet$proxyState().getListeners$realm();
             if (!listeners.contains(listener)) {
                 listeners.add(listener);
             }
+            if (isLoaded(proxy)) {
+                // Try to add this object to the realmObjects if it has already been loaded.
+                // For newly created async objects, it will be handled in RealmQuery.findFirstAsync &
+                // HandlerController.completedAsyncRealmObject.
+                realm.handlerController.addToRealmObjects(proxy);
+            }
         } else {
             throw new IllegalArgumentException("Cannot add listener from this unmanaged RealmObject (created outside of Realm)");
         }
@@ -254,6 +330,8 @@ public final void addChangeListener(RealmChangeListener listener) {
      * Removes a previously registered listener.
      *
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public final void removeChangeListener(RealmChangeListener listener) {
         RealmObject.removeChangeListener(this, listener);
@@ -264,8 +342,14 @@ public final void removeChangeListener(RealmChangeListener listener) {
      *
      * @param object RealmObject to remove listener from.
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
+     * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener listener) {
+        if (object == null) {
+            throw new IllegalArgumentException("Object should not be null");
+        }
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -297,7 +381,7 @@ public final void removeChangeListeners() {
             proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
             proxy.realmGet$proxyState().getListeners$realm().clear();
         } else {
-            throw new IllegalArgumentException("Cannot remove listeners from this un-managed RealmObject (created outside of Realm)");
+            throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
         }
     }
 
@@ -305,10 +389,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      *
@@ -321,12 +405,19 @@ public final void removeChangeListeners() {
      * }
      * </pre>
      *
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
      * @param <E> RealmObject class that is being observed. Must be this class or its super types.
      * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public final <E extends RealmObject> Observable<E> asObservable() {
         return (Observable<E>) RealmObject.asObservable(this);
     }
@@ -335,10 +426,10 @@ public final void removeChangeListeners() {
      * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
-     *
-     * If chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * <p>
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
-     *
+     * <p>
      * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
      * emit only the first item by using the {@code first()} operator:
      *
@@ -374,7 +465,7 @@ public final void removeChangeListeners() {
             }
         } else {
             // TODO Is this true? Should we just return Observable.just(object) ?
-            throw new IllegalArgumentException("Cannot create Observables from un-managed RealmObjects");
+            throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
         }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 7a3d006452..893831a57a 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -88,8 +88,10 @@
     /**
      * Returns the name of the RealmObject class being represented by this schema.
      * <p>
-     * When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.
-     * When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.
+     * <ul>
+     * <li>When using a normal {@link Realm} this name is the same as the {@link RealmObject} class.</li>
+     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
+     * </ul>
      *
      * @return the name of the RealmObject class represented by this schema.
      */
@@ -98,24 +100,47 @@ public String getClassName() {
     }
 
     /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When {@link RealmObjectSchema#table}
+     * has a primary key, this will transfer the primary key for the new class name.
      *
      * @param className the new name for this class.
+     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56 characters.
      * @see RealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
         checkEmpty(className);
         String internalTableName = Table.TABLE_PREFIX + className;
+        //FIXME : when core implements class name length check, please remove.
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is to long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+        }
         if (transaction.hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        String oldTableName = null;
+        String pkField = null;
+        if (table.hasPrimaryKey()) {
+            oldTableName = table.getName();
+            pkField = getPrimaryKey();
+            table.setPrimaryKey(null);
+        }
         transaction.renameTable(table.getName(), internalTableName);
+        if (pkField != null && !pkField.isEmpty()) {
+            try {
+                table.setPrimaryKey(pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                transaction.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
         return this;
     }
 
     /**
      * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See {@link RealmObject}
-     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.
+     * for the list of supported types. If the field should allow {@code null} values use the boxed type instead e.g.,
      * {@code Integer.class} instead of {@code int.class}.
      * <p>
      * To add fields that reference other RealmObjects or RealmLists use {@link #addRealmObjectField(String, RealmObjectSchema)}
@@ -292,7 +317,7 @@ public RealmObjectSchema removeIndex(String fieldName) {
 
     /**
      * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field.
+     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field as well.
      *
      * @param fieldName field to set as primary key.
      * @return the updated schema.
@@ -306,12 +331,17 @@ public RealmObjectSchema addPrimaryKey(String fieldName) {
             throw new IllegalStateException("A primary key is already defined");
         }
         table.setPrimaryKey(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
         return this;
     }
 
     /**
      * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class.
+     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from the field as well.
      *
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
@@ -320,13 +350,17 @@ public RealmObjectSchema removePrimaryKey() {
         if (!table.hasPrimaryKey()) {
             throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
         }
+        long columnIndex = table.getPrimaryKey();
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
         table.setPrimaryKey("");
         return this;
     }
 
     /**
-     * Sets a field to be required, i.e. not allowed to hold {@code null values}. This is equivalent to switching
-     * between boxed types and their primitive variant e.g. {@code Integer} to {@code int}.
+     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
+     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
      *
      * @param fieldName name of field in the class.
      * @param required  {@code true} if field should be required, {@code false} otherwise.
@@ -362,8 +396,8 @@ public RealmObjectSchema setRequired(String fieldName, boolean required) {
     }
 
     /**
-     * Sets a field to be nullable, i.e. it should be able to hold {@code null values}. This is equivalent to switching
-     * between primitive types and their boxed variant e.g. {@code int} to {@code Integer}.
+     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
+     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
      *
      * @param fieldName name of field in the class.
      * @param nullable  {@code true} if field should be nullable, {@code false} otherwise.
@@ -376,7 +410,7 @@ public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
     }
 
     /**
-     * Checks if a given field is required, i.e. is not allowed to contain {@code null} values.
+     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -389,7 +423,7 @@ public boolean isRequired(String fieldName) {
     }
 
     /**
-     * Checks if a given field is nullable, i.e. is allowed to contain {@code null} values.
+     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
      *
      * @param fieldName field to check.
      * @return {@code true} if it is required, {@code false} otherwise.
@@ -479,9 +513,9 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
                 }
 
                 if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
                     addPrimaryKey(fieldName);
+                    indexAdded = true;
                 }
 
                 // REQUIRED is being handled when adding the column using addField through the nullable parameter.
@@ -553,10 +587,10 @@ private void checkEmpty(String str) {
 
     /**
      * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned
+     * each field is returned.
      *
      * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes Legal field type for the last field in a linked field
+     * @param validColumnTypes valid field type for the last field in a linked field
      * @return list of column indices.
      */
     // TODO: consider another caching strategy so linked classes are included in the cache.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 0e2596940b..fdd8f1d788 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.Future;
 
 import io.realm.annotations.Required;
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -43,7 +44,7 @@
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
- * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}
+ * pattern. The query is executed using either {@link #findAll()} or {@link #findFirst()}.
  * <p>
  * The input to many of the query functions take a field name as String. Note that this is not type safe. If a 
  * RealmObject class is refactored care has to be taken to not break any queries.
@@ -69,6 +70,8 @@
     private LinkView view;
     private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
+    private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
+
 
     private final static Long INVALID_NATIVE_POINTER = 0L;
     private ArgumentsHolder argumentsHolder;
@@ -98,9 +101,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmResults}.
+     * Creates a query from an existing {@link RealmResults}.
      *
-     * @param queryResults   a existing @{link io.realm.RealmResults} to query against.
+     * @param queryResults   an existing @{link io.realm.RealmResults} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -115,9 +118,9 @@
     }
 
     /**
-     * Creates a query from a existing {@link RealmList}.
+     * Creates a query from an existing {@link RealmList}.
      *
-     * @param list   a existing @{link io.realm.RealmList} to query against.
+     * @param list   an existing @{link io.realm.RealmList} to query against.
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
@@ -183,7 +186,7 @@ private RealmQuery(BaseRealm realm, LinkView view, String className) {
     }
 
     /**
-     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e. the {@link io.realm.Realm} instance hasn't been
+     * Checks if {@link io.realm.RealmQuery} is still valid to use i.e., the {@link io.realm.Realm} instance hasn't been
      * closed and any parent {@link io.realm.RealmResults} is still valid.
      *
      * @return {@code true} if still valid to use, {@code false} otherwise.
@@ -201,9 +204,9 @@ public boolean isValid() {
 
     /**
      * Tests if a field is {@code null}. Only works for nullable fields.
-     *
+     * <p>
      * For link queries, if any part of the link path is {@code null} the whole path is considered to be {@code null}
-     * e.g. {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
+     * e.g., {@code isNull("linkField.stringField")} will be considered to be {@code null} if either {@code linkField} or
      * {@code linkField.stringField} is {@code null}.
      *
      * @param fieldName the field name.
@@ -254,7 +257,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -403,6 +406,192 @@ public boolean isValid() {
         return this;
     }
 
+    // In
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, String[] values) {
+        return in(fieldName, values, Case.SENSITIVE);
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @param casing how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, String[] values, Case casing) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0], casing);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i], casing);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Byte field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Byte[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Short field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Short[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Integer field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Integer[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Long field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Long[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Double field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Double[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Float field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Float[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Boolean field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Boolean[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Date field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Date[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
     // Not Equal
 
     /**
@@ -422,7 +611,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the value to compare with.
-     * @param casing     How casing is handled. {@link Case#INSENSITIVE} works only for the English locale characters.
+     * @param casing     how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -960,7 +1149,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return The query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -987,7 +1176,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
@@ -1014,7 +1203,7 @@ public boolean isValid() {
      *
      * @param fieldName the field to compare.
      * @param value the substring.
-     * @param casing     How to handle casing. Setting this to {@link Case#INSENSITIVE} only works for English locale characters.
+     * @param casing     how to handle casing. Setting this to {@link Case#INSENSITIVE} only works for Latin-1 characters.
      * @return the query object.
      * @throws java.lang.IllegalArgumentException One or more arguments do not match class or field type.
      */
@@ -1069,7 +1258,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "empty", i.e. an empty list, the 0-length string or byte array.
+     * Condition that finds values that are considered "empty" i.e., an empty list, the 0-length string or byte array.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1083,7 +1272,7 @@ public boolean isValid() {
     }
 
     /**
-     * Condition that find values that are considered "Not-empty", i.e. a list, a string or a byte array with not-empty values.
+     * Condition that finds values that are considered "Not-empty" i.e., a list, a string or a byte array with not-empty values.
      *
      * @param fieldName the field to compare.
      * @return the query object.
@@ -1103,7 +1292,7 @@ public boolean isValid() {
      *
      * @param fieldName the field name.
      * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
@@ -1131,7 +1320,7 @@ public boolean isValid() {
      * @return immediately a {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
      * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type,
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
@@ -1162,7 +1351,7 @@ public boolean isValid() {
 
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1184,13 +1373,13 @@ public Long call() throws Exception {
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                         result.versionID = sharedGroup.getVersion();
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                         return handoverTableViewPointer;
-                    } catch (Exception e) {
+                    } catch (Throwable e) {
                         RealmLog.e(e.getMessage(), e);
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
 
                     } finally {
                         if (sharedGroup != null && !sharedGroup.isClosed()) {
@@ -1283,8 +1472,9 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
      * Calculates the sum of a given field.
      *
      * @param fieldName the field to sum. Only number fields are supported.
-     * @return the sum if no objects exist or they all have {@code null} as the value for the given field, {@code 0}
-     * will be returned. When computing the sum, objects with {@code null} values are ignored.
+     * @return the sum of fields of the matching objects. If no objects exist or they all have {@code null} as the value
+     *         for the given field, {@code 0} will be returned. When computing the sum, objects with {@code null} values
+     *         are ignored.
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public Number sum(String fieldName) {
@@ -1469,7 +1659,7 @@ public long count() {
 
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1490,7 +1680,7 @@ public Long call() throws Exception {
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                         result.versionID = sharedGroup.getVersion();
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                         return handoverTableViewPointer;
 
@@ -1499,10 +1689,10 @@ public Long call() throws Exception {
                         RealmLog.d("findAllAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
-                    } catch (Exception e) {
+                    } catch (Throwable e) {
                         RealmLog.e(e.getMessage(), e);
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
 
                     } finally {
                         if (sharedGroup != null && !sharedGroup.isClosed()) {
@@ -1587,7 +1777,7 @@ public Long call() throws Exception {
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults =
                 realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1609,7 +1799,7 @@ public Long call() throws Exception {
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                         result.versionID = sharedGroup.getVersion();
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                         return handoverTableViewPointer;
                     } catch (BadVersionException e) {
@@ -1617,10 +1807,10 @@ public Long call() throws Exception {
                         RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
-                    } catch (Exception e) {
+                    } catch (Throwable e) {
                         RealmLog.e(e.getMessage(), e);
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
 
                     } finally {
                         if (sharedGroup != null && !sharedGroup.isClosed()) {
@@ -1648,7 +1838,8 @@ public Long call() throws Exception {
      * @param fieldName the field name to sort by.
      * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
      * objects is returned.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSorted(String fieldName) {
         return findAllSorted(fieldName, Sort.ASCENDING);
@@ -1660,7 +1851,8 @@ public Long call() throws Exception {
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if field name does not exist.
+     * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(String fieldName) {
         return findAllSortedAsync(fieldName, Sort.ASCENDING);
@@ -1760,7 +1952,7 @@ private boolean isDynamicQuery() {
 
             final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-            final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
                 @Override
                 public Long call() throws Exception {
                     if (!Thread.currentThread().isInterrupted()) {
@@ -1780,7 +1972,7 @@ public Long call() throws Exception {
                             result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
                             result.versionID = sharedGroup.getVersion();
                             closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                                    weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result);
 
                             return handoverTableViewPointer;
                         } catch (BadVersionException e) {
@@ -1788,10 +1980,10 @@ public Long call() throws Exception {
                             RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                     "Retry is scheduled by a REALM_CHANGED event.");
 
-                        } catch (Exception e) {
+                        } catch (Throwable e) {
                             RealmLog.e(e.getMessage(), e);
                             closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                                    weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
 
                         } finally {
                             if (sharedGroup != null && !sharedGroup.isClosed()) {
@@ -1823,10 +2015,11 @@ public Long call() throws Exception {
      * @param sortOrder2 sort order for second field
      * @return a {@link io.realm.RealmResults} containing objects. If no objects match the condition, a list with zero
      * objects is returned.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
-                                   String fieldName2, Sort sortOrder2) {
+                                         String fieldName2, Sort sortOrder2) {
         return findAllSorted(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
@@ -1836,35 +2029,14 @@ public Long call() throws Exception {
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
+     * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
+     * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
                                               String fieldName2, Sort sortOrder2) {
         return findAllSortedAsync(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
-    /**
-     * DEPRECATED: Use {@link #findAllSorted(String[], Sort[])}  instead.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
-                                   String fieldName2, Sort sortOrder2,
-                                   String fieldName3, Sort sortOrder3) {
-        return findAllSorted(new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
-    /**
-     * DEPRECATED: Use {@link #findAllSortedAsync(String[], Sort[])}  instead.
-     */
-    @Deprecated
-    public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
-                                              String fieldName2, Sort sortOrder2,
-                                              String fieldName3, Sort sortOrder3) {
-        return findAllSortedAsync(new String[]{fieldName1, fieldName2, fieldName3},
-                new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
     /**
      * Finds the first object that fulfills the query conditions.
      *
@@ -1876,9 +2048,6 @@ public E findFirst() {
         long sourceRowIndex = getSourceRowIndexForFirstObject();
         if (sourceRowIndex >= 0) {
             E realmObject = realm.get(clazz, className, sourceRowIndex);
-            WeakReference<RealmObjectProxy> realmObjectWeakReference
-                    = new WeakReference<RealmObjectProxy>((RealmObjectProxy) realmObject, realm.handlerController.referenceQueueRealmObject);
-            realm.handlerController.realmObjects.put(realmObjectWeakReference, this);
             return realmObject;
         } else {
             return null;
@@ -1923,7 +2092,7 @@ public E findFirstAsync() {
         proxy.realmGet$proxyState().setRealm$realm(realm);
         proxy.realmGet$proxyState().setRow$realm(Row.EMPTY_ROW);
 
-        final Future<Long> pendingQuery = Realm.asyncQueryExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
@@ -1946,15 +2115,15 @@ public Long call() throws Exception {
                         result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
                         result.versionID = sharedGroup.getVersion();
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_OBJECT, result);
+                                weakHandler, HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT, result);
 
                         return handoverRowPointer;
 
-                    } catch (Exception e) {
+                    } catch (Throwable e) {
                         RealmLog.e(e.getMessage(), e);
                         // handler can't throw a checked exception need to wrap it into unchecked Exception
                         closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                                weakHandler, HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
 
                     } finally {
                         if (sharedGroup != null && !sharedGroup.isClosed()) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index e507ca6267..1013035f13 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -17,6 +17,8 @@
 package io.realm;
 
 
+import android.app.IntentService;
+
 import java.util.AbstractList;
 import java.util.Collection;
 import java.util.Collections;
@@ -29,6 +31,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
+import io.realm.annotations.internal.OptionalAPI;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Table;
@@ -45,7 +48,7 @@
  * increases speed.
  * <p>
  * RealmResults are live views, which means that if it is on an {@link android.os.Looper} thread, it will automatically
- * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#refresh()}
+ * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#waitForChange()}
  * must be called to update the results.
  * <p>
  * Updates to RealmObjects from a RealmResults list must be done from within a transaction and the modified objects are
@@ -54,7 +57,7 @@
  * A RealmResults object cannot be passed between different threads.
  * <p>
  * Notice that a RealmResults is never {@code null} not even in the case where it contains no objects. You should always
- * use the size() method to check if a RealmResults is empty or not.
+ * use the {@link RealmResults#size()} method to check if a RealmResults is empty or not.
  * <p>
  * If a RealmResults is built on RealmList through {@link RealmList#where()}, it will become empty when the source
  * RealmList gets deleted.
@@ -64,8 +67,7 @@
  *
  * @param <E> The class of objects in this list.
  * @see RealmQuery#findAll()
- * @see Realm#allObjects(Class)
- * @see io.realm.Realm#beginTransaction()
+ * @see io.realm.Realm#executeTransaction(Realm.Transaction)
  */
 public final class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
@@ -81,7 +83,7 @@
 
     private long currentTableViewVersion = TABLE_VIEW_VERSION_NONE;
     private final TableQuery query;
-    private final List<RealmChangeListener> listeners = new CopyOnWriteArrayList<RealmChangeListener>();
+    private final List<RealmChangeListener<RealmResults<E>>> listeners = new CopyOnWriteArrayList<RealmChangeListener<RealmResults<E>>>();
     private Future<Long> pendingQuery;
     private boolean asyncQueryCompleted = false;
     // Keep track of changes to the RealmResult. Is updated after a call to `syncIfNeeded()`. Calling notifyListeners will
@@ -218,7 +220,7 @@ public E first() {
         if (size() > 0) {
             return get(0);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -231,7 +233,7 @@ public E last() {
         if (size > 0) {
             return get(size - 1);
         } else {
-            throw new IndexOutOfBoundsException("No results was found.");
+            throw new IndexOutOfBoundsException("No results were found.");
         }
     }
 
@@ -359,24 +361,6 @@ private long getColumnIndexForSort(String fieldName) {
         return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
-    /**
-     * Sorts existing {@link io.realm.RealmResults} using three fields.
-     *
-     * DEPRECATED: Use {@link #sort(String[], Sort[])} instead.
-     *
-     * @param fieldName1 first field name.
-     * @param sortOrder1 sort order for first field.
-     * @param fieldName2 second field name.
-     * @param sortOrder2 sort order for second field.
-     * @param fieldName3 third field name.
-     * @param sortOrder3 sort order for third field.
-     * @throws java.lang.IllegalArgumentException if a field name does not exist.
-     */
-    @Deprecated
-    public void sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2, String fieldName3, Sort sortOrder3) {
-        sort(new String[]{fieldName1, fieldName2, fieldName3}, new Sort[]{sortOrder1, sortOrder2, sortOrder3});
-    }
-
     // Aggregates
 
     /**
@@ -616,18 +600,6 @@ public boolean retainAll(Collection<?> collection) {
         throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
     }
 
-    /**
-     * Removes the last object in the list. This also deletes the object from the underlying Realm.
-     *
-     * DEPRECATED: Use {@link #deleteLastFromRealm()} instead.
-     *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Deprecated
-    public void removeLast() {
-        deleteLastFromRealm();
-    }
-
     /**
      * Removes the last object in the list. This also deletes the object from the underlying Realm.
      *
@@ -645,6 +617,14 @@ public boolean deleteLastFromRealm() {
         }
     }
 
+    /**
+     * Syncs this RealmResults, so it is up to date after `advance_read` has been called.
+     * Not doing so can leave detached accessors in the table view.
+     *
+     * By design, we should only call this on looper events.
+     *
+     * NOTE: Calling this is a prerequisite to calling {@link #notifyChangeListeners(boolean)}.
+     */
     void syncIfNeeded() {
         long newVersion = table.syncIfNeeded();
         viewUpdated = newVersion != currentTableViewVersion;
@@ -882,12 +862,11 @@ void setPendingQuery(Future<Long> pendingQuery) {
     }
 
     /**
-     * Returns {@code true} if the results are not yet loaded, {@code false} if they are still loading. Synchronous
+     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded. Synchronous
      * query methods like findAll() will always return {@code true}, while asynchronous query methods like
      * findAllAsync() will return {@code false} until the results are available.
-     * This will return {@code true} if called for a standalone object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is still
+     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
      * running.
      */
     public boolean isLoaded() {
@@ -900,7 +879,7 @@ public boolean isLoaded() {
      * the query completes.
      *
      * @return {@code true} if it successfully completed the query, {@code false} otherwise. {@code true} will always
-     *         be returned for standalone objects.
+     *         be returned for unmanaged objects.
      */
     public boolean load() {
         //noinspection SimplifiableIfStatement
@@ -927,7 +906,7 @@ private boolean onAsyncQueryCompleted() {
             // this should handle more complex use cases like retry, ignore etc
             table = query.importHandoverTableView(tvHandover, realm.sharedGroupManager.getNativePointer());
             asyncQueryCompleted = true;
-            notifyChangeListeners(false, true);
+            notifyChangeListeners(true);
         } catch (Exception e) {
             RealmLog.d(e.getMessage());
             return false;
@@ -939,14 +918,16 @@ private boolean onAsyncQueryCompleted() {
      * Adds a change listener to this RealmResults.
      *
      * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
-    public void addChangeListener(RealmChangeListener listener) {
+    public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
         realm.checkIfValid();
-        if (realm.handler == null) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+        if (!realm.handlerController.isAutoRefreshEnabled()) {
+            throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread. ");
         }
         if (!listeners.contains(listener)) {
             listeners.add(listener);
@@ -957,11 +938,13 @@ public void addChangeListener(RealmChangeListener listener) {
      * Removes a previously registered listener.
      *
      * @param listener the instance to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public void removeChangeListener(RealmChangeListener listener) {
-        if (listener == null)
+        if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
-
+        }
         realm.checkIfValid();
         listeners.remove(listener);
     }
@@ -991,12 +974,19 @@ public void removeChangeListeners() {
      * }
      * </pre>
      *
+     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
      * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
+
     @SuppressWarnings("unchecked")
+    @OptionalAPI(dependencies = {"rx.Observable"})
     public Observable<RealmResults<E>> asObservable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
@@ -1013,15 +1003,10 @@ public void removeChangeListeners() {
 
     /**
      * Notifies all registered listeners.
+     *
+     * NOTE: Remember to call `syncIfNeeded` before calling this method.
      */
-    void notifyChangeListeners() {
-        notifyChangeListeners(true, false);
-    }
-
-    private void notifyChangeListeners(boolean syncBeforeNotifying, boolean forceNotify) {
-        if (syncBeforeNotifying) {
-            syncIfNeeded();
-        }
+    void notifyChangeListeners(boolean forceNotify) {
         if (!listeners.isEmpty()) {
             // table might be null (if the async query didn't complete
             // but we have already registered listeners for it)
@@ -1029,7 +1014,7 @@ private void notifyChangeListeners(boolean syncBeforeNotifying, boolean forceNot
             if (!viewUpdated && !forceNotify) return;
             viewUpdated = false;
             for (RealmChangeListener listener : listeners) {
-                listener.onChange();
+                listener.onChange(this);
             }
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index aca535075f..d7624d66f0 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -30,8 +30,8 @@
 /**
  * Class for interacting with the Realm schema using a dynamic API. This makes it possible
  * to add, delete and change the classes in the Realm.
- *
- * All changes must happen inside a write transaction for that Realm.
+ * <p>
+ * All changes must happen inside a write transaction for the particular Realm.
  *
  * @see io.realm.RealmMigration
  */
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index 71329ed351..ae187baff1 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -19,7 +19,6 @@
 /**
  * This class describes the sorting order used in Realm queries.
  *
- * @see io.realm.Realm#allObjectsSorted(Class, String, Sort)
  * @see io.realm.RealmQuery#findAllSorted(String, Sort)
  */
 public enum Sort {
@@ -34,7 +33,7 @@
 
     /**
      * Returns the value for this setting that is used by the underlying query engine.
-     * @return The value used by the underlying query engine to indicate this value.
+     * @return the value used by the underlying query engine to indicate this value.
      */
     public boolean getValue() {
         return value;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java b/realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java
similarity index 50%
rename from realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
rename to realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java
index 5dcb1a61a0..d1135bef12 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/IncompatibleLockFileException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,24 +14,22 @@
  * limitations under the License.
  */
 
-package io.realm.internal;
+package io.realm.exceptions;
 
-@SuppressWarnings("serial")
-public class IllegalMixedTypeException extends RuntimeException {
+import io.realm.internal.Keep;
 
-    public IllegalMixedTypeException(Throwable cause) {
-        super(cause);
-    }
-
-    public IllegalMixedTypeException() {
-    }
+/**
+ * Triggered from the JNI level when there was something wrong with the lock file.
+ * This can happen if two different versions of Realm tries to access the same file concurrently.
+ */
+@Keep
+public class IncompatibleLockFileException extends RealmIOException {
 
-    public IllegalMixedTypeException(String message) {
-        super(message);
+    public IncompatibleLockFileException(String detailMessage) {
+        super(detailMessage);
     }
 
-    public IllegalMixedTypeException(String message, Throwable cause) {
-        super(message, cause);
+    public IncompatibleLockFileException(String detailMessage, Throwable exception) {
+        super(detailMessage, exception);
     }
-
 }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
index 845093fbc7..3d59ed049e 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
@@ -22,7 +22,7 @@
  * Class for reporting problems with Realm files.
  */
 @Keep
-public final class RealmIOException extends RuntimeException {
+public class RealmIOException extends RuntimeException {
 
     public RealmIOException(Throwable cause) {
         super(cause);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 60e9d56d1e..42c89a20c1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -120,22 +120,19 @@ public void setNull(long columnIndex) {
     protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
     protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
     protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetTimestamp(long nativeRowPtr, long columnIndex);
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
     protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
     protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java b/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
deleted file mode 100644
index c4ed8e4632..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * This annotation is used to mark the classes that serve as entity description.
- * For each such class, e.g. Xyz, the classes XyzTable, XyzView, XyzRow and XyzQuery will be generated.
- */
-@Retention(RetentionPolicy.SOURCE)
-@Target(ElementType.TYPE)
-public @interface DefineTable {
-
-    String row() default "";
-
-    String table() default "";
-
-    String view() default "";
-
-    String query() default "";
-
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Group.java b/realm/realm-library/src/main/java/io/realm/internal/Group.java
index 3b5cc85ef2..d02022fdec 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Group.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Group.java
@@ -281,7 +281,6 @@ public String toString() {
     protected native boolean nativeHasTable(long nativeGroupPtr, String name);
     protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray) throws IOException;
     protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
-    protected native long nativeLoadFromMem(byte[] buffer);
     protected native byte[] nativeWriteToMem(long nativeGroupPtr);
     protected native String nativeToJson(long nativeGroupPtr);
     protected native void nativeCommit(long nativeGroupPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java b/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
new file mode 100644
index 0000000000..029c91bc02
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * This class is to share some Android handler related constants between package {@link io.realm} and
+ * {@link io.realm.internal.async}.
+ */
+public final class HandlerControllerConstants {
+    public static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
+    public static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
+    public static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
+    public static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
+    public static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+    public static final int LOCAL_COMMIT = 165580141;
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
index cb708bf4ac..eab9406359 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -93,16 +93,6 @@ public String getString(long columnIndex) {
         throw getStubException();
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex) {
-        throw getStubException();
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex) {
-        throw getStubException();
-    }
-
     @Override
     public long getLink(long columnIndex) {
         throw getStubException();
@@ -153,11 +143,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
         throw getStubException();
     }
 
-    @Override
-    public void setMixed(long columnIndex, Mixed data) {
-        throw getStubException();
-    }
-
     @Override
     public void setLink(long columnIndex, long value) {
         throw getStubException();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index 3e6869ffeb..2a92a7ba92 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -167,15 +167,15 @@ private void checkImmutable() {
         }
     }
 
-    static native void nativeClose(long nativeLinkViewPtr);
+    public static native void nativeClose(long nativeLinkViewPtr);
     native long nativeGetRow(long nativeLinkViewPtr, long pos);
     private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
-    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
+    public static native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
     private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
     private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
     private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
     private native void nativeRemove(long nativeLinkViewPtr, long pos);
-    private native void nativeClear(long nativeLinkViewPtr);
+    public static native void nativeClear(long nativeLinkViewPtr);
     private native long nativeSize(long nativeLinkViewPtr);
     private native boolean nativeIsEmpty(long nativeLinkViewPtr);
     protected native long nativeWhere(long nativeLinkViewPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Mixed.java b/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
deleted file mode 100644
index af103c077b..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-
-public class Mixed {
-
-    public static final int BINARY_TYPE_BYTE_ARRAY = 0;
-    public static final int BINARY_TYPE_BYTE_BUFFER = 1;
-
-    private Object value;
-
-    public Mixed(long value) {
-        this.value = value;
-    }
-
-    public Mixed(float value) {
-        this.value = value;
-    }
-
-    public Mixed(double value) {
-        this.value = value;
-    }
-
-    public Mixed(RealmFieldType columnType) {
-        // It's actually ok to call with any columnType - it will however be assumed to be a ColumnTypeTable.
-        if (columnType == null  || columnType == RealmFieldType.UNSUPPORTED_TABLE) {
-            throw new AssertionError();
-        }
-        this.value = null;
-    }
-
-    public Mixed(boolean value) {
-        this.value = value ? Boolean.TRUE : Boolean.FALSE;
-    }
-
-    public Mixed(Date value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(String value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(ByteBuffer value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(byte[] value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-
-        Mixed mixed = (Mixed) obj;
-
-        if (value.getClass() != mixed.value.getClass()) {
-            return false;
-        }
-
-        if (value instanceof byte[]) {
-            return Arrays.equals((byte[]) value, (byte[]) mixed.value);
-        }
-        if (value instanceof ByteBuffer) {
-            return ((ByteBuffer) value).compareTo((ByteBuffer) mixed.value) == 0;
-        }
-        return value.equals(mixed.value);
-    }
-
-    @Override
-    public int hashCode() {
-        if (value instanceof byte[]) {
-            return Arrays.hashCode((byte[]) value);
-        }
-        return value.hashCode();
-    }
-
-    public RealmFieldType getType() {
-        if (value == null) {
-            return RealmFieldType.UNSUPPORTED_TABLE;
-        }
-        if (value instanceof String)
-            return RealmFieldType.STRING;
-        else if (value instanceof Long)
-            return RealmFieldType.INTEGER;
-        else if (value instanceof Float)
-            return RealmFieldType.FLOAT;
-        else if (value instanceof Double)
-            return RealmFieldType.DOUBLE;
-        else if (value instanceof Date)
-            return RealmFieldType.DATE;
-        else if (value instanceof Boolean)
-            return RealmFieldType.BOOLEAN;
-        else if (value instanceof ByteBuffer || (value instanceof byte[])) {
-            return RealmFieldType.BINARY;
-        }
-
-        throw new IllegalStateException("Unknown column type!");
-    }
-
-    public static Mixed mixedValue(Object value) {
-        // TODO: Isn't it a slow way to convert? Can it be done faster?
-        if (value instanceof String) {
-            return new Mixed((String) value);
-        } else if (value instanceof Long) {
-            return new Mixed((Long) value);
-        } else if (value instanceof Integer) {
-            return new Mixed(((Integer)value).longValue());
-        } else if (value instanceof Boolean) {
-            return new Mixed((Boolean) value);
-        } else if (value instanceof Float) {
-            return new Mixed((Float) value);
-        } else if (value instanceof Double) {
-            return new Mixed((Double) value);
-        } else if (value instanceof Date) {
-            return new Mixed((Date) value);
-        } else if (value instanceof ByteBuffer) {
-            return new Mixed((ByteBuffer) value);
-        } else if (value instanceof byte[]) {
-            return new Mixed((byte[]) value);
-        } else if (value instanceof Mixed) {
-            return ((Mixed)(value));
-        } else {
-            throw new IllegalArgumentException("The value is of unsupported type: " + value.getClass());
-        }
-    }
-
-    public long getLongValue() {
-        if (!(value instanceof Long)) {
-            throw new IllegalMixedTypeException("Can't get a long from a Mixed containing a " + getType());
-        }
-        return (Long) value;
-    }
-
-    public boolean getBooleanValue() {
-        if (!(value instanceof Boolean))
-            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containing a " + getType());
-        return (Boolean) value;
-    }
-
-    public float getFloatValue() {
-        if (!(value instanceof Float))
-            throw new IllegalMixedTypeException("Can't get a float from a Mixed containing a " + getType());
-        return (Float) value;
-    }
-
-    public double getDoubleValue() {
-        if (!(value instanceof Double))
-            throw new IllegalMixedTypeException("Can't get a double from a Mixed containing a " + getType());
-        return (Double) value;
-    }
-
-    public String getStringValue() {
-        if (!(value instanceof String))
-            throw new IllegalMixedTypeException("Can't get a String from a Mixed containing a " + getType());
-        return (String) value;
-    }
-
-    public Date getDateValue() {
-        if (!(value instanceof Date)) {
-            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containing a " + getType());
-        }
-        return (Date) value;
-    }
-
-    protected long getDateTimeValue() {
-        return getDateValue().getTime();
-    }
-
-    public ByteBuffer getBinaryValue() {
-        if (!(value instanceof ByteBuffer)) {
-            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containing a " + getType());
-        }
-        return (ByteBuffer) value;
-    }
-
-    public byte[] getBinaryByteArray() {
-        if (!(value instanceof byte[])) {
-            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containing a " + getType());
-        }
-        return (byte[]) value;
-    }
-
-    public int getBinaryType() {
-        if (value instanceof byte[]) {
-            return BINARY_TYPE_BYTE_ARRAY;
-        }
-        if (value instanceof ByteBuffer) {
-            return BINARY_TYPE_BYTE_BUFFER;
-        }
-        return -1;
-    }
-
-    public Object getValue() {
-        return value;
-    }
-
-    public String getReadableValue() {
-        RealmFieldType type = getType();
-        try {
-            switch (type) {
-            case BINARY:
-                return "Binary";
-            case BOOLEAN:
-                return String.valueOf(getBooleanValue());
-            case DATE:
-                return String.valueOf(getDateValue());
-            case DOUBLE:
-                return String.valueOf(getDoubleValue());
-            case FLOAT:
-                return String.valueOf(getFloatValue());
-            case INTEGER:
-                return String.valueOf(getLongValue());
-            case STRING:
-                return String.valueOf(getStringValue());
-            case UNSUPPORTED_TABLE:
-                return "Subtable";
-            case UNSUPPORTED_MIXED:
-                break; // error
-            }
-        } catch (Exception ignored) {
-        }
-        return "ERROR";
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index e2700ee8cd..0b1256a1ed 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -21,6 +21,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -93,17 +94,59 @@
     public abstract Set<Class<? extends RealmModel>> getModelClasses();
 
     /**
-     * Copies a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
+     * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
      * any changes to the original object will not be persisted.
      *
+     * @param realm reference to the {@link Realm} where the object will be copied.
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
      * {@code false} otherwise.
-     * @param cache the cache for mapping between standalone objects and their {@link RealmObjectProxy} representation.
+     * @param cache the cache for mapping between unmanaged objects and their {@link RealmObjectProxy} representation.
      * @return the managed Realm object.
      */
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
 
+    /**
+     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the object will be inserted.
+     * @param object {@link RealmObject} to insert.
+     * @param cache the cache for mapping between unmanaged objects and their table row index for eventual reuse.
+     */
+    public abstract void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
+
+    /**
+     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objecs will be inserted.
+     * @param object {@link RealmObject} to insert.
+     * @param cache the cache for mapping between unmanaged objects and their table row index for eventual reuse.
+     */
+    public abstract void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
+
+    /**
+     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objects will be inserted.
+     * @param objects Collection of {@link RealmObject} to insert or update. This must not be empty.
+     */
+    public abstract void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects);
+
+    /**
+     * Insert a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks. After being inserted any changes to the original objects will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objects will be inserted.
+     * @param objects Collection of {@link RealmObject} to insert or update. This must not be empty.
+     */
+    public abstract void insert(Realm realm, Collection<? extends RealmModel> objects);
+
     /**
      * Creates or updates a {@link RealmObject} using the provided JSON data.
      *
@@ -129,13 +172,13 @@
     public abstract <E extends RealmModel> E createUsingJsonStream(Class<E> clazz, Realm realm, JsonReader reader) throws java.io.IOException;
 
     /**
-     * Creates a deep standalone copy of a RealmObject. This is a deep copy so all links will be copied as well.
+     * Creates a deep unmanaged copy of a RealmObject. This is a deep copy so all links will be copied as well.
      * The depth can be restricted to a maximum depth after which all links will be turned into null values instead.
      *
      * @param realmObject RealmObject to copy. It must be a valid object.
      * @param maxDepth restrict the depth of the copy to this level. The root object is depth {@code 0}.
-     * @param cache cache used to make sure standalone objects are reused correctly.
-     * @return a standalone copy of the given object.
+     * @param cache cache used to make sure unmanaged objects are reused correctly.
+     * @return an unmanaged copy of the given object.
      */
     public abstract <E extends RealmModel> E createDetachedCopy(E realmObject, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index d61a0bc531..b63f85fd34 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -69,10 +69,6 @@
 
     byte[] getBinaryByteArray(long columnIndex);
 
-    Mixed getMixed(long columnIndex);
-
-    RealmFieldType getMixedType(long columnIndex);
-
     long getLink(long columnIndex);
 
     boolean isNullLink(long columnIndex);
@@ -93,8 +89,6 @@
 
     void setBinaryByteArray(long columnIndex, byte[] data);
 
-    void setMixed(long columnIndex, Mixed data);
-
     void setLink(long columnIndex, long value);
 
     void nullifyLink(long columnIndex);
@@ -119,8 +113,8 @@
     boolean hasColumn(String fieldName);
 
     Row EMPTY_ROW = new Row() {
-        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded, make sure the instance" +
-                " is loaded by calling RealmObject.isLoaded().";
+        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded or represents 'null', " +
+                "make sure the instance is loaded and is valid by calling 'RealmObject.isLoaded() && RealmObject.isValid()'.";
 
         @Override
         public long getColumnCount() {
@@ -187,16 +181,6 @@ public String getString(long columnIndex) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
         }
 
-        @Override
-        public Mixed getMixed(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public RealmFieldType getMixedType(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
         @Override
         public long getLink(long columnIndex) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
@@ -257,11 +241,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
         }
 
-        @Override
-        public void setMixed(long columnIndex, Mixed data) {
-            throw new IllegalStateException();
-        }
-
         @Override
         public void setLink(long columnIndex, long value) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
index 2f42292b51..da20dd4114 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
@@ -18,12 +18,21 @@
 
 import java.io.Closeable;
 import java.io.IOError;
+import java.util.concurrent.TimeUnit;
 
+import io.realm.exceptions.IncompatibleLockFileException;
+import io.realm.exceptions.RealmError;
 import io.realm.exceptions.RealmIOException;
 import io.realm.internal.async.BadVersionException;
+import io.realm.internal.log.RealmLog;
 
 public class SharedGroup implements Closeable {
 
+    // Keep these public so we can ask users to experiment with these values if needed.
+    // Should be locked down as soon as possible.
+    public static long[] INCREMENTAL_BACKOFF_MS = new long[] {1, 10, 20, 50, 100, 200, 400}; // Will keep re-using last value until LIMIT is hit
+    public static long INCREMENTAL_BACKOFF_LIMIT_MS = 3000;
+
     public static final boolean IMPLICIT_TRANSACTION = true;
     public static final boolean EXPLICIT_TRANSACTION = false;
 
@@ -51,6 +60,7 @@
         }
     }
 
+    // TODO Only used by Unit tests. Remove?
     public SharedGroup(String databaseFile) {
         context = new Context();
         path = databaseFile;
@@ -61,8 +71,7 @@ public SharedGroup(String databaseFile) {
     public SharedGroup(String canonicalPath, boolean enableImplicitTransactions, Durability durability, byte[] key) {
         if (enableImplicitTransactions) {
             nativeReplicationPtr = nativeCreateReplication(canonicalPath, key);
-            nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr,
-                    durability.value, key);
+            nativePtr = openSharedGroupOrFail(durability, key);
             implicitTransactionsEnabled = true;
         } else {
             nativePtr = nativeCreate(canonicalPath, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, key);
@@ -72,6 +81,51 @@ public SharedGroup(String canonicalPath, boolean enableImplicitTransactions, Dur
         checkNativePtrNotZero();
     }
 
+    private long openSharedGroupOrFail(Durability durability, byte[] key) {
+        // We have anecdotal evidence that on some versions of Android it is possible for two versions of an app
+        // to exist in two processes during an app upgrade. This is problematic since the lock file might not be
+        // compatible across two versions of Android. See https://github.com/realm/realm-java/issues/2459. If this
+        // happens we assume the overlap is really small so instead of failing outright we retry using incremental
+        // backoff.
+        int i = 0;
+        final long start = System.nanoTime();
+        RuntimeException lastError = null;
+        while (TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS) < INCREMENTAL_BACKOFF_LIMIT_MS) {
+            try {
+                long nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr, durability.value, key);
+                if (i > 0) {
+                    RealmLog.w("IncompatibleLockFile was detected. Error was resolved after " + i + " retries");
+                }
+                return nativePtr;
+            } catch (IncompatibleLockFileException e) {
+                i++;
+                lastError = e;
+                try {
+                    Thread.sleep(getSleepTime(i));
+                    RealmLog.d("Waiting for another process to release the Realm file: " + path);
+                } catch (InterruptedException ignored) {
+                    RealmLog.d("Waiting for Realm to open interrupted: " + path);
+                }
+            }
+        }
+
+        throw new RealmError("Could not open the Realm file: " + lastError.getMessage());
+    }
+
+    // Returns the time to sleep before retrying opening the SharedGroup.
+    private static long getSleepTime(int tries) {
+        if (INCREMENTAL_BACKOFF_MS == null) {
+            return 0;
+        } else {
+            if (tries > INCREMENTAL_BACKOFF_MS.length) {
+                return INCREMENTAL_BACKOFF_MS[INCREMENTAL_BACKOFF_MS.length - 1];
+            } else {
+                return INCREMENTAL_BACKOFF_MS[tries - 1];
+            }
+        }
+    }
+
+    // TODO Only used by Unit tests. Remove?
     public SharedGroup(String canonicalPath, Durability durability, byte[] key) {
         path = canonicalPath;
         context = new Context();
@@ -293,12 +347,27 @@ public int hashCode() {
         }
     }
 
+    /**
+     * Waits for change committed by {@link SharedGroup} in other Thread.
+     *
+     * @return {@code true} if successfully detects change, {@code false} no change has been detected otherwise.
+     */
+    public boolean waitForChange() {
+        return nativeWaitForChange(nativePtr);
+    }
+
+    /**
+     * Stops waiting for change.
+     */
+    public void stopWaitForChange() {
+        nativeStopWaitForChange(nativePtr);
+    }
+
     private native long createNativeWithImplicitTransactions(long nativeReplicationPtr,
                                                              int durability, byte[] key);
     private native long nativeCreateReplication(String databaseFile, byte[] key);
     private native void nativeCommitAndContinueAsRead(long nativePtr);
     private native long nativeBeginImplicit(long nativePtr);
-    private native String nativeGetDefaultReplicationDatabaseFileName();
 
     private native void nativeReserve(long nativePtr, long bytes);
     private native boolean nativeHasChanged(long nativePtr);
@@ -317,6 +386,8 @@ private native long nativeCreate(String databaseFile,
     private native void nativeCloseReplication(long nativeReplicationPtr);
     private native void nativeRollbackAndContinueAsRead(long nativePtr);
     private native long[] nativeGetVersionID (long nativePtr);
+    private native boolean nativeWaitForChange(long nativePtr);
+    private native void nativeStopWaitForChange(long nativePtr);
     private native void nativeAdvanceRead(long nativePtr);
     private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index) throws BadVersionException;
     private native void nativePromoteToWrite(long nativePtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
deleted file mode 100644
index dda38d3e5a..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import io.realm.RealmFieldType;
-
-public class SubtableSchema implements TableSchema {
-
-    private long[] path;
-    private long parentNativePtr;
-
-    SubtableSchema(long parentNativePtr, long[] path) {
-        this.parentNativePtr = parentNativePtr;
-        this.path = path;
-    }
-
-    @Override
-    public SubtableSchema getSubtableSchema(long columnIndex) {
-        long[] newPath = new long[path.length + 1];
-        System.arraycopy(path, 0, newPath, 0, path.length);
-        newPath[path.length] = columnIndex;
-        return new SubtableSchema(this.parentNativePtr, newPath);
-    }
-
-    private void verifyColumnName(String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-    }
-
-    @Override
-    public long addColumn(RealmFieldType type, String name) {
-        verifyColumnName(name);
-        return nativeAddColumn(parentNativePtr, path, type.getNativeValue(), name);
-    }
-
-    protected native long nativeAddColumn(long nativeTablePtr, long[] path, int type, String name);
-
-    /**
-     * Removes a column in the table dynamically.
-     */
-    @Override
-    public void removeColumn(long columnIndex) {
-        nativeRemoveColumn(parentNativePtr, path, columnIndex);
-    }
-
-    protected native void nativeRemoveColumn(long nativeTablePtr, long[] path, long columnIndex);
-
-    /**
-     * Renames a column in the table.
-     */
-    @Override
-    public void renameColumn(long columnIndex, String newName) {
-        verifyColumnName(newName);
-        nativeRenameColumn(parentNativePtr, path, columnIndex, newName);
-    }
-
-    protected native void nativeRenameColumn(long nativeTablePtr, long[] path, long columnIndex, String name);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 724286ae04..84b8696654 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -99,6 +99,10 @@ public Table getTable() {
         return this;
     }
 
+    public long getNativeTablePointer() {
+        return nativePtr;
+    }
+
     // If close() is called, no penalty is paid for delayed disposal
     // via the context
     @Override
@@ -146,17 +150,6 @@ private void verifyColumnName(String name) {
         }
     }
 
-    @Override
-    public TableSchema getSubtableSchema(long columnIndex) {
-        if (!nativeIsRootTable(nativePtr)) {
-            throw new UnsupportedOperationException("This is a subtable. Can only be called on root table.");
-        }
-
-        long[] newPath = new long[1];
-        newPath[0] = columnIndex;
-        return new SubtableSchema(nativePtr, newPath);
-    }
-
     /**
      * Adds a column to the table dynamically.
      *
@@ -191,20 +184,82 @@ public long addColumnLink (RealmFieldType type, String name, Table table) {
     }
 
     /**
-     * Removes a column in the table dynamically.
+     * Removes a column in the table dynamically. if {@code columnIndex} is smaller than the primary
+     * key column index, {@link #invalidateCachedPrimaryKeyIndex()} will be called to recalculate the
+     * primary key column index.
+     *
+     * <p>It should be noted if {@code columnIndex} is the same as the primary key column index,
+     * the primary key column is removed from the meta table.
+     *
+     * @param columnIndex the column index to be removed.
      */
     @Override
     public void removeColumn(long columnIndex) {
+        // Check the PK column index before removing a column. We don't know if we're hitting a PK col,
+        // but it should be noted that once a column is removed, there is no way we can find whether
+        // a PK exists or not.
+        final long oldPkColumnIndex = getPrimaryKey();
+
+        // firstly remove a column. If there is no error, we can proceed. Otherwise, it will stop here.
         nativeRemoveColumn(nativePtr, columnIndex);
+
+        // Check if a PK exists and take actions if there is. This is same as hasPrimaryKey(), but
+        // this relies on the local cache.
+        if (oldPkColumnIndex >= 0) {
+
+            // In case we're hitting PK column, we should remove the PK as it is either 1) a user has
+            // forgotten to remove PK or 2) removeColumn gets called before setPrimaryKey(null) is called.
+            // Since there is no danger in removing PK twice, we'll do it here to be on safe side.
+            if (oldPkColumnIndex == columnIndex) {
+                setPrimaryKey(null);
+
+            // But if you remove a column with a smaller index than that of PK column, you need to
+            // recalculate the PK column index as core could have changed its column index.
+            } else if (oldPkColumnIndex > columnIndex) {
+                invalidateCachedPrimaryKeyIndex();
+            }
+        }
     }
 
     /**
-     * Renames a column in the table.
+     * Renames a column in the table. If the column is a primary key column, the corresponding entry
+     * in PrimaryKeyTable will be renamed accordingly.
+     *
+     * @param columnIndex the column index to be renamed.
+     * @param newName a new name replacing the old column name.
+     * @throws {@link IllegalArgumentException} if {@code newFieldName} is an empty string, or exceeds field name length limit.
+     * @throws {@link IllegalStateException} if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
      */
     @Override
     public void renameColumn(long columnIndex, String newName) {
         verifyColumnName(newName);
+        // get the old column name. We'll assume that the old column name is *NOT* an empty string.
+        final String oldName = nativeGetColumnName(nativePtr, columnIndex);
+        // also old pk index. Once a column name changes, there is no way you can find the column name
+        // by old name.
+        final long oldPkColumnIndex = getPrimaryKey();
+
+        // then let's try to rename a column. If an error occurs for some reasons, we'll throw.
         nativeRenameColumn(nativePtr, columnIndex, newName);
+
+        // Rename a primary key. At this point, renaming the column name should have been fine.
+        if (oldPkColumnIndex == columnIndex) {
+            try {
+                String className = tableNameToClassName(getName());
+                Table pkTable = getPrimaryKeyTable();
+                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
+                if (pkRowIndex != NO_MATCH) {
+                    pkTable.setString(PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName);
+                } else {
+                    throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
+                }
+            } catch (Exception e) {
+                // we failed to rename the pk meta table. roll back the column name, not pk meta table
+                // then rethrow.
+                nativeRenameColumn(nativePtr, columnIndex, oldName);
+                throw e;
+            }
+        }
     }
 
     /**
@@ -235,14 +290,6 @@ public void convertColumnToNotNullable(long columnIndex) {
         nativeConvertColumnToNotNullable(nativePtr, columnIndex);
     }
 
-    /**
-     * Updates a table specification from a Table specification structure.
-     */
-    public void updateFromSpec(TableSpec tableSpec) {
-        checkImmutable();
-        nativeUpdateFromSpec(nativePtr, tableSpec);
-    }
-
     // Table Size and deletion. AutoGenerated subclasses are nothing to do with this
     // class.
     /**
@@ -285,10 +332,6 @@ public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
     }
 
-    public TableSpec getTableSpec(){
-        return nativeGetTableSpec(nativePtr);
-    }
-
     /**
      * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
      *
@@ -529,21 +572,15 @@ protected long add(Object... values) {
             case DATE:
                 if (value == null)
                     throw new IllegalArgumentException("Null Date is not allowed.");
-                nativeSetDate(nativePtr, columnIndex, rowIndex, ((Date) value).getTime() / 1000);
-                break;
-            case UNSUPPORTED_MIXED:
-                if (value == null)
-                    throw new IllegalArgumentException("Null Mixed data is not allowed");
-                nativeSetMixed(nativePtr, columnIndex, rowIndex, Mixed.mixedValue(value));
+                nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
                 break;
             case BINARY:
                 if (value == null)
                     throw new IllegalArgumentException("Null Array is not allowed");
                 nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
                 break;
+            case UNSUPPORTED_MIXED:
             case UNSUPPORTED_TABLE:
-                insertSubTable(columnIndex, rowIndex, value);
-                break;
             default:
                 throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int)columnIndex]));
             }
@@ -674,13 +711,19 @@ void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
                     }
                     break;
                 default:
-                    // Since it is sufficient to check the existance of duplicated null values
+                    // Since it is sufficient to check the existence of duplicated null values
                     // on PrimaryKey in supported types only, this part is left empty.
             }
         }
     }
 
-    private void throwDuplicatePrimaryKeyException(Object value) {
+    /**
+     * Throws a properly formatted exception when multiple objects with the same primary key
+     * value is detected.
+     *
+     * @param value the primary key value.
+     */
+    public static void throwDuplicatePrimaryKeyException(Object value) {
         throw new RealmPrimaryKeyConstraintException("Value already exists: " + value);
     }
 
@@ -710,7 +753,7 @@ public double getDouble(long columnIndex, long rowIndex) {
 
     @Override
     public Date getDate(long columnIndex, long rowIndex) {
-        return new Date(nativeGetDateTime(nativePtr, columnIndex, rowIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
     }
 
     /**
@@ -746,16 +789,6 @@ public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex, long rowIndex) {
-        return nativeGetMixed(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
-    }
-
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
@@ -774,55 +807,6 @@ public Table getLinkTarget(long columnIndex) {
         }
     }
 
-    /**
-     *
-     * Note: The subtable returned will have to be closed again after use.
-     * You can let javas garbage collector handle that or better yet call close() after use.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @return the TableBase the subtable at the requested.
-     */
-    @Override
-    public Table getSubtable(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr = nativeGetSubtable(nativePtr, columnIndex, rowIndex);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    // Below version will allow to getSubtable when number of available rows are not updated yet -
-    // which happens before an insertDone().
-
-    private Table getSubtableDuringInsert(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr =  nativeGetSubtableDuringInsert(nativePtr, columnIndex, rowIndex);
-        try {
-            return new Table(context, this, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    public long getSubtableSize(long columnIndex, long rowIndex) {
-        return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
-    }
-
-    public void clearSubtable(long columnIndex, long rowIndex) {
-        checkImmutable();
-        nativeClearSubtable(nativePtr, columnIndex, rowIndex);
-    }
-
     /**
      * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
      * If error checking is required, use {@link #getCheckedRow(long)} instead.
@@ -892,7 +876,7 @@ public void setDate(long columnIndex, long rowIndex, Date date) {
         if (date == null)
             throw new IllegalArgumentException("Null Date is not allowed.");
         checkImmutable();
-        nativeSetDate(nativePtr, columnIndex, rowIndex, date.getTime() / 1000);
+        nativeSetTimestamp(nativePtr, columnIndex, rowIndex, date.getTime());
     }
 
     /**
@@ -944,40 +928,11 @@ public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data) {
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    /**
-     * Sets the value for a (mixed typed) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the value.
-     */
-    @Override
-    public void setMixed(long columnIndex, long rowIndex, Mixed data) {
-        checkImmutable();
-        if (data == null)
-            throw new IllegalArgumentException();
-        nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
-    }
-
     public void setLink(long columnIndex, long rowIndex, long value) {
         checkImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
-    //TODO: Clean up this function
-    private void insertSubTable(long columnIndex, long rowIndex, Object value) {
-        checkImmutable();
-        if (value != null) {
-            // insert rows in subtable recursively
-            Table subtable = getSubtableDuringInsert(columnIndex, rowIndex);
-            int rows = ((Object[])value).length;
-            for (int i=0; i<rows; ++i) {
-                Object rowArr = ((Object[])value)[i];
-                subtable.add((Object[])rowArr);
-            }
-        }
-    }
-
     public void addSearchIndex(long columnIndex) {
         checkImmutable();
         nativeAddSearchIndex(nativePtr, columnIndex);
@@ -1025,6 +980,13 @@ private Table getPrimaryKeyTable() {
         return pkTable;
     }
 
+    /**
+     * Invalidating a cached primary key column index for the table.
+     */
+    private void invalidateCachedPrimaryKeyIndex() {
+        cachedPrimaryKeyColumnIndex = NO_MATCH;
+    }
+
     /*
      * 1) Migration required to fix https://github.com/realm/realm-java/issues/1059
      * This will convert INTEGER column to the corresponding STRING column if needed.
@@ -1152,12 +1114,12 @@ public double averageDouble(long columnIndex) {
 
     @Override
     public Date maximumDate(long columnIndex) {
-        return new Date(nativeMaximumDate(nativePtr, columnIndex) * 1000);
+        return new Date(nativeMaximumTimestamp(nativePtr, columnIndex));
     }
 
     @Override
     public Date minimumDate(long columnIndex) {
-        return new Date(nativeMinimumDate(nativePtr, columnIndex) * 1000);
+        return new Date(nativeMinimumTimestamp(nativePtr, columnIndex));
     }
 
     //
@@ -1237,7 +1199,7 @@ public long findFirstDate(long columnIndex, Date date) {
         if (date == null) {
             throw new IllegalArgumentException("null is not supported");
         }
-        return nativeFindFirstDate(nativePtr, columnIndex, date.getTime() / 1000);
+        return nativeFindFirstTimestamp(nativePtr, columnIndex, date.getTime());
     }
 
     @Override
@@ -1309,19 +1271,6 @@ public TableView findAllDouble(long columnIndex, double value) {
         }
     }
 
-    @Override
-    public TableView findAllDate(long columnIndex, Date date) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeFindAllDate(nativePtr, columnIndex, date.getTime() / 1000);
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
-    }
-
     @Override
     public TableView findAllString(long columnIndex, String value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
@@ -1393,17 +1342,34 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, INFINITE);
-    }
+        long columnCount = getColumnCount();
+        String name = getName();
+        StringBuilder stringBuilder = new StringBuilder("The Table ");
+        if (name != null && !name.isEmpty()) {
+            stringBuilder.append(getName());
+            stringBuilder.append(" ");
+        }
+        if (hasPrimaryKey()) {
+            String pkFieldName = getColumnName(getPrimaryKey());
+            stringBuilder.append("has \'" + pkFieldName + "\' field as a PrimaryKey, and ");
+        }
+        stringBuilder.append("contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
+
+        return stringBuilder.toString();
     }
 
     @Override
@@ -1464,53 +1430,45 @@ public static String tableNameToClassName(String tableName) {
     private native boolean nativeIsColumnNullable(long nativePtr, long columnIndex);
     private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex);
     private native void nativeConvertColumnToNotNullable(long nativePtr, long columnIndex);
-    private native void nativeUpdateFromSpec(long nativeTablePtr, TableSpec tableSpec);
     private native long nativeSize(long nativeTablePtr);
     private native void nativeClear(long nativeTablePtr);
     private native long nativeGetColumnCount(long nativeTablePtr);
-    private native TableSpec nativeGetTableSpec(long nativeTablePtr);
     private native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
     private native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
     private native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
     private native void nativeRemove(long nativeTablePtr, long rowIndex);
     private native void nativeRemoveLast(long nativeTablePtr);
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
-    private native long nativeAddEmptyRow(long nativeTablePtr, long rows);
+    public static native long nativeAddEmptyRow(long nativeTablePtr, long rows);
     private native long nativeGetSortedView(long nativeTableViewPtr, long columnIndex, boolean ascending);
     private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
     private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
     private native float nativeGetFloat(long nativeTablePtr, long columnIndex, long rowIndex);
     private native double nativeGetDouble(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetDateTime(long nativeTablePtr, long columnIndex, long rowIndex);
+    private native long nativeGetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativePtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-    private native int nativeGetMixedType(long nativePtr, long columnIndex, long rowIndex);
-    private native Mixed nativeGetMixed(long nativeTablePtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
-    private native long nativeGetSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableDuringInsert(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
     native long nativeGetRowPtr(long nativePtr, long index);
-    private native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-    private native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-    private native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-    private native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetDate(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
-    private native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-    private native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    private native void nativeSetMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed data);
-    private native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
+    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
+    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
+    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
+    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
+    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
     private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
     private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
     private native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
-    private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
+    public static native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeSumInt(long nativePtr, long columnIndex);
     private native long nativeMaximumInt(long nativePtr, long columnIndex);
     private native long nativeMinimumInt(long nativePtr, long columnIndex);
@@ -1523,25 +1481,25 @@ public static String tableNameToClassName(String tableName) {
     private native double nativeMaximumDouble(long nativePtr, long columnIndex);
     private native double nativeMinimumDouble(long nativePtr, long columnIndex);
     private native double nativeAverageDouble(long nativePtr, long columnIndex);
-    private native long nativeMaximumDate(long nativePtr, long columnIndex);
-    private native long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native long nativeMaximumTimestamp(long nativePtr, long columnIndex);
+    private native long nativeMinimumTimestamp(long nativePtr, long columnIndex);
     private native long nativeCountLong(long nativePtr, long columnIndex, long value);
     private native long nativeCountFloat(long nativePtr, long columnIndex, float value);
     private native long nativeCountDouble(long nativePtr, long columnIndex, double value);
     private native long nativeCountString(long nativePtr, long columnIndex, String value);
     private native long nativeWhere(long nativeTablePtr);
-    private native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
+    public static native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
     private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
-    private native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
-    private native long nativeFindFirstNull(long nativePtr, long columnIndex);
+    private native long nativeFindFirstTimestamp(long nativeTablePtr, long columnIndex, long dateTimeValue);
+    public static native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
+    public static native long nativeFindFirstNull(long nativeTablePtr, long columnIndex);
     private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
     private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
+    private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
     private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
     private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
     private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
@@ -1550,8 +1508,6 @@ public static String tableNameToClassName(String tableName) {
     private native String nativeGetName(long nativeTablePtr);
     private native void nativeOptimize(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
     private native long nativeVersion(long nativeTablePtr);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index cf080da4a8..9157aa37ed 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -137,8 +137,6 @@
 
     byte[] getBinaryByteArray(long columnIndex, long rowIndex);
 
-    Mixed getMixed(long columnIndex, long rowIndex);
-
     /**
      * Gets the link index of a cell of the table/view identified by the columnIndex and rowIndex.
      *
@@ -148,14 +146,6 @@
      */
     long getLink(long columnIndex, long rowIndex);
 
-    RealmFieldType getMixedType(long columnIndex, long rowIndex);
-
-    Table getSubtable(long columnIndex, long rowIndex);
-
-    void clearSubtable(long columnIndex, long rowIndex);
-
-    long getSubtableSize(long columnIndex, long rowIndex);
-
     /**
      * Sets the long value for a particular cell identified by columnIndex and rowIndex of that cell.
      *
@@ -215,8 +205,6 @@
 
     void setDate(long columnIndex, long rowIndex, Date date);
 
-    void setMixed(long columnIndex, long rowIndex, Mixed data);
-
     boolean isNullLink(long columnIndex, long rowIndex);
 
     void nullifyLink(long columnIndex, long rowIndex);
@@ -328,18 +316,12 @@
 
     TableView findAllDouble(long columnIndex, double value);
 
-    TableView findAllDate(long columnIndex, Date value);
-
     TableView findAllString(long columnIndex, String value);
 
     String toJson();
 
     String toString();
 
-    String toString(long maxRows);
-
-    String rowToString(long rowIndex);
-
     TableQuery where();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index b76d41f269..08db937eca 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -115,18 +115,6 @@ public TableQuery endGroup() {
         return this;
     }
 
-    public TableQuery subtable(long columnIndex) {
-        nativeSubtable(nativePtr, columnIndex);
-        queryValidated = false;
-        return this;
-    }
-
-    public TableQuery endSubtable() {
-        nativeParent(nativePtr);
-        queryValidated = false;
-        return this;
-    }
-
     public TableQuery or() {
         nativeOr(nativePtr);
         queryValidated = false;
@@ -287,7 +275,7 @@ public TableQuery equalTo(long columnIndex[], Date value){
         if (value == null) {
             nativeIsNull(nativePtr, columnIndex);
         } else {
-            nativeEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+            nativeEqualTimestamp(nativePtr, columnIndex, value.getTime());
         }
         queryValidated = false;
         return this;
@@ -296,7 +284,7 @@ public TableQuery equalTo(long columnIndex[], Date value){
     public TableQuery notEqualTo(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeNotEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -304,7 +292,7 @@ public TableQuery notEqualTo(long columnIndex[], Date value){
     public TableQuery greaterThan(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeGreaterDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -312,7 +300,7 @@ public TableQuery greaterThan(long columnIndex[], Date value){
     public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeGreaterEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -320,7 +308,7 @@ public TableQuery greaterThanOrEqual(long columnIndex[], Date value){
     public TableQuery lessThan(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeLessDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -328,7 +316,7 @@ public TableQuery lessThan(long columnIndex[], Date value){
     public TableQuery lessThanOrEqual(long columnIndex[], Date value){
         if (value == null)
             throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE);
-        nativeLessEqualDateTime(nativePtr, columnIndex, value.getTime()/1000);
+        nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
         queryValidated = false;
         return this;
     }
@@ -336,7 +324,7 @@ public TableQuery lessThanOrEqual(long columnIndex[], Date value){
     public TableQuery between(long columnIndex[], Date value1, Date value2){
         if (value1 == null || value2 == null)
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
-        nativeBetweenDateTime(nativePtr, columnIndex, value1.getTime()/1000, value2.getTime()/1000);
+        nativeBetweenTimestamp(nativePtr, columnIndex, value1.getTime(), value2.getTime());
         queryValidated = false;
         return this;
     }
@@ -655,24 +643,24 @@ public double averageDouble(long columnIndex) {
 
     public Date maximumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        Long result = nativeMaximumDate(nativePtr, columnIndex, start, end, limit);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex, start, end, limit);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
     public Date maximumDate(long columnIndex) {
         validateQuery();
-        Long result = nativeMaximumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
 
     public Date minimumDate(long columnIndex, long start, long end, long limit) {
         validateQuery();
-        Long result = nativeMinimumDate(nativePtr, columnIndex, start, end, limit);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex, start, end, limit);
         if (result != null) {
             return new Date(result * 1000);
         }
@@ -680,9 +668,9 @@ public Date minimumDate(long columnIndex, long start, long end, long limit) {
     }
     public Date minimumDate(long columnIndex) {
         validateQuery();
-        Long result = nativeMinimumDate(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex, 0, Table.INFINITE, Table.INFINITE);
         if (result != null) {
-            return new Date(result * 1000);
+            return new Date(result);
         }
         return null;
     }
@@ -746,8 +734,6 @@ private void throwImmutable() {
     private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
     private native void nativeGroup(long nativeQueryPtr);
     private native void nativeEndGroup(long nativeQueryPtr);
-    private native void nativeSubtable(long nativeQueryPtr, long columnIndex);
-    private native void nativeParent(long nativeQueryPtr);
     private native void nativeOr(long nativeQueryPtr);
     private native void nativeNot(long nativeQueryPtr);
     private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
@@ -772,13 +758,13 @@ private void throwImmutable() {
     private native void nativeLessEqual(long nativeQueryPtr, long columnIndex[], double value);
     private native void nativeBetween(long nativeQueryPtr, long columnIndex[], double value1, double value2);
     private native void nativeEqual(long nativeQueryPtr, long columnIndex[], boolean value);
-    private native void nativeEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeNotEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeGreaterDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeGreaterEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeLessDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeLessEqualDateTime(long nativeQueryPtr, long columnIndex[], long value);
-    private native void nativeBetweenDateTime(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
+    private native void nativeBetweenTimestamp(long nativeQueryPtr, long columnIndex[], long value1, long value2);
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
     private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
     private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
@@ -799,8 +785,8 @@ private void throwImmutable() {
     private native Double nativeMaximumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native Double nativeMinimumDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native double nativeAverageDouble(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-    private native Long nativeMaximumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
-    private native Long nativeMinimumDate(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMaximumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
+    private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
     private native void nativeIsNull(long nativePtr, long columnIndices[]);
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
index 0b7f8dfbe4..1a0f2528ae 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
@@ -21,8 +21,6 @@
 
 public interface TableSchema {
 
-    TableSchema getSubtableSchema(long columnIndex);
-
     long addColumn(RealmFieldType type, String name);
 
     void removeColumn(long columnIndex);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java b/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
deleted file mode 100644
index b3a7cfbcf6..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-@Keep
-public class TableSpec {
-
-    public static class ColumnInfo {
-
-        protected final RealmFieldType type;
-        protected final String name;
-        protected final TableSpec tableSpec;
-
-        public ColumnInfo(RealmFieldType type, String name) {
-            this.name = name;
-            this.type = type;
-            this.tableSpec = (type == RealmFieldType.UNSUPPORTED_TABLE) ? new TableSpec() : null;
-        }
-
-        @Override
-        public int hashCode() {
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((name == null) ? 0 : name.hashCode());
-            result = prime * result + ((tableSpec == null) ? 0 : tableSpec.hashCode());
-            result = prime * result + ((type == null) ? 0 : type.hashCode());
-            return result;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            ColumnInfo other = (ColumnInfo) obj;
-            if (name == null) {
-                if (other.name != null)
-                    return false;
-            } else if (!name.equals(other.name))
-                return false;
-            if (tableSpec == null) {
-                if (other.tableSpec != null)
-                    return false;
-            } else if (!tableSpec.equals(other.tableSpec))
-                return false;
-            if (type != other.type)
-                return false;
-            return true;
-        }
-    }
-
-    private List<ColumnInfo> columnInfos;
-
-    public TableSpec() {
-        columnInfos = new ArrayList<ColumnInfo>();
-    }
-
-    public void addColumn(RealmFieldType type, String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-        columnInfos.add(new ColumnInfo(type, name));
-    }
-
-    protected void addColumn(int colTypeIndex, String name) {
-        addColumn(RealmFieldType.fromNativeValue(colTypeIndex), name);
-    }
-
-    public TableSpec addSubtableColumn(String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-        ColumnInfo columnInfo = new ColumnInfo(RealmFieldType.UNSUPPORTED_TABLE, name);
-        columnInfos.add(columnInfo);
-        return columnInfo.tableSpec;
-    }
-
-    public TableSpec getSubtableSpec(long columnIndex) {
-        return columnInfos.get((int) columnIndex).tableSpec;
-    }
-
-    public long getColumnCount() {
-        return columnInfos.size();
-    }
-
-    public RealmFieldType getColumnType(long columnIndex) {
-        return columnInfos.get((int) columnIndex).type;
-    }
-
-    public String getColumnName(long columnIndex) {
-        return columnInfos.get((int) columnIndex).name;
-    }
-
-    public long getColumnIndex(String name) {
-        for (int i = 0; i < columnInfos.size(); i++) {
-            ColumnInfo columnInfo = columnInfos.get(i);
-            if (columnInfo.name.equals(name)) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((columnInfos == null) ? 0 : columnInfos.hashCode());
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        TableSpec other = (TableSpec) obj;
-        if (columnInfos == null) {
-            if (other.columnInfos != null)
-                return false;
-        } else if (!columnInfos.equals(other.columnInfos))
-            return false;
-        return true;
-    }
-
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index d30c5fab13..df97a3fb06 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -79,12 +79,12 @@ public void close() {
         synchronized (context) {
             if (nativePtr != 0) {
                 nativeClose(nativePtr);
-                
+
                 if (DEBUG) {
                     RealmLog.d("==== TableView CLOSE, ptr= " + nativePtr);
                 }
                 nativePtr = 0;
-            } 
+            }
         }
     }
 
@@ -230,7 +230,7 @@ public double getDouble(long columnIndex, long rowIndex){
      */
     @Override
     public Date getDate(long columnIndex, long rowIndex){
-        return new Date(nativeGetDateTimeValue(nativePtr, columnIndex, rowIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
     }
 
     /**
@@ -266,46 +266,10 @@ public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex){
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
-    }
-
-    @Override
-    public Mixed getMixed(long columnIndex, long rowIndex){
-        return nativeGetMixed(nativePtr, columnIndex, rowIndex);
-    }
-
     public long getLink(long columnIndex, long rowIndex){
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public Table getSubtable(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr = nativeGetSubtable(nativePtr, columnIndex, rowIndex);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this.parent, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            Table.nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    @Override
-    public long getSubtableSize(long columnIndex, long rowIndex) {
-        return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public void clearSubtable(long columnIndex, long rowIndex) {
-        if (parent.isImmutable()) throwImmutable();
-        nativeClearSubtable(nativePtr, columnIndex, rowIndex);
-    }
-
     // Methods for setting values.
 
     /**
@@ -370,7 +334,7 @@ public void setDouble(long columnIndex, long rowIndex, double value){
     @Override
     public void setDate(long columnIndex, long rowIndex, Date value){
         if (parent.isImmutable()) throwImmutable();
-        nativeSetDateTimeValue(nativePtr, columnIndex, rowIndex, value.getTime()/1000);
+        nativeSetTimestampValue(nativePtr, columnIndex, rowIndex, value.getTime());
     }
 
     /**
@@ -409,19 +373,6 @@ public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data){
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    /**
-     * Sets the value for a particular (mixed typed) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the value.
-     */
-    @Override
-    public void setMixed(long columnIndex, long rowIndex, Mixed data){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
-    }
-
     public void setLink(long columnIndex, long rowIndex, long value){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
@@ -493,7 +444,9 @@ public long findFirstDouble(long columnIndex, double value) {
 
     @Override
     public long findFirstDate(long columnIndex, Date date) {
-        return nativeFindFirstDate(nativePtr, columnIndex, date.getTime()/1000);
+        // FIXME: waiting for implementation
+        return NO_MATCH;
+        // return nativeFindFirstDate(nativePtr, columnIndex, date.getTime());
     }
 
     @Override
@@ -520,7 +473,7 @@ public TableView findAllLong(long columnIndex, long value){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
@@ -533,12 +486,12 @@ public TableView findAllBoolean(long columnIndex, boolean value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -546,12 +499,12 @@ public TableView findAllFloat(long columnIndex, float value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -559,25 +512,12 @@ public TableView findAllDouble(long columnIndex, double value) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        try { 
-            return new TableView(this.context, this.parent, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }   
-    }
-
-    @Override
-    public TableView findAllDate(long columnIndex, Date date) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeFindAllDate(nativePtr, columnIndex, date.getTime()/1000);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
             throw e;
-        }  
+        }
     }
 
     @Override
@@ -585,7 +525,7 @@ public TableView findAllString(long columnIndex, String value){
         // Execute the disposal of abandoned realm objects each time a new realm object is created
         context.executeDelayedDisposal();
         long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        try { 
+        try {
             return new TableView(this.context, this.parent, nativeViewPtr);
         } catch (RuntimeException e) {
             TableView.nativeClose(nativeViewPtr);
@@ -692,20 +632,20 @@ public double averageDouble(long columnIndex) {
 
     @Override
     public Date maximumDate(long columnIndex) {
-        Long result = nativeMaximumDate(nativePtr, columnIndex);
+        Long result = nativeMaximumTimestamp(nativePtr, columnIndex);
         if (result == null) {
             return null;
         }
-        return new Date(result * 1000);
+        return new Date(result);
     }
 
     @Override
     public Date minimumDate(long columnIndex) {
-        Long result = nativeMinimumDate(nativePtr, columnIndex);
+        Long result = nativeMinimumTimestamp(nativePtr, columnIndex);
         if (result == null) {
             return null;
         }
-        return new Date(result * 1000);
+        return new Date(result);
     }
 
     // Sorting
@@ -735,17 +675,24 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, 500);
-    }
+        long columnCount = getColumnCount();
+        StringBuilder stringBuilder = new StringBuilder("The TableView contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
+
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        return stringBuilder.toString();
     }
 
     @Override
@@ -854,23 +801,17 @@ public long syncIfNeeded() {
     private native boolean nativeGetBoolean(long nativeViewPtr, long columnIndex, long rowIndex);
     private native float nativeGetFloat(long nativeViewPtr, long columnIndex, long rowIndex);
     private native double nativeGetDouble(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetDateTimeValue(long nativeViewPtr, long columnIndex, long rowIndex);
+    private native long nativeGetTimestamp(long nativeViewPtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-    private native int nativeGetMixedType(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native Mixed nativeGetMixed(long nativeViewPtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtable(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
     private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
     private native void nativeSetDouble(long nativeViewPtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetDateTimeValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    private native void nativeSetTimestampValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
     private native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
     private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    private native void nativeSetMixed(long nativeViewPtr, long columnIndex, long rowIndex, Mixed value);
     private native void nativeSetLink(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
     private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
@@ -901,18 +842,16 @@ public long syncIfNeeded() {
     private native Double nativeMaximumDouble(long nativeViewPtr, long columnIndex);
     private native Double nativeMinimumDouble(long nativeViewPtr, long columnIndex);
     private native double nativeAverageDouble(long nativePtr, long columnIndex);
-    private native Long nativeMaximumDate(long nativePtr, long columnIndex);
-    private native Long nativeMinimumDate(long nativePtr, long columnIndex);
+    private native Long nativeMaximumTimestamp(long nativePtr, long columnIndex);
+    private native Long nativeMinimumTimestamp(long nativePtr, long columnIndex);
     private native void nativeSort(long nativeTableViewPtr, long columnIndex, boolean sortOrder);
     private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
     private native long createNativeTableView(Table table, long nativeTablePtr);
     private native String nativeToJson(long nativeViewPtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
     private native long nativeWhere(long nativeViewPtr);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
-    private native long nativeDistinct(long nativeViewPtr, long columnIndex);
+    private native void nativeDistinct(long nativeViewPtr, long columnIndex);
     private native long nativeSyncIfNeeded(long nativeTablePtr);
-    private native long nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
+    private native void nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
     private native long nativeSync(long nativeTablePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index f692f90432..d2d012f466 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -145,7 +145,7 @@ public double getDouble(long columnIndex) {
 
     @Override
     public Date getDate(long columnIndex) {
-        return new Date(nativeGetDateTime(nativePointer, columnIndex)*1000);
+        return new Date(nativeGetTimestamp(nativePointer, columnIndex));
     }
 
     @Override
@@ -158,16 +158,6 @@ public String getString(long columnIndex) {
         return nativeGetByteArray(nativePointer, columnIndex);
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex) {
-        return nativeGetMixed(nativePointer, columnIndex);
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePointer, columnIndex));
-    }
-
     @Override
     public long getLink(long columnIndex) {
         return nativeGetLink(nativePointer, columnIndex);
@@ -217,8 +207,8 @@ public void setDate(long columnIndex, Date date) {
         if (date == null) {
             throw new IllegalArgumentException("Null Date is not allowed.");
         }
-        long timestamp = date.getTime() / 1000;
-        nativeSetDate(nativePointer, columnIndex, timestamp);
+        long timestamp = date.getTime();
+        nativeSetTimestamp(nativePointer, columnIndex, timestamp);
     }
 
     /**
@@ -245,15 +235,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
         nativeSetByteArray(nativePointer, columnIndex, data);
     }
 
-    @Override
-    public void setMixed(long columnIndex, Mixed data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null data is not allowed");
-        }
-        nativeSetMixed(nativePointer, columnIndex, data);
-    }
-
     @Override
     public void setLink(long columnIndex, long value) {
         parent.checkImmutable();
@@ -311,22 +292,19 @@ public boolean hasColumn(String fieldName) {
     protected native boolean nativeGetBoolean(long nativeRowPtr, long columnIndex);
     protected native float nativeGetFloat(long nativeRowPtr, long columnIndex);
     protected native double nativeGetDouble(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetDateTime(long nativeRowPtr, long columnIndex);
+    protected native long nativeGetTimestamp(long nativeRowPtr, long columnIndex);
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
     protected native long nativeGetLink(long nativeRowPtr, long columnIndex);
     protected native void nativeSetDouble(long nativeRowPtr, long columnIndex, double value);
-    protected native void nativeSetDate(long nativeRowPtr, long columnIndex, long dateTimeValue);
+    protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
     static native void nativeClose(long nativeRowPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 1f075b5110..8d24bfe3b1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -67,7 +67,8 @@ public static String getTablePrefix() {
         Exception_RowInvalid(13),
         Exception_EncryptionNotSupported(14),
         Exception_CrossTableLink(15),
-        Exception_BadVersion(16);
+        Exception_BadVersion(16),
+        Exception_IncompatibleLockFile(17);
 
         private final int nativeTestcase;
         Testcase(int nativeValue) {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index c2558fca93..a7be9d941b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -26,6 +26,7 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmResults;
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SharedGroup;
 import io.realm.internal.Table;
@@ -100,8 +101,17 @@ public void run() {
                 handler.obtainMessage(message, result).sendToTarget();
             }
 
-        } catch (Exception e) {
+        } catch (BadVersionException e) {
+            // In some rare race conditions, this can happen. In that case, just ignore the error.
+            RealmLog.d("Query update task could not complete due to a BadVersionException. " +
+                    "Retry is scheduled by a REALM_CHANGED event.");
+
+        } catch (Throwable e) {
             RealmLog.e(e.getMessage(), e);
+            Handler handler = callerHandler.get();
+            if (handler != null && handler.getLooper().getThread().isAlive()) {
+                handler.obtainMessage(HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e)).sendToTarget();
+            }
 
         } finally {
             if (sharedGroup != null) {
@@ -211,7 +221,7 @@ private boolean isAliveHandler(Handler handler) {
 
         public static Result newRealmResultsResponse() {
             Result result = new Result();
-            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<?>>, Long>(1);
+            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long>(1);
             return result;
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 24246f1526..482cbdc1b6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -24,6 +24,8 @@
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
+import io.realm.Realm;
+
 /**
  * Custom thread pool settings, instances of this executor can be paused, and resumed, this will also set
  * appropriate number of Threads & wrap submitted tasks to set the thread priority according to
@@ -59,19 +61,46 @@ private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
                 new ArrayBlockingQueue<Runnable>(QUEUE_SIZE));
     }
 
-    @Override
-    public Future<?> submit(Runnable task) {
+    /**
+     * Submits a runnable for executing a transaction.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitTransaction(Runnable task) {
+        Future<?> future = super.submit(new BgPriorityRunnable(task));
+        return future;
+    }
+
+    /**
+     * Submits a runnable for updating a query.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitQueryUpdate(Runnable task) {
         return super.submit(new BgPriorityRunnable(task));
     }
 
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
+    /**
+     * Submits a runnable for executing a query.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public <T> Future<T> submitQuery(Callable<T> task) {
         return super.submit(new BgPriorityCallable<T>(task));
     }
 
+    /**
+     * Method invoked prior to executing the given Runnable to pause execution of the thread.
+     *
+     * @param t the thread that will run task r
+     * @param r the task that will be executed
+     */
     @Override
     protected void beforeExecute(Thread t, Runnable r) {
-            super.beforeExecute(t, r);
+        super.beforeExecute(t, r);
         pauseLock.lock();
         try {
             while (isPaused) unpaused.await();
@@ -94,6 +123,9 @@ public void pause() {
         }
     }
 
+    /**
+     * Resume executing any scheduled tasks.
+     */
     public void resume() {
         pauseLock.lock();
         try {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index cfe7ba1198..662f8f732f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -22,6 +22,7 @@
 import org.json.JSONObject;
 
 import java.io.IOException;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -97,6 +98,30 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         return mediator.copyOrUpdate(realm, object, update, cache);
     }
 
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        mediator.insert(realm, object, cache);
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(Util.getOriginalModelClass(objects.iterator().next().getClass())));
+        mediator.insert(realm, objects);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        mediator.insertOrUpdate(realm, object, cache);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(Util.getOriginalModelClass(objects.iterator().next().getClass())));
+        mediator.insertOrUpdate(realm, objects);
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         RealmProxyMediator mediator = getMediator(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index ed5122e3e9..8d233a3e91 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -113,6 +113,30 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         return originalMediator.copyOrUpdate(realm, object, update, cache);
     }
 
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        originalMediator.insert(realm, object, cache);
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        checkSchemaHasClass(Util.getOriginalModelClass(objects.iterator().next().getClass()));
+        originalMediator.insert(realm, objects);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        originalMediator.insertOrUpdate(realm, object, cache);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        checkSchemaHasClass(Util.getOriginalModelClass(objects.iterator().next().getClass()));
+        originalMediator.insertOrUpdate(realm, objects);
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         checkSchemaHasClass(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 74d5a2b4bf..285388bbc8 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -70,9 +70,9 @@ public void call(final Subscriber<? super Realm> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(Realm realm) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(observableRealm);
                         }
@@ -100,9 +100,9 @@ public void call(final Subscriber<? super DynamicRealm> subscriber) {
                 // Get instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<DynamicRealm> listener = new RealmChangeListener<DynamicRealm>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(DynamicRealm realm) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(observableRealm);
                         }
@@ -136,9 +136,9 @@ public void call(final Subscriber<? super RealmResults<E>> subscriber) {
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(RealmResults<E> result) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(results);
                         }
@@ -172,9 +172,9 @@ public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subs
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<RealmResults<DynamicRealmObject>> listener = new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(RealmResults<DynamicRealmObject> result) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(results);
                         }
@@ -222,9 +222,9 @@ public void call(final Subscriber<? super E> subscriber) {
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<E> listener = new RealmChangeListener<E>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(E object) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(object);
                         }
@@ -258,9 +258,9 @@ public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
 
-                final RealmChangeListener listener = new RealmChangeListener() {
+                final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() {
                     @Override
-                    public void onChange() {
+                    public void onChange(DynamicRealmObject object) {
                         if (!subscriber.isUnsubscribed()) {
                             subscriber.onNext(object);
                         }
diff --git a/version.txt b/version.txt
index c51cb6d0c7..468e6c357b 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.90.0-SNAPSHOT
+1.2.0-SNAPSHOT
