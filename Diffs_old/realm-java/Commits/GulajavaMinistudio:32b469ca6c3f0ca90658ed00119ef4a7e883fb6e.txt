diff --git a/CHANGELOG.md b/CHANGELOG.md
index f03336384a..3aefb83c90 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,42 +1,53 @@
-## 3.4.0 (YYYY-MM-DD)
+## 3.5.0 (YYYY-MM-DD)
 
 ### Breaking Changes
 
-* [ObjectServer] Updated protocol version to 18 which is only compatible with ROS > 1.6.0.
+### Deprecated
 
 ### Enhancements
 
-* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
-* [ObjectServer] Added `SyncSession.getState()` (#4784).
-* Added support for querying inverse relationships (#2904).
-* Moved inverse relationships out of beta stage.
-* Added `Realm.getDefaultConfiguration()` (#4725).
-
 ### Bug Fixes
 
 ### Internal
 
-* Upgraded to Realm Sync 1.10.1
-* Upgraded to Realm Core 2.8.4
-
 ### Credits
 
-* Thanks to Anis Ben Nsir (@abennsir) for upgrading Roboelectric in the unitTestExample (#4698).
 
-## 3.3.3 (YYYY-MM-DD)
+## 3.4.0 (2017-06-22)
 
 ### Breaking Changes
 
+* [ObjectServer] Updated protocol version to 18 which is only compatible with ROS > 1.6.0.
+
+### Deprecated
+
+* `RealmSchema.close()` and `RealmObjectSchema.close()`. They don't need to be closed manually. They were added to the public API by mistake.
+
 ### Enhancements
 
+* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
+* [ObjectServer] Added `SyncSession.getState()` (#4784).
+* Added support for querying inverse relationships (#2904).
+* Moved inverse relationships out of beta stage.
+* Added `Realm.getDefaultConfiguration()` (#4725).
+
 ### Bug Fixes
 
+* [ObjectServer] Fixed a bug which may crash when the JNI local reference limitation was reached on sync client thread.
+* [ObjectServer] Retrying connections with exponential backoff, when encountering `ConnectException` (#4310).
 * When converting nullable BLOB field to required, `null` values should be converted to `byte[0]` instead of `byte[1]`.
 * Fixed a bug which may cause duplicated primary key values when migrating a nullable primary key field to not nullable. `RealmObjectSchema.setRequired()` and `RealmObjectSchema.setNullable()` will throw when converting a nullable primary key field with null values stored to a required primary key field.
-* [ObjectServer] Retrying connections with exponential backoff, when encountering `ConnectException` (#4310).
 
 ### Internal
 
+* Upgraded to Realm Sync 1.10.1
+* Upgraded to Realm Core 2.8.4
+
+### Credits
+
+* Thanks to Anis Ben Nsir (@abennsir) for upgrading Roboelectric in the unitTestExample (#4698).
+
+
 ## 3.3.2 (2017-06-09)
 
 ### Bug Fixes
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 4caa6d94c1..12223436d2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -735,6 +735,7 @@ public void findFirstAsync_twoListenersOnSameInvalidObjectsCauseNPE() {
         final Realm realm = looperThread.getRealm();
         final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
         final AtomicBoolean firstListenerCalled = new AtomicBoolean(false);
+        looperThread.keepStrongReference(allTypes);
 
         allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
index a44043f00b..1eaeee2ba7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
@@ -17,17 +17,24 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import io.realm.Realm;
 import io.realm.RealmFieldType;
 
-public class JNIColumnInfoTest extends TestCase {
+import static junit.framework.TestCase.assertEquals;
+
+
+@RunWith(AndroidJUnit4.class)
+public class JNIColumnInfoTest {
 
     Table table;
 
-    @Override
+    @Before
     public void setUp() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
         table = new Table();
@@ -35,7 +42,8 @@ public void setUp() {
         table.addColumn(RealmFieldType.STRING, "lastName");
     }
 
-    public void testShouldGetColumnInformation() {
+    @Test
+    public void shouldGetColumnInformation() {
 
         assertEquals(2, table.getColumnCount());
 
@@ -47,7 +55,8 @@ public void testShouldGetColumnInformation() {
 
     }
 
-    public void testValidateColumnInfo() {
+    @Test
+    public void validateColumnInfo() {
 
         assertEquals(2, table.getColumnCount());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index ce7de91091..d77bf67ecd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -17,8 +17,11 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 import java.util.concurrent.TimeUnit;
@@ -28,15 +31,19 @@
 import io.realm.RealmFieldType;
 import io.realm.TestHelper;
 
-public class JNIQueryTest extends TestCase {
+import static junit.framework.TestCase.assertEquals;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class JNIQueryTest {
 
     private Table table;
     private final long[] oneNullTable = new long[]{NativeObject.NULLPTR};
 
 
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
+    @Before
+    public void setUp() throws Exception {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
     }
 
@@ -54,7 +61,8 @@ private void init() {
         assertEquals(6, table.size());
     }
 
-    public void testShouldQuery() {
+    @Test
+    public void shouldQuery() {
         init();
         TableQuery query = table.where();
 
@@ -77,7 +85,8 @@ public void testShouldQuery() {
     }
 
 
-    public void testNonCompleteQuery() {
+    @Test
+    public void nonCompleteQuery() {
         init();
 
         // All the following queries are not valid, e.g contain a group but not a closing group, an or() but not a second filter etc
@@ -101,7 +110,8 @@ public void testNonCompleteQuery() {
         try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
     }
 
-    public void testInvalidColumnIndexEqualTo() {
+    @Test
+    public void invalidColumnIndexEqualTo() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -147,7 +157,8 @@ public void testInvalidColumnIndexEqualTo() {
         try { query.equalTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testInvalidColumnIndexNotEqualTo() {
+    @Test
+    public void invalidColumnIndexNotEqualTo() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -189,8 +200,8 @@ public void testInvalidColumnIndexNotEqualTo() {
         try { query.notEqualTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexGreaterThan() {
+    @Test
+    public void invalidColumnIndexGreaterThan() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -216,8 +227,8 @@ public void testInvalidColumnIndexGreaterThan() {
         try { query.greaterThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexGreaterThanOrEqual() {
+    @Test
+    public void invalidColumnIndexGreaterThanOrEqual() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -243,8 +254,8 @@ public void testInvalidColumnIndexGreaterThanOrEqual() {
         try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexLessThan() {
+    @Test
+    public void invalidColumnIndexLessThan() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -270,7 +281,8 @@ public void testInvalidColumnIndexLessThan() {
         try { query.lessThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testInvalidColumnIndexLessThanOrEqual() {
+    @Test
+    public void invalidColumnIndexLessThanOrEqual() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -296,8 +308,8 @@ public void testInvalidColumnIndexLessThanOrEqual() {
         try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexBetween() {
+    @Test
+    public void invalidColumnIndexBetween() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -323,8 +335,8 @@ public void testInvalidColumnIndexBetween() {
         try { query.between(new long[]{10}, 1, 10); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexContains() {
+    @Test
+    public void invalidColumnIndexContains() {
         Table table = TestHelper.getTableWithAllColumnTypes();
         TableQuery query = table.where();
 
@@ -345,7 +357,8 @@ public void testInvalidColumnIndexContains() {
     }
 
     @SuppressWarnings("ConstantConditions")
-    public void testNullInputQuery() {
+    @Test
+    public void nullInputQuery() {
         Table t = new Table();
         t.addColumn(RealmFieldType.DATE, "dateCol");
         t.addColumn(RealmFieldType.STRING, "stringCol");
@@ -376,9 +389,8 @@ public void testNullInputQuery() {
         try { t.where().like(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException ignore) { }
     }
 
-
-
-    public void testShouldFind() {
+    @Test
+    public void shouldFind() {
         // Creates a table.
         Table table = new Table();
 
@@ -420,9 +432,8 @@ public void testShouldFind() {
         try {  query.find(7);  fail("Exception expected");  } catch (ArrayIndexOutOfBoundsException ignore) {  }
     }
 
-
-
-    public void testQueryTestForNoMatches() {
+    @Test
+    public void queryTestForNoMatches() {
         Table t = TestHelper.getTableWithAllColumnTypes();
 
         t.add(new byte[]{1,2,3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
@@ -433,9 +444,8 @@ public void testQueryTestForNoMatches() {
         assertEquals(-1, q.find(1));
     }
 
-
-
-    public void testQueryWithWrongDataType() {
+    @Test
+    public void queryWithWrongDataType() {
 
         Table table = TestHelper.getTableWithAllColumnTypes();
 
@@ -516,8 +526,8 @@ public void testQueryWithWrongDataType() {
         */
     }
 
-
-    public void testColumnIndexOutOfBounds() {
+    @Test
+    public void columnIndexOutOfBounds() {
         Table table = TestHelper.getTableWithAllColumnTypes();
 
         // Queries the table.
@@ -617,7 +627,8 @@ public void testColumnIndexOutOfBounds() {
         try { query.equalTo(new long[]{7}, oneNullTable, true);                     fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testMaximumDate() {
+    @Test
+    public void maximumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -629,8 +640,8 @@ public void testMaximumDate() {
         assertEquals(new Date(10000), table.where().maximumDate(0));
     }
 
-
-    public void testMinimumDate() {
+    @Test
+    public void minimumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -642,7 +653,8 @@ public void testMinimumDate() {
         assertEquals(new Date(0), table.where().minimumDate(0));
     }
 
-    public void testDateQuery() throws Exception {
+    @Test
+    public void dateQuery() throws Exception {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -740,7 +752,8 @@ public void testDateQuery() throws Exception {
         assertEquals(1L, table.where().between(new long[]{0}, distantFuture, distantFuture).count());
     }
 
-    public void testByteArrayQuery() throws Exception {
+    @Test
+    public void byteArrayQuery() throws Exception {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.BINARY, "binary");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 3d8902ea90..12258cb24e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -16,17 +16,27 @@
 
 package io.realm.internal;
 
+import android.support.test.runner.AndroidJUnit4;
 import android.test.MoreAsserts;
 
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 
 import io.realm.RealmFieldType;
 
-public class JNIRowTest extends TestCase {
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
 
-    public void testRow() {
+
+@RunWith(AndroidJUnit4.class)
+public class JNIRowTest {
+
+    @Test
+    public void nonNullValues() {
 
         Table table = new Table();
 
@@ -74,7 +84,8 @@ public void testRow() {
         MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
     }
 
-    public void testNull() {
+    @Test
+    public void nullValues() {
 
         Table table = new Table();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
index 6c14e963b4..4145a51749 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
@@ -17,13 +17,19 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import io.realm.Realm;
 import io.realm.RealmFieldType;
 
-public class JNISortedLongTest extends TestCase {
+import static org.junit.Assert.assertEquals;
+
+
+@RunWith(AndroidJUnit4.class)
+public class JNISortedLongTest {
     Table table;
 
     void init() {
@@ -44,7 +50,8 @@ void init() {
         assertEquals(8, table.size());
     }
 
-    public void testShouldTestSortedIntTable() {
+    @Test
+    public void shouldTestSortedIntTable() {
         init();
 
         // Before first entry.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
index 67006b5592..574fcb43c3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
@@ -17,21 +17,29 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import io.realm.Realm;
 import io.realm.RealmFieldType;
 import io.realm.internal.Table.PivotType;
 
-public class PivotTest extends TestCase {
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class PivotTest {
 
     Table t;
     long colIndexSex;
     long colIndexAge;
     long colIndexHired;
 
-    @Override
+    @Before
     public void setUp() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
         t = new Table();
@@ -45,7 +53,8 @@ public void setUp() {
         }
     }
 
-    public void testPivotTable(){
+    @Test
+    public void pivotTable(){
 
         Table resultCount = t.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
         assertEquals(2, resultCount.size());
@@ -60,7 +69,7 @@ public void testPivotTable(){
         assertEquals(38, resultMax.getLong(1, 0));
         assertEquals(39, resultMax.getLong(1, 1));
 
-        try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
-        try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
+        try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException ignore) { }
+        try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException ignore) { }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index 041c45ced3..fe4fb16267 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -16,11 +16,18 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import io.realm.RealmFieldType;
 
-public class TableIndexAndDistinctTest extends TestCase {
+import static org.junit.Assert.assertEquals;
+
+
+@RunWith(AndroidJUnit4.class)
+public class TableIndexAndDistinctTest {
     Table table;
 
     void init() {
@@ -43,7 +50,8 @@ void init() {
      * Checks that Index can be set on multiple columns, with the String.
      * @param
      */
-    public void testShouldTestSettingIndexOnMultipleColumns() {
+    @Test
+    public void shouldTestSettingIndexOnMultipleColumns() {
 
         // Creates a table only with String type columns
         Table t = new Table();
@@ -85,12 +93,14 @@ public void shouldTestIndexOnWrongColumnType(Long index) {
         t.addSearchIndex(index);
     }*/
 
-    public void testShouldCheckIndexIsOkOnColumn() {
+    @Test
+    public void shouldCheckIndexIsOkOnColumn() {
         init();
         table.addSearchIndex(1);
     }
 
-    public void testRemoveSearchIndex() {
+    @Test
+    public void removeSearchIndex() {
         init();
         table.addSearchIndex(1);
         assertEquals(true, table.hasSearchIndex(1));
@@ -99,7 +109,8 @@ public void testRemoveSearchIndex() {
         assertEquals(false, table.hasSearchIndex(1));
     }
 
-    public void testRemoveSearchIndexNoop() {
+    @Test
+    public void removeSearchIndexNoOp() {
         init();
         assertEquals(false, table.hasSearchIndex(1));
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 8a132d05ea..5dde2c61e5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -24,6 +24,7 @@
 
 #include "util.hpp"
 #include "jni_util/java_global_ref.hpp"
+#include "jni_util/java_local_ref.hpp"
 #include "jni_util/java_method.hpp"
 #include "jni_util/java_class.hpp"
 #include "jni_util/jni_utils.hpp"
@@ -98,9 +99,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIE
             uint64_t transferred, uint64_t transferrable) {
             JNIEnv* local_env = jni_util::JniUtils::get_env(true);
 
-            auto path = to_jstring(local_env, local_realm_path);
-            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path, listener_id,
-                                            static_cast<jlong>(transferred), static_cast<jlong>(transferrable));
+            JavaLocalRef<jstring> path(local_env, to_jstring(local_env, local_realm_path));
+            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path.get(),
+                                            listener_id, static_cast<jlong>(transferred),
+                                            static_cast<jlong>(transferrable));
 
             // All exceptions will be caught on the Java side of handlers, but Errors will still end
             // up here, so we need to do something sensible with them.
@@ -111,10 +113,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIE
                 local_env->ExceptionDescribe();
                 throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
             }
-
-            // Callback happens on a thread not controlled by the JVM. So manual cleanup is
-            // required.
-            local_env->DeleteLocalRef(path);
         };
         uint64_t token = session->register_progress_notifier(callback, type, to_bool(is_streaming));
         return static_cast<jlong>(token);
@@ -155,14 +153,14 @@ JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadComple
             bool listener_registered =
                 session->wait_for_download_completion([java_session_object_ref](std::error_code error) {
                     JNIEnv* env = JniUtils::get_env(true);
-                    jobject java_error_code = nullptr;
-                    jstring java_error_message = nullptr;
+                    JavaLocalRef<jobject> java_error_code;
+                    JavaLocalRef<jstring> java_error_message;
                     if (error != std::error_code{}) {
-                        java_error_code = NewLong(env, error.value());
-                        java_error_message = env->NewStringUTF(error.message().c_str());
+                        java_error_code = JavaLocalRef<jobject>(env, NewLong(env, error.value()));
+                        java_error_message = JavaLocalRef<jstring>(env, env->NewStringUTF(error.message().c_str()));
                     }
-                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method, java_error_code,
-                                        java_error_message);
+                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method, java_error_code.get(),
+                                        java_error_message.get());
                 });
 
             return to_jbool(listener_registered);
@@ -197,4 +195,4 @@ JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jc
     }
     CATCH_STD()
     return -1;
-}
\ No newline at end of file
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 4a57062471..0417887449 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -33,17 +33,22 @@ static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 template <typename T>
 class JavaLocalRef {
 public:
-    // need_to_create is useful when acquire a local ref from a global weak ref.
+    inline JavaLocalRef() noexcept
+        : m_jobject(nullptr)
+        , m_env(nullptr){};
     inline JavaLocalRef(JNIEnv* env, T obj) noexcept
         : m_jobject(obj)
         , m_env(env){};
+    // need_to_create is useful when acquire a local ref from a global weak ref.
     inline JavaLocalRef(JNIEnv* env, T obj, NeedToCreateLocalRef) noexcept
         : m_jobject(env->NewLocalRef(obj))
         , m_env(env){};
 
     inline ~JavaLocalRef()
     {
-        m_env->DeleteLocalRef(m_jobject);
+        if (m_jobject) {
+            m_env->DeleteLocalRef(m_jobject);
+        }
     }
 
     JavaLocalRef& operator=(JavaLocalRef&& rhs)
@@ -54,9 +59,11 @@ class JavaLocalRef {
     }
 
     inline JavaLocalRef(JavaLocalRef&& rhs)
-            : m_env(rhs.m_env), m_jobject(rhs.m_jobject)
+        : m_jobject(rhs.m_jobject)
+        , m_env(rhs.m_env)
     {
         rhs.m_jobject = nullptr;
+        rhs.m_env = nullptr;
     }
 
     inline operator bool() const noexcept
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index f0a029fac9..106d97b4a1 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -42,8 +42,9 @@ protected RealmObjectSchema(RealmSchema schema) {
     }
 
     /**
-     * Release the object schema and any of native resources it might hold.
+     * @deprecated {@link RealmObjectSchema} doesn't have to be released manually.
      */
+    @Deprecated
     public abstract void close();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index cc7a15bbdb..17049602d4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -37,8 +37,9 @@
     private ColumnIndices columnIndices; // Cached field look up
 
     /**
-     * Release the schema and any of native resources it might hold.
+     * @deprecated {@link RealmSchema} doesn't have to be released manually.
      */
+    @Deprecated
     public abstract void close();
 
     /**
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index e83815efe0..23ab53ade8 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -12,12 +12,12 @@ RUN apt-get update -qq \
 RUN npm init -y
 RUN npm install winston temp httpdispatcher@1.0.0
 
-COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
-COPY ros-testing-server.js /usr/bin/
-
 # Install realm object server
 RUN apt-get update -qq \
     && apt-get install -y realm-object-server-developer=$ROS_DE_VERSION \
     && apt-get clean
 
+COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
+COPY ros-testing-server.js /usr/bin/
+
 CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
index d9a350fc00..e3440d05bb 100644
--- a/tools/sync_test_server/configuration.yml
+++ b/tools/sync_test_server/configuration.yml
@@ -154,7 +154,7 @@ proxy:
     ## The address/interface on which the HTTP proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    listen_address: '::'
+    listen_address: '0.0.0.0'
 
     ## The port that the HTTP proxy module should bind to.
     # listen_port: 9080
@@ -175,7 +175,7 @@ proxy:
     ## The address/interface on which the HTTPS proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    listen_address: '::'
+    listen_address: '0.0.0.0'
 
     ## The port that the HTTPS proxy module should bind to.
     listen_port: 9443
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index ae43a8477a..ca7163c46e 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -33,7 +33,13 @@ function handleRequest(request, response) {
 
 var syncServerChildProcess = null;
 
-function startRealmObjectServer() {
+function startRealmObjectServer(done) {
+    // Hack for checking the ROS is fully initialized.
+    // Consider the ROS is initialized fully only if log below shows twice
+    // "client: Closing Realm file: /tmp/ros117521-7-1eiqt7a/internal_data/permission/__auth.realm"
+    // https://github.com/realm/realm-object-server/issues/1297
+    var logFindingCounter = 2
+
     stopRealmObjectServer();
     temp.mkdir('ros', function(err, path) {
         if (!err) {
@@ -44,9 +50,15 @@ function startRealmObjectServer() {
             syncServerChildProcess = spawn('realm-object-server',
                     ['--root', path,
                     '--configuration', '/configuration.yml'],
-                    { env: env });
+                    { env: env});
             // local config:
             syncServerChildProcess.stdout.on('data', (data) => {
+                if (logFindingCounter != 0 && /client: Closing Realm file: .*__auth.realm/.test(data)) {
+                    if (logFindingCounter == 1) {
+                        done()
+                    }
+                    logFindingCounter--
+                }
                 winston.info(`stdout: ${data}`);
             });
 
@@ -75,11 +87,13 @@ function stopRealmObjectServer() {
     }
 }
 
+
 // start sync server
 dispatcher.onGet("/start", function(req, res) {
-    startRealmObjectServer();
-    res.writeHead(200, {'Content-Type': 'text/plain'});
-    res.end('Starting a server');
+    startRealmObjectServer(() => {
+        res.writeHead(200, {'Content-Type': 'text/plain'});
+        res.end('Starting a server');
+    })
 });
 
 // stop a previously started sync server
diff --git a/version.txt b/version.txt
index 6b970ae4c3..b9821b826b 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.4.0-SNAPSHOT
+3.5.0-SNAPSHOT
\ No newline at end of file
